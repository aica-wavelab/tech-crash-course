var lge=Object.defineProperty;var cge=(n,e,t)=>e in n?lge(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var zt=(n,e,t)=>(cge(n,typeof e!="symbol"?e+"":e,t),t);function uge(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const i=Object.getOwnPropertyDescriptor(r,s);i&&Object.defineProperty(n,s,i.get?i:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hge=1e-7,fge=1e-4;class dM{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}let V_=class{refCount(e){return Pa("refCount")}incRef(e){return Pa("incRef")}timerAvailable(){return!0}time(e){return Pa("time")}read(e){return Pa("read")}readSync(e){return Pa("readSync")}readToGPU(e,t){return Pa("readToGPU")}numDataIds(){return Pa("numDataIds")}disposeData(e,t){return Pa("disposeData")}write(e,t,r){return Pa("write")}move(e,t,r,s,i){return Pa("move")}createTensorFromGPUData(e,t,r){return Pa("createTensorFromGPUData")}memory(){return Pa("memory")}floatPrecision(){return Pa("floatPrecision")}epsilon(){return this.floatPrecision()===32?hge:fge}dispose(){return Pa("dispose")}};function Pa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yL(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Cf(n,e,t)}function dge(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Cf(n,t,r),Cf(e,t,r)}function Zd(n,e,t){return Math.max(n,Math.min(e,t))}function pM(n){return n%2===0?n:n+1}function Cf(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function bL(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function pge(n,e){const t=Math.random();return e*t+(1-t)*n}function mge(n,e){let t=0;for(let r=0;r<n.length;r++){const s=Number(n[r])-Number(e[r]);t+=s*s}return t}function U(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function ji(n,e,t=""){U(Mn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function $g(n){U(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Te(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function tD(n){return n.length===0}function z7(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Mn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function eg(n){return n%1===0}function gge(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function pI(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function yge(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return yL(e),e}function Um(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function nD(n,e=s=>0,t,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n()){s();return}o++;const l=e(o);if(t!=null&&o>=t){i();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function mM(n,e){let t=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function Tn(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),U(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),U(n.every(r=>eg(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Bf(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:Tn(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function li(n,e){return Cs(n,e)}function Cs(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function B7(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function V7(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function gM(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function lS(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function U7(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function uu(n){return typeof n=="string"||n instanceof String}function W7(n){return typeof n=="boolean"}function mI(n){return typeof n=="number"}function xp(n){return Array.isArray(n)?xp(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":mI(n)?"float32":uu(n)?"string":W7(n)?"bool":"float32"}function Jd(n){return!!(n&&n.constructor&&n.call&&n.apply)}function gI(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Jt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function G7(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=G7(n+l*a,o,t,r)}return s}function El(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return G7(0,n,e,t)}function H1(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function yM(n,e){const t=Hi(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Hi(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function vL(n,e){const t=n.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return El(n,new Float32Array(t));if(e==="int32")return El(n,new Int32Array(t));if(e==="bool")return El(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Za(n){n.forEach(e=>{U(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function mu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function Rg(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function Qd(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VW="tfjsflags";let H7=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bge,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Qd(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);VW in e&&e[VW].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=wge(s,i)})}};function bge(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(vge(e,r[0],r[1]),r.join("="))),e}function vge(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function wge(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ee(){return wL}let wL=null;function xge(n){wL=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YR;function j7(){if(YR==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");YR=n}return YR}function Sge(){const n=j7();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function xL(n,e){const t=Sge();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const _v="Abs",Pg="Acos",Dg="Acosh",Sp="Add",Cv="AddN",U_="All",W_="Any",kv="ArgMax",Tv="ArgMin",Og="Asin",Fg="Asinh",Lg="Atan",zg="Atanh",Bg="Atan2",Ev="AvgPool",G_="AvgPoolGrad",Iv="AvgPool3D",H_="AvgPool3DGrad",Av="BatchMatMul",Mv="BatchToSpaceND",j_="Bincount",q_="BitwiseAnd",q7="BroadcastTo",X_="BroadcastArgs",Vg="Cast",Ug="Ceil",Wg="ClipByValue",K_="Complex",Nv="ComplexAbs",$v="Concat",Rv="Conv2D",Y_="Conv2DBackpropFilter",Pv="Conv2DBackpropInput",Dv="Conv3D",Z_="Conv3DBackpropFilterV2",J_="Conv3DBackpropInputV2",Gg="Cos",Hg="Cosh",Q_="Cumprod",Ov="Cumsum",e2="CropAndResize",t2="DenseBincount",n2="DepthToSpace",Fv="DepthwiseConv2dNative",r2="DepthwiseConv2dNativeBackpropFilter",s2="DepthwiseConv2dNativeBackpropInput",i2="Diag",Lv="Dilation2D",cS="Dilation2DBackpropInput",uS="Dilation2DBackpropFilter",o2="Draw",jg="RealDiv",a2="Einsum",qg="Elu",l2="EluGrad",Xg="Erf",zv="Equal",Kg="Exp",Bv="ExpandDims",Yg="Expm1",c2="FFT",u2="Fill",h2="FlipLeftRight",Zg="Floor",Jg="FloorDiv",Vv="FusedBatchNorm",Uv="GatherV2",f2="GatherNd",Wv="Greater",Qg="GreaterEqual",ey="Identity",d2="IFFT",p2="Imag",ty="IsFinite",ny="IsInf",ry="IsNan",Gv="LeakyRelu",Hv="Less",jv="LessEqual",m2="LinSpace",sy="Log",iy="Log1p",qv="LogicalAnd",Xv="LogicalNot",Kv="LogicalOr",_ge="LogicalXor",X7="LogSoftmax",Cge="LowerBound",Yv="LRN",g2="LRNGrad",kge="MatrixBandPart",Zv="Max",oy="Maximum",Jv="MaxPool",y2="MaxPoolGrad",Qv="MaxPool3D",b2="MaxPool3DGrad",v2="MaxPoolWithArgmax",ew="Mean",tw="Min",ay="Minimum",nw="MirrorPad",ly="Mod",w2="Multinomial",cy="Multiply",rw="Neg",sw="NotEqual",x2="NonMaxSuppressionV3",bM="NonMaxSuppressionV4",S2="NonMaxSuppressionV5",iw="OnesLike",ow="OneHot",aw="Pack",lw="PadV2",Tge="Pool",uy="Pow",cw="Prelu",uw="Prod",vM="RaggedGather",wM="RaggedRange",xM="RaggedTensorToTensor",_2="Range",C2="Real",hy="Reciprocal",fy="Relu",hw="Reshape",fw="ResizeNearestNeighbor",k2="ResizeNearestNeighborGrad",dw="ResizeBilinear",T2="ResizeBilinearGrad",dy="Relu6",pw="Reverse",py="Round",my="Rsqrt",E2="ScatterNd",I2="TensorScatterUpdate",A2="SearchSorted",mw="Select",gy="Selu",gw="Slice",yy="Sin",by="Sinh",vy="Sign",wy="Sigmoid",xy="Softplus",Sy="Sqrt",yw="Sum",bw="SpaceToBatchND",vw="SplitV",ww="Softmax",SM="SparseFillEmptyRows",_M="SparseReshape",M2="SparseSegmentMean",N2="SparseSegmentSum",$2="SparseToDense",_y="SquaredDifference",R2="Square",P2="StaticRegexReplace",D2="StridedSlice",O2="StringNGrams",CM="StringSplit",kM="StringToHashBucketFast",Cy="Sub",ky="Tan",Ty="Tanh",Ey="Tile",F2="TopK",L2="Transform",Bd="Transpose",TM="Unique",xw="Unpack",Sw="UnsortedSegmentSum",Ege="UpperBound",_w="ZerosLike",Iy="Step",hS="FromPixels",z2="RotateWithOffset",Lb="_FusedMatMul",zb="FusedConv2D",Bb="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(...n){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(...n)}function Ige(...n){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb=xL("kernelRegistry",()=>new Map),fS=xL("gradRegistry",()=>new Map);function dS(n,e){const t=SL(n,e);return Vb.get(t)}function rD(n){return fS.get(n)}function yI(n){const e=Vb.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function B2(n){const{kernelName:e,backendName:t}=n,r=SL(e,t);Vb.has(r)&&xl(`The kernel '${e}' for backend '${t}' is already registered`),Vb.set(r,n)}function K7(n){const{kernelName:e}=n;fS.has(e)&&Ee().getBool("DEBUG")&&xl(`Overriding the gradient for '${e}'`),fS.set(e,n)}function Age(n,e){const t=SL(n,e);if(!Vb.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Vb.delete(t)}function Mge(n){if(!fS.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);fS.delete(n)}function Nge(n,e){yI(n).forEach(r=>{const s=Object.assign({},r,{backendName:e});B2(s)})}function SL(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y7(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var mt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ay(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Vf(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}var Z7=as,dc=null;try{dc=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function as(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}as.prototype.__isLong__;Object.defineProperty(as.prototype,"__isLong__",{value:!0});function Ja(n){return(n&&n.__isLong__)===!0}as.isLong=Ja;var UW={},WW={};function My(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=WW[n],r)?r:(t=ls(n,(n|0)<0?-1:0,!0),s&&(WW[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=UW[n],r)?r:(t=ls(n,n<0?-1:0,!1),s&&(UW[n]=t),t))}as.fromInt=My;function pc(n,e){if(isNaN(n))return e?Pm:mc;if(e){if(n<0)return Pm;if(n>=J7)return tX}else{if(n<=-HW)return Va;if(n+1>=HW)return eX}return n<0?pc(-n,e).neg():ls(n%Ub|0,n/Ub|0,e)}as.fromNumber=pc;function ls(n,e,t){return new as(n,e,t)}as.fromBits=ls;var bI=Math.pow;function _L(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return mc;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return _L(n.substring(1),e,t).neg();for(var s=pc(bI(t,8)),i=mc,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=pc(bI(t,a));i=i.mul(c).add(pc(l))}else i=i.mul(s),i=i.add(pc(l))}return i.unsigned=e,i}as.fromString=_L;function Pu(n,e){return typeof n=="number"?pc(n,e):typeof n=="string"?_L(n,e):ls(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}as.fromValue=Pu;var GW=65536,$ge=1<<24,Ub=GW*GW,J7=Ub*Ub,HW=J7/2,jW=My($ge),mc=My(0);as.ZERO=mc;var Pm=My(0,!0);as.UZERO=Pm;var bb=My(1);as.ONE=bb;var Q7=My(1,!0);as.UONE=Q7;var sD=My(-1);as.NEG_ONE=sD;var eX=ls(-1,2147483647,!1);as.MAX_VALUE=eX;var tX=ls(-1,-1,!0);as.MAX_UNSIGNED_VALUE=tX;var Va=ls(0,-2147483648,!1);as.MIN_VALUE=Va;var It=as.prototype;It.toInt=function(){return this.unsigned?this.low>>>0:this.low};It.toNumber=function(){return this.unsigned?(this.high>>>0)*Ub+(this.low>>>0):this.high*Ub+(this.low>>>0)};It.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Va)){var t=pc(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=pc(bI(e,6),this.unsigned),o=this,a="";;){var l=o.div(i),c=o.sub(l.mul(i)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};It.getHighBits=function(){return this.high};It.getHighBitsUnsigned=function(){return this.high>>>0};It.getLowBits=function(){return this.low};It.getLowBitsUnsigned=function(){return this.low>>>0};It.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Va)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};It.isZero=function(){return this.high===0&&this.low===0};It.eqz=It.isZero;It.isNegative=function(){return!this.unsigned&&this.high<0};It.isPositive=function(){return this.unsigned||this.high>=0};It.isOdd=function(){return(this.low&1)===1};It.isEven=function(){return(this.low&1)===0};It.equals=function(e){return Ja(e)||(e=Pu(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};It.eq=It.equals;It.notEquals=function(e){return!this.eq(e)};It.neq=It.notEquals;It.ne=It.notEquals;It.lessThan=function(e){return this.comp(e)<0};It.lt=It.lessThan;It.lessThanOrEqual=function(e){return this.comp(e)<=0};It.lte=It.lessThanOrEqual;It.le=It.lessThanOrEqual;It.greaterThan=function(e){return this.comp(e)>0};It.gt=It.greaterThan;It.greaterThanOrEqual=function(e){return this.comp(e)>=0};It.gte=It.greaterThanOrEqual;It.ge=It.greaterThanOrEqual;It.compare=function(e){if(Ja(e)||(e=Pu(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};It.comp=It.compare;It.negate=function(){return!this.unsigned&&this.eq(Va)?Va:this.not().add(bb)};It.neg=It.negate;It.add=function(e){Ja(e)||(e=Pu(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,i=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,f=0,d=0;return d+=i+c,f+=d>>>16,d&=65535,f+=s+l,h+=f>>>16,f&=65535,h+=r+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,ls(f<<16|d,u<<16|h,this.unsigned)};It.subtract=function(e){return Ja(e)||(e=Pu(e)),this.add(e.neg())};It.sub=It.subtract;It.multiply=function(e){if(this.isZero())return mc;if(Ja(e)||(e=Pu(e)),dc){var t=dc.mul(this.low,this.high,e.low,e.high);return ls(t,dc.get_high(),this.unsigned)}if(e.isZero())return mc;if(this.eq(Va))return e.isOdd()?Va:mc;if(e.eq(Va))return this.isOdd()?Va:mc;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(jW)&&e.lt(jW))return pc(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,i=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,f=0,d=0,p=0;return p+=o*u,d+=p>>>16,p&=65535,d+=i*u,f+=d>>>16,d&=65535,d+=o*c,f+=d>>>16,d&=65535,f+=s*u,h+=f>>>16,f&=65535,f+=i*c,h+=f>>>16,f&=65535,f+=o*l,h+=f>>>16,f&=65535,h+=r*u+s*c+i*l+o*a,h&=65535,ls(d<<16|p,h<<16|f,this.unsigned)};It.mul=It.multiply;It.divide=function(e){if(Ja(e)||(e=Pu(e)),e.isZero())throw Error("division by zero");if(dc){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?dc.div_u:dc.div_s)(this.low,this.high,e.low,e.high);return ls(t,dc.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Pm:mc;var r,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Pm;if(e.gt(this.shru(1)))return Q7;i=Pm}else{if(this.eq(Va)){if(e.eq(bb)||e.eq(sD))return Va;if(e.eq(Va))return bb;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(mc)?e.isNegative()?bb:sD:(s=this.sub(e.mul(r)),i=r.add(s.div(e)),i)}else if(e.eq(Va))return this.unsigned?Pm:mc;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=mc}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:bI(2,a-48),c=pc(r),u=c.mul(e);u.isNegative()||u.gt(s);)r-=l,c=pc(r,this.unsigned),u=c.mul(e);c.isZero()&&(c=bb),i=i.add(c),s=s.sub(u)}return i};It.div=It.divide;It.modulo=function(e){if(Ja(e)||(e=Pu(e)),dc){var t=(this.unsigned?dc.rem_u:dc.rem_s)(this.low,this.high,e.low,e.high);return ls(t,dc.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};It.mod=It.modulo;It.rem=It.modulo;It.not=function(){return ls(~this.low,~this.high,this.unsigned)};It.and=function(e){return Ja(e)||(e=Pu(e)),ls(this.low&e.low,this.high&e.high,this.unsigned)};It.or=function(e){return Ja(e)||(e=Pu(e)),ls(this.low|e.low,this.high|e.high,this.unsigned)};It.xor=function(e){return Ja(e)||(e=Pu(e)),ls(this.low^e.low,this.high^e.high,this.unsigned)};It.shiftLeft=function(e){return Ja(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ls(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):ls(0,this.low<<e-32,this.unsigned)};It.shl=It.shiftLeft;It.shiftRight=function(e){return Ja(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ls(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):ls(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};It.shr=It.shiftRight;It.shiftRightUnsigned=function(e){if(Ja(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return ls(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?ls(t,0,this.unsigned):ls(t>>>e-32,0,this.unsigned)};It.shru=It.shiftRightUnsigned;It.shr_u=It.shiftRightUnsigned;It.toSigned=function(){return this.unsigned?ls(this.low,this.high,!1):this};It.toUnsigned=function(){return this.unsigned?this:ls(this.low,this.high,!0)};It.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};It.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};It.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};as.fromBytes=function(e,t,r){return r?as.fromBytesLE(e,t):as.fromBytesBE(e,t)};as.fromBytesLE=function(e,t){return new as(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};as.fromBytesBE=function(e,t){return new as(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const nX=Ay(Z7),Rge=uge({__proto__:null,default:nX},[Z7]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Em=nX||Rge;function V2(n){return Em.fromString(n,!0,16)}const rX=V2("c3a5c85c97cb3127"),ym=V2("b492b66fbe98f273"),zo=V2("9ae16a3b2f90404f");function iD(n){return n.xor(n.shru(47))}function sX(n,e,t){const r=n.slice(e,e+t);return Em.fromBytes(Array.from(r),!0,!0)}function Qr(n,e){return sX(n,e,8)}function qW(n,e){return sX(n,e,4)}function zi(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Vd(n,e,t=V2("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function Pge(n,e,t,r,s,i){s=s.add(n),i=zi(i.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(t),i=i.add(zi(s,44)),[s.add(r),i.add(o)]}function Bk(n,e,t,r){return Pge(Qr(n,e),Qr(n,e+8),Qr(n,e+16),Qr(n,e+24),t,r)}function Dge(n,e=n.length){if(e>=8){const t=zo.add(e*2),r=Qr(n,0).add(zo),s=Qr(n,e-8),i=zi(s,37).mul(t).add(r),o=zi(r,25).add(s).mul(t);return Vd(i,o,t)}if(e>=4){const t=zo.add(e*2),r=qW(n,0);return Vd(r.shl(3).add(e),qW(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],i=t+(r<<8),o=e+(s<<2);return iD(zo.mul(i).xor(rX.mul(o))).mul(zo)}return zo}function Oge(n,e=n.length){const t=zo.add(e*2),r=Qr(n,0).mul(ym),s=Qr(n,8),i=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(zo);return Vd(zi(r.add(s),43).add(zi(i,30)).add(o),r.add(zi(s.add(zo),18)).add(i),t)}function Fge(n,e=n.length){const t=zo.add(e*2),r=Qr(n,0).mul(zo),s=Qr(n,8),i=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(zo),a=zi(r.add(s),43).add(zi(i,30)).add(o),l=Vd(a,r.add(zi(s.add(zo),18)).add(i),t),c=Qr(n,16).mul(t),u=Qr(n,24),h=a.add(Qr(n,e-32)).mul(t),f=l.add(Qr(n,e-24)).mul(t);return Vd(zi(c.add(u),43).add(zi(h,30)).add(f),c.add(zi(u.add(r),18)).add(h),t)}function iX(n,e=n.length){const t=Em.fromNumber(81,!0);if(e<=32)return e<=16?Dge(n,e):Oge(n,e);if(e<=64)return Fge(n,e);let r=t,s=t.mul(ym).add(113),i=iD(s.mul(zo).add(113)).mul(zo),o=[Em.UZERO,Em.UZERO],a=[Em.UZERO,Em.UZERO];r=r.mul(zo).add(Qr(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do r=zi(r.add(s).add(o[0]).add(Qr(n,l+8)),37).mul(ym),s=zi(s.add(o[1]).add(Qr(n,l+48)),42).mul(ym),r=r.xor(a[1]),s=s.add(o[0]).add(Qr(n,l+40)),i=zi(i.add(a[0]),33).mul(ym),o=Bk(n,l,o[1].mul(ym),r.add(a[0])),a=Bk(n,l+32,i.add(a[1]),s.add(Qr(n,l+16))),[i,r]=[r,i],l+=64;while(l!==c);const h=ym.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=zi(r.add(s).add(o[0]).add(Qr(n,l+8)),37).mul(h),s=zi(s.add(o[1]).add(Qr(n,l+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(Qr(n,l+40))),i=zi(i.add(a[0]),33).mul(h),o=Bk(n,l,o[1].mul(h),r.add(a[0])),a=Bk(n,l+32,i.add(a[1]),s.add(Qr(n,l+16))),[i,r]=[r,i],Vd(Vd(o[0],a[0],h).add(iD(s).mul(rX)).add(i),Vd(o[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uf(n,e){return e==="string"?gu(n):_p([n],e)}function Lge(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function _p(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Tc(n)),Ee().getBool("DEBUG")&&B7(n,e),Lge(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function ro(){return Ee().platform.now()}function zge(n,e){return Ee().platform.fetch(n,e)}function gu(n,e="utf-8"){return e=e||"utf-8",Ee().platform.encode(n,e)}function kc(n,e="utf-8"){return e=e||"utf-8",Ee().platform.decode(n,e)}function wi(n){return Ee().platform.isTypedArray!=null?Ee().platform.isTypedArray(n):Y7(n)}function Tc(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Qd(n)||n==null||wi(n)&&t)e.push(n);else if(Array.isArray(n)||wi(n))for(let r=0;r<n.length;++r)Tc(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Tc(n[s],e,t)}return e}const Bge=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Mn,arraysEqualWithNull:z7,assert:U,assertNonNegativeIntegerDimensions:Za,assertNonNull:$g,assertShapesMatch:ji,bytesFromStringArray:U7,bytesPerElement:lS,checkConversionForErrors:B7,clamp:Zd,computeStrides:Jt,convertBackendValuesAndArrayBuffer:H1,createScalarValue:Uf,createShuffledIndices:yge,decodeString:kc,distSquared:mge,encodeString:gu,fetch:zge,fingerPrint64:iX,flatten:Tc,getArrayFromDType:Cs,getTypedArrayFromDType:li,hasEncodingLoss:gM,hexToLong:V2,indexToLoc:Rg,inferDtype:xp,inferFromImplicitShape:mM,isBoolean:W7,isFunction:Jd,isInt:eg,isNumber:mI,isPromise:Qd,isScalarShape:tD,isString:uu,isTypedArray:wi,isValidDtype:V7,locToIndex:mu,makeOnesTypedArray:yM,makeZerosNestedTypedArray:vL,makeZerosTypedArray:Hi,nearestDivisor:gI,nearestLargerEven:pM,now:ro,parseAxisParam:Tn,randUniform:pge,repeatedTry:nD,rightPad:Um,shuffle:yL,shuffleCombo:dge,sizeFromShape:Te,sizeToSquarishShape:pI,squeezeShape:Bf,sum:bL,swap:Cf,tanh:gge,toNestedArray:El,toTypedArray:_p},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vge=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Wge)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=ro();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:ro()-a})}if(Ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(h=>{Uge(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}};function Uge(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}let Wge=class{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?Um(`${s}ms`,9):s.error,l=Um(e,25),c=t.rank,u=t.size,h=Um(t.shape.toString(),14);let f="";for(const d in i){const p=i[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gge(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const f in u)i[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function Hge(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Mn(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XW=20,Lx=3,ZR=7;function jge(n,e,t,r){const s=Jt(e),i=qge(n,e,t,s),o=e.length,a=AE(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function qge(n,e,t,r){const s=Te(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?b1(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],y1(l[u+h],0,t).length)}return o}function y1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(ZR))} + ${parseFloat(n[1].toFixed(ZR))}j`:uu(n)?r=`'${n}'`:t==="bool"?r=oX(n):r=parseFloat(n.toFixed(ZR)).toString(),Um(r,e)}function oX(n){return n===0?"false":"true"}function AE(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=b1(n);return[y1(m[0],0,t)]}return t==="bool"?[oX(n[0])]:[n[0].toString()]}if(l===1){if(a>XW){const g=Lx*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-Lx)*o,a*o));return t==="complex64"&&(y=b1(y),b=b1(b)),["["+y.map((x,w)=>y1(x,s[w],t)).join(", ")+", ..., "+b.map((x,w)=>y1(x,s[a-Lx+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?b1(n):Array.from(n)).map((g,y)=>y1(g,s[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>XW){for(let m=0;m<Lx;m++){const g=m*h,y=g+h;f.push(...AE(n.slice(g,y),c,t,u,s,!1))}f.push("...");for(let m=a-Lx;m<a;m++){const g=m*h,y=g+h;f.push(...AE(n.slice(g,y),c,t,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...AE(n.slice(g,y),c,t,u,s,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":p),f}function b1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ai{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Te(e),r!=null){const s=r.length;U(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Cs(t,this.size),this.strides=Jt(e)}set(e,...t){t.length===0&&(t=[0]),U(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return iu().makeTensor(this.values,this.shape,this.dtype)}}let iu=null,lb=null;function Xge(n){iu=n}function Kge(n){lb=n}let qn=class{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Te(e),this.strides=Jt(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return lb.buffer(this.shape,this.dtype,e)}bufferSync(){return lb.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return El(this.shape,e,this.dtype==="complex64")}arraySync(){return El(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=iu().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>kc(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),iu().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=iu().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>kc(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await iu().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),iu().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return lb.print(this,e)}clone(){return this.throwIfDisposed(),lb.clone(this)}toString(e=!1){const t=this.dataSync();return jge(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),lb.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),iu().makeVariable(this,e,t,r)}};Object.defineProperty(qn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Yge(){return xL("Tensor",()=>qn)}Yge();let pS=class extends qn{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Mn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);iu().disposeTensor(this),this.dataId=e.dataId,iu().incRef(this,null)}dispose(){iu().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(pS,Symbol.hasInstance,{value:n=>n instanceof qn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oD;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(oD||(oD={}));var aD;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(aD||(aD={}));var lD;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(lD||(lD={}));var cD;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(cD||(cD={}));var uD;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(uD||(uD={}));const Zge={float32:cD,int32:aD,bool:lD,complex64:uD};function Ii(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Zge[n][e]}function U2(n){return Ii(n,"int32")}function aX(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function lX(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ts(n,e){if(n.dtype===e.dtype)return[n,e];const t=Ii(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function cX(n,e){U(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function EM(n,e){return e.some(t=>t.id===n.id)}function Rf(n){const e=[];return uX(n,e,new Set),e}function uX(n,e,t){if(n==null)return;if(n instanceof qn){e.push(n);return}if(!Jge(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),uX(i,e,t))}}function Jge(n){return Array.isArray(n)||typeof n=="object"}const Qge=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:cX,getTensorsInContainer:Rf,isTensorInList:EM,makeTypesMatch:Ts},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JR(n){return n.kernelName!=null}let KW=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},CL=class hD{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new KW}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(xl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Vge(this.backendInstance),!0}setupRegisteredKernels(){yI(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){yI(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof V_)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,xl(`Initialization of backend ${e} failed`),xl(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return xl(`Initialization of backend ${e} failed`),xl(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return hD.nextTensorId++}nextVariableId(){return hD.nextVariableId++}clone(e){const t=ce.runKernel(ey,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ce.runKernel(Vg,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(dS(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=JR(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(JR(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=dS(p,this.backendName);U(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,x);const w=x.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(s){const _=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(_)}return w}}else{const{forwardFunc:p}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=JR(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=rD(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(U(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&uu(e[0])&&(i=e.map(l=>gu(l)));const o=s.write(i,t,r),a=new qn(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),c=U7(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new qn(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new pS(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*lS(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof pS||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*lS(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=rD(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=Hi(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Rf(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(U(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));U(i instanceof qn,()=>"The result y returned by f() must be a tensor.");const o=Gge(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??eye(i.shape),Hge(a,o,c=>this.tidy(c),tye);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return U(Jd(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{U(t.every(a=>a instanceof qn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),U(r.value instanceof qn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(Jd(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];U(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(u.every(f=>f instanceof qn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=ro(),r=await this.backend.time(e);return r.wallMs=ro()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new KW;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};CL.nextTensorId=0;CL.nextVariableId=0;function eye(n){const e=yM(Te(n),"float32");return ce.makeTensor(e,n,"float32")}function hX(){const n=j7();if(n._tfengine==null){const e=new H7(n);n._tfengine=new CL(e)}return xge(n._tfengine.ENV),Xge(()=>n._tfengine),n._tfengine}const ce=hX();function tye(n,e){const t={a:n,b:e};return ce.runKernel(Sp,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(){return typeof navigator<"u"&&navigator!=null}let fD;function rye(n){fD=n}function kL(n){if(fD!==void 0)return fD;if(n||nye()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function TL(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const sye=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:TL,isMobile:kL,mockIsMobile:rye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ba=Ee();ba.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ba.registerFlag("IS_BROWSER",()=>TL());ba.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ba.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ba.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));ba.registerFlag("PROD",()=>!1);ba.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ba.getBool("DEBUG"));ba.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ba.registerFlag("IS_TEST",()=>!1);ba.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ba.getBool("DEBUG"));ba.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ba.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ba.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wh(n,e){let t=n;if(wi(n))return e==="string"?[]:[n.length];if(aX(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(lX(n))return[n.buffer.size/(e==null?4:lS(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||wi(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&fX(n,r,[]),r}function fX(n,e,t){if(t=t||[],!Array.isArray(n)&&!wi(n)){U(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}U(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),U(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)fX(n[s],r,t.concat(s))}function YW(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function j(n,e,t,r="numeric"){if(n instanceof qn)return YW(r,n.dtype,e,t),n;let s=xp(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),YW(r,s,e,t),n==null||!wi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=wh(n,s);!wi(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?_p(n,s):Tc(n,[],!0);return ce.makeTensor(a,i,s)}function mS(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>j(i,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EL="__op";function he(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+EL;const s=(...i)=>{ce.startScope(t);try{const o=r(...i);return Qd(o)&&console.error("Cannot return a Promise inside of tidy."),ce.endScope(o),o}catch(o){throw ce.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iye(n,e){const t=j(n,"real","complex"),r=j(e,"imag","complex");ji(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return ce.runKernel(K_,s)}const Pf=he({complex_:iye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cp(n,e,t,r){if(r==null)r=xp(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(lX(n)||aX(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ce.backend.createTensorFromGPUData(n,e||t,r)}if(!wi(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Za(e);const s=Te(e),i=Te(t);U(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Te(e.slice(o)):!0;U(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!wi(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?_p(n,r):Tc(n,[],!0),ce.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ki(n,e,t){const r=wh(n,t);return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Du{static join(e){return new Du(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>wi(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+s.byteLength;this.shards.push({buffer:s,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,i=new ArrayBuffer(s),o=new Uint8Array(i);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],h=e+a-c.start,f=a,p=Math.min(t,c.end)-c.start,m=new Uint8Array(c.buffer,h,p-h);if(o.set(m,f),a+=m.length,t<c.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=oye(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function oye(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,i=e(n[s]);if(i===0)return s;i<0?r=s:t=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vI=4;async function pD(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const f=await l.bytes(),d=f.reduce((g,y)=>g+y.length,0)+vI*f.length,p=new Uint8Array(d);let m=0;for(let g=0;g<f.length;g++){const y=f[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(b,m),m+=vI,p.set(y,m),m+=y.length}h(p)});r.push(u)}else r.push(l.data());e!=null&&(c.group=e),t.push(c)}const i=await Promise.all(r);return{data:aye(i),specs:t}}function IL(n,e){const t=new Du(n),r={};let s,i=0;for(const o of e){const a=o.name,l=o.dtype,c=o.shape,u=Te(c);let h;if("quantization"in o){const f=o.quantization;if(f.dtype==="uint8"||f.dtype==="uint16"){if(!("min"in f&&"scale"in f))throw new Error(`Weight ${o.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`)}else if(f.dtype==="float16"){if(l!=="float32")throw new Error(`Weight ${o.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${l}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=dD[f.dtype],p=t.slice(i,i+u*d),m=f.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(l==="float32")if(f.dtype==="uint8"||f.dtype==="uint16"){h=new Float32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=y*f.scale+f.min}}else if(f.dtype==="float16")s===void 0&&(s=dye()),h=s(m);else throw new Error(`Unsupported quantization type ${f.dtype} for weight type float32.`);else if(l==="int32"){if(f.dtype!=="uint8"&&f.dtype!=="uint16")throw new Error(`Unsupported quantization type ${f.dtype} for weight type int32.`);h=new Int32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=Math.round(y*f.scale+f.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);i+=u*d}else if(l==="string"){const f=Te(o.shape);h=[];for(let d=0;d<f;d++){const p=new Uint32Array(t.slice(i,i+vI))[0];i+=vI;const m=new Uint8Array(t.slice(i,i+p));h.push(m),i+=p}}else{const f=dD[l],d=t.slice(i,i+u*f);if(l==="float32")h=new Float32Array(d);else if(l==="int32")h=new Int32Array(d);else if(l==="bool")h=new Uint8Array(d);else if(l==="complex64"){h=new Float32Array(d);const p=new Float32Array(h.length/2),m=new Float32Array(h.length/2);for(let b=0;b<p.length;b++)p[b]=h[b*2],m[b]=h[b*2+1];const g=ki(p,c,"float32"),y=ki(m,c,"float32");r[a]=Pf(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);i+=u*f}l!=="complex64"&&(r[a]=ki(h,c,l))}return r}function aye(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const AL=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function ZW(n){return AL?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function lye(n){if(AL)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function cye(n){if(AL){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function dX(n){return Du.join(n)}function JW(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function pX(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function ML(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function NL(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),ML(n,t,r)}function W2(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:ZW(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:ZW(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Du(n.weightData).byteLength}}function $L(n){const e=[];for(const t of n)e.push(...t.weights);return e}function uye(){const n=t=>{let r=t<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function hye(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function fye(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function dye(){const n=uye(),e=hye(),t=fye();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _s{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return _s.instance==null&&(_s.instance=new _s),_s.instance}static registerSaveRouter(e){_s.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_s.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _s.getHandlers(e,"save")}static getLoadHandlers(e,t){return _s.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?_s.getInstance().loadRouters:_s.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&s.push(a)}),s}}const pye=n=>_s.registerSaveRouter(n),mye=n=>_s.registerLoadRouter(n),mX=n=>_s.getSaveHandlers(n),gX=(n,e)=>_s.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD="tensorflowjs",gD=1,Dm="models_store",Id="model_info_store";function yX(){if(!Ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function yD(n){const e=n.result;e.createObjectStore(Dm,{keyPath:"modelPath"}),e.createObjectStore(Id,{keyPath:"modelPath"})}class tg{constructor(e){if(this.indexedDB=yX(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const i=this.indexedDB.open(mD,gD);i.onupgradeneeded=()=>yD(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Dm,"readonly"),c=a.objectStore(Dm).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=u=>(o.close(),s(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=Du.join(t.weightData);const a=W2(t),l=o.transaction(Id,"readwrite");let c=l.objectStore(Id),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return s(f)}let h;u.onsuccess=()=>{h=o.transaction(Dm,"readwrite");const f=h.objectStore(Dm);let d;try{d=f.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(p){return s(p)}d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=p=>{c=l.objectStore(Id);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),s(d.error)),m.onerror=g=>(o.close(),s(d.error))}},u.onerror=f=>(o.close(),s(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>s(i.error)})}}tg.URL_SCHEME="indexeddb://";const bX=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(tg.URL_SCHEME)?gye(n.slice(tg.URL_SCHEME.length)):null;_s.registerSaveRouter(bX);_s.registerLoadRouter(bX);function gye(n){return new tg(n)}function yye(n){return n.startsWith(tg.URL_SCHEME)?n.slice(tg.URL_SCHEME.length):n}class bye{constructor(){this.indexedDB=yX()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(mD,gD);r.onupgradeneeded=()=>yD(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(Id,"readonly"),a=i.objectStore(Id).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),t(a.error)),i.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=yye(e),new Promise((t,r)=>{const s=this.indexedDB.open(mD,gD);s.onupgradeneeded=()=>yD(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(Id,"readwrite"),a=o.objectStore(Id),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=i.transaction(Dm,"readwrite");const d=c.objectStore(Dm).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=p=>r(l.error)};u.onsuccess=h,u.onerror=f=>(h(),i.close(),r(l.error))}},l.onerror=u=>(i.close(),r(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},s.onerror=i=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kf="/",cb="tensorflowjs_models",vX="info",vye="model_topology",wye="weight_specs",xye="weight_data",Sye="model_metadata";function wX(n){return{info:[cb,n,vX].join(kf),topology:[cb,n,vye].join(kf),weightSpecs:[cb,n,wye].join(kf),weightData:[cb,n,xye].join(kf),modelMetadata:[cb,n,Sye].join(kf)}}function xX(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function _ye(n){const e=n.split(kf);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(kf)}function Cye(n){return n.startsWith(ng.URL_SCHEME)?n.slice(ng.URL_SCHEME.length):n}class ng{constructor(e){if(!Ee().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=wX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=W2(e),i=Du.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,lye(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw xX(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=cye(o),t}}ng.URL_SCHEME="localstorage://";const SX=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ng.URL_SCHEME)?kye(n.slice(ng.URL_SCHEME.length)):null;_s.registerSaveRouter(SX);_s.registerLoadRouter(SX);function kye(n){return new ng(n)}class Tye{constructor(){U(Ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=cb+kf,r=kf+vX;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(r)){const o=_ye(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=Cye(e);const t=wX(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return xX(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cb="://";class Fo{constructor(){this.managers={}}static getInstance(){return Fo.instance==null&&(Fo.instance=new Fo),Fo.instance}static registerManager(e,t){U(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Cb)&&(e=e.slice(0,e.indexOf(Cb))),U(e.length>0,()=>"scheme must not be an empty string.");const r=Fo.getInstance();U(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=Fo.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Fo.getInstance().managers)}}function ME(n){if(n.indexOf(Cb)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Fo.getSchemes().join(",")}`);return{scheme:n.split(Cb)[0],path:n.split(Cb)[1]}}async function _X(n,e,t=!1){U(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=_s.getLoadHandlers(n);U(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),U(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=_s.getSaveHandlers(e);U(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),U(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=ME(n).scheme,l=ME(n).path,c=a===ME(n).scheme,u=await s.load();t&&c&&await Fo.getManager(a).removeModel(l);const h=await o.save(u);return t&&!c&&await Fo.getManager(a).removeModel(l),h.modelArtifactsInfo}async function RL(){const n=Fo.getSchemes(),e={};for(const t of n){const r=await Fo.getManager(t).listModels();for(const s in r){const i=t+Cb+s;e[i]=r[s]}}return e}async function PL(n){const e=ME(n);return Fo.getManager(e.scheme).removeModel(e.path)}async function Eye(n,e){return _X(n,e,!1)}async function Iye(n,e){return _X(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aye{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ee().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Y7(e)}}if(Ee().get("IS_BROWSER")){Ee().setPlatform("browser",new Aye);try{Fo.registerManager(ng.URL_SCHEME,new Tye)}catch{}try{Fo.registerManager(tg.URL_SCHEME,new bye)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mye={importFetch:()=>require("node-fetch")};let QR;class Nye{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ee().global.fetch!=null?Ee().global.fetch(e,t):(QR==null&&(QR=Mye.importFetch()),QR(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Ee().get("IS_NODE")&&!Ee().get("IS_BROWSER")&&Ee().setPlatform("node",new Nye);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(n,e="float32",t){return e=e||"float32",Za(n),new ai(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ye(n,e){const t=j(n,"x","cast");if(!V7(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return ce.runKernel(Vg,r,s)}const xt=he({cast_:$ye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rye(n){const t={x:j(n,"x","clone","string_or_numeric")};return ce.runKernel(ey,t)}const mh=he({clone_:Rye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DL(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */hX();const Pye={buffer:wn,cast:xt,clone:mh,print:DL};Kge(Pye);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dye(){Ee().set("PROD",!0)}function Oye(){Ee().set("DEBUG",!0)}function Fye(){Ee().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Lye(n){Ee().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function zye(){ce.disposeVariables()}function bo(){return ce}function wI(){return ce.memory()}function Bye(n){return ce.profile(n)}function Se(n,e){return ce.tidy(n,e)}function nn(n){Rf(n).forEach(t=>t.dispose())}function qs(n){return ce.keep(n)}function Vye(n){return ce.time(n)}function Uye(n){return ce.setBackend(n)}function G2(){return ce.ready()}function gS(){return ce.backendName}function Wye(n){ce.removeBackend(n)}function Gye(n){return ce.findBackend(n)}function Hye(n){return ce.findBackendFactory(n)}function IM(n,e,t=1){return ce.registerBackend(n,e,t)}function rg(){return ce.backend}function jye(n,e){Ee().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qye(n,e){let t=j(n,"a","add"),r=j(e,"b","add");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(Sp,s)}const qe=he({add_:qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(n,e){let t=j(n,"a","floorDiv"),r=j(e,"b","floorDiv");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(Jg,s)}const OL=he({floorDiv_:Xye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kye(n,e){let t=j(n,"a","div"),r=j(e,"b","div");if([t,r]=Ts(t,r),t.dtype==="int32"&&r.dtype==="int32")return OL(t,r);const s={a:t,b:r},i={};return ce.runKernel(jg,s,i)}const Ft=he({div_:Kye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yye(n,e){let t=j(n,"a","mul"),r=j(e,"b","mul");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(cy,s)}const fe=he({mul_:Yye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(n){const e=j(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ce.runKernel(Nv,t)}else{const t={x:e};return ce.runKernel(_v,t)}}const bi=he({abs_:Zye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jye(n){const t={x:j(n,"x","acos")};return ce.runKernel(Pg,t)}const CX=he({acos_:Jye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(n){const t={x:j(n,"x","acosh")};return ce.runKernel(Dg,t)}const kX=he({acosh_:Qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(n){U(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),U(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,i)=>j(s,`tensors${i}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Mn(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return ce.runKernel(Cv,r)}const TX=he({addN_:e0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0e(n,e=null,t=!1){const s={x:j(n,"x","all","bool")},i={axis:e,keepDims:t};return ce.runKernel(U_,s,i)}const FL=he({all_:t0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n0e(n,e=null,t=!1){const s={x:j(n,"x","any","bool")},i={axis:e,keepDims:t};return ce.runKernel(W_,s,i)}const xI=he({any_:n0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0e(n,e=0){const r={x:j(n,"x","argMax")},s={axis:e};return ce.runKernel(kv,r,s)}const sg=he({argMax_:r0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(n,e=0){const r={x:j(n,"x","argMin")},s={axis:e};return ce.runKernel(Tv,r,s)}const EX=he({argMin_:s0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(n){const t={x:j(n,"x","asin")};return ce.runKernel(Og,t)}const IX=he({asin_:i0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0e(n){const t={x:j(n,"x","asinh")};return ce.runKernel(Fg,t)}const AX=he({asinh_:o0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0e(n){const t={x:j(n,"x","atan")};return ce.runKernel(Lg,t)}const MX=he({atan_:a0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0e(n,e){let t=j(n,"a","atan2"),r=j(e,"b","atan2");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(Bg,s)}const NX=he({atan2_:l0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c0e(n){const t={x:j(n,"x","atanh")};return ce.runKernel(zg,t)}const $X=he({atanh_:c0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(n,e,t,r,s="NHWC",i){const o=n[3],a=[...e,o],l=Qa(s);return ns(n,a,t,i,r,null,null,l)}function _o(n,e,t,r,s,i,o="channelsLast"){const[a,l]=yS(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ns(n,c,t,r,s,i,!1,o)}function zl(n,e,t,r,s,i,o="NDHWC"){const[a,l,c]=bD(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ou(n,u,t,r,s,!1,h,i)}function ns(n,e,t,r,s,i,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[f,d,,p]=e,[m,g]=yS(t),[y,b]=yS(r),x=kb(f,y),w=kb(d,b),{padInfo:_,outHeight:C,outWidth:k}=f0e(s,c,u,m,g,x,w,i,a),A=o?p*h:p;let M;return a==="channelsFirst"?M=[l,A,C,k]:a==="channelsLast"&&(M=[l,C,k,A]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:C,outWidth:k,outChannels:A,padInfo:_,strideHeight:m,strideWidth:g,filterHeight:f,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:n,outShape:M,filterShape:e}}function Ou(n,e,t,r,s,i=!1,o="channelsLast",a){let[l,c,u,h,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,f]=n;else if(o==="channelsFirst")[l,f,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,m,,g]=e,[y,b,x]=bD(t),[w,_,C]=bD(r),k=kb(d,w),A=kb(p,_),M=kb(m,C),{padInfo:I,outDepth:N,outHeight:O,outWidth:R}=d0e(s,c,u,h,y,b,x,k,A,M,a),D=i?g*f:g;let z;return o==="channelsFirst"?z=[l,D,N,O,R]:o==="channelsLast"&&(z=[l,N,O,R,D]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:f,outDepth:N,outHeight:O,outWidth:R,outChannels:D,padInfo:I,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:d,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:A,effectiveFilterWidth:M,dilationDepth:w,dilationHeight:_,dilationWidth:C,inShape:n,outShape:z,filterShape:e}}function u0e(n,e,t,r,s){r==null&&(r=LL(n,e,t));const i=n[0],o=n[1],a=bS((i-e+2*r)/t+1,s),l=bS((o-e+2*r)/t+1,s);return[a,l]}function h0e(n,e,t,r,s,i){s==null&&(s=LL(n,e[0],r[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*s>=e[a]&&(o[a]=bS((n[a]-e[a]+2*s)/r[a]+1,i));return o}function LL(n,e,t,r=1){const s=kb(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function yS(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function bD(n){return typeof n=="number"?[n,n,n]:n}function kb(n,e){return e<=1?n:n+(n-1)*(e-1)}function f0e(n,e,t,r,s,i,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=u0e([e,t],i,r,n,a);u=d[0],h=d[1]}else if(n==="same"){u=Math.ceil(e/r),h=Math.ceil(t/s);const f=Math.max(0,(u-1)*r+i-e),d=Math.max(0,(h-1)*s+o-t),p=Math.floor(f/2),m=f-p,g=Math.floor(d/2),y=d-g;c={top:p,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-i+1)/r),h=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const f=l==="channelsLast"?n[1][0]:n[2][0],d=l==="channelsLast"?n[1][1]:n[2][1],p=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:f,bottom:d,left:p,right:m,type:f===0&&d===0&&p===0&&m===0?"VALID":"EXPLICIT"},u=bS((e-i+f+d)/r+1,a),h=bS((t-o+p+m)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function d0e(n,e,t,r,s,i,o,a,l,c,u){let h,f,d,p;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=h0e([e,t,r,1],[a,l,c],1,[s,i,o],n,u);f=g[0],d=g[1],p=g[2]}else if(n==="same"){f=Math.ceil(e/s),d=Math.ceil(t/i),p=Math.ceil(r/o);const m=(f-1)*s+a-e,g=(d-1)*i+l-t,y=(p-1)*o+c-r,b=Math.floor(m/2),x=m-b,w=Math.floor(g/2),_=g-w,C=Math.floor(y/2),k=y-C;h={top:w,bottom:_,left:C,right:k,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:f,outHeight:d,outWidth:p}}function bS(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function ep(n){const[e,t,r]=yS(n);return e===1&&t===1&&r===1}function Ni(n,e){return ep(n)||ep(e)}function ig(n){return yS(n).every(e=>e>0)}function Qa(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Jo(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")U(eg(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{U(eg(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(n,e){const r={x:j(n,"x","reshape","string_or_numeric")},s={shape:e};return ce.runKernel(hw,r,s)}const ve=he({reshape_:p0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0e(n,e,t,r,s){const i=j(n,"x","avgPool","float32"),o=1;U(Ni(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Jo("avgPool",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=ce.runKernel(Ev,c,u);return h=xt(h,i.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const AM=he({avgPool_:m0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0e(n,e,t,r,s,i="NDHWC"){const o=j(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),U(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),U(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Jo("avgPool3d",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i};let h=ce.runKernel(Iv,c,u);return h=xt(h,a.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const zL=he({avgPool3d_:g0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0e(n,e=0){U(n.length>=1,()=>"Pass at least one tensor to concat");const t=mS(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return mh(t[0]);const r=t,s={axis:e};return ce.runKernel($v,r,s)}const cs=he({concat_:y0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0e(n,e,t=!1,r=!1){let s=j(n,"a","matMul"),i=j(e,"b","matMul");[s,i]=Ts(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return ce.runKernel(Av,o,a)}const jn=he({matMul_:b0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0e(n){const t={x:j(n,"x","sigmoid","float32")};return ce.runKernel(wy,t)}const Il=he({sigmoid_:v0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(n,e,t){const r=j(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:t};return ce.runKernel(gw,s,i)}const fn=he({slice_:w0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0e(n){const t={x:j(n,"x","tanh","float32")};return ce.runKernel(Ty,t)}const Wb=he({tanh_:x0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0e(n,e,t,r,s,i){const o=j(n,"forgetBias","basicLSTMCell"),a=j(e,"lstmKernel","basicLSTMCell"),l=j(t,"lstmBias","basicLSTMCell"),c=j(r,"data","basicLSTMCell"),u=j(s,"c","basicLSTMCell"),h=j(i,"h","basicLSTMCell"),f=cs([c,h],1),d=jn(f,a),p=qe(d,l),m=p.shape[0],g=p.shape[1]/4,y=[m,g],b=fn(p,[0,0],y),x=fn(p,[0,g],y),w=fn(p,[0,g*2],y),_=fn(p,[0,g*3],y),C=qe(fe(Il(b),Wb(x)),fe(u,Il(qe(o,w)))),k=fe(Wb(C),Il(_));return[C,k]}const RX=he({basicLSTMCell_:S0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(n,e,t){const r=j(n,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);U(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),U(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),U(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:r},o={blockShape:e,crops:t};return ce.runKernel(Mv,i,o)}const MM=he({batchToSpaceND_:_0e});function C0e(n){let e;return n.rank===0||n.rank===1?e=ve(n,[1,1,1,n.size]):n.rank===2?e=ve(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0e(n,e,t,r,s,i){i==null&&(i=.001);const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;r!=null&&(u=j(r,"offset","batchNorm")),U(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:C0e(o),scale:c,offset:u,mean:a,variance:l},d={varianceEpsilon:i},p=ce.runKernel(Vv,f,d);return ve(p,o.shape)}const H2=he({batchNorm_:k0e});function T0e(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),U(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),U(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),H2(o,a,l,u,c,i)}const BL=he({batchNorm2d_:T0e});function E0e(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),U(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),U(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),H2(o,a,l,u,c,i)}const VL=he({batchNorm3d_:E0e});function I0e(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),U(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),U(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),H2(o,a,l,u,c,i)}const UL=he({batchNorm4d_:I0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(n,e,t){const r=j(n,"x","bincount"),s=j(e,"weights","bincount");U(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:t};return ce.runKernel(j_,i,o)}const WL=he({bincount_:A0e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0e(n,e){const t=j(n,"x","bitwiseAnd"),r=j(e,"y","bitwiseAnd");if(!Mn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const s={a:t,b:r};return ce.runKernel(q_,s)}const PX=he({bitwiseAnd_:M0e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(n,e){const t=j(n,"s0","broadcastArgs","int32"),r=j(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return ce.runKernel(X_,s)}const DX=he({broadcastArgs_:N0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0e(n,e){let t=j(n,"broadcastTo","x");const r=t.shape;if(Za(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ve(t,c)}const s=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return mh(t);const a={x:t},l={reps:i};return ce.runKernel(Ey,a,l)}const Tb=he({broadcastTo_:$0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(n){const t={x:j(n,"x","ceil","float32")};return ce.runKernel(Ug,t)}const OX=he({ceil_:R0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ny(n,e,t){Za(n),t=t||xp(e);const r={shape:n,value:e,dtype:t};return ce.runKernel(u2,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(n,e,t){const r=j(n,"x","clipByValue");if(U(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Ny(r.shape,e,r.dtype);const s={x:r},i={clipValueMin:e,clipValueMax:t};return ce.runKernel(Wg,s,i)}const va=he({clipByValue_:P0e});function D0e(n){return cs(n,0)}const GL=he({concat1d_:D0e});function O0e(n,e){return cs(n,e)}const HL=he({concat2d_:O0e});function F0e(n,e){return cs(n,e)}const jL=he({concat3d_:F0e});function L0e(n,e){return cs(n,e)}const qL=he({concat4d_:L0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0e(n,e,t,r,s="NHWC",i=[1,1],o){const a=j(n,"x","conv2d","float32"),l=j(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Jo("conv2d",r,o);const h=s==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),U(Ni(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),U(ig(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(ig(t),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},p=ce.runKernel(Rv,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const tp=he({conv2d_:z0e});function B0e(n,e,t,r,s="NWC",i=1,o){const a=j(n,"x","conv1d"),l=j(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1]])),U(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),U(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Jo("conv1d",r,o),U(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),U(Ni(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),U(ig(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(ig(t),()=>"Error in conv1D: Stride should be larger than 0."),U(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=ve(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=tp(f,h,[1,t],r,"NHWC",[1,i],o);return u?ve(g,[g.shape[2],g.shape[3]]):ve(g,[g.shape[0],g.shape[2],g.shape[3]])}const XL=he({conv1d_:B0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0e(n,e,t,r,s,i="NHWC",o){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),U(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),U(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),U(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];U(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),U(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Jo("conv2dDerInput",s,o);const f={dy:l,filter:t},d={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a},p=ce.runKernel(Pv,f,d);return c?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const KL=he({conv2DBackpropInput_:V0e});function U0e(n,e,t,r,s,i){const o=j(n,"x","conv2dTranspose"),a=j(e,"filter","conv2dTranspose");return KL(t,o,a,r,s,"NHWC",i)}const YL=he({conv2dTranspose_:U0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(n,e,t,r,s="NDHWC",i=[1,1,1]){const o=j(n,"x","conv3d"),a=j(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),U(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),U(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),U(Ni(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),U(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),U(ig(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(ig(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:i},f=ce.runKernel(Dv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const ZL=he({conv3d_:W0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(n,e,t,r,s){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];U(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),U(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),U(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),U(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),U(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},h={pad:s,strides:r,inputShape:i},f=ce.runKernel(J_,u,h);return a?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const FX=he({conv3DBackpropInput_:G0e});function H0e(n,e,t,r,s){const i=j(n,"x","conv3dTranspose"),o=j(e,"filter","conv3dTranspose");return FX(t,i,o,r,s)}const JL=he({conv3dTranspose_:H0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0e(n){const t={x:j(n,"x","cos","float32")};return ce.runKernel(Gg,t)}const NM=he({cos_:j0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(n){const t={x:j(n,"x","cosh","float32")};return ce.runKernel(Hg,t)}const QL=he({cosh_:q0e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0e(n,e=0,t=!1,r=!1){const i={x:j(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return ce.runKernel(Q_,i,o)}const SI=he({cumprod_:X0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0e(n,e=0,t=!1,r=!1){const i={x:j(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return ce.runKernel(Ov,i,o)}const ez=he({cumsum_:K0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(n,e,t,r=!1){const s=j(n,"x","denseBincount"),i=j(e,"weights","denseBincount");U(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),U(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const o={x:s,weights:i},a={size:t,binaryOutput:r};return ce.runKernel(t2,o,a)}const _I=he({denseBincount_:Y0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(n,e,t="NHWC"){const r=j(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],i=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];U(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),U(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),U(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${r.shape}`),U(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:t};return ce.runKernel(n2,a,l)}const LX=he({depthToSpace_:Z0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0e(n,e,t,r,s="NHWC",i=[1,1],o){const a=j(n,"x","depthwiseConv2d","float32"),l=j(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=s==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Jo("depthwiseConv2d",r,o);const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},p=ce.runKernel(Fv,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const j2=he({depthwiseConv2d_:J0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q0e(n){const t={x:j(n,"x","diag")};return ce.runKernel(i2,t)}const zX=he({diag_:Q0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(n,e,t,r,s=[1,1],i="NHWC"){const o=j(n,"x","dilation2d"),a=j(e,"filter","dilation2d");U(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),U(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),U(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),U(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:t,pad:r,dilations:s},f=ce.runKernel(Lv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const BX=he({dilation2d_:ebe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Df(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const i=t-1-s,o=n[i]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(i)}return r}function ci(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],i=e.length-r-1,o=e[i];(s==null||s===1&&o>1)&&t.unshift(i)}return t}function ln(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let i=n[n.length-s-1];i==null&&(i=1);let o=e[e.length-s-1];if(o==null&&(o=1),i===1)r[t-s-1]=o;else if(o===1)r[t-s-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-s-1]=i}return r}const tbe=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:ln,getBroadcastDims:Df,getReductionAxes:ci},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(n,e){let t=j(n,"a","equal","string_or_numeric"),r=j(e,"b","equal","string_or_numeric");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(zv,s)}const vu=he({equal_:nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbe(n,e,t){const r=j(e,"a","where"),s=j(t,"b","where"),i=j(n,"condition","where","bool"),o=ln(ln(i.shape,r.shape),s.shape),a=Tb(i,o),l=Tb(r,o),c=Tb(s,o),u={condition:a,t:l,e:c};return ce.runKernel(mw,u)}const vo=he({where_:rbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbe(n){const t={x:j(n,"x","zerosLike")};return ce.runKernel(_w,t)}const ar=he({zerosLike_:sbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(n,e){let t=j(n,"a","div"),r=j(e,"b","div");[t,r]=Ts(t,r);const s=Ft(t,r),i=ar(s),o=vu(r,i);return vo(o,i,s)}const VX=he({divNoNan_:ibe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obe(n,e){const t=j(n,"t1","dot"),r=j(e,"t2","dot");U((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],i=r.rank===1?r.size:r.shape[0];if(U(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),t.rank===1&&r.rank===1){const o=ve(t,[1,-1]),a=ve(r,[-1,1]),l=jn(o,a);return ve(l,[])}else if(t.rank===1&&r.rank===2){const o=ve(t,[1,-1]),a=ve(r,[r.shape[0],r.shape[1]]),l=jn(o,a);return ve(l,[l.size])}else if(t.rank===2&&r.rank===1){const o=ve(r,[-1,1]),a=jn(t,o);return ve(a,[a.size])}else{const o=ve(r,[r.shape[0],r.shape[1]]);return jn(t,o)}}const UX=he({dot_:obe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(n,...e){const t=e.map((s,i)=>j(s,`tensors${i}`,"einsum")),r={equation:n};return ce.runKernel(a2,t,r)}const Im=he({einsum_:abe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(n){const t={x:j(n,"x","elu","float32")};return ce.runKernel(qg,t)}const q2=he({elu_:lbe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(n,e){const t=j(n,"x","ensureShape","string_or_numeric");if(!z7(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const WX=he({ensureShape_:cbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ube(n){let e=j(n,"x","erf");U(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=xt(e,"float32"));const t={x:e};return ce.runKernel(Xg,t)}const GX=he({erf_:ube});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tz(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function HX(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function Js(n,e){const t=[],r=n.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&t.push(n[i]);const s=e.map(i=>n[i]);return[t,s]}function Ls(n,e){const t=e.map(r=>1);return HX(n,t,e)}function ui(n,e,t){U(tz(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Lr(n,e){if(tz(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Rh(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function rs(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hbe(n,e=null,t=!1){const s={x:j(n,"x","max")},i={reductionIndices:e,keepDims:t};return ce.runKernel(Zv,s,i)}const Sc=he({max_:hbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fbe(n,e=null,t=!1){const s={x:j(n,"x","min")},i={axis:e,keepDims:t};return ce.runKernel(tw,s,i)}const vS=he({min_:fbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(n,e){let t=j(n,"base","pow"),r=j(e,"exp","pow");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(uy,s)}const np=he({pow_:dbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(n,e){if((wi(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&wi(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Cp(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(n){const t={x:j(n,"x","sqrt","float32")};return ce.runKernel(Sy,t)}const wo=he({sqrt_:pbe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mbe(n){const e=j(n,"x","square"),t={};return ce.runKernel("Square",{x:e},t)}const Or=he({square_:mbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(n,e=null,t=!1){let r=j(n,"x","sum");r.dtype==="bool"&&(r=xt(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ce.runKernel(yw,s,i)}const Yt=he({sum_:gbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ybe(n,e="euclidean",t=null,r=!1){n=j(n,"x","norm");const s=jX(n,e,t);let i=s.shape;if(r){const o=Tn(t,n.shape);i=Ls(s.shape,o)}return ve(s,i)}function jX(n,e,t=null){if(n.rank===0)return bi(n);if(n.rank!==1&&t===null)return jX(ve(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Yt(bi(n),t);if(e===1/0)return Sc(bi(n),t);if(e===-1/0)return vS(bi(n),t);if(e==="euclidean"||e===2)return wo(Yt(np(bi(n),en(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Sc(Yt(bi(n),t[0]),t[1]-1);if(e===1/0)return Sc(Yt(bi(n),t[1]),t[0]);if(e===-1/0)return vS(Yt(bi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return wo(Yt(Or(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Cw=he({norm_:ybe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbe(n,e=null,t=!1){return Cw(n,"euclidean",e,t)}const qX=he({euclideanNorm_:bbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vbe(n){const t={x:j(n,"x","exp")};return ce.runKernel(Kg,t)}const Xo=he({exp_:vbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(n,e=0){const t=j(n,"x","expandDims","string_or_numeric");U(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return ce.runKernel(Bv,r,s)}const ii=he({expandDims_:wbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(n){const t={x:j(n,"x","expm1")};return ce.runKernel(Yg,t)}const XX=he({expm1_:xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(n,e){const t=j(n,"x","tile","string_or_numeric");U(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return ce.runKernel(Ey,r,s)}const gc=he({tile_:Sbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _be(n,e,t,r="float32"){e==null&&(e=n);const s=wn([n,e],r),i=n<=e?n:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=ve(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return gc(ii(o,0),[t[0],1,1]);if(t.length===2)return gc(ii(ii(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return gc(ii(ii(ii(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const $M=he({eye_:_be});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cbe(n){const t={x:j(n,"x","floor","float32")};return ce.runKernel(Zg,t)}const X2=he({floor_:Cbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(n,e,t=0,r=0){const s=j(n,"x","gather"),i=j(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return ce.runKernel(Uv,o,a)}const K2=he({gather_:kbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(n,e){let t=j(n,"a","greater","string_or_numeric"),r=j(e,"b","greater","string_or_numeric");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(Wv,s)}const el=he({greater_:Tbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ebe(n,e){let t=j(n,"a","greaterEqual","string_or_numeric"),r=j(e,"b","greaterEqual","string_or_numeric");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(Qg,s)}const Tp=he({greaterEqual_:Ebe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(n){const t={input:j(n,"input","imag")};return ce.runKernel(p2,t)}const Y2=he({imag_:Ibe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Abe(n){const t={x:j(n,"x","isFinite")};return ce.runKernel(ty,t)}const KX=he({isFinite_:Abe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mbe(n){const t={x:j(n,"x","isInf")};return ce.runKernel(ny,t)}const YX=he({isInf_:Mbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(n){const t={x:j(n,"x","isNaN")};return ce.runKernel(ry,t)}const ZX=he({isNaN_:Nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(n,e=.2){const r={x:j(n,"x","leakyRelu")},s={alpha:e};return ce.runKernel(Gv,r,s)}const RM=he({leakyRelu_:$be});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rbe(n,e){let t=j(n,"a","less","string_or_numeric"),r=j(e,"b","less","string_or_numeric");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(Hv,s)}const wS=he({less_:Rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pbe(n,e){let t=j(n,"a","lessEqual","string_or_numeric"),r=j(e,"b","lessEqual","string_or_numeric");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(jv,s)}const $y=he({lessEqual_:Pbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JX(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return ce.runKernel(m2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(n,e=5,t=1,r=1,s=.5){const i=j(n,"x","localResponseNormalization");U(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),U(eg(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:r,beta:s},u=ce.runKernel(Yv,l,c);return a?ve(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const QX=he({localResponseNormalization_:Dbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obe(n){const t={x:j(n,"x","log","float32")};return ce.runKernel(sy,t)}const $l=he({log_:Obe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fbe(n){const t={x:j(n,"x","log1p")};return ce.runKernel(iy,t)}const PM=he({log1p_:Fbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lbe(n){return U(Jd(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const r=j(e,"x","tf.grad","string_or_numeric"),s=t!=null?j(t,"dy","tf.grad"):null;return ce.tidy(()=>{const{value:i,grads:o}=ce.gradients(()=>n(r),[r],s);return s!=null&&ji(i.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),DM(o),o[0]})}}function zbe(n){return U(Jd(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{U(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=mS(e,"args","tf.grads","string_or_numeric"),s=t!=null?j(t,"dy","tf.grads"):null;return ce.tidy(()=>{const{value:i,grads:o}=ce.gradients(()=>n(...r),r,s);return s!=null&&ji(i.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),DM(o),o})}}function Bbe(n){return U(Jd(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{U(e instanceof qn,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),U(t==null||t instanceof qn,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=ce.gradients(()=>n(e),[e],t);return DM(r),{grad:r[0],value:s}}}function Vbe(n){return U(Jd(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{U(Array.isArray(e)&&e.every(s=>s instanceof qn),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),U(t==null||t instanceof qn,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=ce.gradients(()=>n(...e),e,t);return t!=null&&ji(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),DM(r.grads),r}}function eK(n,e){U(Jd(n),()=>"The f passed in variableGrads(f) must be a function"),U(e==null||Array.isArray(e)&&e.every(c=>c instanceof pS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in ce.registeredVariables)e.push(ce.registeredVariables[c])}const r=t?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),U(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const i=!0,{value:o,grads:a}=ce.gradients(n,e,null,i);U(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:o,grads:l}}function xh(n){return ce.customGrad(n)}function DM(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(n){const t={x:j(n,"x","neg")};return ce.runKernel(rw,t)}const us=he({neg_:Ube});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wbe(n){const t={x:j(n,"x","softplus")};return ce.runKernel(xy,t)}const kw=he({softplus_:Wbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gbe(n){const e=j(n,"x","logSigmoid");return xh(r=>({value:us(kw(us(r))),gradFunc:o=>fe(o,Il(us(r)))}))(e)}const tK=he({logSigmoid_:Gbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbe(n,e){let t=j(n,"a","sub"),r=j(e,"b","sub");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(Cy,s)}const Rt=he({sub_:Hbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jbe(n,e=-1){const t=j(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return xh((s,i)=>{const a=Sc(s,e,!0),l=Rt(s,a),c=Rt(xt(l,"float32"),$l(Yt(Xo(l),e,!0)));return i([c]),{value:c,gradFunc:(h,f)=>{const[d]=f,p=!0,m=Xo(d);return Rt(h,fe(Yt(h,e,p),m))}}})(t)}const nz=he({logSoftmax_:jbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(n,e=null,t=!1){const r=j(n,"x","logSumExp"),s=Tn(e,r.shape),i=Sc(r,s,!0),o=Rt(r,i),a=Xo(o),l=Yt(a,s),c=$l(l),u=qe(ve(i,c.shape),c);if(t){const h=Ls(u.shape,s);return ve(u,h)}return u}const OM=he({logSumExp_:qbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xbe(n,e){const t=j(n,"a","logicalAnd","bool"),r=j(e,"b","logicalAnd","bool");ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(qv,s)}const Sh=he({logicalAnd_:Xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(n){const t={x:j(n,"x","logicalNot","bool")};return ce.runKernel(Xv,t)}const FM=he({logicalNot_:Kbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ybe(n,e){const t=j(n,"a","logicalOr","bool"),r=j(e,"b","logicalOr","bool");ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(Kv,s)}const rz=he({logicalOr_:Ybe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(n,e){const t=j(n,"a","logicalXor","bool"),r=j(e,"b","logicalXor","bool");return ln(t.shape,r.shape),Sh(rz(n,e),FM(Sh(n,e)))}const nK=he({logicalXor_:Zbe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vk=2147483648;function Jbe(n,e,t="left"){const r=j(n,"sortedSequence","searchSorted"),s=j(e,"values","searchSorted"),i=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],a=ve(r,[-1,i]),l=ve(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Te(l.shape)>=Vk)throw new Error(`values tensor size must less than ${Vk}`);if(a.shape[1]>=Vk)throw new Error(`trailing dim_size must less than ${Vk} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:t};return ce.runKernel(A2,c,u)}const LM=he({searchSorted_:Jbe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rK(n,e){return LM(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(n,e,t,r,s){const i=j(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),U(Ni(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Jo("maxPool",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=ce.runKernel(Jv,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const zM=he({maxPool_:Qbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eve(n,e=[1,1,1],t,r,s,i="NDHWC"){const o=j(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),U(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Jo("maxPool3d",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i},h=ce.runKernel(Qv,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const sz=he({maxPool3d_:eve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tve(n,e,t,r,s=!1){const o={x:j(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},l=ce.runKernel(v2,o,a);return{result:l[0],indexes:l[1]}}const sK=he({maxPoolWithArgmax_:tve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(n,e){let t=j(n,"a","maximum"),r=j(e,"b","maximum");[t,r]=Ts(t,r),t.dtype==="bool"&&(t=xt(t,"int32"),r=xt(r,"int32")),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(oy,s)}const Wf=he({maximum_:nve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rve(n,e=null,t=!1){const s={x:j(n,"x","mean")},i={axis:e,keepDims:t};return ce.runKernel(ew,s,i)}const Os=he({mean_:rve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n,e="float32"){if(Za(n),e==="complex64"){const r=ms(n,"float32"),s=ms(n,"float32");return Pf(r,s)}const t=Hi(Te(n),e);return ce.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function da(n,e="float32"){if(Za(n),e==="complex64"){const r=da(n,"float32"),s=ms(n,"float32");return Pf(r,s)}const t=yM(Te(n),e);return ce.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iK(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=j(n,"x","meshgrid",n instanceof qn?n.dtype:"float32");if(e===void 0)return[r];let s=j(e,"y","meshgrid",e instanceof qn?e.dtype:"float32");const i=Te(r.shape),o=Te(s.shape);return t==="xy"?(r=ve(r,[1,-1]),s=ve(s,[-1,1]),[jn(da([o,1],r.dtype),r),jn(s,da([1,i],s.dtype))]):(r=ve(r,[-1,1]),s=ve(s,[1,-1]),[jn(r,da([1,o],r.dtype)),jn(da([i,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(n,e){let t=j(n,"a","minimum"),r=j(e,"b","minimum");[t,r]=Ts(t,r),t.dtype==="bool"&&(t=xt(t,"int32"),r=xt(r,"int32")),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(ay,s)}const rp=he({minimum_:sve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ive(n,e,t){U(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=j(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)U(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const i={paddings:e,mode:t},o={x:r};return ce.runKernel(nw,o,i)}const iz=he({mirrorPad_:ive});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ove(n,e){let t=j(n,"a","mod"),r=j(e,"b","mod");[t,r]=Ts(t,r);const s={a:t,b:r};return ce.runKernel(ly,s)}const oK=he({mod_:ove});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(n,e=null,t=!1){n=j(n,"x","moments");const r=Tn(e,n.shape),s=Os(n,r,t);let i=s.shape;t||(i=Ls(s.shape,r));const o=Or(Rt(xt(n,"float32"),ve(s,i))),a=Os(o,r,t);return{mean:s,variance:a}}const Z2=he({moments_:ave});function lve(n,e,t,r){const s=j(e,"data","multiRNNCell"),i=mS(t,"c","multiRNNCell"),o=mS(r,"h","multiRNNCell");let a=s;const l=[];for(let h=0;h<n.length;h++){const f=n[h](a,i[h],o[h]);l.push(f[0]),l.push(f[1]),a=f[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const aK=he({multiRNNCell_:lve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(n,e,t,r=!1){const s=j(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ve(s,[1,-1]):s},c={numSamples:e,seed:t,normalized:r},u=ce.runKernel(w2,l,c);return o===1?ve(u,[u.size]):u}const lK=he({multinomial_:cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(n,e){let t=j(n,"a","notEqual","string_or_numeric"),r=j(e,"b","notEqual","string_or_numeric");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ce.runKernel(sw,s)}const Gb=he({notEqual_:uve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:j(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return ce.runKernel(ow,o,a)}const Hb=he({oneHot_:hve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fve(n){const t={x:j(n,"x","onesLike")};return ce.runKernel(iw,t)}const Rl=he({onesLike_:fve});function dve(n,e){const t=j(n,"v1","outerProduct"),r=j(e,"v2","outerProduct");U(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=ve(t,[-1,1]),i=ve(r,[1,-1]);return jn(s,i)}const cK=he({outerProduct_:dve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pve(n,e,t=0){const r=j(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},i={x:r};return ce.runKernel(lw,i,s)}const wu=he({pad_:pve});function mve(n,e,t=0){return U(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),wu(n,[e],t)}const uK=he({pad1d_:mve});function gve(n,e,t=0){return U(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wu(n,e,t)}const hK=he({pad2d_:gve});function yve(n,e,t=0){return U(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wu(n,e,t)}const fK=he({pad3d_:yve});function bve(n,e,t=0){return U(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),wu(n,e,t)}const dK=he({pad4d_:bve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vve(n,e,t){const r=j(n,"x","spaceToBatchND");U(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),U(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),U(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},i={blockShape:e,paddings:t};return ce.runKernel(bw,s,i)}const BM=he({spaceToBatchND_:vve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wve(n,e,t,r,s,i,o){s==null&&(s=[1,1]),i==null&&(i=1),r===0&&(r="valid");const a=j(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(Ni(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=_o(l.shape,e,i,s,r),h=[u.dilationHeight,u.dilationWidth];let f;r==="same"?f=Sve([u.filterHeight,u.filterWidth],h):f=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[p,m]=xve([u.inHeight,u.inWidth],h,f),g=d?r:"valid",y=d?l:BM(l,h,p),x=(t==="avg"?()=>AM(y,e,i,g,o):()=>zM(y,e,i,g,o))(),w=d?x:MM(x,h,m);return c?ve(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function xve(n,e,t){const r=t.map(u=>u[0]),s=t.map(u=>u[1]),i=n.concat(r,s),o=e.map((u,h)=>(u-i[h]%u)%u),a=s.map((u,h)=>u+o[h]),l=e.map((u,h)=>[r[h],a[h]]),c=e.map((u,h)=>[0,o[h]]);return[l,c]}function Sve(n,e){const r=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}const pK=he({pool_:wve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ve(n,e){const t=j(n,"x","prelu"),r=j(e,"alpha","prelu"),s={x:t,alpha:r};return ce.runKernel(cw,s)}const VM=he({prelu_:_ve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(n,e=null,t=!1){let r=j(n,"x","prod");r.dtype==="bool"&&(r=xt(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ce.runKernel(uw,s,i)}const mK=he({prod_:Cve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(n,e,t,r){const s=n.map((u,h)=>j(u,`tensors${h}`,"raggedGather","int32")),i=j(e,"paramsDenseValues","raggedGather"),o=j(t,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:i,indices:o},l={outputRaggedRank:r},c=ce.runKernel(vM,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const gK=he({raggedGather_:kve});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tve(n,e,t){const r=j(n,"starts","raggedRange"),s=j(e,"limits","raggedRange",r.dtype),i=j(t,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:i},a=ce.runKernel(wM,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const yK=he({raggedRange_:Tve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eve(n,e,t,r,s){const i=j(n,"shape","raggedTensorToTensor","int32"),o=j(e,"values","raggedTensorToTensor"),a=j(t,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((h,f)=>j(h,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:s};return ce.runKernel(xM,c,u)}const bK=he({raggedTensorToTensor_:Eve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(n,e,t){Za(n);const r=Te(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<r;i++)s[i]=e();return ce.makeTensor(s,n,t)}const vK=he({rand_:Ive});var oz={exports:{}};oz.exports;(function(n){(function(e,t,r){function s(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new s(l),h=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&i(h,u),f.state=function(){return i(u,{})}),f}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(mt,n,!1)})(oz);var Ave=oz.exports,az={exports:{}};az.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(mt,n,!1)})(az);var Mve=az.exports,lz={exports:{}};lz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(mt,n,!1)})(lz);var Nve=lz.exports,cz={exports:{}};cz.exports;(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var u=l.x,h=l.i,f,d;return f=u[h],f^=f>>>7,d=f^f<<24,f=u[h+1&7],d^=f^f>>>10,f=u[h+3&7],d^=f^f>>>3,f=u[h+4&7],d^=f^f<<7,f=u[h+7&7],f=f^f<<13,d^=f^f<<9,u[h]=d,l.i=h+1&7,d};function c(u,h){var f,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,f=0;f<h.length;++f)d[f&7]=d[f&7]<<15^h.charCodeAt(f)+d[f+1&7]<<13;for(;d.length<8;)d.push(0);for(f=0;f<8&&d[f]===0;++f);for(f==8?d[7]=-1:d[f],u.x=d,u.i=0,f=256;f>0;--f)u.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.x&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(mt,n,!1)})(cz);var $ve=cz.exports,uz={exports:{}};uz.exports;(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var u=l.w,h=l.X,f=l.i,d,p;return l.w=u=u+1640531527|0,p=h[f+34&127],d=h[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,p=h[f]=p^d,l.i=f,p+(u^u>>>16)|0};function c(u,h){var f,d,p,m,g,y=[],b=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,b=Math.max(b,h.length)),p=0,m=-32;m<b;++m)h&&(d^=h.charCodeAt((m+32)%h.length)),m===0&&(g=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(g=g+1640531527|0,f=y[m&127]^=d+g,p=f==0?p+1:0);for(p>=128&&(y[(h&&h.length||0)&127]=-1),p=127,m=4*128;m>0;--m)d=y[p+34&127],f=y[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,y[p]=d^f;u.w=g,u.X=y,u.i=p}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.X&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(mt,n,!1)})(uz);var Rve=uz.exports,hz={exports:{}};hz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.next=function(){var h=l.b,f=l.c,d=l.d,p=l.a;return h=h<<25^h>>>7^f,f=f-d|0,d=d<<24^d>>>8^p,p=p-h|0,l.b=h=h<<20^h>>>12^f,l.c=f=f-d|0,l.d=d<<16^f>>>16^p,l.a=p-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(mt,n,!1)})(hz);var Pve=hz.exports,wK={exports:{}};const Dve={},Ove=Object.freeze(Object.defineProperty({__proto__:null,default:Dve},Symbol.toStringTag,{value:"Module"})),xK=Vf(Ove);(function(n){(function(e,t,r){var s=256,i=6,o=52,a="random",l=r.pow(s,i),c=r.pow(2,o),u=c*2,h=s-1,f;function d(w,_,C){var k=[];_=_==!0?{entropy:!0}:_||{};var A=y(g(_.entropy?[w,x(t)]:w??b(),3),k),M=new p(k),I=function(){for(var N=M.g(i),O=l,R=0;N<c;)N=(N+R)*s,O*=s,R=M.g(1);for(;N>=u;)N/=2,O/=2,R>>>=1;return(N+R)/O};return I.int32=function(){return M.g(4)|0},I.quick=function(){return M.g(4)/4294967296},I.double=I,y(x(M.S),t),(_.pass||C||function(N,O,R,D){return D&&(D.S&&m(D,M),N.state=function(){return m(M,{})}),R?(r[a]=N,O):N})(I,A,"global"in _?_.global:this==r,_.state)}function p(w){var _,C=w.length,k=this,A=0,M=k.i=k.j=0,I=k.S=[];for(C||(w=[C++]);A<s;)I[A]=A++;for(A=0;A<s;A++)I[A]=I[M=h&M+w[A%C]+(_=I[A])],I[M]=_;(k.g=function(N){for(var O,R=0,D=k.i,z=k.j,B=k.S;N--;)O=B[D=h&D+1],R=R*s+B[h&(B[D]=B[z=h&z+O])+(B[z]=O)];return k.i=D,k.j=z,R})(s)}function m(w,_){return _.i=w.i,_.j=w.j,_.S=w.S.slice(),_}function g(w,_){var C=[],k=typeof w,A;if(_&&k=="object")for(A in w)try{C.push(g(w[A],_-1))}catch{}return C.length?C:k=="string"?w:w+"\0"}function y(w,_){for(var C=w+"",k,A=0;A<C.length;)_[h&A]=h&(k^=_[h&A]*19)+C.charCodeAt(A++);return x(_)}function b(){try{var w;return f&&(w=f.randomBytes)?w=w(s):(w=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(w)),x(w)}catch{var _=e.navigator,C=_&&_.plugins;return[+new Date,e,C,e.screen,x(t)]}}function x(w){return String.fromCharCode.apply(0,w)}if(y(r.random(),t),n.exports){n.exports=d;try{f=xK}catch{}}else r["seed"+a]=d})(typeof self<"u"?self:mt,[],Math)})(wK);var Fve=wK.exports,Lve=Ave,zve=Mve,Bve=Nve,Vve=$ve,Uve=Rve,Wve=Pve,Ry=Fve;Ry.alea=Lve;Ry.xor128=zve;Ry.xorwow=Bve;Ry.xorshift7=Vve;Ry.xor4096=Uve;Ry.tychei=Wve;var Tw=Ry;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve=.001,SK=.1;function Hve(n,e,t){return t==null&&(t=fz()),vD(n,e,(r,s)=>dz(r,s,t))}function fz(){return ce.backend.floatPrecision()===32?Gve:SK}function vD(n,e,t){let r=!0;if((wi(n)||wi(e))&&(r=!1),wi(n)&&wi(e)&&(r=!0),r){const o=n.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=wh(n),a=wh(e);if(!Mn(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const s=wi(n)?n:Tc(n),i=wi(e)?e:Tc(e);if(s.length!==i.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${i.length}.
Actual:   ${s}.
Expected: ${i}.`);for(let o=0;o<i.length;++o){const a=s[o],l=i[o];if(!t(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${s}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function jve(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function qve(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return uu(n)||uu(n[0])||uu(e)||uu(e[0])?vD(n,t,(r,s)=>r==s):vD(n,e,(r,s)=>dz(r,s,0))}function Xve(n,e,t){if(t==null&&(t=fz()),!dz(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function dz(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function Kve(n,e,t){for(let r=0;r<n.length;r++)if(n[r]<e||n[r]>t)throw new Error(`Value out of range:${n[r]} low: ${e}, high: ${t}`)}function Yve(n,e){const t=new Float32Array(n),r=new Float32Array(e);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let s=0;s<r.length;s++)if(t[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${t[s]} instead`)}function _K(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?_K(t):n[e]=gu(t)}return n}function Zve(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",r=>t(e)),e.load()})}async function Jve(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const Qve=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:SK,createVideoElement:Zve,encodeStrings:_K,expectArrayBuffersEqual:Yve,expectArraysClose:Hve,expectArraysEqual:qve,expectNumbersClose:Xve,expectPromiseToFail:jve,expectValuesInRange:Kve,play:Jve,testEpsilon:fz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pz{constructor(e,t,r,s,i){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Tw.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,i,o;do s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class ewe{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const i=s||Math.random();this.randu=Tw.alea(i.toString()),this.randn=new pz(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,i,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<t||Math.log(i)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class twe{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Tw.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(n,e,t=1,r="float32",s){if(Za(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const i=new ewe(e,t,r,s),o=wn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const CK=he({randomGamma_:nwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rwe(n,e=0,t=1,r,s){if(Za(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const i=new pz(e,t,r,!1,s),o=wn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const UM=he({randomNormal_:rwe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function swe(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return UM(n,0,1,e,t)}const kK=he({randomStandardNormal_:swe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iwe(n,e=0,t=1,r="float32",s){Za(n);const i=wn(n,r),o=new twe(e,t,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Ep=he({randomUniform_:iwe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function owe(n,e,t,r){return Ep(n,e,t,"int32",r)}const TK=he({randomUniformInt_:owe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function og(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return ce.runKernel(_2,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function awe(n){const t={input:j(n,"input","real")};return ce.runKernel(C2,t)}const jb=he({real_:awe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lwe(n){const t={x:j(n,"x","reciprocal")};return ce.runKernel(hy,t)}const EK=he({reciprocal_:lwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cwe(n){const t={x:j(n,"x","relu")};return ce.runKernel(fy,t)}const Ph=he({relu_:cwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uwe(n){const t={x:j(n,"x","relu6")};return ce.runKernel(dy,t)}const mz=he({relu6_:uwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hwe(n,e){const r={x:j(n,"x","reverse")},s={dims:e};return ce.runKernel(pw,r,s)}const Ec=he({reverse_:hwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fwe(n){const e=j(n,"x","reverse");return U(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Ec(e,0)}const IK=he({reverse1d_:fwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dwe(n,e){const t=j(n,"x","reverse");return U(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Ec(t,e)}const AK=he({reverse2d_:dwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pwe(n,e){const t=j(n,"x","reverse");return U(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Ec(t,e)}const MK=he({reverse3d_:pwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mwe(n,e){const t=j(n,"x","reverse");return U(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Ec(t,e)}const NK=he({reverse4d_:mwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gwe(n){const t={x:j(n,"x","round")};return ce.runKernel(py,t)}const gz=he({round_:gwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ywe(n){const t={x:j(n,"x","rsqrt","float32")};return ce.runKernel(my,t)}const yz=he({rsqrt_:ywe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bwe(n){const t={x:j(n,"x","selu")};return ce.runKernel(gy,t)}const bz=he({selu_:bwe});function vwe(n,e,t,r,s,i=[1,1],o="NHWC"){const a=j(n,"x","separableConv2d"),l=j(e,"depthwiseFilter","separableConv2d"),c=j(t,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),U(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),U(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),U(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],d=l.shape[3];U(c.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${c.shape[2]}.`);const p=j2(u,l,r,s,o,i),g=tp(p,c,1,"valid",o);return h?ve(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const vz=he({separableConv2d_:vwe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function wwe(n,e){const t=j(n,"x","setdiff1d"),r=j(e,"y","setdiff1d");U(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),U(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),U(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),i=await r.data(),o=new Set(i);let a=0;for(let u=0;u<s.length;u++)o.has(s[u])||a++;const l=new ai([a],t.dtype),c=new ai([a],"int32");for(let u=0,h=0;u<s.length;u++)o.has(s[u])||(l.values[h]=s[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const $K=wwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xwe(n){const t={x:j(n,"x","sign")};return ce.runKernel(vy,t)}const RK=he({sign_:xwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Swe(n){const t={x:j(n,"x","sin","float32")};return ce.runKernel(yy,t)}const wz=he({sin_:Swe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(n){const t={x:j(n,"x","sinh")};return ce.runKernel(by,t)}const xz=he({sinh_:_we});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cwe(n,e,t){const r=j(n,"x","slice1d");return U(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),fn(r,[e],[t])}const J2=he({slice1d_:Cwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kwe(n,e,t){const r=j(n,"x","slice2d");return U(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),fn(r,e,t)}const WM=he({slice2d_:kwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Twe(n,e,t){const r=j(n,"x","slice3d");return U(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),fn(r,e,t)}const Q2=he({slice3d_:Twe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ewe(n,e,t){const r=j(n,"x","slice4d");return U(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),fn(r,e,t)}const qb=he({slice4d_:Ewe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iwe(n,e=-1){const t=j(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return ce.runKernel(ww,r,s)}const eC=he({softmax_:Iwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Awe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ce.runKernel(c2,e)}const GM=he({fft_:Awe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mwe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ce.runKernel(d2,e)}const xS=he({ifft_:Mwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nwe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=ve(n,[t,e]);r=xS(s)}else{const s=[t,2*(e-1)],i=ve(jb(n),[t,e]),o=ve(Y2(n),[t,e]),a=Ec(fn(i,[0,1],[t,e-2]),1),l=fe(Ec(fn(o,[0,1],[t,e-2]),1),en(-1)),c=cs([i,a],1),u=cs([o,l],1),h=ve(Pf(c,u),[s[0],s[1]]);r=xS(h)}if(r=jb(r),n.rank===3&&n.shape[0]!==0){const s=r,i=n.shape[0];r=ve(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}const Sz=he({irfft_:Nwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $we(n,e,t=0){const s={x:j(n,"x","split")},i={numOrSizeSplits:e,axis:t};return ce.runKernel(vw,s,i)}const Wa=he({split_:$we});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rwe(n,e){U(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,s=fn(n,p,m),t=e}else if(e!=null&&e>t){const p=n.shape.map(m=>m);p[n.shape.length-1]=e-t,s=cs([n,ms(p)],n.shape.length-1),t=e}else s=n;const i=ar(s),o=ve(Pf(s,i),[r,t]),a=GM(o),l=Math.floor(t/2)+1,c=jb(a),u=Y2(a),h=Wa(c,[l,t-l],c.shape.length-1),f=Wa(u,[l,t-l],u.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=l,ve(Pf(h[0],f[0]),d)}const HM=he({rfft_:Rwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pwe(n,e){let t=j(n,"a","squaredDifference"),r=j(e,"b","squaredDifference");[t,r]=Ts(t,r),ln(t.shape,r.shape);const s={a:t,b:r},i={};return ce.runKernel(_y,s,i)}const _z=he({squaredDifference_:Pwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dwe(n,e){const t=j(n,"x","squeeze","string_or_numeric");return ve(t,Bf(t.shape,e).newShape)}const gr=he({squeeze_:Dwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Owe(n,e=0){const t=mS(n,"tensors","stack","string_or_numeric");U(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&U(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return ce.runKernel(aw,r,s)}const wa=he({stack_:Owe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fwe(n,e=0){const r={x:j(n,"x","step")},s={alpha:e};return ce.runKernel(Iy,r,s)}const Ew=he({step_:Fwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(n,e,t,r,s=0,i=0,o=0,a=0,l=0){const u={x:j(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ce.runKernel(D2,u,h)}const PK=he({stridedSlice_:Lwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(n){const t={x:j(n,"x","tan","float32")};return ce.runKernel(ky,t)}const DK=he({tan_:zwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xs(n,e){$g(n);const t=wh(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Cp(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ga(n,e,t){if($g(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=wh(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cz(n,e,t){if($g(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=wh(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OK(n,e,t){if($g(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=wh(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(n,e,t){if($g(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=wh(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Cp(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LK(n,e,t){if($g(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=wh(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Cp(n,e,r,t)}function kz(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(i+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(i+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function jM(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}kz(t,e,n)}function Fu(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=t.length;let o=1;for(let h=s;h<i;++h)o*=t[h];const a=s<1?1:s,l=Te(e.shape)/a,c=[...Jt(t.slice(0,s)),1],u=Te(t);return{sliceRank:s,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}const Bwe=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Fu,validateInput:jM,validateUpdateShape:kz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(n,e,t){const r=j(n,"tensor","tensorScatterupdate"),s=j(e,"indices","tensorScatterupdate","int32"),i=j(t,"updates","tensorScatterupdate");if(jM(i,s,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);const o={tensor:r,indices:s,updates:i},a={};return ce.runKernel(I2,o,a)}const zK=he({tensorScatterUpdate_:Vwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwe(n,e=1,t=!0){const r=j(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},o={k:e,sorted:t},[a,l]=ce.runKernel(F2,i,o);return{values:a,indices:l}}const BK=he({topk_:Uwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wwe(n,e=0,t=1,r,s){if(Za(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new pz(e,t,r,!0,s),o=wn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const qM=he({truncatedNormal_:Wwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(n,e=0){const t=j(n,"x","unique","string_or_numeric");U(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[i,o]=ce.runKernel(TM,r,s);return{values:i,indices:o}}const VK=he({unique_:Gwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hwe(n,e,t){const r=j(n,"x","unsortedSegmentSum"),s=j(e,"segmentIds","unsortedSegmentSum","int32");U(eg(t),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:s},o={numSegments:t};return ce.runKernel(Sw,i,o)}const Tz=he({unsortedSegmentSum_:Hwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwe(n,e=0){const t=j(n,"x","unstack","string_or_numeric");U(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return ce.runKernel(xw,r,s)}const Ic=he({unstack_:jwe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UK(n,e){return LM(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ez(n,e=!0,t,r){return ce.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XM(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const r=wn(n,"int32"),s=wn([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=r.indexToLoc(t[i]),a=i*n.length;s.values.set(o,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function qwe(n){const e=j(n,"condition","whereAsync","bool"),t=await e.data(),r=XM(e.shape,t);return n!==e&&e.dispose(),r}const Iz=qwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Xwe(n,e,t){const r=j(n,"tensor","boolMask"),s=j(e,"mask","boolMask","bool"),i=t??0,o=s.rank,a=r.shape;U(o>0,()=>"mask cannot be scalar"),ji(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=ve(r,c),h=ve(s,[-1]),f=await Iz(h),d=gr(f,[1]),p=K2(u,d,i);return n!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),u.dispose(),h.dispose(),f.dispose(),p}const WK=Xwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kwe(n,e,t){const r=j(n,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),U(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{U(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return r.dtype==="complex64"?Se(()=>{let o=jb(r),a=Y2(r);return o=ce.runKernel(Bd,{x:o},i),a=ce.runKernel(Bd,{x:a},i),t&&(a=us(a)),Pf(o,a)}):ce.runKernel(Bd,s,i)}const nr=he({transpose_:Kwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ywe(n,e,t,r,s=!0){const i=j(n,"v","movingAverage"),o=j(e,"x","movingAverage"),a=j(t,"decay","movingAverage");cX(i,o),U(Mn(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=en(1),c=Rt(l,a);let u=fe(Rt(o,i),c);if(s){U(r!=null,()=>"When using zeroDebias: true, step is required.");const h=j(r,"step","movingAverage");u=Ft(u,Rt(l,np(a,h)))}return qe(i,u)}const GK=he({movingAverage_:Ywe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zwe(n,e,t){Za(t);const r=j(n,"indices","scatterND","int32"),s=j(e,"updates","scatterND");jM(s,r,t);const i={indices:r,updates:s},o={shape:t};return ce.runKernel(E2,i,o)}const HK=he({scatterND_:Zwe});function Jwe(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qwe(n,e,t,r=0){Za(t);const s=j(n,"sparseIndices","sparseToDense","int32"),i=j(e,"sparseValues","sparseToDense","string_or_numeric"),o=j(r,"defaultValue","sparseToDense",i.dtype);Jwe(s,i,t,o);const a={sparseIndices:s,sparseValues:i,defaultValue:o},l={outputShape:t};return ce.runKernel($2,a,l)}const jK=he({sparseToDense_:Qwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(n,e){const t=j(e,"indices","gatherND","int32"),s={params:j(n,"x","gatherND","string_or_numeric"),indices:t};return ce.runKernel(f2,s)}const qK=he({gatherND_:exe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function txe(n,e){if(e==null)return n.shape.slice();if(Mn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(n,e,t,r){const s=j(n,"x","dropout");if(U(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),U(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof qn?s.clone():s;const i=txe(s,t),o=1-e,a=Ft(X2(qe(Ep(i,0,1,"float32",r),o)),o);return fe(s,a)}const Az=he({dropout_:nxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mz(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function KM(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=e-t*Math.cos(o)}return Xs(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function rxe(n,e,t=1){const r=j(n,"predictions","inTopK"),s=j(e,"targets","inTopK");U(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),U(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),ji(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];U(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const o=await r.data(),a=await s.data(),[l,c]=[o.length/i,i],u=li("bool",l);for(let h=0;h<l;h++){const f=h*c,d=o.subarray(f,f+c),p=[];for(let m=0;m<d.length;m++)p.push({value:d[m],index:m});p.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<t;m++)if(p[m].index===a[h]){u[h]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),ki(u,s.shape,"bool")}const XK=rxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(n,e,t,r,s,i="NHWC",o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]])),U(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),U(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),U(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],u=i==="NHWC"?l.shape[3]:l.shape[1];U(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),U(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),Jo("conv2dDerFilter",s,o);const h={x:a,dy:l},f={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:t};return ce.runKernel(Y_,h,f)}const Nz=he({conv2DBackpropFilter_:sxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YM(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return fe(n,Ew(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function ZM(n,e){let t=e;const r=ci(n.shape,e.shape);return r.length>0&&(t=Yt(t,r)),ve(t,n.shape)}function JM(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Ph(n);if(e==="elu")return q2(n);if(e==="relu6")return mz(n);if(e==="prelu")return VM(n,t);if(e==="leakyrelu")return RM(n,r);if(e==="sigmoid")return Il(n);throw new Error(`Unknown fused activation ${e}.`)}const QM=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ixe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",QM(ce.state.gradientDepth,l)===!1){U(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=tp(n,e,t,r,s,i,o);return a!=null&&(C=qe(C,a)),JM(C,l,c,u)}const h=j(n,"x","conv2d","float32"),f=j(e,"filter","conv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),Jo("fused conv2d",r,o);const m=s==="NHWC"?d.shape[3]:d.shape[1];U(f.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`),U(Ni(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const g=ns(d.shape,f.shape,t,i,r,o);let y;a!=null&&(y=j(a,"bias","fused conv2d"),[y]=Ts(y,h),s==="NHWC"?ln(g.outShape,y.shape):(U(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),U(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(c!=null){const C=c.shape;if(U(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)U(C[0]===1||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(C.length===3)try{ln(C,g.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(A)}b=j(c,"prelu weights","fused conv2d")}const x=(C,k)=>{U(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[A,M,I,N]=k,O=YM(C,I,l);U(ep(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const R=KL(M.shape,O,A,t,r),D=Nz(M,O,A.shape,t,r),z=[R,D];if(N!=null){const B=ZM(N,O);z.push(B)}return z},w={x:d,filter:f,bias:y,preluActivationWeights:b},_={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?xh((k,A,M)=>{let I=ce.runKernel(zb,w,_);return M([A,k,I]),p&&(I=ve(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:x}})(d,f):xh((k,A,M,I)=>{let N=ce.runKernel(zb,w,_);return I([A,k,N,M]),p&&(N=ve(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:x}})(d,f,y)}const KK=he({fusedConv2d_:ixe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(n,e,t,r,s,i=[1,1],o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:t};return ce.runKernel(r2,c,u)}const YK=he({depthwiseConv2dNativeBackpropFilter_:oxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axe(n,e,t,r,s,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n},h=ce.runKernel(s2,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ZK=he({depthwiseConv2dNativeBackpropInput_:axe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lxe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(QM(ce.state.gradientDepth,l)===!1){let _=j2(n,e,t,r,s,i,o);return a!=null&&(_=qe(_,a)),JM(_,l,c,u)}const h=j(n,"x","depthwiseConv2d","float32"),f=j(e,"filter","depthwiseConv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),U(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),i==null&&(i=[1,1]),U(Ni(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Jo("fused depthwiseConv2d",r,o);const m=ns(d.shape,f.shape,t,i,r,o,!0);let g;a!=null&&(g=j(a,"bias","fused conv2d"),[g]=Ts(g,h),ln(m.outShape,g.shape));let y;c!=null&&(y=j(c,"prelu weights","fused depthwiseConv2d"));const b=(_,C)=>{U(ep(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[k,A,M,I]=C,N=YM(_,M,l),O=ZK(A.shape,N,k,t,r,i,o),R=YK(A,N,k.shape,t,r,i,o);if(I!=null){const D=ZM(g,N);return[O,R,D]}return[O,R]},x={x:d,filter:f,bias:g,preluActivationWeights:y},w={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?xh((C,k,A)=>{let M=ce.runKernel(Bb,x,w);return A([k,C,M]),p&&(M=ve(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(d,f):xh((C,k,A,M)=>{let I=ce.runKernel(Bb,x,w);return M([k,C,I,A]),p&&(I=ve(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:b}})(d,f,g)}const cxe=he({fusedDepthwiseConv2d_:lxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(QM(ce.state.gradientDepth,i)===!1){let N=jn(n,e,t,r);return s!=null&&(N=qe(N,s)),JM(N,i,o,a)}let l=j(n,"a","fused matMul"),c=j(e,"b","fused matMul");[l,c]=Ts(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=t?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=Te(p),y=Te(m);U(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${r} must match.`);const x=ln(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,d]),w=t?ve(l,[g,u,f]):ve(l,[g,f,u]),_=r?ve(c,[y,d,h]):ve(c,[y,h,d]);let C;s!=null&&(C=j(s,"bias","fused matMul"),[C]=Ts(C,l),ln(x,C.shape));let k;o!=null&&(k=j(o,"prelu weights","fused matMul"));const A=(N,O)=>{const[R,D,z,B]=O,X=YM(ve(N,z.shape),z,i);let G,ee;if(!t&&!r?(G=jn(X,D,!1,!0),ee=jn(R,X,!0,!1)):!t&&r?(G=jn(X,D,!1,!1),ee=jn(X,R,!0,!1)):t&&!r?(G=jn(D,X,!1,!0),ee=jn(R,X,!1,!1)):(G=jn(D,X,!0,!0),ee=jn(X,R,!0,!0)),s!=null){const pe=ZM(B,X);return[G,ee,pe]}else return[G,ee]},M={a:w,b:_,bias:C,preluActivationWeights:k},I={transposeA:t,transposeB:r,activation:i,leakyreluAlpha:a};return s==null?xh((O,R,D)=>{const z=ce.runKernel(Lb,M,I);return D([O,R,z]),{value:ve(z,x),gradFunc:A}})(w,_):xh((O,R,D,z)=>{const B=ce.runKernel(Lb,M,I);return z([O,R,B,D]),{value:ve(B,x),gradFunc:A}})(w,_,C)}const wD=he({fusedMatMul_:uxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JK=Object.freeze(Object.defineProperty({__proto__:null,conv2d:KK,depthwiseConv2d:cxe,matMul:wD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hxe(n){return KM(n,.54,.46)}const fxe=he({hammingWindow_:hxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(n){return KM(n,.5,.5)}const QK=he({hannWindow_:dxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe(n,e,t,r=!1,s=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(fn(n,i,e)),i+=t;if(r)for(;i<n.size;){const a=i+e-n.size,l=cs([fn(n,i,e-a),Ny([a],s)]);o.push(l),i+=t}return o.length===0?Ga([],[0,e]):ve(cs(o),[o.length,e])}const eY=he({frame_:pxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mxe(n,e,t,r,s=QK){r==null&&(r=Mz(e));const i=eY(n,e,t),o=fe(i,s(e));return HM(o,r)}const gxe=he({stft_:mxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yxe(n,e,t,r,s="bilinear",i=0){const o=j(n,"image","cropAndResize"),a=j(e,"boxes","cropAndResize","float32"),l=j(t,"boxInd","cropAndResize","int32"),c=a.shape[0];U(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),U(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),U(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),U(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),U(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const u={image:o,boxes:a,boxInd:l},h={method:s,extrapolationValue:i,cropSize:r};return ce.runKernel(e2,u,h)}const bxe=he({cropAndResize_:yxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(n){const e=j(n,"image","flipLeftRight","float32");U(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ce.runKernel(h2,t,{})}const wxe=he({flipLeftRight_:vxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(n){const e=j(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),U(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,gc(e,s)}const Sxe=he({grayscaleToRGB_:xxe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _xe(n){const e=j(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),U(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,i=xt(e,"float32"),o=Xs([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Im("ij,j->i",i,o);break;case 3:a=Im("ijk,k->ij",i,o);break;case 4:a=Im("ijkl,l->ijk",i,o);break;case 5:a=Im("ijklm,m->ijkl",i,o);break;case 6:a=Im("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=ii(a,-1),xt(a,s)}const Cxe=he({rgbToGrayscale_:_xe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kxe(n,e,t=0,r=.5){const s=j(n,"image","rotateWithOffset","float32");U(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},o={radians:e,fillValue:t,center:r};return ce.runKernel(z2,i,o)}const Txe=he({rotateWithOffset_:kxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n,e,t,r,s,i){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),U(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),U(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),U(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),U(e.rank===1,()=>"scores must be a 1D tensor"),U(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),U(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Exe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=j(n,"boxes","nonMaxSuppression","float32"),o=j(e,"scores","nonMaxSuppression","float32"),a=Iw(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return ce.runKernel(x2,{boxes:i,scores:o},l)}const Ixe=he({nonMaxSuppression_:Exe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(n,e,t){const r=Mxe(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function Mxe(n,e,t){return $xe(n,e,t||Nxe)}function Nxe(n,e){return n>e?1:n<e?-1:0}function $xe(n,e,t){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=t(e,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tC(n,e,t,r,s){return $z(n,e,t,r,s,0)}function eN(n,e,t,r,s,i){return $z(n,e,t,r,s,0,!1,i,!0)}function nC(n,e,t,r,s,i){return $z(n,e,t,r,s,i,!0)}function $z(n,e,t,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>s&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(QW);const u=i>0?-.5/i:0,h=[],f=[];for(;h.length<t&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let w=!1;for(let _=h.length-1;_>=x;--_){const C=Rxe(n,b,h[_]);if(C>=r){w=!0;break}if(g.score=g.score*Pxe(r,u,C),g.score<=s)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(b),f.push(g.score)):g.score>s&&Axe(c,g,QW))}const d=h.length,p=t-d;a&&p>0&&(h.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=f),l&&(m.validOutputs=d),m}function Rxe(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),f=Math.max(s[1],s[3]),d=(a-i)*(l-o),p=(h-c)*(f-u);if(d<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,h),b=Math.min(l,f),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(d+p-x)}function Pxe(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function QW(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Dxe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=j(n,"boxes","nonMaxSuppressionAsync"),o=j(e,"scores","nonMaxSuppressionAsync"),a=Iw(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=tC(c,u,t,r,s);return i!==n&&i.dispose(),o!==e&&o.dispose(),Xs(h,"int32")}const Oxe=Dxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fxe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Iw(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i},h=ce.runKernel(S2,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const Lxe=he({nonMaxSuppressionWithScore_:Fxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function zxe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Iw(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:f,selectedScores:d}=nC(u,h,t,r,s,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Xs(f,"int32"),selectedScores:Xs(d)}}const Bxe=zxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Iw(o,a,t,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,f={boxes:o,scores:a},d={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:i},p=ce.runKernel(bM,f,d);return{selectedIndices:p[0],validOutputs:p[1]}}const Uxe=he({nonMaxSuppressionPadded_:Vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Wxe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Iw(o,a,t,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[f,d]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=eN(f,d,c,u,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Xs(p,"int32"),validOutputs:en(m,"int32")}}const Gxe=Wxe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hxe(n,e,t=!1,r=!1){const s=j(n,"images","resizeBilinear");U(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),U(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),U(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},c=ce.runKernel(dw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const jxe=he({resizeBilinear_:Hxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qxe(n,e,t=!1,r=!1){const s=j(n,"images","resizeNearestNeighbor");U(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),U(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),U(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},c=ce.runKernel(fw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Xxe=he({resizeNearestNeighbor_:qxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kxe(n,e="binary",t=!1,r=.5){const s=j(n,"image","threshold"),i=.2989,o=.587,a=.114,l=s.shape[0]*s.shape[1];let c=fe(Xs([r]),255),u,h,f,d;if(U(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),U(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),U(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),U(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[u,h,f]=Wa(s,[1,1,1],-1);const g=fe(u,i),y=fe(h,o),b=fe(f,a);d=qe(qe(g,y),b)}else d=n;if(e==="otsu"){const g=WL(xt(gz(d),"int32"),ki([]),256);c=Yxe(g,l)}const p=t?$y(d,c):el(d,c);return xt(fe(p,255),"int32")}function Yxe(n,e){let t=Xs([-1]),r=Xs([0]),s=Xs([0]),i,o,a,l,c,u;for(let h=0;h<n.size-1;h++){i=fn(n,0,h+1),o=fn(n,h+1),c=Ft(Yt(i),e),u=Ft(Yt(o),e);const f=Yt(fe(i,og(0,i.size)));a=Ft(f,Yt(i));const d=Ny(o.shape,i.size),p=qe(og(0,o.size),d),m=fe(o,p);l=Ft(Yt(m),Yt(o));const g=Rt(a,l),y=Rt(a,l),b=fe(c,u);s=fe(fe(b,g),y);const x=el(s,r);r=vo(x,s,r),t=vo(x,Xs([h]),t)}return t}const Zxe=he({threshold_:Kxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jxe(n,e,t="nearest",r="constant",s=0,i){const o=j(n,"image","transform","float32"),a=j(e,"transforms","transform","float32");U(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:r,fillValue:s,outputShape:i};return ce.runKernel(L2,l,c)}const Qxe=he({transform_:Jxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e(n,e,t){const r=j(n,"a","bandPart");U(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(U(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),U(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=j(e<0?i:e,"numLower","bandPart")):(U(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=vo(wS(e,0),i,rp(e,i))),typeof t=="number"?(U(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),U(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=j(t<0?o:t,"numUpper","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=vo(wS(t,0),o,rp(t,o)));const c=ve(og(0,i,1,"int32"),[-1,1]),u=og(0,o,1,"int32"),h=Rt(c,u),f=Sh($y(h,a),Tp(h,us(l))),d=ms([i,o],r.dtype);return ve(wa(Ic(ve(r,[-1,i,o])).map(p=>vo(f,p,d))),s)}const t1e=he({bandPart_:e1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1e(n){let e;if(Array.isArray(n)){e=!1,U(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)U(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else e=!0,n=Wa(n,n.shape[0],0).map(s=>gr(s,[0]));U(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(ce.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=fe(Yt(fe(t[o],i)),t[o]);i=Rt(i,a)}return Ft(i,Cw(i,"euclidean"))}));return e?wa(t,0):t}const r1e=he({gramSchmidt_:n1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(n,e=!1){if(U(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return eG(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Ic(ve(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];r.forEach(l=>{const[c,u]=eG(l,e);s.push(c),i.push(u)});const o=ve(wa(s,0),n.shape),a=ve(wa(i,0),n.shape);return[o,a]}}function eG(n,e=!1){return ce.tidy(()=>{U(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=$M(t),i=mh(n);const o=Ga([[1]],[1,1]);let a=mh(o);const l=t>=r?r:t;for(let c=0;c<l;++c){const u=i,h=a,f=s;[a,i,s]=ce.tidy(()=>{const d=fn(i,[c,c],[t-c,1]),p=Cw(d),m=fn(i,[c,c],[1,1]),g=vo(el(m,0),Ga([[-1]]),Ga([[1]])),y=Rt(m,fe(g,p)),b=Ft(d,y);b.shape[0]===1?a=mh(o):a=cs([o,fn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const x=us(Ft(jn(g,y),p)),w=fn(i,[c,0],[t-c,r]),_=fe(x,a),C=nr(a);if(c===0)i=Rt(w,jn(_,jn(C,w)));else{const M=Rt(w,jn(_,jn(C,w)));i=cs([fn(i,[0,0],[c,r]),M],0)}const k=nr(_),A=fn(s,[0,c],[t,s.shape[1]-c]);if(c===0)s=Rt(A,jn(jn(A,a),k));else{const M=Rt(A,jn(jn(A,a),k));s=cs([fn(s,[0,0],[t,c]),M],1)}return[a,i,s]}),nn([u,h,f])}return!e&&t>r&&(s=fn(s,[0,0],[t,r]),i=fn(i,[0,0],[r,r])),[s,i]})}const i1e=he({qr_:s1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Bo;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Bo||(Bo={}));function o1e(n,e,t=Bo.SUM_BY_NONZERO_WEIGHTS){const r=j(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=j(e,"weights","computeWeightedLoss"));const i=s==null?r:fe(r,s);if(t===Bo.NONE)return i;if(t===Bo.SUM)return Yt(i);if(t===Bo.MEAN){if(s==null)return Os(i);{const o=r.size/s.size,a=Ft(Yt(i),Yt(s));return o>1?Ft(a,en(o)):a}}if(t===Bo.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Ft(Yt(i),en(r.size));{const o=fe(s,da(r.shape)),a=xt(Yt(Gb(o,en(0))),"float32");return Ft(Yt(i),a)}}throw Error(`Unknown reduction: ${t}`)}const Gf=he({computeWeightedLoss_:o1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1e(n,e,t,r=Bo.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","absoluteDifference"),i=j(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=j(t,"weights","absoluteDifference")),ji(s.shape,i.shape,"Error in absoluteDifference: ");const a=bi(Rt(s,i));return Gf(a,o,r)}const l1e=he({absoluteDifference_:a1e});function c1e(n,e,t,r,s=Bo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","cosineDistance"),o=j(e,"predictions","cosineDistance");let a=null;r!=null&&(a=j(r,"weights","cosineDistance")),ji(i.shape,o.shape,"Error in cosineDistance: ");const l=en(1),c=Rt(l,Yt(fe(i,o),t,!0));return Gf(c,a,s)}const u1e=he({cosineDistance_:c1e});function h1e(n,e,t,r=Bo.SUM_BY_NONZERO_WEIGHTS){let s=j(n,"labels","hingeLoss");const i=j(e,"predictions","hingeLoss");let o=null;t!=null&&(o=j(t,"weights","hingeLoss")),ji(s.shape,i.shape,"Error in hingeLoss: ");const a=en(1);s=Rt(fe(en(2),s),a);const l=Ph(Rt(a,fe(s,i)));return Gf(l,o,r)}const f1e=he({hingeLoss_:h1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d1e(n,e,t,r=1,s=Bo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","huberLoss"),o=j(e,"predictions","huberLoss");let a=null;t!=null&&(a=j(t,"weights","huberLoss")),ji(i.shape,o.shape,"Error in huberLoss: ");const l=en(r),c=bi(Rt(o,i)),u=rp(c,l),h=Rt(c,u),f=qe(fe(en(.5),Or(u)),fe(l,h));return Gf(f,a,s)}const p1e=he({huberLoss_:d1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1e(n,e,t,r=1e-7,s=Bo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","logLoss"),o=j(e,"predictions","logLoss");let a=null;t!=null&&(a=j(t,"weights","logLoss")),ji(i.shape,o.shape,"Error in logLoss: ");const l=en(1),c=en(r),u=us(fe(i,$l(qe(o,c)))),h=fe(Rt(l,i),$l(qe(Rt(l,o),c))),f=Rt(u,h);return Gf(f,a,s)}const g1e=he({logLoss_:m1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1e(n,e,t,r=Bo.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","meanSquaredError"),i=j(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=j(t,"weights","meanSquaredError")),ji(s.shape,i.shape,"Error in meanSquaredError: ");const a=_z(s,i);return Gf(a,o,r)}const b1e=he({meanSquaredError_:y1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1e(n,e){const t=j(n,"labels","sigmoidCrossEntropyWithLogits"),r=j(e,"logits","sigmoidCrossEntropyWithLogits");ji(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Ph(r),i=fe(r,t),o=PM(Xo(us(bi(r))));return qe(Rt(s,i),o)}function w1e(n,e,t,r=0,s=Bo.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"multiClassLabels","sigmoidCrossEntropy");const o=j(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","sigmoidCrossEntropy")),ji(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=en(r),u=en(1),h=en(.5);i=qe(fe(i,Rt(u,c)),fe(h,c))}const l=v1e(i,o);return Gf(l,a,s)}const x1e=he({sigmoidCrossEntropy_:w1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1e(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return xh((s,i,o)=>{const l=OM(i,[t],!0),c=Rt(xt(i,"float32"),l);o([s,c]);const u=us(fe(c,s));return{value:Yt(u,[t]),gradFunc:(d,p)=>{const[m,g]=p,y=Ls(d.shape,[t]);return[fe(ve(d,y),Rt(xt(m,"float32"),Xo(g))),fe(ve(d,y),Rt(Xo(g),xt(m,"float32")))]}}})(n,e)}function _1e(n,e,t,r=0,s=Bo.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"onehotLabels","softmaxCrossEntropy");const o=j(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","softmaxCrossEntropy")),ji(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=en(r),u=en(1),h=en(i.shape[1]);i=qe(fe(i,Rt(u,c)),Ft(c,h))}const l=S1e(i,o);return Gf(l,a,s)}const C1e=he({softmaxCrossEntropy_:_1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1e(n,e,t,r){const s=j(n,"indices","sparseFillEmptyRows","int32"),i=j(e,"values","sparseFillEmptyRows"),o=j(t,"denseShape","sparseFillEmptyRows","int32"),a=j(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:i,denseShape:o,defaultValue:a},c=ce.runKernel(SM,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const T1e=he({sparseFillEmptyRows_:k1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1e(n,e,t){const r=j(n,"inputIndices","sparseReshape","int32"),s=j(e,"inputShape","sparseReshape","int32"),i=j(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:r,inputShape:s,newShape:i},a=ce.runKernel(_M,o);return{outputIndices:a[0],outputShape:a[1]}}const I1e=he({sparseReshape_:E1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(n,e,t){const r=j(n,"data","sparseSegmentMean"),s=j(e,"indices","sparseSegmentMean","int32"),i=j(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return ce.runKernel(M2,o)}const M1e=he({sparseSegmentMean_:A1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(n,e,t){const r=j(n,"data","sparseSegmentSum"),s=j(e,"indices","sparseSegmentSum","int32"),i=j(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return ce.runKernel(N2,o)}const $1e=he({sparseSegmentSum_:N1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1e(n,e,t,r,s,i,o,a){const l=j(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=j(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},f=ce.runKernel(O2,h,u);return{nGrams:f[0],nGramsSplits:f[1]}}const P1e=he({stringNGrams_:R1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1e(n,e,t=!0){const r=j(n,"input","stringSplit","string"),s=j(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:t},o={input:r,delimiter:s},a=ce.runKernel(CM,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const O1e=he({stringSplit_:D1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1e(n,e){const t=j(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return ce.runKernel(kM,s,r)}const L1e=he({stringToHashBucketFast_:F1e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1e(n,e,t,r=!0){const s=j(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:r};return ce.runKernel(P2,{x:s},i)}const B1e=he({staticRegexReplace_:z1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tY={fft:GM,ifft:xS,rfft:HM,irfft:Sz},nY={hammingWindow:fxe,hannWindow:QK,frame:eY,stft:gxe},Si={flipLeftRight:wxe,grayscaleToRGB:Sxe,resizeNearestNeighbor:Xxe,resizeBilinear:jxe,rgbToGrayscale:Cxe,rotateWithOffset:Txe,cropAndResize:bxe,nonMaxSuppression:Ixe,nonMaxSuppressionAsync:Oxe,nonMaxSuppressionWithScore:Lxe,nonMaxSuppressionWithScoreAsync:Bxe,nonMaxSuppressionPadded:Uxe,nonMaxSuppressionPaddedAsync:Gxe,threshold:Zxe,transform:Qxe},Rz={bandPart:t1e,gramSchmidt:r1e,qr:i1e},rY={absoluteDifference:l1e,computeWeightedLoss:Gf,cosineDistance:u1e,hingeLoss:f1e,huberLoss:p1e,logLoss:g1e,meanSquaredError:b1e,sigmoidCrossEntropy:x1e,softmaxCrossEntropy:C1e},sY={sparseFillEmptyRows:T1e,sparseReshape:I1e,sparseSegmentMean:M1e,sparseSegmentSum:$1e},iY={stringNGrams:P1e,stringSplit:O1e,stringToHashBucketFast:L1e,staticRegexReplace:B1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V1e=new Map,xD=new Map;class Py{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Sl{constructor(){this.classNameMap={}}static getMap(){return Sl.instance==null&&(Sl.instance=new Sl),Sl.instance}static register(e){Sl.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function at(n,e,t){U(n.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),U(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return Sl.register(n),V1e.set(s,n),xD.set(n,s),n}function U1e(n){return xD.has(n)?xD.get(n):n.className}const W1e=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Py,SerializationMap:Sl,getRegisteredName:U1e,registerClass:at},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hf extends Py{minimize(e,t=!1,r){const{value:s,grads:i}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return nn(i),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return eK(e,t)}dispose(){this.iterations_!=null&&nn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:en(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Hf,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pz extends Hf{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=ce.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ce.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Se(()=>ar(i).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Se(()=>ar(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;Se(()=>{const u=qe(fe(l,this.rho),fe(Or(a),1-this.rho)),h=fe(Ft(wo(qe(c,this.epsilon)),wo(qe(l,this.epsilon))),a),f=qe(fe(c,this.rho),fe(Or(h),1-this.rho));l.assign(u),c.assign(f);const d=qe(fe(h,-this.learningRate),i);i.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nn(this.accumulatedGrads.map(e=>e.variable)),nn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dz extends Hf{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ce.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Se(()=>Ny(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[s].variable;Se(()=>{const l=qe(a,Or(o));a.assign(l);const c=qe(fe(Ft(o,wo(qe(l,ce.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oz extends Hf{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=en(t).variable(),this.accBeta2=en(r).variable()}),s==null&&(this.epsilon=ce.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Rt(1,this.accBeta1),s=Rt(1,this.accBeta2);t.forEach((i,o)=>{const a=ce.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Se(()=>ar(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:Se(()=>ar(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=qe(fe(u,this.beta1),fe(c,1-this.beta1)),d=qe(fe(h,this.beta2),fe(Or(c),1-this.beta2)),p=Ft(f,r),m=Ft(d,s);u.assign(f),h.assign(d);const g=qe(fe(Ft(p,qe(wo(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&nn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Se(()=>{this.accBeta1.assign(np(this.beta1,this.iterations_+1)),this.accBeta2.assign(np(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fz extends Hf{static get className(){return"Adamax"}constructor(e,t,r,s=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=en(0).variable(),this.accBeta1=en(t).variable()}),s==null&&(this.epsilon=ce.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Rt(1,this.accBeta1),s=Ft(-this.learningRate,qe(fe(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=ce.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ar(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:ar(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=qe(fe(u,this.beta1),fe(c,1-this.beta1)),d=fe(h,this.beta2),p=bi(c),m=Wf(d,p);u.assign(f),h.assign(m);const g=qe(fe(Ft(s,r),Ft(f,qe(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(qe(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&nn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tN extends Hf{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const o=ce.registeredVariables[r];Se(()=>{const a=qe(fe(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=qs(en(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lz extends tN{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=en(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ce.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Se(()=>ar(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&Se(()=>{let l;const c=qe(fe(this.m,o),a);this.useNesterov?l=qe(fe(this.c,qe(a,fe(c,this.m))),i):l=qe(fe(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zz extends Hf{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=ce.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ce.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Se(()=>ar(i).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Se(()=>ar(i).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Se(()=>ar(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;Se(()=>{const u=qe(fe(l,this.decay),fe(Or(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,f=qe(fe(h,this.decay),fe(a,1-this.decay)),d=Ft(fe(a,this.learningRate),wo(Rt(u,qe(Or(f),this.epsilon)))),p=qe(fe(c,this.momentum),d);l.assign(u),h.assign(f),c.assign(p);const m=Rt(i,p);i.assign(m)}else{const h=qe(fe(l,this.decay),fe(Or(a),1-this.decay)),f=qe(fe(c,this.momentum),Ft(fe(a,this.learningRate),wo(qe(h,this.epsilon))));l.assign(h),c.assign(f);const d=Rt(i,f);i.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&nn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G1e=[Pz,Dz,Oz,Fz,Lz,zz,tN];function H1e(){for(const n of G1e)at(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1e="model",q1e=".json",X1e=".weights.bin";function tG(n){return new Promise(e=>setTimeout(e)).then(n)}class ag{constructor(e){if(!Ee().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ag.URL_SCHEME)&&(e=e.slice(ag.URL_SCHEME.length)),(e==null||e.length===0)&&(e=j1e),this.modelJsonFileName=e+q1e,this.weightDataFileName=e+X1e}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Du.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=pX(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await tG(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await tG(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:W2(e)}}}}ag.URL_SCHEME="downloads://";class K1e{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=NL(i,c=>this.loadWeights(c));e(l)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;r(a)},i.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(i=>JW(i.name)),s={};for(const i of e)i.paths.forEach(o=>{const a=JW(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const Y1e=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ag.URL_SCHEME)?Z1e(n.slice(ag.URL_SCHEME.length)):null;_s.registerSaveRouter(Y1e);function Z1e(n="model"){return new ag(n)}function oY(n){return new K1e(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nG(n,e,t,r){o(n),t=t??0,r=r??1,a(t,r);let s=0;const i=l=>(l.then(c=>{const u=t+ ++s/n.length*(r-t);return e(u),c}),l);function o(l){U(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){U(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),U(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),U(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function aY(n,e){e==null&&(e={});const t=e.fetchFunc==null?Ee().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),s=0,i=.5,a=(e.onProgress==null?await Promise.all(r):await nG(r,e.onProgress,s,i)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await nG(a,e.onProgress,l,c)}async function J1e(n,e="",t,r){return lY(o=>aY(o,{requestInit:r}))(n,e,t)}function lY(n){return async(e,t="",r)=>{const s=e.map(()=>!1),i={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((d,p)=>{let m=0;d.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=dD[y]*Te(g.shape),x=()=>{s[p]=!0,i[p]==null&&(i[p]=[]),i[p].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,_)=>{w===g.name&&(x(),o[_]=!0)}):x(),a.push(g.name),m+=b})}),!o.every(d=>d)){const d=r.filter((p,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((d,p,m)=>(p&&d.push(m),d),[]),c=[];l.forEach(d=>{e[d].paths.forEach(p=>{const m=t+(t.endsWith("/")?"":"/")+p;c.push(m)})});const u=await n(c),h={};let f=0;return l.forEach(d=>{const p=e[d].paths.length,m=new Du(u.slice(f,f+p));i[d].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),x=IL(b,[y.manifestEntry]);for(const w in x)h[w]=x[w]}),f+=p}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q1e="application/octet-stream",eSe="application/json";class Bz{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(U(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ee().platform.fetch,U(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&U(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=pX(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:eSe}),"model.json"),e.weightData!=null){const o=Du.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:Q1e}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:W2(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return NL(t,i=>this.loadWeights(i))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=tSe(t),i=this.weightPathPrefix||r,o=$L(e),a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(i+h+s);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await aY(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,c]}}Bz.URL_SCHEME_REGEX=/^https?:\/\//;function tSe(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function SD(n){return n.match(Bz.URL_SCHEME_REGEX)!=null}const cY=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>SD(r)):t=SD(n),t)return nN(n,e)}return null};_s.registerSaveRouter(cY);_s.registerLoadRouter(cY);function nN(n,e){return new Bz(n,e)}function uY(n,e){return nN(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e3{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class hY{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class nSe{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function rSe(n,e,t,r){const s=arguments;return new nSe(CI(...s))}function CI(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new e3(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new e3({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new e3({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function fY(n){return new hY(n)}function sSe(n){return new hY(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vz=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Du,browserFiles:oY,browserHTTPRequest:uY,concatenateArrayBuffers:dX,copyModel:Eye,decodeWeights:IL,encodeWeights:pD,fromMemory:rSe,fromMemorySync:CI,getLoadHandlers:gX,getModelArtifactsForJSON:NL,getModelArtifactsForJSONSync:ML,getModelArtifactsInfoForJSON:W2,getSaveHandlers:mX,getWeightSpecs:$L,http:nN,isHTTPScheme:SD,listModels:RL,loadWeights:J1e,moveModel:Iye,registerLoadRouter:mye,registerSaveRouter:pye,removeModel:PL,weightsLoaderFactory:lY,withSaveHandler:fY,withSaveHandlerSync:sSe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iSe(n,e,t){const r=j(n,"labels","confusionMatrix"),s=j(e,"predictions","confusionMatrix");U(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),U(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),U(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),U(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),U(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const i=Hb(xt(r,"int32"),t),o=Hb(xt(s,"int32"),t),a=nr(i),l=jn(a,o);return xt(l,"int32")}const oSe=he({confusionMatrix_:iSe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aSe=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:oSe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qp,rG=!1;function dY(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(dS(hS,ce.backendName)!=null){const p={pixels:n},m={numChannels:e};return ce.runKernel(hS,p,m)}const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||t)h=n.data;else if(i||s||a){if(Qp==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Qp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Qp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Qp.canvas.width=c,Qp.canvas.height=u,Qp.drawImage(n,0,0,c,u),h=Qp.getImageData(0,0,c,u).data}let f;if(e===4)f=new Int32Array(h);else{const p=c*u;f=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)f[m*e+g]=h[m*4+g]}return Cz(f,[u,c,e],"int32")}function lSe(n){return n!=null&&n.data instanceof Uint8Array}function cSe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function uSe(n){return n!=null&&n.width!==0&&n.height!==0}function hSe(n){return cSe()&&!(n instanceof ImageBitmap)&&uSe(n)&&!lSe(n)}async function fSe(n,e=3){let t=null;if(Ee().getBool("WRAP_TO_IMAGEBITMAP")&&hSe(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?t=r:t=n}else t=n;return dY(t,e)}function pY(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function dSe(n){const e=(n==null?void 0:n.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function rC(n,e){let t=j(n,"img","toPixels");if(!(n instanceof qn)){const c=t;t=xt(c,"int32"),c.dispose()}pY(t);const[r,s]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const u=[0,0,0,255];for(let f=0;f<i;f++){const d=o[c*i+f];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);i===1?(u[0]=d*a,u[1]=d*a,u[2]=d*a):u[f]=d*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){rG||dS(o2,ce.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),rG=!0),e.width=s,e.height=r;const c=e.getContext("2d"),u=new ImageData(l,s,r);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}function pSe(n,e,t){let r=j(n,"img","draw");if(!(n instanceof qn)){const o=r;r=xt(o,"int32"),o.dispose()}pY(r),dSe(t==null?void 0:t.imageOptions);const s={image:r},i={canvas:e,options:t};ce.runKernel(o2,s,i)}const sC=he({fromPixels_:dY}),mSe=Object.freeze(Object.defineProperty({__proto__:null,draw:pSe,fromPixels:sC,fromPixelsAsync:fSe,toPixels:rC},Symbol.toStringTag,{value:"Module"}));function iC(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Te(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,i=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const a=n.shape,l=s.slice();l.pop();let c=1;for(let h=i;h<t;++h)c*=a[h],l.push(a[h]);const u=[...Jt(n.shape).map(h=>h/c),1].slice(0,i);return[l,o,c,u]}const gSe=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:iC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _D=-2,ySe=-1;function rN(n,e,t){const r=n.shape.length;U(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),U(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)U(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function bSe(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function sN(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function mY(n,e,t,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<t;i++)i===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function gY(n,e,t){return t<=n?t:t-(e-1)}function yY(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function vSe(n,e,t,r,s,i,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),f=new Array(c);if(e.length&&t>0){const d=e[0],p=t+1;u=bY(o,d,p,r,n),h=vY(a,d,p,s,n),f=mY(i,d,p,n)}else for(let d=0;d<c;d++)u[d]=xY(o,r,i,n,d,l),h[d]=SY(a,s,i,n,d,l),f[d]=wY(i,d,l);return{begin:u,end:h,strides:f}}function bY(n,e,t,r,s){const i=[...s],o=yY(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=gY(e,t,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function vY(n,e,t,r,s){const i=[...s],o=yY(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=gY(e,t,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=Zd(0,i[a],s[a])}return i}function wY(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function xY(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=Zd(0,o,l-1),o}function SY(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),a>0?o=Zd(0,o,l):o=Zd(-1,o,l-1),o}function Uz(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function Wz(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function oC(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{U(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(s).fill(-1):typeof t=="number"?i=[t,...new Array(s-1).fill(-1)]:t.length<s?i=t.concat(new Array(s-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(U(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function iN(n,e,t,r,s,i,o,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let x=0;x<h.dims;x++)u&&1<<x&a&&h.numAddAxisAfterEllipsis++,1<<x&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};wSe(h,f);let d=!0,p=!0,m=!0;const g=[],y=[];for(let x=0;x<n.length;++x){if(f.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const w=!!(f.shrinkAxisMask&1<<x),_=n[x];if(_===-1){g.push(w?1:-1);continue}const C=[f.beginMask&1<<x,f.endMask&1<<x],k=[f.strides[x]>0?0:-1,f.strides[x]>0?_:_-1];if(w&&f.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&f.strides[x]===1;const A=!!(f.beginMask&1<<x&&f.endMask&1<<x);if(f.beginValid&&f.endValid){if(w){const O=f.begin[x]<0?_+f.begin[x]:f.begin[x];if(f.begin[x]=O,f.end[x]=f.begin[x]+1,O<0||O>=_)throw Error(`slice index ${f.begin[x]} of dimension ${x} out of bounds.`)}else f.begin[x]=sG(f.begin[x],0,f.strides[x],_,C,k),f.end[x]=sG(f.end[x],1,f.strides[x],_,C,k);const N=f.strides[x]===1&&f.begin[x]===0&&f.end[x]===_;d=d&&N,p=p&&(x===0&&f.strides[x]===1||N)}else d=d&&f.strides[x]===1&&A,p=p&&(x===0&&f.strides[x]===1||A);let M,I=!1;if(f.beginValid&&f.endValid?(M=f.end[x]-f.begin[x],I=!0):w?(M=1,I=!0):A&&_>=0&&(f.strides[x]<0?M=-_:M=_,I=!0),I){let N;M===0||M<0!=f.strides[x]<0?N=0:N=Math.trunc(M/f.strides[x])+(M%f.strides[x]!==0?1:0),g.push(N)}else g.push(-1)}for(let x=0;x<f.finalShapeGatherIndices.length;++x){const w=f.finalShapeGatherIndices[x];w>=0?y.push(g[w]):w===_D&&y.push(1)}return{finalShapeSparse:y.filter((x,w)=>f.finalShapeGatherIndices[w]!==_D),finalShape:y,isIdentity:d,sliceDim0:p,isSimpleSlice:m,begin:f.begin,end:f.end,strides:f.strides}}function wSe(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(_D),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(ySe),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function sG(n,e,t,r,s,i){if(s[e])return t>0?i[e]:i[e+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const _Y=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:rN,computeFlatOffset:Wz,computeOutShape:sN,getNormalizedAxes:vSe,isSliceContinous:Uz,maskToAxes:bSe,parseSliceParams:oC,sliceInfo:iN,startForAxis:xY,startIndicesWithElidedDims:bY,stopForAxis:SY,stopIndicesWithElidedDims:vY,stridesForAxis:wY,stridesWithElidedDims:mY},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const xSe="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CY{static sgd(e){return new tN(e)}static momentum(e,t,r=!1){return new Lz(e,t,r)}static rmsprop(e,t=.9,r=0,s=null,i=!1){return new zz(e,t,r,s,i)}static adam(e=.001,t=.9,r=.999,s=null){return new Oz(e,t,r,s)}static adadelta(e=.001,t=.95,r=null){return new Pz(e,t,r)}static adamax(e=.002,t=.9,r=.999,s=null,i=0){return new Fz(e,t,r,s,i)}static adagrad(e,t=.1){return new Dz(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sd=CY;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SSe=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function Gz(){return new Promise(n=>SSe(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oN(n,e){const t=n[0].length;n.forEach((s,i)=>{U(s.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),U(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<t;o++)U(o===e||s[o]===r[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function ga(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ou;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(ou||(ou={}));function kY(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const i=t[s],o=r[r.length-t.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function TY(n){const e={FIRST_DIM_SIZE:ou.FIRST_DIM_SIZE,VALUE_ROWIDS:ou.VALUE_ROWIDS,ROW_LENGTHS:ou.ROW_LENGTHS,ROW_SPLITS:ou.ROW_SPLITS,ROW_LIMITS:ou.ROW_LIMITS,ROW_STARTS:ou.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function EY(n){return n.length===0?0:n[0]===ou.FIRST_DIM_SIZE?n.length-1:n.length}function IY(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const i=n[s],o=e[s+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hz=30;function aN(n){return n<=Hz?n:gI(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lN(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dy(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/e[o],e[o]]);s=s.concat(n.slice(i+1))}return s}function Oy(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Fy(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?r?s.push(e[i-1]*n[i]):s.push(n[i]/e[i-1]):s.push(n[i]);return s}function cN(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function uN(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aC=1.7580993408473768,lC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hN=.3275911,fN=.254829592,dN=-.284496736,pN=1.421413741,mN=-1.453152027,gN=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xu(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function AY(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function MY(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function NY(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function jz(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function $Y(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function RY(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:t,imag:r}}function PY(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),i=Math.sin(r);return{real:s,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t3="->",_Se=/->/g,iG=",",oG="...";function yN(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(_Se,"").length)/t3.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${t3}").`);const[r,s]=n.split(t3);U(r.indexOf(oG)===-1,()=>`The ellipsis notation ("${oG}") is not supported yet.`);const i=r.split(iG),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<s.length;++f){const d=s[f];if(!i.some(p=>p.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){const d=r[f];a.indexOf(d)===-1&&d!==iG&&a.push(d)}const l=new Array(i.length);for(let f=0;f<o;++f){if(new Set(i[f].split("")).size!==i[f].length)throw new Error(`Found duplicate axes in input component ${i[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<i[f].length;++d)l[f].push(a.indexOf(i[f][d]))}const c=a.length,u=s.length,h=[];for(let f=u;f<c;++f)h.push(f);return{allDims:a,summedDims:h,idDims:l}}function bN(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function vN(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const i=t[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=i[o]:U(r[e[s][o]]===i[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function wN(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=CSe(e,a);for(const c of l)i.indexOf(c)===-1&&(r[o].push(c),i.push(c))}return{path:t,steps:r}}function xN(n){return n.every((e,t)=>e===t)}function CSe(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function SN(n,e,t=0){let r=[];if(typeof e=="number")U(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);U(s<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}U(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DY(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function OY(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function FY(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LY(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function zY(n,e){return`size ${n} must be non-negative, not ${e}`}function BY(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function VY(n,e){const t=Te(n),r=Te(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function UY(n,e){const t=Te(n),r=Te(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CD(){return"segment ids must be >= 0"}function WY(){return"segment ids are not increasing"}function GY(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function HY(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jY(n,e){let t=!1,r;for(n<=Hz?(r=n,t=!0):r=gI(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=gI(n,r+1);return r}function qz(n,e,t){const r=[],s=n.length;for(let i=0;i<s;i++)i!==e?r.push(n[i]):r.push(t);return r}function _N(n,e,t,r){const s=e.shape.length,i=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=t+1;h<i;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const kSe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:_N,computeOutShape:qz,segOpComputeOptimalWindowSize:jY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(n){try{return n.map(e=>kc(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function qY(n){return n.map(e=>gu(e))}const XY=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:fN,ERF_A2:dN,ERF_A3:pN,ERF_A4:mN,ERF_A5:gN,ERF_P:hN,PARALLELIZE_THRESHOLD:Hz,get RowPartitionType(){return ou},SELU_SCALE:lC,SELU_SCALEALPHA:aC,applyActivation:JM,assertAndGetBroadcastShape:ln,assertAxesAreInnerMostDims:ui,assertParamsConsistent:oN,assignToTypedArray:$Y,axesAreInnerMostDims:tz,calculateShapes:Fu,checkEinsumDimSizes:vN,checkPadOnDimRoundingMode:Jo,combineLocations:HX,combineRaggedTensorToTensorShapes:kY,complexWithEvenIndex:MY,complexWithOddIndex:NY,computeConv2DInfo:ns,computeConv3DInfo:Ou,computeDefaultPad:LL,computeDilation2DInfo:kp,computeOptimalWindowSize:aN,computeOutAndReduceShapes:Js,computeOutShape:ga,computePool2DInfo:_o,computePool3DInfo:zl,convertConv2DDataFormat:Qa,decodeEinsumEquation:yN,eitherStridesOrDilationsAreOne:Ni,expandShapeToKeepDim:Ls,exponent:PY,exponents:RY,fromStringArrayToUint8:qY,fromUint8ToStringArray:Su,getAxesPermutation:Lr,getBroadcastDims:Df,getComplexWithIndex:jz,getEinsumComputePath:wN,getEinsumPermutation:bN,getFusedBiasGradient:ZM,getFusedDyActivation:YM,getImageCenter:lN,getInnerMostAxes:rs,getPermuted:Oy,getRaggedRank:EY,getReductionAxes:ci,getReshaped:Dy,getReshapedPermuted:Fy,getRowPartitionTypesHelper:TY,getSliceBeginCoords:cN,getSliceSize:uN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:DY,getSparseFillEmptyRowsNegativeIndexErrorMessage:OY,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:FY,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:BY,getSparseReshapeInputOutputMismatchErrorMessage:UY,getSparseReshapeInputOutputMultipleErrorMessage:VY,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:LY,getSparseReshapeNegativeOutputDimErrorMessage:zY,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:HY,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:CD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:WY,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:GY,getUndoAxesPermutation:Rh,isIdentityPermutation:xN,log:Ige,mergeRealAndImagArrays:xu,prepareAndValidate:iC,prepareSplitSize:SN,segment_util:kSe,shouldFuse:QM,slice_util:_Y,splitRealAndImagArrays:AY,stridesOrDilationsArePositive:ig,tupleValuesAreOne:ep,upcastType:Ii,validateDefaultValueShape:IY,validateInput:jM,validateUpdateShape:kz,warn:xl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TSe=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:tC,nonMaxSuppressionV4Impl:eN,nonMaxSuppressionV5Impl:nC,whereImpl:XM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */H1e();const KY=Object.freeze(Object.defineProperty({__proto__:null,Abs:_v,Acos:Pg,Acosh:Dg,AdadeltaOptimizer:Pz,AdagradOptimizer:Dz,AdamOptimizer:Oz,AdamaxOptimizer:Fz,Add:Sp,AddN:Cv,All:U_,Any:W_,ArgMax:kv,ArgMin:Tv,Asin:Og,Asinh:Fg,Atan:Lg,Atan2:Bg,Atanh:zg,AvgPool:Ev,AvgPool3D:Iv,AvgPool3DGrad:H_,AvgPoolGrad:G_,BatchMatMul:Av,BatchToSpaceND:Mv,Bincount:j_,BitwiseAnd:q_,BroadcastArgs:X_,BroadcastTo:q7,Cast:Vg,Ceil:Ug,ClipByValue:Wg,Complex:K_,ComplexAbs:Nv,Concat:$v,Conv2D:Rv,Conv2DBackpropFilter:Y_,Conv2DBackpropInput:Pv,Conv3D:Dv,Conv3DBackpropFilterV2:Z_,Conv3DBackpropInputV2:J_,Cos:Gg,Cosh:Hg,CropAndResize:e2,Cumprod:Q_,Cumsum:Ov,DataStorage:dM,DenseBincount:t2,DepthToSpace:n2,DepthwiseConv2dNative:Fv,DepthwiseConv2dNativeBackpropFilter:r2,DepthwiseConv2dNativeBackpropInput:s2,Diag:i2,Dilation2D:Lv,Dilation2DBackpropFilter:uS,Dilation2DBackpropInput:cS,Draw:o2,get ENV(){return wL},Einsum:a2,Elu:qg,EluGrad:l2,Environment:H7,Equal:zv,Erf:Xg,Exp:Kg,ExpandDims:Bv,Expm1:Yg,FFT:c2,Fill:u2,FlipLeftRight:h2,Floor:Zg,FloorDiv:Jg,FromPixels:hS,FusedBatchNorm:Vv,FusedConv2D:zb,FusedDepthwiseConv2D:Bb,GatherNd:f2,GatherV2:Uv,Greater:Wv,GreaterEqual:Qg,IFFT:d2,Identity:ey,Imag:p2,IsFinite:ty,IsInf:ny,IsNan:ry,KernelBackend:V_,LRN:Yv,LRNGrad:g2,LeakyRelu:Gv,Less:Hv,LessEqual:jv,LinSpace:m2,Log:sy,Log1p:iy,LogSoftmax:X7,LogicalAnd:qv,LogicalNot:Xv,LogicalOr:Kv,LogicalXor:_ge,LowerBound:Cge,MatrixBandPart:kge,Max:Zv,MaxPool:Jv,MaxPool3D:Qv,MaxPool3DGrad:b2,MaxPoolGrad:y2,MaxPoolWithArgmax:v2,Maximum:oy,Mean:ew,Min:tw,Minimum:ay,MirrorPad:nw,Mod:ly,MomentumOptimizer:Lz,Multinomial:w2,Multiply:cy,Neg:rw,NonMaxSuppressionV3:x2,NonMaxSuppressionV4:bM,NonMaxSuppressionV5:S2,NotEqual:sw,OP_SCOPE_SUFFIX:EL,OneHot:ow,OnesLike:iw,Optimizer:Hf,OptimizerConstructors:CY,Pack:aw,PadV2:lw,Pool:Tge,Pow:uy,Prelu:cw,Prod:uw,RMSPropOptimizer:zz,RaggedGather:vM,RaggedRange:wM,RaggedTensorToTensor:xM,Range:_2,get Rank(){return oD},Real:C2,RealDiv:jg,Reciprocal:hy,get Reduction(){return Bo},Relu:fy,Relu6:dy,Reshape:hw,ResizeBilinear:dw,ResizeBilinearGrad:T2,ResizeNearestNeighbor:fw,ResizeNearestNeighborGrad:k2,Reverse:pw,RotateWithOffset:z2,Round:py,Rsqrt:my,SGDOptimizer:tN,ScatterNd:E2,SearchSorted:A2,Select:mw,Selu:gy,Sigmoid:wy,Sign:vy,Sin:yy,Sinh:by,Slice:gw,Softmax:ww,Softplus:xy,SpaceToBatchND:bw,SparseFillEmptyRows:SM,SparseReshape:_M,SparseSegmentMean:M2,SparseSegmentSum:N2,SparseToDense:$2,SplitV:vw,Sqrt:Sy,Square:R2,SquaredDifference:_y,StaticRegexReplace:P2,Step:Iy,StridedSlice:D2,StringNGrams:O2,StringSplit:CM,StringToHashBucketFast:kM,Sub:Cy,Sum:yw,Tan:ky,Tanh:Ty,Tensor:qn,TensorBuffer:ai,TensorScatterUpdate:I2,Tile:Ey,TopK:F2,Transform:L2,Transpose:Bd,Unique:TM,Unpack:xw,UnsortedSegmentSum:Sw,UpperBound:Ege,Variable:pS,ZerosLike:_w,_FusedMatMul:Lb,abs:bi,acos:CX,acosh:kX,add:qe,addN:TX,all:FL,any:xI,argMax:sg,argMin:EX,asin:IX,asinh:AX,atan:MX,atan2:NX,atanh:$X,avgPool:AM,avgPool3d:zL,backend:rg,backend_util:XY,basicLSTMCell:RX,batchNorm:H2,batchNorm2d:BL,batchNorm3d:VL,batchNorm4d:UL,batchToSpaceND:MM,bincount:WL,bitwiseAnd:PX,booleanMaskAsync:WK,broadcastArgs:DX,broadcastTo:Tb,broadcast_util:tbe,browser:mSe,buffer:wn,cast:xt,ceil:OX,clipByValue:va,clone:mh,complex:Pf,concat:cs,concat1d:GL,concat2d:HL,concat3d:jL,concat4d:qL,conv1d:XL,conv2d:tp,conv2dTranspose:YL,conv3d:ZL,conv3dTranspose:JL,copyRegisteredKernels:Nge,cos:NM,cosh:QL,cosineWindow:KM,cumprod:SI,cumsum:ez,customGrad:xh,denseBincount:_I,deprecationWarn:Lye,depthToSpace:LX,depthwiseConv2d:j2,device_util:sye,diag:zX,dilation2d:BX,disableDeprecationWarnings:Fye,dispose:nn,disposeVariables:zye,div:Ft,divNoNan:VX,dot:UX,dropout:Az,einsum:Im,elu:q2,enableDebugMode:Oye,enableProdMode:Dye,enclosingPowerOfTwo:Mz,engine:bo,ensureShape:WX,env:Ee,equal:vu,erf:GX,euclideanNorm:qX,exp:Xo,expandDims:ii,expm1:XX,eye:$M,fft:GM,fill:Ny,findBackend:Gye,findBackendFactory:Hye,floor:X2,floorDiv:OL,fused:JK,gather:K2,gatherND:qK,gather_util:gSe,getBackend:gS,getGradient:rD,getKernel:dS,getKernelsForBackend:yI,grad:Lbe,grads:zbe,greater:el,greaterEqual:Tp,ifft:xS,imag:Y2,image:Si,inTopKAsync:XK,io:Vz,irfft:Sz,isFinite:KX,isInf:YX,isNaN:ZX,keep:qs,kernel_impls:TSe,leakyRelu:RM,less:wS,lessEqual:$y,linalg:Rz,linspace:JX,localResponseNormalization:QX,log:$l,log1p:PM,logSigmoid:tK,logSoftmax:nz,logSumExp:OM,logicalAnd:Sh,logicalNot:FM,logicalOr:rz,logicalXor:nK,losses:rY,lowerBound:rK,matMul:jn,math:aSe,max:Sc,maxPool:zM,maxPool3d:sz,maxPoolWithArgmax:sK,maximum:Wf,mean:Os,memory:wI,meshgrid:iK,min:vS,minimum:rp,mirrorPad:iz,mod:oK,moments:Z2,movingAverage:GK,mul:fe,multiRNNCell:aK,multinomial:lK,neg:us,nextFrame:Gz,norm:Cw,notEqual:Gb,oneHot:Hb,ones:da,onesLike:Rl,op:he,outerProduct:cK,pad:wu,pad1d:uK,pad2d:hK,pad3d:fK,pad4d:dK,pool:pK,pow:np,prelu:VM,print:DL,prod:mK,profile:Bye,raggedGather:gK,raggedRange:yK,raggedTensorToTensor:bK,rand:vK,randomGamma:CK,randomNormal:UM,randomStandardNormal:kK,randomUniform:Ep,randomUniformInt:TK,range:og,ready:G2,real:jb,reciprocal:EK,registerBackend:IM,registerGradient:K7,registerKernel:B2,relu:Ph,relu6:mz,removeBackend:Wye,reshape:ve,reverse:Ec,reverse1d:IK,reverse2d:AK,reverse3d:MK,reverse4d:NK,rfft:HM,round:gz,rsqrt:yz,scalar:en,scatterND:HK,scatter_util:Bwe,searchSorted:LM,selu:bz,separableConv2d:vz,serialization:W1e,setBackend:Uye,setPlatform:jye,setdiff1dAsync:$K,sigmoid:Il,sign:RK,signal:nY,sin:wz,sinh:xz,slice:fn,slice1d:J2,slice2d:WM,slice3d:Q2,slice4d:qb,slice_util:_Y,softmax:eC,softplus:kw,spaceToBatchND:BM,sparse:sY,sparseToDense:jK,spectral:tY,split:Wa,sqrt:wo,square:Or,squaredDifference:_z,squeeze:gr,stack:wa,step:Ew,stridedSlice:PK,string:iY,sub:Rt,sum:Yt,sumOutType:U2,tan:DK,tanh:Wb,tensor:ki,tensor1d:Xs,tensor2d:Ga,tensor3d:Cz,tensor4d:OK,tensor5d:FK,tensor6d:LK,tensorScatterUpdate:zK,tensor_util:Qge,test_util:Qve,tidy:Se,tile:gc,time:Vye,topk:BK,train:Sd,transpose:nr,truncatedNormal:qM,unique:VK,unregisterGradient:Mge,unregisterKernel:Age,unsortedSegmentSum:Tz,unstack:Ic,upcastType:Ii,upperBound:UK,util:Bge,valueAndGrad:Bbe,valueAndGrads:Vbe,variable:Ez,variableGrads:eK,version_core:xSe,where:vo,whereAsync:Iz,zeros:ms,zerosLike:ar},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ESe=XM;class CN extends V_{nextDataId(){return CN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new dM(this,bo())}write(e,t,r){this.firstUse&&(this.firstUse=!1,Ee().get("IS_NODE")&&xl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&uu(r[0])){const i=r.map(o=>gu(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,r,s,i){this.data.set(e,{values:t,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);if(t==="complex64"){const s=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return xu(s,i)}return H1(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>kc(s));return wn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return wn(e.shape,e.dtype,t)}makeOutput(e,t,r){return bo().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=ro();return e(),{kernelMs:ro()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Zt([e],"where");const t=this.readSync(e.dataId);return ESe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}CN.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const ISe=n=>{const{x:e}=n.inputs,t=n.backend;Zt(e,"abs");let r=new Float32Array(Te(e.shape));const s=t.data.get(e.dataId).values;return r=YY(s),t.makeOutput(r,e.shape,e.dtype)},ASe={kernelName:_v,backendName:"cpu",kernelFunc:ISe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qs(n){return(e,t,r,s,i)=>{const o=ln(e,t),a=o.length,l=Jt(o),c=Te(o),u=li(i,c),h=e.length,f=t.length,d=Jt(e),p=Jt(t),m=Df(e,o),g=Df(t,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<u.length;++y){const b=Rg(y,a,l),x=b.slice(-h);m.forEach(k=>x[k]=0);const w=mu(x,h,d),_=b.slice(-f);g.forEach(k=>_[k]=0);const C=mu(_,f,p);u[y]=n(r[w],s[C])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function za(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",i),imag:t.makeTensorInfo(s.shape,"float32",o)},a}const MSe={kernelName:K_,backendName:"cpu",kernelFunc:za};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(n,e,t="float32"){if(t==="complex64"){const s=kI(n,e,"float32"),i=kI(n,e,"float32");return za({inputs:{real:s,imag:i},backend:n})}const r=Hi(Te(e),t);return n.makeTensorInfo(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _h(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const NSe={kernelName:ey,backendName:"cpu",kernelFunc:_h};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lg(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.real,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const $Se={kernelName:C2,backendName:"cpu",kernelFunc:lg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=_p([0],t),[i,o]=Qs((a,l)=>a!==l?1:0)(e,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function sp(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return _h({inputs:{x:s},backend:t});const u=kI(t,s.shape,s.dtype),h=sp({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),f=za({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),f}if(s.dtype==="complex64"){const u=lg({inputs:{input:s},backend:t}),h=sp({inputs:{x:u},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(u),h}if(!gM(s.dtype,i)){const u=_h({inputs:{x:s},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=t.data.get(s.dataId).values,[a,l,c]=ZY(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}const RSe={kernelName:Vg,backendName:"cpu",kernelFunc:sp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $i(n,e,t,r){return t==null?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Zt([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?Su(c):c,f=o.dtype==="string"?Su(u):u,d=r||o.dtype,[p,m]=e(o.shape,a.shape,h,f,d);return l.makeTensorInfo(m,d,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=sp({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,d=l.data.get(h.dataId).values,p=l.data.get(f.dataId).values,m=sp({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[_,C,k]=t(o.shape,a.shape,d,p,x,w),A=l.makeTensorInfo(k,"float32",_),M=l.makeTensorInfo(k,"float32",C),I=za({inputs:{real:A,imag:M},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(M),I}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=r||o.dtype,[f,d]=e(o.shape,a.shape,c,u,h);return l.makeTensorInfo(d,h,f)}}}function Xz(n){return(e,t,r,s,i,o)=>{const a=ln(e,t),l=Te(a),c=a.length,u=Jt(a),h=li("float32",l),f=li("float32",l),d=Df(e,a),p=Df(t,a),m=xu(r,s),g=xu(i,o),y=e.length,b=Jt(e),x=t.length,w=Jt(t);if(d.length+p.length===0)for(let _=0;_<h.length;_++){const C=_%m.length,k=_%g.length,A=n(m[C*2],m[C*2+1],g[k*2],g[k*2+1]);h[_]=A.real,f[_]=A.imag}else for(let _=0;_<h.length;_++){const C=Rg(_,c,u),k=C.slice(-y);d.forEach(O=>k[O]=0);const A=mu(k,y,b),M=C.slice(-x);p.forEach(O=>M[O]=0);const I=mu(M,x,w),N=n(m[A*2],m[A*2+1],g[I*2],g[I*2+1]);h[_]=N.real,f[_]=N.imag}return[h,f,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JY=Qs((n,e)=>n+e),PSe=Xz((n,e,t,r)=>({real:n+t,imag:e+r})),Xb=$i(Sp,JY,PSe),DSe={kernelName:Sp,backendName:"cpu",kernelFunc:Xb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kz(n,e,t,r,s){const i=Te(r),o=Hi(s,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function QY(n,e,t,r=!1){const s=n.shape[0],i=n.shape[1],o=wn([s,t],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(r?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eZ=Qs((n,e)=>n&e),OSe=$i(q_,eZ),FSe={kernelName:q_,backendName:"cpu",kernelFunc:OSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dh(n){return(e,t,r)=>{const s=Cs(t,e.length);for(let i=0;i<e.length;++i)s[i]=n(e[i],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n,e,t){const r=Dh(e);return Ip(n,r,t)}function Ip(n,e,t){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;Zt(o,n);const a=i,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Su(l)}else c=l;const u=t||o.dtype,h=e(c,u,s);return a.makeTensorInfo(o.shape,u,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tZ=Dh(n=>Math.ceil(n)),LSe=Ip(Ug,tZ),zSe={kernelName:Ug,backendName:"cpu",kernelFunc:LSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nZ(n,e,t,r){const s=Cs(t,Te(e));if(r&&t!=="string"){let i=0;n.forEach(o=>{const a=Te(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?Su(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+i;for(let h=0;h<o.shape[1];++h)s[u+h]=a[l++]}i+=o.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rZ=Qs((n,e)=>n===e?1:0),sZ=$i(zv,rZ,null,"bool"),BSe={kernelName:zv,backendName:"cpu",kernelFunc:sZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iZ=Dh(n=>Math.exp(n)),oZ=Ip(Kg,iZ,"float32"),VSe={kernelName:Kg,backendName:"cpu",kernelFunc:oZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aZ=Dh(n=>Math.expm1(n)),USe=Ip(Yg,aZ),WSe={kernelName:Yg,backendName:"cpu",kernelFunc:USe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lZ=Dh(n=>Math.floor(n)),GSe=Ip(Zg,lZ),HSe={kernelName:Zg,backendName:"cpu",kernelFunc:GSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cZ=Qs((n,e)=>Math.floor(n/e)),jSe=$i(Jg,cZ,null,"int32"),qSe={kernelName:Jg,backendName:"cpu",kernelFunc:jSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(n,e,t,r,s,i,o,a,l){const c=wn([r,i],t);for(let u=0;u<r;u++){const h=[];let f=0;for(let d=0;d<s;d++){const p=n[u*s+d];f+=p*o[d],h.push(p)}if(f<0||f>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<i;d++)c.values[u*i+d]=e.get(...e.indexToLoc(f*i+d))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(n,e,t){const r=wn(t,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fZ=Qs((n,e)=>n>e?1:0),XSe=$i(Wv,fZ,null,"bool"),KSe={kernelName:Wv,backendName:"cpu",kernelFunc:XSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dZ=Qs((n,e)=>n>=e?1:0),YSe=$i(Qg,dZ,null,"bool"),ZSe={kernelName:Qg,backendName:"cpu",kernelFunc:YSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pZ=Qs((n,e)=>n<e?1:0),JSe=$i(Hv,pZ,null,"bool"),QSe={kernelName:Hv,backendName:"cpu",kernelFunc:JSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZ=Qs((n,e)=>n<=e?1:0),e_e=$i(jv,mZ,null,"bool"),t_e={kernelName:jv,backendName:"cpu",kernelFunc:e_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(n,e,t){const r=(e-n)/(t-1),s=Hi(t,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZ=Dh(n=>Math.log(n)),n_e=Ip(sy,yZ),r_e={kernelName:sy,backendName:"cpu",kernelFunc:n_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bZ(n,e,t,r){const s=li(r,Te(t));for(let i=0;i<s.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vZ=Qs((n,e)=>Math.max(n,e)),s_e=$i(oy,vZ),i_e={kernelName:oy,backendName:"cpu",kernelFunc:s_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wZ=Qs((n,e)=>Math.min(n,e)),o_e=$i(ay,wZ),a_e={kernelName:ay,backendName:"cpu",kernelFunc:o_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yz=Qs((n,e)=>n*e),l_e=Xz((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),kN=$i(cy,Yz,l_e),c_e={kernelName:cy,backendName:"cpu",kernelFunc:kN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xZ(n,e,t){const r=Uf(-1,t);return Yz([],e,r,n,t)}function u_e(n){const{inputs:e,backend:t}=n,{x:r}=e;Zt(r,"neg");const s=t.data.get(r.dataId).values,[i,o]=xZ(s,r.shape,r.dtype);return t.makeTensorInfo(o,r.dtype,i)}const h_e={kernelName:rw,backendName:"cpu",kernelFunc:u_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ=Qs((n,e)=>n!==e?1:0),f_e=$i(sw,SZ,null,"bool"),d_e={kernelName:sw,backendName:"cpu",kernelFunc:f_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zz(n,e,t,r,s){const i=e.length,o=Te(e),a=Jt(e),l=Jt(s),c=li(t,Te(s));for(let u=0;u<o;++u){const h=Rg(u,i,a),f=new Array(h.length);for(let p=0;p<f.length;p++)f[p]=h[r[p]];const d=mu(f,i,l);c[d]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{perm:i}=t;Zt(s,"transpose");const o=s.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=s.shape[i[h]];const l=r.data.get(s.dataId).values,c=Zz(l,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const p_e={kernelName:Bd,backendName:"cpu",kernelFunc:xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Z(n,e,t,r){const[s,i]=Js(n,r),o=Ii(e,"int32"),a=Hi(Te(s),o),l=Te(i);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let f=0;f<l;++f)h*=t[u+f];a[c]=h}return{outVals:a,outShape:s,outDtype:o}}function m_e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"prod");const a=s.shape.length,l=Tn(i,s.shape),c=Lr(l,a);let u=l,h=s;const f=[];c!=null&&(h=xa({inputs:{x:s},backend:t,attrs:{perm:c}}),f.push(h),u=rs(u.length,a));const d=t.data.get(h.dataId).values,{outVals:p,outShape:m,outDtype:g}=_Z(h.shape,h.dtype,d,u);let y=m;return o&&(y=Ls(m,l)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(y,g,p)}const g_e={kernelName:uw,backendName:"cpu",kernelFunc:m_e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_e(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const i=Rg(s,e.length,Jt(e)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${t})`)}})}function b_e(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function v_e(n,e,t,r){const s=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);b_e(t,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let f=0;f<t.length;++f){const d=t[f],p=f+e.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-d[u];for(let y=u;y<h;++y)a[p].push(d[y+1]+g)}u=d[u],h=d[h]}h!==u&&(s.push([u,h]),i+=h-u)}return{outSplits:a,valueSlices:s,numValues:i}}function w_e(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=Cs("int32",r);e.push(s),n[t].forEach((i,o)=>s[o]=i)}return e}function aG(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function x_e(n,e,t,r,s,i){const o=aG(e,2)[1],a=aG(i,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<r;++h)s[l*a+h]=n[u*o+h];++l}}function S_e(n,e,t,r,s){const i=e.slice();i[0]=s;const o=Cs(t,Te(i)),a=n.length,l=a===0?0:a/e[0];return x_e(n,e,r,l,o,i),[o,i]}function CZ(n,e,t,r,s,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(y_e(i,o,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:h,numValues:f}=v_e(i,o,n,c),d=w_e(u),p=S_e(t,r,s,h,f);return[d,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lG=2147483647;function kZ(n,e,t,r,s,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(s[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],f=Cs("int32",h+1);f[0]=0;for(let g=0;g<h;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],x=c?i[0]:i[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&b<y||x<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/x)),w>lG)throw new Error(`Requires ((limit - start) / delta) <= ${lG}`);f[g+1]=f[g]+w}const d=f[h],p=Cs(t,d);let m=0;for(let g=0;g<h;++g){const y=f[g+1]-f[g];let b=a?n[0]:n[g];const x=c?i[0]:i[g];for(let w=0;w<y;++w)p[m++]=b,b+=x}return[f,p]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ql=ou;class TI{constructor(e,t,r,s,i,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=TY(u),this.raggedRank=EY(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ql.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ql.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ql.VALUE_ROWIDS:return TI.getMaxWidthValueRowID(t);case Ql.ROW_SPLITS:return TI.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ql[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const i=e[s+1]-e[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(t-r,i)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return uG(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;IY(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=kY(this.raggedRank,s,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),i=[];let o=0;for(let a=0;a<s;++a,o+=t)i.push(o);for(let a=s;a<e;++a)i.push(-1);return U(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,r,s){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let c=Math.min(s,l),u=t[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=r;for(let h=0;h<l-c;++h)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,r,s){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<i;++u){const h=e[u];if(h===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,r,s){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Ql.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,r,s);case Ql.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,r,s);default:throw new Error(`Unsupported partition type: ${Ql[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Ql.FIRST_DIM_SIZE:return e[0];case Ql.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ql.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ql[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=uG(r,!1),o=Cs(this.valuesDType,Te(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,t,r,s){if(r.length===0)return;const i=this.values,o=r;let a=s.slice();a=a.slice(e+1);const l=Te(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const p=this.defaultValueShape;Se(()=>{const m=ve(u,p);u=Tb(m,a).dataSync()})}let h=0,f=0,d=0;for(let p=0;p<=c;++p){let m=p<c?t[p]:-1;if(m===d){++d;continue}if(f<d){const g=i.subarray(h*l),y=o.subarray(f*l),b=(d-f)*l;cG(y,g,b)}if(p>=c){const g=r.length;m=Math.floor(g/l)}if(m>d)if(this.defaultValue.length===1)o.subarray(d*l,m*l).fill(this.defaultValue[0]),d=m;else for(;m>d;){const g=o.slice(d*l);cG(g,u,l),++d}m<0?(h=p+1,f=d):(h=p,f=d,d=f+1)}}}function cG(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function uG(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function TZ(n,e,t,r,s,i,o,a,l,c){return new TI(n,e,t,r,s,i,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EZ(n,e,t,r){const s=n===e,i=n<e&&t<0,o=e<n&&t>1;if(s||i||o)return Hi(0,r);const a=Math.abs(Math.ceil((e-n)/t)),l=Hi(a,r);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZ=Dh(n=>1/Math.sqrt(n)),__e=Ip(my,IZ),C_e={kernelName:my,backendName:"cpu",kernelFunc:__e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Om(n,e,t,r,s,i,o,a,l,c){const u=[r/s,s],h=n.values,f=e.values;if(r===0)return wn(t,e.dtype);const d=l instanceof ai?l:wn(u,e.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let p=0;p<i;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=h[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<s;y++)c?d.values[g*s+y]+=f[p*s+y]:d.values[g*s+y]=e.rank===0?f[0]:f[p*s+y]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k_e=Dh(n=>1/(1+Math.exp(-n))),AZ=$r(wy,n=>1/(1+Math.exp(-n))),T_e={kernelName:wy,backendName:"cpu",kernelFunc:AZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MZ(n,e,t,r,s){const i=Uz(r,e,t),o=Te(t),a=Jt(r);if(i){const h=Wz(e,a);return s==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=s==="string"?Su(n):n,c=wn(r,s,l),u=wn(t,s);for(let h=0;h<u.size;++h){const f=u.indexToLoc(h),d=f.map((p,m)=>p+e[m]);u.set(c.get(...d),...f)}return s==="string"?qY(u.values):u.values}function cg(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r;Zt(s,"slice");const[a,l]=oC(s,i,o);rN(s,a,l);const c=t.data.get(s.dataId).values,u=MZ(c,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,u)}const E_e={kernelName:gw,backendName:"cpu",kernelFunc:cg};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NZ(n,e,t,r,s,i,o){const a=e[0],l=i[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(DY(a));const g=Cs(t,0),y=Cs(s,0);return[g,[0,h],y,c,u]}let f=!0,d=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*h];if(y<0)throw new Error(OY(g,y));if(y>=l)throw new Error(FY(g,y,l));++p[y],f=f&&y>=d,d=y}let m=!0;for(let g=0;g<l;++g){const y=p[g]===0;c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&f){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,h],y,c,u]}else{const g=p[l-1],y=Cs(t,g*h),b=Cs(s,g),x=new Array(l).fill(0);for(let w=0;w<a;++w){const _=n[w*h],C=x[_],k=(_===0?0:p[_-1])+C;x[_]++;for(let A=0;A<h;++A)y[k*h+A]=n[w*h+A];b[k]=r[w],u[w]=k}for(let w=0;w<l;++w)if(x[w]===0){const C=w===0?0:p[w-1];y[C*h+0]=w;for(let k=1;k<h;++k)y[C*h+k]=0;b[C]=o}return[y,[g,h],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n,e,t,r,s){const i=Te(r),o=e[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=s[g];if(y===-1){if(u!==-1)throw new Error(LY(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(zY(g,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(BY());const g=Math.trunc(i/c);if(c*g!==i)throw new Error(VY(r,l));l[u]=g}if(Te(l)!==i)throw new Error(UY(r,l));const f=r.length,d=[];if(f>0){d[f-1]=1;for(let g=f-2;g>=0;--g)d[g]=d[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Cs(t,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<f;++b)y+=n[g*f+b]*d[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jz(n,e,t,r,s,i=!1,o=0){const a=r.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(CD());const f=e.slice();f[0]=h;const d=f.reduce((x,w)=>x*w,1),p=Cs(t,d);if(a===0)return h>0&&p.fill(o),[p,f];if(h<=0)throw new Error(CD());let m=0,g=1,y=0,b=s[m];for(;;){let x=0;if(g<a){if(x=s[g],b===x){++g;continue}if(b>=x)throw new Error(WY())}if(b<0||b>=h)throw new Error(GY(b,h));b>y&&p.fill(o,y*c,b*c);for(let w=m;w<g;++w){const _=r[w];if(_<0||_>=l[0])throw new Error(HY(w,r[w],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[_*c+C]}if(i)for(let w=0;w<c;w++)p[b*c+w]/=g-m;if(m=g,++g,y=b+1,b=x,g>a)break}return y<h&&p.fill(o,y*c,h*c),[p,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I_e=Dh(n=>Math.sqrt(n)),A_e=$r(Sy,n=>Math.sqrt(n)),M_e={kernelName:Sy,backendName:"cpu",kernelFunc:A_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZ=Qs((n,e)=>{const t=n-e;return t*t}),N_e=$i(_y,RZ),$_e={kernelName:_y,backendName:"cpu",kernelFunc:N_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ=Dh((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:s}=e;return n.replace(new RegExp(t,r?"g":""),s)}),R_e=Ip(P2,PZ),P_e={kernelName:P2,backendName:"cpu",kernelFunc:R_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(n,e,t,r){const s=wn(n,e.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+r[l];s.set(e.get(...a),...o)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D_e{constructor(e,t,r,s,i,o){this.separator=gu(e),this.nGramWidths=t,this.leftPad=gu(r),this.rightPad=gu(s),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),h=o-(c+u),f=t+(c>0?0:a-l);let d=0;d+=c*this.leftPad.length;for(let b=0;b<h;++b)d+=e[f+b].length;d+=u*this.rightPad.length;const p=c+u+h-1;d+=p*this.separator.length,r[s+a]=new Uint8Array(d);const m=r[s+a];let g=0;const y=b=>b.forEach(x=>m[g++]=x);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(e[f+b]),y(this.separator);if(h>0){y(e[f+h-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=t[c]>=l;if(u=u&&t[c]<=r,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${r}]`);l=t[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Cs("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const f=t[l+1]-t[l],d=this.getNumNGrams(f,h);this.createNGrams(e,c,a,u,d,h),u+=d}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const f=h+2*this.padWidth,d=1;this.createNGrams(e,c,a,u,d,f)}}return[a,o]}}function OZ(n,e,t,r,s,i,o,a){return new D_e(t,r,s,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O_e(n,e,t,r){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&r.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(s,i);(!t||o.length!==0)&&r.push(o),s=i+1}}function FZ(n,e,t){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let f=0;f<r;++f){const d=s.length;O_e(n[f],e,t,s);const p=s.length-d;a[f]=p,i+=p,o=Math.max(o,p)}const l=Cs("int32",i*2),c=new Array(i),u=[r,o];let h=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[h*2]=f,l[h*2+1]=d,c[h]=s[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LZ(n,e){const t=Cs("int32",n.length);for(let r=0;r<n.length;++r)t[r]=iX(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zZ=Qs((n,e)=>n-e),F_e=Xz((n,e,t,r)=>({real:n-t,imag:e-r})),Qz=$i(Cy,zZ,F_e),L_e={kernelName:Cy,backendName:"cpu",kernelFunc:Qz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BZ(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=wn(t,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v1=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function VZ(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),f=Math.max(t,Math.floor(e-l*u/a+h)),d=Math.min(r,Math.floor(e+(a-l)*u/a+h));VZ(n,e,f,d)}const s=n[e];let i=t,o=r;for(Cf(n,t,e),v1(n[r],s)>0&&Cf(n,t,r);i<o;){for(Cf(n,i,o),i++,o--;v1(n[i],s)<0;)i=i+1;for(;v1(n[o],s)>0;)o=o-1}v1(n[t],s)===0?Cf(n,t,o):(o=o+1,Cf(n,o,r)),o<=e&&(t=o+1),e<=o&&(r=o-1)}}function UZ(n,e,t,r,s){const i=e[e.length-1],[o,a]=[n.length/i,i],l=li(t,o*r),c=li("int32",o*r);for(let h=0;h<o;h++){const f=h*a,d=n.subarray(f,f+a);let p=new Array(d.length);d.forEach((b,x)=>p[x]={value:b,index:x}),r<p.length&&(VZ(p,r),p=p.slice(0,r)),s&&p.sort(v1);const m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=e.slice();return u[u.length-1]=r,[wn(u,t,l),wn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WZ(n,e,t,r){const s=Tn(e,t)[0],i=[1,t[0],1];for(let p=0;p<s;p++)i[0]*=t[p];i[1]=t[s];for(let p=s+1;p<t.length;p++)i[2]*=t[p];const o=new Map,a=new Int32Array(t[s]),l=new ai(i,r,n),c=[],u=i[0]===1&&i[2]===1;for(let p=0;p<t[s];p++){let m;if(u)m=n[p].toString();else{const y=[];for(let b=0;b<i[0];b++)for(let x=0;x<i[2];x++)y.push(l.get(b,p,x));m=y.join(",")}const g=o.get(m);if(g!=null)a[p]=g;else{const y=o.size;o.set(m,y),a[p]=y,c.push(p)}}const h=i.slice();h[1]=o.size;const f=new ai(h,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)f.set(l.get(g,p,y),g,m,y)});const d=t.slice();return d[s]=h[1],{outputValues:f.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ=Object.freeze(Object.defineProperty({__proto__:null,addImpl:JY,bincountImpl:Kz,bincountReduceImpl:QY,bitwiseAndImpl:eZ,castImpl:ZY,ceilImpl:tZ,concatImpl:nZ,equalImpl:rZ,expImpl:iZ,expm1Impl:aZ,floorDivImpl:cZ,floorImpl:lZ,gatherNdImpl:uZ,gatherV2Impl:hZ,greaterEqualImpl:dZ,greaterImpl:fZ,lessEqualImpl:mZ,lessImpl:pZ,linSpaceImpl:gZ,logImpl:yZ,maxImpl:bZ,maximumImpl:vZ,minimumImpl:wZ,multiplyImpl:Yz,negImpl:xZ,notEqualImpl:SZ,prodImpl:_Z,raggedGatherImpl:CZ,raggedRangeImpl:kZ,raggedTensorToTensorImpl:TZ,rangeImpl:EZ,rsqrtImpl:IZ,scatterImpl:Om,sigmoidImpl:k_e,simpleAbsImpl:YY,sliceImpl:MZ,sparseFillEmptyRowsImpl:NZ,sparseReshapeImpl:$Z,sparseSegmentReductionImpl:Jz,sqrtImpl:I_e,squaredDifferenceImpl:RZ,staticRegexReplaceImpl:PZ,stridedSliceImpl:DZ,stringNGramsImpl:OZ,stringSplitImpl:FZ,stringToHashBucketFastImpl:LZ,subImpl:zZ,tileImpl:BZ,topKImpl:UZ,transposeImpl:Zz,uniqueImpl:WZ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */IM("cpu",()=>new CN,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZ=$r(qg,n=>n>=0?n:Math.exp(n)-1),z_e={kernelName:qg,backendName:"cpu",kernelFunc:HZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r;Zt([s],"leakyRelu");const o=Te(s.shape),a=t.data.get(s.dataId).values,l=li("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return t.makeTensorInfo(s.shape,"float32",l)}const B_e={kernelName:Gv,backendName:"cpu",kernelFunc:jZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V_e=Qs((n,e)=>n<0?e*n:n);function qZ(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e;Zt([r,s],"prelu");const i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,[a,l]=V_e(r.shape,s.shape,i,o,"float32");return t.makeTensorInfo(l,"float32",a)}const U_e={kernelName:cw,backendName:"cpu",kernelFunc:qZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZ=$r(fy,n=>Math.max(0,n)),W_e={kernelName:fy,backendName:"cpu",kernelFunc:XZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZ=$r(dy,n=>Math.min(Math.max(0,n),6)),G_e={kernelName:dy,backendName:"cpu",kernelFunc:KZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n,e,t,r,s){if(t==="linear")return _h({inputs:{x:e},backend:n});if(t==="relu")return XZ({inputs:{x:e},backend:n});if(t==="elu")return HZ({inputs:{x:e},backend:n});if(t==="relu6")return KZ({inputs:{x:e},backend:n});if(t==="prelu")return qZ({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return jZ({inputs:{x:e},backend:n,attrs:{alpha:s}});if(t==="sigmoid")return AZ({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=Te(s.shape),a=mM(i,o),l=Te(a);U(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(s.dataId);const c=t.data.get(s.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const H_e={kernelName:hw,backendName:"cpu",kernelFunc:ts};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YZ(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;Zt([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],h=a?i.shape[c-1]:i.shape[c-2],f=o?s.shape[l-1]:s.shape[l-2],d=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=Te(p),y=Te(m),x=ln(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([f,d]);U(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=o?[g,u,f]:[g,f,u],_=a?[y,d,h]:[y,h,d],C=ts({inputs:{x:s},backend:t,attrs:{shape:w}}),k=ts({inputs:{x:i},backend:t,attrs:{shape:_}}),A=o?C.shape[1]:C.shape[2],M=o?C.shape[2]:C.shape[1],I=a?k.shape[1]:k.shape[2],N=Math.max(g,y),O=t.data.get(C.dataId).values,R=t.data.get(k.dataId).values,D=Jt(C.shape),z=Jt(k.shape),[B,X,G]=o?[D[0],1,D[1]]:[D[0],D[1],1],[ee,pe,oe]=a?[1,z[1],z[0]]:[z[1],1,z[0]],Ne=M*I,ke=wn([N,M,I],C.dtype),De=ke.values,ge=t.blockSize;for(let Xe=0;Xe<N;Xe++){const Oe=Xe%g,it=Xe%y;for(let Ge=0;Ge<M;Ge+=ge){const pt=Math.min(Ge+ge,M);for(let ut=0;ut<I;ut+=ge){const Ve=Math.min(ut+ge,I);for(let ze=0;ze<A;ze+=ge){const Be=Math.min(ze+ge,A);for(let ht=Ge;ht<pt;ht++)for(let Ke=ut;Ke<Ve;Ke++){let Q=0;for(let Z=ze;Z<Be;Z++){const nt=O[Oe*B+ht*X+Z*G],He=R[Z*ee+Ke*pe+it*oe];Q+=nt*He}De[Xe*Ne+(ht*I+Ke)]+=Q}}}}}return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(k),t.makeTensorInfo(x,ke.dtype,ke.values)}const j_e={kernelName:Av,backendName:"cpu",kernelFunc:YZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let f,d,p;const m=[];f=YZ({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(d=Xb({inputs:{a:f,b:o},backend:t}),m.push(f),f=d),u&&(p=EI(t,f,u,a,h),m.push(f),f=p);for(const y of m)t.disposeIntermediateTensorInfo(y);return f}const X_e={kernelName:Lb,backendName:"cpu",kernelFunc:q_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K_e=$r(Pg,n=>Math.acos(n)),Y_e={kernelName:Pg,backendName:"cpu",kernelFunc:K_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z_e=$r(Dg,n=>Math.acosh(n)),J_e={kernelName:Dg,backendName:"cpu",kernelFunc:Z_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_e(n){const{inputs:e,backend:t}=n,r=e;Zt(e,"addN");const s=r.map(a=>t.data.get(a.dataId).values),i=wn(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const e2e={kernelName:Cv,backendName:"cpu",kernelFunc:Q_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"all");const a=Tn(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=xa({inputs:{x:s},backend:t,attrs:{perm:c}}),l=rs(l.length,s.shape.length)),ui("all",l,u.shape.length);const[h,f]=Js(u.shape,l),d=Te(f),p=Hi(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const _=m[b+w];x=x&&_}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=ts({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const n2e={kernelName:U_,backendName:"cpu",kernelFunc:t2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"any");const a=Tn(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=xa({inputs:{x:s},backend:t,attrs:{perm:c}}),l=rs(l.length,s.shape.length)),ui("any",l,u.shape.length);const[h,f]=Js(u.shape,l),d=Te(f),p=Hi(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const _=m[b+w];x=x||_}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=ts({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const s2e={kernelName:W_,backendName:"cpu",kernelFunc:r2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Zt(s,"argMax");let o=Tn(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=xa({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=rs(o.length,l.shape.length)),o=[o[0]],ui("argMax",o,l.shape.length);const[u,h]=Js(l.shape,o),f=Te(u),d=Hi(f,"int32"),p=Te(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],x=0;for(let w=0;w<p;++w){const _=m[y+w];_>b&&(b=_,x=w)}d[g]=x}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const o2e={kernelName:kv,backendName:"cpu",kernelFunc:i2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Zt(s,"argMin");let o=Tn(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=xa({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=rs(o.length,l.shape.length)),o=[o[0]],ui("argMin",o,l.shape.length);const[u,h]=Js(l.shape,o),f=Te(u),d=Hi(f,"int32"),p=Te(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],x=0;for(let w=0;w<p;++w){const _=m[y+w];_<b&&(b=_,x=w)}d[g]=x}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const l2e={kernelName:Tv,backendName:"cpu",kernelFunc:a2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2e=$r(Og,n=>Math.asin(n)),u2e={kernelName:Og,backendName:"cpu",kernelFunc:c2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2e=$r(Fg,n=>Math.asinh(n)),f2e={kernelName:Fg,backendName:"cpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d2e=$r(Lg,n=>Math.atan(n)),p2e={kernelName:Lg,backendName:"cpu",kernelFunc:d2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m2e=Qs((n,e)=>Math.atan2(n,e)),g2e=$i(Bg,m2e),y2e={kernelName:Bg,backendName:"cpu",kernelFunc:g2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b2e=$r(zg,n=>Math.atanh(n)),v2e={kernelName:zg,backendName:"cpu",kernelFunc:b2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n,e,t,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,d=s.padInfo.left,p=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=wn(s.outShape,t),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){const _=w*y,C=w*r[0];for(let k=0;k<s.inChannels;++k)for(let A=0;A<s.outHeight;++A){const M=A*o-f,I=Math.max(0,M),N=Math.min(s.inHeight,u+M),O=_+A*b;for(let R=0;R<s.outWidth;++R){const D=R*a-d,z=Math.max(0,D),B=Math.min(s.inWidth,h+D);let X=p,G=0,ee=0;for(let oe=I;oe<N;oe+=l){const Ne=C+oe*r[1];for(let ke=z;ke<B;ke+=c){const De=Ne+ke*r[2],ge=n[De+k];i==="max"&&ge>X?X=ge:i==="avg"&&(G+=ge,ee++)}if(isNaN(X))break}const pe=O+R*x+k;g[pe]=i==="avg"?G/ee:X}}}return m}function ZZ(n,e,t,r,s=!1,i=!1){const o=wn(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,m=wn(e,t,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const x=b*a-d;let w=x;for(;w<0;)w+=c;const _=Math.min(r.inHeight,h+x);for(let C=0;C<r.outWidth;++C){const k=C*l-p;let A=k;for(;A<0;)A+=u;const M=Math.min(r.inWidth,f+k);let I=Number.NEGATIVE_INFINITY,N=-1;for(let O=w;O<_;O+=c){const R=O-x;for(let D=A;D<M;D+=u){const z=D-k,B=m.get(g,O,D,y);B>I&&(I=B,s?N=i?((g*r.inHeight+O)*r.inWidth+D)*r.inChannels+y:(O*r.inWidth+D)*r.inChannels+y:N=R*f+z)}}o.set(N,g,b,C,y)}}return o}function JZ(n,e,t,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterDepth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=wn(s.outShape,t),w=x.values,_=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let M=0;M<s.batchSize;++M){const I=M*_,N=M*r[0];for(let O=0;O<s.inChannels;++O)for(let R=0;R<s.outDepth;++R){const D=R*o-m;let z=D;for(;z<0;)z+=c;const B=Math.min(s.inDepth,f+D),X=I+R*C;for(let G=0;G<s.outHeight;++G){const ee=G*a-g;let pe=ee;for(;pe<0;)pe+=u;const oe=Math.min(s.inHeight,d+ee),Ne=X+G*k;for(let ke=0;ke<s.outWidth;++ke){const De=ke*l-y;let ge=De;for(;ge<0;)ge+=h;const Xe=Math.min(s.inWidth,p+De),Oe=Ne+ke*A;let it=b,Ge=0,pt=0;for(let Ve=z;Ve<B;Ve+=c){const ze=N+Ve*r[1];for(let Be=pe;Be<oe;Be+=u){const ht=ze+Be*r[2];for(let Ke=ge;Ke<Xe;Ke+=h){const Q=ht+Ke*r[3],Z=n[Q+O];if(i==="max"&&Z>it?it=Z:i==="avg"&&(Ge+=Z,pt++),isNaN(it))break}if(isNaN(it))break}if(isNaN(it))break}const ut=Oe+O;w[ut]=i==="avg"?Ge/Math.max(pt,1):it}}}}return x}function w2e(n,e){const t=wn(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*r-f;let x=b;for(;x<0;)x+=o;const w=Math.min(e.inDepth,c+b);for(let _=0;_<e.outHeight;++_){const C=_*s-d;let k=C;for(;k<0;)k+=a;const A=Math.min(e.inHeight,u+C);for(let M=0;M<e.outWidth;++M){const I=M*i-p;let N=I;for(;N<0;)N+=l;const O=Math.min(e.inWidth,h+I);let R=Number.NEGATIVE_INFINITY,D=-1;for(let z=x;z<w;z+=o){const B=z-b;for(let X=k;X<A;X+=a){const G=X-C;for(let ee=N;ee<O;ee+=l){const pe=ee-I,oe=n.get(m,z,X,ee,g);oe>=R&&(R=oe,D=B*u*h+G*u+pe)}}}t.set(D,m,y,_,M,g)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Zt(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ni(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=_o(s.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Mn(u.inShape,u.outShape))h=_h({inputs:{x:s},backend:t});else{const f=t.data.get(s.dataId).values,d=Jt(s.shape),p=eB(f,s.shape,s.dtype,d,u,"avg");h=t.makeTensorInfo(u.outShape,s.dtype,p.values)}return h}const S2e={kernelName:Ev,backendName:"cpu",kernelFunc:x2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Zt(s,"avgPool3d");const u=zl(s.shape,i,o,1,a,l,c),h=t.data.get(s.dataId).values,f=JZ(h,s.shape,s.dtype,Jt(s.shape),u,"avg");return t.makeTensorInfo(f.shape,"float32",f.values)}const C2e={kernelName:Iv,backendName:"cpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Zt([s,i],"avgPool3DGrad");const u=zl(i.shape,o,a,1,l,c),h=u.strideDepth,f=u.strideHeight,d=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,w=u.effectiveFilterDepth,_=u.effectiveFilterHeight,C=u.effectiveFilterWidth,k=w-1-u.padInfo.front,A=C-1-u.padInfo.left,M=_-1-u.padInfo.top,I=wn(i.shape,"float32"),N=1/(p*m*g),O=t.bufferSync(s);for(let R=0;R<u.batchSize;++R)for(let D=0;D<u.inChannels;++D)for(let z=0;z<u.inDepth;++z)for(let B=0;B<u.inHeight;++B)for(let X=0;X<u.inWidth;++X){const G=z-k,ee=B-M,pe=X-A;let oe=0;for(let Ne=0;Ne<w;Ne+=y){const ke=(G+Ne)/h;if(!(ke<0||ke>=u.outDepth||Math.floor(ke)!==ke))for(let De=0;De<_;De+=b){const ge=(ee+De)/f;if(!(ge<0||ge>=u.outHeight||Math.floor(ge)!==ge))for(let Xe=0;Xe<C;Xe+=x){const Oe=(pe+Xe)/d;if(Oe<0||Oe>=u.outWidth||Math.floor(Oe)!==Oe)continue;const it=O.get(R,ke,ge,Oe,D);oe+=it}}}I.set(oe*N,R,z,B,X,D)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const T2e={kernelName:H_,backendName:"cpu",kernelFunc:k2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;Zt([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=_o(o.shape,a,l,1,c),h=u.strideHeight,f=u.strideWidth,d=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,w=y-1-u.padInfo.top,_=wn(o.shape,"float32"),C=1/(d*p),k=t.data.get(s.dataId).values,A=wn(s.shape,"float32",k);for(let M=0;M<u.batchSize;++M)for(let I=0;I<u.inChannels;++I)for(let N=0;N<u.inHeight;++N)for(let O=0;O<u.inWidth;++O){const R=N-w,D=O-x;let z=0;for(let B=0;B<y;B+=m){const X=(R+B)/h;if(!(X<0||X>=u.outHeight||Math.floor(X)!==X))for(let G=0;G<b;G+=g){const ee=(D+G)/f;if(ee<0||ee>=u.outWidth||Math.floor(ee)!==ee)continue;const pe=A.get(M,X,ee,I);z+=pe}}_.set(z*C,M,N,O,I)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const I2e={kernelName:G_,backendName:"cpu",kernelFunc:E2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=e;U(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Zt([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);const u=t.data.get(s.dataId).values,h=t.data.get(a.dataId).values,f=t.data.get(l.dataId).values,d=i?t.data.get(i.dataId).values:new Float32Array([1]),p=o?t.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=d.length,b=f.length,x=h.length;let w=0,_=0,C=0,k=0;for(let A=0;A<u.length;++A)m[A]=p[w++]+(u[A]-h[_++])*d[C++]/Math.sqrt(f[k++]+c),w>=g&&(w=0),_>=x&&(_=0),C>=y&&(C=0),k>=b&&(k=0);return t.makeTensorInfo(s.shape,s.dtype,m)}const M2e={kernelName:Vv,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;Zt([s],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=Dy(s.shape,i,a),c=Oy(l.length,i.length),u=Fy(s.shape,i,a),h=cN(o,i.length),f=uN(u,o,i.length),d=ts({inputs:{x:s},backend:t,attrs:{shape:l}}),p=xa({inputs:{x:d},backend:t,attrs:{perm:c}}),m=ts({inputs:{x:p},backend:t,attrs:{shape:u}}),g=cg({inputs:{x:m},backend:t,attrs:{begin:h,size:f}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const $2e={kernelName:Mv,backendName:"cpu",kernelFunc:N2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=Kz(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const P2e={kernelName:j_,backendName:"cpu",kernelFunc:R2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D2e(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=ln(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const O2e={kernelName:X_,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F2e=$r(Wg,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),L2e={kernelName:Wg,backendName:"cpu",kernelFunc:F2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z2e=n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(Te(e.shape)),s=t.data.get(e.dataId),i=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];r[c]=Math.hypot(u,h)}return t.makeOutput(r,e.shape,"float32")},B2e={kernelName:Nv,backendName:"cpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.imag,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const V2e={kernelName:p2,backendName:"cpu",kernelFunc:Kb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yb(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=Tn(s,e[0].shape)[0],o=e.map(m=>m.shape);oN(o,i);let a=ga(e.map(m=>m.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(m=>Te(m.shape)>0);if(l.length===1)return _h({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const m=l.map(w=>lg({inputs:{input:w},backend:t})),g=l.map(w=>Kb({inputs:{input:w},backend:t})),y=Yb({inputs:m,backend:t,attrs:{axis:i}}),b=Yb({inputs:g,backend:t,attrs:{axis:i}}),x=za({inputs:{real:y,imag:b},backend:t});return m.forEach(w=>t.disposeIntermediateTensorInfo(w)),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}const c=l.map(m=>{const y=[-1,Te(m.shape.slice(i))];return ts({inputs:{x:m},backend:t,attrs:{shape:y}})}),u=c.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));a=ga(c.map(m=>m.shape),1);const h=c[0].shape[0]===1,f=nZ(u,a,e[0].dtype,h),d=ga(l.map(m=>m.shape),i),p=t.makeTensorInfo(d,e[0].dtype,f);return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const U2e={kernelName:$v,backendName:"cpu",kernelFunc:Yb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QZ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Zt([s,i],"conv2d");const h=Qa(l),f=ns(s.shape,i.shape,o,c,a,u,!1,h),d=f.filterHeight,p=f.filterWidth,m=f.dilationHeight,g=f.dilationWidth,y=f.padInfo.left,b=f.padInfo.top,x=f.dataFormat==="channelsLast",w=new ai(f.outShape,s.dtype),_=Jt(s.shape),C=Jt(i.shape),k=_[0],A=x?_[1]:_[2],M=x?_[2]:1,I=x?1:_[1],N=w.strides[0],O=x?w.strides[1]:w.strides[2],R=x?w.strides[2]:1,D=x?1:w.strides[1],z=t.data.get(s.dataId).values,B=t.data.get(i.dataId).values,X=w.values;for(let G=0;G<f.batchSize;++G){const ee=G*k,pe=G*N;for(let oe=0;oe<f.outHeight;++oe){const Ne=pe+oe*O,ke=oe*f.strideHeight-b;for(let De=0;De<d;++De){const ge=ke+De*m;if(ge<0||ge>=f.inHeight)continue;const Xe=De*C[0],Oe=ee+ge*A;for(let it=0;it<f.outWidth;++it){const Ge=Ne+it*R,pt=it*f.strideWidth-y;for(let ut=0;ut<p;++ut){const Ve=pt+ut*g;if(Ve<0||Ve>=f.inWidth)continue;const ze=Xe+ut*C[1],Be=Oe+Ve*M;let ht=ze;for(let Ke=0;Ke<f.inChannels;++Ke){const Q=z[Be+Ke*I];for(let Z=0;Z<f.outChannels;++Z)X[Ge+Z*D]+=Q*B[ht+Z];ht+=f.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,X)}const W2e={kernelName:Rv,backendName:"cpu",kernelFunc:QZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Zt([s,i],"conv2dBackpropFilter");const h=Qa(l),f=ns(s.shape,u,o,1,a,c,!1,h),{strideHeight:d,strideWidth:p,filterHeight:m,filterWidth:g}=f,y=f.dataFormat==="channelsLast",b=new ai(f.filterShape,"float32"),x=f.padInfo.left,w=f.padInfo.top,_=t.data.get(s.dataId).values,C=t.data.get(i.dataId).values,k=new ai(s.shape,s.dtype,_),A=new ai(i.shape,i.dtype,C);for(let M=0;M<m;++M){const I=Math.max(0,Math.ceil((w-M)/d)),N=Math.min(f.outHeight,(f.inHeight+w-M)/d);for(let O=0;O<g;++O){const R=Math.max(0,Math.ceil((x-O)/p)),D=Math.min(f.outWidth,(f.inWidth+x-O)/p);for(let z=0;z<f.inChannels;++z)for(let B=0;B<f.outChannels;++B){let X=0;for(let G=0;G<f.batchSize;++G)for(let ee=I;ee<N;++ee){const pe=M+ee*d-w;for(let oe=R;oe<D;++oe){const Ne=O+oe*p-x;y?X+=k.get(G,pe,Ne,z)*A.get(G,ee,oe,B):X+=k.get(G,z,pe,Ne)*A.get(G,B,ee,oe)}}b.set(X,M,O,z,B)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const H2e={kernelName:Y_,backendName:"cpu",kernelFunc:G2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Zt([s,i],"conv2dBackpropInput");const h=Jt(i.shape),f=Jt(s.shape);let d=Qa(c);const p=ns(o,i.shape,a,1,l,u,!1,d),m=new ai(p.inShape,"float32"),g=m.values,y=t.data.get(s.dataId).values,b=t.data.get(i.dataId).values,[x,w,_]=h,{batchSize:C,filterHeight:k,filterWidth:A,inChannels:M,inHeight:I,inWidth:N,outChannels:O,outHeight:R,outWidth:D,strideHeight:z,strideWidth:B}=p;d=p.dataFormat;const X=k-1-p.padInfo.top,G=A-1-p.padInfo.left,ee=d==="channelsLast",pe=m.strides[0],oe=ee?m.strides[1]:m.strides[2],Ne=ee?m.strides[2]:1,ke=ee?1:m.strides[1],De=f[0],ge=ee?f[1]:f[2],Xe=ee?f[2]:1,Oe=ee?1:f[1];for(let it=0;it<C;++it)for(let Ge=0;Ge<M;++Ge)for(let pt=0;pt<I;++pt){const ut=pt-X,Ve=Math.max(0,Math.ceil(ut/z)),ze=Math.min(R,(k+ut)/z);for(let Be=0;Be<N;++Be){const ht=Be-G,Ke=Math.max(0,Math.ceil(ht/B)),Q=Math.min(D,(A+ht)/B);let Z=0;for(let He=Ve;He<ze;++He){const me=He*z-ut;for(let Ye=Ke;Ye<Q;++Ye){const bt=Ye*B-ht,kt=De*it+ge*He+Xe*Ye,dt=x*(k-1-me)+w*(A-1-bt)+_*Ge;for(let le=0;le<O;++le){const tt=y[kt+Oe*le],Ct=b[dt+le];Z+=tt*Ct}}}const nt=pe*it+oe*pt+Ne*Be+ke*Ge;g[nt]=Z}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const q2e={kernelName:Pv,backendName:"cpu",kernelFunc:j2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r;Zt([s,i],"conv3d");const c=Ou(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:f,dilationDepth:d,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,x=g.top,w=new ai(c.outShape,s.dtype),_=t.data.get(s.dataId).values,C=t.data.get(i.dataId).values,k=w.values,A=Jt(s.shape),M=Jt(i.shape);for(let I=0;I<c.batchSize;++I){const N=I*A[0],O=I*w.strides[0];for(let R=0;R<c.outDepth;++R){const D=O+R*w.strides[1],z=R*c.strideDepth-y;for(let B=0;B<u;++B){const X=z+B*d;if(X<0||X>=c.inDepth)continue;const G=B*M[0],ee=N+X*A[1];for(let pe=0;pe<c.outHeight;++pe){const oe=D+pe*w.strides[2],Ne=pe*c.strideHeight-x;for(let ke=0;ke<h;++ke){const De=Ne+ke*p;if(De<0||De>=c.inHeight)continue;const ge=G+ke*M[1],Xe=ee+De*A[2];for(let Oe=0;Oe<c.outWidth;++Oe){const it=oe+Oe*c.outChannels,Ge=Oe*c.strideWidth-b;for(let pt=0;pt<f;++pt){const ut=Ge+pt*m;if(ut<0||ut>=c.inWidth)continue;const Ve=ge+pt*M[2],ze=Xe+ut*c.inChannels;let Be=Ve;for(let ht=0;ht<c.inChannels;++ht){const Ke=_[ze+ht];for(let Q=0;Q<c.outChannels;++Q)k[it+Q]+=Ke*C[Be+Q];Be+=c.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const K2e={kernelName:Dv,backendName:"cpu",kernelFunc:X2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r;Zt([s,i],"conv3dBackpropFilterV2");const c=Jt(s.shape),u=Jt(i.shape),h=Ou(s.shape,l,o,1,a),f=h.strideDepth,d=h.strideHeight,p=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new ai(h.filterShape,"float32"),x=b.values,[w,_,C,k]=b.strides,A=t.data.get(i.dataId).values,[M,I,N,O]=u,R=t.data.get(s.dataId).values,[D,z,B,X]=c,G=h.padInfo.front,ee=h.padInfo.left,pe=h.padInfo.top;for(let oe=0;oe<m;++oe){const Ne=Math.max(0,Math.ceil((G-oe)/f)),ke=Math.min(h.outDepth,(h.inDepth+G-oe)/f),De=oe*w;for(let ge=0;ge<g;++ge){const Xe=Math.max(0,Math.ceil((pe-ge)/d)),Oe=Math.min(h.outHeight,(h.inHeight+pe-ge)/d),it=ge*_+De;for(let Ge=0;Ge<y;++Ge){const pt=Math.max(0,Math.ceil((ee-Ge)/p)),ut=Math.min(h.outWidth,(h.inWidth+ee-Ge)/p),Ve=Ge*C+it;for(let ze=0;ze<h.inChannels;++ze){const Be=ze*k+Ve;for(let ht=0;ht<h.outChannels;++ht){let Ke=0;for(let Q=0;Q<h.batchSize;++Q){const Z=Q*D,nt=Q*M;for(let He=Ne;He<ke;++He){const Ye=(oe+He*f-G)*z+Z,bt=He*I+nt;for(let kt=Xe;kt<Oe;++kt){const le=(ge+kt*d-pe)*B+Ye,tt=kt*N+bt;for(let Ct=pt;Ct<ut;++Ct){const Ht=(Ge+Ct*p-ee)*X+le,En=Ct*O+tt;Ke+=R[Ht+ze]*A[En+ht]}}}}x[Be+ht]=Ke}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const Z2e={kernelName:Z_,backendName:"cpu",kernelFunc:Y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r;Zt([s],"conv3dBackpropInputV2");const c=Jt(s.shape),u=Jt(i.shape),h=Ou(l,i.shape,a,1,o),f=new ai(h.inShape,"float32"),d=f.values,[p,m,g,y]=f.strides,b=t.data.get(s.dataId).values,[x,w,_,C]=c,k=t.data.get(i.dataId).values,[A,M,I,N]=u,{batchSize:O,filterDepth:R,filterHeight:D,filterWidth:z,inChannels:B,inDepth:X,inHeight:G,inWidth:ee,outChannels:pe,outDepth:oe,outHeight:Ne,outWidth:ke,strideDepth:De,strideHeight:ge,strideWidth:Xe}=h,Oe=R-1-h.padInfo.front,it=D-1-h.padInfo.top,Ge=z-1-h.padInfo.left;for(let pt=0;pt<O;++pt)for(let ut=0;ut<B;++ut)for(let Ve=0;Ve<X;++Ve){const ze=Ve-Oe,Be=Math.max(0,Math.ceil(ze/De)),ht=Math.min(oe,(R+ze)/De);for(let Ke=0;Ke<G;++Ke){const Q=Ke-it,Z=Math.max(0,Math.ceil(Q/ge)),nt=Math.min(Ne,(D+Q)/ge);for(let He=0;He<ee;++He){const me=He-Ge,Ye=Math.max(0,Math.ceil(me/Xe)),bt=Math.min(ke,(z+me)/Xe);let kt=0;for(let dt=Be;dt<ht;++dt){const le=dt*De-ze;for(let tt=Z;tt<nt;++tt){const Ct=tt*ge-Q;for(let yt=Ye;yt<bt;++yt){const Ht=yt*Xe-me,En=x*pt+w*dt+_*tt+C*yt,_r=A*(R-1-le)+M*(D-1-Ct)+I*(z-1-Ht)+N*ut;for(let Bs=0;Bs<pe;++Bs){const Ms=b[En+Bs],Ns=k[_r+Bs];kt+=Ms*Ns}}}}d[p*pt+m*Ve+g*Ke+y*He+ut]=kt}}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const Q2e={kernelName:J_,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eCe=$r(Gg,n=>Math.cos(n)),tCe={kernelName:Gg,backendName:"cpu",kernelFunc:eCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nCe=$r(Hg,n=>Math.cosh(n)),rCe={kernelName:Hg,backendName:"cpu",kernelFunc:nCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sCe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,[u,h,f,d]=s.shape,p=i.shape[0],[m,g]=a,y=wn([p,m,g,d],"float32"),b=t.data.get(i.dataId).values,x=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,_=Jt(s.shape),C=Jt(y.shape);for(let k=0;k<p;k++){const A=k*4,M=b[A],I=b[A+1],N=b[A+2],O=b[A+3],R=x[k];if(R>=u)continue;const D=m>1?(N-M)*(h-1)/(m-1):0,z=g>1?(O-I)*(f-1)/(g-1):0;for(let B=0;B<m;B++){const X=m>1?M*(h-1)+B*D:.5*(M+N)*(h-1);if(X<0||X>h-1){for(let G=0;G<g;G++)for(let ee=0;ee<d;ee++){const pe=ee+G*C[2]+B*C[1]+k*C[0];y.values[pe]=c}continue}if(l==="bilinear"){const G=Math.floor(X),ee=Math.ceil(X),pe=X-G;for(let oe=0;oe<g;oe++){const Ne=g>1?I*(f-1)+oe*z:.5*(I+O)*(f-1);if(Ne<0||Ne>f-1){for(let Xe=0;Xe<d;Xe++){const Oe=Xe+oe*C[2]+B*C[1]+k*C[0];y.values[Oe]=c}continue}const ke=Math.floor(Ne),De=Math.ceil(Ne),ge=Ne-ke;for(let Xe=0;Xe<d;Xe++){let Oe=Xe+ke*_[2]+G*_[1]+R*_[0];const it=w[Oe];Oe=Xe+De*_[2]+G*_[1]+R*_[0];const Ge=w[Oe];Oe=Xe+ke*_[2]+ee*_[1]+R*_[0];const pt=w[Oe];Oe=Xe+De*_[2]+ee*_[1]+R*_[0];const ut=w[Oe],Ve=it+(Ge-it)*ge,ze=pt+(ut-pt)*ge;Oe=Xe+oe*C[2]+B*C[1]+k*C[0],y.values[Oe]=Ve+(ze-Ve)*pe}}}else for(let G=0;G<g;++G){const ee=g>1?I*(f-1)+G*z:.5*(I+O)*(f-1);if(ee<0||ee>f-1){for(let Ne=0;Ne<d;Ne++){const ke=Ne+G*C[2]+B*C[1]+k*C[0];y.values[ke]=c}continue}const pe=Math.round(ee),oe=Math.round(X);for(let Ne=0;Ne<d;Ne++){const ke=Ne+pe*_[2]+oe*_[1]+R*_[0],De=Ne+G*C[2]+B*C[1]+k*C[0];y.values[De]=w[ke]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const iCe={kernelName:e2,backendName:"cpu",kernelFunc:sCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Zt(s,"cumprod");const l=Lr([i],s.shape.length);let c=s;l!=null&&(c=xa({inputs:{x:s},backend:t,attrs:{perm:l}}));const u=rs(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Ii(c.dtype,"int32"),f=yM(Te(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const x=m(y,b);if(b===0)f[x]=o?1:d[x];else{const w=m(y,b-1);f[x]=o?d[w]*f[w]:d[x]*f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Rh(l),b=xa({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const aCe={kernelName:Q_,backendName:"cpu",kernelFunc:oCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Zt(s,"cumsum");const l=Lr([i],s.shape.length);let c=s;l!=null&&(c=xa({inputs:{x:s},backend:t,attrs:{perm:l}}));const u=rs(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Ii(c.dtype,"int32"),f=Hi(Te(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const x=m(y,b);if(b===0)f[x]=o?0:d[x];else{const w=m(y,b-1);f[x]=o?d[w]+f[w]:d[x]+f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Rh(l),b=xa({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const cCe={kernelName:Ov,backendName:"cpu",kernelFunc:lCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=Kz(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(s.shape.length===2){const l=t.bufferSync(s),c=t.bufferSync(i),u=QY(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const hCe={kernelName:t2,backendName:"cpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r;U(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],h=l*i,f=c*i,d=u/(i*i),p=t.data.get(s.dataId).values,m=new Float32Array(a*h*f*d);let g=0;for(let y=0;y<a;++y)for(let b=0;b<h;++b){const x=Math.floor(b/i),w=b%i;for(let _=0;_<f;++_){const C=Math.floor(_/i),k=_%i,A=(w*i+k)*d;for(let M=0;M<d;++M){const N=M+A+u*(C+c*(x+l*y));m[g++]=p[N]}}}return t.makeTensorInfo([a,h,f,d],s.dtype,m)}const dCe={kernelName:n2,backendName:"cpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Zt([s,i],"depthwiseConv2DNative");const u=Jt(s.shape),h=Jt(i.shape);let f=l;f==null&&(f=[1,1]),U(Ni(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const d=ns(s.shape,i.shape,o,f,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=d,x=b.left,w=b.top,_=d.outChannels/d.inChannels,C=new ai(d.outShape,s.dtype),k=t.data.get(s.dataId).values,A=t.data.get(i.dataId).values,M=C.values;for(let I=0;I<d.batchSize;++I){const N=I*u[0],O=I*C.strides[0];for(let R=0;R<d.outHeight;++R){const D=O+R*C.strides[1],z=R*d.strideHeight-w;for(let B=0;B<p;++B){const X=z+B*g;if(X<0||X>=d.inHeight)continue;const G=B*h[0],ee=N+X*u[1];for(let pe=0;pe<d.outWidth;++pe){const oe=D+pe*C.strides[2],Ne=pe*d.strideWidth-x;for(let ke=0;ke<m;++ke){const De=Ne+ke*y;if(De<0||De>=d.inWidth)continue;const ge=G+ke*h[1],Xe=ee+De*d.inChannels;let Oe=oe,it=ge;for(let Ge=0;Ge<d.inChannels;++Ge){const pt=k[Xe+Ge];for(let ut=0;ut<_;++ut)M[Oe+ut]+=pt*A[it+ut];Oe+=_,it+=_}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const pCe={kernelName:Fv,backendName:"cpu",kernelFunc:eJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Zt([s,i],"depthwiseConv2dNativeBackpropFilter");const h=ns(s.shape,u,o,a,l,c,!0),{strideHeight:f,strideWidth:d,filterHeight:p,filterWidth:m}=h,g=new ai(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,w=t.data.get(s.dataId).values,_=new ai(s.shape,s.dtype,w),C=t.data.get(i.dataId).values,k=new ai(i.shape,i.dtype,C);for(let A=0;A<p;++A){const M=Math.max(0,Math.ceil((b-A)/f)),I=Math.min(h.outHeight,(h.inHeight+b-A)/f);for(let N=0;N<m;++N){const O=Math.max(0,Math.ceil((y-N)/d)),R=Math.min(h.outWidth,(h.inWidth+y-N)/d);for(let D=0;D<h.outChannels;++D){const z=Math.trunc(D/x),B=D%x;let X=0;for(let G=0;G<h.batchSize;++G)for(let ee=M;ee<I;++ee){const pe=A+ee*f-b;for(let oe=O;oe<R;++oe){const Ne=N+oe*d-y;X+=_.get(G,pe,Ne,z)*k.get(G,ee,oe,D)}}g.set(X,A,N,z,B)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const gCe={kernelName:r2,backendName:"cpu",kernelFunc:mCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Zt([s,i],"depthwiseConv2DNativeBackpropInput");const h=Jt(s.shape),f=Jt(i.shape),d=ns(u,i.shape,o,a,l,c,!0),p=new ai(d.inShape,"float32"),m=p.values,[g,y,b]=p.strides,x=t.data.get(s.dataId).values,[w,_,C]=h,k=t.data.get(i.dataId).values,[A,M,I]=f,{batchSize:N,filterHeight:O,filterWidth:R,inChannels:D,inHeight:z,inWidth:B,outChannels:X,outHeight:G,outWidth:ee,strideHeight:pe,strideWidth:oe}=d,Ne=O-1-d.padInfo.top,ke=R-1-d.padInfo.left,De=X/D;for(let ge=0;ge<N;++ge)for(let Xe=0;Xe<D;++Xe)for(let Oe=0;Oe<z;++Oe){const it=Oe-Ne,Ge=Math.max(0,Math.ceil(it/pe)),pt=Math.min(G,(O+it)/pe);for(let ut=0;ut<B;++ut){const Ve=ut-ke,ze=Math.max(0,Math.ceil(Ve/oe)),Be=Math.min(ee,(R+Ve)/oe);let ht=0;for(let Ke=Ge;Ke<pt;++Ke){const Q=Ke*pe-it;for(let Z=ze;Z<Be;++Z){const nt=Z*oe-Ve,He=w*ge+_*Ke+C*Z,me=A*(O-1-Q)+M*(R-1-nt)+I*Xe;for(let Ye=0;Ye<De;++Ye){const bt=Xe*De+Ye,kt=x[He+bt],dt=k[me+Ye];ht+=kt*dt}}}m[g*ge+y*Oe+b*ut+Xe]=ht}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const bCe={kernelName:s2,backendName:"cpu",kernelFunc:yCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=Te(r.shape),i=t.data.get(r.dataId).values,o=wn([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const wCe={kernelName:i2,backendName:"cpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xCe={kernelName:Lv,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=t,l=e,c=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(s.dataId).values,f=s.shape.length,{batchSize:d,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:_,filterHeight:C,filterWidth:k,dilationHeight:A,dilationWidth:M,outShape:I}=kp(r.shape,s.shape,i,o,"NHWC",a),N=Te(I),O=I.length,R=Cs(r.dtype,N);for(let z=0;z<d;++z)for(let B=0;B<y;++B){const X=B*w-x.top;for(let G=0;G<b;++G){const ee=G*_-x.left;for(let pe=0;pe<g;++pe){let oe=Number.MIN_SAFE_INTEGER;for(let ke=0;ke<C;++ke){const De=X+ke*A;if(De>=0&&De<p)for(let ge=0;ge<k;++ge){const Xe=ee+ge*M;if(Xe>=0&&Xe<m){const Oe=mu([z,De,Xe,pe],u,Jt(r.shape)),it=mu([ke,ge,pe],f,Jt(s.shape)),Ge=c[Oe]+h[it];Ge>oe&&(oe=Ge)}}}const Ne=mu([z,B,G,pe],O,Jt(I));R[Ne]=oe}}}return{dataId:l.write(_p(R,r.dtype),I,r.dtype),shape:I,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SCe={kernelName:uS,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=El(r.shape,c.data.get(r.dataId).values),h=El(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:_,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=kp(r.shape,s.shape,o,a,"NHWC",l);U(i.rank===M.length,()=>`Error in ${uS}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const I=El(M,c.data.get(i.dataId).values),N=vL(s.shape,s.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*x-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let G=0;G<m;++G){let ee=Number.MIN_SAFE_INTEGER,pe=0,oe=0;for(let Ne=0;Ne<_;++Ne){const ke=z+Ne*k;if(ke>=0&&ke<d)for(let De=0;De<C;++De){const ge=X+De*A;if(ge>=0&&ge<p){const Xe=u[R][ke][ge][G]+h[Ne][De][G];Xe>ee&&(ee=Xe,pe=Ne,oe=De)}}}N[pe][oe][G]+=I[R][D][B][G]}}}return{dataId:c.write(_p(N,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ce={kernelName:cS,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=El(r.shape,c.data.get(r.dataId).values),h=El(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:_,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=kp(r.shape,s.shape,o,a,"NHWC",l);U(i.rank===M.length,()=>`Error in ${cS}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const I=El(M,c.data.get(i.dataId).values),N=vL(r.shape,r.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*x-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let G=0;G<m;++G){let ee=Number.MIN_SAFE_INTEGER,pe=z<0?0:z,oe=X<0?0:X;for(let Ne=0;Ne<_;++Ne){const ke=z+Ne*k;if(ke>=0&&ke<d)for(let De=0;De<C;++De){const ge=X+De*A;if(ge>=0&&ge<p){const Xe=u[R][ke][ge][G]+h[Ne][De][G];Xe>ee&&(ee=Xe,pe=ke,oe=ge)}}}N[R][pe][oe][G]+=I[R][D][B][G]}}}return{dataId:c.write(_p(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CCe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,{contextOptions:a,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,u=(a==null?void 0:a.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(u,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);const[f,d]=s.shape.slice(0,2),p=s.shape.length===2?1:s.shape[2],m=t.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let x=0;x<f*d;++x){const w=[0,0,0,255*c];for(let C=0;C<p;C++){const k=m[x*p+C];if(s.dtype==="float32"){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if(s.dtype==="int32"&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);p===1?(w[0]=k*g,w[1]=k*g,w[2]=k*g):w[C]=k*g}const _=x*4;y[_+0]=Math.round(w[0]),y[_+1]=Math.round(w[1]),y[_+2]=Math.round(w[2]),y[_+3]=Math.round(w[3])}i.width=d,i.height=f;const b=new ImageData(y,d,f);return h.putImageData(b,0,0),s}const kCe={kernelName:o2,backendName:"cpu",kernelFunc:CCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"sum");let a;s.dtype==="bool"?a=sp({inputs:{x:s},backend:t,attrs:{dtype:"int32"}}):a=_h({inputs:{x:s},backend:t});const l=a.shape.length,c=Tn(i,a.shape),u=Lr(c,l);let h=c,f=a;u!=null&&(f=xa({inputs:{x:a},backend:t,attrs:{perm:u}}),h=rs(h.length,l)),ui("sum",h,f.shape.length);const[d,p]=Js(f.shape,h),m=Ii(f.dtype,"int32");let g=kI(t,d,m);const y=Te(p),b=t.data.get(g.dataId).values,x=t.data.get(f.dataId).values;for(let w=0;w<b.length;++w){const _=w*y;let C=0;for(let k=0;k<y;++k)C+=x[_+k];b[w]=C}if(o){const w=Ls(g.shape,c),_=g;g=ts({inputs:{x:g},backend:t,attrs:{shape:w}}),t.disposeIntermediateTensorInfo(_)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(f),g}const TCe={kernelName:yw,backendName:"cpu",kernelFunc:cC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=yN(s,i.length);vN(o.length,l,i);const{path:c,steps:u}=wN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=bN(d,l[g]);let x;xN(y)?x=i[g]:(x=xa({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let _=0;_<b.length;++_)w.splice(b[_],0,1);Mn(x.shape,w)||(x=ts({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=kN({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=cC({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const ICe={kernelName:a2,backendName:"cpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ACe(n){const{inputs:e,backend:t}=n,{dy:r,y:s}=e;Zt([r,s],"eluGrad");const i=new Float32Array(Te(s.shape)),o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?i[l]=a[l]:i[l]=a[l]*(c+1)}return t.makeTensorInfo(s.shape,"float32",i)}const MCe={kernelName:l2,backendName:"cpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NCe=hN,$Ce=fN,RCe=dN,PCe=pN,DCe=mN,OCe=gN,FCe=$r(Xg,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+NCe*t);return e*(1-((((OCe*r+DCe)*r+PCe)*r+RCe)*r+$Ce)*r*Math.exp(-t*t))}),LCe={kernelName:Xg,backendName:"cpu",kernelFunc:FCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n){const{inputs:e,backend:t,attrs:r}=n,{input:s}=e,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(U(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),ts({inputs:{x:s},backend:t,attrs:{shape:a}})}const zCe={kernelName:Bv,backendName:"cpu",kernelFunc:II};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BCe=Qs((n,e)=>n/e),tB=$i(jg,BCe),kD={kernelName:jg,backendName:"cpu",kernelFunc:tB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tJ(n,e,t){const r=n.shape,s=r[0],i=r[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=Te(c),h=li("float32",u),f=li("float32",u);for(let g=0;g<s;g++){const y=cg({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,i]}}),b=cg({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,i]}}),x=za({inputs:{real:y,imag:b},backend:t}),{real:w,imag:_}=VCe(x,e,t),C=xu(w,_);for(let k=0;k<i;k++){const A=jz(C,k);h[g*i+k]=A.real,f[g*i+k]=A.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x)}const d=t.makeTensorInfo(c,"float32",h),p=t.makeTensorInfo(c,"float32",f),m=za({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}function VCe(n,e,t){const r=Te(n.shape),s=t.data.get(n.dataId),i=t.data.get(s.complexTensorInfos.real.dataId).values,o=t.data.get(s.complexTensorInfos.imag.dataId).values;if(UCe(r)){const a=TD(i,o,r,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Uf(r,"float32")),f=_h({inputs:{x:h},backend:t}),d=kD.kernelFunc({inputs:{a:c,b:h},backend:t}),p=kD.kernelFunc({inputs:{a:u,b:f},backend:t}),m=t.data.get(d.dataId).values,g=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}else{const a=xu(i,o),l=WCe(a,r,e);return AY(l)}}function UCe(n){return(n&n-1)===0}function TD(n,e,t,r,s){if(t===1)return{real:n,imag:e};const i=xu(n,e),o=t/2,a=MY(i),l=a.real,c=a.imag,u=[l.length],h=s.makeTensorInfo(u,"float32",l),f=s.makeTensorInfo(u,"float32",c),d=za({inputs:{real:h,imag:f},backend:s}),p=NY(i),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=za({inputs:{real:b,imag:x},backend:s}),_=TD(l,c,o,r,s),C=_.real,k=_.imag,A=[C.length],M=s.makeTensorInfo(A,"float32",C),I=s.makeTensorInfo(A,"float32",k),N=za({inputs:{real:M,imag:I},backend:s}),O=TD(m,g,o,r,s),R=O.real,D=O.imag,z=[R.length],B=s.makeTensorInfo(z,"float32",R),X=s.makeTensorInfo(z,"float32",D),G=za({inputs:{real:B,imag:X},backend:s}),ee=RY(t,r),pe=[ee.real.length],oe=s.makeTensorInfo(pe,"float32",ee.real),Ne=s.makeTensorInfo(pe,"float32",ee.imag),ke=za({inputs:{real:oe,imag:Ne},backend:s}),De=kN({inputs:{a:ke,b:G},backend:s}),ge=Xb({inputs:{a:N,b:De},backend:s}),Xe=Qz({inputs:{a:N,b:De},backend:s}),Oe=lg({inputs:{input:ge},backend:s}),it=lg({inputs:{input:Xe},backend:s}),Ge=Kb({inputs:{input:ge},backend:s}),pt=Kb({inputs:{input:Xe},backend:s}),ut=Yb({inputs:[Oe,it],backend:s,attrs:{axis:0}}),Ve=Yb({inputs:[Ge,pt],backend:s,attrs:{axis:0}}),ze=s.data.get(ut.dataId).values,Be=s.data.get(Ve.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(oe),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(Xe),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(Ge),s.disposeIntermediateTensorInfo(it),s.disposeIntermediateTensorInfo(pt),s.disposeIntermediateTensorInfo(ut),s.disposeIntermediateTensorInfo(Ve),{real:ze,imag:Be}}function WCe(n,e,t){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let i=0,o=0;for(let a=0;a<e;a++){const l=PY(s*a,e,t),c=jz(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(i/=e,o/=e),$Y(r,i,o,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GCe(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Te(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=ts({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=tJ(a,!1,t),c=ts({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const HCe={kernelName:c2,backendName:"cpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n){const{backend:e,attrs:t}=n,{shape:r,value:s,dtype:i}=t,o=i||xp(s),a=Cs(o,Te(r));return qCe(a,s,o),e.makeTensorInfo(r,o,a)}const jCe={kernelName:u2,backendName:"cpu",kernelFunc:nB};function qCe(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XCe={kernelName:h2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,s=t,i=li(r.dtype,Te(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let f=0;f<o;f++){const d=f*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const x=Math.round(l-g-1),w=d+m+y+b;let _=u[w];if(x>=0&&x<l){const C=x*c,k=d+m+C+b;_=u[k]}i[w]=_}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=QZ({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const y=ts({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});m=Xb({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=Xb({inputs:{a:m,b:o},backend:t});t.disposeIntermediateTensorInfo(g)}if(d){const g=m;if(u==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=ts({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=EI(t,m,d,y,p),t.disposeIntermediateTensorInfo(y)}else m=EI(t,m,d,a,p);t.disposeIntermediateTensorInfo(g)}return m}const YCe={kernelName:zb,backendName:"cpu",kernelFunc:KCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=eJ({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;m=Xb({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){const g=m;m=EI(t,m,d,a,p),t.disposeIntermediateTensorInfo(g)}return m}const JCe={kernelName:Bb,backendName:"cpu",kernelFunc:ZCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QCe(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=Te(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,h]=iC(r,s);if(c===0)return t.makeTensorInfo(l,r.dtype,[]);const f=t.data.get(s.dataId).values,d=t.bufferSync(r),p=uZ(f,d,r.dtype,c,a,u,h,r.shape,i);return t.makeTensorInfo(l,r.dtype,p.values)}const eke={kernelName:f2,backendName:"cpu",kernelFunc:QCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r;Zt([s,i],"gatherV2");const l=Tn(o,s.shape)[0],c=t.data.get(i.dataId).values,u=s.shape[l];for(let w=0;w<c.length;++w){const _=c[w];U(_<=u-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const f=Te(i.shape),d=_N(s,i,l,h),p=ts({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=ts({inputs:{x:i},backend:t,attrs:{shape:[d.batchSize,f/d.batchSize]}}),g=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=t.bufferSync(m),b=t.bufferSync(p),x=hZ(b,y,g);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(d.outputShape,x.dtype,x.values)}const nke={kernelName:Uv,backendName:"cpu",kernelFunc:tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rke(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Te(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=ts({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=tJ(a,!0,t),c=ts({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const ske={kernelName:d2,backendName:"cpu",kernelFunc:rke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ike=$r(ty,n=>Number.isFinite(n)?1:0,"bool"),oke={kernelName:ty,backendName:"cpu",kernelFunc:ike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ake=$r(ny,n=>Math.abs(n)===1/0?1:0,"bool"),lke={kernelName:ny,backendName:"cpu",kernelFunc:ake};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cke=$r(ry,n=>Number.isNaN(n)?1:0,"bool"),uke={kernelName:ry,backendName:"cpu",kernelFunc:cke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hke(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=gZ(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const fke={kernelName:m2,backendName:"cpu",kernelFunc:hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dke=$r(iy,n=>Math.log1p(n)),pke={kernelName:iy,backendName:"cpu",kernelFunc:dke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mke=Qs((n,e)=>n&&e),gke=$i(qv,mke,null,"bool"),yke={kernelName:qv,backendName:"cpu",kernelFunc:gke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bke=$r(Xv,n=>n?0:1,"bool"),vke={kernelName:Xv,backendName:"cpu",kernelFunc:bke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wke=Qs((n,e)=>n||e),xke=$i(Kv,wke,null,"bool"),Ske={kernelName:Kv,backendName:"cpu",kernelFunc:xke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Zt(s,"LRN");const c=s.shape[3],u=c-1,h=t.data.get(s.dataId).values,f=Te(s.shape),d=new Float32Array(f);function p(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let x=0;for(;y<=b;y++){const w=h[y];x+=w*w}return x}for(let m=0;m<f;m++){const g=p(m),y=h[m]*Math.pow(o+a*g,-l);d[m]=y}return t.makeTensorInfo(s.shape,s.dtype,d)}const Cke={kernelName:Yv,backendName:"cpu",kernelFunc:_ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Zt(o,"LRNGrad");const h=Te(o.shape),f=o.shape[3],d=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,m=t.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const x=b%f,w=b-x+Math.max(0,x-a),_=b-x+Math.min(f,x+a+1);let C=0;for(let k=w;k<_;k++)C+=Math.pow(p[k],2);C=c*C+l;for(let k=w;k<_;k++){let A=-2*c*u*p[k]*m[b]/C;b===k&&(A+=Math.pow(C,-u)),A*=d[b],g[k]+=A}}return t.makeTensorInfo(o.shape,s.dtype,g)}const Tke={kernelName:g2,backendName:"cpu",kernelFunc:kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=t;let l=s.shape;const c=l.length,u=Tn(i,l);let h=u;const f=Lr(h,c);let d=a.data.get(s.dataId).values;if(f!=null){const w=new Array(c);for(let _=0;_<w.length;_++)w[_]=l[f[_]];d=Zz(d,l,s.dtype,f,w),h=rs(h.length,c),l=w}Zt(s,"max"),ui("max",h,c);const[p,m]=Js(l,h),g=Te(m),y=bZ(d,g,p,s.dtype),b=a.write(y,p,s.dtype);let x=p;return o&&(x=Ls(p,u)),{dataId:b,shape:x,dtype:s.dtype}}const Eke={kernelName:Zv,backendName:"cpu",kernelFunc:nJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ike(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Zt(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ni(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=_o(s.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Mn(u.inShape,u.outShape))h=_h({inputs:{x:s},backend:t});else{const f=t.data.get(s.dataId).values,d=Jt(s.shape),p=eB(f,s.shape,s.dtype,d,u,"max");h=t.makeTensorInfo(u.outShape,s.dtype,p.values)}return h}const Ake={kernelName:Jv,backendName:"cpu",kernelFunc:Ike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Zt(s,"maxPool3d");const u=zl(s.shape,i,o,1,a,l,c),h=t.data.get(s.dataId).values,f=JZ(h,s.shape,s.dtype,Jt(s.shape),u,"max");return t.makeTensorInfo(f.shape,"float32",f.values)}const Nke={kernelName:Qv,backendName:"cpu",kernelFunc:Mke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ke(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Zt([s,i],"maxPool3DGrad");const u=zl(i.shape,o,a,1,l,c),h=t.bufferSync(i),f=w2e(h,u),d=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,_=u.effectiveFilterWidth,C=x-1-u.padInfo.front,k=_-1-u.padInfo.left,A=w-1-u.padInfo.top,M=wn(i.shape,"float32"),I=t.bufferSync(s);for(let N=0;N<u.batchSize;++N)for(let O=0;O<u.inChannels;++O)for(let R=0;R<u.inDepth;++R)for(let D=0;D<u.inHeight;++D)for(let z=0;z<u.inWidth;++z){const B=R-C,X=D-A,G=z-k;let ee=0;for(let pe=0;pe<x;pe+=g){const oe=(B+pe)/d;if(!(oe<0||oe>=u.outDepth||Math.floor(oe)!==oe))for(let Ne=0;Ne<w;Ne+=y){const ke=(X+Ne)/p;if(!(ke<0||ke>=u.outHeight||Math.floor(ke)!==ke))for(let De=0;De<_;De+=b){const ge=(G+De)/m;if(ge<0||ge>=u.outWidth||Math.floor(ge)!==ge)continue;const Xe=x*w*_-1-f.get(N,oe,ke,ge,O),Oe=pe*w*_+Ne*_+De,it=Xe===Oe?1:0;if(it===0)continue;const Ge=I.get(N,oe,ke,ge,O);ee+=Ge*it}}}M.set(ee,N,R,D,z,O)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const Rke={kernelName:b2,backendName:"cpu",kernelFunc:$ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pke(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;Zt([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=_o(a.shape,l,c,1,u,h),d=t.data.get(a.dataId).values,p=wn(f.outShape,a.dtype,ZZ(d,a.shape,a.dtype,f).values),m=f.strideHeight,g=f.strideWidth,y=f.dilationHeight,b=f.dilationWidth,x=f.effectiveFilterHeight,w=f.effectiveFilterWidth,_=w-1-f.padInfo.left,C=x-1-f.padInfo.top,k=wn(a.shape,"float32"),A=t.data.get(s.dataId).values,M=wn(s.shape,"float32",A);for(let I=0;I<f.batchSize;++I)for(let N=0;N<f.inChannels;++N)for(let O=0;O<f.inHeight;++O)for(let R=0;R<f.inWidth;++R){const D=O-C,z=R-_;let B=0;for(let X=0;X<x;X+=y){const G=(D+X)/m;if(!(G<0||G>=f.outHeight||Math.floor(G)!==G))for(let ee=0;ee<w;ee+=b){const pe=(z+ee)/g;if(pe<0||pe>=f.outWidth||Math.floor(pe)!==pe)continue;const oe=x*w-1-p.get(I,G,pe,N),Ne=X*w+ee,ke=oe===Ne?1:0;if(ke===0)continue;const De=M.get(I,G,pe,N);B+=De*ke}}k.set(B,I,O,R,N)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const Dke={kernelName:y2,backendName:"cpu",kernelFunc:Pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oke(n,e,t,r,s){const i=Jt(e),o=eB(n,e,t,i,s,"max"),a=ZZ(n,e,t,s,!0,r);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fke={kernelName:v2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;Zt(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=_o(r.shape,s,i,[1,1],o),[h,f]=Oke(c,r.shape,r.dtype,a,u),d=l.write(h,u.outShape,r.dtype),p=l.write(f,u.outShape,r.dtype);return[{dataId:d,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=Tn(i,s.shape),c=Js(s.shape,a)[1],u=Te(c),h=[],f=t.makeTensorInfo([],"float32",new Float32Array([u]));h.push(f);const d=sp({inputs:{x:s},backend:t,attrs:{dtype:"float32"}});h.push(d);const p=tB({inputs:{a:d,b:f},backend:t});h.push(p);const m=cC({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:o}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const zke={kernelName:ew,backendName:"cpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"min");const a=Tn(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=xa({inputs:{x:s},backend:t,attrs:{perm:c}}),l=rs(l.length,s.shape.length)),ui("min",l,u.shape.length);const[h,f]=Js(u.shape,l),d=Te(f),p=Hi(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const _=m[b+w];(Number.isNaN(_)||_<x)&&(x=_)}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=ts({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const Vke={kernelName:tw,backendName:"cpu",kernelFunc:Bke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,mode:o}=r;Zt(s,"mirrorPad");const a=i.map((x,w)=>x[0]+s.shape[w]+x[1]),l=i.map(x=>x[0]),c=i.map((x,w)=>x[0]+s.shape[w]),u=o==="reflect"?0:1,h=t.data.get(s.dataId).values,f=s.shape.length,d=Jt(s.shape),p=Te(a),m=a.length,g=Jt(a),y=li(s.dtype,p);for(let x=0;x<p;x++){let w=Rg(x,m,g);for(let C=0;C<m;C++)w[C]<l[C]?w[C]=l[C]*2-w[C]-u:w[C]>=c[C]&&(w[C]=(c[C]-1)*2-w[C]+u);w=w.map((C,k)=>C-l[k]);const _=mu(w,f,d);y[x]=h[_]}return{dataId:t.write(y,a,s.dtype),shape:a,dtype:s.dtype}}const Wke={kernelName:nw,backendName:"cpu",kernelFunc:Uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gke=Qs((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),Hke=$i(ly,Gke),jke={kernelName:ly,backendName:"cpu",kernelFunc:Hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=s.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Tn([a],s.shape),c=nJ({inputs:{x:s},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=Ls(c.shape,l),h=ts({inputs:{x:c},backend:t,attrs:{shape:u}}),f=Qz({inputs:{a:s,b:h},backend:t}),d=oZ({inputs:{x:f},backend:t}),p=cC({inputs:{x:d},backend:t,attrs:{axis:l,keepDims:!1}}),m=ts({inputs:{x:p},backend:t,attrs:{shape:u}}),g=tB({inputs:{a:d,b:m},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const qke={kernelName:ww,backendName:"cpu",kernelFunc:rJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xke(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r;Zt(s,"multinomial");const l=a?s:rJ({inputs:{logits:s},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,f=[c,i],d=Hi(Te(f),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=h[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+h[m+x];const y=Tw.alea(o.toString()),b=p*i;for(let x=0;x<i;++x){const w=y();d[b+x]=g.length;for(let _=0;_<g.length;_++)if(w<g[_]){d[b+x]=_;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(f,"int32",d)}const Kke={kernelName:w2,backendName:"cpu",kernelFunc:Xke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yke=tC;function Zke(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Zt(s,"NonMaxSuppression");const c=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,{selectedIndices:h}=Yke(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Jke={kernelName:x2,backendName:"cpu",kernelFunc:Zke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qke=eN;function eTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Zt(s,"NonMaxSuppressionPadded");const u=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:f,validOutputs:d}=Qke(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const tTe={kernelName:bM,backendName:"cpu",kernelFunc:eTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nTe=nC;function rTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Zt(s,"NonMaxSuppressionWithScore");const u=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=nTe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const sTe={kernelName:S2,backendName:"cpu",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iTe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r;Zt(s,"oneHot");const c=Te(s.shape),u=new Float32Array(c*o);u.fill(l);const h=t.data.get(s.dataId).values;for(let f=0;f<c;++f)h[f]>=0&&h[f]<o&&(u[f*o+h[f]]=a);return t.makeTensorInfo([...s.shape,o],i,u)}const oTe={kernelName:ow,backendName:"cpu",kernelFunc:iTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=lg({inputs:{input:r},backend:t}),i=AI({inputs:{x:s},backend:t}),o=Kb({inputs:{input:r},backend:t}),a=AI({inputs:{x:o},backend:t}),l=za({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return nB({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const aTe={kernelName:_w,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=lg({inputs:{input:r},backend:t}),i=sJ({inputs:{x:s},backend:t}),o=Kb({inputs:{input:r},backend:t}),a=AI({inputs:{x:o},backend:t}),l=za({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return nB({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const lTe={kernelName:iw,backendName:"cpu",kernelFunc:sJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return II({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{ji(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=II({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=Yb({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const cTe={kernelName:aw,backendName:"cpu",kernelFunc:iJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;Zt(s,"pad");const a=i.map((b,x)=>b[0]+s.shape[x]+b[1]),l=i.map(b=>b[0]),c=t.data.get(s.dataId).values,u=Te(s.shape),h=s.shape.length,f=Jt(s.shape),d=Te(a),p=a.length,m=Jt(a),g=li(s.dtype,d);o!==0&&g.fill(o);for(let b=0;b<u;b++){const w=Rg(b,h,f).map((C,k)=>C+l[k]),_=mu(w,p,m);g[_]=c[b]}return{dataId:t.write(g,a,s.dtype),shape:a,dtype:s.dtype}}const oJ={kernelName:lw,backendName:"cpu",kernelFunc:uTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hTe=Qs((n,e)=>Math.pow(n,e)),fTe=$i(uy,hTe),dTe={kernelName:uy,backendName:"cpu",kernelFunc:fTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pTe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,a=s.map(g=>t.data.get(g.dataId).values),l=s.map(g=>g.shape),c=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values,[h,f,d]=CZ(a,l,c,i.shape,i.dtype,u,o.shape),p=h.map(g=>t.makeTensorInfo([g.length],"int32",g)),m=t.makeTensorInfo(d,i.dtype,f);return p.concat([m])}const mTe={kernelName:vM,backendName:"cpu",kernelFunc:pTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gTe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=kZ(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const yTe={kernelName:wM,backendName:"cpu",kernelFunc:gTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bTe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,f=a.map(g=>t.data.get(g.dataId).values),d=a.map(g=>g.shape),[p,m]=TZ(c,s.shape,u,i.shape,i.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,i.dtype,m)}const vTe={kernelName:xM,backendName:"cpu",kernelFunc:bTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wTe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,dtype:i,step:o}=t,a=EZ(r,s,o,i);return e.makeTensorInfo([a.length],i,a)}const xTe={kernelName:_2,backendName:"cpu",kernelFunc:wTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const STe=$r(hy,n=>1/n),_Te={kernelName:hy,backendName:"cpu",kernelFunc:STe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CTe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Zt(s,"resizeBilinear");const l=Jt(s.shape),[c,u]=a,[h,f,d,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(Te([h,c,u,p])),y=[i&&c>1?f-1:f,i&&u>1?d-1:d],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let x=0;const w=y[0]/b[0],_=y[1]/b[1];for(let C=0;C<h;C++)for(let k=0;k<c;k++){let A;o?A=w*(k+.5)-.5:A=w*k;const M=Math.max(0,Math.floor(A)),I=A-M,N=Math.min(f-1,Math.ceil(A)),O=C*l[0]+M*l[1],R=C*l[0]+N*l[1];for(let D=0;D<u;D++){let z;o?z=_*(D+.5)-.5:z=_*D;const B=Math.max(0,Math.floor(z)),X=z-B,G=Math.min(d-1,Math.ceil(z)),ee=O+B*l[2],pe=R+B*l[2],oe=O+G*l[2],Ne=R+G*l[2];for(let ke=0;ke<p;ke++){const De=m[ee+ke],ge=m[pe+ke],Xe=m[oe+ke],Oe=m[Ne+ke],it=De+(Xe-De)*X,Ge=ge+(Oe-ge)*X,pt=it+(Ge-it)*I;g[x++]=pt}}}return t.makeTensorInfo([h,c,u,p],"float32",g)}const kTe={kernelName:dw,backendName:"cpu",kernelFunc:CTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TTe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Zt([i,s],"resizeBilinearGrad");const a=Jt(s.shape),[l,c,u,h]=s.shape,[,f,d]=i.shape,p=new Float32Array(l*c*u*h),m=[o&&f>1?c-1:c,o&&d>1?u-1:u],g=[o&&f>1?f-1:f,o&&d>1?d-1:d],y=m[0]/g[0],b=m[1]/g[1],x=t.data.get(i.dataId).values;let w=0;for(let _=0;_<l;_++){const C=_*a[0];for(let k=0;k<f;k++){const A=k*y,M=Math.floor(A),I=Math.min(Math.ceil(A),c-1),N=C+M*a[1],O=C+I*a[1],R=A-M,D=1-R;for(let z=0;z<d;z++){const B=z*b,X=Math.floor(B),G=Math.min(Math.ceil(B),u-1),ee=B-X,pe=1-ee,oe=N+X*a[2],Ne=N+G*a[2],ke=O+X*a[2],De=O+G*a[2],ge=D*pe,Xe=D*ee,Oe=R*pe,it=R*ee;for(let Ge=0;Ge<h;Ge++){const pt=x[w++];p[oe+Ge]+=pt*ge,p[Ne+Ge]+=pt*Xe,p[ke+Ge]+=pt*Oe,p[De+Ge]+=pt*it}}}}return t.makeTensorInfo([l,u,c,h],"float32",p)}const ETe={kernelName:T2,backendName:"cpu",kernelFunc:TTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ITe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Zt(s,"resizeNearestNeighbor");const l=Jt(s.shape),[c,u]=a,[h,f,d,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(h*c*u*p),y=[i&&c>1?f-1:f,i&&u>1?d-1:d],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],x=y[0]/b[0],w=y[1]/b[1];let _=0;for(let C=0;C<h;C++){const k=C*l[0];for(let A=0;A<c;A++){const M=o?x*(A+.5):x*A;let I=Math.min(f-1,i?Math.round(M):Math.floor(M));o&&(I=Math.max(0,I));const N=k+I*l[1];for(let O=0;O<u;O++){const R=o?w*(O+.5):w*O;let D=Math.min(d-1,i?Math.round(R):Math.floor(R));o&&(D=Math.max(0,D));const z=N+D*l[2];for(let B=0;B<p;B++){const X=m[z+B];g[_++]=X}}}}return t.makeTensorInfo([h,c,u,p],s.dtype,g)}const ATe={kernelName:fw,backendName:"cpu",kernelFunc:ITe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MTe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Zt([i,s],"resizeNearestNeighborGrad");const a=Jt(s.shape),l=Jt(i.shape),[c,u,h,f]=s.shape,[,d,p]=i.shape,m=new Float32Array(c*u*h*f),g=t.data.get(i.dataId).values,y=[o&&d>1?u-1:u,o&&p>1?h-1:h],b=[o&&d>1?d-1:d,o&&p>1?p-1:p],x=y[0]/b[0],w=y[1]/b[1],_=1/x,C=1/w,k=Math.ceil(_)*2+2,A=Math.ceil(C)*2+2;for(let M=0;M<c;M++){const I=M*a[0];for(let N=0;N<u;N++){const O=I+N*a[1],R=Math.floor(N*_),D=Math.floor(R-k/2);for(let z=0;z<h;z++){const B=O+z*a[2],X=Math.floor(z*C),G=Math.floor(X-A/2);for(let ee=0;ee<f;ee++){let pe=0;for(let oe=0;oe<k;oe++){const Ne=oe+D;if(Ne<0||Ne>=d)continue;const ke=I+Ne*l[1],De=Ne*x,ge=Math.min(u-1,o?Math.round(De):Math.floor(De));if(N===ge)for(let Xe=0;Xe<A;Xe++){const Oe=Xe+G;if(Oe<0||Oe>=p)continue;const it=ke+Oe*l[2],Ge=Oe*w,pt=Math.min(h-1,o?Math.round(Ge):Math.floor(Ge));z===pt&&(pe+=g[it+ee])}}m[B+ee]=pe}}}}return t.makeTensorInfo(s.shape,s.dtype,m)}const NTe={kernelName:k2,backendName:"cpu",kernelFunc:MTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Te(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r;Zt(s,"reverse");const o=s.shape.length,a=Tn(i,s.shape);if(o===0)return _h({inputs:{x:s},backend:t});const l=new ai(s.shape,s.dtype),c=t.bufferSync(s);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),f=h.slice();a.forEach(d=>f[d]=s.shape[d]-1-f[d]),l.set(c.get(...f),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const RTe={kernelName:pw,backendName:"cpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PTe={kernelName:z2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=li(r.dtype,Te(r.shape)),[c,u,h,f]=r.shape,[d,p]=lN(o,u,h),m=255,g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let w=0;w<c;w++){const _=w*h*u*f;for(let C=0;C<u;C++){const k=C*(h*f);for(let A=0;A<h;A++){const M=A*f;for(let I=0;I<f;I++){const N=[c,C,A,I],O=N[2],R=N[1];let D=(O-d)*y-(R-p)*g,z=(O-d)*g+(R-p)*y;D=Math.round(D+d),z=Math.round(z+p);let B=i;if(typeof i!="number"&&(I===3?B=m:B=i[I]),D>=0&&D<h&&z>=0&&z<u){const G=z*(h*f),ee=D*f,pe=_+G+ee+I;B=b[pe]}const X=_+k+M+I;l[X]=B}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DTe=$r(py,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),OTe={kernelName:py,backendName:"cpu",kernelFunc:DTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FTe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(i,s,o),f=!0,d=t.bufferSync(s),p=t.bufferSync(i),m=Om(d,p,o,h,c,l,a,u,0,f);return t.makeTensorInfo(o,m.dtype,m.values)}const LTe={kernelName:E2,backendName:"cpu",kernelFunc:FTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zTe(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<e?t=s+1:r=s;return r}function BTe(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<=e?t=s+1:r=s;return r}function VTe(n,e,t,r,s,i){const o=Cs("int32",t*s);for(let a=0;a<t;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)o[c+u]=i==="left"?zTe(l,e[u+c]):BTe(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UTe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=VTe(a,l,s.shape[0],s.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",c)}const WTe={kernelName:A2,backendName:"cpu",kernelFunc:UTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GTe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e;Zt([r,s,i],"select");const o=r.shape.length,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=Ii(s.dtype,i.dtype),h=Hi(Te(s.shape),u);let f=0;const d=o===0||o>1||s.shape.length===1?1:Te(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<d;m++)a[p]===1?h[f++]=l[p]:h[f++]=c[p];return t.makeTensorInfo(s.shape,u,h)}const HTe={kernelName:mw,backendName:"cpu",kernelFunc:GTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jTe=aC,qTe=lC,XTe=$r(gy,n=>n>=0?qTe*n:jTe*(Math.exp(n)-1)),KTe={kernelName:gy,backendName:"cpu",kernelFunc:XTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YTe=$r(vy,n=>n<0?-1:n>0?1:0),ZTe={kernelName:vy,backendName:"cpu",kernelFunc:YTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JTe=$r(yy,n=>Math.sin(n)),QTe={kernelName:yy,backendName:"cpu",kernelFunc:JTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eEe=$r(by,n=>Math.sinh(n)),tEe={kernelName:by,backendName:"cpu",kernelFunc:eEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nEe=11920928955078125e-23,hG=Math.log(nEe)+2,rEe=$r(xy,n=>{const e=n>-hG,t=n<hG,r=Math.exp(n);let s;return t?s=r:e?s=n:s=Math.log(1+r),s}),sEe={kernelName:xy,backendName:"cpu",kernelFunc:rEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;Zt([s],"spaceToBatchND");const a=Te(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=oJ.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),u=Dy(c.shape,i,a,!1),h=Oy(u.length,i.length,!1),f=Fy(c.shape,i,a,!1),m=ts({inputs:{x:c},backend:t,attrs:{shape:u}}),b=xa({inputs:{x:m},backend:t,attrs:{perm:h}}),_=ts({inputs:{x:b},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),_}const oEe={kernelName:bw,backendName:"cpu",kernelFunc:iEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aEe(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values[0],[h,f,d,p,m]=NZ(a,r.shape,r.dtype,l,s.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],s.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const lEe={kernelName:SM,backendName:"cpu",kernelFunc:aEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cEe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(s.dataId).values),a=t.data.get(r.dataId).values,l=Array.from(t.data.get(i.dataId).values),[c,u,h]=$Z(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const uEe={kernelName:_M,backendName:"cpu",kernelFunc:cEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hEe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=Jz(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const fEe={kernelName:M2,backendName:"cpu",kernelFunc:hEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dEe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=Jz(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const pEe={kernelName:N2,backendName:"cpu",kernelFunc:dEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mEe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Fu(i,s,a),d=!1,p=t.bufferSync(s);let m;switch(i.dtype){case"bool":{const g=t.bufferSync(i),y=!!t.data.get(o.dataId).values[0];m=Om(p,g,a,f,u,c,l,h,y,d);break}case"float32":{const g=t.bufferSync(i),y=t.data.get(o.dataId).values[0];m=Om(p,g,a,f,u,c,l,h,y,d);break}case"int32":{const g=t.bufferSync(i),y=t.data.get(o.dataId).values[0];m=Om(p,g,a,f,u,c,l,h,y,d);break}case"string":{const g=t.bufferSync(i),y=kc(t.data.get(o.dataId).values[0]);m=Om(p,g,a,f,u,c,l,h,y,d);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,m.dtype,m.values)}const gEe={kernelName:$2,backendName:"cpu",kernelFunc:mEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=Tn(o,s.shape)[0],l=SN(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(h=>{const f=[...u];f[a]=h;const d=cg({inputs:{x:s},backend:t,attrs:{begin:c,size:f}});return c[a]+=h,d})}const bEe={kernelName:vw,backendName:"cpu",kernelFunc:yEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vEe={kernelName:R2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Zt(t,"square");const s=r.data.get(t.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wEe=$r(Iy,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),xEe={kernelName:Iy,backendName:"cpu",kernelFunc:wEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r;Zt(s,"stridedSlice");const{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=iN(s.shape,i,o,a,l,c,u,h,f);let _;if(m)_=ts({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=sN(b,x,w),k=cg({inputs:{x:s},backend:t,attrs:{begin:b,size:C}});_=ts({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(k)}else{const C=t.bufferSync(s),k=DZ(d,C,w,b);_=t.makeTensorInfo(p,k.dtype,k.values)}return _}const _Ee={kernelName:D2,backendName:"cpu",kernelFunc:SEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CEe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.data.get(u.dataId).values,d=t.data.get(h.dataId).values,[p,m]=OZ(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const kEe={kernelName:O2,backendName:"cpu",kernelFunc:CEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TEe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,h]=FZ(a,l,s),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const EEe={kernelName:CM,backendName:"cpu",kernelFunc:TEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IEe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=LZ(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const AEe={kernelName:kM,backendName:"cpu",kernelFunc:IEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MEe=$r(ky,n=>Math.tan(n)),NEe={kernelName:ky,backendName:"cpu",kernelFunc:MEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ee=$r(Ty,n=>Math.tanh(n)),REe={kernelName:Ty,backendName:"cpu",kernelFunc:$Ee};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PEe(n){const{inputs:e,backend:t}=n,{tensor:r,indices:s,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=Fu(i,s,r.shape),h=!1,f=t.bufferSync(s),d=t.bufferSync(i),p=t.bufferSync(r),m=Om(f,d,r.shape,u,l,a,o,c,p,h);return t.makeTensorInfo(r.shape,m.dtype,m.values)}const DEe={kernelName:I2,backendName:"cpu",kernelFunc:PEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;Zt(s,"tile");const o=BZ(t.bufferSync(s),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const FEe={kernelName:Ey,backendName:"cpu",kernelFunc:OEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r;Zt(s,"topk");const a=t.data.get(s.dataId).values,[l,c]=UZ(a,s.shape,s.dtype,i,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const zEe={kernelName:F2,backendName:"cpu",kernelFunc:LEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BEe(n){const{inputs:e,attrs:t,backend:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=Jt(s.shape),b=y[0],x=y[1],w=y[2],_=Jt(g),C=_[0],k=_[1],A=_[2],M=li(s.dtype,Te(g));M.fill(l);const I=r.data.get(s.dataId).values,N=r.data.get(i.dataId).values;for(let R=0;R<u;++R){const D=i.shape[0]===1?N:N.subarray(R*8,R*8+8);for(let z=0;z<p;++z)for(let B=0;B<m;++B)for(let X=0;X<d;++X){let G;const ee=D[6]*B+D[7]*z+1;if(ee===0)continue;const pe=(D[0]*B+D[1]*z+D[2])/ee,oe=(D[3]*B+D[4]*z+D[5])/ee,Ne=fG(pe,f,a),ke=fG(oe,h,a);switch(o){case"nearest":G=jEe(I,h,f,b,x,w,R,ke,Ne,X,l);break;case"bilinear":G=qEe(I,h,f,b,x,w,R,ke,Ne,X,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const De=R*C+z*k+B*A+X;M[De]=G}return r.makeTensorInfo(g,s.dtype,M)}return{dataId:r.write(M,g,s.dtype),shape:s.shape,dtype:s.dtype}}const VEe={kernelName:L2,backendName:"cpu",kernelFunc:BEe};function fG(n,e,t){switch(t){case"reflect":return UEe(n,e);case"wrap":return WEe(n,e);case"nearest":return HEe(n,e);case"constant":default:return GEe(n)}}function UEe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{const r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return Zd(0,t,e-1)}function WEe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{const r=e-1;t-=e*Math.trunc(t/r)}return Zd(0,t,e-1)}function GEe(n,e){return n}function HEe(n,e){return Zd(0,n,e-1)}function w1(n,e,t,r,s,i,o,a,l,c,u){const h=o*r+a*s+l*i+c;return 0<=a&&a<e&&0<=l&&l<t?n[h]:u}function jEe(n,e,t,r,s,i,o,a,l,c,u){const h=Math.round(a),f=Math.round(l);return w1(n,e,t,r,s,i,o,h,f,c,u)}function qEe(n,e,t,r,s,i,o,a,l,c,u){const h=Math.floor(a),f=Math.floor(l),d=h+1,p=f+1,m=(p-l)*w1(n,e,t,r,s,i,o,h,f,c,u)+(l-f)*w1(n,e,t,r,s,i,o,h,p,c,u),g=(p-l)*w1(n,e,t,r,s,i,o,d,f,c,u)+(l-f)*w1(n,e,t,r,s,i,o,d,p,c,u);return(d-a)*m+(a-h)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XEe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;Zt(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=WZ(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const KEe={kernelName:TM,backendName:"cpu",kernelFunc:XEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YEe(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let d=0;d<o;d++)d!==i&&(l[c++]=s.shape[d]);const u=new Array(o).fill(0),h=s.shape.slice();h[i]=1;const f=new Array(a);for(let d=0;d<f.length;d++){u[i]=d;const p=cg({inputs:{x:s},backend:t,attrs:{begin:u,size:h}});f[d]=ts({inputs:{x:p},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(p)}return f}const ZEe={kernelName:xw,backendName:"cpu",kernelFunc:YEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r;Zt(s,"unsortedSegmentSum");const a=s.shape.length,l=i.shape.length,c=[],u=[],h=a-l;let f=i;for(let p=0;p<h;++p){const m=II({inputs:{input:f},backend:t,attrs:{dim:p+1}});f=m,u.push(m)}for(let p=0;p<o;++p){const m=Uf(p,"int32"),g=t.makeTensorInfo([],"int32",m),y=sZ({inputs:{a:g,b:f},backend:t}),b=sp({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),x=kN({inputs:{a:b,b:s},backend:t}),w=cC({inputs:{x},backend:t,attrs:{axis:0,keepDims:!1}});c.push(w),u.push(g),u.push(y),u.push(b),u.push(x),u.push(w)}const d=iJ({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const QEe={kernelName:Sw,backendName:"cpu",kernelFunc:JEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eIe=[X_e,ASe,Y_e,J_e,DSe,e2e,n2e,s2e,o2e,l2e,u2e,f2e,p2e,y2e,v2e,S2e,C2e,T2e,I2e,j_e,M2e,$2e,P2e,FSe,O2e,RSe,zSe,L2e,MSe,B2e,U2e,W2e,H2e,q2e,K2e,Z2e,Q2e,tCe,rCe,iCe,aCe,cCe,hCe,dCe,pCe,gCe,bCe,wCe,xCe,SCe,_Ce,kCe,ICe,z_e,MCe,BSe,LCe,VSe,zCe,WSe,HCe,jCe,XCe,HSe,qSe,YCe,JCe,eke,nke,KSe,ZSe,NSe,ske,V2e,oke,lke,uke,B_e,QSe,t_e,fke,r_e,pke,yke,vke,Ske,Cke,Tke,Eke,i_e,Ake,Nke,Rke,Dke,Fke,zke,Vke,a_e,Wke,jke,Kke,c_e,h_e,Jke,tTe,sTe,d_e,oTe,lTe,cTe,oJ,dTe,U_e,g_e,mTe,yTe,vTe,xTe,$Se,kD,_Te,W_e,G_e,H_e,kTe,ETe,ATe,NTe,RTe,PTe,OTe,C_e,LTe,WTe,HTe,KTe,T_e,ZTe,QTe,tEe,E_e,qke,sEe,oEe,lEe,uEe,fEe,pEe,gEe,bEe,M_e,vEe,$_e,P_e,xEe,_Ee,kEe,EEe,AEe,L_e,TCe,NEe,REe,DEe,FEe,zEe,VEe,p_e,KEe,ZEe,QEe,aTe];for(const n of eIe)B2(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Am={},Uk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function tIe(n,e){Am[n]=e}function _u(n,e){if(!(n in Am)||e!=null){const r=rIe(n,e);if(r!==null)Am[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Am[n];return t==null||t.isContextLost()?(delete Am[n],_u(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Am[n])}function nIe(n){if(!Ee().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function rIe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??nIe(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Am[n]},!1),Ee().getBool("SOFTWARE_WEBGL_ENABLED")&&(Uk.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Uk)||t.getContext("experimental-webgl",Uk):t.getContext("webgl2",Uk)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var SS;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(SS||(SS={}));var Cl;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Cl||(Cl={}));var io;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(io||(io={}));function uC(n,e){return[e,n]}function sIe(n,e){return n*e}function Wk(n){const e=Te(n),t=Math.ceil(e/4);return pI(t)}function Aw(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function iIe(n,e){const[t,r]=Aw(n,e);return t*r*4}function rB(n,e){const t=n;let r,s,i,o,a,l,c,u,h,f;return Ee().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,f=t.FLOAT,l=t.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,f=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(n,e){const t=e();return Ee().getBool("DEBUG")&&oIe(n),t}function oIe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+uIe(n,e))}const aIe=596e-10,lIe=65504;function cIe(n){return!!(Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||aIe<Math.abs(n)&&Math.abs(n)<lIe)}function uIe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Gk(n,e){return jf(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function hIe(n,e){const t=jf(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function fIe(n,e){const t=jf(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),Ee().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw aJ(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const dIe=/ERROR: [0-9]+:([0-9]+):/g;function aJ(n,e){const t=dIe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),i=s.length.toString().length+2,o=s.map((h,f)=>Um((f+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Um(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function pIe(n){return jf(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function mIe(n,e){if(Bt(n,()=>n.linkProgram(e)),!Ee().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function n3(n,e){if(Bt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function gIe(n,e){const t=jf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function yIe(n,e){const t=jf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function bIe(n){return jf(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function vIe(n,e){const t=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function wIe(n){return jf(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function dG(n,e,t,r,s,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Bt(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),Bt(n,()=>n.enableVertexAttribArray(a)),!0)}function xIe(n,e,t){TIe(n,t),Bt(n,()=>n.activeTexture(n.TEXTURE0+t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function SIe(n,e,t){return jf(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function _Ie(n,e,t){return n.getUniformLocation(e,t)}function CIe(n,e,t,r){Bt(n,()=>xIe(n,e,r)),Bt(n,()=>n.uniform1i(t,r))}function r3(n,e,t){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function pG(n,e){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Hk(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+kIe(n,e))}function kIe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function jf(n,e,t){const r=Bt(n,()=>e());if(r==null)throw new Error(t);return r}function TIe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Zb(n,e=2){return Te(n.slice(0,n.length-e))}function Jb(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function jk(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Zb(n),...Jb(n)]),e}function EIe(n,e=!1){let t=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ee().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ee().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,l)=>l>=n.length-2?pM(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Bf(n).newShape);let s=Te(n),i=null;n.length<=1&&s<=t?i=[1,s]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=Zb(n);let l=2,c=2;n.length&&([l,c]=Jb(n)),s=a*(l/2)*(c/2),i=pI(s).map(u=>u*2)}else i=pI(s);return i}function qk(n){return n%2===0}function MI(n,e){if(n=n.slice(-2),e=e.slice(-2),Mn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r||qk(t)&&qk(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&qk(n[0])&&qk(e[0])}let s3,i3;function IIe(n){if(s3==null){const e=_u(n);s3=e.getParameter(e.MAX_TEXTURE_SIZE)}return s3}function AIe(n){if(i3==null){const e=_u(n);i3=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,i3)}function MIe(n){if(n===0)return 0;let e;const t=_u(n);return yc(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:yc(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function yc(n,e){return n.getExtension(e)!=null}function mG(n){try{if(_u(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function NIe(n){if(n===0)return!1;const e=_u(n);if(n===1){if(!yc(e,"OES_texture_float"))return!1}else if(!yc(e,"EXT_color_buffer_float"))return!1;return ED(e)}function $Ie(n){if(n===0)return!1;const e=_u(n);if(n===1){if(!yc(e,"OES_texture_float")||!yc(e,"WEBGL_color_buffer_float"))return!1}else{if(yc(e,"EXT_color_buffer_float"))return ED(e);const r="EXT_color_buffer_half_float";if(yc(e,r)){const s=e.getExtension(r);return RIe(e,s)}return!1}return ED(e)}function ED(n){const e=rB(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function RIe(n,e){const t=rB(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,i=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,i,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}function PIe(n){return n!==2?!1:_u(n).fenceSync!=null}function hC(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qt=Ee();Qt.registerFlag("HAS_WEBGL",()=>Qt.getNumber("WEBGL_VERSION")>0);Qt.registerFlag("WEBGL_VERSION",()=>mG(2)?2:mG(1)?1:0);Qt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qt.get("WEBGL_VERSION")===2);Qt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qt.registerFlag("WEBGL_PACK",()=>Qt.getBool("HAS_WEBGL"));Qt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CLIP",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_REDUCE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_CONV_IM2COL",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>IIe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>AIe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Qt.getNumber("WEBGL_VERSION");return n===0?0:MIe(n)});Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!kL());Qt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>NIe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>$Ie(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>PIe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Qt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>kL()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Qt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_EXP_CONV",()=>!1);Qt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qt.getBool("IS_TEST"));Qt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qo(){let n,e,t,r,s,i,o,a,l,c;return Ee().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=Ee().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ly(n,e,t="index"){const r=Jt(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / ${s}`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`;return`${o}; ${a};`}).join("")}function TN(n,e,t="index"){const r=Jt(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function DIe(n,e){const t=n.length,r=n.map(i=>`${e}[${i}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let i=t-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}function OIe(n,e,t="index"){const r=n.map((i,o)=>o),s=DIe(r,e);return s.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${s[o]}`,l=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`;return`${a}; ${l};`}).join("")}function sB(n){const e=Jt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function iB(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const lJ=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:cJ}=XY;function FIe(n,e,t){const r=[];if(n.forEach(d=>{const p=Te(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:m}=oB(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),i=n.map(d=>LIe(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Qo(),l=VIe(a);let c,u,h=GIe(a);return e.isPacked?(c=zIe(e.logicalShape,o,t.enableShapeUniforms),u=WIe(a)):(c=BIe(e.logicalShape,o,t.enableShapeUniforms),u=UIe(a)),t.packedInputs&&(h+=XIe),[h,l,u,s,c,i,t.userCode].join(`
`)}function Mw(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return oAe(n,e);case 1:return lAe(n,e);case 2:return uAe(n,e);case 3:return fAe(n,e);case 4:return pAe(n,e);case 5:return mAe(n);case 6:return gAe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function uJ(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return iAe(n);case 1:return aAe(n,e);case 2:return cAe(n,e);case 3:return hAe(n,e);default:return dAe(n,e)}}function LIe(n,e,t=!1,r){let s="";t?s+=uJ(n,r):s+=Mw(n,r);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?s+=yAe(n,e):s+=bAe(n,e)),s}function zIe(n,e,t){switch(n.length){case 0:return hJ();case 1:return KIe(n,e,t);case 2:return rAe(n,e,t);case 3:return ZIe(n,e,t);default:return QIe(n,e,t)}}function BIe(n,e,t){switch(n.length){case 0:return hJ();case 1:return YIe(n,e,t);case 2:return sAe(n,e,t);case 3:return JIe(n,e,t);case 4:return eAe(n,e,t);case 5:return tAe(n,e);case 6:return nAe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function VIe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function UIe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function WIe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function GIe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${HIe}
    ${jIe}
    ${qIe}
  `}const HIe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,jIe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qIe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,XIe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function hJ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function KIe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function YIe(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function ZIe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function JIe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${TN(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=Ly(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function QIe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${l});
    }
  `}function eAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${TN(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Ly(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function tAe(n,e){const t=Ly(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function nAe(n,e){const t=Ly(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function rAe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Mn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function sAe(n,e,t){return Mn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function zy(n){return`offset${n}`}function iAe(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Qo();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function oAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,i]=n.shapeInfo.texShape;if(s===1&&i===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=zy(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function aAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,i=Qo();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function lAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Nw(n)}
      }
    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(o===1&&i===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=zy(t);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function cAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Qo();if(i!=null&&Mn(t,i))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function uAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Mn(t,i)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=i[0],d=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=Bf(t),l=o;if(l.length<t.length){const f=$w(n,l),d=["row","col"];return`
      ${Mw(f,e)}
      float ${s}(int row, int col) {
        return ${s}(${Rw(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Nw(n)}
      }
    `;const c=i[0],u=i[1],h=zy(r);return u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function hAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const f=t.slice(1),d=[1,2],p=$w(n,f),m=["b","row","col"];return`
        ${uJ(p,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Rw(m,d)});
        }
      `}const a=Qo();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function fAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Bf(t),c=a;if(c.length<t.length){const m=$w(n,c),g=["row","col","depth"];return`
        ${Mw(m,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Rw(g,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Nw(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],f=u[1],d=n.shapeInfo.flatOffset;if(f===i&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const p=zy(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function dAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Qo();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(i[o-1]/2);let f=h*Math.ceil(i[o-2]/2),d="int b, int row, int col",p=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)d=`int b${m}, `+d,f*=i[o-m-1],p=`b${m} * ${f} + `+p;return`
    vec4 ${r}(${d}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${s.texture2D}(${t}, uv);
    }
  `}function pAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Bf(t);if(l.length<t.length){const b=$w(n,l),x=["row","col","depth","depth2"];return`
      ${Mw(b,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Rw(x,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Nw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${p}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===i&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=zy(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function mAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],i=e[3]*s,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Bf(e);if(l.length<e.length){const m=$w(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${Mw(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Rw(g,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${s})) +
          depth3;
        ${Nw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1];if(d===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===s&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const p=zy(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function gAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:i}=Bf(e);if(s.length<e.length){const g=$w(n,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Mw(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Rw(y,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Nw(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],p=f[1];if(p===u&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===o&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=zy(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Nw(n){const e=n.name,t=Te(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function yAe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=cJ(n.shapeInfo.logicalShape,e.logicalShape),l=Fr(o),c=o-i;let u;const h=["x","y","z","w","u","v"];i===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${h[b+c]} = 0;`).join(`
`);let f="";o<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((b,x)=>`coords.${h[x+c]}`).join(", ");let d="return outputValue;";const m=Te(n.shapeInfo.logicalShape)===1,y=Te(e.logicalShape)===1;if(i===1&&!m&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=i-2,x=i-1;a.indexOf(b)>-1&&a.indexOf(x)>-1?d="return vec4(outputValue.x);":a.indexOf(b)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(x)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function bAe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Mn(o,i))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Fr(l),u=cJ(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let f;const d=["x","y","z","w","u","v"];a===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(m=>`coords.${d[m+h]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((m,g)=>`coords.${d[g+h]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${p});
    }
  `}function Fr(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function oB(n,e,t){const{newShape:r,keptDims:s}=Bf(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):r,l=!n&&i>1&&!Mn(e,t)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function $w(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Rw(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vAe(n,e,t,r){const s=t.map((u,h)=>{const f={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(f.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:f}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=FIe(s,o,e),l=fIe(n.gl,a),c=n.createProgram(l);return Ee().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},fJ(n,e,c)))}function fJ(n,e,t){const r=[],s=[];let i,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),Ee().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const f={name:h,uniform:n.getUniformLocation(t,h,u),offset:n.getUniformLocation(t,`offset${h}`,u)};e.enableShapeUniforms&&(f.shape=n.getUniformLocation(t,`${h}Shape`,u),f.texShape=n.getUniformLocation(t,`${h}TexShape`,u)),r.push(f)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),o=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)s.push(n.getUniformLocation(t,h.name,u));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function gG(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,i=e[r],o=i.shape;if(!Mn(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!Mn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function wAe(n,e,t,r,s){e.program.enableShapeUniforms||(gG(e.inShapeInfos,t),gG([e.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),Ee().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:u,offset:h,shape:f,texShape:d}=e.variablesLocations[l];if(f){const{uniformShape:p}=oB(e.program.packedInputs,c.shape,c.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(f,new Int32Array(p));break;case 2:n.gl.uniform2iv(f,new Int32Array(p));break;case 3:n.gl.uniform3iv(f,new Int32Array(p));break;case 4:n.gl.uniform4iv(f,new Int32Array(p));break}}if(d&&n.gl.uniform2i(d,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(Te(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let p=c.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(u,p)}continue}c.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Jt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],u=e.customUniformLocations[l],h=s[l];if(c.type==="float")n.gl.uniform1fv(u,h);else if(c.type==="vec2")n.gl.uniform2fv(u,h);else if(c.type==="vec3")n.gl.uniform3fv(u,h);else if(c.type==="vec4")n.gl.uniform4fv(u,h);else if(c.type==="int")n.gl.uniform1iv(u,h);else if(c.type==="ivec2")n.gl.uniform2iv(u,h);else if(c.type==="ivec3")n.gl.uniform3iv(u,h);else if(c.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function xAe(n,e,t){let r="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=oB(n.packedInputs,o.shape,l);let f="",d="",p="";if(u.length===1&&n.packedInputs){const _=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${_[0]>1}_${_[1]>1}`}else if(u.length===2&&!n.packedInputs)d=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const _=Jt(u);p=`${_[0]===l[1]}_${_[_.length-1]===l[1]}`}const m=o.shape.length,g=u.length===2&&Mn(o.shape,l),y=Te(o.shape)===1,b=Df(o.shape,t.shape),x=!n.packedInputs&&m===t.shape.length&&Mn(l,t.texData.texShape),w=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${c?h:""}_${u.length}_${y}_${b}_${g}_${f}_${d}_${p}_${w}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const s=n.userCode;let i=n.constructor.name;return i+="_"+r+"_"+s+`${Ee().getNumber("WEBGL_VERSION")}`,i}function Co(n){return Ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SAe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=SS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Qo();this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?TN(["r","c","d"],e):Ly(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Ae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=SS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Qo();this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?TN(["r","c","d"],e):Ly(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CAe{constructor(e){this.variableNames=["A"],this.outTexUsage=Cl.DOWNLOAD;const t=Qo();this.outputShape=e,this.userCode=`
      ${lJ}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Cl.DOWNLOAD;const t=Qo();this.outputShape=e,this.userCode=`
      ${lJ}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TAe={R:0,G:1,B:2,A:3};class yG{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Qo();this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++){const l=r[a];o+=`
          if(offset == ${a}) {
            result = values[${TAe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?iB():sB(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${o}
        }
        ${s.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EAe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Qo();this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length);let s="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?iB():sB(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IAe(n){const e=Qo(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return hIe(n,t)}function AAe(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return gIe(n,e)}function MAe(n){const e=new Uint16Array([0,1,2,2,1,3]);return yIe(n,e)}function fC(n,e,t,r,s,i){vIe(e,t);const o=bIe(n),a=n.TEXTURE_2D;return Bt(n,()=>n.bindTexture(a,o)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),Ee().getNumber("WEBGL_VERSION")===1?Bt(n,()=>n.texImage2D(a,0,r,e,t,0,s,i,null)):Bt(n,()=>n.texStorage2D(a,1,r,e,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function dJ(n){return n.internalFormatFloat}function NAe(n,e,t,r){const[s,i]=uC(e,t);return fC(n,s,i,dJ(r),r.textureFormatFloat,n.FLOAT)}function pJ(n){return n.internalFormatHalfFloat}function $Ae(n,e,t,r){const[s,i]=uC(e,t);return fC(n,s,i,pJ(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function mJ(n){return n.downloadTextureFormat}function RAe(n,e,t,r){const[s,i]=uC(e,t);return fC(n,s,i,mJ(r),n.RGBA,n.UNSIGNED_BYTE)}function gJ(n){return n.internalFormatPackedFloat}function PAe(n,e,t,r){const[s,i]=Aw(e,t);return fC(n,s,i,gJ(r),n.RGBA,n.FLOAT)}function yJ(n){return n.internalFormatPackedHalfFloat}function DAe(n,e,t,r){const[s,i]=Aw(e,t);return fC(n,s,i,yJ(r),n.RGBA,r.textureTypeHalfFloat)}function OAe(n,e,t){return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),dG(n,e,"clipSpacePos",t,3,20,0)&&dG(n,e,"uv",t,2,20,12)}function FAe(n,e,t,r,s,i){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;s instanceof Uint8Array?(o=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,o)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,r,0,n.RGBA,a,o)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function LAe(n,e,t){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function zAe(n,e,t,r){const s=n.createBuffer();Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=4*4*e*t;return Bt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function BAe(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function VAe(n,e,t,r){const[s,i]=uC(e,t),o=4,a=new Uint8Array(sIe(e*t,o));return Bt(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function UAe(n,e,t,r,s,i,o,a){const l=n,c=new Float32Array(iIe(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function WAe(n,e,t){const r=new Float32Array(e*t*4);return Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o3{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Ee().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,tIe(t,e)):this.gl=_u(t),e=this.gl,Ee().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Bt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>Bt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>Bt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>Bt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bt(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>Bt(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Bt(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>Bt(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ee().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Gk(this.gl,i),yc(this.gl,o))this.textureHalfFloatExtension=Gk(this.gl,o);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),yc(this.gl,s))this.colorBufferHalfFloatExtension=Gk(this.gl,s);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",yc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(yc(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=AAe(this.gl),this.indexBuffer=MAe(this.gl),this.framebuffer=wIe(this.gl),this.textureConfig=rB(this.gl,this.textureHalfFloatExtension)}get debug(){return Ee().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Bt(e,()=>e.finish()),Bt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Bt(e,()=>e.deleteFramebuffer(this.framebuffer)),Bt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Bt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Bt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),NAe(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),$Ae(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),RAe(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),LAe(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),FAe(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),DAe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),PAe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(pG(this.gl,this.framebuffer),this.outputTexture=null),Bt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>VAe(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,i,o){return UAe(this.gl,e,t,r,s,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return BAe(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=zAe(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(Ee().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},t=i}else Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>WAe(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=IAe(t));const r=pIe(t);Bt(t,()=>t.attachShader(r,this.vertexShader)),Bt(t,()=>t.attachShader(r,e)),mIe(t,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&n3(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Bt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),OAe(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Bt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&n3(this.gl,this.program),Bt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?SIe(this.gl,e,t):_Ie(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Bt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),CIe(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,i]=Aw(t,r);this.setOutputMatrixTextureDriver(e,s,i)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&n3(this.gl,this.program),Hk(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Gk(this.gl,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await nD(()=>this.disposed||this.isQueryAvailable(e,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=GAe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Ee().platform&&(r=Ee().platform.setTimeoutCustom.bind(Ee().platform)),nD(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),r3(this.gl,e,this.framebuffer),this.debug&&Hk(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(r3(this.gl,this.outputTexture,this.framebuffer),this.debug&&Hk(this.gl)):pG(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;r3(s,e,this.framebuffer),this.debug&&Hk(s),this.outputTexture=e,Bt(s,()=>s.viewport(0,0,t,r)),Bt(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function GAe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:HAe,bincountImpl:bJ,bincountReduceImpl:jAe,bitwiseAndImpl:qAe,castImpl:XAe,ceilImpl:KAe,concatImpl:YAe,equalImpl:ZAe,expImpl:JAe,expm1Impl:QAe,floorImpl:eMe,gatherNdImpl:tMe,gatherV2Impl:nMe,greaterImpl:rMe,greaterEqualImpl:sMe,lessImpl:iMe,lessEqualImpl:oMe,linSpaceImpl:aMe,logImpl:lMe,maxImpl:cMe,maximumImpl:uMe,minimumImpl:hMe,multiplyImpl:fMe,negImpl:dMe,notEqualImpl:pMe,prodImpl:mMe,raggedGatherImpl:gMe,raggedRangeImpl:yMe,raggedTensorToTensorImpl:bMe,rangeImpl:vMe,rsqrtImpl:wMe,scatterImpl:xMe,sigmoidImpl:SMe,simpleAbsImpl:vJ,sliceImpl:_Me,sparseFillEmptyRowsImpl:CMe,sparseReshapeImpl:kMe,sparseSegmentReductionImpl:wJ,sqrtImpl:TMe,staticRegexReplaceImpl:EMe,stridedSliceImpl:IMe,stringNGramsImpl:AMe,stringSplitImpl:MMe,stringToHashBucketFastImpl:NMe,subImpl:$Me,tileImpl:RMe,topKImpl:PMe,transposeImpl:aB,uniqueImpl:DMe}=GZ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Vo(n,e){return e===1?[n]:xJ(n,e)}function OMe(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FMe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Co(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Vo("rc",this.rank),r=Fr(this.rank),s=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2===1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`
        ${i}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${LMe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?iB():sB(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function LMe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?OIe(["r","c","d"],"inputShape"):Ly(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zMe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){const s=vG(t,r),i=wG(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=bG(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return s===io.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===io.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===io.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===io.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===io.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const i=vG(r,s),o=wG(t,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=bG(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=Ee().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function BMe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function bG(n,e,t,r,s){const i=VMe(e,r);let o;if(s){const[l,c]=Aw(n[0],n[1]);o=l*c}else{const[l,c]=uC(n[0],n[1]);o=l*c}const a=BMe(t,i);return o*a}function VMe(n,e){switch(n){case io.PACKED_2X2_FLOAT32:return gJ(e);case io.PACKED_2X2_FLOAT16:return yJ(e);case io.UNPACKED_FLOAT32:return dJ(e);case io.UNPACKED_FLOAT16:return pJ(e);case io.PACKED_4X1_UNSIGNED_BYTE:return mJ(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function UMe(n){return Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?io.PACKED_2X2_FLOAT32:io.UNPACKED_FLOAT32:n?io.PACKED_2X2_FLOAT16:io.UNPACKED_FLOAT16}function vG(n,e){if(n===Cl.UPLOAD)return io.PACKED_2X2_FLOAT32;if(n===Cl.RENDER||n==null)return UMe(e);if(n===Cl.DOWNLOAD||n===Cl.PIXELS)return io.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function wG(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fh=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Dc="if (isnan(x)) return x;",WMe="return x;",xG="return abs(x);",GMe="return (x >= 0.0) ? x : (exp(x) - 1.0);",HMe=Dc+`
  return (x < 0.0) ? 0.0 : x;
`,jMe=Dc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_d="return x;",qMe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XMe="return x;",KMe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,YMe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ZMe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,JMe="return 1.0 / (1.0 + exp(-1.0 * x));";class Ad{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QMe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length);const t=e.length,r=Vo("rc",t),s=Fr(t),i=OMe(t,r),o=r.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eNe=XM,tNe=1e-7,nNe=1e-4,Xk={};function rNe(n){return n in Xk||(Xk[n]={}),Xk[n]}const sNe=Ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),iNe=600;function oNe(){return Ee().global.screen==null?1024:Ee().global.screen.height*Ee().global.screen.width*window.devicePixelRatio*iNe/1024/1024}class EN extends V_{nextDataId(){return EN.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof o3)t=e;else{const r=_u(Ee().getNumber("WEBGL_VERSION"),e);t=new o3(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=_u(Ee().getNumber("WEBGL_VERSION"));t=new o3(r),this.binaryCache=rNe(Ee().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zMe(this.gpgpu),this.numMBBeforeWarning=oNe(),this.texData=new dM(this,bo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,s,i,o){const a=this.makeTensorInfo(t,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,i]},l.texShape=[s,i];const c=jk(t),u=new yG(c,!1,o),h=this.runWebGLProgram(u,[a],r,[[s,i]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,r){if((Ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ee().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:Cl.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,i){if(Ee().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:Cl.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let f;l?f=new Ad(a,_d):f=new fh(a,_d);const d=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:s}],s),p=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),p}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let u;c&&(u=ro());let h;if(s==="complex64"){const f=this.readSync(i.real.dataId),d=this.readSync(i.imag.dataId);h=xu(f,d)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=ro()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(m=>p.push(m))}const t=this.texData.get(e),{values:r,shape:s,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let p;l?p=new Ad(s,_d):p=new fh(s,_d);const m=this.runWebGLProgram(p,[{dataId:e,shape:s,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(Ee().getBool("DEBUG")&&!Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ee().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&Ee().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(p.texture.texture,...Wk(s))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=p[0],g=p[1];h=xu(m,g)}else if(c==null)h=this.getValuesFromTexture(e);else{const p=Te(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const p=this.gpgpu.gl;Bt(p,()=>p.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(p=>p(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&bo().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let d;l?d=new Ad(i,_d):d=new fh(i,_d);const p=this.runWebGLProgram(d,[{dataId:e,shape:i,dtype:a}],a),m=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=bo().makeTensorFromTensorInfo(u),f=this.texData.get(u.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>kc(s));return wn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return wn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!cIe(r))throw Ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),i=Te(t);if(Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),d=this.texData.get(f.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...Wk(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),p}const o=Ee().getBool("WEBGL_PACK")&&s===!0,a=o?jk(t):t,l=o?new kAe(a):new CAe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Tc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Tc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=bL(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ro(),endMs:null}}endTimer(e){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ro(),e)}async getQueryTime(e){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,i,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=sNe){return Ee().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Te(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){xl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return eNe(e.shape,t)}packedUnaryOp(e,t,r){const s=new Ad(e.shape,t),i=this.compileAndRun(s,[e],r);return bo().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=vJ(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,xG,e.dtype);const t=new fh(e.shape,xG),r=this.compileAndRun(t,[e]);return bo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&uu(r[0])){const i=r.map(o=>gu(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return bo().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new QMe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new FMe(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[Zb(e.shape),...Jb(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},i=[Zb(t),...Jb(t)],o=new SJ(i,r),a=!0,l=[r],c=this.runWebGLProgram(o,[s],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:i,dtype:o}=r;if(t!=null){const f=Te(i),d=t[0]*t[1]*4;U(f<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=jk(i);let l;s?l=new _Ae(a):l=new SAe(a);const c=!0,u=[t??Wk(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(e,t,r,s,i=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===SS.DENSE){const y=o??Wk(e.outputShape);l.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Te(a.shape)===0)return l.values=li(a.dtype,0),a;const c=[],u=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&Te(y.shape)<=Ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!MI(b.shape,y.shape)){const x=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),c.push(y),b=this.texData.get(y.dataId),x.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},f=xAe(e,u,h),d=this.getAndSaveBinary(f,()=>vAe(this.gpgpu,e,u,h)),p=this.activeTimers!=null;let m;p&&(m=this.startTimer()),Ee().get("ENGINE_COMPILE_ONLY")||wAe(this.gpgpu,d,u,h,s),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=Ee().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=ro();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!Ee().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,t,r,s,i=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Se(()=>{if(!Ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ee().getBool("DEBUG");Ee().set("DEBUG",!1);const t=this.abs(en(1e-8)).dataSync()[0];if(Ee().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?tNe:nNe}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=ro());let h=t.texShape;if(h==null&&(h=EIe(r,l),t.texShape=h),i!=null){const f=jk(r);let d,p=h[1],m=h[0];const g=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!g)&&([p,m]=Aw(h[0],h[1])),l?d=new EAe(f,g):d=new yG(f,g);const y=g?[m,p]:h,b=this.makeTensorInfo(y,s),x=this.texData.get(b.dataId);g?x.usage=Cl.PIXELS:x.usage=Cl.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),p,m,i);const w=[[m,p]],_=!0,C=this.runWebGLProgram(d,[b],s,w,_),k=this.texData.get(C.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,Ee().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=ro()-u)}else{const f=this.acquireTexture(h,a,s,l);t.texture=f}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return t!=null&&(r.values=aNe(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*lS(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(i){throw i}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Gz(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(aJ(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:r,infLoc:s,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=fJ(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";const{texture:s,height:i,width:o,channels:a}=e,l=bo().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(s,t,r,i,o,a);return bo().makeTensorFromDataId(c,t,r,l)}}EN.nextDataId=0;function aNe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */TL()&&IM("webgl",()=>new EN,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lB=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let ug=class{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=ln(t,r),this.enableShapeUniforms=Co(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const By=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Pw{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ln(t,r);const i=this.outputShape.length;this.enableShapeUniforms=Co(i);let o="";if(s)if(i===0||Te(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Fr(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Vo("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const lNe={kernelName:ey,backendName:"webgl",kernelFunc:Ha};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.texData.get(i.dataId),a=Ha({inputs:{x:r},backend:t}),l=Ha({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const cNe={kernelName:K_,backendName:"webgl",kernelFunc:Ap};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _J="return (a < 0.) ? b * a : a;",CJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function uNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=t.makeTensorInfo([],"float32",Uf(i,"float32")),a=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pw(CJ,s.shape,o.shape):new ug(_J,s.shape,o.shape),l=t.runWebGLProgram(a,[s,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const hNe={kernelName:Gv,backendName:"webgl",kernelFunc:uNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJ="return (a < 0.) ? b * a : a;",TJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function fNe(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pw(TJ,r.shape,s.shape):new ug(kJ,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],"float32")}const dNe={kernelName:cw,backendName:"webgl",kernelFunc:fNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dw="if (isnan(x)) return x;";function dr({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),f=t(h.values,l);return a.makeTensorInfo(o.shape,l,f)}const c=Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Ad(o.shape,e):u=new fh(o.shape,n),a.runWebGLProgram(u,[o],l)}}function co({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&l.dtype==="complex64"){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{const[w,_]=x,C={dataId:w.dataId,dtype:w.dtype,shape:l.shape},k={dataId:_.dataId,dtype:_.dtype,shape:c.shape},A=new ug(n,l.shape,c.shape);return u.runWebGLProgram(A,[C,k],Ii(w.dtype,_.dtype))}),b=Ap({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const h=i||Ii(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&s!=null){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g=l.dtype==="string"?Su(p):p,y=l.dtype==="string"?Su(m):m,[b,x]=s(l.shape,c.shape,g,y,h),w=u.makeTensorInfo(x,h),_=u.texData.get(w.dataId);return _.values=b,w}const f=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return f?d=new Pw(e,l.shape,c.shape,t):d=new ug(n,l.shape,c.shape),u.runWebGLProgram(d,[l,c],h)}}function _S(n,e=!1){if(n==="linear")return e?XMe:WMe;if(n==="relu")return e?YMe:HMe;if(n==="elu")return e?KMe:GMe;if(n==="relu6")return e?ZMe:jMe;if(n==="prelu")return e?TJ:kJ;if(n==="leakyrelu")return e?CJ:_J;if(n==="sigmoid")return e?JMe:qMe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EJ=class{constructor(e,t,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Co(this.outputShape.length);const u=s?e[1]:e[2],h=Math.ceil(u/2),f=s?"i * 2, rc.y":"rc.y, i * 2",d=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let x="rc.x",w="rc.x";e[0]<t[0]?x=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${w};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let _G=class{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ln(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG="return a * b;";function cB(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=Ii(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),c=new _G(SG.REAL,r.shape,s.shape),u=new _G(SG.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Ap({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),[c,u]=fMe(r.shape,s.shape,a.values,l.values,i),h=t.makeTensorInfo(u,i),f=t.texData.get(h.dataId);return f.values=c,h}let o;return Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Pw(CG,r.shape,s.shape):o=new ug(CG,r.shape,s.shape),t.runWebGLProgram(o,[r,s],i)}const pNe={kernelName:cy,backendName:"webgl",kernelFunc:cB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mNe(n,e,t){const r=[Zb(n.shape),...Jb(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[Zb(e),...Jb(e)],o=new SJ(i,r),a=!0,l=[r],c=t.runWebGLProgram(o,[s],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=t,a=Te(s.shape),l=mM(i,a),c=Te(l);U(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return u.isPacked&&!MI(s.shape,l)&&!(u.texture!==null&&MI(u.shape,l))?mNe(s,l,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const gNe={kernelName:hw,backendName:"webgl",kernelFunc:Et};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kG{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${eg(h)?h.toPrecision(2):h}, ones);`}let u="";i%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yNe=class{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(r/4)*4,h=r%4;let f=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bNe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=aN(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Vy(n,e,t,r){const s=bNe(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,h;t==="mean"?u=o===0?new kG({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new kG({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new yNe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=i,i=r.runWebGLProgram(u,[i],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vNe=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[t[o]];this.outputShape=r,this.rank=r.length;const s=Fr(this.rank),i=wNe(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function wNe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xNe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Fr(this.rank),i=xJ("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(n,e,t){const r=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xNe(n.shape,e):new vNe(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SNe(n,e,t,r){const s=e,i=n.shape.length,o=Tn(s,n.shape);let a=o;const l=Lr(a,i),c=l!=null;let u=n;c&&(u=IN(n,l,r),a=rs(a.length,i)),ui("sum",a,i);const[h,f]=Js(u.shape,a);let d=h;t&&(d=Ls(h,o));const p=Te(f),g=Te(n.shape)/p,y=Et({inputs:{x:u},attrs:{shape:[g,p]},backend:r}),b=U2(n.dtype),x=Vy(y,b,"sum",r),w=Et({inputs:{x},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),c&&r.disposeIntermediateTensorInfo(u),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return SNe(s,i,o,t)}const _Ne={kernelName:yw,backendName:"webgl",kernelFunc:AN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const h=o.texData.get(s.dataId).values,f=aB(h,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype);const d=o.texData.get(c.dataId);d.values=f}else c=IN(s,i,o);return c}const CNe={kernelName:Bd,backendName:"webgl",kernelFunc:Ko};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IJ=1e3;function NI({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Te(m),b=Te(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const _=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=Et({inputs:{x:n},backend:s,attrs:{shape:_}}),A=Et({inputs:{x:e},backend:s,attrs:{shape:C}}),M=[k,A],I=Math.max(y,b),N=t?k.shape[1]:k.shape[2],O=i!=null,R=o!=null,D=l==="leakyrelu",z=l!=null?_S(l,!0):null,B=O||R||D||z!=null;let X;if((d===1||p===1)&&N>IJ&&B===!1){let ee=k,pe=A;t&&(ee=Ko({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),M.push(ee)),r&&(pe=Ko({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),M.push(pe));const oe=p!==1,Ne=p===1;let ke=ee;oe&&(ke=Et({inputs:{x:ee},backend:s,attrs:{shape:[I,N,1]}}),M.push(ke));const De=p===1?2:1;let ge=pe;Ne&&(ge=Et({inputs:{x:pe},backend:s,attrs:{shape:[I,1,N]}}),M.push(ge));const Xe=cB({inputs:{a:ke,b:ge},backend:s});X=AN({inputs:{x:Xe},backend:s,attrs:{axis:De,keepDims:!0}}),M.push(Xe)}else{const ee=Ii(n.dtype,e.dtype),pe=new EJ(_,C,[I,d,p],t,r,O,z,R,D),oe=[k,A];if(i!=null&&oe.push(i),R&&oe.push(o),D){const Ne=s.makeTensorInfo([],"float32",Uf(a,"float32"));oe.push(Ne),M.push(Ne)}X=s.runWebGLProgram(pe,oe,ee)}const G=Et({inputs:{x:X},backend:s,attrs:{shape:w}});M.push(X);for(const ee of M)s.disposeIntermediateTensorInfo(ee);return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kNe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return NI({a:s,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const TNe={kernelName:Lb,backendName:"webgl",kernelFunc:kNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TG="return abs(x);";function ENe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=t.texData.get(r.dataId),o=vJ(i.values);return t.makeTensorInfo(r.shape,r.dtype,o)}let s;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ad(r.shape,TG):s=new fh(r.shape,TG),t.runWebGLProgram(s,[r],r.dtype)}const INe={kernelName:_v,backendName:"webgl",kernelFunc:ENe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ANe=Dc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,MNe=dr({opSnippet:ANe}),NNe={kernelName:Pg,backendName:"webgl",kernelFunc:MNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ne=Dc+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,RNe=dr({opSnippet:$Ne}),PNe={kernelName:Dg,backendName:"webgl",kernelFunc:RNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EG="return a + b;",DNe=co({opSnippet:EG,packedOpSnippet:EG,supportsComplex:!0,cpuKernelImpl:HAe}),ONe={kernelName:Sp,backendName:"webgl",kernelFunc:DNe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FNe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LNe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Ha({inputs:{x:r[0]},backend:t});if(r.length>Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=NE({inputs:r.slice(0,l),backend:t}),u=NE({inputs:r.slice(l),backend:t});return NE({inputs:[c,u],backend:t})}const s=r.map(l=>l.dtype).reduce((l,c)=>Ii(l,c)),i=r.map(l=>l.shape),a=Ee().getBool("WEBGL_PACK")?new LNe(r[0].shape,i):new FNe(r[0].shape,i);return t.runWebGLProgram(a,r,s)}const zNe={kernelName:Cv,backendName:"webgl",kernelFunc:NE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=Tn(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Ko({inputs:{x:s},backend:t,attrs:{perm:u}}),c=rs(c.length,a)),ui("all",c,a);const[f,d]=Js(h.shape,c),p=Te(d),m=Et({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Vy(m,m.dtype,"all",t);let y;if(o){const b=Ls(f,l);y=Et({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=Et({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const VNe={kernelName:U_,backendName:"webgl",kernelFunc:BNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=Tn(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Ko({inputs:{x:s},backend:t,attrs:{perm:u}}),c=rs(c.length,a)),ui("any",c,a);const[f,d]=Js(h.shape,c),p=Te(d),m=Et({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Vy(m,m.dtype,"any",t);let y;if(o){const b=Ls(f,l);y=Et({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=Et({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const WNe={kernelName:W_,backendName:"webgl",kernelFunc:UNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GNe=class{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HNe{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,U(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Fr(l),u=Vo("coords",l);let h,f;if(o===1){f=l+1;const A=Fr(f);h=`
        ${A} sourceLocR = ${A}(${u.join()}, 0);
        ++${u[l-1]};
        ${A} sourceLocG = ${A}(${u.join()}, 0);
        ++${u[l-2]};
        ${A} sourceLocA = ${A}(${u.join()}, 0);
        --${u[l-1]};
        ${A} sourceLocB = ${A}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const d=["x","y","z","w","u","v"].slice(0,f),p="."+d[f-1],m=d.map(A=>"int "+A),g=Vo("sourceLocR",f-1).concat("inIdx.r"),y=Vo("sourceLocG",f-1).concat("inIdx.g"),b=Vo("sourceLocB",f-1).concat("inIdx.b"),x=Vo("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",_=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,C=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,k=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${_}
          vec4 candidate = ${C};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n,e,t,r=null){let s=e.shape[0],i=e.shape[1];r!=null&&(s=r.shape[0],i=r.shape[1]);const o=aN(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new GNe(a,t,r==null),c=[e];r!=null&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=AJ(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function MJ(n,e,t,r=null){const s=r!=null?r.shape:e.shape,i=s[s.length-1],o=aN(i),a=new HNe(s,o,t,r==null),l=r==null?[e]:[e,r],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=MJ(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function NJ(n,e,t,r){const s=[t];if(ui("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!Ee().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[c,u]=Js(l.shape,s),h=Te(u),f=Et({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});i.push(f);const d=AJ(n,f,r);i.push(d);const p=Et({inputs:{x:d},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return MJ(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=Tn(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Ko({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=rs(o.length,l.shape.length)),ui("argMax",[o[0]],l.shape.length);const u=NJ(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const qNe={kernelName:kv,backendName:"webgl",kernelFunc:jNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=Tn(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Ko({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=rs(o.length,l.shape.length)),ui("argMin",[o[0]],l.shape.length);const u=NJ(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const KNe={kernelName:Tv,backendName:"webgl",kernelFunc:XNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YNe=Dc+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ZNe=dr({opSnippet:YNe}),JNe={kernelName:Og,backendName:"webgl",kernelFunc:ZNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QNe=Dc+"return log(x + sqrt(x * x + 1.0));",e$e=dr({opSnippet:QNe}),t$e={kernelName:Fg,backendName:"webgl",kernelFunc:e$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$e=Dc+`
  return atan(x);
`,r$e=dr({opSnippet:n$e}),s$e={kernelName:Lg,backendName:"webgl",kernelFunc:r$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$e=lB+`
  return atan(a, b);
`,o$e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+By+`
  return result;
`,a$e=co({opSnippet:i$e,packedOpSnippet:o$e}),l$e={kernelName:Bg,backendName:"webgl",kernelFunc:a$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$e=Dc+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,u$e=dr({opSnippet:c$e}),h$e={kernelName:zg,backendName:"webgl",kernelFunc:u$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CS=class{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),r){const A=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${A} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?i?g:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");const _=Math.floor(o/4)*4,C=o%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${_};
          if (${C===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${w});
      }
    `}},uB=class{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg";let w="0.0";if(x||(w="-1.0 / 1e-20"),r){const I=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${I} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const _="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const k=Math.floor(o/4)*4,A=o%4,M=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${_}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${k};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${C});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;hC(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ni(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=_o(s.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Mn(u.inShape,u.outShape))return Ha({inputs:{x:s},backend:t});const h=new CS(u,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}const d$e={kernelName:Ev,backendName:"webgl",kernelFunc:f$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],h=zl(s.shape,i,o,u,a,l,c),f=new uB(h,"avg",!1);return t.runWebGLProgram(f,[s],"float32")}const m$e={kernelName:Iv,backendName:"webgl",kernelFunc:p$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let g$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,f=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},y$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=h-1-e.padInfo.front,m=f-1-e.padInfo.top,g=d-1-e.padInfo.left,y=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=zl(o.shape,a,l,h,c,u),d=new y$e(f);return t.runWebGLProgram(d,[s],o.dtype)}const v$e={kernelName:H_,backendName:"webgl",kernelFunc:b$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;hC([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=_o(o.shape,a,l,1,c),h=new g$e(u);return t.runWebGLProgram(h,[s],o.dtype)}const x$e={kernelName:G_,backendName:"webgl",kernelFunc:w$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return NI({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const _$e={kernelName:Av,backendName:"webgl",kernelFunc:S$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let C$e=class{constructor(e,t,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="0.0";s!=null&&(ln(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(ln(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k$e{constructor(e,t,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="vec4(0.0)";s!=null&&(ln(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(ln(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T$e=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;U(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[r,s,i];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const f=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new k$e(r.shape,s.shape,i.shape,u,h,l):new C$e(r.shape,s.shape,i.shape,u,h,l);return e.runWebGLProgram(f,c,c[0].dtype)},E$e={kernelName:Vv,backendName:"webgl",kernelFunc:T$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let I$e=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Fr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=A$e(this.rank);let s;const i=e.map((o,a)=>`sourceLoc.${ID[a]} = start[${a}] + coords.${ID[a]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}};const ID=["x","y","z","w","u","v"];function A$e(n){if(n===1)return"sourceLoc";if(n<=6)return ID.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M$e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Fr(this.rank),r=Vo("coords",this.rank),s=Vo("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${o};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$e(n,e,t,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(t,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Wz(e,Jt(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}function Ow(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=oC(s,i,o);if(rN(s,a,l),Te(l)===0)return t.makeTensorInfo(l,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.texData.get(s.dataId),f=_Me(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,f)}const{isPacked:c}=t.texData.get(s.dataId),u=Uz(s.shape,a,l);if(c||!u){const h=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new M$e(l):new I$e(l),f=[a];return t.runWebGLProgram(h,[s],s.dtype,f)}return t.uploadToGPU(s.dataId),N$e(s,a,l,t)}const $$e={kernelName:gw,backendName:"webgl",kernelFunc:Ow};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R$e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=Dy(s.shape,i,a),c=Oy(l.length,i.length),u=Fy(s.shape,i,a),h=cN(o,i.length),f=uN(u,o,i.length),d=[],p=Et({inputs:{x:s},backend:t,attrs:{shape:l}}),m=Ko({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Et({inputs:{x:m},backend:t,attrs:{shape:u}}),y=Ow({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},P$e={kernelName:Mv,backendName:"webgl",kernelFunc:R$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.readSync(s.dataId),l=t.readSync(i.dataId),c=bJ(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const O$e={kernelName:j_,backendName:"webgl",kernelFunc:D$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F$e=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,L$e=`
  return float(int(a.r) & int(b.r));
`;function z$e(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ee().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,s])||o===1){const l=t.texData.get(r.dataId).values,c=t.texData.get(s.dataId).values,[u,h]=qAe(r.shape,s.shape,l,c,r.dtype),f=t.makeTensorInfo(h,r.dtype),d=t.texData.get(f.dataId);return d.values=u,f}let a;return i?a=new Pw(F$e,r.shape,s.shape,!1):a=new ug(L$e,r.shape,s.shape),t.runWebGLProgram(a,[r,s],r.dtype)}const B$e={kernelName:q_,backendName:"webgl",kernelFunc:z$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$e(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.readSync(r.dataId),o=t.readSync(s.dataId),a=ln(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const U$e={kernelName:X_,backendName:"webgl",kernelFunc:V$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W$e="return float(a != b);",$J=co({opSnippet:W$e,cpuKernelImpl:pMe,dtype:"bool"}),G$e={kernelName:sw,backendName:"webgl",kernelFunc:$J};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dC(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Ha({inputs:{x:s.complexTensorInfos.real},backend:t})}const H$e={kernelName:C2,backendName:"webgl",kernelFunc:dC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j$e="return float(int(x));";function q$e(n,e){const t=new fh(n.shape,j$e),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Ha({inputs:{x:s},backend:t});const o=ms(s.shape),a=AD({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=Ap({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const o=dC({inputs:{input:s},backend:t}),a=AD({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!gM(s.dtype,i)){const o=Ha({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId).values,[a,l,c]=XAe(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return q$e(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",li("bool",1)),l=$J({inputs:{a:s,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const X$e={kernelName:Vg,backendName:"webgl",kernelFunc:AD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG="return ceil(x);",K$e=dr({opSnippet:IG,packedOpSnippet:IG,cpuKernelImpl:KAe}),Y$e={kernelName:Ug,backendName:"webgl",kernelFunc:K$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z$e=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J$e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;Ee().getBool("WEBGL_PACK_CLIP")?a=new J$e(s.shape):a=new Z$e(s.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[s],s.dtype,l)}const eRe={kernelName:Wg,backendName:"webgl",kernelFunc:Q$e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tRe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function nRe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),i=new tRe(r.shape),o=[AG(r,s.complexTensorInfos.real),AG(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const rRe={kernelName:Nv,backendName:"webgl",kernelFunc:nRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sRe=class{constructor(e){this.outputShape=[],this.outputShape=ga(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];r.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const s=t.length,i=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iRe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ga(e,t);const r=this.outputShape,s=r.length,i=Fr(s),o=Vo("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const c=a[t],u=a.slice(-2),h=a.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];f+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Kk(a,c,g)}),
            vec2(${Kk(u,c,g)}));
        }`}const d=l.length,p=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${Kk(a,c,p)}),
          vec2(${Kk(u,c,p)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${f}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[s-1]} = ${o[s-1]} + 1;
        if (${o[s-1]} < ${r[s-1]}) {
          result.g = getValue(${o});
        }

        ${o[s-2]} = ${o[s-2]} + 1;
        if (${o[s-2]} < ${r[s-2]}) {
          result.a = getValue(${o});
        }

        ${o[s-1]} = ${o[s-1]} - 1;
        if (${o[s-2]} < ${r[s-2]} &&
            ${o[s-1]} < ${r[s-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Kk(n,e,t){const r=n.indexOf(e);return n.map((i,o)=>o===r?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MN(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Ha({inputs:{x:s.complexTensorInfos.imag},backend:t})}const oRe={kernelName:p2,backendName:"webgl",kernelFunc:MN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const d=n.map(b=>dC({inputs:{input:b},backend:t})),p=n.map(b=>MN({inputs:{input:b},backend:t})),m=x1(d,e,t),g=x1(p,e,t),y=Ap({inputs:{real:m,imag:g},backend:t});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const d=n.map(w=>{const C=[-1,Te(w.shape.slice(e))];return Et({inputs:{x:w},backend:t,attrs:{shape:C}})}),p=d.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),m=ga(d.map(w=>w.shape),1),g=d[0].shape[0]===1,y=YAe(p,m,r,g),b=ga(n.map(w=>w.shape),e),x=t.makeTensorInfo(b,r,y);return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const i=n.filter(d=>Te(d.shape)>0),o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const d=o?new fh(n[0].shape,_d):new Ad(n[0].shape,_d);return t.runWebGLProgram(d,n,r)}const a=Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const d=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);d.push(x1(g,e,t))}const p=x1(d,e,t);for(const m of d)t.disposeIntermediateTensorInfo(m);return p}if(o){const d=new iRe(i.map(p=>p.shape),e);return t.runWebGLProgram(d,i,r)}const{tensors2D:l,outShape:c}=aRe(i,e,t),u=new sRe(l.map(d=>d.shape)),h=t.runWebGLProgram(u,l,r);l.forEach(d=>t.disposeIntermediateTensorInfo(d));const f=Et({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),f}function aRe(n,e,t){const r=ga(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Et({inputs:{x:i},attrs:{shape:[-1,Te(i.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=Tn(s,e[0].shape)[0],o=e.map(c=>c.shape);oN(o,i);const a=ga(e.map(c=>c.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Te(c.shape)>0);return l.length===1?Ha({inputs:{x:l[0]},backend:t}):x1(l,i,t)}const lRe={kernelName:$v,backendName:"webgl",kernelFunc:RJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PJ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,x=g?3:1;let w="",_="";r&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C}
        ${_}
        setOutput(result);
      }
    `}}class cRe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DJ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Co(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)f+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)f+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){const b=o%2===0?pM(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",p="";r&&(s?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:i?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,p="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uRe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Co(this.outputShape.length);const{dataFormat:r}=t,s=Qo(),i=r==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $I(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function OJ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],f=t.outChannels,d=t.dataFormat==="channelsLast",p=!1,m=!1;let g;const y=[];if(i!=null){const w=$I(i.shape,d);w!=null&&(i=Et({inputs:{x:i},backend:r,attrs:{shape:w}}),y.push(i))}if(s!=null){const w=$I(s.shape,d);w!=null&&(s=Et({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(!((h===1||f===1)&&u>IJ)&&c.isPacked&&d&&c.texture!=null&&l[2]%2!==0&&Mn(c.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),_={dataId:n.dataId,shape:[1,w,t.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,U(MI(c.shape,_.shape),()=>`packed reshape ${c.shape} to ${_.shape} isn't free`);const k=Et({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(k);const A=NI({a:_,b:k,backend:r,transposeA:p,transposeB:m,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),M=r.texData.get(A.dataId);U(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,M.shape=t.outShape,g=Ha({inputs:{x:A},backend:r}),g.shape=t.outShape,y.push(A)}else{const w=t.outHeight*t.outWidth,_=Et({inputs:{x:n},backend:r,attrs:{shape:d?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),C=Et({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=NI({a:d?_:C,b:d?C:_,transposeA:!d,transposeB:m,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=Et({inputs:{x:k},backend:r,attrs:{shape:t.outShape}}),y.push(_),y.push(C),y.push(k)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function FJ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:f,dataFormat:d}=t,p=d==="channelsLast",m=l*c*u,g=f*h,y=[t.batchSize,m,g],b=!0,x=!1,w=[];if(i!=null){const G=$I(i.shape,p);G!=null&&(i=Et({inputs:{x:i},backend:r,attrs:{shape:G}}),w.push(i))}if(s!=null){const G=$I(s.shape,p);G!=null&&(s=Et({inputs:{x:s},backend:r,attrs:{shape:G}}),w.push(s))}const _=Et({inputs:{x:e},backend:r,attrs:{shape:[1,m,Te(e.shape)/m]}});w.push(_);const C=new uRe(y,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=r.runWebGLProgram(C,[n],"float32",k),M=Et({inputs:{x:A},backend:r,attrs:{shape:y}});w.push(A),w.push(M);const I=s!=null,N=i!=null,O=a==="leakyrelu",R=a?_S(a,!0):null,D=new EJ(p?M.shape:_.shape,p?_.shape:M.shape,p?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],b,x,I,R,N,O),z=p?[M,_]:[_,M];if(s&&z.push(s),N&&z.push(i),O){const G=r.makeTensorInfo([],"float32",Uf(o,"float32"));z.push(G),w.push(G)}const B=r.runWebGLProgram(D,z,"float32"),X=Et({inputs:{x:B},backend:r,attrs:{shape:t.outShape}});w.push(B);for(const G of w)r.disposeIntermediateTensorInfo(G);return X}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=Qa(l),f=ns(s.shape,i.shape,o,c,a,u,!1,h);let d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=OJ({x:s,filter:i,convInfo:f,backend:t});else if(f.strideWidth<=2&&h==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const m=new DJ(f),g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=t.runWebGLProgram(m,[s,i],"float32",g)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))d=FJ({x:s,filter:i,convInfo:f,backend:t});else{const m=new PJ(f);d=t.runWebGLProgram(m,[s,i],"float32")}const p=Et({inputs:{x:d},backend:t,attrs:{shape:f.outShape}});return t.disposeIntermediateTensorInfo(d),p}const fRe={kernelName:Rv,backendName:"webgl",kernelFunc:hRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},pRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=r-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},mRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},gRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=r-1-e.padInfo.top,u=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=Qa(l),f=ns(s.shape,u,o,1,a,c,!1,h),d=new dRe(f);return t.runWebGLProgram(d,[s,i],"float32")}const bRe={kernelName:Y_,backendName:"webgl",kernelFunc:yRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vRe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Co(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,s=t-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=Qa(c),f=ns(o,i.shape,a,1,l,u,!1,h);if(Ee().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const d=[[f.strideHeight,f.strideWidth]],p=new vRe(f);return t.runWebGLProgram(p,[s,i],"float32",d)}else{const d=new pRe(f);return t.runWebGLProgram(d,[s,i],"float32")}}const xRe={kernelName:Pv,backendName:"webgl",kernelFunc:wRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Ou(s.shape,i.shape,o,l,a),u=new cRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const _Re={kernelName:Dv,backendName:"webgl",kernelFunc:SRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,c=Ou(s.shape,l,o,1,a),u=new mRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const kRe={kernelName:Z_,backendName:"webgl",kernelFunc:CRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r,c=Ou(l,i.shape,a,1,o),u=new gRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const ERe={kernelName:J_,backendName:"webgl",kernelFunc:TRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IRe=Dw+`
  return cos(x);
`,ARe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${By}
  return result;
`,MRe=dr({opSnippet:IRe,packedOpSnippet:ARe}),NRe={kernelName:Gg,backendName:"webgl",kernelFunc:MRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Re=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,RRe=dr({opSnippet:$Re}),PRe={kernelName:Hg,backendName:"webgl",kernelFunc:RRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DRe=class{constructor(e,t,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,f]=r;this.outputShape=[u,h,f,c];const d=s==="bilinear"?1:0,[p,m]=[`${a-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,w,_]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${_};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ORe=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new DRe(s.shape,i.shape,a,l,c);return t.runWebGLProgram(u,[s,i,o],"float32")},FRe={kernelName:e2,backendName:"webgl",kernelFunc:ORe};var kS;(function(n){n.Prod="*",n.Sum="+"})(kS||(kS={}));let MG=class{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===kS.Prod?"1.0":"0.0",a=r?o:`getX(${NG(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?`end != ${l-1}`:"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Fr(i)} coords = getOutputCoords();
        int end = ${$G(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${$G(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${NG(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function NG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function $G(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LJ(n,e,t,r,s,i){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Ko({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=rs(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Ha({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new MG(n,l.shape,!1,i),p=[[f]],m=h;h=t.runWebGLProgram(d,[h],h.dtype,p),t.disposeIntermediateTensorInfo(m)}if(s){const f=new MG(n,l.shape,s,i),d=h;h=t.runWebGLProgram(f,[h],h.dtype),t.disposeIntermediateTensorInfo(d)}if(a!=null){const f=Rh(a),d=Ko({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return LJ(kS.Prod,s,t,i,o,a)}const zRe={kernelName:Q_,backendName:"webgl",kernelFunc:LRe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return LJ(kS.Sum,s,t,i,o,a)}const VRe={kernelName:Ov,backendName:"webgl",kernelFunc:BRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function URe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.readSync(s.dataId),c=t.readSync(i.dataId),u=bJ(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(s.shape.length===2){const l=t.bufferSync(s),c=t.bufferSync(i),u=jAe(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const WRe={kernelName:t2,backendName:"webgl",kernelFunc:URe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GRe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],u=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,f=c*i,d=u/(i*i),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=new GRe(p,i,o);return t.runWebGLProgram(m,[s],s.dtype)}const jRe={kernelName:n2,backendName:"webgl",kernelFunc:HRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zJ=class{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Co(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BJ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Co(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,f=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<h;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const b=y*2;if(d+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?d+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const x=a%2===0?pM(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:d+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?d+=`
                    xC${b+1} = xTexelC${b};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(d+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(d+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(d+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let p="",m="";r&&(s?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:p=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;u==null&&(u=[1,1]),U(Ni(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=ns(s.shape,i.shape,o,u,a,c,!0);let f;Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?f=new BJ(h):f=new zJ(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(f,[s,i],"float32",d)}const XRe={kernelName:Fv,backendName:"webgl",kernelFunc:qRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},YRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ns(s.shape,u,o,a,l,c,!0),f=new KRe(h);return t.runWebGLProgram(f,[s,i],"float32")}const JRe={kernelName:r2,backendName:"webgl",kernelFunc:ZRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ns(u,i.shape,o,a,l,c,!0),f=new YRe(h);return t.runWebGLProgram(f,[s,i],"float32")}const e3e={kernelName:s2,backendName:"webgl",kernelFunc:QRe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t3e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3e(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Te(r.shape),o=Et({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new t3e(i),l=t.runWebGLProgram(a,[o],o.dtype),c=Et({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const r3e={kernelName:i2,backendName:"webgl",kernelFunc:n3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let s3e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:f}=s;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=kp(s.shape,i.shape,o,a,"NHWC",l);let u;const h=new s3e(c);u=t.runWebGLProgram(h,[s,i],"float32");const f=Et({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),f}const o3e={kernelName:Lv,backendName:"webgl",kernelFunc:i3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a3e(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=yN(s,i.length);vN(o.length,l,i);const{path:c,steps:u}=wN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=bN(d,l[g]);let x;xN(y)?x=i[g]:(x=Ko({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let _=0;_<b.length;++_)w.splice(b[_],0,1);Mn(x.shape,w)||(x=Et({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=cB({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=AN({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const l3e={kernelName:a2,backendName:"webgl",kernelFunc:a3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c3e="return (x >= 0.0) ? x : (exp(x) - 1.0);",u3e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,h3e=dr({opSnippet:c3e,packedOpSnippet:u3e}),f3e={kernelName:qg,backendName:"webgl",kernelFunc:h3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3e="return (b >= 0.0) ? a : a * (b + 1.0);",p3e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,m3e=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Pw(p3e,r.shape,s.shape):new ug(d3e,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],r.dtype)},g3e={kernelName:l2,backendName:"webgl",kernelFunc:m3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y3e=`
  return vec4(equal(a, b));
`,b3e="return float(a == b);",v3e=co({opSnippet:b3e,packedOpSnippet:y3e,dtype:"bool",cpuKernelImpl:ZAe}),w3e={kernelName:zv,backendName:"webgl",kernelFunc:v3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x3e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${hN};
  float a1 = ${fN};
  float a2 = ${dN};
  float a3 = ${pN};
  float a4 = ${mN};
  float a5 = ${gN};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,S3e=dr({opSnippet:x3e}),_3e={kernelName:Xg,backendName:"webgl",kernelFunc:S3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C3e=Dw+`
  return exp(x);
`,k3e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VJ=dr({opSnippet:C3e,packedOpSnippet:k3e,cpuKernelImpl:JAe,dtype:"float32"}),T3e={kernelName:Kg,backendName:"webgl",kernelFunc:VJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),Et({inputs:{x:i},backend:r,attrs:{shape:a}})}const E3e={kernelName:Bv,backendName:"webgl",kernelFunc:MD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG="return exp(x) - 1.0;",I3e=dr({opSnippet:RG,packedOpSnippet:RG,cpuKernelImpl:QAe}),A3e={kernelName:Yg,backendName:"webgl",kernelFunc:I3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PG=class{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UJ(n,e,t){const r=t.texData.get(n.dataId),s=Te(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=Et({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,c=new PG("real",l,e),u=new PG("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Ap({inputs:{real:f,imag:d},backend:t});t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d);const m=Et({inputs:{x:p},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3e(n){const{inputs:e,backend:t}=n,{input:r}=e;return UJ(r,!1,t)}const N3e={kernelName:c2,backendName:"webgl",kernelFunc:M3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $3e=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pC(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||xp(s),i==="string"){const o=Cs(i,Te(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new $3e(r,s),a=[[s]];return e.runWebGLProgram(o,[],i,a)}}const R3e={kernelName:u2,backendName:"webgl",kernelFunc:pC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P3e=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3e={kernelName:h2,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new P3e(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG="return floor(x);",O3e=dr({opSnippet:DG,packedOpSnippet:DG,cpuKernelImpl:eMe}),F3e={kernelName:Zg,backendName:"webgl",kernelFunc:O3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,z3e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,B3e=co({opSnippet:L3e,packedOpSnippet:z3e,dtype:"int32"}),V3e={kernelName:Jg,backendName:"webgl",kernelFunc:B3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U3e=class{constructor(e){this.variableNames=["A"];const t=Qo(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W3e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Qo(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G3e={kernelName:hS,backendName:"webgl",kernelFunc:H3e};let k0,a3=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function H3e(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],h=[c,l,i];if(a||o){const m=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(k0==null||m!==a3)&&(a3=m,k0=document.createElement("canvas").getContext("2d",{willReadFrequently:a3})),k0.canvas.width=l,k0.canvas.height=c,k0.drawImage(s,0,0,l,c),s=k0.canvas}const f=t.makeTensorInfo(u,"int32");t.texData.get(f.dataId).usage=Cl.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(f.dataId),s);const d=Ee().getBool("WEBGL_PACK")?new W3e(h):new U3e(h),p=t.runWebGLProgram(d,[f],"int32");return t.disposeData(f.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=Qa(u),g=ns(s.shape,i.shape,l,h,c,f,!1,m);let y;const b=[],x=o!=null,w=a!=null,_=d==="leakyrelu",C=()=>{const A=[s,i],M=(I,N)=>{if(N==="NCHW"&&I.shape.length===1&&I.shape[0]!==1){const O=Et({inputs:{x:I},backend:t,attrs:{shape:[I.shape[0],1,1]}});return b.push(O),O}return I};if(x&&A.push(M(o,u)),w&&A.push(M(a,u)),_){const I=t.makeTensorInfo([],"float32",Uf(p,"float32"));A.push(I),b.push(I)}return A};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=OJ({x:s,filter:i,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else if(g.strideWidth<=2&&m==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const A=d?_S(d,!0):null,M=new DJ(g,x,A,w,_),I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=C();y=t.runWebGLProgram(M,N,"float32",I)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))y=FJ({x:s,filter:i,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else{const A=d?_S(d,!1):null,M=new PJ(g,x,A,w,_),I=C();y=t.runWebGLProgram(M,I,"float32")}const k=Et({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return b.push(y),b.forEach(A=>t.disposeIntermediateTensorInfo(A)),k}const q3e={kernelName:zb,backendName:"webgl",kernelFunc:j3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r,p=[];let m=u;m==null&&(m=[1,1]),U(Ni(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=ns(s.shape,i.shape,l,m,c,h,!0),y=Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=f?_S(f,y):null,x=[s,i],w=o!=null,_=a!=null,C=f==="leakyrelu";if(w&&x.push(o),_&&x.push(a),C){const I=t.makeTensorInfo([],"float32",Uf(d,"float32"));x.push(I),p.push(I)}let k;y?k=new BJ(g,w,b,_,C):k=new zJ(g,w,b,_,C);const A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=t.runWebGLProgram(k,x,"float32",A);return p.forEach(I=>t.disposeIntermediateTensorInfo(I)),M}const K3e={kernelName:Bb,backendName:"webgl",kernelFunc:X3e};let Y3e=class{constructor(e,t,r,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=Fr(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3e(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Te(r.shape),[l,c,u,h]=iC(r,s),f=Et({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),d=Et({inputs:{x:r},backend:t,attrs:{shape:[Te(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=t.readSync(s.dataId),b=t.bufferSync(r),x=tMe(y,b,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,x.values)}const p=new Y3e(o,h,[c,u],r.shape),m=t.runWebGLProgram(p,[d,f],d.dtype),g=Et({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),g}const J3e={kernelName:f2,backendName:"webgl",kernelFunc:Z3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Q3e=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Fr(this.rank),s=ePe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function ePe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=Tn(o,s.shape)[0];if(Ee().get("DEBUG")){const b=t.readSync(i.dataId),x=s.shape[l];for(let w=0;w<b.length;++w){const _=b[w];U(_<=x-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${x-1}]`)}}const c=_N(s,i,l,a),u=Te(i.shape),h=[],f=Et({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=Et({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=t.bufferSync(d),x=t.bufferSync(f),w=nMe(x,b,p);return h.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.makeTensorInfo(c.outputShape,w.dtype,w.values)}const m=new Q3e(f.shape,p),g=t.runWebGLProgram(m,[f,d],f.dtype);h.push(g);const y=Et({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const tPe={kernelName:Uv,backendName:"webgl",kernelFunc:WJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nPe="return float(a > b);",rPe=`
  return vec4(greaterThan(a, b));
`,sPe=co({opSnippet:nPe,packedOpSnippet:rPe,cpuKernelImpl:rMe,dtype:"bool"}),iPe={kernelName:Wv,backendName:"webgl",kernelFunc:sPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oPe="return float(a >= b);",aPe=`
  return vec4(greaterThanEqual(a, b));
`,lPe=co({opSnippet:oPe,packedOpSnippet:aPe,dtype:"bool",cpuKernelImpl:sMe}),cPe={kernelName:Qg,backendName:"webgl",kernelFunc:lPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uPe(n){const{inputs:e,backend:t}=n,{input:r}=e;return UJ(r,!0,t)}const hPe={kernelName:d2,backendName:"webgl",kernelFunc:uPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fPe="return float(!isnan(x) && !isinf(x));",dPe=dr({opSnippet:fPe,dtype:"bool"}),pPe={kernelName:ty,backendName:"webgl",kernelFunc:dPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mPe="return float(isinf(x));",gPe=dr({opSnippet:mPe,dtype:"bool"}),yPe={kernelName:ny,backendName:"webgl",kernelFunc:gPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bPe="return float(isnan(x));",vPe=dr({opSnippet:bPe,dtype:"bool"}),wPe={kernelName:ry,backendName:"webgl",kernelFunc:vPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xPe="return float(a < b);",SPe=`
  return vec4(lessThan(a, b));
`,_Pe=co({opSnippet:xPe,packedOpSnippet:SPe,cpuKernelImpl:iMe,dtype:"bool"}),CPe={kernelName:Hv,backendName:"webgl",kernelFunc:_Pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kPe="return float(a <= b);",TPe=`
  return vec4(lessThanEqual(a, b));
`,EPe=co({opSnippet:kPe,packedOpSnippet:TPe,cpuKernelImpl:oMe,dtype:"bool"}),IPe={kernelName:jv,backendName:"webgl",kernelFunc:EPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function APe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=aMe(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const MPe={kernelName:m2,backendName:"webgl",kernelFunc:APe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NPe=Dw+`
  return x < 0.0 ? 0./0. : log(x);
`,$Pe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,RPe=dr({opSnippet:NPe,packedOpSnippet:$Pe,cpuKernelImpl:lMe}),PPe={kernelName:sy,backendName:"webgl",kernelFunc:RPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DPe=Dw+`
  return log(1.0 + x);
`,OPe=dr({opSnippet:DPe}),FPe={kernelName:iy,backendName:"webgl",kernelFunc:OPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LPe="return float(a >= 1.0 && b >= 1.0);",zPe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,BPe=co({opSnippet:LPe,packedOpSnippet:zPe,dtype:"bool"}),VPe={kernelName:qv,backendName:"webgl",kernelFunc:BPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UPe="return float(!(x >= 1.0));",WPe=dr({opSnippet:UPe}),GPe={kernelName:Xv,backendName:"webgl",kernelFunc:WPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HPe="return float(a >= 1.0 || b >= 1.0);",jPe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,qPe=co({opSnippet:HPe,packedOpSnippet:jPe,dtype:"bool"}),XPe={kernelName:Kv,backendName:"webgl",kernelFunc:qPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KPe=class{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YPe{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZPe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new YPe(s.shape,i,o,a,l):new KPe(s.shape,i,o,a,l);return t.runWebGLProgram(c,[s],s.dtype)},JPe={kernelName:Yv,backendName:"webgl",kernelFunc:ZPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QPe=class{constructor(e,t,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eDe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new QPe(s.shape,a,l,c,u);return t.runWebGLProgram(h,[s,i,o],s.dtype)},tDe={kernelName:g2,backendName:"webgl",kernelFunc:eDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nDe(n,e,t,r){const s=Te(e),o=Te(n.shape)/s,a=Et({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=Vy(a,n.dtype,"max",r),c=Et({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=Tn(i,s.shape);let c=l;const u=Lr(c,a),h=u!=null,f=t.shouldExecuteOnCPU([s]);let d=s;if(h){if(f){const x=t.texData.get(d.dataId).values,w=new Array(a);for(let k=0;k<w.length;k++)w[k]=s.shape[u[k]];const _=aB(x,s.shape,s.dtype,u,w);d=t.makeTensorInfo(w,s.dtype);const C=t.texData.get(d.dataId);C.values=_}else d=IN(s,u,t);c=rs(c.length,a)}ui("max",c,a);const[p,m]=Js(d.shape,c);let g=p;o&&(g=Ls(p,l));let y;if(f){const x=t.texData.get(d.dataId).values,w=cMe(x,Te(m),g,s.dtype);y=t.makeTensorInfo(g,s.dtype);const _=t.texData.get(y.dataId);_.values=w}else y=nDe(d,m,g,t);return h&&t.disposeIntermediateTensorInfo(d),y}const rDe={kernelName:Zv,backendName:"webgl",kernelFunc:GJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sDe=lB+`
  return max(a, b);
`,iDe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+By+`
  return result;
`,oDe=co({opSnippet:sDe,packedOpSnippet:iDe,cpuKernelImpl:uMe}),aDe={kernelName:oy,backendName:"webgl",kernelFunc:oDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;hC(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ni(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=_o(s.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Mn(u.inShape,u.outShape))return Ha({inputs:{x:s},backend:t});const h=new CS(u,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}const cDe={kernelName:Jv,backendName:"webgl",kernelFunc:lDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=zl(s.shape,i,o,u,a,c,l),f=new uB(h,"max",!1);return t.runWebGLProgram(f,[s],s.dtype)}const hDe={kernelName:Qv,backendName:"webgl",kernelFunc:uDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},dDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=c-1-e.padInfo.top,d=u-1-e.padInfo.left,p=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=zl(o.shape,a,l,h,c,u),d=new uB(f,"max",!0),p=t.runWebGLProgram(d,[o],o.dtype),m=new dDe(f),g=t.runWebGLProgram(m,[s,p],o.dtype);return t.disposeIntermediateTensorInfo(p),g}const mDe={kernelName:b2,backendName:"webgl",kernelFunc:pDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;hC([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=_o(a.shape,l,c,1,u,h),d=!0,p=new CS(f,"max",d),m=t.runWebGLProgram(p,[a],a.dtype),g=new fDe(f),y=t.runWebGLProgram(g,[s,m],a.dtype);return t.disposeIntermediateTensorInfo(m),y}const yDe={kernelName:y2,backendName:"webgl",kernelFunc:gDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bDe(n,e,t,r){let s=new CS(t,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");s=new CS(t,"max",!0,!0,e);const o=r.runWebGLProgram(s,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vDe={kernelName:v2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;U(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];U(Ni(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=_o(r.shape,s,i,c,o),[h,f]=bDe(r,a,u,l);return[h,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wDe(n,e,t,r){const s=Te(e),o=Te(n.shape)/s,a=Et({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=Vy(a,"float32","mean",r),c=Et({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xDe={kernelName:ew,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:i}=e,o=t,a=r.shape.length,l=Tn(i,r.shape);let c=l;const u=Lr(c,a),h=u!=null,f=o.shouldExecuteOnCPU([r]),d=[];let p=r;if(h){if(f){const w=o.texData.get(p.dataId).values,_=new Array(a);for(let A=0;A<_.length;A++)_[A]=r.shape[u[A]];const C=aB(w,r.shape,r.dtype,u,_);p=o.makeTensorInfo(_,r.dtype);const k=o.texData.get(p.dataId);k.values=C}else p=IN(r,u,o);d.push(p),c=rs(c.length,a)}ui("sum",c,a);const[m,g]=Js(p.shape,c);let y=m;s&&(y=Ls(m,l));const b=wDe(p,g,y,o);for(const x of d)o.disposeIntermediateTensorInfo(x);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=Tn(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Ko({inputs:{x:s},backend:t,attrs:{perm:u}}),c=rs(c.length,s.shape.length)),ui("min",c,a);const[f,d]=Js(h.shape,c),p=Te(d),m=Et({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Vy(m,m.dtype,"min",t);let y;if(o){const b=Ls(f,l);y=Et({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=Et({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const _De={kernelName:tw,backendName:"webgl",kernelFunc:SDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CDe=lB+`
  return min(a, b);
`,kDe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+By+`
  return result;
`,TDe=co({opSnippet:CDe,packedOpSnippet:kDe,cpuKernelImpl:hMe}),EDe={kernelName:ay,backendName:"webgl",kernelFunc:TDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let IDe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const s=e.length,i=Fr(s),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ADe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);const s=e.length,i=Fr(s),o=t.map(p=>p[0]).join(","),a=t.map((p,m)=>p[0]+e[m]).join(","),l=Vo("rc",s),c=Vo("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let d="";if(s===1){const p=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[s-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const p=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[s-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${p}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[s-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MDe=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:i}=t,o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ADe(r.shape,s,i):new IDe(r.shape,s,i);return e.runWebGLProgram(o,[r],r.dtype)},NDe={kernelName:nw,backendName:"webgl",kernelFunc:MDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $De=`if (b == 0.0) return NAN;
  return mod(a, b);`,RDe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+By+`
  return result;
`,PDe=co({opSnippet:$De,packedOpSnippet:RDe}),DDe={kernelName:ly,backendName:"webgl",kernelFunc:PDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ODe=class{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FDe=`
if (a == b) {
  return 1.0;
};
return a / b;`,LDe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,HJ=co({opSnippet:FDe,packedOpSnippet:LDe,checkOutOfBounds:!0}),zDe={kernelName:jg,backendName:"webgl",kernelFunc:HJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG="return a - b;",jJ=co({opSnippet:OG,packedOpSnippet:OG,supportsComplex:!0,cpuKernelImpl:$Me}),BDe={kernelName:Cy,backendName:"webgl",kernelFunc:jJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=Tn([i],s.shape),a=GJ({inputs:{x:s},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Ls(a.shape,o),c=Et({inputs:{x:a},backend:t,attrs:{shape:l}}),u=jJ({inputs:{a:s,b:c},backend:t}),h=VJ({inputs:{x:u},backend:t}),f=AN({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),d=Et({inputs:{x:f},backend:t,attrs:{shape:l}}),p=HJ({inputs:{a:h,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}const VDe={kernelName:ww,backendName:"webgl",kernelFunc:qJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UDe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:qJ({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new ODe(c,u,i),f=[[o]],d=t.runWebGLProgram(h,[l],"int32",f);return a||t.disposeIntermediateTensorInfo(l),d}const WDe={kernelName:w2,backendName:"webgl",kernelFunc:UDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GDe=Dc+`
  return -x;
`,HDe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function jDe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId),[o,a]=dMe(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}let s;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Ad(r.shape,HDe):s=new fh(r.shape,GDe),t.runWebGLProgram(s,[r],r.dtype)}const qDe={kernelName:rw,backendName:"webgl",kernelFunc:jDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XDe=tC;function KDe(n){xl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=XDe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const YDe={kernelName:x2,backendName:"webgl",kernelFunc:KDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZDe=eN;function JDe(n){xl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),{selectedIndices:f,validOutputs:d}=ZDe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const QDe={kernelName:bM,backendName:"webgl",kernelFunc:JDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eOe=nC;function tOe(n){xl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=eOe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const nOe={kernelName:S2,backendName:"webgl",kernelFunc:tOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rOe=class{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sOe=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=Te(s.shape),u=new rOe(c,o,a,l),h=Et({inputs:{x:s},backend:t,attrs:{shape:[c]}}),f=t.runWebGLProgram(u,[h],i);t.disposeIntermediateTensorInfo(h);const d=[...s.shape,o],p=Et({inputs:{x:f},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(f),p},iOe={kernelName:ow,backendName:"webgl",kernelFunc:sOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=dC({inputs:{input:r},backend:t}),i=RI({inputs:{x:s},backend:t}),o=MN({inputs:{input:r},backend:t}),a=RI({inputs:{x:o},backend:t}),l=Ap({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return pC({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const oOe={kernelName:_w,backendName:"webgl",kernelFunc:RI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=dC({inputs:{input:r},backend:t}),i=XJ({inputs:{x:s},backend:t}),o=MN({inputs:{input:r},backend:t}),a=RI({inputs:{x:o},backend:t}),l=Ap({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return pC({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const aOe={kernelName:iw,backendName:"webgl",kernelFunc:XJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lOe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return MD({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{ji(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=MD({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=RJ({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const cOe={kernelName:aw,backendName:"webgl",kernelFunc:lOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uOe=class{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const s=e.length,i=Fr(s),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hOe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const s=e.length,i=Fr(s),o=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+e[g]).join(","),l=Vo("rc",s),c=Vo("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${u}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${u}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=s===1?2:4;m<g;m++)p+=`
        ${f[m]}
        if (${d}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;p+=s===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJ=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(Te(s.shape)===0){const c=i.map((u,h)=>u[0]+s.shape[h]+u[1]);return pC({backend:t,attrs:{shape:c,value:o,dtype:s.dtype}})}const a=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hOe(s.shape,i,o):new uOe(s.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[s],s.dtype,l)},fOe={kernelName:lw,backendName:"webgl",kernelFunc:KJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dOe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,pOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+By+`
  return result;
`,mOe=co({opSnippet:dOe,packedOpSnippet:pOe}),gOe={kernelName:uy,backendName:"webgl",kernelFunc:mOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yOe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=Tn(i,s.shape);let u=c;const h=Lr(u,a);let f=s;h!=null&&(f=Ko({inputs:{x:s},backend:t,attrs:{perm:h}}),u=rs(u.length,a),l.push(f)),ui("prod",u,a);let d;if(t.shouldExecuteOnCPU([f])){const p=t.texData.get(f.dataId).values,{outVals:m,outShape:g,outDtype:y}=mMe(f.shape,f.dtype,p,u);d=t.makeTensorInfo(g,y,m)}else{const[p,m]=Js(f.shape,u),g=Te(m),y=Et({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}}),b=U2(s.dtype),x=Vy(y,b,"prod",t);d=Et({inputs:{x},backend:t,attrs:{shape:p}}),l.push(y),l.push(x)}if(o){l.push(d);const p=Ls(d.shape,c);d=Et({inputs:{x:d},backend:t,attrs:{shape:p}})}return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const bOe={kernelName:uw,backendName:"webgl",kernelFunc:yOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vOe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(y=>t.readSync(y.dataId)),c=s.map(y=>y.shape),u=t.readSync(i.dataId),h=t.readSync(o.dataId),[f,d,p]=gMe(l,c,u,i.shape,i.dtype,h,o.shape,a),m=f.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,i.dtype,d);return m.concat([g])}const wOe={kernelName:vM,backendName:"webgl",kernelFunc:vOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xOe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=yMe(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const SOe={kernelName:wM,backendName:"webgl",kernelFunc:xOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Oe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),h=t.readSync(o.dataId),f=a.map(g=>t.readSync(g.dataId)),d=a.map(g=>g.shape),[p,m]=bMe(c,s.shape,u,i.shape,i.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,i.dtype,m)}const COe={kernelName:xM,backendName:"webgl",kernelFunc:_Oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJ=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=vMe(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},kOe={kernelName:_2,backendName:"webgl",kernelFunc:YJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TOe="return 1.0 / x;",EOe=dr({opSnippet:TOe}),IOe={kernelName:hy,backendName:"webgl",kernelFunc:EOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AOe=Dc+`
  return (x < 0.0) ? 0.0 : x;
`,MOe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,NOe=dr({opSnippet:AOe,packedOpSnippet:MOe}),$Oe={kernelName:fy,backendName:"webgl",kernelFunc:NOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ROe=Dc+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,POe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,DOe=dr({opSnippet:ROe,packedOpSnippet:POe}),OOe={kernelName:dy,backendName:"webgl",kernelFunc:DOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FOe=class{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;i?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LOe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;i?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new LOe(s.shape,l,c,i,o):new FOe(s.shape,l,c,i,o);return t.runWebGLProgram(u,[s],"float32")}const BOe={kernelName:dw,backendName:"webgl",kernelFunc:zOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VOe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new VOe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const WOe={kernelName:T2,backendName:"webgl",kernelFunc:UOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GOe=class{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;i?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HOe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;i?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new HOe(s.shape,l,c,i,o):new GOe(s.shape,l,c,i,o);return t.runWebGLProgram(u,[s],s.dtype)}const qOe={kernelName:fw,backendName:"webgl",kernelFunc:jOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XOe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KOe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new XOe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const YOe={kernelName:k2,backendName:"webgl",kernelFunc:KOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZOe=class{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>s(l)).join(","),o=Fr(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JOe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=Vo("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Fr(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${i}){
            result.g = ${c(s.slice())};
          }
          if(${o}) {
            result.b = ${u(s.slice())};
            if(${i}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return f(p)}function c(p){return p[r-1]="("+p[r-1]+" + 1)",f(p)}function u(p){return p[r-2]="("+p[r-2]+" + 1)",f(p)}function h(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",f(p)}function f(p){const m=e.map((b,x)=>d(x,p)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function d(p,m){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${m[p]} - 1`:`${m[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QOe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length,a=Tn(i,s.shape);if(o===0)return Ha({inputs:{x:s},backend:t});const l=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JOe(s.shape,a):new ZOe(s.shape,a);return t.runWebGLProgram(l,[s],s.dtype)}const eFe={kernelName:pw,backendName:"webgl",kernelFunc:QOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tFe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nFe={kernelName:z2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new tFe(r.shape,i),[c,u]=lN(o,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rFe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,sFe=dr({opSnippet:rFe}),iFe={kernelName:py,backendName:"webgl",kernelFunc:sFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oFe="return inversesqrt(x);",aFe=dr({opSnippet:oFe,cpuKernelImpl:wMe}),lFe={kernelName:my,backendName:"webgl",kernelFunc:aFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hB=class{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Fr(i.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cFe{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Fr(i.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uFe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(i,s,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,s.dtype);const d=Et({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=Et({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;Ee().getBool("WEBGL_PACK")?g=new cFe(l,a,d.shape.length,p.shape.length,u,f):g=new hB(l,a,d.shape.length,p.shape.length,u,f);const y=t.runWebGLProgram(g,[p,d,m],p.dtype),b=Et({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),b}const hFe={kernelName:E2,backendName:"webgl",kernelFunc:uFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fFe=class{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=Ee().getNumber("WEBGL_VERSION")===2?i:o,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dFe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new fFe(s.shape[0],s.shape[1],i.shape[1],o),l=[[s.shape[1]]];return t.runWebGLProgram(a,[s,i],"int32",l)}const pFe={kernelName:A2,backendName:"webgl",kernelFunc:dFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let mFe=class{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,i;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=Fr(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gFe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new mFe(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(o,[r,s,i],Ii(s.dtype,i.dtype))}const yFe={kernelName:mw,backendName:"webgl",kernelFunc:gFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bFe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${aC};
  float scale = ${lC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,vFe=dr({opSnippet:bFe}),wFe={kernelName:gy,backendName:"webgl",kernelFunc:vFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xFe=Dw+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,SFe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_Fe=dr({opSnippet:xFe,packedOpSnippet:SFe,cpuKernelImpl:SMe}),CFe={kernelName:wy,backendName:"webgl",kernelFunc:_Fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kFe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,TFe=dr({opSnippet:kFe}),EFe={kernelName:vy,backendName:"webgl",kernelFunc:TFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IFe=Dw+`
  return sin(x);
`,AFe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${By}
  return result;
`,MFe=dr({opSnippet:IFe,packedOpSnippet:AFe}),NFe={kernelName:yy,backendName:"webgl",kernelFunc:MFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Fe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,RFe=dr({opSnippet:$Fe}),PFe={kernelName:by,backendName:"webgl",kernelFunc:RFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DFe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,OFe=dr({opSnippet:DFe}),FFe={kernelName:xy,backendName:"webgl",kernelFunc:OFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LFe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<s.shape.length;++y)l.push([0,0]);const c=[],u=KJ({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),h=Dy(u.shape,i,a,!1),f=Oy(h.length,i.length,!1),d=Fy(u.shape,i,a,!1),p=Et({inputs:{x:u},backend:t,attrs:{shape:h}}),m=Ko({inputs:{x:p},backend:t,attrs:{perm:f}}),g=Et({inputs:{x:m},backend:t,attrs:{shape:d}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},zFe={kernelName:bw,backendName:"webgl",kernelFunc:LFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BFe(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(s.dataId),c=t.readSync(i.dataId),u=t.readSync(o.dataId)[0],[h,f,d,p,m]=CMe(a,r.shape,r.dtype,l,s.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],s.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const VFe={kernelName:SM,backendName:"webgl",kernelFunc:BFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UFe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),l=Array.from(t.readSync(i.dataId)),[c,u,h]=kMe(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const WFe={kernelName:_M,backendName:"webgl",kernelFunc:UFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GFe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=wJ(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const HFe={kernelName:M2,backendName:"webgl",kernelFunc:GFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=wJ(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const qFe={kernelName:N2,backendName:"webgl",kernelFunc:jFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XFe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Fu(i,s,a),d=!1;if(i.dtype==="string"){const y=t.bufferSync(s),b=t.bufferSync(i),x=kc(t.readSync(o.dataId)[0]),w=xMe(y,b,a,f,u,c,l,h,x,d);return t.makeTensorInfo(a,w.dtype,w.values)}const p=new hB(c,l,s.shape.length,i.shape.length,h,[f,1],d),m=t.runWebGLProgram(p,[i,s,o],i.dtype),g=Et({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),g}const KFe={kernelName:$2,backendName:"webgl",kernelFunc:XFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YFe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=Tn(o,s.shape)[0],l=SN(s,i,a),c=s.shape.length,u=new Array(c).fill(0),h=s.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=Ow({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const ZFe={kernelName:vw,backendName:"webgl",kernelFunc:YFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG="return sqrt(x);",JFe=dr({opSnippet:FG,packedOpSnippet:FG,cpuKernelImpl:TMe}),QFe={kernelName:Sy,backendName:"webgl",kernelFunc:JFe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eLe="return x * x;",tLe=dr({opSnippet:eLe}),nLe={kernelName:R2,backendName:"webgl",kernelFunc:tLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG="return (a - b) * (a - b);",rLe=co({opSnippet:LG,packedOpSnippet:LG}),sLe={kernelName:_y,backendName:"webgl",kernelFunc:rLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(s.dataId),o=Su(i),a=EMe(o,"string",r);return t.makeTensorInfo(s.shape,"string",a)}const oLe={kernelName:P2,backendName:"webgl",kernelFunc:iLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aLe({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=Dc+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new fh(r.shape,s);return t.runWebGLProgram(i,[r],r.dtype)}const lLe={kernelName:Iy,backendName:"webgl",kernelFunc:aLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cLe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=Fr(r.length),o=Fr(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=iN(s.shape,i,o,a,l,c,u,h,f);let _;if(m)_=Et({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=sN(b,x,w),A=Ow({inputs:{x:s},backend:t,attrs:{begin:b,size:k}});_=Et({inputs:{x:A},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(A)}else if(t.shouldExecuteOnCPU([s])){const A=t.readSync(s.dataId),M=wn(s.shape,s.dtype,A),I=IMe(d,M,w,b);_=t.makeTensorInfo(p,s.dtype,I.values)}else{const A=new cLe(b,w,d);_=t.runWebGLProgram(A,[s],s.dtype)}const C=Et({inputs:{x:_},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(_),C}const hLe={kernelName:D2,backendName:"webgl",kernelFunc:uLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fLe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=AMe(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const dLe={kernelName:O2,backendName:"webgl",kernelFunc:fLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pLe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=MMe(a,l,s),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const mLe={kernelName:CM,backendName:"webgl",kernelFunc:pLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gLe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=NMe(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const yLe={kernelName:kM,backendName:"webgl",kernelFunc:gLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bLe="return tan(x);",vLe=dr({opSnippet:bLe}),wLe={kernelName:ky,backendName:"webgl",kernelFunc:vLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xLe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,SLe=dr({opSnippet:xLe}),_Le={kernelName:Ty,backendName:"webgl",kernelFunc:SLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CLe(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(o,i,s.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const d=Et({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),p=Et({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),m=Et({inputs:{x:s},backend:t,attrs:{shape:f}}),g=new hB(l,a,d.shape.length,p.shape.length,u,f,!1,!0),y=t.runWebGLProgram(g,[p,d,m],m.dtype),b=Et({inputs:{x:y},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const kLe={kernelName:I2,backendName:"webgl",kernelFunc:CLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TLe=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*t[o];this.outputShape=r,this.rank=r.length;const s=Fr(this.rank),i=ELe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function ELe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(s.dtype==="string"||s.shape.length>5){const l=t.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>kc(f)):l,u=wn(s.shape,s.dtype,c),h=RMe(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new TLe(s.shape,i);return t.runWebGLProgram(o,[s],s.dtype)}const ILe={kernelName:Ey,backendName:"webgl",kernelFunc:ZJ};let ALe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},MLe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function em(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function zG(n){let e=1;for(;e<n;)e*=2;return e}function NLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=Ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([s])||u<a||i>l){const I=t.readSync(s.dataId),[N,O]=PMe(I,c,s.dtype,i,o);return[t.makeTensorInfo(N.shape,N.dtype,N.values),t.makeTensorInfo(O.shape,O.dtype,O.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,s.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[s,pC({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(s.dataId),f=h!==null&&h.isPacked,d=f?t.unpackTensor(s):s,m=Te(c)/u,g=Et({inputs:{x:d},attrs:{shape:[m,u]},backend:t});f&&em(t,d);const y=zG(i),b=zG(u);let x=null;const w=()=>x===null?[g,g]:[g,x],_=(I,N,O)=>{const R=w(),D=new ALe(O),B=[[u],[x===null?1:0],[Number.NEGATIVE_INFINITY],[I],[N]],X=x;x=t.runWebGLProgram(D,R,"int32",B),em(t,X)};for(let I=1;I<y;I*=2){const N=I*2;for(let O=I;O>=1;O/=2)_(N,O,[m,b])}for(let I=b;I>y;I/=2){const N=w(),O=new MLe([m,I/2]),D=[[u],[x===null?1:0],[y]],z=x;x=t.runWebGLProgram(O,N,"int32",D),em(t,z);const B=y/2,X=B*2;for(let G=B;G>=1;G/=2)_(X,G,x.shape)}let C=x;x=Ow({inputs:{x},backend:t,attrs:{begin:0,size:[m,i]}}),em(t,C);let k=WJ({inputs:{x:g,indices:x},backend:t,attrs:{axis:1,batchDims:1}});em(t,g);const A=c.slice(0,-1);A.push(i),C=x,x=Et({inputs:{x},attrs:{shape:A},backend:t}),em(t,C);const M=k;return k=Et({inputs:{x:k},attrs:{shape:A},backend:t}),em(t,M),[k,x]}const $Le={kernelName:F2,backendName:"webgl",kernelFunc:NLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RLe=class{constructor(e,t,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PLe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new RLe(h,f,o,a,l,g);return t.runWebGLProgram(y,[s,i],"float32")}const DLe={kernelName:L2,backendName:"webgl",kernelFunc:PLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OLe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;hC(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=DMe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const FLe={kernelName:TM,backendName:"webgl",kernelFunc:OLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LLe(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[i]=m;const g=Ow({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=Et({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const zLe={kernelName:xw,backendName:"webgl",kernelFunc:LLe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BLe{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const l="0.0",c="sumValue",u=Math.floor(r/4)*4,h=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let d="";i%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Lr([c],a);let h=s;u!=null&&(h=Ko({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),c=rs(1,a)[0]);const f=qz(h.shape,c,o),d=Te([h.shape[c]]),p=Et({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=U2(s.dtype),g=(w,_,C,k,A)=>{const M=w.shape[0],I=w.shape[1],N=jY(I,A),O={windowSize:N,inSize:I,batchSize:M,numSegments:A},R=new BLe(O,_),D=t.compileAndRun(R,[w,C],k);if(l.push(D),D.shape[1]===A)return D;const z=YJ({backend:t,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),B=ZJ({inputs:{x:z},backend:t,attrs:{reps:[I/N]}});return l.push(z),l.push(B),g(D,_,B,k,A)},y=g(p,"unsortedSegmentSum",i,m,o),b=Et({inputs:{x:y},backend:t,attrs:{shape:f}});let x=b;if(u!=null){l.push(b);const w=Rh(u);x=Ko({inputs:{x},backend:t,attrs:{perm:w}})}return l.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const ULe={kernelName:Sw,backendName:"webgl",kernelFunc:VLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WLe=[TNe,INe,NNe,PNe,ONe,zNe,VNe,WNe,qNe,KNe,JNe,t$e,s$e,l$e,h$e,d$e,m$e,v$e,x$e,_$e,E$e,P$e,O$e,B$e,U$e,X$e,Y$e,eRe,cNe,rRe,lRe,fRe,bRe,xRe,_Re,kRe,ERe,NRe,PRe,FRe,zRe,VRe,WRe,jRe,XRe,JRe,e3e,r3e,o3e,l3e,f3e,g3e,w3e,_3e,T3e,E3e,A3e,N3e,R3e,D3e,F3e,V3e,G3e,q3e,K3e,J3e,tPe,iPe,cPe,lNe,hPe,oRe,pPe,yPe,wPe,hNe,CPe,IPe,MPe,PPe,FPe,VPe,GPe,XPe,JPe,tDe,rDe,aDe,cDe,hDe,mDe,yDe,vDe,xDe,_De,EDe,NDe,DDe,WDe,pNe,qDe,YDe,QDe,nOe,G$e,iOe,aOe,cOe,fOe,gOe,dNe,bOe,wOe,SOe,COe,kOe,H$e,zDe,IOe,$Oe,OOe,gNe,BOe,WOe,qOe,YOe,eFe,nFe,iFe,lFe,hFe,pFe,yFe,wFe,CFe,EFe,NFe,PFe,$$e,VDe,FFe,zFe,VFe,WFe,HFe,qFe,KFe,ZFe,QFe,nLe,sLe,oLe,lLe,hLe,dLe,mLe,yLe,BDe,_Ne,wLe,_Le,kLe,ILe,$Le,DLe,CNe,FLe,zLe,ULe,oOe];for(const n of WLe)B2(n);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl=Ee();Bl.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Bl.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Bl.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Bl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Bl.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Bl.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Bl.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Bl.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Bl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Bl.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Bl.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Bl.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Bl.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GLe{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HLe{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,r=!1,s=!0){let i;const o=BG(e,t);return s?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(i=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,i=BG(r,s),o=this.usedBuffers.get(i),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function BG(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jLe{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,r,s){const i=UG(r),o=e*t*i,a=VG(e,t,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,t],format:r,usage:s});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,r=e.height,s=e.format,i=e.usage,o=VG(t,r,s,i);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=UG(s),u=t*r*c;this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function VG(n,e,t,r){return`${n}_${e}_${t}_${r}`}function UG(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qLe(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,r="xyzwuv",s=n.map(o=>`${e}.${r[o]}`),i=new Array(t-1);i[t-2]=s[t-1];for(let o=t-3;o>=0;--o)i[o]=`(${i[o+1]} * ${s[o+1]})`;return i}const Mp=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Qb;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Qb||(Qb={}));const XLe=(n,e,t,r,s)=>{const i={dtype:r.dtype,shape:r.shape},o=YLe(t,i,e),a=n.createShaderModule({code:o,label:e.constructor.name});let l=Ee().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(u=>e.shaderKey.toLowerCase().includes(u)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return s?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},Un=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Ks(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Mf(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function St(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function WG(n,e){let t;return t=`
     ${KLe(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function KLe(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function YLe(n,e,t){const r=[],s=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${JJ(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const p=t.pixelsOpType===Qb.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Mm(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Mm(n[0].dtype,t.outputComponent)}>;`,m=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${m},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const g=HG(t);return[GG,r.join(`
`),$E(e.shape),t.getUserCode(),WG(g,t)].join(`
`)}let i,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((p,m)=>{const g=Ks(n[m].shape.length);a+=`${p.charAt(0).toLowerCase()+p.slice(1)}Shape : ${g}, `,i=n[m].shape.length-1,o=Ks(i),a+=`${p.charAt(0).toLowerCase()+p.slice(1)}ShapeStrides: ${o}, `});const l=Ks(e.shape.length);a+=`outShape : ${l}, `,i=e.shape.length-1,o=Ks(i),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=ize(a),r.push(a),t.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Mm(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((p,m)=>{r.push(`
      @group(0) @binding(${1+m}) var<storage, read> ${p}: array<${t.variableComponents?Mm(n[m].dtype,t.variableComponents[m]):Mm(n[m].dtype,t.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=nze(e.shape,t.dispatchLayout),u=[GG,r.join(`
`)+JLe,$E(e.shape),c,rze(e.shape.length)];t.atomic||u.push(sze(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((p,m)=>{u.push(`${$E(n[m].shape,p)}`)});const h=n.map((p,m)=>tze(p,e.shape,t.variableComponents?t.variableComponents[m]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);u.push(h),u.push(t.getUserCode());const f=HG(t);return u.push(WG(f,t)),u.join(`
`)}function ZLe(n,e,t){let r=n.shaderKey;if(n.pixelsOpType!=null)return r;const s=[],i=[];e.forEach(u=>{s.push(u.shape),i.push(u.dtype)}),s.push(t.shape),i.push(t.dtype);const o=e.map(u=>Df(u.shape,t.shape)),a=e.map(u=>Mn(u.shape,t.shape)).join("_"),l=o.map(u=>u.join("_")).join(";"),c=JJ(n)?"flatDispatch":"";return r+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+s.map(u=>u.length).join(",")+i.join(",")+n.variableNames.join(",")+l+a+c,r}const GG=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,JLe=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function $E(n,e=""){const t=n.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const i=Jt(n),o=Ks(t),a=[];for(let c=0;c<t;c++)a.push(`d${c}`);if(i.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+i.map((c,u)=>{const h=`let ${a[u]} = index2 / uniforms.${s}.${Mf(u)}`,f=u===i.length-1?`let ${a[u+1]} = index2 - ${a[u]} * uniforms.${s}.${Mf(u)}`:`index2 = index2 - ${a[u]} * uniforms.${s}.${Mf(u)}`;return`${h}; ${f};`}).join(""),`
    fn ${r}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function QLe(n,e){const t=n.name,r=n.shape.length,s=Ks(r),i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=o.map(u=>`${u} : i32`).join(", ");if(r<1)return`
      fn ${i}() -> ${Un(e)} {
        return ${Un(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${i}(${a}) -> ${Un(e)} {
      return ${Un(e)}(${t}[getIndexFromCoords${c}(${s}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function eze(n,e,t,r){const s=n.name,i=s.charAt(0).toUpperCase()+s.slice(1),o="get"+i+"ByOutput",a=n.shape.length,l=e.length,c=Ks(l);if(Mn(n.shape,e)&&r)return`
    fn ${o}Index(globalIndex : i32) -> ${Un(t)} {
      return ${Un(t)}(${s}[globalIndex]);
    }

    fn ${o}Coords(coords : ${c}) -> ${Un(t)} {
      return ${Un(t)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const u=Df(n.shape,e),h=l-a;let f="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${Un(t)}{
      return get${i}();
    }

    fn ${o}Coords(coords : ${c}) -> ${Un(t)}{
      return get${i}();
    }
  `;l<2&&u.length>=1?f="coords = 0;":f=u.map(g=>`coords.${Mf(g+h)} = 0;`).join(`
`);let d="";if(l<2&&a>0)d="coords";else if(l>1){const g=Ks(a),y=n.shape.map((b,x)=>`coords.${Mf(x+h)}`).join(", ");d=`${g}(${y})`}else d="coords";const p=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,m=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${Un(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${f}
    return ${Un(t)}(${s}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${c}) -> ${Un(t)} {
    var coords = coordsIn;
    ${f}
    return ${Un(t)}(${s}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }
`}function tze(n,e,t,r){let s=QLe(n,t);return n.shape.length<=e.length&&(s+=eze(n,e,t,r)),s}function nze(n,e){const{x:t,y:r=[],z:s=[]}=e,i=n.length,o=t.length+r.length+s.length;if(o!==i)return"";if(t.length===i)return`fn getOutputCoords() -> ${Ks(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[t,r,s];for(let f=0;f<l.length;f++){const d=l[f];if(d.length!==0)if(d.length===1)a+=`let d${d[0]} = i32(globalId[${f}]);`;else{const p=qLe(d,"uniforms.outShape");a+=`var index${f} = i32(globalId[${f}]);`;for(let m=0;m<p.length;m++)a+=`let d${d[m]} = index${f} / ${p[m]};`,m===p.length-1?a+=`let d${d[m+1]} = index${f} - d${d[m]} * ${p[m]};`:a+=`index${f} = index${f} - d${d[m]} * ${p[m]};`}}const c=[];for(let f=0;f<o;f++)c.push(`d${f}`);const u=Ks(o);let h=`fn getOutputCoords() -> ${u} {
  ${a}
`;return c.length===0?h+=`return ${u}(0); }`:h+=`return ${u}(${c.join(",")}); }`,h}function rze(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:U(!1,()=>`Unsupported ${n}D shape`);break}return e}function JJ(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Mm(n,e=1){if(n==="float32")return Un(e,"f32");if(n==="int32"||n==="bool")return Un(e,"i32");throw new Error(`type ${n} is not supported.`)}function sze(n,e,t){const r=n.length,s=Mm(e,t);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${Un(t)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Un(t,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=Ks(r);i+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Un(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Un(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return i}function ize(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,r=>"@align(16) "+r);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(r,s,i)=>`vec${s}, @align(16) ${i}`),n}function HG(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wm=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function _t(n,e,t=[1,1,1],r=[1,1,1]){const[s,i,o]=[Math.ceil(Wm(n.x.map(a=>e[a]))/(t[0]*r[0])),n.y?Math.ceil(Wm(n.y.map(a=>e[a]))/(t[1]*r[1])):1,n.z?Math.ceil(Wm(n.z.map(a=>e[a]))/(t[2]*r[2])):1];return[s,i,o]}function oze(n,e,t,r=!1){const s=[8,8,1],i=[4,4,1];return r||(n<=8&&(i[1]=1),e<=16&&t<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:i}}function QJ(n,e,t=!1){if(t)return[8,8,1];const r=Wm(n.x.map(i=>e[i])),s=Wm(n.y.map(i=>e[i]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function eQ(n,e,t=!1){if(t)return[4,4,1];const r=Wm(n.x.map(i=>e[i])),s=Wm(n.y.map(i=>e[i]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function Dt(n){return{x:n.map((e,t)=>t)}}function jG(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function tQ(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}function nQ(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var rh;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(rh||(rh={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aze=Ee().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),lze=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(o=>o<=t))return s;U(s[0]>t&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(s[0]));return i>t?(i=Math.ceil(Math.cbrt(s[0])),U(i<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class Fw extends V_{nextDataId(){return Fw.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!tQ())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new GLe(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new HLe(this.device),this.textureManager=new jLe(this.device),this.tensorMap=new dM(this,bo()),Ee().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return t?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:t,values:e,refCount:1}),s}move(e,t,r,s,i){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:t,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,r)=>{this.pipelineCache[t]=e[r]})}async getBufferData(e){if(Ee().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,r=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),Ee().getBool("WEBGPU_USE_PROFILE_TOOL")&&(U(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,t){const r=this.tensorMap.get(e);return r.values=t,r.values}readSync(e){const t=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=t;if(r!=null||t.dtype==="string")return r;if(t.dtype==="complex64"){const m=this.readSync(s.real.dataId),g=this.readSync(s.imag.dataId),y=H1(xu(m,g).buffer,"float32");return this.convertAndCacheOnCPU(e,y),y}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],o=t.resource,a=o.size;U(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),u=256,h=256,f=i.map(m=>new OffscreenCanvas(u,h)),d=new OffscreenCanvas(u,h);this.endComputePassEncoder(),f.map((m,g)=>{const y=m.getContext("webgpu");return y.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[g]}),y.getCurrentTexture()}).map((m,g)=>{const y=u*4,b=(A,M,I)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:y,offset:I},{texture:m},{width:A,height:M}),this.submitQueue();const N=d.getContext("2d",{willReadFrequently:!0});N.clearRect(0,0,A,M),N.drawImage(f[g],0,0);const O=N.getImageData(0,0,A,M).data,R=i[g],D=new Uint8ClampedArray(c,I,A*M*4);for(let z=0;z<D.length;z+=4)if(R==="premultiplied")D[z+3]=O[z+3];else{const B=O[z];D[z]=O[z+2],D[z+1]=O[z+1],D[z+2]=B}},x=Math.floor(l/(u*h));let w=u,_=h,C=0;for(let A=0;A<x;A++)b(w,_,C),C+=u*h*4;const k=l%(u*h);_=Math.floor(k/u),_>0&&(b(w,_,C),C+=_*(u*4)),w=k%u,w>0&&b(w,1,C)});const p=H1(c,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:r}=t;if(r!=null)return r;let s;if(t.dtype==="complex64"){const i=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=i[0],a=i[1];s=xu(o,a)}else{const i=await this.getBufferData(t.resource);s=H1(i,t.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const t=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(t,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),s}createTensorFromGPUData(e,t,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:r,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(i),a=jG(o.dtype)*Te(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),o.resource=s,bo().makeTensorFromDataId(i,t,r,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:r,dtype:s,shape:i,resource:o}=t;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,c=a.usage,u=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,u,0,l),this.submitQueue();const h=this.makeTensorInfo(i,s),f=bo().makeTensorFromTensorInfo(h),d=this.tensorMap.get(h.dataId);return d.resource=u,{tensorRef:f,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>kc(s));return wn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return wn(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Tc(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Tc(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(i);return a.kernelMs=bL(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,r){return t==="string"&&r!=null&&r.length>0&&uu(r[0])&&(r=r.map(i=>gu(i))),{dataId:this.write(r,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const r=jG(t.dtype)*Te(t.shape);let s;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(s=this.bufferManager.acquireBuffer(r,i,!0),s.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,s,0,r),this.stagingPendingDisposal.push(o)}else{const o=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),s.unmap()}t.values=null}else s=this.bufferManager.acquireBuffer(r,i);t.resource=s}makeUniforms(e){let t=0,r=0;const s=[];let i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:U(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>i&&(i=c),t=Math.ceil(t/c)*c,r=l.data.length,s.push(t),t+=l.data.length*4}),t=Math.ceil(t/i)*i;const o=new ArrayBuffer(t);e.forEach((l,c)=>{const u=s[c];l.type==="int32"?new Int32Array(o,u,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,u,l.data.length).set(l.data):new Float32Array(o,u,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,r,s,i){if(i||(i=this.makeTensorInfo(e.outputShape,r)),Te(i.shape)===0)return this.tensorMap.get(i.dataId).values=li(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=lze(this.device,e);const o=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=ZLe(e,o,i);const a=Ee().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=XLe(this.device,e,o,i,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,i,t,s),i}recordAndSubmit(e,t,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],o=[];const a="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=r.concat(t).map(d=>d.shape);const f="int32";o.map(d=>{i.push({type:f,data:d});const p=Jt(d);i.push({type:f,data:p})})}else{const f=Jt(t.shape);i.push({type:a,data:f})}if(e.size){const f=Te(e.outputShape);i.push({type:a,data:[e.outputComponent?f/e.outputComponent:f]})}s&&(i=[...i,...s]);const l=[this.tensorToBinding(t),...r.map(f=>this.tensorToBinding(f)),this.makeUniforms(i)];r.forEach(f=>{this.commandQueueOwnedIds.add(f.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((f,d)=>({binding:d,resource:f}))}),u=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};u&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(u||Ee().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Qb.DRAW)&&(this.endComputePassEncoder(),u?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),r=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,t=aze){return Ee().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&Te(r.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Fw.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */tQ()&&IM("webgpu",async()=>{const n={powerPreference:Ee().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),t.requiredFeatures=r;const s=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(t),o=await e.requestAdapterInfo();return new Fw(i,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gn;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(gn||(gn={}));const cze="let resultTemp = a + b;",uze="let resultTemp = atan2(a, b);",hze="let resultTemp = areal * breal - aimag * bimag;",fze="let resultTemp = areal * bimag + aimag * breal;",dze="let resultTemp = a / b;",pze="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",mze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,gze=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,yze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,bze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,vze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,wze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,xze="return f32(a >= 1.0 && b >= 1.0);",Sze=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,_ze="return f32(a >= 1.0 || b >= 1.0);",Cze=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,kze="let resultTemp = max(a, b);",Tze="let resultTemp = min(a, b);",Eze=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,Ize=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,Aze="let resultTemp = a * b;",Mze=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,Nze=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,$ze=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,Rze=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,Pze="if (a < 0.0) { return b * a; }  return a;",Dze=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Oze="let resultTemp = (a - b) * (a - b);",Fze="let resultTemp = a - b;";function fB(n,e){let t;do{switch(n){case gn.ATAN2:t=uze;break;case gn.MAX:t=kze;break;case gn.MIN:t=Tze;break;case gn.MOD:t=e?Ize:Eze;break;case gn.NOT_EQUAL:t=e?Nze:Mze;break;case gn.POW:t=e?Rze:$ze;break;default:continue}let r,s,i;return e?(r="isnanVec4",s="vec4<f32>",i="vec4<bool>"):(r="isnan",s="f32",i="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case gn.ADD:t=cze;break;case gn.COMPLEX_MULTIPLY_IMAG:t=fze;break;case gn.COMPLEX_MULTIPLY_REAL:t=hze;break;case gn.DIV:t=dze;break;case gn.ELU_DER:t=pze;break;case gn.EQUAL:t=mze;break;case gn.FLOOR_DIV:t=gze;break;case gn.GREATER:t=yze;break;case gn.GREATER_EQUAL:t=bze;break;case gn.LESS:t=vze;break;case gn.LESS_EQUAL:t=wze;break;case gn.LOGICAL_AND:return e?Sze:xze;case gn.LOGICAL_OR:return e?Cze:_ze;case gn.MUL:t=Aze;break;case gn.PRELU:return e?Dze:Pze;case gn.SQUARED_DIFFERENCE:t=Oze;break;case gn.SUB:t=Fze;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var vt;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(vt||(vt={}));const Lze="return abs(a);",zze=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,Bze=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,Vze=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,Uze="return asinh(a);",Wze=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,Gze=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,Hze="return ceil(a);",jze="return cos(a);",qze=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Xze="return exp(a) - 1.0;",Kze="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Yze=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Zze=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${hN};
  let a1 = ${fN};
  let a2 = ${dN};
  let a3 = ${pN};
  let a4 = ${mN};
  let a5 = ${gN};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Jze="return exp(a);",Qze="return floor(a);",eBe="return f32(!isnan(a) && !isinf(a));",tBe="return f32(isinf(a));",nBe="return f32(isnan(a));",rBe="return a;",sBe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,iBe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,oBe="return f32(!(a >= 1.0));",aBe="return -a;",lBe="if (a < 0.0) { return uniforms.alpha * a; } return a;",cBe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,uBe="return 1.0 / a;",hBe="return select(a, 0.0, a < 0.0);",fBe="return clamp(a, 0.0, 6.0);",dBe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",pBe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,mBe="return round(a);",gBe="return inverseSqrt(a);",yBe=`
  if (a >= 0.0) {
    return ${lC} * a;
  } else {
    return ${aC} * (exp(a) - 1.0);
  }
`,bBe="return 1.0 / (1.0 + exp(-1.0 * a));",vBe="return sign(a);",wBe="return sin(a);",xBe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,SBe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,_Be="return sqrt(a);",CBe="return a * a;",kBe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,TBe="return tan(a);",EBe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,IBe="return f32(i32((a)));";function bm(n,e){switch(n){case vt.ABS:return Lze;case vt.ACOS:return zze;case vt.ACOSH:return Bze;case vt.ASIN:return Vze;case vt.ASINH:return Uze;case vt.ATAN:return Wze;case vt.ATANH:return Gze;case vt.COS:return jze;case vt.COSH:return qze;case vt.CEIL:return Hze;case vt.ELU:return e?Yze:Kze;case vt.ERF:return Zze;case vt.EXP:return Jze;case vt.EXPM1:return Xze;case vt.FLOOR:return Qze;case vt.IS_FINITE:return eBe;case vt.IS_INF:return tBe;case vt.IS_NAN:return nBe;case vt.LINEAR:return rBe;case vt.LOG:return sBe;case vt.LOG1P:return iBe;case vt.LOGICAL_NOT:return oBe;case vt.NEG:return aBe;case vt.LEAKYRELU:return e?cBe:lBe;case vt.RECIPROCAL:return uBe;case vt.RELU:return e?pBe:hBe;case vt.RELU6:return e?dBe:fBe;case vt.ROUND:return mBe;case vt.RSQRT:return gBe;case vt.SELU:return yBe;case vt.SIGMOID:return bBe;case vt.SIGN:return vBe;case vt.SIN:return wBe;case vt.SINH:return xBe;case vt.SOFTPLUS:return SBe;case vt.SQRT:return _Be;case vt.SQUARE:return CBe;case vt.STEP:return kBe;case vt.TAN:return TBe;case vt.TANH:return EBe;case vt.TO_INT:return IBe;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qf(n,e=!1,t=!1,r=3){if(n===null)return"";let s="";if(n==="linear")s=bm(vt.LINEAR);else if(n==="relu")s=bm(vt.RELU,t);else if(n==="elu")s=bm(vt.ELU,t);else if(n==="relu6")s=bm(vt.RELU6,t);else if(n==="prelu")s=fB(gn.PRELU,t);else if(n==="sigmoid")s=bm(vt.SIGMOID,t);else if(n==="leakyrelu")s=bm(vt.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=Un(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        ${s}
      }`,a}function Uy(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQ(n,e,t=!1,r=!1,s=!1,i=1){U(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Un(i)} {
    var value = ${Un(i)}(0.0);
    ${t&&s?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Un(i)} {
    var value = ${Un(i)}(0.0);
    ${a}
    return value;
  }
  `}function dB(n,e,t,r,s=!1,i=!1,o=!1,a=1){return`
  ${rQ(t,r,s,i,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Un(a)}) {
    ${s&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Uy(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const ABe=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,MBe=(n,e,t,r)=>{if(n)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",i="";for(let o=0;o<e;o++)s+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,i+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function NN(n,e,t=!1,r=32,s=!1,i=32,o=!1){const a=e[1]*n[1],l=e[0]*n[0],c=t?a:r,u=t?r:a,h=c/e[0],f=r/e[1],d=n[1],p=n[0];return U((t&&h===4&&n[1]===4||!t&&(h===3||h===4))&&c%e[0]===0&&r%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${c/h}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${r}>;

  ${St()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${d};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${d};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${d}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${f};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${ABe(t,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${MBe(t,h,d,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const qG=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,NBe=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function $N(n,e,t=!1,r=32,s=!1,i=32,o=!1,a=!1){const l=n[1]*e[1],c=n[0]*e[0],u=t?l:r,h=t?r:l;U(h%e[1]===0&&u%e[0]===0&&r%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const f=h/e[1],d=u/e[0],p=r/e[1],m=n[1],g=n[0],y=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${qG(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${f};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${qG(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${NBe(t)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${St()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${g}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${y}
    }
  `}const $Be=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function RBe(n,e=!1){U(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${St()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${$Be(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class PBe{constructor(e,t,r=!1,s=!1,i=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||t[1]%4===0&&r)&&t[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const f=oze(t[1],c,t[2],r);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const u=i!=null,h=a!=null;u&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const o=e%s===0,a=t%i===0,l=r%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${qf(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${dB(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?NN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?RBe(this.workgroupSize,this.transposeA):$N(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DBe(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${St()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class OBe{constructor(e,t=!1,r=!1,s=null,i=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=r,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${r}`}getUserCode(){return`
      ${qf(this.activation,this.hasPreluActivationWeights)}
      ${dB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${DBe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FBe(n){const e=n[1],t=n[0],r=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${St()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class LBe{constructor(e,t,r,s=!1,i=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=o!=null;c&&this.variableNames.push("bias");const u=l!=null;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=i,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${i}`}getUserCode(){return`
      ${qf(this.activation,this.hasPreluActivationWeights)}
      ${dB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${FBe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zBe{constructor(e,t,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,U(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(r&&this.outputShape[1]%4===0||!r&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=_t(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${rQ(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Un(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Mp("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?NN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):$N(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class BBe{constructor(e,t=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${qf(this.activation,this.hasPreluActivationWeights)}
    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Uy(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VBe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||xp(s),i==="string"){const o=Cs(i,Te(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new VBe(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(o,[],i,a)}}const UBe={kernelName:u2,backendName:"webgpu",kernelFunc:ya};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:s}=t,i=Te(r.shape),o=mM(s,i),a=Te(o);return U(i===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const WBe={kernelName:hw,backendName:"webgpu",kernelFunc:Kt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Te(m),b=Te(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const _=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=Kt({inputs:{x:n},backend:s,attrs:{shape:_}}),A=Kt({inputs:{x:e},backend:s,attrs:{shape:C}}),M=[k,A],I=Math.max(y,b),N=[k,A],O=[{type:"int32",data:[d]},{type:"int32",data:[p]},{type:"int32",data:[h]}];let R,D;const z=[I,d,p];let B=Ee().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(B<0){const G=Ee().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),ee=G>0?G:s.thresholdToIncreaseWorkgroups,pe=I*Math.ceil(d/32)*Math.ceil(p/32);pe<=ee||d<=8&&pe<=ee*2?I*d*p<=128?B=rh.MatMulReduceProgram:I===1&&f>=2e3?B=rh.MatMulSplitKProgram:B=rh.MatMulSmallOutputSizeProgram:B=rh.MatMulPackedProgram}switch(B){case rh.MatMulReduceProgram:R=new OBe(z,t,r,i,l,o);break;case rh.MatMulSplitKProgram:{if(D=ya({backend:s,attrs:{shape:z,value:0,dtype:n.dtype}}),R=new zBe(z,f,t,r),i||l){D=s.runWebGPUProgram(R,N,n.dtype,O,D);const ee=new BBe(D.shape,i,l,o);let pe=null;const oe=[D];i&&oe.push(i),o&&oe.push(o),l==="leakyrelu"&&(pe=[{type:"float32",data:[a]}],ee.uniforms+=" alpha : f32,");const Ne=s.runWebGPUProgram(ee,oe,D.dtype,pe);M.push(D);const ke=Kt({inputs:{x:Ne},backend:s,attrs:{shape:w}});M.push(Ne);for(const De of M)s.disposeData(De.dataId);return ke}break}case rh.MatMulSmallOutputSizeProgram:R=new LBe(_,C,z,t,r,i,l,o);break;case rh.MatMulPackedProgram:const G=s.adapterInfo.isIntel();R=new PBe(_,z,t,r,i,l,o,G);break;default:throw new Error(`Unsupported MatMulProgramType ${B}.`)}i&&N.push(i),o&&N.push(o),l==="leakyrelu"&&(O.push({type:"float32",data:[a]}),R.uniforms+=" alpha : f32,"),D=s.runWebGPUProgram(R,N,n.dtype,O,D);const X=Kt({inputs:{x:D},backend:s,attrs:{shape:w}});M.push(D);for(const G of M)s.disposeData(G.dataId);return X}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GBe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return RN({a:s,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const HBe={kernelName:Lb,backendName:"webgpu",kernelFunc:GBe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XG{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ln(t,r),this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${fB(this.op,!1)}
      }

      ${St("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PI{constructor(e,t,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ln(t,r),this.dispatchLayout=Dt(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&r.length>1&&t[0]<128,this.useSharedMemoryWithB=r.length<=1&&t.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=t.length>0&&t[t.length-1]%4===0,i=r.length>0&&r[r.length-1]%4===0;s&&i?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(tD(r)||r[r.length-1]===1)||i&&(tD(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${fB(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${St("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${St("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ja(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const jBe={kernelName:ey,backendName:"webgpu",kernelFunc:ja};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wy(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.tensorMap.get(i.dataId),a=ja({inputs:{x:r},backend:t}),l=ja({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const qBe={kernelName:K_,backendName:"webgpu",kernelFunc:Wy};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lw{constructor(e,t,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${bm(this.op,!1)}
      }
      ${St("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pr({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:r,backend:s})=>{const{x:i}=r,o=s,a=t||i.dtype;if(o.shouldExecuteOnCPU([i])&&e!=null){const c=o.tensorMap.get(i.dataId),u=e(c.values,a);return o.makeTensorInfo(i.shape,a,u)}const l=new Lw(i.shape,n);return o.runWebGPUProgram(l,[i],a)}}function qi({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:r}){return({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(t&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),f=l.tensorMap.get(a.dataId);let d,p;if(n!==gn.MUL)[d,p]=[[h.complexTensorInfos.real,f.complexTensorInfos.real],[h.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(g=>{const[y,b]=g,x={dataId:y.dataId,dtype:y.dtype,shape:o.shape},w={dataId:b.dataId,dtype:b.dtype,shape:a.shape},_=new PI(n,o.shape,a.shape);return l.runWebGPUProgram(_,[x,w],Ii(y.dtype,b.dtype))});else{const g=new XG(gn.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),y=new XG(gn.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape}];d=l.runWebGPUProgram(g,b,"float32"),p=l.runWebGPUProgram(y,b,"float32")}const m=Wy({inputs:{real:d,imag:p},backend:l});return l.disposeData(d.dataId),l.disposeData(p.dataId),m}const c=r||Ii(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,f=l.tensorMap.get(a.dataId).values,d=o.dtype==="string"?Su(h):h,p=o.dtype==="string"?Su(f):f,[m,g]=e(o.shape,a.shape,d,p,c);return l.makeTensorInfo(g,c,m)}const u=new PI(n,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:XBe,castImpl:KBe,ceilImpl:YBe,concatImpl:ZBe,equalImpl:JBe,expImpl:QBe,expm1Impl:e4e,floorImpl:t4e,floorDivImpl:n4e,gatherNdImpl:r4e,gatherV2Impl:s4e,greaterEqualImpl:i4e,greaterImpl:o4e,lessEqualImpl:a4e,lessImpl:l4e,logImpl:c4e,maxImpl:u4e,maximumImpl:h4e,minimumImpl:f4e,multiplyImpl:d4e,negImpl:p4e,notEqualImpl:m4e,prodImpl:g4e,rangeImpl:y4e,rsqrtImpl:b4e,scatterImpl:v4e,simpleAbsImpl:w4e,sliceImpl:x4e,stridedSliceImpl:S4e,stringNGramsImpl:_4e,subImpl:C4e,tileImpl:k4e,topKImpl:T4e,transposeImpl:E4e,uniqueImpl:AEt}=GZ;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I4e=pr({opType:vt.ABS,cpuKernelImpl:w4e}),A4e={kernelName:_v,backendName:"webgpu",kernelFunc:I4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M4e=pr({opType:vt.ACOS}),N4e={kernelName:Pg,backendName:"webgpu",kernelFunc:M4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $4e=pr({opType:vt.ACOSH}),R4e={kernelName:Dg,backendName:"webgpu",kernelFunc:$4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P4e=qi({opType:gn.ADD,cpuKernelImpl:XBe,supportsComplex:!0}),D4e={kernelName:Sp,backendName:"webgpu",kernelFunc:P4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O4e{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const t=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${St("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4e(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return ja({inputs:{x:r[0]},backend:t});const s=r.map(a=>a.dtype).reduce((a,l)=>Ii(a,l)),i=r.map(a=>a.shape),o=new O4e(i);return t.runWebGPUProgram(o,r,s)}const L4e={kernelName:Cv,backendName:"webgpu",kernelFunc:F4e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z4e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){U(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${St()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B4e{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Ks(this.outputShape.length),t=sQ(this.newDim);return`
      ${St("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function sQ(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let r=0;r<n.length;r++)t[n[r]]=`coords.${Mf(r)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ch(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];if(t.shouldExecuteOnCPU([s])){const h=o.tensorMap.get(s.dataId).values,f=E4e(h,s.shape,s.dtype,i,l);return t.makeTensorInfo(l,s.dtype,f)}if(s.shape.length===2&&Mn(i,[1,0])){const u=new z4e(s.shape,i);return o.runWebGPUProgram(u,[s],s.dtype)}const c=new B4e(s.shape,i);return o.runWebGPUProgram(c,[s],s.dtype)}const V4e={kernelName:Bd,backendName:"webgpu",kernelFunc:Ch};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U4e{constructor(e,t,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=Js(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${St("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W4e={mean:"float32",all:"bool",any:"bool"};function Gy(n,e,t,r,s){const i=n.shape.length,o=[],a=Tn(e,n.shape);let l=a;const c=Lr(l,i);let u=n;c!=null&&(u=Ch({inputs:{x:n},attrs:{perm:c},backend:s}),l=rs(l.length,i),o.push(u)),ui(r,l,i);const[h,f]=Js(u.shape,l);let d=h;t&&(d=Ls(h,a));let p;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([u])){const m=s.tensorMap.get(u.dataId).values;switch(r){case"max":const g=u4e(m,Te(f),d,n.dtype);p=s.makeTensorInfo(d,n.dtype,g);break;case"prod":const{outVals:y,outShape:b,outDtype:x}=g4e(u.shape,u.dtype,m,l);p=s.makeTensorInfo(b,x,y);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const m=Te(f),y=Te(u.shape)/m,b={windowSize:m,inSize:m,batchSize:y,outSize:1},x=W4e[r]||U2(n.dtype),w=[{type:"int32",data:[m]}],_=new U4e(b,r,s.device.limits.maxComputeWorkgroupSizeX),C=s.runWebGPUProgram(_,[u],x,w);o.push(C),p=Kt({inputs:{x:C},attrs:{shape:d},backend:s})}return o.forEach(m=>s.disposeData(m.dataId)),p}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Gy(s,o,i,"all",t)}const H4e={kernelName:U_,backendName:"webgpu",kernelFunc:G4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Gy(s,o,i,"any",t)}const q4e={kernelName:W_,backendName:"webgpu",kernelFunc:j4e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iQ{constructor(e,t,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[t];this.op=r==="min"?"<":">";const[i,o]=Js(e,s);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=Dt(this.outputShape),Te(o)<32?(this.type="plain",this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=_t(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Mf(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)s+=`outputCoords.${Mf(i)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${St("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${St("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=Tn(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Ch({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=rs(o.length,l.shape.length)),ui("argMax",[o[0]],l.shape.length);const u=new iQ(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const K4e={kernelName:kv,backendName:"webgpu",kernelFunc:X4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=Tn(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Ch({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=rs(o.length,l.shape.length)),ui("argMin",[o[0]],l.shape.length);const u=new iQ(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const Z4e={kernelName:Tv,backendName:"webgpu",kernelFunc:Y4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J4e=pr({opType:vt.ASIN}),Q4e={kernelName:Og,backendName:"webgpu",kernelFunc:J4e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eVe=pr({opType:vt.ASINH}),tVe={kernelName:Fg,backendName:"webgpu",kernelFunc:eVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nVe=pr({opType:vt.ATAN}),rVe={kernelName:Lg,backendName:"webgpu",kernelFunc:nVe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sVe=qi({opType:gn.ATAN2}),iVe={kernelName:Bg,backendName:"webgpu",kernelFunc:sVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oVe=pr({opType:vt.ATANH}),aVe={kernelName:zg,backendName:"webgpu",kernelFunc:oVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lVe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TS{constructor(e,t,r=!1,s=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${r}_${s}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class pB{constructor(e,t,r=!1,s=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${r}_${s}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r;return Gy(s,i,o,"max",t)}const cVe={kernelName:Zv,backendName:"webgpu",kernelFunc:oQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Gy(s,o,i,"mean",t)}const uVe={kernelName:ew,backendName:"webgpu",kernelFunc:aQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(n,e,t,r){if(e.filterWidth===1&&e.filterHeight===1&&Mn(e.inShape,e.outShape))return ja({inputs:{x:n},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=Kt({inputs:{x:n},backend:r,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let l;t==="avg"?l=aQ({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(U(t==="max",()=>`Invalid pool type ${t}`),l=oQ({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Kt({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let s;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new lVe(e):(t==="avg"?s=new TS(e,"avg"):(U(t==="max",()=>`Invalid pool type ${t}`),s=new TS(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[n],n.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=_o(s.shape,i,o,c,a,l);return lQ(s,u,"avg",t)}const fVe={kernelName:Ev,backendName:"webgpu",kernelFunc:hVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=zl(s.shape,i,o,u,a,c,l),f=new pB(h,"avg"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[s],s.dtype,d)}const pVe={kernelName:Iv,backendName:"webgpu",kernelFunc:dVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class gVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=zl(o.shape,a,l,1,c,u),f=new gVe(h),d=1/(h.filterDepth*h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(f,[s],o.dtype,p)}const bVe={kernelName:H_,backendName:"webgpu",kernelFunc:yVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;nQ([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=_o(o.shape,a,l,1,c),h=new mVe(u),f=1/(u.filterHeight*u.filterWidth),d=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[f]}];return t.runWebGPUProgram(h,[s],o.dtype,d)}const wVe={kernelName:G_,backendName:"webgpu",kernelFunc:vVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xVe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return RN({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const SVe={kernelName:Av,backendName:"webgpu",kernelFunc:xVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Ve{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ks(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ks(this.rank),t=CVe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((i,o)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((i,o)=>`sourceLoc.${ND[o]} = uniforms.start.${Mf(o)} + coords.${ND[o]};`),`
      ${St("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const ND=["x","y","z","w","u","v"];function CVe(n){if(n===1)return"sourceLoc";if(n<=6)return ND.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=oC(s,i,o);if(rN(s,a,l),t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.tensorMap.get(s.dataId),f=x4e(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,f)}if(Te(l)===0)return t.makeTensorInfo(l,s.dtype,[]);const c=new _Ve(a,l),u=[{type:"int32",data:a}];return t.runWebGPUProgram(c,[s],s.dtype,u)}const kVe={kernelName:gw,backendName:"webgpu",kernelFunc:zw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TVe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=Dy(s.shape,i,a),c=Oy(l.length,i.length),u=Fy(s.shape,i,a),h=cN(o,i.length),f=uN(u,o,i.length),d=[],p=Kt({inputs:{x:s},backend:t,attrs:{shape:l}}),m=Ch({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Kt({inputs:{x:m},backend:t,attrs:{shape:u}}),y=zw({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeData(b.dataId)),y},EVe={kernelName:Mv,backendName:"webgpu",kernelFunc:TVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IVe=`
  fn bincount_write(index: i32, value: f32) {
    ${Mp("&result[index]","value","float32")}
  }
`,AVe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class cQ{constructor(e,t,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?AVe:IVe}
  ${St("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=Te(s.shape),c=Te(i.shape)>0,u=[o],h=i.dtype,f=ya({backend:t,attrs:{shape:u,value:0,dtype:h}}),d=new cQ([a],c),p=[{type:"int32",data:[o]}],m=c?[s,i]:[s];return t.runWebGPUProgram(d,m,h,p,f)}const NVe={kernelName:j_,backendName:"webgpu",kernelFunc:MVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Ve{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${St("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RVe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e;if(t.shouldExecuteOnCPU([r,s])){const u=t.tensorMap.get(r.dataId),h=t.tensorMap.get(s.dataId),f=u.values,d=h.values,p=ln(Array.from(f),Array.from(d));return t.makeTensorInfo([p.length],"int32",Int32Array.from(p))}const i=Te(r.shape),o=Te(s.shape),a=Math.max(i,o),l=new $Ve(a),c=[{type:"int32",data:[i]},{type:"int32",data:[o]}];return t.runWebGPUProgram(l,[r,s],"int32",c)}const PVe={kernelName:X_,backendName:"webgpu",kernelFunc:RVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uQ=qi({opType:gn.NOT_EQUAL,dtype:"bool",cpuKernelImpl:m4e}),DVe={kernelName:sw,backendName:"webgpu",kernelFunc:uQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return ja({inputs:{x:s.complexTensorInfos.real},backend:t})}const OVe={kernelName:C2,backendName:"webgpu",kernelFunc:mC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FVe(n,e){const t=new Lw(n.shape,vt.TO_INT),r=e.runWebGPUProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $D(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return ja({inputs:{x:s},backend:t});const o=ms(s.shape),a=$D({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=Wy({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),l}if(s.dtype==="complex64"){const o=mC({inputs:{input:s},backend:t}),a=$D({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeData(o.dataId),a}if(!gM(s.dtype,i)){const o=ja({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.tensorMap.get(s.dataId).values,[a,l,c]=KBe(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return FVe(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",li("bool",1)),l=uQ({inputs:{a:s,b:o},backend:t});return t.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const LVe={kernelName:Vg,backendName:"webgpu",kernelFunc:$D};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zVe=pr({opType:vt.CEIL,cpuKernelImpl:YBe}),BVe={kernelName:Ug,backendName:"webgpu",kernelFunc:zVe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VVe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${St("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UVe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${St("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;const l=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return Te(s.shape)%4===0?a=new VVe(s.shape):a=new UVe(s.shape),t.runWebGPUProgram(a,[s],s.dtype,l)}const GVe={kernelName:Wg,backendName:"webgpu",kernelFunc:WVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HVe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function jVe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.tensorMap.get(r.dataId),i=new HVe(r.shape),o=[KG(r,s.complexTensorInfos.real),KG(r,s.complexTensorInfos.imag)];return t.runWebGPUProgram(i,o,o[0].dtype)}const qVe={kernelName:Nv,backendName:"webgpu",kernelFunc:jVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XVe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ga(e,1),this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${St("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PN(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return ja({inputs:{x:s.complexTensorInfos.imag},backend:t})}const KVe={kernelName:p2,backendName:"webgpu",kernelFunc:PN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const p=n.map(x=>mC({inputs:{input:x},backend:t})),m=n.map(x=>PN({inputs:{input:x},backend:t})),g=S1(p,e,t),y=S1(m,e,t),b=Wy({inputs:{real:g,imag:y},backend:t});return p.forEach(x=>t.disposeData(x.dataId)),m.forEach(x=>t.disposeData(x.dataId)),t.disposeData(g.dataId),t.disposeData(y.dataId),b}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const p=n.map(_=>{const k=[-1,Te(_.shape.slice(e))];return Kt({inputs:{x:_},backend:t,attrs:{shape:k}})}),m=p.map(_=>({vals:t.readSync(_.dataId),shape:_.shape})),g=ga(p.map(_=>_.shape),1),y=p[0].shape[0]===1,b=ZBe(m,g,r,y),x=ga(n.map(_=>_.shape),e),w=t.makeTensorInfo(x,r,b);return p.forEach(_=>t.disposeData(_.dataId)),w}const i=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const p=[];for(let g=0;g<n.length;g+=i){const y=n.slice(g,g+i);p.push(S1(y,e,t))}const m=S1(p,e,t);for(const g of p)t.disposeData(g.dataId);return m}const{tensors2D:o,outShape:a}=YVe(n,e,t),l=o.map(p=>p.shape),c=new XVe(l),u=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],u.push({type:"int32",data:[h[0]]});for(let p=1;p<h.length;p++)h[p]=h[p-1]+l[p][1],u.push({type:"int32",data:[h[p]]})}const f=t.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach(p=>t.disposeData(p.dataId));const d=Kt({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),d}function YVe(n,e,t){const r=ga(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Kt({inputs:{x:i},backend:t,attrs:{shape:[Te(i.shape.slice(0,e)),Te(i.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=Tn(s,e[0].shape)[0],o=e.map(c=>c.shape);oN(o,i);const a=ga(e.map(c=>c.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Te(c.shape)>0);return l.length===1?ja({inputs:{x:l[0]},backend:t}):S1(l,i,t)}const ZVe={kernelName:$v,backendName:"webgpu",kernelFunc:hQ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JVe(n,e,t,r,s=!1,i=null,o=!1,a=4,l=4,c=4){const u=M=>{switch(M){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},h=M=>{switch(M){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},f=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,p=n?"uniforms.xShape[1]":"uniforms.xShape[2]",m=n?"uniforms.xShape[2]":"uniforms.xShape[3]",g=n?"row":"col",y=n?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${y} % inChannels;
      var resData = ${Un(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${m}) {
        ${f}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${u(a)}
      }
      return resData;`,x=n?e&&r?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${Un(a)}(0.0);`:r&&t?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${Un(a)}(0.0);`,w=`${h(l)}`,_=Un(c),C=Un(n?a:l),k=Un(n?l:a);return`
      ${qf(i,o,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${C} {
        ${n?x:w}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${k} {
        ${n?w:x}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${_}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${Uy(s,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class QVe{constructor(e,t,r,s,i=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=QJ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=eQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=i,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?NN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):$N(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${JVe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eUe{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=r,this.hasPreluActivationWeights=s,t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${qf(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Uy(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${St("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tUe{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${St("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function nUe({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.dataFormat==="channelsLast",c=!l,u=!1,h=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=[];let d,p;if(h){const y=t.inHeight*t.inWidth*t.inChannels;d=Kt({inputs:{x:n},backend:r,attrs:{shape:[1,t.batchSize,y]}}),p=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,y,t.outChannels]}})}else d=Kt({inputs:{x:n},backend:r,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),p=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(f.push(d),f.push(p),i!=null){const y=DI(i.shape,l);y!=null&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:y}}),f.push(i))}if(s!=null){const y=DI(s.shape,l);y!=null&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:y}}),f.push(s))}const m=RN({a:l?d:p,b:l?p:d,transposeA:c,transposeB:u,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),g=Kt({inputs:{x:m},backend:r,attrs:{shape:t.outShape}});f.push(m);for(const y of f)r.disposeData(y.dataId);return g}function rUe({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:h,strideHeight:f,padInfo:d,outWidth:p,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:b}=t,x=b==="channelsLast",w=l*c*u,_=m*p,C=x?[t.batchSize,_,w]:[t.batchSize,w,_],k=new tUe(C,x),A=[{type:"int32",data:[d.top,d.left]},{type:"int32",data:[f,h]},{type:"int32",data:[y,g]},{type:"int32",data:[p]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],M=r.runWebGPUProgram(k,[n],n.dtype,A),I=[];I.push(M);const N=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,w,-1]}});if(I.push(N),i!=null){const B=DI(i.shape,x);B!=null&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:B}}),I.push(i))}if(s!=null){const B=DI(s.shape,x);B!=null&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:B}}),I.push(s))}const D=RN({a:x?M:N,b:x?N:M,transposeA:!x,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),z=Kt({inputs:{x:D},backend:r,attrs:{shape:t.outShape}});I.push(D);for(const B of I)r.disposeData(B.dataId);return z}function fQ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=s!=null,c=i!=null,u=t.dataFormat==="channelsLast",h=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=Ee().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!f&&(h||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return nUe({x:n,filter:e,convInfo:t,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});const d=Ee().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),p=d>-1?d:r.thresholdToIncreaseWorkgroups,m=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(Ee().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=p)return rUe({x:n,filter:e,convInfo:t,backend:r,bias:s,preluActivationWeights:i,leakyreluAlpha:o,activation:a});let g;const y=[t.padInfo.top,t.padInfo.left],b=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(f)g=new eUe(t,l,a,c);else{const C=u?t.outHeight*t.outWidth:t.outChannels,k=u?t.outChannels:t.outHeight*t.outWidth,A=t.filterHeight*t.filterWidth*t.inChannels;b.push({type:"int32",data:[C]},{type:"int32",data:[k]},{type:"int32",data:[A]});const M=r.adapterInfo.isIntel();g=new QVe(t,C,k,A,l,a,c,M)}const x=[],w=[n,e];l&&(!u&&s.shape.length===1&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),x.push(s)),w.push(s)),c&&(!u&&i.shape.length===1&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),x.push(i)),w.push(i)),a==="leakyrelu"&&(b.push({type:"float32",data:[o]}),g.uniforms+=" alpha : f32,");const _=r.runWebGPUProgram(g,w,n.dtype,b);for(const C of x)r.disposeData(C.dataId);return _}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sUe(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=t,h=Qa(l),f=ns(s.shape,i.shape,o,c,a,u,!1,h);return fQ({x:s,filter:i,convInfo:f,backend:r})}const iUe={kernelName:Rv,backendName:"webgpu",kernelFunc:sUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oUe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${St()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${St("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class aUe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${St("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class lUe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${St("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class cUe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${St("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=Qa(l),f=ns(s.shape,u,o,1,a,c,!1,h),d=new aUe(f),p=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]}];return t.runWebGPUProgram(d,[s,i],s.dtype,p)}const hUe={kernelName:Y_,backendName:"webgpu",kernelFunc:uUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fUe(n=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Un(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Un(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Un(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Un(n)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Un(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Un(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Un(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class dUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=QJ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=eQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?NN(this.elementsPerThread,this.workgroupSize):$N(this.elementsPerThread,this.workgroupSize);return`
    ${fUe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=Qa(c),f=ns(o,i.shape,a,1,l,u,!1,h),d=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let p;if(Ee().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.dataFormat!=="channelsLast")p=new oUe(f);else{p=new dUe(f);const m=f.inHeight*f.inWidth,g=f.inChannels,y=f.filterHeight*f.filterWidth*f.outChannels;d.push({type:"uint32",data:[m]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return t.runWebGPUProgram(p,[s,i],"float32",d)}const mUe={kernelName:Pv,backendName:"webgpu",kernelFunc:pUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Ou(s.shape,i.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],f=new gUe(c),d=Ii(s.dtype,i.dtype);return t.runWebGPUProgram(f,[s,i],d,h)}const bUe={kernelName:Dv,backendName:"webgpu",kernelFunc:yUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,c=Ou(s.shape,l,o,1,a),u=new lUe(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(u,[s,i],i.dtype,h)}const wUe={kernelName:Z_,backendName:"webgpu",kernelFunc:vUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,pad:a,inputShape:l}=r,c=Ou(l,i.shape,o,1,a),u=new cUe(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(u,[s,i],s.dtype,h)}const SUe={kernelName:J_,backendName:"webgpu",kernelFunc:xUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ue=pr({opType:vt.COS}),CUe={kernelName:Gg,backendName:"webgpu",kernelFunc:_Ue};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kUe=pr({opType:vt.COSH}),TUe={kernelName:Hg,backendName:"webgpu",kernelFunc:kUe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EUe{constructor(e,t,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,r[0],r[1],e],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IUe=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new EUe(s.shape[3],i.shape,a,l),h=[{type:"float32",data:[c]}];return t.runWebGPUProgram(u,[s,i,o],"float32",h)},AUe={kernelName:e2,backendName:"webgpu",kernelFunc:IUe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ES;(function(n){n.Prod="*",n.Sum="+"})(ES||(ES={}));class YG{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===ES.Prod?"1.0":"0.0",r=this.exclusive?t:`getX(${ZG(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let i="",o="";return this.exclusive?(i=this.reverse?`end != ${s-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${s}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${St("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${JG(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${o};
           ${JG(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${ZG(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function ZG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function JG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQ(n,e,t,r,s,i){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Ch({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=rs(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=ja({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new YG(n,l.shape,!1,i),p=h,m=[{type:"float32",data:[f]}];h=t.runWebGPUProgram(d,[h],h.dtype,m),t.disposeData(p.dataId)}if(s){const f=new YG(n,l.shape,s,i),d=h,p=[{type:"float32",data:[0]}];h=t.runWebGPUProgram(f,[h],h.dtype,p),t.disposeData(d.dataId)}if(a!=null){const f=Rh(a),d=Ch({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeData(h.dataId),t.disposeData(l.dataId),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return dQ(ES.Prod,s,t,i,o,a)}const NUe={kernelName:Q_,backendName:"webgpu",kernelFunc:MUe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ue(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return dQ(ES.Sum,s,t,i,o,a)}const RUe={kernelName:Ov,backendName:"webgpu",kernelFunc:$Ue};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r,l=s.shape.length===1,u=Te(i.shape)>0,h=i.dtype,f=l?[s.shape[0]]:[s.shape[0],s.shape[1]],d=l?[o]:[s.shape[0],o],p=ya({backend:t,attrs:{shape:d,value:0,dtype:h}}),m=new cQ(f,u,a),g=[{type:"int32",data:[o]}],y=u?[s,i]:[s];return t.runWebGPUProgram(m,y,h,g,p)}const DUe={kernelName:t2,backendName:"webgpu",kernelFunc:PUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OUe{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],u=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,f=c*i,d=u/(i*i),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=[{type:"int32",data:[i]}],g=new OUe(p,o);return t.runWebGPUProgram(g,[s],s.dtype,m)}const LUe={kernelName:n2,backendName:"webgpu",kernelFunc:FUe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zUe{constructor(e,t,r,s=!1,i=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=i,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${qf(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${St()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Uy(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pQ{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Dt(i),this.dispatch=_t(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${qf(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${St("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Uy(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mQ{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${qf(this.activation,this.hasPreluActivation,!1,4)}

      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Uy(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=Qa(l);let f=c;f==null&&(f=[1,1]);const d=ns(s.shape,i.shape,o,f,a,u,!0,h),p=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],m=d.dataFormat==="channelsLast";let g;return!m&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new zUe(d.outShape,d.filterHeight,d.filterWidth):m&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?(g=new pQ(d),p.push({type:"int32",data:[g.virtualWidth]})):(g=new mQ(d),p.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(g,[s,i],s.dtype,p)}const VUe={kernelName:Fv,backendName:"webgpu",kernelFunc:BUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UUe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class WUe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ns(s.shape,u,o,a,l,c,!0),f=new UUe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[s,i],"float32",d)}const HUe={kernelName:r2,backendName:"webgpu",kernelFunc:GUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ns(u,i.shape,o,a,l,c,!0),f=new WUe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[s,i],s.dtype,d)}const qUe={kernelName:s2,backendName:"webgpu",kernelFunc:jUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XUe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KUe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Te(r.shape),o=Kt({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new XUe(i),l=t.runWebGPUProgram(a,[o],o.dtype),c=Kt({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const YUe={kernelName:i2,backendName:"webgpu",kernelFunc:KUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZUe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${St("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=kp(s.shape,i.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],f=new ZUe(c);return t.runWebGPUProgram(f,[s,i],s.dtype,h)}const QUe={kernelName:Lv,backendName:"webgpu",kernelFunc:JUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eWe{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(e.outShape),this.dispatch=_t(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${St("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Mp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class tWe{constructor(e,t,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Dt(e.outShape),this.dispatch=_t(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${St("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Mp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=kp(s.shape,i.shape,a,l,"NHWC",c),h=i.dtype,f=new tWe(u,i.shape,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Te(u.outShape)]}],p=ya({backend:t,attrs:{shape:i.shape,value:0,dtype:h}});return t.runWebGPUProgram(f,[s,i,o],h,d,p)}const rWe={kernelName:uS,backendName:"webgpu",kernelFunc:nWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=kp(s.shape,i.shape,a,l,"NHWC",c),h=s.dtype,f=new eWe(u,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Te(u.outShape)]}],p=ya({backend:t,attrs:{shape:u.inShape,value:0,dtype:h}});return t.runWebGPUProgram(f,[s,i,o],h,d,p)}const iWe={kernelName:cS,backendName:"webgpu",kernelFunc:sWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oWe{constructor(e,t,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Qb.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=r,this.shaderKey=`draw_${t}_${r}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${St("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aWe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,[a,l]=s.shape.slice(0,2),{imageOptions:c}=o||{},u=(c==null?void 0:c.alpha)||1,h=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",f=[a,l],d=new oWe(f,s.dtype,h);i.width=l,i.height=a;const p="webgpu";let m=i.getContext(p),g;m||(g=new OffscreenCanvas(l,a),m=g.getContext(p));const y=s.shape.length===3?s.shape[2]:1;m.configure({device:t.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",x=t.makeTensorInfo(f,b),w=t.tensorMap.get(x.dataId);w.resource=m.getCurrentTexture(),w.external=!0;const _=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(t.runWebGPUProgram(d,[s],b,_,x),g){const C=i.getContext("2d");if(!C)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");C.drawImage(g,0,0)}return t.disposeData(x.dataId),s}const lWe={kernelName:o2,backendName:"webgpu",kernelFunc:aWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gQ=qi({opType:gn.MUL,cpuKernelImpl:d4e,supportsComplex:!0}),cWe={kernelName:cy,backendName:"webgpu",kernelFunc:gQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Gy(s,i,o,"sum",t)}const uWe={kernelName:yw,backendName:"webgpu",kernelFunc:yQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hWe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=yN(s,i.length);vN(o.length,l,i);const{path:c,steps:u}=wN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=bN(d,l[g]);let x;xN(y)?x=i[g]:(x=Ch({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let _=0;_<b.length;++_)w.splice(b[_],0,1);Mn(x.shape,w)||(x=Kt({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=gQ({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=yQ({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeData(m.dataId);return f}const fWe={kernelName:a2,backendName:"webgpu",kernelFunc:hWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dWe=pr({opType:vt.ELU}),pWe={kernelName:qg,backendName:"webgpu",kernelFunc:dWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mWe=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=new PI(gn.ELU_DER,r.shape,s.shape);return t.runWebGPUProgram(i,[r,s],r.dtype)},gWe={kernelName:l2,backendName:"webgpu",kernelFunc:mWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yWe=qi({opType:gn.EQUAL,dtype:"bool",cpuKernelImpl:JBe}),bWe={kernelName:zv,backendName:"webgpu",kernelFunc:yWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vWe=pr({opType:vt.ERF}),wWe={kernelName:Xg,backendName:"webgpu",kernelFunc:vWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xWe=pr({opType:vt.EXP,cpuKernelImpl:QBe,dtype:"float32"}),SWe={kernelName:Kg,backendName:"webgpu",kernelFunc:xWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),Kt({inputs:{x:i},backend:r,attrs:{shape:a}})}const _We={kernelName:Bv,backendName:"webgpu",kernelFunc:RD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CWe=pr({opType:vt.EXPM1,cpuKernelImpl:e4e}),kWe={kernelName:Yg,backendName:"webgpu",kernelFunc:CWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QG{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(n,e,t){const r=t.tensorMap.get(n.dataId),s=Te(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=[],l=Kt({inputs:{x:n},backend:t,attrs:{shape:[o,i]}});a.push(l);const c=l.shape,u=new QG("real",c),h=new QG("imag",c),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=e?2*Math.PI:-2*Math.PI,p=e?c[1]:1,m=[{type:"float32",data:[d]},{type:"float32",data:[p]}],g=t.runWebGPUProgram(u,f,"float32",m);a.push(g);const y=t.runWebGPUProgram(h,f,"float32",m);a.push(y);const b=Wy({inputs:{real:g,imag:y},backend:t});a.push(b);const x=Kt({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return a.forEach(w=>t.disposeData(w.dataId)),x}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TWe(n){const{inputs:e,backend:t}=n,{input:r}=e;return bQ(r,!1,t)}const EWe={kernelName:c2,backendName:"webgpu",kernelFunc:TWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IWe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AWe={kernelName:h2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new IWe(t.shape);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MWe=pr({opType:vt.FLOOR,cpuKernelImpl:t4e}),NWe={kernelName:Zg,backendName:"webgpu",kernelFunc:MWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $We=qi({opType:gn.FLOOR_DIV,cpuKernelImpl:n4e,dtype:"int32"}),RWe={kernelName:Jg,backendName:"webgpu",kernelFunc:$We};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PWe{constructor(e,t,r=!1){this.pixelsOpType=Qb.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${St("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DWe={kernelName:hS,backendName:"webgpu",kernelFunc:OWe};let T0,l3=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function OWe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[u,h]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],f=[h,u,i],d=Ee().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,p=o||a;if(c||l||p){let b;if(d)b=t.device.importExternalTexture({source:s});else{if(p){const R=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(T0==null||R!==l3)&&(l3=R,T0=document.createElement("canvas").getContext("2d",{willReadFrequently:l3})),T0.canvas.width=u,T0.canvas.height=h,T0.drawImage(s,0,0,u,h),s=T0.canvas}const I=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,N="rgba8unorm",O=t.textureManager.acquireTexture(f[1],f[0],N,I);t.queue.copyExternalImageToTexture({source:s},{texture:O},[f[1],f[0]]),b=O}const x=Te(f),w=Jt(f),_=new PWe(f,i,d),C=[{type:"uint32",data:[x]},{type:"uint32",data:[i]},{type:"uint32",data:[...w]}],k=t.makeTensorInfo([h,u],"int32"),A=t.tensorMap.get(k.dataId);A.resource=b;const M=t.runWebGPUProgram(_,[k],"int32",C);return t.disposeData(k.dataId),M}const m=s.data;let g=m;if(i!=null&&i!==4){g=new Uint8Array(s.width*s.height*i);const b=m.length;let x=0;for(let w=0;w<b;w++)w%4<i&&(g[x++]=m[w])}const y=t.makeTensorInfo(f,"int32",new Int32Array(g));return t.uploadToGPU(y.dataId),y}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FWe{constructor(e,t,r,s,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r),this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(ln(e,s),this.variableNames.push("offset")),i!=null&&(ln(e,i),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${St("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LWe={kernelName:Vv,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r,scale:s,offset:i,mean:o,variance:a}=n,{varianceEpsilon:l}=e,c=t,u=[r,o,a];let h=null;i!=null&&(h=i.shape,u.push(i));let f=null;s!=null&&(f=s.shape,u.push(s));const d=new FWe(r.shape,o.shape,a.shape,h,f),p=[{type:"float32",data:[l]}];return c.runWebGPUProgram(d,u,r.dtype,p)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=Qa(u),g=ns(s.shape,i.shape,l,h,c,f,!1,m);return fQ({x:s,filter:i,convInfo:g,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:d})}const BWe={kernelName:zb,backendName:"webgpu",kernelFunc:zWe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r;let p=u;p==null&&(p=[1,1]),U(Ni(l,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);const m=ns(s.shape,i.shape,l,p,c,h,!0),g=[s,i],y=o!=null,b=a!=null;y&&g.push(o),b&&g.push(a);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let w;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&m.dilationHeight===1&&m.dilationWidth===1&&m.inChannels%4===0?(w=new pQ(m,y,f,b),x.push({type:"int32",data:[w.virtualWidth]})):(w=new mQ(m,y,f,b),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),f==="leakyrelu"&&(x.push({type:"float32",data:[d]}),w.uniforms+=" alpha : f32,"),t.runWebGPUProgram(w,g,"float32",x)}const UWe={kernelName:Bb,backendName:"webgpu",kernelFunc:VWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WWe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ks(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GWe(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Te(r.shape),[l,c,u,h]=iC(r,s),f=Kt({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),d=Kt({inputs:{x:r},backend:t,attrs:{shape:[Te(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=t.readSync(s.dataId),x=t.bufferSync(r),w=r4e(b,x,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,w.values)}const p=new WWe(o,[c,u]),m=[{type:"int32",data:[o]},{type:"int32",data:h}],g=t.runWebGPUProgram(p,[d,f],d.dtype,m),y=Kt({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),y}const HWe={kernelName:f2,backendName:"webgpu",kernelFunc:GWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jWe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=qWe(this.aShape);return`
      ${St("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function qWe(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let r=0;r<n.length;r++)r===2?t.push("indexZ"):t.push(`${e[r]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=Tn(o,s.shape)[0],c=_N(s,i,l,a),u=Te(i.shape),h=[],f=Kt({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=Kt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,i])){const x=t.tensorMap.get(d.dataId).values,w=wn(d.shape,d.dtype,x),C=t.tensorMap.get(f.dataId).values,k=wn(f.shape,f.dtype,C),A=s4e(k,w,p);return h.forEach(M=>t.disposeData(M.dataId)),t.makeTensorInfo(c.outputShape,A.dtype,A.values)}const m=new jWe(f.shape,p),g=t.runWebGPUProgram(m,[f,d],f.dtype);h.push(g);const y=Kt({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeData(b.dataId)),y}const XWe={kernelName:Uv,backendName:"webgpu",kernelFunc:vQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KWe=qi({opType:gn.GREATER,cpuKernelImpl:o4e,dtype:"bool"}),YWe={kernelName:Wv,backendName:"webgpu",kernelFunc:KWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZWe=qi({opType:gn.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:i4e}),JWe={kernelName:Qg,backendName:"webgpu",kernelFunc:ZWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QWe(n){const{inputs:e,backend:t}=n,{input:r}=e;return bQ(r,!0,t)}const eGe={kernelName:d2,backendName:"webgpu",kernelFunc:QWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tGe=pr({opType:vt.IS_FINITE,dtype:"bool"}),nGe={kernelName:ty,backendName:"webgpu",kernelFunc:tGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rGe=pr({opType:vt.IS_INF,dtype:"bool"}),sGe={kernelName:ny,backendName:"webgpu",kernelFunc:rGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iGe=pr({opType:vt.IS_NAN,dtype:"bool"}),oGe={kernelName:ry,backendName:"webgpu",kernelFunc:iGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=[{type:"float32",data:[i]}],a=new Lw(s.shape,vt.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[s],"float32",o)}const lGe={kernelName:Gv,backendName:"webgpu",kernelFunc:aGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cGe=qi({opType:gn.LESS,dtype:"bool",cpuKernelImpl:l4e}),uGe={kernelName:Hv,backendName:"webgpu",kernelFunc:cGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hGe=qi({opType:gn.LESS_EQUAL,dtype:"bool",cpuKernelImpl:a4e}),fGe={kernelName:jv,backendName:"webgpu",kernelFunc:hGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dGe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pGe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=(s-r)/(i-1),a=new dGe(i),l=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const mGe={kernelName:m2,backendName:"webgpu",kernelFunc:pGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gGe=pr({opType:vt.LOG,cpuKernelImpl:c4e}),yGe={kernelName:sy,backendName:"webgpu",kernelFunc:gGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bGe=pr({opType:vt.LOG1P}),vGe={kernelName:iy,backendName:"webgpu",kernelFunc:bGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wGe=qi({opType:gn.LOGICAL_AND,dtype:"bool"}),xGe={kernelName:qv,backendName:"webgpu",kernelFunc:wGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SGe=pr({opType:vt.LOGICAL_NOT}),_Ge={kernelName:Xv,backendName:"webgpu",kernelFunc:SGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CGe=qi({opType:gn.LOGICAL_OR}),kGe={kernelName:Kv,backendName:"webgpu",kernelFunc:CGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wQ=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class TGe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${wQ}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class EGe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,U(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${St()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${wQ}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;let c;i>16?c=new TGe(s.shape):c=new EGe(s.shape,i);const u=[{type:"int32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[s],s.dtype,u)}const AGe={kernelName:Yv,backendName:"webgpu",kernelFunc:IGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MGe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new MGe(s.shape),f=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return t.runWebGPUProgram(h,[s,i,o],s.dtype,f)}const $Ge={kernelName:g2,backendName:"webgpu",kernelFunc:NGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RGe=qi({opType:gn.MAX,cpuKernelImpl:h4e}),PGe={kernelName:oy,backendName:"webgpu",kernelFunc:RGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=_o(s.shape,i,o,c,a,l);return lQ(s,u,"max",t)}const OGe={kernelName:Jv,backendName:"webgpu",kernelFunc:DGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=zl(s.shape,i,o,u,a,c,l),f=new pB(h,"max"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[s],s.dtype,d)}const LGe={kernelName:Qv,backendName:"webgpu",kernelFunc:FGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zGe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class BGe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${St("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VGe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=zl(o.shape,a,l,h,c,u),d=new pB(f,"max",!0);let p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[o],"int32",p),g=new BGe(f);p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[s,m],o.dtype,p);return t.disposeData(m.dataId),y}const UGe={kernelName:b2,backendName:"webgpu",kernelFunc:VGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WGe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;nQ([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=_o(a.shape,l,c,1,u,h),d=new TS(f,"max",!0);let p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[a],"int32",p),g=new zGe(f);p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[s,m],a.dtype,p);return t.disposeData(m.dataId),y}const GGe={kernelName:y2,backendName:"webgpu",kernelFunc:WGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HGe(n){const{inputs:e,backend:t,attrs:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=r,{x:l}=e;U(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];U(Ni(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=_o(l.shape,s,i,c,o),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let f=new TS(u,"max",!1);const d=t.runWebGPUProgram(f,[l],l.dtype,h);f=new TS(u,"max",!0,!0,a);const p=t.runWebGPUProgram(f,[l],"int32",h);return[d,p]}const jGe={kernelName:v2,backendName:"webgpu",kernelFunc:HGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Gy(s,i,o,"min",t)}const XGe={kernelName:tw,backendName:"webgpu",kernelFunc:qGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KGe=qi({opType:gn.MIN,cpuKernelImpl:f4e}),YGe={kernelName:ay,backendName:"webgpu",kernelFunc:KGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZGe{constructor(e,t,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,i)=>s[0]+e[i]+s[1]),this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,u)=>`uniforms.pad${u}[0]`).join(","),r=this.xShape.map((c,u)=>`uniforms.pad${u}[0] + uniforms.xShape${e>1?`[${u}]`:""}`).join(","),s=e===1?"start":"start[i]",i=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=Ks(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${St("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${s}) {
              ${o} = ${s} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${i}) {
              ${o} = (${i} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JGe={kernelName:nw,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=t,a=s.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new ZGe(r.shape,s,i);return o.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QGe=qi({opType:gn.MOD}),eHe={kernelName:ly,backendName:"webgpu",kernelFunc:QGe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tHe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${St("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nHe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${St("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=Kt({inputs:{x:s},backend:t,attrs:{shape:[Te(s.shape)/s.shape[i],s.shape[i]]}}),a=new nHe(o.shape),l=t.runWebGPUProgram(a,[o],s.dtype),c=Kt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const rHe={kernelName:ww,backendName:"webgpu",kernelFunc:xQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sHe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:xQ({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new tHe(c,i),f=[{type:"float32",data:[o]},{type:"int32",data:[u]}],d=t.runWebGPUProgram(h,[l],"int32",f);return a||t.disposeData(l.dataId),d}const iHe={kernelName:w2,backendName:"webgpu",kernelFunc:sHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oHe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.tensorMap.get(r.dataId),[o,a]=p4e(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}const s=new Lw(r.shape,vt.NEG);return t.runWebGPUProgram(s,[r],r.dtype)}const aHe={kernelName:rw,backendName:"webgpu",kernelFunc:oHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lHe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=tC(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const cHe={kernelName:x2,backendName:"webgpu",kernelFunc:lHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uHe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=nC(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const hHe={kernelName:S2,backendName:"webgpu",kernelFunc:uHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fHe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${St("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dHe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=Te(s.shape),u=new fHe(c,o),h=Kt({inputs:{x:s},backend:t,attrs:{shape:[c]}}),f=[{type:"float32",data:[a]},{type:"float32",data:[l]}],d=t.runWebGPUProgram(u,[h],i,f);t.disposeData(h.dataId);const p=[...s.shape,o],m=Kt({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeData(d.dataId),m}const pHe={kernelName:ow,backendName:"webgpu",kernelFunc:dHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=mC({inputs:{input:r},backend:t}),i=OI({inputs:{x:s},backend:t}),o=PN({inputs:{input:r},backend:t}),a=OI({inputs:{x:o},backend:t}),l=Wy({inputs:{real:i,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return ya({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const mHe={kernelName:_w,backendName:"webgpu",kernelFunc:OI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SQ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=mC({inputs:{input:r},backend:t}),i=SQ({inputs:{x:s},backend:t}),o=PN({inputs:{input:r},backend:t}),a=OI({inputs:{x:o},backend:t}),l=Wy({inputs:{real:i,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return ya({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const gHe={kernelName:iw,backendName:"webgpu",kernelFunc:SQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yHe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return RD({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{ji(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=RD({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=hQ({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeData(u.dataId)),c}const bHe={kernelName:aw,backendName:"webgpu",kernelFunc:yHe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(n,e=!1){const t=n.length,r=Ks(t),s=n.map((h,f)=>`uniforms.pad${f}[0]`).join(","),i=n.map((h,f)=>`uniforms.pad${f}[0] + uniforms.xShape${t>1?`[${f}]`:""}`).join(","),o=t>1?`${r}(${s})`:`${s}`,a=t>1?`${r}(${i})`:`${i}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${u}));
        }
  `}class vHe{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${_Q(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wHe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(i.every(c=>Mn(c,[0,0])))return ja({inputs:{x:s},backend:t});if(Te(s.shape)===0){const c=i.map((u,h)=>u[0]+s.shape[h]+u[1]);return ya({backend:t,attrs:{shape:c,value:o,dtype:s.dtype}})}const a=[{type:"float32",data:[o]}];i.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new vHe(s.shape,i);return t.runWebGPUProgram(l,[s],s.dtype,a)},xHe={kernelName:lw,backendName:"webgpu",kernelFunc:wHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SHe=qi({opType:gn.POW}),_He={kernelName:uy,backendName:"webgpu",kernelFunc:SHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CHe(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=new PI(gn.PRELU,r.shape,s.shape);return t.runWebGPUProgram(i,[r,s],"float32")}const kHe={kernelName:cw,backendName:"webgpu",kernelFunc:CHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function THe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Gy(s,i,o,"prod",t)}const EHe={kernelName:uw,backendName:"webgpu",kernelFunc:THe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IHe=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=y4e(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},AHe={kernelName:_2,backendName:"webgpu",kernelFunc:IHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MHe=qi({opType:gn.DIV}),NHe={kernelName:jg,backendName:"webgpu",kernelFunc:MHe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $He=pr({opType:vt.RECIPROCAL}),RHe={kernelName:hy,backendName:"webgpu",kernelFunc:$He};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PHe=pr({opType:vt.RELU}),DHe={kernelName:fy,backendName:"webgpu",kernelFunc:PHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OHe=pr({opType:vt.RELU6}),FHe={kernelName:dy,backendName:"webgpu",kernelFunc:OHe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LHe{constructor(e,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zHe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,size:o,halfPixelCenters:a}=r,[l,c]=o,u=i&&l>1?1:0,h=i&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[a?.5:0]}],p=new LHe(s.shape,l,c);return t.runWebGPUProgram(p,[s],"float32",d)}const BHe={kernelName:dw,backendName:"webgpu",kernelFunc:zHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VHe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UHe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,[,a,l]=s.shape,[,c,u]=i.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,x=new VHe(s.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[d]},{type:"float32",data:[p]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(x,[i],i.dtype,w)}const WHe={kernelName:T2,backendName:"webgpu",kernelFunc:UHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GHe{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HHe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=i&&l>1?1:0,h=i&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[i?.5:0]}],p=new GHe(s.shape,l,c,o);return t.runWebGPUProgram(p,[s],s.dtype,d)}const jHe={kernelName:fw,backendName:"webgpu",kernelFunc:HHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qHe{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XHe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,[,a,l]=s.shape,[,c,u]=i.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,x=new qHe(s.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(x,[i],i.dtype,w)}const KHe={kernelName:k2,backendName:"webgpu",kernelFunc:XHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YHe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length;if(o===0)return ja({inputs:{x:s},backend:t});const a=s.shape,l=[1,1,1,1];a.forEach((g,y)=>{const b=y+4-o;l[b]=g});const c=Tn(i,s.shape),u=[0,0,0,0];c.forEach(g=>{const y=g+4-o;u[y]=1});const h=[{type:"int32",data:u}],f=Kt({inputs:{x:s},backend:t,attrs:{shape:l}}),d=new YHe(l),p=t.runWebGPUProgram(d,[f],f.dtype,h);t.disposeData(f.dataId);const m=Kt({inputs:{x:p},backend:t,attrs:{shape:a}});return t.disposeData(p.dataId),m}const JHe={kernelName:pw,backendName:"webgpu",kernelFunc:ZHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QHe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${St("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e6e={kernelName:z2,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new QHe(r.shape,i),[c,u]=lN(o,r.shape[1],r.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof i=="number"?h.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):h.push({type:"float32",data:i}),a.runWebGPUProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t6e=pr({opType:vt.ROUND}),n6e={kernelName:py,backendName:"webgpu",kernelFunc:t6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r6e=pr({opType:vt.RSQRT,cpuKernelImpl:b4e}),s6e={kernelName:my,backendName:"webgpu",kernelFunc:r6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j1{constructor(e,t,r,s,i,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=Dt(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${l}_${i.length}`;const c=Ks(i.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",i="";this.dispatchLayout.x.length===1?(s="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,u)=>`coords[${u}]`).join(", ")})`;return`
    ${i}
      ${St("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${Mm(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?Mp("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i6e(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(i,s,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,s.dtype);const d=Kt({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=Kt({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=p.dtype,g=ya({backend:t,attrs:{shape:f,value:0,dtype:m}}),y=Te(p.shape),b=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[y]}],x=new j1(p.shape,a,d.shape.length,p.shape.length,u,f,m),w=t.runWebGPUProgram(x,[p,d],m,b,g),_=Kt({inputs:{x:w},backend:t,attrs:{shape:o}});return t.disposeData(d.dataId),t.disposeData(p.dataId),t.disposeData(w.dataId),_}const o6e={kernelName:E2,backendName:"webgpu",kernelFunc:i6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a6e{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${St("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6e(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new a6e([i.shape[0],i.shape[1]],o),l=[{type:"int32",data:[s.shape[1]]}];return t.runWebGPUProgram(a,[s,i],"int32",l)}const c6e={kernelName:A2,backendName:"webgpu",kernelFunc:l6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u6e{constructor(e,t,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${s[a]}`),a<this.cRank&&i.push(`${s[a]}`);e=i.join(),t=o.join()}return`
      ${St("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h6e(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new u6e(r.shape.length,s.shape,s.shape.length);return t.runWebGPUProgram(o,[r,s,i],Ii(s.dtype,i.dtype))}const f6e={kernelName:mw,backendName:"webgpu",kernelFunc:h6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d6e=pr({opType:vt.SELU}),p6e={kernelName:gy,backendName:"webgpu",kernelFunc:d6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m6e=pr({opType:vt.SIGMOID}),g6e={kernelName:wy,backendName:"webgpu",kernelFunc:m6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6e=pr({opType:vt.SIGN}),b6e={kernelName:vy,backendName:"webgpu",kernelFunc:y6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v6e=pr({opType:vt.SIN}),w6e={kernelName:yy,backendName:"webgpu",kernelFunc:v6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x6e=pr({opType:vt.SINH}),S6e={kernelName:by,backendName:"webgpu",kernelFunc:x6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _6e=pr({opType:vt.SOFTPLUS}),C6e={kernelName:xy,backendName:"webgpu",kernelFunc:_6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k6e{constructor(e,t,r,s,i,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let l=0;l<a.length;l++)a[l]=s[i[l]];this.outputShape=a,this.newDim=i,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Ks(s.length)}, paddedXShapeStrides : ${Ks(o)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Ks(this.outputShape.length),t=sQ(this.newDim);return`
      ${$E(this.paddedXShape,"PaddedX")}
      ${St("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${_Q(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T6e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=[[0,0]];l.push(...o);for(let b=1+i.length;b<s.shape.length;++b)l.push([0,0]);const c=l.map((b,x)=>b[0]+s.shape[x]+b[1]),u=Dy(c,i,a,!1),h=Oy(u.length,i.length,!1),f=Fy(c,i,a,!1),d=Jt(c),p=new k6e(s.shape,c,l,u,h,d.length),m=[{type:"int32",data:u},{type:"int32",data:d}];l.map(b=>m.push({type:"int32",data:[b[0],b[1]]}));const g=t.runWebGPUProgram(p,[s],s.dtype,m),y=Kt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeData(g.dataId),y},E6e={kernelName:bw,backendName:"webgpu",kernelFunc:T6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I6e{constructor(e,t,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=Dt([t]),this.dispatch=_t(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Mp("&result[outIndex]","value",this.type)}
      }
    }
  `}}class A6e{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Dt(t),this.dispatch=_t(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Mp("&result[segmentId]","1","int32")}
      }
    }
  `}}class M6e{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Dt(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CQ(n,e,t,r=!1,s){const o=Te(n.shape)/n.shape[0],a=n.dtype,l=Te(e.shape),c=s.readSync(t.dataId),h=l>0?c[l-1]+1:0;let f;const d=n.shape.slice();d[0]=h;const p=l*o,m=ya({backend:s,attrs:{shape:d,value:0,dtype:a}});f=new I6e(d,p,a);let g=[{type:"int32",data:[o]},{type:"int32",data:[p]}];const y=s.runWebGPUProgram(f,[n,e,t],a,g,m);if(r)return y;const b=ya({backend:s,attrs:{shape:[h],value:0,dtype:"int32"}});f=new A6e(h,t.shape);const x=s.runWebGPUProgram(f,[t],"int32",null,b),w=ya({backend:s,attrs:{shape:d,value:0,dtype:a}});f=new M6e(d,a),g=[{type:"int32",data:[o]}];const _=s.runWebGPUProgram(f,[y,x],a,g,w);return s.disposeData(y.dataId),s.disposeData(x.dataId),_}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N6e(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;return CQ(r,s,i,!1,t)}const $6e={kernelName:M2,backendName:"webgpu",kernelFunc:N6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6e(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;return CQ(r,s,i,!0,t)}const P6e={kernelName:N2,backendName:"webgpu",kernelFunc:R6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D6e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*t[s];this.outputShape=r,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=O6e(this.rank,"uniforms.");return`
      ${St("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function O6e(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n;s++)r.push(`(${t[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(t.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const l=t.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>kc(f)):l,u=wn(s.shape,s.dtype,c),h=k4e(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new D6e(s.shape,i);return t.runWebGPUProgram(o,[s],s.dtype)}const F6e={kernelName:Ey,backendName:"webgpu",kernelFunc:mB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L6e(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Fu(i,s,a),d=!1;if(i.dtype==="string"){const A=t.bufferSync(s),M=t.bufferSync(i),I=kc(t.readSync(o.dataId)[0]),N=v4e(A,M,a,f,u,c,l,h,I,d);return t.makeTensorInfo(a,N.dtype,N.values)}const p=[f/u,u],m=Kt({inputs:{x:s},backend:t,attrs:{shape:[c,l]}}),g=i.shape.length?Kt({inputs:{x:i},backend:t,attrs:{shape:[c,u]}}):ja({inputs:{x:i},backend:t}),y=g.dtype,b=t.makeTensorInfo([],y,Hi(1,y)),x=Kt({inputs:{x:o},backend:t,attrs:{shape:Array(p.length).fill(1)}}),w=mB({inputs:{x},backend:t,attrs:{reps:p}}),_=Te([c,u]),C=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[_]}];switch(c){case 0:break;case 1:{const A=new j1([c,u],l,m.shape.length,g.shape.length,h,p,y,d);t.runWebGPUProgram(A,[g,m],y,C,w)}break;default:{const A=new j1([c,u],l,m.shape.length,b.shape.length,h,p,y,d);t.runWebGPUProgram(A,[b,m],y,C,w)}{const A=new j1([c,u],l,m.shape.length,g.shape.length,h,p,y);t.runWebGPUProgram(A,[g,m],y,C,w)}}const k=Kt({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),k}const z6e={kernelName:$2,backendName:"webgpu",kernelFunc:L6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=Tn(o,s.shape)[0],l=SN(s,i,a),c=s.shape.length,u=new Array(c).fill(0),h=s.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=zw({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const V6e={kernelName:vw,backendName:"webgpu",kernelFunc:B6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U6e=pr({opType:vt.SQRT}),W6e={kernelName:Sy,backendName:"webgpu",kernelFunc:U6e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G6e={kernelName:R2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e,s=new Lw(t.shape,vt.SQUARE);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H6e=qi({opType:gn.SQUARED_DIFFERENCE}),j6e={kernelName:_y,backendName:"webgpu",kernelFunc:H6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q6e({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=new Lw(r.shape,vt.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(s,[r],r.dtype,i)}const X6e={kernelName:Iy,backendName:"webgpu",kernelFunc:q6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K6e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ks(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let s=0;t=this.outputShape.map((i,o)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${s-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${St("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=iN(s.shape,i,o,a,l,c,u,h,f);let _;if(m)_=Kt({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=sN(b,x,w),k=zw({inputs:{x:s},backend:t,attrs:{begin:b,size:C}});_=Kt({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeData(k.dataId)}else if(t.shouldExecuteOnCPU([s])){const k=t.readSync(s.dataId),A=wn(s.shape,s.dtype,k),M=S4e(d,A,w,b);_=t.makeTensorInfo(p,s.dtype,M.values)}else{const k=new K6e(d),A=[{type:"int32",data:b},{type:"int32",data:w}],M=t.runWebGPUProgram(k,[s],s.dtype,A);_=Kt({inputs:{x:M},backend:t,attrs:{shape:p}}),t.disposeData(M.dataId)}return _}const Z6e={kernelName:D2,backendName:"webgpu",kernelFunc:Y6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J6e(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=_4e(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const Q6e={kernelName:O2,backendName:"webgpu",kernelFunc:J6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e5e=qi({opType:gn.SUB,cpuKernelImpl:C4e,supportsComplex:!0}),t5e={kernelName:Cy,backendName:"webgpu",kernelFunc:e5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n5e=pr({opType:vt.TAN}),r5e={kernelName:ky,backendName:"webgpu",kernelFunc:n5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s5e=pr({opType:vt.TANH}),i5e={kernelName:Ty,backendName:"webgpu",kernelFunc:s5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5e(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(o,i,s.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const d=[],p=Kt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}});d.push(p);const m=Kt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}});d.push(m);const g=Kt({inputs:{x:s},backend:t,attrs:{shape:f}});d.push(g);const y=mB({inputs:{x:g},backend:t,attrs:{reps:Array(f.length).fill(1)}}),b=new j1([l,c],a,p.shape.length,m.shape.length,u,f,s.dtype,!1),x=Te([l,c]),w=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[x]}],_=t.runWebGPUProgram(b,[m,p],g.dtype,w,y);d.push(_);const C=Kt({inputs:{x:_},backend:t,attrs:{shape:s.shape}});return d.forEach(k=>t.disposeData(k.dataId)),C}const a5e={kernelName:I2,backendName:"webgpu",kernelFunc:o5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${St("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class c5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${St("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0(n,e){e!==null&&n.disposeData(e.dataId)}function eH(n){let e=1;for(;e<n;)e*=2;return e}function u5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=s.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([s])){const _=t.readSync(s.dataId),[C,k]=T4e(_,a,s.dtype,i,o);return[t.makeTensorInfo(C.shape,C.dtype,C.values),t.makeTensorInfo(k.shape,k.dtype,k.values)]}if(i===0)return a[a.length-1]=0,[t.makeTensorInfo(a,s.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[s,ya({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=Te(a)/l,h=Kt({inputs:{x:s},attrs:{shape:[u,l]},backend:t}),f=eH(i),d=eH(l);let p=null;const m=()=>p===null?[h,h]:[h,p],g=(_,C,k)=>{const A=m(),M=new l5e(k),N=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[_]},{type:"int32",data:[C]}],O=p;p=t.runWebGPUProgram(M,A,"int32",N),E0(t,O)};for(let _=1;_<f;_*=2){const C=_*2;for(let k=_;k>=1;k/=2)g(C,k,[u,d])}for(let _=d;_>f;_/=2){const C=m(),k=new c5e([u,_/2]),M=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"int32",data:[f]}],I=p;p=t.runWebGPUProgram(k,C,"int32",M),E0(t,I);const N=f/2,O=N*2;for(let R=N;R>=1;R/=2)g(O,R,p.shape)}let y=p;p=zw({inputs:{x:p},backend:t,attrs:{begin:0,size:[u,i]}}),E0(t,y);let b=vQ({inputs:{x:h,indices:p},backend:t,attrs:{axis:1,batchDims:1}});E0(t,h);const x=a.slice(0,-1);x.push(i),y=p,p=Kt({inputs:{x:p},attrs:{shape:x},backend:t}),E0(t,y);const w=b;return b=Kt({inputs:{x:b},attrs:{shape:x},backend:t}),E0(t,w),[b,p]}const h5e={kernelName:F2,backendName:"webgpu",kernelFunc:u5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f5e{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${St("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5e(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new f5e(g),b=o==="nearest"?1:2;let x;switch(a){case"constant":x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4;break;default:x=1;break}const w=[{type:"int32",data:[b]},{type:"int32",data:[x]},{type:"float32",data:[l]}];return t.runWebGPUProgram(y,[s,i],"float32",w)}const p5e={kernelName:L2,backendName:"webgpu",kernelFunc:d5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5e(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[i]=m;const g=zw({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=Kt({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeData(m.dataId)),p}const g5e={kernelName:xw,backendName:"webgpu",kernelFunc:m5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y5e{constructor(e,t,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Dt(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${St("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Mp("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Lr([c],a);let h=s;u!=null&&(h=Ch({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),c=rs(1,a)[0]);const f=qz(h.shape,c,o),d=Te([h.shape[c]]),p=Kt({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=s.dtype,g=[p.shape[0],o],y=ya({backend:t,attrs:{shape:g,value:0,dtype:m}}),b=new y5e(p.shape,g,m),x=[{type:"int32",data:[o]},{type:"int32",data:[Te(p.shape)]}],w=t.runWebGPUProgram(b,[p,i],m,x,y),_=Kt({inputs:{x:w},backend:t,attrs:{shape:f}});l.push(w);let C=_;if(u!=null){l.push(_);const k=Rh(u);C=Ch({inputs:{x:C},backend:t,attrs:{perm:k}})}return l.forEach(k=>t.disposeData(k.dataId)),C}const v5e={kernelName:Sw,backendName:"webgpu",kernelFunc:b5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w5e=[HBe,A4e,N4e,R4e,D4e,L4e,H4e,q4e,K4e,Z4e,Q4e,tVe,rVe,iVe,aVe,fVe,pVe,bVe,wVe,SVe,EVe,NVe,PVe,LVe,BVe,GVe,qBe,qVe,ZVe,iUe,hUe,mUe,bUe,wUe,SUe,CUe,TUe,AUe,NUe,RUe,DUe,LUe,HUe,qUe,VUe,YUe,QUe,rWe,iWe,lWe,fWe,pWe,gWe,bWe,wWe,SWe,_We,kWe,EWe,UBe,AWe,DWe,NWe,RWe,LWe,BWe,UWe,HWe,XWe,YWe,JWe,jBe,eGe,KVe,nGe,sGe,oGe,lGe,uGe,fGe,mGe,vGe,yGe,xGe,_Ge,kGe,AGe,$Ge,cVe,PGe,OGe,GGe,LGe,UGe,jGe,uVe,XGe,YGe,JGe,eHe,iHe,cWe,aHe,cHe,hHe,DVe,pHe,gHe,bHe,xHe,_He,kHe,EHe,AHe,OVe,NHe,RHe,DHe,FHe,WBe,BHe,WHe,jHe,KHe,JHe,e6e,n6e,s6e,o6e,c6e,f6e,p6e,g6e,b6e,w6e,S6e,kVe,X6e,Z6e,Q6e,rHe,C6e,E6e,$6e,P6e,z6e,V6e,W6e,G6e,j6e,t5e,uWe,r5e,i5e,a5e,F6e,h5e,p5e,V4e,g5e,v5e,mHe];for(const n of w5e)B2(n);function PD(n){"@babel/helpers - typeof";return PD=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},PD(n)}function Lu(n,e){if(e.length<n)throw new TypeError(n+" argument"+(n>1?"s":"")+" required, but only "+e.length+" present")}function Ho(n){Lu(1,arguments);var e=Object.prototype.toString.call(n);return n instanceof Date||PD(n)==="object"&&e==="[object Date]"?new Date(n.getTime()):typeof n=="number"||e==="[object Number]"?new Date(n):((typeof n=="string"||e==="[object String]")&&typeof console<"u"&&(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn(new Error().stack)),new Date(NaN))}var x5e={};function S5e(){return x5e}function tH(n){var e=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds(),n.getMilliseconds()));return e.setUTCFullYear(n.getFullYear()),n.getTime()-e.getTime()}function RE(n,e){Lu(2,arguments);var t=Ho(n),r=Ho(e),s=t.getTime()-r.getTime();return s<0?-1:s>0?1:s}function _5e(n,e){Lu(2,arguments);var t=Ho(n),r=Ho(e),s=t.getFullYear()-r.getFullYear(),i=t.getMonth()-r.getMonth();return s*12+i}function C5e(n,e){return Lu(2,arguments),Ho(n).getTime()-Ho(e).getTime()}var nH={ceil:Math.ceil,round:Math.round,floor:Math.floor,trunc:function(e){return e<0?Math.ceil(e):Math.floor(e)}},k5e="trunc";function T5e(n){return n?nH[n]:nH[k5e]}function E5e(n){Lu(1,arguments);var e=Ho(n);return e.setHours(23,59,59,999),e}function I5e(n){Lu(1,arguments);var e=Ho(n),t=e.getMonth();return e.setFullYear(e.getFullYear(),t+1,0),e.setHours(23,59,59,999),e}function A5e(n){Lu(1,arguments);var e=Ho(n);return E5e(e).getTime()===I5e(e).getTime()}function M5e(n,e){Lu(2,arguments);var t=Ho(n),r=Ho(e),s=RE(t,r),i=Math.abs(_5e(t,r)),o;if(i<1)o=0;else{t.getMonth()===1&&t.getDate()>27&&t.setDate(30),t.setMonth(t.getMonth()-s*i);var a=RE(t,r)===-s;A5e(Ho(n))&&i===1&&RE(n,r)===1&&(a=!1),o=s*(i-Number(a))}return o===0?0:o}function N5e(n,e,t){Lu(2,arguments);var r=C5e(n,e)/1e3;return T5e(t==null?void 0:t.roundingMethod)(r)}var $5e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}},R5e=function(e,t,r){var s,i=$5e[e];return typeof i=="string"?s=i:t===1?s=i.one:s=i.other.replace("{{count}}",t.toString()),r!=null&&r.addSuffix?r.comparison&&r.comparison>0?"in "+s:s+" ago":s};const P5e=R5e;function c3(n){return function(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=e.width?String(e.width):n.defaultWidth,r=n.formats[t]||n.formats[n.defaultWidth];return r}}var D5e={full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},O5e={full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},F5e={full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},L5e={date:c3({formats:D5e,defaultWidth:"full"}),time:c3({formats:O5e,defaultWidth:"full"}),dateTime:c3({formats:F5e,defaultWidth:"full"})};const z5e=L5e;var B5e={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"},V5e=function(e,t,r,s){return B5e[e]};const U5e=V5e;function zx(n){return function(e,t){var r=t!=null&&t.context?String(t.context):"standalone",s;if(r==="formatting"&&n.formattingValues){var i=n.defaultFormattingWidth||n.defaultWidth,o=t!=null&&t.width?String(t.width):i;s=n.formattingValues[o]||n.formattingValues[i]}else{var a=n.defaultWidth,l=t!=null&&t.width?String(t.width):n.defaultWidth;s=n.values[l]||n.values[a]}var c=n.argumentCallback?n.argumentCallback(e):e;return s[c]}}var W5e={narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},G5e={narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},H5e={narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},j5e={narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},q5e={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},X5e={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},K5e=function(e,t){var r=Number(e),s=r%100;if(s>20||s<10)switch(s%10){case 1:return r+"st";case 2:return r+"nd";case 3:return r+"rd"}return r+"th"},Y5e={ordinalNumber:K5e,era:zx({values:W5e,defaultWidth:"wide"}),quarter:zx({values:G5e,defaultWidth:"wide",argumentCallback:function(e){return e-1}}),month:zx({values:H5e,defaultWidth:"wide"}),day:zx({values:j5e,defaultWidth:"wide"}),dayPeriod:zx({values:q5e,defaultWidth:"wide",formattingValues:X5e,defaultFormattingWidth:"wide"})};const Z5e=Y5e;function Bx(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=t.width,s=r&&n.matchPatterns[r]||n.matchPatterns[n.defaultMatchWidth],i=e.match(s);if(!i)return null;var o=i[0],a=r&&n.parsePatterns[r]||n.parsePatterns[n.defaultParseWidth],l=Array.isArray(a)?Q5e(a,function(h){return h.test(o)}):J5e(a,function(h){return h.test(o)}),c;c=n.valueCallback?n.valueCallback(l):l,c=t.valueCallback?t.valueCallback(c):c;var u=e.slice(o.length);return{value:c,rest:u}}}function J5e(n,e){for(var t in n)if(n.hasOwnProperty(t)&&e(n[t]))return t}function Q5e(n,e){for(var t=0;t<n.length;t++)if(e(n[t]))return t}function eje(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=e.match(n.matchPattern);if(!r)return null;var s=r[0],i=e.match(n.parsePattern);if(!i)return null;var o=n.valueCallback?n.valueCallback(i[0]):i[0];o=t.valueCallback?t.valueCallback(o):o;var a=e.slice(s.length);return{value:o,rest:a}}}var tje=/^(\d+)(th|st|nd|rd)?/i,nje=/\d+/i,rje={narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},sje={any:[/^b/i,/^(a|c)/i]},ije={narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},oje={any:[/1/i,/2/i,/3/i,/4/i]},aje={narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},lje={narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},cje={narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},uje={narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},hje={narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},fje={any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},dje={ordinalNumber:eje({matchPattern:tje,parsePattern:nje,valueCallback:function(e){return parseInt(e,10)}}),era:Bx({matchPatterns:rje,defaultMatchWidth:"wide",parsePatterns:sje,defaultParseWidth:"any"}),quarter:Bx({matchPatterns:ije,defaultMatchWidth:"wide",parsePatterns:oje,defaultParseWidth:"any",valueCallback:function(e){return e+1}}),month:Bx({matchPatterns:aje,defaultMatchWidth:"wide",parsePatterns:lje,defaultParseWidth:"any"}),day:Bx({matchPatterns:cje,defaultMatchWidth:"wide",parsePatterns:uje,defaultParseWidth:"any"}),dayPeriod:Bx({matchPatterns:hje,defaultMatchWidth:"any",parsePatterns:fje,defaultParseWidth:"any"})};const pje=dje;var mje={code:"en-US",formatDistance:P5e,formatLong:z5e,formatRelative:U5e,localize:Z5e,match:pje,options:{weekStartsOn:0,firstWeekContainsDate:1}};const gje=mje;function kQ(n,e){if(n==null)throw new TypeError("assign requires that input parameter not be null or undefined");for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function yje(n){return kQ({},n)}var rH=1440,bje=2520,u3=43200,vje=86400;function wje(n,e,t){var r,s;Lu(2,arguments);var i=S5e(),o=(r=(s=t==null?void 0:t.locale)!==null&&s!==void 0?s:i.locale)!==null&&r!==void 0?r:gje;if(!o.formatDistance)throw new RangeError("locale must contain formatDistance property");var a=RE(n,e);if(isNaN(a))throw new RangeError("Invalid time value");var l=kQ(yje(t),{addSuffix:!!(t!=null&&t.addSuffix),comparison:a}),c,u;a>0?(c=Ho(e),u=Ho(n)):(c=Ho(n),u=Ho(e));var h=N5e(u,c),f=(tH(u)-tH(c))/1e3,d=Math.round((h-f)/60),p;if(d<2)return t!=null&&t.includeSeconds?h<5?o.formatDistance("lessThanXSeconds",5,l):h<10?o.formatDistance("lessThanXSeconds",10,l):h<20?o.formatDistance("lessThanXSeconds",20,l):h<40?o.formatDistance("halfAMinute",0,l):h<60?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",1,l):d===0?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",d,l);if(d<45)return o.formatDistance("xMinutes",d,l);if(d<90)return o.formatDistance("aboutXHours",1,l);if(d<rH){var m=Math.round(d/60);return o.formatDistance("aboutXHours",m,l)}else{if(d<bje)return o.formatDistance("xDays",1,l);if(d<u3){var g=Math.round(d/rH);return o.formatDistance("xDays",g,l)}else if(d<vje)return p=Math.round(d/u3),o.formatDistance("aboutXMonths",p,l)}if(p=M5e(u,c),p<12){var y=Math.round(d/u3);return o.formatDistance("xMonths",y,l)}else{var b=p%12,x=Math.floor(p/12);return b<3?o.formatDistance("aboutXYears",x,l):b<9?o.formatDistance("overXYears",x,l):o.formatDistance("almostXYears",x+1,l)}}function xje(n,e){return Lu(1,arguments),wje(n,Date.now(),e)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function TQ(n,e){for(var t=e.length,r=new Array(t+1),s=0;s<t;++s)r[s]=e[s];return r[t]=n,r}function Sje(n,e){var t=n.length,r=e.length,s=new Array(t+r),i=0;for(i=0;i<t;i++)s[i]=n[i];for(var o=0;o<r;o++)s[i++]=e[o];return s}function _je(n,e){for(var t=e.length,r=new Array(t),s=0;s<t;++s)r[s]=n(e[s]);return r}function DN(n,e,t){for(var r=e,s=0,i=t.length;s<i;++s)r=n(r,t[s],s);return r}function Cje(n,e){if(n<0)throw new TypeError("i must be >= 0");var t=e.length;return t===0||n>=t?e:t===1?[]:kje(n,e,t-1)}function kje(n,e,t){var r=new Array(t),s;for(s=0;s<n;++s)r[s]=e[s];for(s=n;s<t;++s)r[s]=e[s+1];return r}function Tje(n,e){for(var t=e.length,r=new Array(t),s=0,i=void 0,o=0;o<t;++o)i=e[o],n(i)||(r[s]=i,++s);return r.length=s,r}function EQ(n,e){for(var t=0,r=e.length;t<r;++t)if(n===e[t])return t;return-1}/** @license MIT License (c) copyright 2010-2016 original author or authors */var Eje=function(n){return n},Ije=function(n,e){return function(t){return n(e(t))}},Aje=function(n,e){return n(e)};function kr(n){function e(t,r){switch(arguments.length){case 0:return e;case 1:return function(s){return n(t,s)};default:return n(t,r)}}return e}function zu(n){function e(t,r,s){switch(arguments.length){case 0:return e;case 1:return kr(function(i,o){return n(t,i,o)});case 2:return function(i){return n(t,r,i)};default:return n(t,r,s)}}return e}var Mje=function(){function n(e,t,r,s,i){this.time=e,this.localOffset=t,this.period=r,this.task=s,this.scheduler=i,this.active=!0}return n.prototype.run=function(){return this.task.run(this.time-this.localOffset)},n.prototype.error=function(e){return this.task.error(this.time-this.localOffset,e)},n.prototype.dispose=function(){return this.active=!1,this.scheduler.cancel(this),this.task.dispose()},n}(),IQ=function(){function n(e,t){this.origin=e,this.scheduler=t}return n.prototype.currentTime=function(){return this.scheduler.currentTime()-this.origin},n.prototype.scheduleTask=function(e,t,r,s){return this.scheduler.scheduleTask(e+this.origin,t,r,s)},n.prototype.relative=function(e){return new n(e+this.origin,this.scheduler)},n.prototype.cancel=function(e){return this.scheduler.cancel(e)},n.prototype.cancelAll=function(e){return this.scheduler.cancelAll(e)},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var Nje=function(n){return Promise.resolve(n).then(AQ)};function AQ(n){try{return n.run()}catch(e){return n.error(e)}}/** @license MIT License (c) copyright 2010-2017 original author or authors */var $je=function(){function n(e,t){var r=this;this._runReadyTasksBound=function(){return r._runReadyTasks()},this.timer=e,this.timeline=t,this._timer=null,this._nextArrival=1/0}return n.prototype.currentTime=function(){return this.timer.now()},n.prototype.scheduleTask=function(e,t,r,s){var i=this.currentTime()+Math.max(0,t),o=new Mje(i,e,r,s,this);return this.timeline.add(o),this._scheduleNextRun(),o},n.prototype.relative=function(e){return new IQ(e,this)},n.prototype.cancel=function(e){e.active=!1,this.timeline.remove(e)&&this._reschedule()},n.prototype.cancelAll=function(e){this.timeline.removeAll(e),this._reschedule()},n.prototype._reschedule=function(){this.timeline.isEmpty()?this._unschedule():this._scheduleNextRun()},n.prototype._unschedule=function(){this.timer.clearTimer(this._timer),this._timer=null},n.prototype._scheduleNextRun=function(){if(!this.timeline.isEmpty()){var e=this.timeline.nextArrival();this._timer===null?this._scheduleNextArrival(e):e<this._nextArrival&&(this._unschedule(),this._scheduleNextArrival(e))}},n.prototype._scheduleNextArrival=function(e){this._nextArrival=e;var t=Math.max(0,e-this.currentTime());this._timer=this.timer.setTimer(this._runReadyTasksBound,t)},n.prototype._runReadyTasks=function(){this._timer=null,this.timeline.runTasks(this.currentTime(),AQ),this._scheduleNextRun()},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var Rje=function(){function n(){this.tasks=[]}return n.prototype.nextArrival=function(){return this.isEmpty()?1/0:this.tasks[0].time},n.prototype.isEmpty=function(){return this.tasks.length===0},n.prototype.add=function(e){MQ(e,this.tasks)},n.prototype.remove=function(e){var t=$Q(NQ(e),this.tasks);if(t>=0&&t<this.tasks.length){var r=this.tasks[t].events,s=EQ(e,r);if(s>=0)return r.splice(s,1),r.length===0&&this.tasks.splice(t,1),!0}return!1},n.prototype.removeAll=function(e){for(var t=0;t<this.tasks.length;++t)Lje(e,this.tasks[t])},n.prototype.runTasks=function(e,t){for(var r=this.tasks,s=r.length,i=0;i<s&&r[i].time<=e;)++i;this.tasks=r.slice(i);for(var o=0;o<i;++o)this.tasks=Pje(t,r[o].events,this.tasks)},n}();function Pje(n,e,t){for(var r=0;r<e.length;++r){var s=e[r];s.active&&(n(s),s.period>=0&&s.active&&(s.time=s.time+s.period,MQ(s,t)))}return t}function MQ(n,e){var t=e.length,r=NQ(n);if(t===0){e.push(DD(r,[n]));return}var s=$Q(r,e);s>=t?e.push(DD(r,[n])):Dje(n,e,r,s)}function Dje(n,e,t,r){var s=e[r];t===s.time?Oje(n,s.events):e.splice(r,0,DD(t,[n]))}function Oje(n,e){e.length===0||n.time>=e[e.length-1].time?e.push(n):Fje(n,e)}function Fje(n,e){for(var t=0;t<e.length;t++)if(n.time<e[t].time){e.splice(t,0,n);break}}function NQ(n){return Math.floor(n.time)}function Lje(n,e){e.events=Tje(n,e.events)}function $Q(n,e){for(var t=0,r=e.length,s,i;t<r;){if(s=Math.floor((t+r)/2),i=e[s],n===i.time)return s;n<i.time?r=s:t=s+1}return r}var DD=function(n,e){return{time:n,events:e}};/** @license MIT License (c) copyright 2010-2017 original author or authors */var zje=function(){function n(e){this._clock=e}return n.prototype.now=function(){return this._clock.now()},n.prototype.setTimer=function(e,t){return t<=0?Bje(e):setTimeout(e,t)},n.prototype.clearTimer=function(e){return e instanceof RQ?e.cancel():clearTimeout(e)},n}(),RQ=function(){function n(e){this.f=e,this.active=!0}return n.prototype.run=function(){if(this.active)return this.f()},n.prototype.error=function(e){throw e},n.prototype.cancel=function(){this.active=!1},n}();function Bje(n){var e=new RQ(n);return Nje(e),e}var Vje=function(){function n(e,t){this.origin=t,this.clock=e}return n.prototype.now=function(){return this.clock.now()-this.origin},n}(),Uje=function(){function n(e,t){this.origin=t,this.hrtime=e}return n.prototype.now=function(){var e=this.hrtime(this.origin);return(e[0]*1e9+e[1])/1e6},n}(),PQ=function(n){return new Vje(n,n.now())},Wje=function(){return PQ(performance)},Gje=function(){return PQ(Date)},Hje=function(){return new Uje(process.hrtime,process.hrtime())},jje=function(){return typeof performance<"u"&&typeof performance.now=="function"?Wje():typeof process<"u"&&typeof process.hrtime=="function"?Hje():Gje()},PE=function(n){return n.currentTime()},ON=kr(function(n,e){return e.scheduleTask(0,0,-1,n)}),FI=zu(function(n,e,t){return t.scheduleTask(0,n,-1,e)}),qje=zu(function(n,e,t){return t.scheduleTask(0,0,n,e)}),Xje=function(n){return n.dispose()},gB=kr(function(n,e){return new IQ(n,e)}),Kje=function(){return new $je(Yje(),new Rje)},Yje=function(){return new zje(jje())},IS=function(){return DQ},DQ=new(function(){function n(){}return n.prototype.dispose=function(){},n}()),Zje=function(n){return n===DQ},yB=function(n){return new Jje(n)},Jje=function(){function n(e){this.disposed=!1,this.disposable=e}return n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable&&(this.disposable.dispose(),this.disposable=void 0))},n}();/** @license MIT License (c) copyright 2010 original author or authors */var gC=function(n){var e=DN(Qje,[],n);return e.length===0?IS():new OQ(e)},Bw=kr(function(n,e){return gC([n,e])}),Qje=function(n,e){return Zje(e)?n:e instanceof OQ?Sje(n,e.disposables):TQ(e,n)},OQ=function(){function n(e){this.disposables=e}return n.prototype.dispose=function(){n8e(e8e(this.disposables))},n}(),e8e=function(n){return DN(t8e,[],n)},t8e=function(n,e){try{e.dispose()}catch(t){n.push(t)}return n},n8e=function(n){if(n.length>0)throw new FQ(n.length+" errors",n)},FQ=function(){function n(e,t){this.name="DisposeAllError",this.message=e,this.errors=t,Error.call(this,e),Error.captureStackTrace&&Error.captureStackTrace(this,n),this.stack=""+this.stack+r8e(this.errors)}return n}();FQ.prototype=Object.create(Error.prototype);var r8e=function(n){return DN(s8e,"",n)},s8e=function(n,e,t){return n+(`
[`+(t+1)+"] "+e.stack)};/** @license MIT License (c) copyright 2010-2017 original author or authors */var hg=zu(function(n,e,t){try{e.dispose()}catch(r){t.error(n,r)}});/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var OD=function(n,e){return OD=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])},OD(n,e)};function Yr(n,e){OD(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function LQ(n){setTimeout(i8e,0,n)}function i8e(n){throw n}/** @license MIT License (c) copyright 2010-2016 original author or authors */var o8e=function(n,e,t){return new l8e(n,e,t)},bB=function(n,e){return new c8e(n,e)},zQ=function(n){return new u8e(n)},a8e=function(n,e){return new h8e(n,e)},FN=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.dispose=function(){this.active=!1},n.prototype.run=function(e){this.active&&this.runIfActive(e)},n.prototype.error=function(e,t){if(!this.active)return LQ(t);this.sink.error(e,t)},n}(),l8e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.runEvent=t,i.value=r,i}return e.prototype.runIfActive=function(t){this.runEvent(t,this.value,this.sink)},e}(FN),c8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.value=t,s}return e.prototype.runIfActive=function(t){this.sink.event(t,this.value)},e}(FN),u8e=function(n){Yr(e,n);function e(){return n!==null&&n.apply(this,arguments)||this}return e.prototype.runIfActive=function(t){this.sink.end(t)},e}(FN),h8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.value=t,s}return e.prototype.runIfActive=function(t){this.sink.error(t,this.value)},e}(FN);/** @license MIT License (c) copyright 2010-2017 original author or authors */var Xi=function(){return VQ},Ai=function(n){return n===VQ},BQ=function(n){return n.some(Ai)},f8e=function(){function n(){}return n.prototype.run=function(e,t){return ON(zQ(e),t)},n}(),VQ=new f8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var AS=function(){return p8e},d8e=function(){function n(){}return n.prototype.run=function(){return IS()},n}(),p8e=new d8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var UQ=function(n,e){return new m8e(n,e)},m8e=function(){function n(e,t){this.time=e,this.value=t}return n.prototype.run=function(e,t){return FI(this.time,o8e(g8e,this.value,e),t)},n}();function g8e(n,e,t){t.event(n,e),t.end(n)}/** @license MIT License (c) copyright 2010-2017 original author or authors */var FD=function(n){return UQ(0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var y8e=function(n){return new b8e(n)},b8e=function(){function n(e){this.period=e}return n.prototype.run=function(e,t){return qje(this.period,bB(void 0,e),t)},n}(),LN=function(){function n(){this.disposable=void 0,this.disposed=!1}return n.prototype.setDisposable=function(e){if(this.disposable!==void 0)throw new Error("setDisposable called more than once");this.disposable=e,this.disposed&&e.dispose()},n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable!==void 0&&this.disposable.dispose())},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var v8e=kr(function(n,e){return new Promise(function(t,r){return w8e(n,e,t,r)})});function w8e(n,e,t,r){var s=new LN,i=new x8e(t,r,s);s.setDisposable(n.run(i,e))}var x8e=function(){function n(e,t,r){this._end=e,this._error=t,this._disposable=r,this.active=!0}return n.prototype.event=function(){},n.prototype.end=function(){this.active&&this.dispose(this._error,this._end,void 0)},n.prototype.error=function(e,t){this.dispose(this._error,this._error,t)},n.prototype.dispose=function(e,t,r){this.active=!1,S8e(e,t,r,this._disposable)},n}();function S8e(n,e,t,r){try{r.dispose()}catch(s){n(s);return}e(t)}var WQ=function(n,e,t){return t.run(n,e)},h3=function(){function n(e,t){this.sink=t,this.offset=e}return n.prototype.event=function(e,t){this.sink.event(e+this.offset,t)},n.prototype.error=function(e,t){this.sink.error(e+this.offset,t)},n.prototype.end=function(e){this.sink.end(e+this.offset)},n}(),vB=function(n,e){return new _8e(n,e)},_8e=function(){function n(e,t){this.origin=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(C8e(this.origin,e),gB(this.origin,t))},n}(),C8e=function(n,e){return e instanceof h3?new h3(n+e.offset,e.sink):new h3(n,e)},As=function(){function n(e){this.sink=e}return n.prototype.end=function(e){return this.sink.end(e)},n.prototype.error=function(e,t){return this.sink.error(e,t)},n}();/** @license MIT License (c) copyright 2010 original author or authors */var k8e=function(n,e,t){return Ai(t)?Xi():new T8e(n,e,t)},T8e=function(){function n(e,t,r){this.step=e,this.seed=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new E8e(this.step,this.seed,e),t)},n}(),E8e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.step=t,i.seed=r,i}return e.prototype.event=function(t,r){var s=this.step(this.seed,r);this.seed=s.seed,this.sink.event(t,s.value)},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */var I8e=function(n,e,t){return new A8e(n,e,t)},A8e=function(){function n(e,t,r){this.source=r,this.f=e,this.value=t}return n.prototype.run=function(e,t){var r=ON(bB(this.value,e),t),s=this.source.run(new M8e(this.f,this.value,e),t);return Bw(r,s)},n}(),M8e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.f=t,i.value=r,i}return e.prototype.event=function(t,r){var s=this.f;this.value=s(this.value,r),this.sink.event(t,this.value)},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */var GQ=function(n,e){return new N8e(n,e)},N8e=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new $8e(this.f,this.source,e,t)},n}(),$8e=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.f=t,o.scheduler=i,o.active=!0,o.disposable=yB(r.run(o,i)),o}return e.prototype.event=function(t,r){this.active&&this.sink.event(t,r)},e.prototype.end=function(t){this.active&&(hg(t,this.disposable,this.sink),this.startNext(t,this.sink))},e.prototype.startNext=function(t,r){try{this.disposable=this.continue(this.f,t,r)}catch(s){r.error(t,s)}},e.prototype.continue=function(t,r,s){return WQ(s,this.scheduler,vB(r,t()))},e.prototype.dispose=function(){return this.active=!1,this.disposable.dispose()},e}(As);/** @license MIT License (c) copyright 2010-2017 original author or authors */var R8e=function(n,e){return GQ(function(){return e},FD(n))};/** @license MIT License (c) copyright 2010-2016 original author or authors */var HQ=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new P8e(this.p,e),t)},n.create=function(e,t){return Ai(t)?t:t instanceof n?new n(D8e(t.p,e),t.source):new n(e,t)},n}(),P8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s}return e.prototype.event=function(t,r){var s=this.p;s(r)&&this.sink.event(t,r)},e}(As),D8e=function(n,e){return function(t){return n(t)&&e(t)}};/** @license MIT License (c) copyright 2010-2016 original author or authors */var O8e=function(){function n(e,t,r){this.p=e,this.f=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new F8e(this.p,this.f,e),t)},n}(),F8e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.p=t,i.f=r,i}return e.prototype.event=function(t,r){var s=this.f,i=this.p;i(r)&&this.sink.event(t,s(r))},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */var yC=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new L8e(this.f,e),t)},n.create=function(e,t){return Ai(t)?Xi():t instanceof n?new n(Ije(e,t.f),t.source):t instanceof HQ?new O8e(t.p,e,t.source):new n(e,t)},n}(),L8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s}return e.prototype.event=function(t,r){var s=this.f;this.sink.event(t,s(r))},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */var zN=function(n,e){return yC.create(n,e)},z8e=function(n,e){return zN(function(){return n},e)},B8e=function(n,e){return new V8e(n,e)},V8e=function(){function n(e,t){this.source=t,this.f=e}return n.prototype.run=function(e,t){return this.source.run(new U8e(this.f,e),t)},n}(),U8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s}return e.prototype.event=function(t,r){var s=this.f;s(r),this.sink.event(t,r)},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */var wB=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.index=t,s.active=!0,s.value=void 0,s}return e.prototype.event=function(t,r){this.active&&(this.value=r,this.sink.event(t,this))},e.prototype.end=function(t){this.active&&(this.active=!1,this.sink.event(t,this))},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */function jQ(n,e){switch(e.length){case 0:return n();case 1:return n(e[0]);case 2:return n(e[0],e[1]);case 3:return n(e[0],e[1],e[2]);case 4:return n(e[0],e[1],e[2],e[3]);case 5:return n(e[0],e[1],e[2],e[3],e[4]);default:return n.apply(void 0,e)}}/** @license MIT License (c) copyright 2010 original author or authors */var qQ=function(n,e,t){return W8e(n,[e,t])},W8e=function(n,e){return e.length===0||BQ(e)?Xi():e.length===1?zN(n,e[0]):new G8e(n,e)},G8e=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new H8e(s,i.length,e,this.f),a=void 0,l=0;l<r;++l)a=i[l]=new wB(l,o),s[l]=this.sources[l].run(a,t);return gC(s)},n}(),H8e=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.disposables=t,o.f=i,o.awaiting=r,o.values=new Array(r),o.hasValue=new Array(r).fill(!1),o.activeCount=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var s=r.index,i=this.updateReady(s);this.values[s]=r.value,i===0&&this.sink.event(t,jQ(this.f,this.values))},e.prototype.updateReady=function(t){return this.awaiting>0&&(this.hasValue[t]||(this.hasValue[t]=!0,this.awaiting-=1)),this.awaiting},e.prototype.dispose=function(t,r){hg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */function j8e(n,e){return qQ(Aje,n,e)}/** @license MIT License (c) copyright 2010 original author or authors */var XQ=function(n,e){return BN(Eje,n,e)},BN=function(n,e,t){return Ai(t)?Xi():new q8e(n,e,t)},q8e=function(){function n(e,t,r){this.f=e,this.concurrency=t,this.source=r}return n.prototype.run=function(e,t){return new K8e(this.f,this.concurrency,this.source,e,t)},n}(),X8e=function(n){return n.length>0},K8e=function(){function n(e,t,r,s,i){this.f=e,this.concurrency=t,this.sink=s,this.scheduler=i,this.pending=[],this.current=[],this.disposable=yB(r.run(this,i)),this.active=!0}return n.prototype.event=function(e,t){this.addInner(e,t)},n.prototype.addInner=function(e,t){this.current.length<this.concurrency?this.startInner(e,t):this.pending.push(t)},n.prototype.startInner=function(e,t){try{this.initInner(e,t)}catch(r){this.error(e,r)}},n.prototype.initInner=function(e,t){var r=new Z8e(e,this,this.sink);r.disposable=Y8e(this.f,e,t,r,this.scheduler),this.current.push(r)},n.prototype.end=function(e){this.active=!1,hg(e,this.disposable,this.sink),this.checkEnd(e)},n.prototype.error=function(e,t){this.active=!1,this.sink.error(e,t)},n.prototype.dispose=function(){this.active=!1,this.pending.length=0,this.disposable.dispose(),gC(this.current).dispose()},n.prototype.endInner=function(e,t){var r=this.current.indexOf(t);r>=0&&this.current.splice(r,1),hg(e,t,this);var s=this.pending;X8e(s)?this.startInner(e,s.shift()):this.checkEnd(e)},n.prototype.checkEnd=function(e){!this.active&&this.current.length===0&&this.sink.end(e)},n}(),Y8e=function(n,e,t,r,s){return n(t).run(r,gB(e,s))},Z8e=function(){function n(e,t,r){this.time=e,this.outer=t,this.sink=r,this.disposable=IS()}return n.prototype.event=function(e,t){this.sink.event(e+this.time,t)},n.prototype.end=function(e){this.outer.endInner(e+this.time,this)},n.prototype.error=function(e,t){this.outer.error(e+this.time,t)},n.prototype.dispose=function(){return this.disposable.dispose()},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var J8e=function(n,e){return BN(n,1/0,e)},KQ=function(n){return XQ(1/0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var Q8e=function(n,e){return BN(n,1,e)};/** @license MIT License (c) copyright 2010-2016 original author or authors */function eqe(n,e){return tqe([n,e])}var tqe=function(n){return nqe(rqe(n))},nqe=function(n){return n.length===0?Xi():n.length===1?n[0]:new YQ(DN(iqe,[],n))},rqe=function(n){return n.filter(sqe)},sqe=function(n){return!Ai(n)},iqe=function(n,e){return n.concat(e instanceof YQ?e.sources:e)},YQ=function(){function n(e){this.sources=e}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new oqe(s,i,e),a=void 0,l=0;l<r;++l)a=i[l]=new wB(l,o),s[l]=this.sources[l].run(a,t);return gC(s)},n}(),oqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.disposables=t,i.activeCount=r.length,i}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}this.sink.event(t,r.value)},e.prototype.dispose=function(t,r){hg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(As);/** @license MIT License (c) copyright 2010 original author or authors */var aqe=function(n,e){return ZQ(function(t){return t},n,e)},ZQ=function(n,e,t){return Ai(t)||Ai(e)?Xi():new lqe(n,e,t)},lqe=function(){function n(e,t,r){this.f=e,this.values=t,this.sampler=r}return n.prototype.run=function(e,t){var r=new cqe(this.f,e),s=this.values.run(r.latest,t),i=this.sampler.run(r,t);return Bw(i,s)},n}(),cqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s.latest=new uqe(s),s}return e.prototype.event=function(t,r){if(this.latest.hasValue){var s=this.f;this.sink.event(t,s(this.latest.value,r))}},e}(As),uqe=function(n){Yr(e,n);function e(t){var r=n.call(this,t)||this;return r.hasValue=!1,r}return e.prototype.event=function(t,r){this.value=r,this.hasValue=!0},e.prototype.end=function(){},e}(As);/** @license MIT License (c) copyright 2010 original author or authors */var JQ=function(n,e){var t=Math.max(0,n),r=Math.max(t,e);return{min:t,max:r}},hqe=function(n,e){return JQ(n.min+e.min,Math.min(n.max,n.min+e.max))},fqe=function(n){return n.min>=n.max},dqe=function(n){return n.min<=0&&n.max===1/0},QQ=function(n,e){return xB(0,n,e)},pqe=function(n,e){return xB(n,1/0,e)},xB=function(n,e,t){return SB(JQ(n,e),t)},SB=function(n,e){return mqe(n,e)?Xi():e instanceof yC?yqe(n,e):e instanceof eee?bqe(n,e):gqe(n,e)},mqe=function(n,e){return Ai(e)||fqe(n)},gqe=function(n,e){return dqe(n)?e:new eee(n,e)},yqe=function(n,e){return yC.create(e.f,SB(n,e.source))},bqe=function(n,e){return SB(hqe(e.bounds,n),e.source)},eee=function(){function n(e,t){this.source=t,this.bounds=e}return n.prototype.run=function(e,t){var r=new LN,s=new vqe(this.bounds.min,this.bounds.max-this.bounds.min,e,r);return r.setDisposable(this.source.run(s,t)),r},n}(),vqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.skip=t,o.take=r,o.disposable=i,o}return e.prototype.event=function(t,r){if(this.skip>0){this.skip-=1;return}this.take!==0&&(this.take-=1,this.sink.event(t,r),this.take===0&&(this.disposable.dispose(),this.sink.end(t)))},e}(As),wqe=function(n,e){return Ai(e)?Xi():new xqe(n,e)},xqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){var r=new LN,s=new Sqe(this.p,e,r);return r.setDisposable(this.source.run(s,t)),r},n}(),Sqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.p=t,i.active=!0,i.disposable=s,i}return e.prototype.event=function(t,r){if(this.active){var s=this.p;this.active=s(r),this.active?this.sink.event(t,r):(this.disposable.dispose(),this.sink.end(t))}},e}(As),_qe=function(n,e){return Ai(e)?Xi():new Cqe(n,e)},Cqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new kqe(this.p,e),t)},n}(),kqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s.skipping=!0,s}return e.prototype.event=function(t,r){if(this.skipping){var s=this.p;if(this.skipping=s(r),this.skipping)return}this.sink.event(t,r)},e}(As),Tqe=function(n,e){return Ai(e)?Xi():new Eqe(n,e)},Eqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new Iqe(this.p,e),t)},n}(),Iqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s.skipping=!1,s}return e.prototype.event=function(t,r){if(!this.skipping){var s=this.p;this.skipping=s(r),this.sink.event(t,r),this.skipping&&this.sink.end(t)}},e}(As);/** @license MIT License (c) copyright 2017 original author or authors */var Aqe=function(n,e){return tee(Mqe,n,e)},tee=function(n,e,t){return Ai(t)||e.length===0?Xi():new Nqe(n,e,QQ(e.length,t))},Mqe=function(n){return n},Nqe=function(){function n(e,t,r){this.f=e,this.items=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new $qe(this.f,this.items,e),t)},n}(),$qe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.f=t,i.items=r,i.index=0,i}return e.prototype.event=function(t,r){var s=this.f;this.sink.event(t,s(this.items[this.index],r)),this.index+=1},e}(As),Rqe=2,Pqe=1e4,Dqe=function(){function n(){this.head=0,this.tail=0,this.capacityMask=3,this.list=new Array(4)}return n.prototype.push=function(e){var t=this.tail;return this.list[t]=e,this.tail=t+1&this.capacityMask,this.tail===this.head&&this.growArray(),this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.shift=function(){var e=this.head;if(e!==this.tail){var t=this.list[e];return this.list[e]=void 0,this.head=e+1&this.capacityMask,e<Rqe&&this.tail>Pqe&&this.tail<=this.list.length>>>2&&this.shrinkArray(),t}},n.prototype.isEmpty=function(){return this.head===this.tail},n.prototype.length=function(){return this.head===this.tail?0:this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.growArray=function(){this.head&&(this.list=this.copyArray(),this.head=0),this.tail=this.list.length,this.list.length*=2,this.capacityMask=this.capacityMask<<1|1},n.prototype.shrinkArray=function(){this.list.length>>>=1,this.capacityMask>>>=1},n.prototype.copyArray=function(){var e=[],t=this.list,r=t.length,s;for(s=this.head;s<r;s++)e.push(t[s]);for(s=0;s<this.tail;s++)e.push(t[s]);return e},n}();/** @license MIT License (c) copyright 2010 original author or authors */function Oqe(n,e,t){return Fqe(n,[e,t])}var Fqe=function(n,e){return e.length===0||BQ(e)?Xi():e.length===1?zN(n,e[0]):new Lqe(n,e)},Lqe=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new Array(r),a=new zqe(this.f,o,i,e),l=void 0,c=0;c<r;++c)o[c]=new Dqe,l=i[c]=new wB(c,a),s[c]=this.sources[c].run(l,t);return gC(s)},n}(),zqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,i)||this;return o.f=t,o.sinks=s,o.buffers=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var s=this.buffers,i=s[r.index];if(i.push(r.value),i.length()===1){if(!Wqe(s))return;Bqe(this.f,t,s,this.sink),Uqe(this.buffers,this.sinks)&&this.sink.end(t)}},e.prototype.dispose=function(t,r){var s=this.buffers[r];s.isEmpty()&&this.sink.end(t)},e}(As),Bqe=function(n,e,t,r){return r.event(e,jQ(n,_je(Vqe,t)))},Vqe=function(n){return n.shift()};function Uqe(n,e){for(var t=0,r=n.length;t<r;++t)if(n[t].isEmpty()&&!e[t].active)return!0;return!1}function Wqe(n){for(var e=0,t=n.length;e<t;++e)if(n[e].isEmpty())return!1;return!0}/** @license MIT License (c) copyright 2010-2016 original author or authors */var Gqe=function(n){return Ai(n)?Xi():new Hqe(n)},Hqe=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){var r=new jqe(e,t);return Bw(r,this.source.run(r,t))},n}(),jqe=function(){function n(e,t){this.sink=e,this.scheduler=t,this.current=null,this.ended=!1}return n.prototype.event=function(e,t){this.disposeCurrent(e),this.current=new qqe(t,e,1/0,this,this.sink,this.scheduler)},n.prototype.end=function(e){this.ended=!0,this.checkEnd(e)},n.prototype.error=function(e,t){this.ended=!0,this.sink.error(e,t)},n.prototype.dispose=function(){return this.disposeCurrent(PE(this.scheduler))},n.prototype.disposeCurrent=function(e){if(this.current!==null)return this.current.dispose(e)},n.prototype.disposeInner=function(e,t){t.dispose(e),t===this.current&&(this.current=null)},n.prototype.checkEnd=function(e){this.ended&&this.current===null&&this.sink.end(e)},n.prototype.endInner=function(e,t){this.disposeInner(e,t),this.checkEnd(e)},n.prototype.errorInner=function(e,t,r){this.disposeInner(e,r),this.sink.error(e,t)},n}(),qqe=function(){function n(e,t,r,s,i,o){this.min=t,this.max=r,this.outer=s,this.sink=i,this.disposable=e.run(this,gB(t,o))}return n.prototype.event=function(e,t){var r=Math.max(0,e+this.min);r<this.max&&this.sink.event(r,t)},n.prototype.end=function(e){this.outer.endInner(e+this.min,this)},n.prototype.error=function(e,t){this.outer.errorInner(e+this.min,t,this)},n.prototype.dispose=function(e){hg(e,this.disposable,this.sink)},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function Xqe(n,e){return HQ.create(n,e)}var Kqe=function(n){return nee(Jqe,n)},nee=function(n,e){return Ai(e)?Xi():new Yqe(n,e)},Yqe=function(){function n(e,t){this.equals=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new Zqe(this.equals,e),t)},n}(),Zqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.equals=t,s.value=void 0,s.init=!0,s}return e.prototype.event=function(t,r){this.init?(this.init=!1,this.value=r,this.sink.event(t,r)):this.equals(this.value,r)||(this.value=r,this.sink.event(t,r))},e}(As);function Jqe(n,e){return n===e}/** @license MIT License (c) copyright 2010-2016 original author or authors */var ree=function(n,e){return new e9e(n,e)},see=function(n,e){return new t9e(n,e)},Qqe=function(n,e){return ree(KQ(n),see(n,e))},e9e=function(){function n(e,t){this.maxSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new LN,s=this.source.run(e,t),i=this.maxSignal.run(new s9e(e,r),t);return r.setDisposable(Bw(s,i)),r},n}(),t9e=function(){function n(e,t){this.minSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new r9e(this.minSignal,e,t),s=this.source.run(new n9e(r,e),t);return Bw(r,s)},n}(),n9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.min=t,s}return e.prototype.event=function(t,r){this.min.allow&&this.sink.event(t,r)},e}(As),r9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.allow=!1,i.disposable=t.run(i,s),i}return e.prototype.event=function(){this.allow=!0,this.dispose()},e.prototype.end=function(){},e.prototype.dispose=function(){this.disposable.dispose()},e}(As),s9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,t)||this;return s.disposable=r,s}return e.prototype.event=function(t){this.disposable.dispose(),this.sink.end(t)},e.prototype.end=function(){},e}(As);/** @license MIT License (c) copyright 2010-2016 original author or authors */var i9e=function(n,e){return n<=0?e:new o9e(n,e)},o9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){var r=new a9e(this.dt,e,t);return Bw(r,this.source.run(r,t))},n}(),a9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.dt=t,i.scheduler=s,i.tasks=[],i}return e.prototype.dispose=function(){this.tasks.forEach(Xje)},e.prototype.event=function(t,r){this.tasks.push(FI(this.dt,bB(r,this.sink),this.scheduler))},e.prototype.end=function(){this.tasks.push(FI(this.dt,zQ(this.sink),this.scheduler))},e}(As);/** @license MIT License (c) copyright 2010-2017 original author or authors */var iee=function(n,e){return Ai(e)?Xi():e instanceof yC?l9e(n,e):e instanceof LD?c9e(n,e):new LD(n,e)},l9e=function(n,e){return yC.create(e.f,iee(n,e.source))},c9e=function(n,e){return new LD(Math.max(n,e.period),e.source)},LD=function(){function n(e,t){this.period=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new u9e(this.period,e),t)},n}(),u9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.time=0,s.period=t,s}return e.prototype.event=function(t,r){t>=this.time&&(this.time=t+this.period,this.sink.event(t,r))},e}(As),h9e=function(n,e){return Ai(e)?Xi():new f9e(n,e)},f9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){return new d9e(this.dt,this.source,e,t)},n}(),d9e=function(){function n(e,t,r,s){this.dt=e,this.sink=r,this.scheduler=s,this.timer=null,this.disposable=t.run(this,s)}return n.prototype.event=function(e,t){this.clearTimer(),this.value=t,this.timer=FI(this.dt,new p9e(this,t),this.scheduler)},n.prototype.handleEventFromTask=function(e,t){this.clearTimer(),this.sink.event(e,t)},n.prototype.end=function(e){this.clearTimer()&&(this.sink.event(e,this.value),this.value=void 0),this.sink.end(e)},n.prototype.error=function(e,t){this.clearTimer(),this.sink.error(e,t)},n.prototype.dispose=function(){this.clearTimer(),this.disposable.dispose()},n.prototype.clearTimer=function(){return this.timer===null?!1:(this.timer.dispose(),this.timer=null,!0)},n}(),p9e=function(){function n(e,t){this.sink=e,this.value=t}return n.prototype.run=function(e){this.sink.handleEventFromTask(e,this.value)},n.prototype.error=function(e,t){this.sink.error(e,t)},n.prototype.dispose=function(){},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var m9e=function(n){return Ai(n)?Xi():new g9e(n)},g9e=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){return this.source.run(new y9e(e,t),t)},n}(),y9e=function(){function n(e,t){var r=this;this.eventBound=function(s){return r.sink.event(PE(r.scheduler),s)},this.endBound=function(){return r.sink.end(PE(r.scheduler))},this.errorBound=function(s){return r.sink.error(PE(r.scheduler),s)},this.sink=e,this.scheduler=t,this.queue=Promise.resolve()}return n.prototype.event=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.handlePromise(t)}).catch(this.errorBound)},n.prototype.end=function(){this.queue=this.queue.then(this.endBound).catch(this.errorBound)},n.prototype.error=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.errorBound(t)}).catch(LQ)},n.prototype.handlePromise=function(e){return e.then(this.eventBound)},n}(),b9e=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.event=function(e,t){this.active&&this.sink.event(e,t)},n.prototype.end=function(e){this.active&&(this.disable(),this.sink.end(e))},n.prototype.error=function(e,t){this.disable(),this.sink.error(e,t)},n.prototype.disable=function(){return this.active=!1,this.sink},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function oee(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}function aee(n,e){try{e.end(n)}catch(t){e.error(n,t)}}/** @license MIT License (c) copyright 2010-2016 original author or authors */var v9e=function(n,e){return Ai(e)?Xi():new S9e(n,e)},w9e=function(n){return new x9e(n)},x9e=function(){function n(e){this.value=e}return n.prototype.run=function(e,t){return ON(a8e(this.value,e),t)},n}(),S9e=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new _9e(this.f,this.source,e,t)},n}(),_9e=function(){function n(e,t,r,s){this.f=e,this.sink=new b9e(r),this.scheduler=s,this.disposable=t.run(this,s)}return n.prototype.event=function(e,t){oee(e,t,this.sink)},n.prototype.end=function(e){aee(e,this.sink)},n.prototype.error=function(e,t){var r=this.sink.disable();hg(e,this.disposable,this.sink),this._startNext(e,t,r)},n.prototype._startNext=function(e,t,r){try{this.disposable=this._continue(this.f,e,t,r)}catch(s){r.error(e,s)}},n.prototype._continue=function(e,t,r,s){return WQ(s,this.scheduler,vB(t,e(r)))},n.prototype.dispose=function(){return this.disposable.dispose()},n}(),C9e=function(n){return n instanceof sH||Ai(n)?n:new sH(n)},sH=function(){function n(e){this.source=new k9e(e)}return n.prototype.run=function(e,t){return this.source.run(e,t)},n}(),k9e=function(){function n(e){this.source=e,this.sinks=[],this.disposable=IS()}return n.prototype.run=function(e,t){var r=this.add(e);return r===1&&(this.disposable=this.source.run(this,t)),yB(new T9e(this,e))},n.prototype.dispose=function(){var e=this.disposable;return this.disposable=IS(),e.dispose()},n.prototype.add=function(e){return this.sinks=TQ(e,this.sinks),this.sinks.length},n.prototype.remove=function(e){var t=EQ(e,this.sinks);return t>=0&&(this.sinks=Cje(t,this.sinks)),this.sinks.length},n.prototype.event=function(e,t){var r=this.sinks;if(r.length===1)return r[0].event(e,t);for(var s=0;s<r.length;++s)oee(e,t,r[s])},n.prototype.end=function(e){for(var t=this.sinks,r=0;r<t.length;++r)aee(e,t[r])},n.prototype.error=function(e,t){for(var r=this.sinks,s=0;s<r.length;++s)r[s].error(e,t)},n}(),T9e=function(){function n(e,t){this.source=e,this.sink=t}return n.prototype.dispose=function(){this.source.remove(this.sink)===0&&this.source.dispose()},n}(),E9e=kr(vB),I9e=zu(k8e),A9e=zu(I8e),M9e=kr(R8e),iH=kr(zN),N9e=kr(z8e),oH=kr(B8e),$9e=kr(j8e),R9e=kr(J8e),P9e=kr(GQ),D9e=kr(Q8e),O9e=kr(XQ),F9e=zu(BN),aH=kr(eqe),L9e=zu(qQ),lH=kr(aqe),z9e=zu(ZQ),B9e=zu(tee),V9e=kr(Aqe),U9e=zu(Oqe),W9e=kr(Xqe),G9e=kr(nee),H9e=kr(QQ),j9e=kr(pqe),q9e=zu(xB),X9e=kr(wqe),K9e=kr(_qe),Y9e=kr(Tqe),cH=kr(ree),Z9e=kr(see),J9e=kr(Qqe),Q9e=kr(i9e),e7e=kr(iee),t7e=kr(h9e),n7e=kr(v9e),uH=function(){var n=[];return[function(e){return r7e(n,e)},new s7e(n)]},r7e=function(n,e){return n.forEach(function(t){var r=t.sink,s=t.scheduler;return o7e(s.currentTime(),e,r)})},s7e=function(){function n(e){this.sinks=e}return n.prototype.run=function(e,t){var r={sink:e,scheduler:t};return this.sinks.push(r),new i7e(r,this.sinks)},n}(),i7e=function(){function n(e,t){this.sink=e,this.sinks=t}return n.prototype.dispose=function(){var e=this.sinks.indexOf(this.sink);e>=0&&this.sinks.splice(e,1)},n}();function o7e(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}const a7e=n=>{const e=new Set;do for(const t of Reflect.ownKeys(n))e.add([n,t]);while((n=Reflect.getPrototypeOf(n))&&n!==Object.prototype);return e};function l7e(n,{include:e,exclude:t}={}){const r=s=>{const i=o=>typeof o=="string"?s===o:o.test(s);return e?e.some(i):t?!t.some(i):!0};for(const[s,i]of a7e(n.constructor.prototype)){if(i==="constructor"||!r(i))continue;const o=Reflect.getOwnPropertyDescriptor(s,i);o&&typeof o.value=="function"&&(n[i]=n[i].bind(n))}return n}var zD={exports:{}},c7e=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,u7e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],lee=function(e){var t=e,r=e.indexOf("["),s=e.indexOf("]");r!=-1&&s!=-1&&(e=e.substring(0,r)+e.substring(r,s).replace(/:/g,";")+e.substring(s,e.length));for(var i=c7e.exec(e||""),o={},a=14;a--;)o[u7e[a]]=i[a]||"";return r!=-1&&s!=-1&&(o.source=t,o.host=o.host.substring(1,o.host.length-1).replace(/;/g,":"),o.authority=o.authority.replace("[","").replace("]","").replace(/;/g,":"),o.ipv6uri=!0),o.pathNames=h7e(o,o.path),o.queryKey=f7e(o,o.query),o};function h7e(n,e){var t=/\/{2,9}/g,r=e.replace(t,"/").split("/");return(e.substr(0,1)=="/"||e.length===0)&&r.splice(0,1),e.substr(e.length-1,1)=="/"&&r.splice(r.length-1,1),r}function f7e(n,e){var t={};return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(r,s,i){s&&(t[s]=i)}),t}var BD={exports:{}},VD={exports:{}},MS=1e3,NS=MS*60,$S=NS*60,RS=$S*24,d7e=RS*365.25,p7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return m7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?y7e(n):g7e(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function m7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*d7e;case"days":case"day":case"d":return t*RS;case"hours":case"hour":case"hrs":case"hr":case"h":return t*$S;case"minutes":case"minute":case"mins":case"min":case"m":return t*NS;case"seconds":case"second":case"secs":case"sec":case"s":return t*MS;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function g7e(n){return n>=RS?Math.round(n/RS)+"d":n>=$S?Math.round(n/$S)+"h":n>=NS?Math.round(n/NS)+"m":n>=MS?Math.round(n/MS)+"s":n+"ms"}function y7e(n){return Yk(n,RS,"day")||Yk(n,$S,"hour")||Yk(n,NS,"minute")||Yk(n,MS,"second")||n+" ms"}function Yk(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=p7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var _=e.formatters[w];if(typeof _=="function"){var C=m[y];x=_.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(VD,VD.exports);var b7e=VD.exports;(function(n,e){e=n.exports=b7e,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(BD,BD.exports);var VN=BD.exports,v7e=lee,hH=VN("socket.io-client:url"),w7e=x7e;function x7e(n,e){var t=n;e=e||typeof location<"u"&&location,n==null&&(n=e.protocol+"//"+e.host),typeof n=="string"&&(n.charAt(0)==="/"&&(n.charAt(1)==="/"?n=e.protocol+n:n=e.host+n),/^(https?|wss?):\/\//.test(n)||(hH("protocol-less url %s",n),typeof e<"u"?n=e.protocol+"//"+n:n="https://"+n),hH("parse %s",n),t=v7e(n)),t.port||(/^(http|ws)$/.test(t.protocol)?t.port="80":/^(http|ws)s$/.test(t.protocol)&&(t.port="443")),t.path=t.path||"/";var r=t.host.indexOf(":")!==-1,s=r?"["+t.host+"]":t.host;return t.id=t.protocol+"://"+s+":"+t.port,t.href=t.protocol+"://"+s+(e&&e.port===t.port?"":":"+t.port),t}var UN={},UD={exports:{}},WD={exports:{}},PS=1e3,DS=PS*60,OS=DS*60,FS=OS*24,S7e=FS*365.25,_7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return C7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?T7e(n):k7e(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function C7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*S7e;case"days":case"day":case"d":return t*FS;case"hours":case"hour":case"hrs":case"hr":case"h":return t*OS;case"minutes":case"minute":case"mins":case"min":case"m":return t*DS;case"seconds":case"second":case"secs":case"sec":case"s":return t*PS;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function k7e(n){return n>=FS?Math.round(n/FS)+"d":n>=OS?Math.round(n/OS)+"h":n>=DS?Math.round(n/DS)+"m":n>=PS?Math.round(n/PS)+"s":n+"ms"}function T7e(n){return Zk(n,FS,"day")||Zk(n,OS,"hour")||Zk(n,DS,"minute")||Zk(n,PS,"second")||n+" ms"}function Zk(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=_7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var _=e.formatters[w];if(typeof _=="function"){var C=m[y];x=_.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(WD,WD.exports);var E7e=WD.exports;(function(n,e){e=n.exports=E7e,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(UD,UD.exports);var I7e=UD.exports,cee={exports:{}};(function(n){n.exports=e;function e(r){if(r)return t(r)}function t(r){for(var s in e.prototype)r[s]=e.prototype[s];return r}e.prototype.on=e.prototype.addEventListener=function(r,s){return this._callbacks=this._callbacks||{},(this._callbacks["$"+r]=this._callbacks["$"+r]||[]).push(s),this},e.prototype.once=function(r,s){function i(){this.off(r,i),s.apply(this,arguments)}return i.fn=s,this.on(r,i),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(r,s){if(this._callbacks=this._callbacks||{},arguments.length==0)return this._callbacks={},this;var i=this._callbacks["$"+r];if(!i)return this;if(arguments.length==1)return delete this._callbacks["$"+r],this;for(var o,a=0;a<i.length;a++)if(o=i[a],o===s||o.fn===s){i.splice(a,1);break}return i.length===0&&delete this._callbacks["$"+r],this},e.prototype.emit=function(r){this._callbacks=this._callbacks||{};for(var s=new Array(arguments.length-1),i=this._callbacks["$"+r],o=1;o<arguments.length;o++)s[o-1]=arguments[o];if(i){i=i.slice(0);for(var o=0,a=i.length;o<a;++o)i[o].apply(this,s)}return this},e.prototype.listeners=function(r){return this._callbacks=this._callbacks||{},this._callbacks["$"+r]||[]},e.prototype.hasListeners=function(r){return!!this.listeners(r).length}})(cee);var Vw=cee.exports,WN={},A7e={}.toString,uee=Array.isArray||function(n){return A7e.call(n)=="[object Array]"},hee=R7e,M7e=typeof Buffer=="function"&&typeof Buffer.isBuffer=="function",N7e=typeof ArrayBuffer=="function",$7e=function(n){return typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(n):n.buffer instanceof ArrayBuffer};function R7e(n){return M7e&&Buffer.isBuffer(n)||N7e&&(n instanceof ArrayBuffer||$7e(n))}var _B=uee,fee=hee,dee=Object.prototype.toString,P7e=typeof Blob=="function"||typeof Blob<"u"&&dee.call(Blob)==="[object BlobConstructor]",D7e=typeof File=="function"||typeof File<"u"&&dee.call(File)==="[object FileConstructor]";WN.deconstructPacket=function(n){var e=[],t=n.data,r=n;return r.data=GD(t,e),r.attachments=e.length,{packet:r,buffers:e}};function GD(n,e){if(!n)return n;if(fee(n)){var t={_placeholder:!0,num:e.length};return e.push(n),t}else if(_B(n)){for(var r=new Array(n.length),s=0;s<n.length;s++)r[s]=GD(n[s],e);return r}else if(typeof n=="object"&&!(n instanceof Date)){var r={};for(var i in n)r[i]=GD(n[i],e);return r}return n}WN.reconstructPacket=function(n,e){return n.data=HD(n.data,e),n.attachments=void 0,n};function HD(n,e){if(!n)return n;if(n&&n._placeholder===!0){var t=typeof n.num=="number"&&n.num>=0&&n.num<e.length;if(t)return e[n.num];throw new Error("illegal attachments")}else if(_B(n))for(var r=0;r<n.length;r++)n[r]=HD(n[r],e);else if(typeof n=="object")for(var s in n)n[s]=HD(n[s],e);return n}WN.removeBlobs=function(n,e){function t(i,o,a){if(!i)return i;if(P7e&&i instanceof Blob||D7e&&i instanceof File){r++;var l=new FileReader;l.onload=function(){a?a[o]=this.result:s=this.result,--r||e(s)},l.readAsArrayBuffer(i)}else if(_B(i))for(var c=0;c<i.length;c++)t(i[c],c,i);else if(typeof i=="object"&&!fee(i))for(var u in i)t(i[u],u,i)}var r=0,s=n;t(s),r||e(s)};(function(n){var e=I7e("socket.io-parser"),t=Vw,r=WN,s=uee,i=hee;n.protocol=4,n.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],n.CONNECT=0,n.DISCONNECT=1,n.EVENT=2,n.ACK=3,n.ERROR=4,n.BINARY_EVENT=5,n.BINARY_ACK=6,n.Encoder=o,n.Decoder=h;function o(){}var a=n.ERROR+'"encode error"';o.prototype.encode=function(g,y){if(e("encoding packet %j",g),n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)u(g,y);else{var b=l(g);y([b])}};function l(g){var y=""+g.type;if((n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)&&(y+=g.attachments+"-"),g.nsp&&g.nsp!=="/"&&(y+=g.nsp+","),g.id!=null&&(y+=g.id),g.data!=null){var b=c(g.data);if(b!==!1)y+=b;else return a}return e("encoded %j as %s",g,y),y}function c(g){try{return JSON.stringify(g)}catch{return!1}}function u(g,y){function b(x){var w=r.deconstructPacket(x),_=l(w.packet),C=w.buffers;C.unshift(_),y(C)}r.removeBlobs(g,b)}function h(){this.reconstructor=null}t(h.prototype),h.prototype.add=function(g){var y;if(typeof g=="string"){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");y=f(g),n.BINARY_EVENT===y.type||n.BINARY_ACK===y.type?(this.reconstructor=new p(y),this.reconstructor.reconPack.attachments===0&&this.emit("decoded",y)):this.emit("decoded",y)}else if(i(g)||g.base64)if(this.reconstructor)y=this.reconstructor.takeBinaryData(g),y&&(this.reconstructor=null,this.emit("decoded",y));else throw new Error("got binary data when not reconstructing a packet");else throw new Error("Unknown type: "+g)};function f(g){var y=0,b={type:Number(g.charAt(0))};if(n.types[b.type]==null)return m("unknown packet type "+b.type);if(n.BINARY_EVENT===b.type||n.BINARY_ACK===b.type){for(var x=y+1;g.charAt(++y)!=="-"&&y!=g.length;);var w=g.substring(x,y);if(w!=Number(w)||g.charAt(y)!=="-")throw new Error("Illegal attachments");b.attachments=Number(w)}if(g.charAt(y+1)==="/"){for(var x=y+1;++y;){var _=g.charAt(y);if(_===","||y===g.length)break}b.nsp=g.substring(x,y)}else b.nsp="/";var C=g.charAt(y+1);if(C!==""&&Number(C)==C){for(var x=y+1;++y;){var _=g.charAt(y);if(_==null||Number(_)!=_){--y;break}if(y===g.length)break}b.id=Number(g.substring(x,y+1))}if(g.charAt(++y)){var k=d(g.substr(y)),A=k!==!1&&(b.type===n.ERROR||s(k));if(A)b.data=k;else return m("invalid payload")}return e("decoded %s as %j",g,b),b}function d(g){try{return JSON.parse(g)}catch{return!1}}h.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()};function p(g){this.reconPack=g,this.buffers=[]}p.prototype.takeBinaryData=function(g){if(this.buffers.push(g),this.buffers.length===this.reconPack.attachments){var y=r.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),y}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]};function m(g){return{type:n.ERROR,data:"parser error: "+g}}})(UN);var CB={exports:{}},GN={},jD={exports:{}};try{jD.exports=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{jD.exports=!1}var O7e=jD.exports,kB=function(){return typeof self<"u"?self:typeof window<"u"?window:Function("return this")()}(),F7e=O7e,L7e=kB,TB=function(n){var e=n.xdomain,t=n.xscheme,r=n.enablesXDR;try{if(typeof XMLHttpRequest<"u"&&(!e||F7e))return new XMLHttpRequest}catch{}try{if(typeof XDomainRequest<"u"&&!t&&r)return new XDomainRequest}catch{}if(!e)try{return new L7e[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")}catch{}},EB={exports:{}},Hy={},z7e=Object.keys||function(e){var t=[],r=Object.prototype.hasOwnProperty;for(var s in e)r.call(e,s)&&t.push(s);return t},f3,fH;function B7e(){if(fH)return f3;fH=1;var n={}.toString;return f3=Array.isArray||function(e){return n.call(e)=="[object Array]"},f3}var d3,dH;function pee(){if(dH)return d3;dH=1;var n=B7e(),e=Object.prototype.toString,t=typeof Blob=="function"||typeof Blob<"u"&&e.call(Blob)==="[object BlobConstructor]",r=typeof File=="function"||typeof File<"u"&&e.call(File)==="[object FileConstructor]";d3=s;function s(i){if(!i||typeof i!="object")return!1;if(n(i)){for(var o=0,a=i.length;o<a;o++)if(s(i[o]))return!0;return!1}if(typeof Buffer=="function"&&Buffer.isBuffer&&Buffer.isBuffer(i)||typeof ArrayBuffer=="function"&&i instanceof ArrayBuffer||t&&i instanceof Blob||r&&i instanceof File)return!0;if(i.toJSON&&typeof i.toJSON=="function"&&arguments.length===1)return s(i.toJSON(),!0);for(var l in i)if(Object.prototype.hasOwnProperty.call(i,l)&&s(i[l]))return!0;return!1}return d3}var V7e=function(n,e,t){var r=n.byteLength;if(e=e||0,t=t||r,n.slice)return n.slice(e,t);if(e<0&&(e+=r),t<0&&(t+=r),t>r&&(t=r),e>=r||e>=t||r===0)return new ArrayBuffer(0);for(var s=new Uint8Array(n),i=new Uint8Array(t-e),o=e,a=0;o<t;o++,a++)i[a]=s[o];return i.buffer},U7e=W7e;function W7e(n,e,t){var r=!1;return t=t||G7e,s.count=n,n===0?e():s;function s(i,o){if(s.count<=0)throw new Error("after called too many times");--s.count,i?(r=!0,e(i),e=t):s.count===0&&!r&&e(null,o)}}function G7e(){}/*! https://mths.be/utf8js v2.1.2 by @mathias */var Td=String.fromCharCode;function mee(n){for(var e=[],t=0,r=n.length,s,i;t<r;)s=n.charCodeAt(t++),s>=55296&&s<=56319&&t<r?(i=n.charCodeAt(t++),(i&64512)==56320?e.push(((s&1023)<<10)+(i&1023)+65536):(e.push(s),t--)):e.push(s);return e}function H7e(n){for(var e=n.length,t=-1,r,s="";++t<e;)r=n[t],r>65535&&(r-=65536,s+=Td(r>>>10&1023|55296),r=56320|r&1023),s+=Td(r);return s}function gee(n,e){if(n>=55296&&n<=57343){if(e)throw Error("Lone surrogate U+"+n.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function p3(n,e){return Td(n>>e&63|128)}function j7e(n,e){if(!(n&4294967168))return Td(n);var t="";return n&4294965248?n&4294901760?n&4292870144||(t=Td(n>>18&7|240),t+=p3(n,12),t+=p3(n,6)):(gee(n,e)||(n=65533),t=Td(n>>12&15|224),t+=p3(n,6)):t=Td(n>>6&31|192),t+=Td(n&63|128),t}function q7e(n,e){e=e||{};for(var t=e.strict!==!1,r=mee(n),s=r.length,i=-1,o,a="";++i<s;)o=r[i],a+=j7e(o,t);return a}function I0(){if(Md>=zI)throw Error("Invalid byte index");var n=LI[Md]&255;if(Md++,(n&192)==128)return n&63;throw Error("Invalid continuation byte")}function X7e(n){var e,t,r,s,i;if(Md>zI)throw Error("Invalid byte index");if(Md==zI)return!1;if(e=LI[Md]&255,Md++,!(e&128))return e;if((e&224)==192){if(t=I0(),i=(e&31)<<6|t,i>=128)return i;throw Error("Invalid continuation byte")}if((e&240)==224){if(t=I0(),r=I0(),i=(e&15)<<12|t<<6|r,i>=2048)return gee(i,n)?i:65533;throw Error("Invalid continuation byte")}if((e&248)==240&&(t=I0(),r=I0(),s=I0(),i=(e&7)<<18|t<<12|r<<6|s,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}var LI,zI,Md;function K7e(n,e){e=e||{};var t=e.strict!==!1;LI=mee(n),zI=LI.length,Md=0;for(var r=[],s;(s=X7e(t))!==!1;)r.push(s);return H7e(r)}var Y7e={version:"2.1.2",encode:q7e,decode:K7e},Jk={},pH;function Z7e(){return pH||(pH=1,function(n){Jk.encode=function(e){var t=new Uint8Array(e),r,s=t.length,i="";for(r=0;r<s;r+=3)i+=n[t[r]>>2],i+=n[(t[r]&3)<<4|t[r+1]>>4],i+=n[(t[r+1]&15)<<2|t[r+2]>>6],i+=n[t[r+2]&63];return s%3===2?i=i.substring(0,i.length-1)+"=":s%3===1&&(i=i.substring(0,i.length-2)+"=="),i},Jk.decode=function(e){var t=e.length*.75,r=e.length,s,i=0,o,a,l,c;e[e.length-1]==="="&&(t--,e[e.length-2]==="="&&t--);var u=new ArrayBuffer(t),h=new Uint8Array(u);for(s=0;s<r;s+=4)o=n.indexOf(e[s]),a=n.indexOf(e[s+1]),l=n.indexOf(e[s+2]),c=n.indexOf(e[s+3]),h[i++]=o<<2|a>>4,h[i++]=(a&15)<<4|l>>2,h[i++]=(l&3)<<6|c&63;return u}}("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")),Jk}var m3,mH;function J7e(){if(mH)return m3;mH=1;var n=typeof n<"u"?n:typeof WebKitBlobBuilder<"u"?WebKitBlobBuilder:typeof MSBlobBuilder<"u"?MSBlobBuilder:typeof MozBlobBuilder<"u"?MozBlobBuilder:!1,e=function(){try{var a=new Blob(["hi"]);return a.size===2}catch{return!1}}(),t=e&&function(){try{var a=new Blob([new Uint8Array([1,2])]);return a.size===2}catch{return!1}}(),r=n&&n.prototype.append&&n.prototype.getBlob;function s(a){return a.map(function(l){if(l.buffer instanceof ArrayBuffer){var c=l.buffer;if(l.byteLength!==c.byteLength){var u=new Uint8Array(l.byteLength);u.set(new Uint8Array(c,l.byteOffset,l.byteLength)),c=u.buffer}return c}return l})}function i(a,l){l=l||{};var c=new n;return s(a).forEach(function(u){c.append(u)}),l.type?c.getBlob(l.type):c.getBlob()}function o(a,l){return new Blob(s(a),l||{})}return typeof Blob<"u"&&(i.prototype=Blob.prototype,o.prototype=Blob.prototype),m3=function(){return e?t?Blob:o:r?i:void 0}(),m3}(function(n){var e=z7e,t=pee(),r=V7e,s=U7e,i=Y7e,o;typeof ArrayBuffer<"u"&&(o=Z7e());var a=typeof navigator<"u"&&/Android/i.test(navigator.userAgent),l=typeof navigator<"u"&&/PhantomJS/i.test(navigator.userAgent),c=a||l;n.protocol=3;var u=n.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},h=e(u),f={type:"error",data:"parser error"},d=J7e();n.encodePacket=function(w,_,C,k){typeof _=="function"&&(k=_,_=!1),typeof C=="function"&&(k=C,C=null);var A=w.data===void 0?void 0:w.data.buffer||w.data;if(typeof ArrayBuffer<"u"&&A instanceof ArrayBuffer)return m(w,_,k);if(typeof d<"u"&&A instanceof d)return y(w,_,k);if(A&&A.base64)return p(w,k);var M=u[w.type];return w.data!==void 0&&(M+=C?i.encode(String(w.data),{strict:!1}):String(w.data)),k(""+M)};function p(w,_){var C="b"+n.packets[w.type]+w.data.data;return _(C)}function m(w,_,C){if(!_)return n.encodeBase64Packet(w,C);var k=w.data,A=new Uint8Array(k),M=new Uint8Array(1+k.byteLength);M[0]=u[w.type];for(var I=0;I<A.length;I++)M[I+1]=A[I];return C(M.buffer)}function g(w,_,C){if(!_)return n.encodeBase64Packet(w,C);var k=new FileReader;return k.onload=function(){n.encodePacket({type:w.type,data:k.result},_,!0,C)},k.readAsArrayBuffer(w.data)}function y(w,_,C){if(!_)return n.encodeBase64Packet(w,C);if(c)return g(w,_,C);var k=new Uint8Array(1);k[0]=u[w.type];var A=new d([k.buffer,w.data]);return C(A)}n.encodeBase64Packet=function(w,_){var C="b"+n.packets[w.type];if(typeof d<"u"&&w.data instanceof d){var k=new FileReader;return k.onload=function(){var O=k.result.split(",")[1];_(C+O)},k.readAsDataURL(w.data)}var A;try{A=String.fromCharCode.apply(null,new Uint8Array(w.data))}catch{for(var M=new Uint8Array(w.data),I=new Array(M.length),N=0;N<M.length;N++)I[N]=M[N];A=String.fromCharCode.apply(null,I)}return C+=btoa(A),_(C)},n.decodePacket=function(w,_,C){if(w===void 0)return f;if(typeof w=="string"){if(w.charAt(0)==="b")return n.decodeBase64Packet(w.substr(1),_);if(C&&(w=b(w),w===!1))return f;var A=w.charAt(0);return Number(A)!=A||!h[A]?f:w.length>1?{type:h[A],data:w.substring(1)}:{type:h[A]}}var k=new Uint8Array(w),A=k[0],M=r(w,1);return d&&_==="blob"&&(M=new d([M])),{type:h[A],data:M}};function b(w){try{w=i.decode(w,{strict:!1})}catch{return!1}return w}n.decodeBase64Packet=function(w,_){var C=h[w.charAt(0)];if(!o)return{type:C,data:{base64:!0,data:w.substr(1)}};var k=o.decode(w.substr(1));return _==="blob"&&d&&(k=new d([k])),{type:C,data:k}},n.encodePayload=function(w,_,C){typeof _=="function"&&(C=_,_=null);var k=t(w);if(_&&k)return d&&!c?n.encodePayloadAsBlob(w,C):n.encodePayloadAsArrayBuffer(w,C);if(!w.length)return C("0:");function A(I){return I.length+":"+I}function M(I,N){n.encodePacket(I,k?_:!1,!1,function(O){N(null,A(O))})}x(w,M,function(I,N){return C(N.join(""))})};function x(w,_,C){for(var k=new Array(w.length),A=s(w.length,C),M=function(N,O,R){_(O,function(D,z){k[N]=z,R(D,k)})},I=0;I<w.length;I++)M(I,w[I],A)}n.decodePayload=function(w,_,C){if(typeof w!="string")return n.decodePayloadAsBinary(w,_,C);typeof _=="function"&&(C=_,_=null);var k;if(w==="")return C(f,0,1);for(var A="",M,I,N=0,O=w.length;N<O;N++){var R=w.charAt(N);if(R!==":"){A+=R;continue}if(A===""||A!=(M=Number(A))||(I=w.substr(N+1,M),A!=I.length))return C(f,0,1);if(I.length){if(k=n.decodePacket(I,_,!1),f.type===k.type&&f.data===k.data)return C(f,0,1);var D=C(k,N+M,O);if(D===!1)return}N+=M,A=""}if(A!=="")return C(f,0,1)},n.encodePayloadAsArrayBuffer=function(w,_){if(!w.length)return _(new ArrayBuffer(0));function C(k,A){n.encodePacket(k,!0,!0,function(M){return A(null,M)})}x(w,C,function(k,A){var M=A.reduce(function(O,R){var D;return typeof R=="string"?D=R.length:D=R.byteLength,O+D.toString().length+D+2},0),I=new Uint8Array(M),N=0;return A.forEach(function(O){var R=typeof O=="string",D=O;if(R){for(var X=new Uint8Array(O.length),z=0;z<O.length;z++)X[z]=O.charCodeAt(z);D=X.buffer}R?I[N++]=0:I[N++]=1;for(var B=D.byteLength.toString(),z=0;z<B.length;z++)I[N++]=parseInt(B[z]);I[N++]=255;for(var X=new Uint8Array(D),z=0;z<X.length;z++)I[N++]=X[z]}),_(I.buffer)})},n.encodePayloadAsBlob=function(w,_){function C(k,A){n.encodePacket(k,!0,!0,function(M){var I=new Uint8Array(1);if(I[0]=1,typeof M=="string"){for(var N=new Uint8Array(M.length),O=0;O<M.length;O++)N[O]=M.charCodeAt(O);M=N.buffer,I[0]=0}for(var R=M instanceof ArrayBuffer?M.byteLength:M.size,D=R.toString(),z=new Uint8Array(D.length+1),O=0;O<D.length;O++)z[O]=parseInt(D[O]);if(z[D.length]=255,d){var B=new d([I.buffer,z.buffer,M]);A(null,B)}})}x(w,C,function(k,A){return _(new d(A))})},n.decodePayloadAsBinary=function(w,_,C){typeof _=="function"&&(C=_,_=null);for(var k=w,A=[];k.byteLength>0;){for(var M=new Uint8Array(k),I=M[0]===0,N="",O=1;M[O]!==255;O++){if(N.length>310)return C(f,0,1);N+=M[O]}k=r(k,2+N.length),N=parseInt(N);var R=r(k,0,N);if(I)try{R=String.fromCharCode.apply(null,new Uint8Array(R))}catch{var D=new Uint8Array(R);R="";for(var O=0;O<D.length;O++)R+=String.fromCharCode(D[O])}A.push(R),k=r(k,N)}var z=A.length;A.forEach(function(B,X){C(n.decodePacket(B,_,!0),X,z)})}})(Hy);var g3,gH;function IB(){if(gH)return g3;gH=1;var n=Hy,e=Vw;g3=t;function t(r){this.path=r.path,this.hostname=r.hostname,this.port=r.port,this.secure=r.secure,this.query=r.query,this.timestampParam=r.timestampParam,this.timestampRequests=r.timestampRequests,this.readyState="",this.agent=r.agent||!1,this.socket=r.socket,this.enablesXDR=r.enablesXDR,this.withCredentials=r.withCredentials,this.pfx=r.pfx,this.key=r.key,this.passphrase=r.passphrase,this.cert=r.cert,this.ca=r.ca,this.ciphers=r.ciphers,this.rejectUnauthorized=r.rejectUnauthorized,this.forceNode=r.forceNode,this.isReactNative=r.isReactNative,this.extraHeaders=r.extraHeaders,this.localAddress=r.localAddress}return e(t.prototype),t.prototype.onError=function(r,s){var i=new Error(r);return i.type="TransportError",i.description=s,this.emit("error",i),this},t.prototype.open=function(){return(this.readyState==="closed"||this.readyState==="")&&(this.readyState="opening",this.doOpen()),this},t.prototype.close=function(){return(this.readyState==="opening"||this.readyState==="open")&&(this.doClose(),this.onClose()),this},t.prototype.send=function(r){if(this.readyState==="open")this.write(r);else throw new Error("Transport not open")},t.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},t.prototype.onData=function(r){var s=n.decodePacket(r,this.socket.binaryType);this.onPacket(s)},t.prototype.onPacket=function(r){this.emit("packet",r)},t.prototype.onClose=function(){this.readyState="closed",this.emit("close")},g3}var Qk={},yH;function HN(){return yH||(yH=1,Qk.encode=function(n){var e="";for(var t in n)n.hasOwnProperty(t)&&(e.length&&(e+="&"),e+=encodeURIComponent(t)+"="+encodeURIComponent(n[t]));return e},Qk.decode=function(n){for(var e={},t=n.split("&"),r=0,s=t.length;r<s;r++){var i=t[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}),Qk}var jN=function(n,e){var t=function(){};t.prototype=e.prototype,n.prototype=new t,n.prototype.constructor=n},yee="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),BI=64,bee={},bH=0,Nd=0,vH;function qD(n){var e="";do e=yee[n%BI]+e,n=Math.floor(n/BI);while(n>0);return e}function Q7e(n){var e=0;for(Nd=0;Nd<n.length;Nd++)e=e*BI+bee[n.charAt(Nd)];return e}function AB(){var n=qD(+new Date);return n!==vH?(bH=0,vH=n):n+"."+qD(bH++)}for(;Nd<BI;Nd++)bee[yee[Nd]]=Nd;AB.encode=qD;AB.decode=Q7e;var vee=AB,XD={exports:{}},KD={exports:{}},LS=1e3,zS=LS*60,BS=zS*60,VS=BS*24,eXe=VS*365.25,tXe=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return nXe(n);if(t==="number"&&isNaN(n)===!1)return e.long?sXe(n):rXe(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function nXe(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*eXe;case"days":case"day":case"d":return t*VS;case"hours":case"hour":case"hrs":case"hr":case"h":return t*BS;case"minutes":case"minute":case"mins":case"min":case"m":return t*zS;case"seconds":case"second":case"secs":case"sec":case"s":return t*LS;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function rXe(n){return n>=VS?Math.round(n/VS)+"d":n>=BS?Math.round(n/BS)+"h":n>=zS?Math.round(n/zS)+"m":n>=LS?Math.round(n/LS)+"s":n+"ms"}function sXe(n){return eT(n,VS,"day")||eT(n,BS,"hour")||eT(n,zS,"minute")||eT(n,LS,"second")||n+" ms"}function eT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=tXe,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var _=e.formatters[w];if(typeof _=="function"){var C=m[y];x=_.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(KD,KD.exports);var iXe=KD.exports;(function(n,e){e=n.exports=iXe,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(XD,XD.exports);var qN=XD.exports,wee=IB(),oXe=HN(),xee=Hy,aXe=jN,lXe=vee,lu=qN("engine.io-client:polling"),See=Oh,cXe=function(){var n=TB,e=new n({xdomain:!1});return e.responseType!=null}();function Oh(n){var e=n&&n.forceBase64;(!cXe||e)&&(this.supportsBinary=!1),wee.call(this,n)}aXe(Oh,wee);Oh.prototype.name="polling";Oh.prototype.doOpen=function(){this.poll()};Oh.prototype.pause=function(n){var e=this;this.readyState="pausing";function t(){lu("paused"),e.readyState="paused",n()}if(this.polling||!this.writable){var r=0;this.polling&&(lu("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){lu("pre-pause polling complete"),--r||t()})),this.writable||(lu("we are currently writing - waiting to pause"),r++,this.once("drain",function(){lu("pre-pause writing complete"),--r||t()}))}else t()};Oh.prototype.poll=function(){lu("polling"),this.polling=!0,this.doPoll(),this.emit("poll")};Oh.prototype.onData=function(n){var e=this;lu("polling got data %s",n);var t=function(r,s,i){if(e.readyState==="opening"&&r.type==="open"&&e.onOpen(),r.type==="close")return e.onClose(),!1;e.onPacket(r)};xee.decodePayload(n,this.socket.binaryType,t),this.readyState!=="closed"&&(this.polling=!1,this.emit("pollComplete"),this.readyState==="open"?this.poll():lu('ignoring poll - transport state "%s"',this.readyState))};Oh.prototype.doClose=function(){var n=this;function e(){lu("writing close packet"),n.write([{type:"close"}])}this.readyState==="open"?(lu("transport open - closing"),e()):(lu("transport not open - deferring close"),this.once("open",e))};Oh.prototype.write=function(n){var e=this;this.writable=!1;var t=function(){e.writable=!0,e.emit("drain")};xee.encodePayload(n,this.supportsBinary,function(r){e.doWrite(r,t)})};Oh.prototype.uri=function(){var n=this.query||{},e=this.secure?"https":"http",t="";this.timestampRequests!==!1&&(n[this.timestampParam]=lXe()),!this.supportsBinary&&!n.sid&&(n.b64=1),n=oXe.encode(n),this.port&&(e==="https"&&Number(this.port)!==443||e==="http"&&Number(this.port)!==80)&&(t=":"+this.port),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};var uXe=TB,_ee=See,hXe=Vw,fXe=jN,YD=qN("engine.io-client:polling-xhr"),dXe=kB;EB.exports=Uw;EB.exports.Request=Gi;function wH(){}function Uw(n){if(_ee.call(this,n),this.requestTimeout=n.requestTimeout,this.extraHeaders=n.extraHeaders,typeof location<"u"){var e=location.protocol==="https:",t=location.port;t||(t=e?443:80),this.xd=typeof location<"u"&&n.hostname!==location.hostname||t!==n.port,this.xs=n.secure!==e}}fXe(Uw,_ee);Uw.prototype.supportsBinary=!0;Uw.prototype.request=function(n){return n=n||{},n.uri=this.uri(),n.xd=this.xd,n.xs=this.xs,n.agent=this.agent||!1,n.supportsBinary=this.supportsBinary,n.enablesXDR=this.enablesXDR,n.withCredentials=this.withCredentials,n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,n.requestTimeout=this.requestTimeout,n.extraHeaders=this.extraHeaders,new Gi(n)};Uw.prototype.doWrite=function(n,e){var t=typeof n!="string"&&n!==void 0,r=this.request({method:"POST",data:n,isBinary:t}),s=this;r.on("success",e),r.on("error",function(i){s.onError("xhr post error",i)}),this.sendXhr=r};Uw.prototype.doPoll=function(){YD("xhr poll");var n=this.request(),e=this;n.on("data",function(t){e.onData(t)}),n.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=n};function Gi(n){this.method=n.method||"GET",this.uri=n.uri,this.xd=!!n.xd,this.xs=!!n.xs,this.async=n.async!==!1,this.data=n.data!==void 0?n.data:null,this.agent=n.agent,this.isBinary=n.isBinary,this.supportsBinary=n.supportsBinary,this.enablesXDR=n.enablesXDR,this.withCredentials=n.withCredentials,this.requestTimeout=n.requestTimeout,this.pfx=n.pfx,this.key=n.key,this.passphrase=n.passphrase,this.cert=n.cert,this.ca=n.ca,this.ciphers=n.ciphers,this.rejectUnauthorized=n.rejectUnauthorized,this.extraHeaders=n.extraHeaders,this.create()}hXe(Gi.prototype);Gi.prototype.create=function(){var n={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new uXe(n),t=this;try{YD("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch{}if(this.method==="POST")try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{e.setRequestHeader("Accept","*/*")}catch{}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){t.onLoad()},e.onerror=function(){t.onError(e.responseText)}):e.onreadystatechange=function(){if(e.readyState===2)try{var s=e.getResponseHeader("Content-Type");(t.supportsBinary&&s==="application/octet-stream"||s==="application/octet-stream; charset=UTF-8")&&(e.responseType="arraybuffer")}catch{}e.readyState===4&&(e.status===200||e.status===1223?t.onLoad():setTimeout(function(){t.onError(typeof e.status=="number"?e.status:0)},0))},YD("xhr data %s",this.data),e.send(this.data)}catch(s){setTimeout(function(){t.onError(s)},0);return}typeof document<"u"&&(this.index=Gi.requestsCount++,Gi.requests[this.index]=this)};Gi.prototype.onSuccess=function(){this.emit("success"),this.cleanup()};Gi.prototype.onData=function(n){this.emit("data",n),this.onSuccess()};Gi.prototype.onError=function(n){this.emit("error",n),this.cleanup(!0)};Gi.prototype.cleanup=function(n){if(!(typeof this.xhr>"u"||this.xhr===null)){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=wH:this.xhr.onreadystatechange=wH,n)try{this.xhr.abort()}catch{}typeof document<"u"&&delete Gi.requests[this.index],this.xhr=null}};Gi.prototype.onLoad=function(){var n;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch{}e==="application/octet-stream"||e==="application/octet-stream; charset=UTF-8"?n=this.xhr.response||this.xhr.responseText:n=this.xhr.responseText}catch(t){this.onError(t)}n!=null&&this.onData(n)};Gi.prototype.hasXDR=function(){return typeof XDomainRequest<"u"&&!this.xs&&this.enablesXDR};Gi.prototype.abort=function(){this.cleanup()};Gi.requestsCount=0;Gi.requests={};if(typeof document<"u"){if(typeof attachEvent=="function")attachEvent("onunload",xH);else if(typeof addEventListener=="function"){var pXe="onpagehide"in dXe?"pagehide":"unload";addEventListener(pXe,xH,!1)}}function xH(){for(var n in Gi.requests)Gi.requests.hasOwnProperty(n)&&Gi.requests[n].abort()}var mXe=EB.exports,MB=See,gXe=jN,SH=kB,yXe=Ww,bXe=/\n/g,vXe=/\\n/g,tT;function wXe(){}function Ww(n){MB.call(this,n),this.query=this.query||{},tT||(tT=SH.___eio=SH.___eio||[]),this.index=tT.length;var e=this;tT.push(function(t){e.onData(t)}),this.query.j=this.index,typeof addEventListener=="function"&&addEventListener("beforeunload",function(){e.script&&(e.script.onerror=wXe)},!1)}gXe(Ww,MB);Ww.prototype.supportsBinary=!1;Ww.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),MB.prototype.doClose.call(this)};Ww.prototype.doPoll=function(){var n=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(s){n.onError("jsonp poll error",s)};var t=document.getElementsByTagName("script")[0];t?t.parentNode.insertBefore(e,t):(document.head||document.body).appendChild(e),this.script=e;var r=typeof navigator<"u"&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var s=document.createElement("iframe");document.body.appendChild(s),document.body.removeChild(s)},100)};Ww.prototype.doWrite=function(n,e){var t=this;if(!this.form){var r=document.createElement("form"),s=document.createElement("textarea"),i=this.iframeId="eio_iframe_"+this.index,o;r.className="socketio",r.style.position="absolute",r.style.top="-1000px",r.style.left="-1000px",r.target=i,r.method="POST",r.setAttribute("accept-charset","utf-8"),s.name="d",r.appendChild(s),document.body.appendChild(r),this.form=r,this.area=s}this.form.action=this.uri();function a(){l(),e()}function l(){if(t.iframe)try{t.form.removeChild(t.iframe)}catch(u){t.onError("jsonp polling iframe removal error",u)}try{var c='<iframe src="javascript:0" name="'+t.iframeId+'">';o=document.createElement(c)}catch{o=document.createElement("iframe"),o.name=t.iframeId,o.src="javascript:0"}o.id=t.iframeId,t.form.appendChild(o),t.iframe=o}l(),n=n.replace(vXe,`\\
`),this.area.value=n.replace(bXe,"\\n");try{this.form.submit()}catch{}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){t.iframe.readyState==="complete"&&a()}:this.iframe.onload=a};var NB=IB(),xXe=Hy,SXe=HN(),_Xe=jN,CXe=vee,kXe=qN("engine.io-client:websocket"),VI,$B;typeof WebSocket<"u"?VI=WebSocket:typeof self<"u"&&(VI=self.WebSocket||self.MozWebSocket);if(typeof window>"u")try{$B=xK}catch{}var Eb=VI||$B,TXe=Ac;function Ac(n){var e=n&&n.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=n.perMessageDeflate,this.usingBrowserWebSocket=VI&&!n.forceNode,this.protocols=n.protocols,this.usingBrowserWebSocket||(Eb=$B),NB.call(this,n)}_Xe(Ac,NB);Ac.prototype.name="websocket";Ac.prototype.supportsBinary=!0;Ac.prototype.doOpen=function(){if(this.check()){var n=this.uri(),e=this.protocols,t={};this.isReactNative||(t.agent=this.agent,t.perMessageDeflate=this.perMessageDeflate,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized),this.extraHeaders&&(t.headers=this.extraHeaders),this.localAddress&&(t.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new Eb(n,e):new Eb(n):new Eb(n,e,t)}catch(r){return this.emit("error",r)}this.ws.binaryType===void 0&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}};Ac.prototype.addEventListeners=function(){var n=this;this.ws.onopen=function(){n.onOpen()},this.ws.onclose=function(){n.onClose()},this.ws.onmessage=function(e){n.onData(e.data)},this.ws.onerror=function(e){n.onError("websocket error",e)}};Ac.prototype.write=function(n){var e=this;this.writable=!1;for(var t=n.length,r=0,s=t;r<s;r++)(function(o){xXe.encodePacket(o,e.supportsBinary,function(a){if(!e.usingBrowserWebSocket){var l={};if(o.options&&(l.compress=o.options.compress),e.perMessageDeflate){var c=typeof a=="string"?Buffer.byteLength(a):a.length;c<e.perMessageDeflate.threshold&&(l.compress=!1)}}try{e.usingBrowserWebSocket?e.ws.send(a):e.ws.send(a,l)}catch{kXe("websocket closed before onclose event")}--t||i()})})(n[r]);function i(){e.emit("flush"),setTimeout(function(){e.writable=!0,e.emit("drain")},0)}};Ac.prototype.onClose=function(){NB.prototype.onClose.call(this)};Ac.prototype.doClose=function(){typeof this.ws<"u"&&this.ws.close()};Ac.prototype.uri=function(){var n=this.query||{},e=this.secure?"wss":"ws",t="";this.port&&(e==="wss"&&Number(this.port)!==443||e==="ws"&&Number(this.port)!==80)&&(t=":"+this.port),this.timestampRequests&&(n[this.timestampParam]=CXe()),this.supportsBinary||(n.b64=1),n=SXe.encode(n),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};Ac.prototype.check=function(){return!!Eb&&!("__initialize"in Eb&&this.name===Ac.prototype.name)};var EXe=TB,IXe=mXe,AXe=yXe,MXe=TXe;GN.polling=NXe;GN.websocket=MXe;function NXe(n){var e,t=!1,r=!1,s=n.jsonp!==!1;if(typeof location<"u"){var i=location.protocol==="https:",o=location.port;o||(o=i?443:80),t=n.hostname!==location.hostname||o!==n.port,r=n.secure!==i}if(n.xdomain=t,n.xscheme=r,e=new EXe(n),"open"in e&&!n.forceJSONP)return new IXe(n);if(!s)throw new Error("JSONP disabled");return new AXe(n)}var $Xe=[].indexOf,Cee=function(n,e){if($Xe)return n.indexOf(e);for(var t=0;t<n.length;++t)if(n[t]===e)return t;return-1},RXe=GN,PXe=Vw,vi=qN("engine.io-client:socket"),DXe=Cee,kee=Hy,_H=lee,OXe=HN(),FXe=fr;function fr(n,e){if(!(this instanceof fr))return new fr(n,e);e=e||{},n&&typeof n=="object"&&(e=n,n=null),n?(n=_H(n),e.hostname=n.host,e.secure=n.protocol==="https"||n.protocol==="wss",e.port=n.port,n.query&&(e.query=n.query)):e.host&&(e.hostname=_H(e.host).host),this.secure=e.secure!=null?e.secure:typeof location<"u"&&location.protocol==="https:",e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=e.port||(typeof location<"u"&&location.port?location.port:this.secure?443:80),this.query=e.query||{},typeof this.query=="string"&&(this.query=OXe.decode(this.query)),this.upgrade=e.upgrade!==!1,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=e.jsonp!==!1,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=e.withCredentials!==!1,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=e.perMessageDeflate!==!1?e.perMessageDeflate||{}:!1,this.perMessageDeflate===!0&&(this.perMessageDeflate={}),this.perMessageDeflate&&this.perMessageDeflate.threshold==null&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||void 0,this.key=e.key||void 0,this.passphrase=e.passphrase||void 0,this.cert=e.cert||void 0,this.ca=e.ca||void 0,this.ciphers=e.ciphers||void 0,this.rejectUnauthorized=e.rejectUnauthorized===void 0?!0:e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative=typeof navigator<"u"&&typeof navigator.product=="string"&&navigator.product.toLowerCase()==="reactnative",(typeof self>"u"||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}fr.priorWebsocketSuccess=!1;PXe(fr.prototype);fr.protocol=kee.protocol;fr.Socket=fr;fr.Transport=IB();fr.transports=GN;fr.parser=Hy;fr.prototype.createTransport=function(n){vi('creating transport "%s"',n);var e=LXe(this.query);e.EIO=kee.protocol,e.transport=n;var t=this.transportOptions[n]||{};this.id&&(e.sid=this.id);var r=new RXe[n]({query:e,socket:this,agent:t.agent||this.agent,hostname:t.hostname||this.hostname,port:t.port||this.port,secure:t.secure||this.secure,path:t.path||this.path,forceJSONP:t.forceJSONP||this.forceJSONP,jsonp:t.jsonp||this.jsonp,forceBase64:t.forceBase64||this.forceBase64,enablesXDR:t.enablesXDR||this.enablesXDR,withCredentials:t.withCredentials||this.withCredentials,timestampRequests:t.timestampRequests||this.timestampRequests,timestampParam:t.timestampParam||this.timestampParam,policyPort:t.policyPort||this.policyPort,pfx:t.pfx||this.pfx,key:t.key||this.key,passphrase:t.passphrase||this.passphrase,cert:t.cert||this.cert,ca:t.ca||this.ca,ciphers:t.ciphers||this.ciphers,rejectUnauthorized:t.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:t.perMessageDeflate||this.perMessageDeflate,extraHeaders:t.extraHeaders||this.extraHeaders,forceNode:t.forceNode||this.forceNode,localAddress:t.localAddress||this.localAddress,requestTimeout:t.requestTimeout||this.requestTimeout,protocols:t.protocols||void 0,isReactNative:this.isReactNative});return r};function LXe(n){var e={};for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e}fr.prototype.open=function(){var n;if(this.rememberUpgrade&&fr.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)n="websocket";else if(this.transports.length===0){var e=this;setTimeout(function(){e.emit("error","No transports available")},0);return}else n=this.transports[0];this.readyState="opening";try{n=this.createTransport(n)}catch{this.transports.shift(),this.open();return}n.open(),this.setTransport(n)};fr.prototype.setTransport=function(n){vi("setting transport %s",n.name);var e=this;this.transport&&(vi("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=n,n.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})};fr.prototype.probe=function(n){vi('probing transport "%s"',n);var e=this.createTransport(n,{probe:1}),t=!1,r=this;fr.priorWebsocketSuccess=!1;function s(){if(r.onlyBinaryUpgrades){var h=!this.supportsBinary&&r.transport.supportsBinary;t=t||h}t||(vi('probe transport "%s" opened',n),e.send([{type:"ping",data:"probe"}]),e.once("packet",function(f){if(!t)if(f.type==="pong"&&f.data==="probe"){if(vi('probe transport "%s" pong',n),r.upgrading=!0,r.emit("upgrading",e),!e)return;fr.priorWebsocketSuccess=e.name==="websocket",vi('pausing current transport "%s"',r.transport.name),r.transport.pause(function(){t||r.readyState!=="closed"&&(vi("changing transport and sending upgrade packet"),u(),r.setTransport(e),e.send([{type:"upgrade"}]),r.emit("upgrade",e),e=null,r.upgrading=!1,r.flush())})}else{vi('probe transport "%s" failed',n);var d=new Error("probe error");d.transport=e.name,r.emit("upgradeError",d)}}))}function i(){t||(t=!0,u(),e.close(),e=null)}function o(h){var f=new Error("probe error: "+h);f.transport=e.name,i(),vi('probe transport "%s" failed because of error: %s',n,h),r.emit("upgradeError",f)}function a(){o("transport closed")}function l(){o("socket closed")}function c(h){e&&h.name!==e.name&&(vi('"%s" works - aborting "%s"',h.name,e.name),i())}function u(){e.removeListener("open",s),e.removeListener("error",o),e.removeListener("close",a),r.removeListener("close",l),r.removeListener("upgrading",c)}e.once("open",s),e.once("error",o),e.once("close",a),this.once("close",l),this.once("upgrading",c),e.open()};fr.prototype.onOpen=function(){if(vi("socket open"),this.readyState="open",fr.priorWebsocketSuccess=this.transport.name==="websocket",this.emit("open"),this.flush(),this.readyState==="open"&&this.upgrade&&this.transport.pause){vi("starting upgrade probes");for(var n=0,e=this.upgrades.length;n<e;n++)this.probe(this.upgrades[n])}};fr.prototype.onPacket=function(n){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")switch(vi('socket receive: type "%s", data "%s"',n.type,n.data),this.emit("packet",n),this.emit("heartbeat"),n.type){case"open":this.onHandshake(JSON.parse(n.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=n.data,this.onError(e);break;case"message":this.emit("data",n.data),this.emit("message",n.data);break}else vi('packet received with socket readyState "%s"',this.readyState)};fr.prototype.onHandshake=function(n){this.emit("handshake",n),this.id=n.sid,this.transport.query.sid=n.sid,this.upgrades=this.filterUpgrades(n.upgrades),this.pingInterval=n.pingInterval,this.pingTimeout=n.pingTimeout,this.onOpen(),this.readyState!=="closed"&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))};fr.prototype.onHeartbeat=function(n){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){e.readyState!=="closed"&&e.onClose("ping timeout")},n||e.pingInterval+e.pingTimeout)};fr.prototype.setPing=function(){var n=this;clearTimeout(n.pingIntervalTimer),n.pingIntervalTimer=setTimeout(function(){vi("writing ping packet - expecting pong within %sms",n.pingTimeout),n.ping(),n.onHeartbeat(n.pingTimeout)},n.pingInterval)};fr.prototype.ping=function(){var n=this;this.sendPacket("ping",function(){n.emit("ping")})};fr.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,this.writeBuffer.length===0?this.emit("drain"):this.flush()};fr.prototype.flush=function(){this.readyState!=="closed"&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(vi("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))};fr.prototype.write=fr.prototype.send=function(n,e,t){return this.sendPacket("message",n,e,t),this};fr.prototype.sendPacket=function(n,e,t,r){if(typeof e=="function"&&(r=e,e=void 0),typeof t=="function"&&(r=t,t=null),!(this.readyState==="closing"||this.readyState==="closed")){t=t||{},t.compress=t.compress!==!1;var s={type:n,data:e,options:t};this.emit("packetCreate",s),this.writeBuffer.push(s),r&&this.once("flush",r),this.flush()}};fr.prototype.close=function(){if(this.readyState==="opening"||this.readyState==="open"){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():e()}):this.upgrading?r():e()}function e(){n.onClose("forced close"),vi("socket closing - telling transport to close"),n.transport.close()}function t(){n.removeListener("upgrade",t),n.removeListener("upgradeError",t),e()}function r(){n.once("upgrade",t),n.once("upgradeError",t)}return this};fr.prototype.onError=function(n){vi("socket error %j",n),fr.priorWebsocketSuccess=!1,this.emit("error",n),this.onClose("transport error",n)};fr.prototype.onClose=function(n,e){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing"){vi('socket close with reason: "%s"',n);var t=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",n,e),t.writeBuffer=[],t.prevBufferLen=0}};fr.prototype.filterUpgrades=function(n){for(var e=[],t=0,r=n.length;t<r;t++)~DXe(this.transports,n[t])&&e.push(n[t]);return e};CB.exports=FXe;CB.exports.parser=Hy;var zXe=CB.exports,y3={exports:{}},b3,CH;function BXe(){if(CH)return b3;CH=1,b3=n;function n(e,t){var r=[];t=t||0;for(var s=t||0;s<e.length;s++)r[s-t]=e[s];return r}return b3}var Tee=VXe;function VXe(n,e,t){return n.on(e,t),{destroy:function(){n.removeListener(e,t)}}}var kH=[].slice,Eee=function(n,e){if(typeof e=="string"&&(e=n[e]),typeof e!="function")throw new Error("bind() requires a function");var t=kH.call(arguments,2);return function(){return e.apply(n,t.concat(kH.call(arguments)))}},TH;function Iee(){return TH||(TH=1,function(n,e){var t=UN,r=Vw,s=BXe(),i=Tee,o=Eee,a=VN("socket.io-client:socket"),l=HN(),c=pee();n.exports=f;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},h=r.prototype.emit;function f(d,p,m){this.io=d,this.nsp=p,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},m&&m.query&&(this.query=m.query),this.io.autoConnect&&this.open()}r(f.prototype),f.prototype.subEvents=function(){if(!this.subs){var d=this.io;this.subs=[i(d,"open",o(this,"onopen")),i(d,"packet",o(this,"onpacket")),i(d,"close",o(this,"onclose"))]}},f.prototype.open=f.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.reconnecting||this.io.open(),this.io.readyState==="open"&&this.onopen(),this.emit("connecting"),this)},f.prototype.send=function(){var d=s(arguments);return d.unshift("message"),this.emit.apply(this,d),this},f.prototype.emit=function(d){if(u.hasOwnProperty(d))return h.apply(this,arguments),this;var p=s(arguments),m={type:(this.flags.binary!==void 0?this.flags.binary:c(p))?t.BINARY_EVENT:t.EVENT,data:p};return m.options={},m.options.compress=!this.flags||this.flags.compress!==!1,typeof p[p.length-1]=="function"&&(a("emitting packet with ack id %d",this.ids),this.acks[this.ids]=p.pop(),m.id=this.ids++),this.connected?this.packet(m):this.sendBuffer.push(m),this.flags={},this},f.prototype.packet=function(d){d.nsp=this.nsp,this.io.packet(d)},f.prototype.onopen=function(){if(a("transport is open - connecting"),this.nsp!=="/")if(this.query){var d=typeof this.query=="object"?l.encode(this.query):this.query;a("sending connect packet with query %s",d),this.packet({type:t.CONNECT,query:d})}else this.packet({type:t.CONNECT})},f.prototype.onclose=function(d){a("close (%s)",d),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",d)},f.prototype.onpacket=function(d){var p=d.nsp===this.nsp,m=d.type===t.ERROR&&d.nsp==="/";if(!(!p&&!m))switch(d.type){case t.CONNECT:this.onconnect();break;case t.EVENT:this.onevent(d);break;case t.BINARY_EVENT:this.onevent(d);break;case t.ACK:this.onack(d);break;case t.BINARY_ACK:this.onack(d);break;case t.DISCONNECT:this.ondisconnect();break;case t.ERROR:this.emit("error",d.data);break}},f.prototype.onevent=function(d){var p=d.data||[];a("emitting event %j",p),d.id!=null&&(a("attaching ack callback to event"),p.push(this.ack(d.id))),this.connected?h.apply(this,p):this.receiveBuffer.push(p)},f.prototype.ack=function(d){var p=this,m=!1;return function(){if(!m){m=!0;var g=s(arguments);a("sending ack %j",g),p.packet({type:c(g)?t.BINARY_ACK:t.ACK,id:d,data:g})}}},f.prototype.onack=function(d){var p=this.acks[d.id];typeof p=="function"?(a("calling ack %s with %j",d.id,d.data),p.apply(this,d.data),delete this.acks[d.id]):a("bad ack %s",d.id)},f.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emitBuffered(),this.emit("connect")},f.prototype.emitBuffered=function(){var d;for(d=0;d<this.receiveBuffer.length;d++)h.apply(this,this.receiveBuffer[d]);for(this.receiveBuffer=[],d=0;d<this.sendBuffer.length;d++)this.packet(this.sendBuffer[d]);this.sendBuffer=[]},f.prototype.ondisconnect=function(){a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},f.prototype.destroy=function(){if(this.subs){for(var d=0;d<this.subs.length;d++)this.subs[d].destroy();this.subs=null}this.io.destroy(this)},f.prototype.close=f.prototype.disconnect=function(){return this.connected&&(a("performing disconnect (%s)",this.nsp),this.packet({type:t.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},f.prototype.compress=function(d){return this.flags.compress=d,this},f.prototype.binary=function(d){return this.flags.binary=d,this}}(y3)),y3.exports}var UXe=Gw;function Gw(n){n=n||{},this.ms=n.min||100,this.max=n.max||1e4,this.factor=n.factor||2,this.jitter=n.jitter>0&&n.jitter<=1?n.jitter:0,this.attempts=0}Gw.prototype.duration=function(){var n=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),t=Math.floor(e*this.jitter*n);n=Math.floor(e*10)&1?n+t:n-t}return Math.min(n,this.max)|0};Gw.prototype.reset=function(){this.attempts=0};Gw.prototype.setMin=function(n){this.ms=n};Gw.prototype.setMax=function(n){this.max=n};Gw.prototype.setJitter=function(n){this.jitter=n};var WXe=zXe,GXe=Iee(),HXe=Vw,jXe=UN,Cd=Tee,A0=Eee,Uo=VN("socket.io-client:manager"),Aee=Cee,qXe=UXe,Mee=Object.prototype.hasOwnProperty,EH=Cr;function Cr(n,e){if(!(this instanceof Cr))return new Cr(n,e);n&&typeof n=="object"&&(e=n,n=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new qXe({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(e.timeout==null?2e4:e.timeout),this.readyState="closed",this.uri=n,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var t=e.parser||jXe;this.encoder=new t.Encoder,this.decoder=new t.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}Cr.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var n in this.nsps)Mee.call(this.nsps,n)&&this.nsps[n].emit.apply(this.nsps[n],arguments)};Cr.prototype.updateSocketIds=function(){for(var n in this.nsps)Mee.call(this.nsps,n)&&(this.nsps[n].id=this.generateId(n))};Cr.prototype.generateId=function(n){return(n==="/"?"":n+"#")+this.engine.id};HXe(Cr.prototype);Cr.prototype.reconnection=function(n){return arguments.length?(this._reconnection=!!n,this):this._reconnection};Cr.prototype.reconnectionAttempts=function(n){return arguments.length?(this._reconnectionAttempts=n,this):this._reconnectionAttempts};Cr.prototype.reconnectionDelay=function(n){return arguments.length?(this._reconnectionDelay=n,this.backoff&&this.backoff.setMin(n),this):this._reconnectionDelay};Cr.prototype.randomizationFactor=function(n){return arguments.length?(this._randomizationFactor=n,this.backoff&&this.backoff.setJitter(n),this):this._randomizationFactor};Cr.prototype.reconnectionDelayMax=function(n){return arguments.length?(this._reconnectionDelayMax=n,this.backoff&&this.backoff.setMax(n),this):this._reconnectionDelayMax};Cr.prototype.timeout=function(n){return arguments.length?(this._timeout=n,this):this._timeout};Cr.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()};Cr.prototype.open=Cr.prototype.connect=function(n,e){if(Uo("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;Uo("opening %s",this.uri),this.engine=WXe(this.uri,this.opts);var t=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var s=Cd(t,"open",function(){r.onopen(),n&&n()}),i=Cd(t,"error",function(l){if(Uo("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",l),n){var c=new Error("Connection error");c.data=l,n(c)}else r.maybeReconnectOnOpen()});if(this._timeout!==!1){var o=this._timeout;Uo("connect attempt will timeout after %d",o),o===0&&s.destroy();var a=setTimeout(function(){Uo("connect attempt timed out after %d",o),s.destroy(),t.close(),t.emit("error","timeout"),r.emitAll("connect_timeout",o)},o);this.subs.push({destroy:function(){clearTimeout(a)}})}return this.subs.push(s),this.subs.push(i),this};Cr.prototype.onopen=function(){Uo("open"),this.cleanup(),this.readyState="open",this.emit("open");var n=this.engine;this.subs.push(Cd(n,"data",A0(this,"ondata"))),this.subs.push(Cd(n,"ping",A0(this,"onping"))),this.subs.push(Cd(n,"pong",A0(this,"onpong"))),this.subs.push(Cd(n,"error",A0(this,"onerror"))),this.subs.push(Cd(n,"close",A0(this,"onclose"))),this.subs.push(Cd(this.decoder,"decoded",A0(this,"ondecoded")))};Cr.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")};Cr.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)};Cr.prototype.ondata=function(n){this.decoder.add(n)};Cr.prototype.ondecoded=function(n){this.emit("packet",n)};Cr.prototype.onerror=function(n){Uo("error",n),this.emitAll("error",n)};Cr.prototype.socket=function(n,e){var t=this.nsps[n];if(!t){t=new GXe(this,n,e),this.nsps[n]=t;var r=this;t.on("connecting",s),t.on("connect",function(){t.id=r.generateId(n)}),this.autoConnect&&s()}function s(){~Aee(r.connecting,t)||r.connecting.push(t)}return t};Cr.prototype.destroy=function(n){var e=Aee(this.connecting,n);~e&&this.connecting.splice(e,1),!this.connecting.length&&this.close()};Cr.prototype.packet=function(n){Uo("writing packet %j",n);var e=this;n.query&&n.type===0&&(n.nsp+="?"+n.query),e.encoding?e.packetBuffer.push(n):(e.encoding=!0,this.encoder.encode(n,function(t){for(var r=0;r<t.length;r++)e.engine.write(t[r],n.options);e.encoding=!1,e.processPacketQueue()}))};Cr.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var n=this.packetBuffer.shift();this.packet(n)}};Cr.prototype.cleanup=function(){Uo("cleanup");for(var n=this.subs.length,e=0;e<n;e++){var t=this.subs.shift();t.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()};Cr.prototype.close=Cr.prototype.disconnect=function(){Uo("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,this.readyState==="opening"&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()};Cr.prototype.onclose=function(n){Uo("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",n),this._reconnection&&!this.skipReconnect&&this.reconnect()};Cr.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var n=this;if(this.backoff.attempts>=this._reconnectionAttempts)Uo("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();Uo("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var t=setTimeout(function(){n.skipReconnect||(Uo("attempting reconnect"),n.emitAll("reconnect_attempt",n.backoff.attempts),n.emitAll("reconnecting",n.backoff.attempts),!n.skipReconnect&&n.open(function(r){r?(Uo("reconnect attempt error"),n.reconnecting=!1,n.reconnect(),n.emitAll("reconnect_error",r.data)):(Uo("reconnect success"),n.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(t)}})}};Cr.prototype.onreconnect=function(){var n=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",n)};(function(n,e){var t=w7e,r=UN,s=EH,i=VN("socket.io-client");n.exports=e=a;var o=e.managers={};function a(l,c){typeof l=="object"&&(c=l,l=void 0),c=c||{};var u=t(l),h=u.source,f=u.id,d=u.path,p=o[f]&&d in o[f].nsps,m=c.forceNew||c["force new connection"]||c.multiplex===!1||p,g;return m?(i("ignoring socket cache for %s",h),g=s(h,c)):(o[f]||(i("new io instance for %s",h),o[f]=s(h,c)),g=o[f]),u.query&&!c.query&&(c.query=u.query),g.socket(u.path,c)}e.protocol=r.protocol,e.connect=a,e.Manager=EH,e.Socket=Iee()})(zD,zD.exports);var XXe=zD.exports;const KXe=Ay(XXe);var ZD={exports:{}},XN={},JD={exports:{}},v3,IH;function YXe(){if(IH)return v3;IH=1;var n=1e3,e=n*60,t=e*60,r=t*24,s=r*7,i=r*365.25;v3=function(u,h){h=h||{};var f=typeof u;if(f==="string"&&u.length>0)return o(u);if(f==="number"&&isFinite(u))return h.long?l(u):a(u);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(u))};function o(u){if(u=String(u),!(u.length>100)){var h=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(u);if(h){var f=parseFloat(h[1]),d=(h[2]||"ms").toLowerCase();switch(d){case"years":case"year":case"yrs":case"yr":case"y":return f*i;case"weeks":case"week":case"w":return f*s;case"days":case"day":case"d":return f*r;case"hours":case"hour":case"hrs":case"hr":case"h":return f*t;case"minutes":case"minute":case"mins":case"min":case"m":return f*e;case"seconds":case"second":case"secs":case"sec":case"s":return f*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return f;default:return}}}}function a(u){var h=Math.abs(u);return h>=r?Math.round(u/r)+"d":h>=t?Math.round(u/t)+"h":h>=e?Math.round(u/e)+"m":h>=n?Math.round(u/n)+"s":u+"ms"}function l(u){var h=Math.abs(u);return h>=r?c(u,h,r,"day"):h>=t?c(u,h,t,"hour"):h>=e?c(u,h,e,"minute"):h>=n?c(u,h,n,"second"):u+" ms"}function c(u,h,f,d){var p=h>=f*1.5;return Math.round(u/f)+" "+d+(p?"s":"")}return v3}function ZXe(n){t.debug=t,t.default=t,t.coerce=l,t.disable=i,t.enable=s,t.enabled=o,t.humanize=YXe(),t.destroy=c,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let f=0;f<u.length;f++)h=(h<<5)-h+u.charCodeAt(f),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u){let h,f=null,d,p;function m(...g){if(!m.enabled)return;const y=m,b=Number(new Date),x=b-(h||b);y.diff=x,y.prev=h,y.curr=b,h=b,g[0]=t.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let w=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(C,k)=>{if(C==="%%")return"%";w++;const A=t.formatters[k];if(typeof A=="function"){const M=g[w];C=A.call(y,M),g.splice(w,1),w--}return C}),t.formatArgs.call(y,g),(y.log||t.log).apply(y,g)}return m.namespace=u,m.useColors=t.useColors(),m.color=t.selectColor(u),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(d!==t.namespaces&&(d=t.namespaces,p=t.enabled(u)),p),set:g=>{f=g}}),typeof t.init=="function"&&t.init(m),m}function r(u,h){const f=t(this.namespace+(typeof h>"u"?":":h)+u);return f.log=this.log,f}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const f=(typeof u=="string"?u:"").split(/[\s,]+/),d=f.length;for(h=0;h<d;h++)f[h]&&(u=f[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.slice(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,f;for(h=0,f=t.skips.length;h<f;h++)if(t.skips[h].test(u))return!1;for(h=0,f=t.names.length;h<f;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function l(u){return u instanceof Error?u.stack||u.message:u}function c(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}var JXe=ZXe;(function(n,e){e.formatArgs=r,e.save=s,e.load=i,e.useColors=t,e.storage=o(),e.destroy=(()=>{let l=!1;return()=>{l||(l=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function r(l){if(l[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+l[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;l.splice(1,0,c,"color: inherit");let u=0,h=0;l[0].replace(/%[a-zA-Z%]/g,f=>{f!=="%%"&&(u++,f==="%c"&&(h=u))}),l.splice(h,0,c)}e.log=console.debug||console.log||(()=>{});function s(l){try{l?e.storage.setItem("debug",l):e.storage.removeItem("debug")}catch{}}function i(){let l;try{l=e.storage.getItem("debug")}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}function o(){try{return localStorage}catch{}}n.exports=JXe(e);const{formatters:a}=n.exports;a.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}}})(JD,JD.exports);var RB=JD.exports;const AH=RB("@feathersjs/errors");function Qn(n,e,t,r,s){n=n||"Error";let i,o,a;n instanceof Error?(o=n.message||"Error",n.errors&&(i=n.errors)):typeof n=="object"?(o=n.message||"Error",s=n):o=n,s&&(a=JSON.parse(JSON.stringify(s)),a.errors?(i=a.errors,delete a.errors):s.errors&&(i=JSON.parse(JSON.stringify(s.errors)))),this.type="FeathersError",this.name=e,this.message=o,this.code=t,this.className=r,this.data=a,this.errors=i||{},AH(`${this.name}(${this.code}): ${this.message}`),AH(this.errors),Error.captureStackTrace?Error.captureStackTrace(this,Qn):this.stack=new Error().stack}function uo(n,e){n.prototype=Object.create(e.prototype),n.prototype.constructor=n}uo(Qn,Error);Object.defineProperty(Qn.prototype,"toJSON",{value:function(){return{name:this.name,message:this.message,code:this.code,className:this.className,data:this.data,errors:this.errors}}});function QD(n,e){Qn.call(this,n,"BadRequest",400,"bad-request",e)}uo(QD,Qn);function eO(n,e){Qn.call(this,n,"NotAuthenticated",401,"not-authenticated",e)}uo(eO,Qn);function tO(n,e){Qn.call(this,n,"PaymentError",402,"payment-error",e)}uo(tO,Qn);function nO(n,e){Qn.call(this,n,"Forbidden",403,"forbidden",e)}uo(nO,Qn);function rO(n,e){Qn.call(this,n,"NotFound",404,"not-found",e)}uo(rO,Qn);function sO(n,e){Qn.call(this,n,"MethodNotAllowed",405,"method-not-allowed",e)}uo(sO,Qn);function iO(n,e){Qn.call(this,n,"NotAcceptable",406,"not-acceptable",e)}uo(iO,Qn);function oO(n,e){Qn.call(this,n,"Timeout",408,"timeout",e)}uo(oO,Qn);function aO(n,e){Qn.call(this,n,"Conflict",409,"conflict",e)}uo(aO,Qn);function lO(n,e){Qn(this,n,"Gone",410,"gone")}uo(lO,Qn);function cO(n,e){Qn.call(this,n,"LengthRequired",411,"length-required",e)}uo(cO,Qn);function uO(n,e){Qn.call(this,n,"Unprocessable",422,"unprocessable",e)}uo(uO,Qn);function hO(n,e){Qn.call(this,n,"TooManyRequests",429,"too-many-requests",e)}uo(hO,Qn);function fO(n,e){Qn.call(this,n,"GeneralError",500,"general-error",e)}uo(fO,Qn);function dO(n,e){Qn.call(this,n,"NotImplemented",501,"not-implemented",e)}uo(dO,Qn);function pO(n,e){Qn.call(this,n,"BadGateway",502,"bad-gateway",e)}uo(pO,Qn);function mO(n,e){Qn.call(this,n,"Unavailable",503,"unavailable",e)}uo(mO,Qn);const Nee={FeathersError:Qn,BadRequest:QD,NotAuthenticated:eO,PaymentError:tO,Forbidden:nO,NotFound:rO,MethodNotAllowed:sO,NotAcceptable:iO,Timeout:oO,Conflict:aO,Gone:lO,LengthRequired:cO,Unprocessable:uO,TooManyRequests:hO,GeneralError:fO,NotImplemented:dO,BadGateway:pO,Unavailable:mO,400:QD,401:eO,402:tO,403:nO,404:rO,405:sO,406:iO,408:oO,409:aO,410:lO,411:cO,422:uO,429:hO,500:fO,501:dO,502:pO,503:mO};function QXe(n){if(!n)return n;const e=Nee[n.name],t=e?new e(n.message,n.data):new Error(n.message||n);return typeof n=="object"&&Object.assign(t,n),t}var bC=Object.assign({convert:QXe},Nee),fg={};Object.defineProperty(fg,"__esModule",{value:!0});fg.StorageWrapper=fg.MemoryStorage=void 0;class eKe{constructor(){this.store={}}getItem(e){return Promise.resolve(this.store[e])}setItem(e,t){return Promise.resolve(this.store[e]=t)}removeItem(e){const t=this.store[e];return delete this.store[e],Promise.resolve(t)}}fg.MemoryStorage=eKe;class tKe{constructor(e){this.storage=e}getItem(e){return Promise.resolve(this.storage.getItem(e))}setItem(e,t){return Promise.resolve(this.storage.setItem(e,t))}removeItem(e){return Promise.resolve(this.storage.removeItem(e))}}fg.StorageWrapper=tKe;Object.defineProperty(XN,"__esModule",{value:!0});XN.AuthenticationClient=void 0;const MH=bC,nKe=fg,NH=(n,e)=>{const t=new RegExp(`(?:&?)${e}=([^&]*)`),r=n.hash?n.hash.match(t):null;if(r!==null){const[,s]=r;return[s,t]}return[null,t]};class rKe{constructor(e,t){const r=e.io||e.primus,s=new nKe.StorageWrapper(e.get("storage")||t.storage);this.app=e,this.options=t,this.authenticated=!1,this.app.set("storage",s),r&&this.handleSocket(r)}get service(){return this.app.service(this.options.path)}get storage(){return this.app.get("storage")}handleSocket(e){const t=this.app.io?"connect":"open",r=this.app.io?"disconnect":"disconnection";e.on(r,()=>{const s=new Promise(i=>e.once(t,o=>i(o))).then(()=>this.authenticated?this.reAuthenticate(!0):null);this.app.set("authentication",s)})}getFromLocation(e){const[t,r]=NH(e,this.options.locationKey);if(t!==null)return e.hash=e.hash.replace(r,""),Promise.resolve(t);const[s,i]=NH(e,this.options.locationErrorKey);return s!==null?(e.hash=e.hash.replace(i,""),Promise.reject(new MH.NotAuthenticated(decodeURIComponent(s)))):Promise.resolve(null)}setAccessToken(e){return this.storage.setItem(this.options.storageKey,e)}getAccessToken(){return this.storage.getItem(this.options.storageKey).then(e=>!e&&typeof window<"u"&&window.location?this.getFromLocation(window.location):e||null)}removeAccessToken(){return this.storage.removeItem(this.options.storageKey)}reset(){return this.app.set("authentication",null),this.authenticated=!1,Promise.resolve(null)}handleError(e,t){if(e.code===401||e.code===403){const r=this.removeAccessToken().then(()=>this.reset());return t==="logout"?r:r.then(()=>Promise.reject(e))}return Promise.reject(e)}reAuthenticate(e=!1,t){const r=this.app.get("authentication");return!r||e===!0?this.getAccessToken().then(s=>{if(!s)throw new MH.NotAuthenticated("No accessToken found in storage");return this.authenticate({strategy:t||this.options.jwtStrategy,accessToken:s})}):r}authenticate(e,t){if(!e)return this.reAuthenticate();const r=this.service.create(e,t).then(s=>{const{accessToken:i}=s;return this.authenticated=!0,this.app.emit("login",s),this.app.emit("authenticated",s),this.setAccessToken(i).then(()=>s)}).catch(s=>this.handleError(s,"authenticate"));return this.app.set("authentication",r),r}logout(){return Promise.resolve(this.app.get("authentication")).then(()=>this.service.remove(null).then(e=>this.removeAccessToken().then(()=>this.reset()).then(()=>(this.app.emit("logout",e),e)))).catch(e=>this.handleError(e,"logout"))}}XN.AuthenticationClient=rKe;var $ee={},KN={},Np={},gi={},PB={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.createSymbol=n.makeUrl=n.isPromise=n._=n.stripSlashes=void 0;function e(i){return i.replace(/^(\/+)|(\/+)$/g,"")}n.stripSlashes=e,n._={each(i,o){i&&typeof i.forEach=="function"?i.forEach(o):n._.isObject(i)&&Object.keys(i).forEach(a=>o(i[a],a))},some(i,o){return Object.keys(i).map(a=>[i[a],a]).some(([a,l])=>o(a,l))},every(i,o){return Object.keys(i).map(a=>[i[a],a]).every(([a,l])=>o(a,l))},keys(i){return Object.keys(i)},values(i){return n._.keys(i).map(o=>i[o])},isMatch(i,o){return n._.keys(o).every(a=>i[a]===o[a])},isEmpty(i){return n._.keys(i).length===0},isObject(i){return typeof i=="object"&&!Array.isArray(i)&&i!==null},isObjectOrArray(i){return typeof i=="object"&&i!==null},extend(i,...o){return Object.assign(i,...o)},omit(i,...o){const a=n._.extend({},i);return o.forEach(l=>delete a[l]),a},pick(i,...o){return o.reduce((a,l)=>(i[l]!==void 0&&(a[l]=i[l]),a),{})},merge(i,o){return n._.isObject(i)&&n._.isObject(o)&&Object.keys(o).forEach(a=>{n._.isObject(o[a])?(i[a]||Object.assign(i,{[a]:{}}),n._.merge(i[a],o[a])):Object.assign(i,{[a]:o[a]})}),i}};function t(i){return n._.isObject(i)&&typeof i.then=="function"}n.isPromise=t;function r(i,o={}){const a=typeof o.get=="function"?o.get.bind(o):()=>{},l=a("env")||"production",c=a("host")||{}.HOST_NAME||"localhost",u=l==="development"||l==="test"||l===void 0?"http":"https",h=a("port")||{}.PORT||3030,f=l==="development"||l==="test"||l===void 0?`:${h}`:"";return i=i||"",`${u}://${c}${f}/${n.stripSlashes(i)}`}n.makeUrl=r;function s(i){return typeof Symbol<"u"?Symbol(i):i}n.createSymbol=s})(PB);Object.defineProperty(gi,"__esModule",{value:!0});gi.enableHooks=gi.processHooks=gi.getHooks=gi.isHookObject=gi.convertHookData=gi.makeArguments=gi.defaultMakeArguments=gi.createHookObject=gi.ACTIVATE_HOOKS=void 0;const Ree=PB,{each:gO,pick:sKe}=Ree._;gi.ACTIVATE_HOOKS=(0,Ree.createSymbol)("__feathersActivateHooks");function iKe(n,e={}){const t={};return Object.defineProperty(t,"toJSON",{value(){return sKe(this,"type","method","path","params","id","data","result","error")}}),Object.assign(t,e,{method:n,get path(){const{app:r,service:s}=e;return!s||!r||!r.services?null:Object.keys(r.services).find(i=>r.services[i]===s)}})}gi.createHookObject=iKe;function Pee(n){const e=[];return typeof n.id<"u"&&e.push(n.id),n.data&&e.push(n.data),e.push(n.params||{}),e}gi.defaultMakeArguments=Pee;function oKe(n){switch(n.method){case"find":return[n.params];case"get":case"remove":return[n.id,n.params];case"update":case"patch":return[n.id,n.data,n.params];case"create":return[n.data,n.params]}return Pee(n)}gi.makeArguments=oKe;function Dee(n){let e={};return Array.isArray(n)?e={all:n}:typeof n!="object"?e={all:[n]}:gO(n,function(t,r){e[r]=Array.isArray(t)?t:[t]}),e}gi.convertHookData=Dee;function Oee(n){return typeof n=="object"&&typeof n.method=="string"&&typeof n.type=="string"}gi.isHookObject=Oee;function aKe(n,e,t,r,s=!1){const i=n.__hooks[t][r]||[],o=e.__hooks[t][r]||[];return s?o.concat(i):i.concat(o)}gi.getHooks=aKe;function lKe(n,e){let t=e;const r=i=>{if(i){if(!Oee(i))throw new Error(`${t.type} hook for '${t.method}' method returned invalid hook object`);t=i}return t};return n.reduce((i,o)=>{const a=o.bind(this);return i.then(l=>a(l)).then(r)},Promise.resolve(t)).then(()=>t).catch(i=>{throw i.hook=t,i})}gi.processHooks=lKe;function cKe(n,e,t){if(typeof n.hooks=="function")return n;const r={};return t.forEach(s=>{r[s]={}}),Object.defineProperty(n,"__hooks",{configurable:!0,value:r,writable:!0}),Object.assign(n,{hooks(s){return gO(s,(i,o)=>{if(!this.__hooks[o])throw new Error(`'${o}' is not a valid hook type`);const a=Dee(i);gO(a,(l,c)=>{if(c!=="all"&&e.indexOf(c)===-1)throw new Error(`'${c}' is not a valid hook method`)}),e.forEach(l=>{const c=this.__hooks[o][l]||(this.__hooks[o][l]=[]);a.all&&c.push.apply(c,a.all),a[l]&&c.push.apply(c,a[l])})}),this}})}gi.enableHooks=cKe;(function(n){var e=mt&&mt.__createBinding||(Object.create?function(o,a,l,c){c===void 0&&(c=l);var u=Object.getOwnPropertyDescriptor(a,l);(!u||("get"in u?!a.__esModule:u.writable||u.configurable))&&(u={enumerable:!0,get:function(){return a[l]}}),Object.defineProperty(o,c,u)}:function(o,a,l,c){c===void 0&&(c=l),o[c]=a[l]}),t=mt&&mt.__setModuleDefault||(Object.create?function(o,a){Object.defineProperty(o,"default",{enumerable:!0,value:a})}:function(o,a){o.default=a}),r=mt&&mt.__importStar||function(o){if(o&&o.__esModule)return o;var a={};if(o!=null)for(var l in o)l!=="default"&&Object.prototype.hasOwnProperty.call(o,l)&&e(a,o,l);return t(a,o),a},s=mt&&mt.__exportStar||function(o,a){for(var l in o)l!=="default"&&!Object.prototype.hasOwnProperty.call(a,l)&&e(a,o,l)};Object.defineProperty(n,"__esModule",{value:!0}),n.hooks=void 0;const i=r(gi);s(PB,n),n.hooks=i})(Np);Object.defineProperty(KN,"__esModule",{value:!0});KN.authentication=void 0;const uKe=Np,hKe=()=>n=>{const{app:e,params:t,path:r,method:s,app:{authentication:i}}=n;return(0,uKe.stripSlashes)(i.options.path)===r&&s==="create"?n:Promise.resolve(e.get("authentication")).then(o=>(o&&(n.params=Object.assign({},o,t)),n))};KN.authentication=hKe;var YN={};Object.defineProperty(YN,"__esModule",{value:!0});YN.populateHeader=void 0;const fKe=()=>n=>{const{app:e,params:{accessToken:t}}=n,r=e.authentication;if(e.rest&&t){const{scheme:s,header:i}=r.options,o=`${s} ${t}`;n.params.headers=Object.assign({},{[i]:o},n.params.headers)}return n};YN.populateHeader=fKe;(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.populateHeader=n.authentication=void 0;var e=KN;Object.defineProperty(n,"authentication",{enumerable:!0,get:function(){return e.authentication}});var t=YN;Object.defineProperty(n,"populateHeader",{enumerable:!0,get:function(){return t.populateHeader}})})($ee);(function(n,e){var t=mt&&mt.__createBinding||(Object.create?function(u,h,f,d){d===void 0&&(d=f);var p=Object.getOwnPropertyDescriptor(h,f);(!p||("get"in p?!h.__esModule:p.writable||p.configurable))&&(p={enumerable:!0,get:function(){return h[f]}}),Object.defineProperty(u,d,p)}:function(u,h,f,d){d===void 0&&(d=f),u[d]=h[f]}),r=mt&&mt.__setModuleDefault||(Object.create?function(u,h){Object.defineProperty(u,"default",{enumerable:!0,value:h})}:function(u,h){u.default=h}),s=mt&&mt.__importStar||function(u){if(u&&u.__esModule)return u;var h={};if(u!=null)for(var f in u)f!=="default"&&Object.prototype.hasOwnProperty.call(u,f)&&t(h,u,f);return r(h,u),h};Object.defineProperty(e,"__esModule",{value:!0}),e.defaults=e.defaultStorage=e.hooks=e.MemoryStorage=e.AuthenticationClient=e.getDefaultStorage=void 0;const i=XN;Object.defineProperty(e,"AuthenticationClient",{enumerable:!0,get:function(){return i.AuthenticationClient}});const o=s($ee);e.hooks=o;const a=fg;Object.defineProperty(e,"MemoryStorage",{enumerable:!0,get:function(){return a.MemoryStorage}});const l=()=>{try{return new a.StorageWrapper(window.localStorage)}catch{}return new a.MemoryStorage};e.getDefaultStorage=l,e.defaultStorage=(0,e.getDefaultStorage)(),e.defaults={header:"Authorization",scheme:"Bearer",storageKey:"feathers-jwt",locationKey:"access_token",locationErrorKey:"error",jwtStrategy:"jwt",path:"/authentication",Authentication:i.AuthenticationClient,storage:e.defaultStorage};const c=(u={})=>{const h=Object.assign({},e.defaults,u),{Authentication:f}=h;return d=>{const p=new f(d,h);d.authentication=p,d.authenticate=p.authenticate.bind(p),d.reAuthenticate=p.reAuthenticate.bind(p),d.logout=p.logout.bind(p),d.hooks({before:{all:[o.authentication(),o.populateHeader()]}})}};e.default=c,n.exports=Object.assign(c,n.exports)})(ZD,ZD.exports);var dKe=ZD.exports;const pKe=Ay(dKe);var DB={exports:{}},Fee={exports:{}};(function(n,e){(function(t,r){n.exports=r()})(mt,function(){var t=typeof Object.getOwnPropertySymbols=="function";function r(s,i,o,a){var l=typeof i=="function",c=function(){var u=this._super;this._super=l?i:s[o];var h=a.apply(this,arguments);return this._super=u,h};return l&&(Object.keys(i).forEach(function(u){c[u]=i[u]}),t&&Object.getOwnPropertySymbols(i).forEach(function(u){c[u]=i[u]})),c}return{create:function(){var s=Object.create(this),i=typeof s.__init=="string"?s.__init:"init";return typeof s[i]=="function"&&s[i].apply(s,arguments),s},mixin:function(s,i){var o=i||this,a=/\b_super\b/,l=Object.getPrototypeOf(o)||o.prototype,c={},u=s,h=function(d){var p=Object.getOwnPropertyDescriptor(u,d);!c[d]&&p&&(c[d]=p)};do Object.getOwnPropertyNames(u).forEach(h),t&&Object.getOwnPropertySymbols(u).forEach(h);while((u=Object.getPrototypeOf(u))&&Object.getPrototypeOf(u));var f=function(d){var p=c[d];typeof p.value=="function"&&a.test(p.value)&&(p.value=r(l,o[d],d,p.value)),Object.defineProperty(o,d,p)};return Object.keys(c).forEach(f),t&&Object.getOwnPropertySymbols(c).forEach(f),o},extend:function(s,i){return this.mixin(s,Object.create(i||this))},proxy:function(s){var i=this[s],o=Array.prototype.slice.call(arguments,1);return o.unshift(this),i.bind.apply(i,o)}}})})(Fee);var OB=Fee.exports,yO={exports:{}},FB={exports:{}},Ib=typeof Reflect=="object"?Reflect:null,$H=Ib&&typeof Ib.apply=="function"?Ib.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},DE;Ib&&typeof Ib.ownKeys=="function"?DE=Ib.ownKeys:Object.getOwnPropertySymbols?DE=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:DE=function(e){return Object.getOwnPropertyNames(e)};function mKe(n){console&&console.warn&&console.warn(n)}var Lee=Number.isNaN||function(e){return e!==e};function Xr(){Xr.init.call(this)}FB.exports=Xr;FB.exports.once=vKe;Xr.EventEmitter=Xr;Xr.prototype._events=void 0;Xr.prototype._eventsCount=0;Xr.prototype._maxListeners=void 0;var RH=10;function ZN(n){if(typeof n!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(Xr,"defaultMaxListeners",{enumerable:!0,get:function(){return RH},set:function(n){if(typeof n!="number"||n<0||Lee(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");RH=n}});Xr.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};Xr.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||Lee(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};function zee(n){return n._maxListeners===void 0?Xr.defaultMaxListeners:n._maxListeners}Xr.prototype.getMaxListeners=function(){return zee(this)};Xr.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var s=e==="error",i=this._events;if(i!==void 0)s=s&&i.error===void 0;else if(!s)return!1;if(s){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var l=i[e];if(l===void 0)return!1;if(typeof l=="function")$H(l,this,t);else for(var c=l.length,u=Gee(l,c),r=0;r<c;++r)$H(u[r],this,t);return!0};function Bee(n,e,t,r){var s,i,o;if(ZN(t),i=n._events,i===void 0?(i=n._events=Object.create(null),n._eventsCount=0):(i.newListener!==void 0&&(n.emit("newListener",e,t.listener?t.listener:t),i=n._events),o=i[e]),o===void 0)o=i[e]=t,++n._eventsCount;else if(typeof o=="function"?o=i[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),s=zee(n),s>0&&o.length>s&&!o.warned){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=n,a.type=e,a.count=o.length,mKe(a)}return n}Xr.prototype.addListener=function(e,t){return Bee(this,e,t,!1)};Xr.prototype.on=Xr.prototype.addListener;Xr.prototype.prependListener=function(e,t){return Bee(this,e,t,!0)};function gKe(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function Vee(n,e,t){var r={fired:!1,wrapFn:void 0,target:n,type:e,listener:t},s=gKe.bind(r);return s.listener=t,r.wrapFn=s,s}Xr.prototype.once=function(e,t){return ZN(t),this.on(e,Vee(this,e,t)),this};Xr.prototype.prependOnceListener=function(e,t){return ZN(t),this.prependListener(e,Vee(this,e,t)),this};Xr.prototype.removeListener=function(e,t){var r,s,i,o,a;if(ZN(t),s=this._events,s===void 0)return this;if(r=s[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){a=r[o].listener,i=o;break}if(i<0)return this;i===0?r.shift():yKe(r,i),r.length===1&&(s[e]=r[0]),s.removeListener!==void 0&&this.emit("removeListener",e,a||t)}return this};Xr.prototype.off=Xr.prototype.removeListener;Xr.prototype.removeAllListeners=function(e){var t,r,s;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var i=Object.keys(r),o;for(s=0;s<i.length;++s)o=i[s],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t!==void 0)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this};function Uee(n,e,t){var r=n._events;if(r===void 0)return[];var s=r[e];return s===void 0?[]:typeof s=="function"?t?[s.listener||s]:[s]:t?bKe(s):Gee(s,s.length)}Xr.prototype.listeners=function(e){return Uee(this,e,!0)};Xr.prototype.rawListeners=function(e){return Uee(this,e,!1)};Xr.listenerCount=function(n,e){return typeof n.listenerCount=="function"?n.listenerCount(e):Wee.call(n,e)};Xr.prototype.listenerCount=Wee;function Wee(n){var e=this._events;if(e!==void 0){var t=e[n];if(typeof t=="function")return 1;if(t!==void 0)return t.length}return 0}Xr.prototype.eventNames=function(){return this._eventsCount>0?DE(this._events):[]};function Gee(n,e){for(var t=new Array(e),r=0;r<e;++r)t[r]=n[r];return t}function yKe(n,e){for(;e+1<n.length;e++)n[e]=n[e+1];n.pop()}function bKe(n){for(var e=new Array(n.length),t=0;t<e.length;++t)e[t]=n[t].listener||n[t];return e}function vKe(n,e){return new Promise(function(t,r){function s(o){n.removeListener(e,i),r(o)}function i(){typeof n.removeListener=="function"&&n.removeListener("error",s),t([].slice.call(arguments))}Hee(n,e,i,{once:!0}),e!=="error"&&wKe(n,s,{once:!0})})}function wKe(n,e,t){typeof n.on=="function"&&Hee(n,"error",e,t)}function Hee(n,e,t,r){if(typeof n.on=="function")r.once?n.once(e,t):n.on(e,t);else if(typeof n.addEventListener=="function")n.addEventListener(e,function s(i){r.once&&n.removeEventListener(e,s),t(i)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n)}var xKe=FB.exports;(function(n,e){const{EventEmitter:t}=xKe,r=OB,s=e.eventHook=function(){return function(a){const{app:l,service:c}=a,u=a.event===null?a.event:l.eventMappings[a.method],h=c._hookEvents&&c._hookEvents.indexOf(u)!==-1;u&&h&&a.type!=="error"&&(Array.isArray(a.result)?a.result:[a.result]).forEach(d=>c.emit(u,d,a))}},i=e.eventMixin=function(a){if(a._serviceEvents)return;const l=this,c=typeof a.on=="function"&&typeof a.emit=="function";typeof a.mixin=="function"&&!c&&a.mixin(t.prototype),Object.defineProperties(a,{_serviceEvents:{value:Array.isArray(a.events)?a.events.slice():[]},_hookEvents:{value:[]}}),Object.keys(l.eventMappings).forEach(u=>{const h=l.eventMappings[u],f=a._serviceEvents.indexOf(h)!==-1;typeof a[u]=="function"&&!f&&(a._serviceEvents.push(h),a._hookEvents.push(h))})};n.exports=function(){return function(o){Object.assign(o,{eventMappings:{create:"created",update:"updated",remove:"removed",patch:"patched"}}),o.hooks({finally:s()}),r.mixin(t.prototype,o),o.mixins.push(i)}}})(yO,yO.exports);var SKe=yO.exports,bO={exports:{}};const{_:_Ke}=Np,CKe=n=>{const{service:e,method:t}=n,r=e.methods[t];return n.arguments.forEach((s,i)=>{n[r[i]]=s}),n.params||(n.params={}),n},kKe=n=>{const{service:e,method:t,path:r}=n,s=e.methods[t];if(s.includes("id")&&n.id===void 0)throw new Error(`An id must be provided to the '${r}.${t}' method`);if(s.includes("data")&&!_Ke.isObjectOrArray(n.data))throw new Error(`A data object must be provided to the '${r}.${t}' method`);return n};var TKe=[CKe,kKe];(function(n,e){const{hooks:t,isPromise:r}=Np,s=TKe,{createHookObject:i,getHooks:o,processHooks:a,enableHooks:l,ACTIVATE_HOOKS:c}=t,u=function({app:d,service:p,method:m,original:g}){return(y={})=>{const b=d.hookTypes.reduce((x,w)=>{const _=y[w]||[];return x[w]=Array.isArray(_)?_:[_],x},{});return function(...x){const w=x[x.length-1]===!0?x.pop():!1,_=i(m,{type:"before",arguments:x,service:p,app:d});return Promise.resolve(_).then(C=>a.call(p,s.concat(b.before),C)).then(C=>typeof C.result<"u"?C:new Promise(A=>{const M=g||p[m],I=p.methods[m].map(O=>C[O]),N=M.apply(p,I);if(!r(N))throw new Error(`Service method '${C.method}' for '${C.path}' service must return a promise`);A(N)}).then(A=>(C.result=A,C)).catch(A=>{throw A.hook=C,A})).then(C=>{const k=Object.assign({},C,{type:"after"});return a.call(p,b.after,k)}).catch(C=>{const k=Object.assign({},C.hook,{type:"error",original:C.hook,error:C,result:void 0});return a.call(p,b.error,k).catch(A=>Object.assign({},A.hook,{error:A,result:void 0}))}).then(C=>a.call(p,b.finally,C).catch(k=>Object.assign({},k.hook,{error:k,result:void 0}))).then(C=>typeof C.error<"u"&&typeof C.result>"u"?Promise.reject(w?C:C.error):w?C:C.result)}}},h=e.hookMixin=function(d){if(typeof d.hooks=="function")return;d.methods=Object.getOwnPropertyNames(d).filter(y=>typeof d[y]=="function"&&d[y][c]).reduce((y,b)=>(y[b]=d[b][c],y),d.methods||{}),Object.assign(d.methods,{find:["params"],get:["id","params"],create:["data","params"],update:["id","data","params"],patch:["id","data","params"],remove:["id","params"]});const p=this,m=Object.keys(d.methods),g=m.reduce((y,b)=>(typeof d[b]!="function"||(y[b]=function(){const x=this,w=Array.from(arguments),_=x._super.bind(x);return u({app:p,service:x,method:b,original:_})({before:o(p,x,"before",b),after:o(p,x,"after",b,!0),error:o(p,x,"error",b,!0),finally:o(p,x,"finally",b,!0)})(...w)}),y),{});l(d,m,p.hookTypes),d.mixin(g)};n.exports=function(){return function(f){Object.assign(f,{hookTypes:["before","after","error","finally"]}),l(f,f.methods,f.hookTypes),f.mixins.push(h)}},n.exports.withHooks=u,n.exports.ACTIVATE_HOOKS=c,n.exports.activateHooks=function(d){return p=>(Object.defineProperty(p,c,{value:d}),p)}})(bO,bO.exports);var jee=bO.exports,qee="4.5.17";const w3=RB("feathers:application"),{stripSlashes:PH}=Np,EKe=OB,IKe=SKe,AKe=jee,MKe=qee,DH=EKe.extend({create:null}),NKe={init(){Object.assign(this,{version:MKe,methods:["find","get","create","update","patch","remove"],mixins:[],services:{},providers:[],_setup:!1,settings:{}}),this.configure(AKe()),this.configure(IKe())},get(n){return this.settings[n]},set(n,e){return this.settings[n]=e,this},disable(n){return this.settings[n]=!1,this},disabled(n){return!this.settings[n]},enable(n){return this.settings[n]=!0,this},enabled(n){return!!this.settings[n]},configure(n){return n.call(this,this),this},service(n,e){if(typeof e<"u")throw new Error("Registering a new service with `app.service(path, service)` is no longer supported. Use `app.use(path, service)` instead.");const t=PH(n)||"/",r=this.services.hasOwnProperty(t)?this.services[t]:void 0;return typeof r>"u"&&typeof this.defaultService=="function"?this.use(t,this.defaultService(t)).service(t):r},use(n,e,t={}){if(typeof n!="string")throw new Error(`'${n}' is not a valid service path.`);const r=PH(n)||"/",s=typeof e.service=="function"&&e.services,i=this.methods.concat("setup").some(a=>typeof e[a]=="function");if(s){const a=e;return Object.keys(a.services).forEach(l=>this.use(`${r}/${l}`,a.service(l))),this}if(!i)throw new Error(`Invalid service object passed for path \`${r}\``);const o=DH.isPrototypeOf(e)?e:DH.extend(e);return w3(`Registering new service at \`${r}\``),this.mixins.forEach(a=>a.call(this,o,r,t)),typeof o._setup=="function"&&o._setup(this,r),this.providers.forEach(a=>a.call(this,o,r,t)),this._isSetup&&typeof o.setup=="function"&&(w3(`Setting up service for \`${r}\``),o.setup(this,r)),this.services[r]=o,this},setup(){return Object.keys(this.services).forEach(n=>{const e=this.services[n];w3(`Setting up service for \`${n}\``),typeof e.setup=="function"&&e.setup(this,n)}),this._isSetup=!0,this}};var $Ke=NKe;const RKe=OB,PKe=$Ke,DKe=qee,{ACTIVATE_HOOKS:OKe,activateHooks:FKe}=jee,LKe=Object.create(null);function vC(){const n=Object.create(LKe);return RKe.mixin(PKe,n),n.init(),n}vC.version=DKe;vC.ACTIVATE_HOOKS=OKe;vC.activateHooks=FKe;DB.exports=vC;DB.exports.default=vC;var zKe=DB.exports;const BKe=Ay(zKe);var LB={exports:{}},JN={},VKe=mt&&mt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(JN,"__esModule",{value:!0});JN.Service=void 0;const UKe=VKe(RB),OH=bC,Xee=(0,UKe.default)("@feathersjs/transport-commons/client"),WKe=["addListener","emit","listenerCount","listeners","on","once","prependListener","prependOnceListener","removeAllListeners","removeListener"],GKe=["eventNames","getMaxListeners","setMaxListeners"],HKe=n=>{GKe.forEach(e=>{n[e]=function(...t){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);return this.connection[e](...t)}}),WKe.forEach(e=>{n[e]=function(t,...r){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);const s=`${this.path} ${t}`;Xee(`Calling emitter method ${e} with namespaced event '${s}'`);const i=this.connection[e](s,...r);return i===this.connection?this:i}})};let jKe=class{constructor(e){this.events=e.events,this.path=e.name,this.connection=e.connection,this.method=e.method,this.timeout=e.timeout||5e3,HKe(this)}send(e,...t){return new Promise((r,s)=>{const i=setTimeout(()=>s(new OH.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${e} on ${this.path}`,{timeout:this.timeout,method:e,path:this.path})),this.timeout);t.unshift(e,this.path),t.push(function(o,a){return o=(0,OH.convert)(o),clearTimeout(i),o?s(o):r(a)}),Xee(`Sending socket.${this.method}`,t),this.connection[this.method](...t)})}find(e={}){return this.send("find",e.query||{})}get(e,t={}){return this.send("get",e,t.query||{})}create(e,t={}){return this.send("create",e,t.query||{})}update(e,t,r={}){return this.send("update",e,t,r.query||{})}patch(e,t,r={}){return this.send("patch",e,t,r.query||{})}remove(e,t={}){return this.send("remove",e,t.query||{})}off(e,...t){if(typeof this.connection.off=="function"){const r=this.connection.off(`${this.path} ${e}`,...t);return r===this.connection?this:r}else if(t.length===0)return this.removeAllListeners(e);return this.removeListener(e,...t)}};JN.Service=jKe;var qKe=JN.Service;const FH=qKe;function Kee(n,e){if(!n)throw new Error("Socket.io connection needs to be provided");if(n&&n.io&&n.io.engine&&n.io.engine.transport&&n.io.engine.transport.query&&n.io.engine.transport.query.EIO>3)throw console.error("You are trying to use the Socket.io client version 3 or later with Feathers v4 which only supports Socket.io version 2. Please use socket.io-client version 2 instead."),new Error("socket.io-client must be version 2.x");const t=function(s){const i=Object.keys(this.eventMappings||{}).map(a=>this.eventMappings[a]),o=Object.assign({},e,{events:i,name:s,connection:n,method:"emit"});return new FH(o)},r=function(s){if(typeof s.defaultService=="function")throw new Error("Only one default client provider can be configured");s.io=n,s.defaultService=t};return r.Service=FH,r.service=t,r}LB.exports=Kee;LB.exports.default=Kee;var XKe=LB.exports;const KKe=Ay(XKe);var zB={exports:{}},Yee={},QN={},vO={exports:{}};(function(n,e){Object.defineProperty(e,"__esModule",{value:!0}),e.OPERATORS=e.FILTERS=void 0;const t=Np,r=bC;function s(u){if(typeof u<"u")return Math.abs(parseInt(u,10))}function i(u,h){if(h&&h.default){const f=typeof u=="number"&&!isNaN(u)?u:h.default,d=typeof h.max=="number"?h.max:Number.MAX_VALUE;return Math.min(f,d)}return u}function o(u){return typeof u!="object"||Array.isArray(u)?u:Object.keys(u).reduce((h,f)=>(h[f]=typeof u[f]=="object"?u[f]:parseInt(u[f],10),h),{})}function a(u,h,f){if(Array.isArray(u))return u.map(d=>a(d,h,f));if(t._.isObject(u)&&u.constructor==={}.constructor){const d={};return t._.each(u,(p,m)=>{if(m[0]==="$"){if(f[m]!==void 0)return;if(!h.includes(m))throw new r.BadRequest(`Invalid query parameter ${m}`,u)}d[m]=a(p,h,f)}),Object.getOwnPropertySymbols(u).forEach(p=>{d[p]=u[p]}),d}return u}function l(u,h,f,d){return Array.isArray(f)?t._.each(f,p=>{h[p]!==void 0&&(u[p]=h[p])}):t._.each(f,(p,m)=>{const g=p(h[m],d);g!==void 0&&(u[m]=g)}),u}e.FILTERS={$sort:u=>o(u),$limit:(u,h)=>i(s(u),h.paginate),$skip:u=>s(u),$select:u=>u},e.OPERATORS=["$in","$nin","$lt","$lte","$gt","$gte","$ne","$or"];function c(u,h={}){const{filters:f={},operators:d=[]}=h,p={};return p.filters=l({},u,e.FILTERS,h),p.filters=l(p.filters,u,f,h),p.query=a(u,e.OPERATORS.concat(d),p.filters),p}e.default=c,n.exports=Object.assign(c,n.exports)})(vO,vO.exports);var Zee=vO.exports,YKe=mt&&mt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(QN,"__esModule",{value:!0});QN.AdapterService=void 0;const _1=bC,ZKe=YKe(Zee),M0=(n,e,...t)=>typeof n[e]!="function"?Promise.reject(new _1.NotImplemented(`Method ${e} not available`)):n[e](...t),JKe={find:!0,get:!1,update:!1};let QKe=class{constructor(e){this.options=Object.assign({id:"id",events:[],paginate:{},multi:!1,filters:[],whitelist:[]},e)}get id(){return this.options.id}get events(){return this.options.events}filterQuery(e={},t={}){const r=typeof e.paginate<"u"?e.paginate:this.options.paginate,{query:s={}}=e,i=Object.assign({operators:this.options.whitelist||[],filters:this.options.filters,paginate:r},t),o=(0,ZKe.default)(s,i);return Object.assign(o,{paginate:r})}allowsMulti(e){const t=JKe[e];if(typeof t<"u")return t;const r=this.options.multi;return r===!0||r===!1?r:r.includes(e)}find(e){return M0(this,"_find",e)}get(e,t){return M0(this,"_get",e,t)}create(e,t){return Array.isArray(e)&&!this.allowsMulti("create")?Promise.reject(new _1.MethodNotAllowed("Can not create multiple entries")):M0(this,"_create",e,t)}update(e,t,r){return e===null||Array.isArray(t)?Promise.reject(new _1.BadRequest("You can not replace multiple instances. Did you mean 'patch'?")):M0(this,"_update",e,t,r)}patch(e,t,r){return e===null&&!this.allowsMulti("patch")?Promise.reject(new _1.MethodNotAllowed("Can not patch multiple entries")):M0(this,"_patch",e,t,r)}remove(e,t){return e===null&&!this.allowsMulti("remove")?Promise.reject(new _1.MethodNotAllowed("Can not remove multiple entries")):M0(this,"_remove",e,t)}};QN.AdapterService=QKe;var Jee={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.sorter=n.compare=n.compareArrays=n.compareNSB=void 0;function e(i,o){return i<o?-1:i>o?1:0}n.compareNSB=e;function t(i,o){let a,l;for(a=0;a<Math.min(i.length,o.length);a+=1)if(l=n.compare(i[a],o[a]),l!==0)return l;return n.compareNSB(i.length,o.length)}n.compareArrays=t;function r(i,o,a=n.compareNSB){const{compareNSB:l,compare:c,compareArrays:u}=n;if(i===void 0)return o===void 0?0:-1;if(o===void 0)return i===void 0?0:1;if(i===null)return o===null?0:-1;if(o===null)return i===null?0:1;if(typeof i=="number")return typeof o=="number"?l(i,o):-1;if(typeof o=="number")return typeof i=="number"?l(i,o):1;if(typeof i=="string")return typeof o=="string"?a(i,o):-1;if(typeof o=="string")return typeof i=="string"?a(i,o):1;if(typeof i=="boolean")return typeof o=="boolean"?l(i,o):-1;if(typeof o=="boolean")return typeof i=="boolean"?l(i,o):1;if(i instanceof Date)return o instanceof Date?l(i.getTime(),o.getTime()):-1;if(o instanceof Date)return i instanceof Date?l(i.getTime(),o.getTime()):1;if(Array.isArray(i))return Array.isArray(o)?u(i,o):-1;if(Array.isArray(o))return Array.isArray(i)?u(i,o):1;const h=Object.keys(i).sort(),f=Object.keys(o).sort();let d=0;for(let p=0;p<Math.min(h.length,f.length);p+=1)if(d=c(i[h[p]],o[f[p]]),d!==0)return d;return l(h.length,f.length)}n.compare=r;function s(i){const o=Object.keys(i).map(a=>{const l=i[a];return{key:a,direction:l}});return function(a,l){let c;for(const u of o)if(c=u.direction*n.compare(a[u.key],l[u.key]),c!==0)return c;return 0}}n.sorter=s})(Jee);(function(n){var e=mt&&mt.__createBinding||(Object.create?function(l,c,u,h){h===void 0&&(h=u);var f=Object.getOwnPropertyDescriptor(c,u);(!f||("get"in f?!c.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return c[u]}}),Object.defineProperty(l,h,f)}:function(l,c,u,h){h===void 0&&(h=u),l[h]=c[u]}),t=mt&&mt.__exportStar||function(l,c){for(var u in l)u!=="default"&&!Object.prototype.hasOwnProperty.call(c,u)&&e(c,l,u)},r=mt&&mt.__importDefault||function(l){return l&&l.__esModule?l:{default:l}};Object.defineProperty(n,"__esModule",{value:!0}),n.select=n.OPERATORS=n.FILTERS=n.filterQuery=n.AdapterService=void 0;const s=Np;var i=QN;Object.defineProperty(n,"AdapterService",{enumerable:!0,get:function(){return i.AdapterService}});var o=Zee;Object.defineProperty(n,"filterQuery",{enumerable:!0,get:function(){return r(o).default}}),Object.defineProperty(n,"FILTERS",{enumerable:!0,get:function(){return o.FILTERS}}),Object.defineProperty(n,"OPERATORS",{enumerable:!0,get:function(){return o.OPERATORS}}),t(Jee,n);function a(l,...c){const u=l&&l.query&&l.query.$select;Array.isArray(u)&&c.length&&u.push(...c);const h=f=>Array.isArray(u)?s._.pick(f,...u):f;return f=>Array.isArray(f)?f.map(h):h(f)}n.select=a})(Yee);function BB(n){var e="[object "+n+"]";return function(t){return Object.prototype.toString.call(t)===e}}var ip=BB("Array"),Qee=BB("Object"),eYe=BB("Function");function _c(n,e){return eYe(n.get)?n.get(e):n[e]}const tYe=n=>(e,t,r,s,i)=>i?!!i.find(([o,a,l])=>n(e,a,l)):n(e,t,r,s),uc=tYe(n=>function(e,t,r,s,i){if(!ip(t)||!t.length)return n(e,t);for(var o=0,a=t.length;o<a;o++)if(n(e,_c(t,o)))return!0;return!1});function ete(n){return function(e,t,r,s){if(!ip(t)||!t.length)return n(e,t,r,s);for(var i=0,o=t.length;i<o;i++)if(!n(e,_c(t,i),t,s))return!1;return!0}}function hu(n,e,t,r,s){return n.validate(n.options,e,t,r,s)}var UI={$eq:uc(function(n,e){return n(e)}),$ne:ete(function(n,e){return n(e)}),$gt:uc(function(n,e){return n(e)}),$gte:uc(function(n,e){return n(e)}),$lt:uc(function(n,e){return n(e)}),$lte:uc(function(n,e){return n(e)}),$mod:uc(function(n,e){return n(e)}),$in(n,e){return n(e)},$nin:function(n,e){return n(e)},$not:function(n,e,t,r){return n(e,t,r)},$type:function(n,e){return n(e)},$all:function(n,e,t,r,s){return UI.$and(n,e,t,r,s)},$size:function(n,e){return e?n===e.length:!1},$or:function(n,e,t,r){for(var s=0,i=n.length;s<i;s++)if(hu(_c(n,s),e,t,r))return!0;return!1},$nor:function(n,e,t,r){return!UI.$or(n,e,t,r)},$and:function(n,e,t,r,s){if(s){for(var i=0,o=n.length;i<o;i++)if(!hu(_c(n,i),e,t,r,s))return!1}else for(var i=0,o=n.length;i<o;i++)if(!hu(_c(n,i),e,t,r,s))return!1;return!0},$regex:uc(function(n,e){return typeof e=="string"&&n.test(e)}),$where:function(n,e,t,r){return n.call(e,e,t,r)},$elemMatch:function(n,e,t,r){return ip(e)?!!~nYe(e,n):hu(n,e,t,r)},$exists:function(n,e,t,r){return r.hasOwnProperty(t)===n}},q1={$eq:function(n,e,{comparable:t,compare:r}){return n instanceof RegExp?uc(function(s){return typeof s=="string"&&n.test(s)}):n instanceof Function?uc(n):ip(n)&&!n.length?uc(function(s){return ip(s)&&!s.length}):uc(n===null?function(s){return s==null}:function(s){return r(t(s),t(n))===0})},$gt:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))>0}},$gte:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))>=0}},$lt:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))<0}},$lte:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))<=0}},$in:function(n,e,t){const{comparable:r}=t;return function(s){if(s instanceof Array){for(var i=s.length;i--;)if(~n.indexOf(r(_c(s,i))))return!0}else{var o=r(s);if(o===s&&typeof s=="object"){for(var i=n.length;i--;)if(String(n[i])===String(s)&&String(s)!=="[object Object]")return!0}if(typeof o>"u"){for(var i=n.length;i--;)if(n[i]==null)return!0}for(var i=n.length;i--;){var a=nte(_c(n,i),t),l=hu(a,o,i,n);if(l&&String(l)!=="[object Object]"&&String(o)!=="[object Object]")return!0}return!!~n.indexOf(o)}return!1}},$nin:function(n,e,t){const r=q1.$in(n,e,t);return function(s,i,o,a){return!r(s,i,o,a)}},$mod:function(n){return function(e){return e%n[0]==n[1]}},$ne:function(n,e,t){const r=q1.$eq(n,e,t);return ete(function(s,i,o,a){return!r(s,i,o,a)})},$and:function(n,e,t){return n.map(ub(t))},$all:function(n,e,t){return q1.$and(n,e,t)},$or:function(n,e,t){return n.map(ub(t))},$nor:function(n,e,t){return n.map(ub(t))},$not:function(n,e,t){const r=ub(t)(n);return function(s,i,o){return!hu(r,s,i,o)}},$type:function(n){return function(e,t,r){return e!=null?e instanceof n||e.constructor==n:!1}},$regex:function(n,e){return new RegExp(n,e.$options)},$where:function(n){return typeof n=="string"?new Function("obj","return "+n):n},$elemMatch:function(n,e,t){return ub(t)(n)},$exists:function(n){return!!n}};function nYe(n,e){for(var t=0;t<n.length;t++)if(_c(n,t),hu(e,_c(n,t)))return t;return-1}function OE(n,e){return{options:n,validate:e}}function rYe({keyPath:n,child:e,query:t},r){const s=[];if(wO(r,n,0,r,s),s.length===1){const[i,o,a]=s[0];return hu(e,i,o,a)}return t&&typeof t.$ne<"u",s.map(([i])=>i),hu(e,void 0,void 0,void 0,s)}function wO(n,e,t,r,s){if(t===e.length||n==null){s.push([n,e[t-1],r]);return}var i=_c(e,t);if(ip(n)&&isNaN(Number(i)))for(var o=0,a=n.length;o<a;o++)wO(_c(n,o),e,t,n,s);else wO(_c(n,i),e,t+1,n,s)}function sYe(n,e,t){return OE({keyPath:n,child:e,query:t},rYe)}function iYe(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")}function ub(n){const{comparable:e,expressions:t}=n;var r=function(a){return(!a||!iYe(a))&&(a={$eq:a}),a},s=function(a){a=e(a);var l=[];for(var c in a){var u=a[c];if(c!=="$options"){var h=UI[c]||n&&t&&t[c];if(h)q1[c]&&(u=q1[c](u,a,n)),l.push(OE(e(u),h));else{if(c.charCodeAt(0)===36)throw new Error("Unknown operation "+c);var f=c.split(".");l.push(sYe(f,i(u),u))}}}return l.length===1?l[0]:OE(l,UI.$and)},i=function(a){return a=r(a),oYe(a)?OE(a,WI):s(a)},o=function(a){return s(r(a))};return o}function WI(n,e){if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(Qee(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var t in n)if(!WI(n[t],e[t]))return!1;return!0}else if(ip(n)){if(n.length!==e.length)return!1;for(var r=0,s=n.length;r<s;r++)if(!WI(n[r],e[r]))return!1;return!0}else return n===e}function tte(n,e){if(!Qee(n))return e;for(var t in n)e.push(t),tte(n[t],e);return e}function oYe(n){return tte(n,[]).join(",").search(/[$.]/)===-1}function nte(n,e){var t=ub(e)(n);return e&&e.select&&(t={options:t,validate:function(r,s,i,o){return hu(r,s&&e.select(s),i,o)}}),t}function aYe(n,e){e=Object.assign({compare:rte,comparable:VB},e);var t=nte(n,e);return function(r,s,i){return hu(t,r,s,i)}}function rte(n,e){if(WI(n,e))return 0;if(typeof n==typeof e){if(n>e)return 1;if(n<e)return-1}}function VB(n){return n instanceof Date?n.getTime():ip(n)?n.map(VB):n&&typeof n.toJSON=="function"?n.toJSON():n}const lYe=Object.freeze(Object.defineProperty({__proto__:null,comparable:VB,compare:rte,default:aYe},Symbol.toStringTag,{value:"Module"})),cYe=Vf(lYe),uYe=bC,{_:N0}=Np,{sorter:hYe,select:fYe,AdapterService:dYe}=Yee,pYe=cYe.default,nT=(n,...e)=>fYe(...e)(JSON.parse(JSON.stringify(n)));let ste=class extends dYe{constructor(e={}){super(N0.extend({id:"id",matcher:pYe,sorter:hYe},e)),this._uId=e.startId||0,this.store=e.store||{}}async getEntries(e={}){const{query:t}=this.filterQuery(e);return this._find(Object.assign({},e,{paginate:!1,query:t}))}async _find(e={}){const{query:t,filters:r,paginate:s}=this.filterQuery(e);let i=N0.values(this.store).filter(this.options.matcher(t));const o=i.length;r.$sort!==void 0&&i.sort(this.options.sorter(r.$sort)),r.$skip!==void 0&&(i=i.slice(r.$skip)),r.$limit!==void 0&&(i=i.slice(0,r.$limit));const a={total:o,limit:r.$limit,skip:r.$skip||0,data:i.map(l=>nT(l,e))};return s&&s.default?a:a.data}async _get(e,t={}){if(e in this.store){const{query:r}=this.filterQuery(t),s=this.store[e];if(this.options.matcher(r)(s))return nT(s,t,this.id)}throw new uYe.NotFound(`No record found for id '${e}'`)}async _create(e,t={}){if(Array.isArray(e))return Promise.all(e.map(o=>this._create(o,t)));const r=e[this.id]||this._uId++,s=N0.extend({},e,{[this.id]:r}),i=this.store[r]=s;return nT(i,t,this.id)}async _update(e,t,r={}){const i=(await this._get(e))[this.id];return e=i==e?i:e,this.store[e]=N0.extend({},t,{[this.id]:e}),this._get(e,r)}async _patch(e,t,r={}){const s=i=>{const o=i[this.id];return this.store[o]=N0.extend(this.store[o],N0.omit(t,this.id)),nT(this.store[o],r,this.id)};return e===null?(await this.getEntries(r)).map(s):s(await this._get(e,r))}async _remove(e,t={}){if(e===null){const s=await this.getEntries(t);return Promise.all(s.map(i=>this._remove(i[this.id],t)))}const r=await this._get(e,t);return delete this.store[e],r}};zB.exports=n=>new ste(n);zB.exports.Service=ste;var ite=zB.exports;const mYe=Ay(ite);var UB={exports:{}};const{Service:gYe}=ite,LH=[];class ote extends gYe{constructor(e={}){if(super(e),this._storageKey=e.name||"feathers",this._storage=e.storage||typeof window<"u"&&window.localStorage,this._throttle=e.throttle||200,this._reuseKeys=e.reuseKeys||!1,this.store=null,!this._storage)throw new Error("The `storage` option needs to be provided");if(LH.indexOf(this._storageKey)===-1)LH.push(this._storageKey);else if(!this._reuseKeys)throw new Error(`The storage name '${this._storageKey}' is already in use by another instance.`);this.ready()}ready(){return this.store?Promise.resolve(this.store):Promise.resolve(this._storage.getItem(this._storageKey)).then(e=>JSON.parse(e||"{}")).then(e=>{const t=Object.keys(e),r=e[t[t.length-1]];return this._uId=t.length&&typeof r[this.id]<"u"?r[this.id]+1:this._uId,this.store=e})}flush(e){return this._timeout||(this._timeout=setTimeout(()=>{this._storage.setItem(this._storageKey,JSON.stringify(this.store)),delete this._timeout},this._throttle)),e}execute(e,...t){return this.ready().then(()=>super[e](...t))}find(...e){return this.execute("find",...e)}get(...e){return this.execute("get",...e)}create(...e){return this.execute("create",...e).then(t=>this.flush(t))}patch(...e){return this.execute("patch",...e).then(t=>this.flush(t))}update(...e){return this.execute("update",...e).then(t=>this.flush(t))}remove(...e){return this.execute("remove",...e).then(t=>this.flush(t))}}UB.exports=function(e){return new ote(e)};UB.exports.Service=ote;var yYe=UB.exports;const bYe=Ay(yYe);var GI={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */GI.exports;(function(n,e){(function(){var t,r="4.17.21",s=200,i="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",o="Expected a function",a="Invalid `variable` option passed into `_.template`",l="__lodash_hash_undefined__",c=500,u="__lodash_placeholder__",h=1,f=2,d=4,p=1,m=2,g=1,y=2,b=4,x=8,w=16,_=32,C=64,k=128,A=256,M=512,I=30,N="...",O=800,R=16,D=1,z=2,B=3,X=1/0,G=9007199254740991,ee=17976931348623157e292,pe=0/0,oe=4294967295,Ne=oe-1,ke=oe>>>1,De=[["ary",k],["bind",g],["bindKey",y],["curry",x],["curryRight",w],["flip",M],["partial",_],["partialRight",C],["rearg",A]],ge="[object Arguments]",Xe="[object Array]",Oe="[object AsyncFunction]",it="[object Boolean]",Ge="[object Date]",pt="[object DOMException]",ut="[object Error]",Ve="[object Function]",ze="[object GeneratorFunction]",Be="[object Map]",ht="[object Number]",Ke="[object Null]",Q="[object Object]",Z="[object Promise]",nt="[object Proxy]",He="[object RegExp]",me="[object Set]",Ye="[object String]",bt="[object Symbol]",kt="[object Undefined]",dt="[object WeakMap]",le="[object WeakSet]",tt="[object ArrayBuffer]",Ct="[object DataView]",yt="[object Float32Array]",Ht="[object Float64Array]",En="[object Int8Array]",_r="[object Int16Array]",Bs="[object Int32Array]",Ms="[object Uint8Array]",Ns="[object Uint8ClampedArray]",Lh="[object Uint16Array]",Wl="[object Uint32Array]",Gl=/\b__p \+= '';/g,fo=/\b(__p \+=) '' \+/g,Hl=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Bc=/&(?:amp|lt|gt|quot|#39);/g,Vc=/[&<>"']/g,Ri=RegExp(Bc.source),zh=RegExp(Vc.source),sl=/<%-([\s\S]+?)%>/g,Bh=/<%([\s\S]+?)%>/g,re=/<%=([\s\S]+?)%>/g,We=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Fe=/^\w*$/,Ze=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,wt=/[\\^$.*+?()[\]{}|]/g,zn=RegExp(wt.source),sn=/^\s+/,_n=/\s/,Cn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,In=/\{\n\/\* \[wrapped with (.+)\] \*/,er=/,? & /,vn=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,cr=/[()=,{}\[\]\/\s]/,Pi=/\\(\\)?/g,wr=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Yi=/\w*$/,Ar=/^[-+]0x[0-9a-f]+$/i,To=/^0b[01]+$/i,ss=/^\[object .+?Constructor\]$/,po=/^0o[0-7]+$/i,Eo=/^(?:0|[1-9]\d*)$/,$s=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,mo=/($^)/,Vh=/['\n\r\u2028\u2029\\]/g,il="\\ud800-\\udfff",Zi="\\u0300-\\u036f",Uc="\\ufe20-\\ufe2f",Ta="\\u20d0-\\u20ff",Rs=Zi+Uc+Ta,Wc="\\u2700-\\u27bf",Ji="a-z\\xdf-\\xf6\\xf8-\\xff",Vs="\\xac\\xb1\\xd7\\xf7",Uh="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",r0="\\u2000-\\u206f",Wh=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Qi="A-Z\\xc0-\\xd6\\xd8-\\xde",Gh="\\ufe0e\\ufe0f",Zf=Vs+Uh+r0+Wh,Hu="[']",Jf="["+il+"]",Hh="["+Zf+"]",jl="["+Rs+"]",Zr="\\d+",s0="["+Wc+"]",Qf="["+Ji+"]",Gc="[^"+il+Zf+Zr+Wc+Ji+Qi+"]",jh="\\ud83c[\\udffb-\\udfff]",i0="(?:"+jl+"|"+jh+")",o0="[^"+il+"]",H="(?:\\ud83c[\\udde6-\\uddff]){2}",Y="[\\ud800-\\udbff][\\udc00-\\udfff]",de="["+Qi+"]",$e="\\u200d",lt="(?:"+Qf+"|"+Gc+")",Vt="(?:"+de+"|"+Gc+")",An="(?:"+Hu+"(?:d|ll|m|re|s|t|ve))?",Ps="(?:"+Hu+"(?:D|LL|M|RE|S|T|VE))?",Us=i0+"?",fi="["+Gh+"]?",Ea="(?:"+$e+"(?:"+[o0,H,Y].join("|")+")"+fi+Us+")*",px="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Vp="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",XC=fi+Us+Ea,W$="(?:"+[s0,H,Y].join("|")+")"+XC,G$="(?:"+[o0+jl+"?",jl,H,Y,Jf].join("|")+")",H$=RegExp(Hu,"g"),mx=RegExp(jl,"g"),a0=RegExp(jh+"(?="+jh+")|"+G$+XC,"g"),KC=RegExp([de+"?"+Qf+"+"+An+"(?="+[Hh,de,"$"].join("|")+")",Vt+"+"+Ps+"(?="+[Hh,de+lt,"$"].join("|")+")",de+"?"+lt+"+"+An,de+"+"+Ps,Vp,px,Zr,W$].join("|"),"g"),Up=RegExp("["+$e+il+Rs+Gh+"]"),ol=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,j$=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],q$=-1,Br={};Br[yt]=Br[Ht]=Br[En]=Br[_r]=Br[Bs]=Br[Ms]=Br[Ns]=Br[Lh]=Br[Wl]=!0,Br[ge]=Br[Xe]=Br[tt]=Br[it]=Br[Ct]=Br[Ge]=Br[ut]=Br[Ve]=Br[Be]=Br[ht]=Br[Q]=Br[He]=Br[me]=Br[Ye]=Br[dt]=!1;var Rr={};Rr[ge]=Rr[Xe]=Rr[tt]=Rr[Ct]=Rr[it]=Rr[Ge]=Rr[yt]=Rr[Ht]=Rr[En]=Rr[_r]=Rr[Bs]=Rr[Be]=Rr[ht]=Rr[Q]=Rr[He]=Rr[me]=Rr[Ye]=Rr[bt]=Rr[Ms]=Rr[Ns]=Rr[Lh]=Rr[Wl]=!0,Rr[ut]=Rr[Ve]=Rr[dt]=!1;var gx={:"A",:"A",:"A",:"A",:"A",:"A",:"a",:"a",:"a",:"a",:"a",:"a",:"C",:"c",:"D",:"d",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"N",:"n",:"O",:"O",:"O",:"O",:"O",:"O",:"o",:"o",:"o",:"o",:"o",:"o",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"Y",:"y",:"y",:"Ae",:"ae",:"Th",:"th",:"ss",:"A",:"A",:"A",:"a",:"a",:"a",:"C",:"C",:"C",:"C",:"c",:"c",:"c",:"c",:"D",:"D",:"d",:"d",:"E",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"e",:"G",:"G",:"G",:"G",:"g",:"g",:"g",:"g",:"H",:"H",:"h",:"h",:"I",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"i",:"J",:"j",:"K",:"k",:"k",:"L",:"L",:"L",:"L",:"L",:"l",:"l",:"l",:"l",:"l",:"N",:"N",:"N",:"N",:"n",:"n",:"n",:"n",:"O",:"O",:"O",:"o",:"o",:"o",:"R",:"R",:"R",:"r",:"r",:"r",:"S",:"S",:"S",:"S",:"s",:"s",:"s",:"s",:"T",:"T",:"T",:"t",:"t",:"t",:"U",:"U",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"u",:"u",:"W",:"w",:"Y",:"y",:"Y",:"Z",:"Z",:"Z",:"z",:"z",:"z",:"IJ",:"ij",:"Oe",:"oe",:"'n",:"s"},yx={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},ed={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},YC={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},bx=parseFloat,X$=parseInt,ZC=typeof mt=="object"&&mt&&mt.Object===Object&&mt,Wp=typeof self=="object"&&self&&self.Object===Object&&self,di=ZC||Wp||Function("return this")(),l0=e&&!e.nodeType&&e,qh=l0&&!0&&n&&!n.nodeType&&n,JC=qh&&qh.exports===l0,td=JC&&ZC.process,na=function(){try{var Ie=qh&&qh.require&&qh.require("util").types;return Ie||td&&td.binding&&td.binding("util")}catch{}}(),QC=na&&na.isArrayBuffer,vx=na&&na.isDate,ek=na&&na.isMap,tk=na&&na.isRegExp,c0=na&&na.isSet,u0=na&&na.isTypedArray;function Io(Ie,je,Le){switch(Le.length){case 0:return Ie.call(je);case 1:return Ie.call(je,Le[0]);case 2:return Ie.call(je,Le[0],Le[1]);case 3:return Ie.call(je,Le[0],Le[1],Le[2])}return Ie.apply(je,Le)}function K$(Ie,je,Le,qt){for(var Pn=-1,Tr=Ie==null?0:Ie.length;++Pn<Tr;){var Oi=Ie[Pn];je(qt,Oi,Le(Oi),Ie)}return qt}function Ia(Ie,je){for(var Le=-1,qt=Ie==null?0:Ie.length;++Le<qt&&je(Ie[Le],Le,Ie)!==!1;);return Ie}function Y$(Ie,je){for(var Le=Ie==null?0:Ie.length;Le--&&je(Ie[Le],Le,Ie)!==!1;);return Ie}function nk(Ie,je){for(var Le=-1,qt=Ie==null?0:Ie.length;++Le<qt;)if(!je(Ie[Le],Le,Ie))return!1;return!0}function Hc(Ie,je){for(var Le=-1,qt=Ie==null?0:Ie.length,Pn=0,Tr=[];++Le<qt;){var Oi=Ie[Le];je(Oi,Le,Ie)&&(Tr[Pn++]=Oi)}return Tr}function h0(Ie,je){var Le=Ie==null?0:Ie.length;return!!Le&&T(Ie,je,0)>-1}function wx(Ie,je,Le){for(var qt=-1,Pn=Ie==null?0:Ie.length;++qt<Pn;)if(Le(je,Ie[qt]))return!0;return!1}function Vr(Ie,je){for(var Le=-1,qt=Ie==null?0:Ie.length,Pn=Array(qt);++Le<qt;)Pn[Le]=je(Ie[Le],Le,Ie);return Pn}function ju(Ie,je){for(var Le=-1,qt=je.length,Pn=Ie.length;++Le<qt;)Ie[Pn+Le]=je[Le];return Ie}function xx(Ie,je,Le,qt){var Pn=-1,Tr=Ie==null?0:Ie.length;for(qt&&Tr&&(Le=Ie[++Pn]);++Pn<Tr;)Le=je(Le,Ie[Pn],Pn,Ie);return Le}function Z$(Ie,je,Le,qt){var Pn=Ie==null?0:Ie.length;for(qt&&Pn&&(Le=Ie[--Pn]);Pn--;)Le=je(Le,Ie[Pn],Pn,Ie);return Le}function nd(Ie,je){for(var Le=-1,qt=Ie==null?0:Ie.length;++Le<qt;)if(je(Ie[Le],Le,Ie))return!0;return!1}var J$=ne("length");function Q$(Ie){return Ie.split("")}function eR(Ie){return Ie.match(vn)||[]}function Sx(Ie,je,Le){var qt;return Le(Ie,function(Pn,Tr,Oi){if(je(Pn,Tr,Oi))return qt=Tr,!1}),qt}function Gp(Ie,je,Le,qt){for(var Pn=Ie.length,Tr=Le+(qt?1:-1);qt?Tr--:++Tr<Pn;)if(je(Ie[Tr],Tr,Ie))return Tr;return-1}function T(Ie,je,Le){return je===je?Xce(Ie,je,Le):Gp(Ie,L,Le)}function $(Ie,je,Le,qt){for(var Pn=Le-1,Tr=Ie.length;++Pn<Tr;)if(qt(Ie[Pn],je))return Pn;return-1}function L(Ie){return Ie!==Ie}function W(Ie,je){var Le=Ie==null?0:Ie.length;return Le?Pe(Ie,je)/Le:pe}function ne(Ie){return function(je){return je==null?t:je[Ie]}}function ie(Ie){return function(je){return Ie==null?t:Ie[je]}}function se(Ie,je,Le,qt,Pn){return Pn(Ie,function(Tr,Oi,Jr){Le=qt?(qt=!1,Tr):je(Le,Tr,Oi,Jr)}),Le}function _e(Ie,je){var Le=Ie.length;for(Ie.sort(je);Le--;)Ie[Le]=Ie[Le].value;return Ie}function Pe(Ie,je){for(var Le,qt=-1,Pn=Ie.length;++qt<Pn;){var Tr=je(Ie[qt]);Tr!==t&&(Le=Le===t?Tr:Le+Tr)}return Le}function ft(Ie,je){for(var Le=-1,qt=Array(Ie);++Le<Ie;)qt[Le]=je(Le);return qt}function Tt(Ie,je){return Vr(je,function(Le){return[Le,Ie[Le]]})}function un(Ie){return Ie&&Ie.slice(0,ZV(Ie)+1).replace(sn,"")}function Ut(Ie){return function(je){return Ie(je)}}function Nt(Ie,je){return Vr(je,function(Le){return Ie[Le]})}function an(Ie,je){return Ie.has(je)}function Bn(Ie,je){for(var Le=-1,qt=Ie.length;++Le<qt&&T(je,Ie[Le],0)>-1;);return Le}function Ur(Ie,je){for(var Le=Ie.length;Le--&&T(je,Ie[Le],0)>-1;);return Le}function Wr(Ie,je){for(var Le=Ie.length,qt=0;Le--;)Ie[Le]===je&&++qt;return qt}var Di=ie(gx),Aa=ie(yx);function Ao(Ie){return"\\"+YC[Ie]}function mr(Ie,je){return Ie==null?t:Ie[je]}function Ss(Ie){return Up.test(Ie)}function qu(Ie){return ol.test(Ie)}function tR(Ie){for(var je,Le=[];!(je=Ie.next()).done;)Le.push(je.value);return Le}function _x(Ie){var je=-1,Le=Array(Ie.size);return Ie.forEach(function(qt,Pn){Le[++je]=[Pn,qt]}),Le}function rk(Ie,je){return function(Le){return Ie(je(Le))}}function Xu(Ie,je){for(var Le=-1,qt=Ie.length,Pn=0,Tr=[];++Le<qt;){var Oi=Ie[Le];(Oi===je||Oi===u)&&(Ie[Le]=u,Tr[Pn++]=Le)}return Tr}function f0(Ie){var je=-1,Le=Array(Ie.size);return Ie.forEach(function(qt){Le[++je]=qt}),Le}function d0(Ie){var je=-1,Le=Array(Ie.size);return Ie.forEach(function(qt){Le[++je]=[qt,qt]}),Le}function Xce(Ie,je,Le){for(var qt=Le-1,Pn=Ie.length;++qt<Pn;)if(Ie[qt]===je)return qt;return-1}function Kce(Ie,je,Le){for(var qt=Le+1;qt--;)if(Ie[qt]===je)return qt;return qt}function p0(Ie){return Ss(Ie)?Zce(Ie):J$(Ie)}function jc(Ie){return Ss(Ie)?Jce(Ie):Q$(Ie)}function ZV(Ie){for(var je=Ie.length;je--&&_n.test(Ie.charAt(je)););return je}var Yce=ie(ed);function Zce(Ie){for(var je=a0.lastIndex=0;a0.test(Ie);)++je;return je}function Jce(Ie){return Ie.match(a0)||[]}function Qce(Ie){return Ie.match(KC)||[]}var eue=function Ie(je){je=je==null?di:m0.defaults(di.Object(),je,m0.pick(di,j$));var Le=je.Array,qt=je.Date,Pn=je.Error,Tr=je.Function,Oi=je.Math,Jr=je.Object,nR=je.RegExp,tue=je.String,ql=je.TypeError,sk=Le.prototype,nue=Tr.prototype,g0=Jr.prototype,ik=je["__core-js_shared__"],ok=nue.toString,Pr=g0.hasOwnProperty,rue=0,JV=function(){var v=/[^.]+$/.exec(ik&&ik.keys&&ik.keys.IE_PROTO||"");return v?"Symbol(src)_1."+v:""}(),ak=g0.toString,sue=ok.call(Jr),iue=di._,oue=nR("^"+ok.call(Pr).replace(wt,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),lk=JC?je.Buffer:t,rd=je.Symbol,ck=je.Uint8Array,QV=lk?lk.allocUnsafe:t,uk=rk(Jr.getPrototypeOf,Jr),eU=Jr.create,tU=g0.propertyIsEnumerable,hk=sk.splice,nU=rd?rd.isConcatSpreadable:t,Cx=rd?rd.iterator:t,Hp=rd?rd.toStringTag:t,fk=function(){try{var v=Yp(Jr,"defineProperty");return v({},"",{}),v}catch{}}(),aue=je.clearTimeout!==di.clearTimeout&&je.clearTimeout,lue=qt&&qt.now!==di.Date.now&&qt.now,cue=je.setTimeout!==di.setTimeout&&je.setTimeout,dk=Oi.ceil,pk=Oi.floor,rR=Jr.getOwnPropertySymbols,uue=lk?lk.isBuffer:t,rU=je.isFinite,hue=sk.join,fue=rk(Jr.keys,Jr),Fi=Oi.max,Mo=Oi.min,due=qt.now,pue=je.parseInt,sU=Oi.random,mue=sk.reverse,sR=Yp(je,"DataView"),kx=Yp(je,"Map"),iR=Yp(je,"Promise"),y0=Yp(je,"Set"),Tx=Yp(je,"WeakMap"),Ex=Yp(Jr,"create"),mk=Tx&&new Tx,b0={},gue=Zp(sR),yue=Zp(kx),bue=Zp(iR),vue=Zp(y0),wue=Zp(Tx),gk=rd?rd.prototype:t,Ix=gk?gk.valueOf:t,iU=gk?gk.toString:t;function q(v){if(Ws(v)&&!On(v)&&!(v instanceof rr)){if(v instanceof Xl)return v;if(Pr.call(v,"__wrapped__"))return oW(v)}return new Xl(v)}var v0=function(){function v(){}return function(S){if(!Ds(S))return{};if(eU)return eU(S);v.prototype=S;var E=new v;return v.prototype=t,E}}();function yk(){}function Xl(v,S){this.__wrapped__=v,this.__actions__=[],this.__chain__=!!S,this.__index__=0,this.__values__=t}q.templateSettings={escape:sl,evaluate:Bh,interpolate:re,variable:"",imports:{_:q}},q.prototype=yk.prototype,q.prototype.constructor=q,Xl.prototype=v0(yk.prototype),Xl.prototype.constructor=Xl;function rr(v){this.__wrapped__=v,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=oe,this.__views__=[]}function xue(){var v=new rr(this.__wrapped__);return v.__actions__=Ma(this.__actions__),v.__dir__=this.__dir__,v.__filtered__=this.__filtered__,v.__iteratees__=Ma(this.__iteratees__),v.__takeCount__=this.__takeCount__,v.__views__=Ma(this.__views__),v}function Sue(){if(this.__filtered__){var v=new rr(this);v.__dir__=-1,v.__filtered__=!0}else v=this.clone(),v.__dir__*=-1;return v}function _ue(){var v=this.__wrapped__.value(),S=this.__dir__,E=On(v),P=S<0,V=E?v.length:0,K=Dhe(0,V,this.__views__),ae=K.start,we=K.end,Me=we-ae,Je=P?we:ae-1,et=this.__iteratees__,ct=et.length,Ot=0,tn=Mo(Me,this.__takeCount__);if(!E||!P&&V==Me&&tn==Me)return AU(v,this.__actions__);var pn=[];e:for(;Me--&&Ot<tn;){Je+=S;for(var Xn=-1,mn=v[Je];++Xn<ct;){var tr=et[Xn],ur=tr.iteratee,cl=tr.type,ia=ur(mn);if(cl==z)mn=ia;else if(!ia){if(cl==D)continue e;break e}}pn[Ot++]=mn}return pn}rr.prototype=v0(yk.prototype),rr.prototype.constructor=rr;function jp(v){var S=-1,E=v==null?0:v.length;for(this.clear();++S<E;){var P=v[S];this.set(P[0],P[1])}}function Cue(){this.__data__=Ex?Ex(null):{},this.size=0}function kue(v){var S=this.has(v)&&delete this.__data__[v];return this.size-=S?1:0,S}function Tue(v){var S=this.__data__;if(Ex){var E=S[v];return E===l?t:E}return Pr.call(S,v)?S[v]:t}function Eue(v){var S=this.__data__;return Ex?S[v]!==t:Pr.call(S,v)}function Iue(v,S){var E=this.__data__;return this.size+=this.has(v)?0:1,E[v]=Ex&&S===t?l:S,this}jp.prototype.clear=Cue,jp.prototype.delete=kue,jp.prototype.get=Tue,jp.prototype.has=Eue,jp.prototype.set=Iue;function Xh(v){var S=-1,E=v==null?0:v.length;for(this.clear();++S<E;){var P=v[S];this.set(P[0],P[1])}}function Aue(){this.__data__=[],this.size=0}function Mue(v){var S=this.__data__,E=bk(S,v);if(E<0)return!1;var P=S.length-1;return E==P?S.pop():hk.call(S,E,1),--this.size,!0}function Nue(v){var S=this.__data__,E=bk(S,v);return E<0?t:S[E][1]}function $ue(v){return bk(this.__data__,v)>-1}function Rue(v,S){var E=this.__data__,P=bk(E,v);return P<0?(++this.size,E.push([v,S])):E[P][1]=S,this}Xh.prototype.clear=Aue,Xh.prototype.delete=Mue,Xh.prototype.get=Nue,Xh.prototype.has=$ue,Xh.prototype.set=Rue;function Kh(v){var S=-1,E=v==null?0:v.length;for(this.clear();++S<E;){var P=v[S];this.set(P[0],P[1])}}function Pue(){this.size=0,this.__data__={hash:new jp,map:new(kx||Xh),string:new jp}}function Due(v){var S=Mk(this,v).delete(v);return this.size-=S?1:0,S}function Oue(v){return Mk(this,v).get(v)}function Fue(v){return Mk(this,v).has(v)}function Lue(v,S){var E=Mk(this,v),P=E.size;return E.set(v,S),this.size+=E.size==P?0:1,this}Kh.prototype.clear=Pue,Kh.prototype.delete=Due,Kh.prototype.get=Oue,Kh.prototype.has=Fue,Kh.prototype.set=Lue;function qp(v){var S=-1,E=v==null?0:v.length;for(this.__data__=new Kh;++S<E;)this.add(v[S])}function zue(v){return this.__data__.set(v,l),this}function Bue(v){return this.__data__.has(v)}qp.prototype.add=qp.prototype.push=zue,qp.prototype.has=Bue;function qc(v){var S=this.__data__=new Xh(v);this.size=S.size}function Vue(){this.__data__=new Xh,this.size=0}function Uue(v){var S=this.__data__,E=S.delete(v);return this.size=S.size,E}function Wue(v){return this.__data__.get(v)}function Gue(v){return this.__data__.has(v)}function Hue(v,S){var E=this.__data__;if(E instanceof Xh){var P=E.__data__;if(!kx||P.length<s-1)return P.push([v,S]),this.size=++E.size,this;E=this.__data__=new Kh(P)}return E.set(v,S),this.size=E.size,this}qc.prototype.clear=Vue,qc.prototype.delete=Uue,qc.prototype.get=Wue,qc.prototype.has=Gue,qc.prototype.set=Hue;function oU(v,S){var E=On(v),P=!E&&Jp(v),V=!E&&!P&&ld(v),K=!E&&!P&&!V&&_0(v),ae=E||P||V||K,we=ae?ft(v.length,tue):[],Me=we.length;for(var Je in v)(S||Pr.call(v,Je))&&!(ae&&(Je=="length"||V&&(Je=="offset"||Je=="parent")||K&&(Je=="buffer"||Je=="byteLength"||Je=="byteOffset")||Qh(Je,Me)))&&we.push(Je);return we}function aU(v){var S=v.length;return S?v[gR(0,S-1)]:t}function jue(v,S){return Nk(Ma(v),Xp(S,0,v.length))}function que(v){return Nk(Ma(v))}function oR(v,S,E){(E!==t&&!Xc(v[S],E)||E===t&&!(S in v))&&Yh(v,S,E)}function Ax(v,S,E){var P=v[S];(!(Pr.call(v,S)&&Xc(P,E))||E===t&&!(S in v))&&Yh(v,S,E)}function bk(v,S){for(var E=v.length;E--;)if(Xc(v[E][0],S))return E;return-1}function Xue(v,S,E,P){return sd(v,function(V,K,ae){S(P,V,E(V),ae)}),P}function lU(v,S){return v&&Yu(S,eo(S),v)}function Kue(v,S){return v&&Yu(S,$a(S),v)}function Yh(v,S,E){S=="__proto__"&&fk?fk(v,S,{configurable:!0,enumerable:!0,value:E,writable:!0}):v[S]=E}function aR(v,S){for(var E=-1,P=S.length,V=Le(P),K=v==null;++E<P;)V[E]=K?t:VR(v,S[E]);return V}function Xp(v,S,E){return v===v&&(E!==t&&(v=v<=E?v:E),S!==t&&(v=v>=S?v:S)),v}function Kl(v,S,E,P,V,K){var ae,we=S&h,Me=S&f,Je=S&d;if(E&&(ae=V?E(v,P,V,K):E(v)),ae!==t)return ae;if(!Ds(v))return v;var et=On(v);if(et){if(ae=Fhe(v),!we)return Ma(v,ae)}else{var ct=No(v),Ot=ct==Ve||ct==ze;if(ld(v))return $U(v,we);if(ct==Q||ct==ge||Ot&&!V){if(ae=Me||Ot?{}:ZU(v),!we)return Me?The(v,Kue(ae,v)):khe(v,lU(ae,v))}else{if(!Rr[ct])return V?v:{};ae=Lhe(v,ct,we)}}K||(K=new qc);var tn=K.get(v);if(tn)return tn;K.set(v,ae),TW(v)?v.forEach(function(mn){ae.add(Kl(mn,S,E,mn,v,K))}):CW(v)&&v.forEach(function(mn,tr){ae.set(tr,Kl(mn,S,E,tr,v,K))});var pn=Je?Me?ER:TR:Me?$a:eo,Xn=et?t:pn(v);return Ia(Xn||v,function(mn,tr){Xn&&(tr=mn,mn=v[tr]),Ax(ae,tr,Kl(mn,S,E,tr,v,K))}),ae}function Yue(v){var S=eo(v);return function(E){return cU(E,v,S)}}function cU(v,S,E){var P=E.length;if(v==null)return!P;for(v=Jr(v);P--;){var V=E[P],K=S[V],ae=v[V];if(ae===t&&!(V in v)||!K(ae))return!1}return!0}function uU(v,S,E){if(typeof v!="function")throw new ql(o);return Ox(function(){v.apply(t,E)},S)}function Mx(v,S,E,P){var V=-1,K=h0,ae=!0,we=v.length,Me=[],Je=S.length;if(!we)return Me;E&&(S=Vr(S,Ut(E))),P?(K=wx,ae=!1):S.length>=s&&(K=an,ae=!1,S=new qp(S));e:for(;++V<we;){var et=v[V],ct=E==null?et:E(et);if(et=P||et!==0?et:0,ae&&ct===ct){for(var Ot=Je;Ot--;)if(S[Ot]===ct)continue e;Me.push(et)}else K(S,ct,P)||Me.push(et)}return Me}var sd=FU(Ku),hU=FU(cR,!0);function Zue(v,S){var E=!0;return sd(v,function(P,V,K){return E=!!S(P,V,K),E}),E}function vk(v,S,E){for(var P=-1,V=v.length;++P<V;){var K=v[P],ae=S(K);if(ae!=null&&(we===t?ae===ae&&!ll(ae):E(ae,we)))var we=ae,Me=K}return Me}function Jue(v,S,E,P){var V=v.length;for(E=Gn(E),E<0&&(E=-E>V?0:V+E),P=P===t||P>V?V:Gn(P),P<0&&(P+=V),P=E>P?0:IW(P);E<P;)v[E++]=S;return v}function fU(v,S){var E=[];return sd(v,function(P,V,K){S(P,V,K)&&E.push(P)}),E}function go(v,S,E,P,V){var K=-1,ae=v.length;for(E||(E=Bhe),V||(V=[]);++K<ae;){var we=v[K];S>0&&E(we)?S>1?go(we,S-1,E,P,V):ju(V,we):P||(V[V.length]=we)}return V}var lR=LU(),dU=LU(!0);function Ku(v,S){return v&&lR(v,S,eo)}function cR(v,S){return v&&dU(v,S,eo)}function wk(v,S){return Hc(S,function(E){return ef(v[E])})}function Kp(v,S){S=od(S,v);for(var E=0,P=S.length;v!=null&&E<P;)v=v[Zu(S[E++])];return E&&E==P?v:t}function pU(v,S,E){var P=S(v);return On(v)?P:ju(P,E(v))}function ra(v){return v==null?v===t?kt:Ke:Hp&&Hp in Jr(v)?Phe(v):qhe(v)}function uR(v,S){return v>S}function Que(v,S){return v!=null&&Pr.call(v,S)}function ehe(v,S){return v!=null&&S in Jr(v)}function the(v,S,E){return v>=Mo(S,E)&&v<Fi(S,E)}function hR(v,S,E){for(var P=E?wx:h0,V=v[0].length,K=v.length,ae=K,we=Le(K),Me=1/0,Je=[];ae--;){var et=v[ae];ae&&S&&(et=Vr(et,Ut(S))),Me=Mo(et.length,Me),we[ae]=!E&&(S||V>=120&&et.length>=120)?new qp(ae&&et):t}et=v[0];var ct=-1,Ot=we[0];e:for(;++ct<V&&Je.length<Me;){var tn=et[ct],pn=S?S(tn):tn;if(tn=E||tn!==0?tn:0,!(Ot?an(Ot,pn):P(Je,pn,E))){for(ae=K;--ae;){var Xn=we[ae];if(!(Xn?an(Xn,pn):P(v[ae],pn,E)))continue e}Ot&&Ot.push(pn),Je.push(tn)}}return Je}function nhe(v,S,E,P){return Ku(v,function(V,K,ae){S(P,E(V),K,ae)}),P}function Nx(v,S,E){S=od(S,v),v=tW(v,S);var P=v==null?v:v[Zu(Zl(S))];return P==null?t:Io(P,v,E)}function mU(v){return Ws(v)&&ra(v)==ge}function rhe(v){return Ws(v)&&ra(v)==tt}function she(v){return Ws(v)&&ra(v)==Ge}function $x(v,S,E,P,V){return v===S?!0:v==null||S==null||!Ws(v)&&!Ws(S)?v!==v&&S!==S:ihe(v,S,E,P,$x,V)}function ihe(v,S,E,P,V,K){var ae=On(v),we=On(S),Me=ae?Xe:No(v),Je=we?Xe:No(S);Me=Me==ge?Q:Me,Je=Je==ge?Q:Je;var et=Me==Q,ct=Je==Q,Ot=Me==Je;if(Ot&&ld(v)){if(!ld(S))return!1;ae=!0,et=!1}if(Ot&&!et)return K||(K=new qc),ae||_0(v)?XU(v,S,E,P,V,K):$he(v,S,Me,E,P,V,K);if(!(E&p)){var tn=et&&Pr.call(v,"__wrapped__"),pn=ct&&Pr.call(S,"__wrapped__");if(tn||pn){var Xn=tn?v.value():v,mn=pn?S.value():S;return K||(K=new qc),V(Xn,mn,E,P,K)}}return Ot?(K||(K=new qc),Rhe(v,S,E,P,V,K)):!1}function ohe(v){return Ws(v)&&No(v)==Be}function fR(v,S,E,P){var V=E.length,K=V,ae=!P;if(v==null)return!K;for(v=Jr(v);V--;){var we=E[V];if(ae&&we[2]?we[1]!==v[we[0]]:!(we[0]in v))return!1}for(;++V<K;){we=E[V];var Me=we[0],Je=v[Me],et=we[1];if(ae&&we[2]){if(Je===t&&!(Me in v))return!1}else{var ct=new qc;if(P)var Ot=P(Je,et,Me,v,S,ct);if(!(Ot===t?$x(et,Je,p|m,P,ct):Ot))return!1}}return!0}function gU(v){if(!Ds(v)||Uhe(v))return!1;var S=ef(v)?oue:ss;return S.test(Zp(v))}function ahe(v){return Ws(v)&&ra(v)==He}function lhe(v){return Ws(v)&&No(v)==me}function che(v){return Ws(v)&&Fk(v.length)&&!!Br[ra(v)]}function yU(v){return typeof v=="function"?v:v==null?Ra:typeof v=="object"?On(v)?wU(v[0],v[1]):vU(v):zW(v)}function dR(v){if(!Dx(v))return fue(v);var S=[];for(var E in Jr(v))Pr.call(v,E)&&E!="constructor"&&S.push(E);return S}function uhe(v){if(!Ds(v))return jhe(v);var S=Dx(v),E=[];for(var P in v)P=="constructor"&&(S||!Pr.call(v,P))||E.push(P);return E}function pR(v,S){return v<S}function bU(v,S){var E=-1,P=Na(v)?Le(v.length):[];return sd(v,function(V,K,ae){P[++E]=S(V,K,ae)}),P}function vU(v){var S=AR(v);return S.length==1&&S[0][2]?QU(S[0][0],S[0][1]):function(E){return E===v||fR(E,v,S)}}function wU(v,S){return NR(v)&&JU(S)?QU(Zu(v),S):function(E){var P=VR(E,v);return P===t&&P===S?UR(E,v):$x(S,P,p|m)}}function xk(v,S,E,P,V){v!==S&&lR(S,function(K,ae){if(V||(V=new qc),Ds(K))hhe(v,S,ae,E,xk,P,V);else{var we=P?P(RR(v,ae),K,ae+"",v,S,V):t;we===t&&(we=K),oR(v,ae,we)}},$a)}function hhe(v,S,E,P,V,K,ae){var we=RR(v,E),Me=RR(S,E),Je=ae.get(Me);if(Je){oR(v,E,Je);return}var et=K?K(we,Me,E+"",v,S,ae):t,ct=et===t;if(ct){var Ot=On(Me),tn=!Ot&&ld(Me),pn=!Ot&&!tn&&_0(Me);et=Me,Ot||tn||pn?On(we)?et=we:ti(we)?et=Ma(we):tn?(ct=!1,et=$U(Me,!0)):pn?(ct=!1,et=RU(Me,!0)):et=[]:Fx(Me)||Jp(Me)?(et=we,Jp(we)?et=AW(we):(!Ds(we)||ef(we))&&(et=ZU(Me))):ct=!1}ct&&(ae.set(Me,et),V(et,Me,P,K,ae),ae.delete(Me)),oR(v,E,et)}function xU(v,S){var E=v.length;if(E)return S+=S<0?E:0,Qh(S,E)?v[S]:t}function SU(v,S,E){S.length?S=Vr(S,function(K){return On(K)?function(ae){return Kp(ae,K.length===1?K[0]:K)}:K}):S=[Ra];var P=-1;S=Vr(S,Ut(hn()));var V=bU(v,function(K,ae,we){var Me=Vr(S,function(Je){return Je(K)});return{criteria:Me,index:++P,value:K}});return _e(V,function(K,ae){return Che(K,ae,E)})}function fhe(v,S){return _U(v,S,function(E,P){return UR(v,P)})}function _U(v,S,E){for(var P=-1,V=S.length,K={};++P<V;){var ae=S[P],we=Kp(v,ae);E(we,ae)&&Rx(K,od(ae,v),we)}return K}function dhe(v){return function(S){return Kp(S,v)}}function mR(v,S,E,P){var V=P?$:T,K=-1,ae=S.length,we=v;for(v===S&&(S=Ma(S)),E&&(we=Vr(v,Ut(E)));++K<ae;)for(var Me=0,Je=S[K],et=E?E(Je):Je;(Me=V(we,et,Me,P))>-1;)we!==v&&hk.call(we,Me,1),hk.call(v,Me,1);return v}function CU(v,S){for(var E=v?S.length:0,P=E-1;E--;){var V=S[E];if(E==P||V!==K){var K=V;Qh(V)?hk.call(v,V,1):vR(v,V)}}return v}function gR(v,S){return v+pk(sU()*(S-v+1))}function phe(v,S,E,P){for(var V=-1,K=Fi(dk((S-v)/(E||1)),0),ae=Le(K);K--;)ae[P?K:++V]=v,v+=E;return ae}function yR(v,S){var E="";if(!v||S<1||S>G)return E;do S%2&&(E+=v),S=pk(S/2),S&&(v+=v);while(S);return E}function Yn(v,S){return PR(eW(v,S,Ra),v+"")}function mhe(v){return aU(C0(v))}function ghe(v,S){var E=C0(v);return Nk(E,Xp(S,0,E.length))}function Rx(v,S,E,P){if(!Ds(v))return v;S=od(S,v);for(var V=-1,K=S.length,ae=K-1,we=v;we!=null&&++V<K;){var Me=Zu(S[V]),Je=E;if(Me==="__proto__"||Me==="constructor"||Me==="prototype")return v;if(V!=ae){var et=we[Me];Je=P?P(et,Me,we):t,Je===t&&(Je=Ds(et)?et:Qh(S[V+1])?[]:{})}Ax(we,Me,Je),we=we[Me]}return v}var kU=mk?function(v,S){return mk.set(v,S),v}:Ra,yhe=fk?function(v,S){return fk(v,"toString",{configurable:!0,enumerable:!1,value:GR(S),writable:!0})}:Ra;function bhe(v){return Nk(C0(v))}function Yl(v,S,E){var P=-1,V=v.length;S<0&&(S=-S>V?0:V+S),E=E>V?V:E,E<0&&(E+=V),V=S>E?0:E-S>>>0,S>>>=0;for(var K=Le(V);++P<V;)K[P]=v[P+S];return K}function vhe(v,S){var E;return sd(v,function(P,V,K){return E=S(P,V,K),!E}),!!E}function Sk(v,S,E){var P=0,V=v==null?P:v.length;if(typeof S=="number"&&S===S&&V<=ke){for(;P<V;){var K=P+V>>>1,ae=v[K];ae!==null&&!ll(ae)&&(E?ae<=S:ae<S)?P=K+1:V=K}return V}return bR(v,S,Ra,E)}function bR(v,S,E,P){var V=0,K=v==null?0:v.length;if(K===0)return 0;S=E(S);for(var ae=S!==S,we=S===null,Me=ll(S),Je=S===t;V<K;){var et=pk((V+K)/2),ct=E(v[et]),Ot=ct!==t,tn=ct===null,pn=ct===ct,Xn=ll(ct);if(ae)var mn=P||pn;else Je?mn=pn&&(P||Ot):we?mn=pn&&Ot&&(P||!tn):Me?mn=pn&&Ot&&!tn&&(P||!Xn):tn||Xn?mn=!1:mn=P?ct<=S:ct<S;mn?V=et+1:K=et}return Mo(K,Ne)}function TU(v,S){for(var E=-1,P=v.length,V=0,K=[];++E<P;){var ae=v[E],we=S?S(ae):ae;if(!E||!Xc(we,Me)){var Me=we;K[V++]=ae===0?0:ae}}return K}function EU(v){return typeof v=="number"?v:ll(v)?pe:+v}function al(v){if(typeof v=="string")return v;if(On(v))return Vr(v,al)+"";if(ll(v))return iU?iU.call(v):"";var S=v+"";return S=="0"&&1/v==-X?"-0":S}function id(v,S,E){var P=-1,V=h0,K=v.length,ae=!0,we=[],Me=we;if(E)ae=!1,V=wx;else if(K>=s){var Je=S?null:Mhe(v);if(Je)return f0(Je);ae=!1,V=an,Me=new qp}else Me=S?[]:we;e:for(;++P<K;){var et=v[P],ct=S?S(et):et;if(et=E||et!==0?et:0,ae&&ct===ct){for(var Ot=Me.length;Ot--;)if(Me[Ot]===ct)continue e;S&&Me.push(ct),we.push(et)}else V(Me,ct,E)||(Me!==we&&Me.push(ct),we.push(et))}return we}function vR(v,S){return S=od(S,v),v=tW(v,S),v==null||delete v[Zu(Zl(S))]}function IU(v,S,E,P){return Rx(v,S,E(Kp(v,S)),P)}function _k(v,S,E,P){for(var V=v.length,K=P?V:-1;(P?K--:++K<V)&&S(v[K],K,v););return E?Yl(v,P?0:K,P?K+1:V):Yl(v,P?K+1:0,P?V:K)}function AU(v,S){var E=v;return E instanceof rr&&(E=E.value()),xx(S,function(P,V){return V.func.apply(V.thisArg,ju([P],V.args))},E)}function wR(v,S,E){var P=v.length;if(P<2)return P?id(v[0]):[];for(var V=-1,K=Le(P);++V<P;)for(var ae=v[V],we=-1;++we<P;)we!=V&&(K[V]=Mx(K[V]||ae,v[we],S,E));return id(go(K,1),S,E)}function MU(v,S,E){for(var P=-1,V=v.length,K=S.length,ae={};++P<V;){var we=P<K?S[P]:t;E(ae,v[P],we)}return ae}function xR(v){return ti(v)?v:[]}function SR(v){return typeof v=="function"?v:Ra}function od(v,S){return On(v)?v:NR(v,S)?[v]:iW(Mr(v))}var whe=Yn;function ad(v,S,E){var P=v.length;return E=E===t?P:E,!S&&E>=P?v:Yl(v,S,E)}var NU=aue||function(v){return di.clearTimeout(v)};function $U(v,S){if(S)return v.slice();var E=v.length,P=QV?QV(E):new v.constructor(E);return v.copy(P),P}function _R(v){var S=new v.constructor(v.byteLength);return new ck(S).set(new ck(v)),S}function xhe(v,S){var E=S?_R(v.buffer):v.buffer;return new v.constructor(E,v.byteOffset,v.byteLength)}function She(v){var S=new v.constructor(v.source,Yi.exec(v));return S.lastIndex=v.lastIndex,S}function _he(v){return Ix?Jr(Ix.call(v)):{}}function RU(v,S){var E=S?_R(v.buffer):v.buffer;return new v.constructor(E,v.byteOffset,v.length)}function PU(v,S){if(v!==S){var E=v!==t,P=v===null,V=v===v,K=ll(v),ae=S!==t,we=S===null,Me=S===S,Je=ll(S);if(!we&&!Je&&!K&&v>S||K&&ae&&Me&&!we&&!Je||P&&ae&&Me||!E&&Me||!V)return 1;if(!P&&!K&&!Je&&v<S||Je&&E&&V&&!P&&!K||we&&E&&V||!ae&&V||!Me)return-1}return 0}function Che(v,S,E){for(var P=-1,V=v.criteria,K=S.criteria,ae=V.length,we=E.length;++P<ae;){var Me=PU(V[P],K[P]);if(Me){if(P>=we)return Me;var Je=E[P];return Me*(Je=="desc"?-1:1)}}return v.index-S.index}function DU(v,S,E,P){for(var V=-1,K=v.length,ae=E.length,we=-1,Me=S.length,Je=Fi(K-ae,0),et=Le(Me+Je),ct=!P;++we<Me;)et[we]=S[we];for(;++V<ae;)(ct||V<K)&&(et[E[V]]=v[V]);for(;Je--;)et[we++]=v[V++];return et}function OU(v,S,E,P){for(var V=-1,K=v.length,ae=-1,we=E.length,Me=-1,Je=S.length,et=Fi(K-we,0),ct=Le(et+Je),Ot=!P;++V<et;)ct[V]=v[V];for(var tn=V;++Me<Je;)ct[tn+Me]=S[Me];for(;++ae<we;)(Ot||V<K)&&(ct[tn+E[ae]]=v[V++]);return ct}function Ma(v,S){var E=-1,P=v.length;for(S||(S=Le(P));++E<P;)S[E]=v[E];return S}function Yu(v,S,E,P){var V=!E;E||(E={});for(var K=-1,ae=S.length;++K<ae;){var we=S[K],Me=P?P(E[we],v[we],we,E,v):t;Me===t&&(Me=v[we]),V?Yh(E,we,Me):Ax(E,we,Me)}return E}function khe(v,S){return Yu(v,MR(v),S)}function The(v,S){return Yu(v,KU(v),S)}function Ck(v,S){return function(E,P){var V=On(E)?K$:Xue,K=S?S():{};return V(E,v,hn(P,2),K)}}function w0(v){return Yn(function(S,E){var P=-1,V=E.length,K=V>1?E[V-1]:t,ae=V>2?E[2]:t;for(K=v.length>3&&typeof K=="function"?(V--,K):t,ae&&sa(E[0],E[1],ae)&&(K=V<3?t:K,V=1),S=Jr(S);++P<V;){var we=E[P];we&&v(S,we,P,K)}return S})}function FU(v,S){return function(E,P){if(E==null)return E;if(!Na(E))return v(E,P);for(var V=E.length,K=S?V:-1,ae=Jr(E);(S?K--:++K<V)&&P(ae[K],K,ae)!==!1;);return E}}function LU(v){return function(S,E,P){for(var V=-1,K=Jr(S),ae=P(S),we=ae.length;we--;){var Me=ae[v?we:++V];if(E(K[Me],Me,K)===!1)break}return S}}function Ehe(v,S,E){var P=S&g,V=Px(v);function K(){var ae=this&&this!==di&&this instanceof K?V:v;return ae.apply(P?E:this,arguments)}return K}function zU(v){return function(S){S=Mr(S);var E=Ss(S)?jc(S):t,P=E?E[0]:S.charAt(0),V=E?ad(E,1).join(""):S.slice(1);return P[v]()+V}}function x0(v){return function(S){return xx(FW(OW(S).replace(H$,"")),v,"")}}function Px(v){return function(){var S=arguments;switch(S.length){case 0:return new v;case 1:return new v(S[0]);case 2:return new v(S[0],S[1]);case 3:return new v(S[0],S[1],S[2]);case 4:return new v(S[0],S[1],S[2],S[3]);case 5:return new v(S[0],S[1],S[2],S[3],S[4]);case 6:return new v(S[0],S[1],S[2],S[3],S[4],S[5]);case 7:return new v(S[0],S[1],S[2],S[3],S[4],S[5],S[6])}var E=v0(v.prototype),P=v.apply(E,S);return Ds(P)?P:E}}function Ihe(v,S,E){var P=Px(v);function V(){for(var K=arguments.length,ae=Le(K),we=K,Me=S0(V);we--;)ae[we]=arguments[we];var Je=K<3&&ae[0]!==Me&&ae[K-1]!==Me?[]:Xu(ae,Me);if(K-=Je.length,K<E)return GU(v,S,kk,V.placeholder,t,ae,Je,t,t,E-K);var et=this&&this!==di&&this instanceof V?P:v;return Io(et,this,ae)}return V}function BU(v){return function(S,E,P){var V=Jr(S);if(!Na(S)){var K=hn(E,3);S=eo(S),E=function(we){return K(V[we],we,V)}}var ae=v(S,E,P);return ae>-1?V[K?S[ae]:ae]:t}}function VU(v){return Jh(function(S){var E=S.length,P=E,V=Xl.prototype.thru;for(v&&S.reverse();P--;){var K=S[P];if(typeof K!="function")throw new ql(o);if(V&&!ae&&Ak(K)=="wrapper")var ae=new Xl([],!0)}for(P=ae?P:E;++P<E;){K=S[P];var we=Ak(K),Me=we=="wrapper"?IR(K):t;Me&&$R(Me[0])&&Me[1]==(k|x|_|A)&&!Me[4].length&&Me[9]==1?ae=ae[Ak(Me[0])].apply(ae,Me[3]):ae=K.length==1&&$R(K)?ae[we]():ae.thru(K)}return function(){var Je=arguments,et=Je[0];if(ae&&Je.length==1&&On(et))return ae.plant(et).value();for(var ct=0,Ot=E?S[ct].apply(this,Je):et;++ct<E;)Ot=S[ct].call(this,Ot);return Ot}})}function kk(v,S,E,P,V,K,ae,we,Me,Je){var et=S&k,ct=S&g,Ot=S&y,tn=S&(x|w),pn=S&M,Xn=Ot?t:Px(v);function mn(){for(var tr=arguments.length,ur=Le(tr),cl=tr;cl--;)ur[cl]=arguments[cl];if(tn)var ia=S0(mn),ul=Wr(ur,ia);if(P&&(ur=DU(ur,P,V,tn)),K&&(ur=OU(ur,K,ae,tn)),tr-=ul,tn&&tr<Je){var ni=Xu(ur,ia);return GU(v,S,kk,mn.placeholder,E,ur,ni,we,Me,Je-tr)}var Kc=ct?E:this,nf=Ot?Kc[v]:v;return tr=ur.length,we?ur=Xhe(ur,we):pn&&tr>1&&ur.reverse(),et&&Me<tr&&(ur.length=Me),this&&this!==di&&this instanceof mn&&(nf=Xn||Px(nf)),nf.apply(Kc,ur)}return mn}function UU(v,S){return function(E,P){return nhe(E,v,S(P),{})}}function Tk(v,S){return function(E,P){var V;if(E===t&&P===t)return S;if(E!==t&&(V=E),P!==t){if(V===t)return P;typeof E=="string"||typeof P=="string"?(E=al(E),P=al(P)):(E=EU(E),P=EU(P)),V=v(E,P)}return V}}function CR(v){return Jh(function(S){return S=Vr(S,Ut(hn())),Yn(function(E){var P=this;return v(S,function(V){return Io(V,P,E)})})})}function Ek(v,S){S=S===t?" ":al(S);var E=S.length;if(E<2)return E?yR(S,v):S;var P=yR(S,dk(v/p0(S)));return Ss(S)?ad(jc(P),0,v).join(""):P.slice(0,v)}function Ahe(v,S,E,P){var V=S&g,K=Px(v);function ae(){for(var we=-1,Me=arguments.length,Je=-1,et=P.length,ct=Le(et+Me),Ot=this&&this!==di&&this instanceof ae?K:v;++Je<et;)ct[Je]=P[Je];for(;Me--;)ct[Je++]=arguments[++we];return Io(Ot,V?E:this,ct)}return ae}function WU(v){return function(S,E,P){return P&&typeof P!="number"&&sa(S,E,P)&&(E=P=t),S=tf(S),E===t?(E=S,S=0):E=tf(E),P=P===t?S<E?1:-1:tf(P),phe(S,E,P,v)}}function Ik(v){return function(S,E){return typeof S=="string"&&typeof E=="string"||(S=Jl(S),E=Jl(E)),v(S,E)}}function GU(v,S,E,P,V,K,ae,we,Me,Je){var et=S&x,ct=et?ae:t,Ot=et?t:ae,tn=et?K:t,pn=et?t:K;S|=et?_:C,S&=~(et?C:_),S&b||(S&=~(g|y));var Xn=[v,S,V,tn,ct,pn,Ot,we,Me,Je],mn=E.apply(t,Xn);return $R(v)&&nW(mn,Xn),mn.placeholder=P,rW(mn,v,S)}function kR(v){var S=Oi[v];return function(E,P){if(E=Jl(E),P=P==null?0:Mo(Gn(P),292),P&&rU(E)){var V=(Mr(E)+"e").split("e"),K=S(V[0]+"e"+(+V[1]+P));return V=(Mr(K)+"e").split("e"),+(V[0]+"e"+(+V[1]-P))}return S(E)}}var Mhe=y0&&1/f0(new y0([,-0]))[1]==X?function(v){return new y0(v)}:qR;function HU(v){return function(S){var E=No(S);return E==Be?_x(S):E==me?d0(S):Tt(S,v(S))}}function Zh(v,S,E,P,V,K,ae,we){var Me=S&y;if(!Me&&typeof v!="function")throw new ql(o);var Je=P?P.length:0;if(Je||(S&=~(_|C),P=V=t),ae=ae===t?ae:Fi(Gn(ae),0),we=we===t?we:Gn(we),Je-=V?V.length:0,S&C){var et=P,ct=V;P=V=t}var Ot=Me?t:IR(v),tn=[v,S,E,P,V,et,ct,K,ae,we];if(Ot&&Hhe(tn,Ot),v=tn[0],S=tn[1],E=tn[2],P=tn[3],V=tn[4],we=tn[9]=tn[9]===t?Me?0:v.length:Fi(tn[9]-Je,0),!we&&S&(x|w)&&(S&=~(x|w)),!S||S==g)var pn=Ehe(v,S,E);else S==x||S==w?pn=Ihe(v,S,we):(S==_||S==(g|_))&&!V.length?pn=Ahe(v,S,E,P):pn=kk.apply(t,tn);var Xn=Ot?kU:nW;return rW(Xn(pn,tn),v,S)}function jU(v,S,E,P){return v===t||Xc(v,g0[E])&&!Pr.call(P,E)?S:v}function qU(v,S,E,P,V,K){return Ds(v)&&Ds(S)&&(K.set(S,v),xk(v,S,t,qU,K),K.delete(S)),v}function Nhe(v){return Fx(v)?t:v}function XU(v,S,E,P,V,K){var ae=E&p,we=v.length,Me=S.length;if(we!=Me&&!(ae&&Me>we))return!1;var Je=K.get(v),et=K.get(S);if(Je&&et)return Je==S&&et==v;var ct=-1,Ot=!0,tn=E&m?new qp:t;for(K.set(v,S),K.set(S,v);++ct<we;){var pn=v[ct],Xn=S[ct];if(P)var mn=ae?P(Xn,pn,ct,S,v,K):P(pn,Xn,ct,v,S,K);if(mn!==t){if(mn)continue;Ot=!1;break}if(tn){if(!nd(S,function(tr,ur){if(!an(tn,ur)&&(pn===tr||V(pn,tr,E,P,K)))return tn.push(ur)})){Ot=!1;break}}else if(!(pn===Xn||V(pn,Xn,E,P,K))){Ot=!1;break}}return K.delete(v),K.delete(S),Ot}function $he(v,S,E,P,V,K,ae){switch(E){case Ct:if(v.byteLength!=S.byteLength||v.byteOffset!=S.byteOffset)return!1;v=v.buffer,S=S.buffer;case tt:return!(v.byteLength!=S.byteLength||!K(new ck(v),new ck(S)));case it:case Ge:case ht:return Xc(+v,+S);case ut:return v.name==S.name&&v.message==S.message;case He:case Ye:return v==S+"";case Be:var we=_x;case me:var Me=P&p;if(we||(we=f0),v.size!=S.size&&!Me)return!1;var Je=ae.get(v);if(Je)return Je==S;P|=m,ae.set(v,S);var et=XU(we(v),we(S),P,V,K,ae);return ae.delete(v),et;case bt:if(Ix)return Ix.call(v)==Ix.call(S)}return!1}function Rhe(v,S,E,P,V,K){var ae=E&p,we=TR(v),Me=we.length,Je=TR(S),et=Je.length;if(Me!=et&&!ae)return!1;for(var ct=Me;ct--;){var Ot=we[ct];if(!(ae?Ot in S:Pr.call(S,Ot)))return!1}var tn=K.get(v),pn=K.get(S);if(tn&&pn)return tn==S&&pn==v;var Xn=!0;K.set(v,S),K.set(S,v);for(var mn=ae;++ct<Me;){Ot=we[ct];var tr=v[Ot],ur=S[Ot];if(P)var cl=ae?P(ur,tr,Ot,S,v,K):P(tr,ur,Ot,v,S,K);if(!(cl===t?tr===ur||V(tr,ur,E,P,K):cl)){Xn=!1;break}mn||(mn=Ot=="constructor")}if(Xn&&!mn){var ia=v.constructor,ul=S.constructor;ia!=ul&&"constructor"in v&&"constructor"in S&&!(typeof ia=="function"&&ia instanceof ia&&typeof ul=="function"&&ul instanceof ul)&&(Xn=!1)}return K.delete(v),K.delete(S),Xn}function Jh(v){return PR(eW(v,t,cW),v+"")}function TR(v){return pU(v,eo,MR)}function ER(v){return pU(v,$a,KU)}var IR=mk?function(v){return mk.get(v)}:qR;function Ak(v){for(var S=v.name+"",E=b0[S],P=Pr.call(b0,S)?E.length:0;P--;){var V=E[P],K=V.func;if(K==null||K==v)return V.name}return S}function S0(v){var S=Pr.call(q,"placeholder")?q:v;return S.placeholder}function hn(){var v=q.iteratee||HR;return v=v===HR?yU:v,arguments.length?v(arguments[0],arguments[1]):v}function Mk(v,S){var E=v.__data__;return Vhe(S)?E[typeof S=="string"?"string":"hash"]:E.map}function AR(v){for(var S=eo(v),E=S.length;E--;){var P=S[E],V=v[P];S[E]=[P,V,JU(V)]}return S}function Yp(v,S){var E=mr(v,S);return gU(E)?E:t}function Phe(v){var S=Pr.call(v,Hp),E=v[Hp];try{v[Hp]=t;var P=!0}catch{}var V=ak.call(v);return P&&(S?v[Hp]=E:delete v[Hp]),V}var MR=rR?function(v){return v==null?[]:(v=Jr(v),Hc(rR(v),function(S){return tU.call(v,S)}))}:XR,KU=rR?function(v){for(var S=[];v;)ju(S,MR(v)),v=uk(v);return S}:XR,No=ra;(sR&&No(new sR(new ArrayBuffer(1)))!=Ct||kx&&No(new kx)!=Be||iR&&No(iR.resolve())!=Z||y0&&No(new y0)!=me||Tx&&No(new Tx)!=dt)&&(No=function(v){var S=ra(v),E=S==Q?v.constructor:t,P=E?Zp(E):"";if(P)switch(P){case gue:return Ct;case yue:return Be;case bue:return Z;case vue:return me;case wue:return dt}return S});function Dhe(v,S,E){for(var P=-1,V=E.length;++P<V;){var K=E[P],ae=K.size;switch(K.type){case"drop":v+=ae;break;case"dropRight":S-=ae;break;case"take":S=Mo(S,v+ae);break;case"takeRight":v=Fi(v,S-ae);break}}return{start:v,end:S}}function Ohe(v){var S=v.match(In);return S?S[1].split(er):[]}function YU(v,S,E){S=od(S,v);for(var P=-1,V=S.length,K=!1;++P<V;){var ae=Zu(S[P]);if(!(K=v!=null&&E(v,ae)))break;v=v[ae]}return K||++P!=V?K:(V=v==null?0:v.length,!!V&&Fk(V)&&Qh(ae,V)&&(On(v)||Jp(v)))}function Fhe(v){var S=v.length,E=new v.constructor(S);return S&&typeof v[0]=="string"&&Pr.call(v,"index")&&(E.index=v.index,E.input=v.input),E}function ZU(v){return typeof v.constructor=="function"&&!Dx(v)?v0(uk(v)):{}}function Lhe(v,S,E){var P=v.constructor;switch(S){case tt:return _R(v);case it:case Ge:return new P(+v);case Ct:return xhe(v,E);case yt:case Ht:case En:case _r:case Bs:case Ms:case Ns:case Lh:case Wl:return RU(v,E);case Be:return new P;case ht:case Ye:return new P(v);case He:return She(v);case me:return new P;case bt:return _he(v)}}function zhe(v,S){var E=S.length;if(!E)return v;var P=E-1;return S[P]=(E>1?"& ":"")+S[P],S=S.join(E>2?", ":" "),v.replace(Cn,`{
/* [wrapped with `+S+`] */
`)}function Bhe(v){return On(v)||Jp(v)||!!(nU&&v&&v[nU])}function Qh(v,S){var E=typeof v;return S=S??G,!!S&&(E=="number"||E!="symbol"&&Eo.test(v))&&v>-1&&v%1==0&&v<S}function sa(v,S,E){if(!Ds(E))return!1;var P=typeof S;return(P=="number"?Na(E)&&Qh(S,E.length):P=="string"&&S in E)?Xc(E[S],v):!1}function NR(v,S){if(On(v))return!1;var E=typeof v;return E=="number"||E=="symbol"||E=="boolean"||v==null||ll(v)?!0:Fe.test(v)||!We.test(v)||S!=null&&v in Jr(S)}function Vhe(v){var S=typeof v;return S=="string"||S=="number"||S=="symbol"||S=="boolean"?v!=="__proto__":v===null}function $R(v){var S=Ak(v),E=q[S];if(typeof E!="function"||!(S in rr.prototype))return!1;if(v===E)return!0;var P=IR(E);return!!P&&v===P[0]}function Uhe(v){return!!JV&&JV in v}var Whe=ik?ef:KR;function Dx(v){var S=v&&v.constructor,E=typeof S=="function"&&S.prototype||g0;return v===E}function JU(v){return v===v&&!Ds(v)}function QU(v,S){return function(E){return E==null?!1:E[v]===S&&(S!==t||v in Jr(E))}}function Ghe(v){var S=Dk(v,function(P){return E.size===c&&E.clear(),P}),E=S.cache;return S}function Hhe(v,S){var E=v[1],P=S[1],V=E|P,K=V<(g|y|k),ae=P==k&&E==x||P==k&&E==A&&v[7].length<=S[8]||P==(k|A)&&S[7].length<=S[8]&&E==x;if(!(K||ae))return v;P&g&&(v[2]=S[2],V|=E&g?0:b);var we=S[3];if(we){var Me=v[3];v[3]=Me?DU(Me,we,S[4]):we,v[4]=Me?Xu(v[3],u):S[4]}return we=S[5],we&&(Me=v[5],v[5]=Me?OU(Me,we,S[6]):we,v[6]=Me?Xu(v[5],u):S[6]),we=S[7],we&&(v[7]=we),P&k&&(v[8]=v[8]==null?S[8]:Mo(v[8],S[8])),v[9]==null&&(v[9]=S[9]),v[0]=S[0],v[1]=V,v}function jhe(v){var S=[];if(v!=null)for(var E in Jr(v))S.push(E);return S}function qhe(v){return ak.call(v)}function eW(v,S,E){return S=Fi(S===t?v.length-1:S,0),function(){for(var P=arguments,V=-1,K=Fi(P.length-S,0),ae=Le(K);++V<K;)ae[V]=P[S+V];V=-1;for(var we=Le(S+1);++V<S;)we[V]=P[V];return we[S]=E(ae),Io(v,this,we)}}function tW(v,S){return S.length<2?v:Kp(v,Yl(S,0,-1))}function Xhe(v,S){for(var E=v.length,P=Mo(S.length,E),V=Ma(v);P--;){var K=S[P];v[P]=Qh(K,E)?V[K]:t}return v}function RR(v,S){if(!(S==="constructor"&&typeof v[S]=="function")&&S!="__proto__")return v[S]}var nW=sW(kU),Ox=cue||function(v,S){return di.setTimeout(v,S)},PR=sW(yhe);function rW(v,S,E){var P=S+"";return PR(v,zhe(P,Khe(Ohe(P),E)))}function sW(v){var S=0,E=0;return function(){var P=due(),V=R-(P-E);if(E=P,V>0){if(++S>=O)return arguments[0]}else S=0;return v.apply(t,arguments)}}function Nk(v,S){var E=-1,P=v.length,V=P-1;for(S=S===t?P:S;++E<S;){var K=gR(E,V),ae=v[K];v[K]=v[E],v[E]=ae}return v.length=S,v}var iW=Ghe(function(v){var S=[];return v.charCodeAt(0)===46&&S.push(""),v.replace(Ze,function(E,P,V,K){S.push(V?K.replace(Pi,"$1"):P||E)}),S});function Zu(v){if(typeof v=="string"||ll(v))return v;var S=v+"";return S=="0"&&1/v==-X?"-0":S}function Zp(v){if(v!=null){try{return ok.call(v)}catch{}try{return v+""}catch{}}return""}function Khe(v,S){return Ia(De,function(E){var P="_."+E[0];S&E[1]&&!h0(v,P)&&v.push(P)}),v.sort()}function oW(v){if(v instanceof rr)return v.clone();var S=new Xl(v.__wrapped__,v.__chain__);return S.__actions__=Ma(v.__actions__),S.__index__=v.__index__,S.__values__=v.__values__,S}function Yhe(v,S,E){(E?sa(v,S,E):S===t)?S=1:S=Fi(Gn(S),0);var P=v==null?0:v.length;if(!P||S<1)return[];for(var V=0,K=0,ae=Le(dk(P/S));V<P;)ae[K++]=Yl(v,V,V+=S);return ae}function Zhe(v){for(var S=-1,E=v==null?0:v.length,P=0,V=[];++S<E;){var K=v[S];K&&(V[P++]=K)}return V}function Jhe(){var v=arguments.length;if(!v)return[];for(var S=Le(v-1),E=arguments[0],P=v;P--;)S[P-1]=arguments[P];return ju(On(E)?Ma(E):[E],go(S,1))}var Qhe=Yn(function(v,S){return ti(v)?Mx(v,go(S,1,ti,!0)):[]}),efe=Yn(function(v,S){var E=Zl(S);return ti(E)&&(E=t),ti(v)?Mx(v,go(S,1,ti,!0),hn(E,2)):[]}),tfe=Yn(function(v,S){var E=Zl(S);return ti(E)&&(E=t),ti(v)?Mx(v,go(S,1,ti,!0),t,E):[]});function nfe(v,S,E){var P=v==null?0:v.length;return P?(S=E||S===t?1:Gn(S),Yl(v,S<0?0:S,P)):[]}function rfe(v,S,E){var P=v==null?0:v.length;return P?(S=E||S===t?1:Gn(S),S=P-S,Yl(v,0,S<0?0:S)):[]}function sfe(v,S){return v&&v.length?_k(v,hn(S,3),!0,!0):[]}function ife(v,S){return v&&v.length?_k(v,hn(S,3),!0):[]}function ofe(v,S,E,P){var V=v==null?0:v.length;return V?(E&&typeof E!="number"&&sa(v,S,E)&&(E=0,P=V),Jue(v,S,E,P)):[]}function aW(v,S,E){var P=v==null?0:v.length;if(!P)return-1;var V=E==null?0:Gn(E);return V<0&&(V=Fi(P+V,0)),Gp(v,hn(S,3),V)}function lW(v,S,E){var P=v==null?0:v.length;if(!P)return-1;var V=P-1;return E!==t&&(V=Gn(E),V=E<0?Fi(P+V,0):Mo(V,P-1)),Gp(v,hn(S,3),V,!0)}function cW(v){var S=v==null?0:v.length;return S?go(v,1):[]}function afe(v){var S=v==null?0:v.length;return S?go(v,X):[]}function lfe(v,S){var E=v==null?0:v.length;return E?(S=S===t?1:Gn(S),go(v,S)):[]}function cfe(v){for(var S=-1,E=v==null?0:v.length,P={};++S<E;){var V=v[S];P[V[0]]=V[1]}return P}function uW(v){return v&&v.length?v[0]:t}function ufe(v,S,E){var P=v==null?0:v.length;if(!P)return-1;var V=E==null?0:Gn(E);return V<0&&(V=Fi(P+V,0)),T(v,S,V)}function hfe(v){var S=v==null?0:v.length;return S?Yl(v,0,-1):[]}var ffe=Yn(function(v){var S=Vr(v,xR);return S.length&&S[0]===v[0]?hR(S):[]}),dfe=Yn(function(v){var S=Zl(v),E=Vr(v,xR);return S===Zl(E)?S=t:E.pop(),E.length&&E[0]===v[0]?hR(E,hn(S,2)):[]}),pfe=Yn(function(v){var S=Zl(v),E=Vr(v,xR);return S=typeof S=="function"?S:t,S&&E.pop(),E.length&&E[0]===v[0]?hR(E,t,S):[]});function mfe(v,S){return v==null?"":hue.call(v,S)}function Zl(v){var S=v==null?0:v.length;return S?v[S-1]:t}function gfe(v,S,E){var P=v==null?0:v.length;if(!P)return-1;var V=P;return E!==t&&(V=Gn(E),V=V<0?Fi(P+V,0):Mo(V,P-1)),S===S?Kce(v,S,V):Gp(v,L,V,!0)}function yfe(v,S){return v&&v.length?xU(v,Gn(S)):t}var bfe=Yn(hW);function hW(v,S){return v&&v.length&&S&&S.length?mR(v,S):v}function vfe(v,S,E){return v&&v.length&&S&&S.length?mR(v,S,hn(E,2)):v}function wfe(v,S,E){return v&&v.length&&S&&S.length?mR(v,S,t,E):v}var xfe=Jh(function(v,S){var E=v==null?0:v.length,P=aR(v,S);return CU(v,Vr(S,function(V){return Qh(V,E)?+V:V}).sort(PU)),P});function Sfe(v,S){var E=[];if(!(v&&v.length))return E;var P=-1,V=[],K=v.length;for(S=hn(S,3);++P<K;){var ae=v[P];S(ae,P,v)&&(E.push(ae),V.push(P))}return CU(v,V),E}function DR(v){return v==null?v:mue.call(v)}function _fe(v,S,E){var P=v==null?0:v.length;return P?(E&&typeof E!="number"&&sa(v,S,E)?(S=0,E=P):(S=S==null?0:Gn(S),E=E===t?P:Gn(E)),Yl(v,S,E)):[]}function Cfe(v,S){return Sk(v,S)}function kfe(v,S,E){return bR(v,S,hn(E,2))}function Tfe(v,S){var E=v==null?0:v.length;if(E){var P=Sk(v,S);if(P<E&&Xc(v[P],S))return P}return-1}function Efe(v,S){return Sk(v,S,!0)}function Ife(v,S,E){return bR(v,S,hn(E,2),!0)}function Afe(v,S){var E=v==null?0:v.length;if(E){var P=Sk(v,S,!0)-1;if(Xc(v[P],S))return P}return-1}function Mfe(v){return v&&v.length?TU(v):[]}function Nfe(v,S){return v&&v.length?TU(v,hn(S,2)):[]}function $fe(v){var S=v==null?0:v.length;return S?Yl(v,1,S):[]}function Rfe(v,S,E){return v&&v.length?(S=E||S===t?1:Gn(S),Yl(v,0,S<0?0:S)):[]}function Pfe(v,S,E){var P=v==null?0:v.length;return P?(S=E||S===t?1:Gn(S),S=P-S,Yl(v,S<0?0:S,P)):[]}function Dfe(v,S){return v&&v.length?_k(v,hn(S,3),!1,!0):[]}function Ofe(v,S){return v&&v.length?_k(v,hn(S,3)):[]}var Ffe=Yn(function(v){return id(go(v,1,ti,!0))}),Lfe=Yn(function(v){var S=Zl(v);return ti(S)&&(S=t),id(go(v,1,ti,!0),hn(S,2))}),zfe=Yn(function(v){var S=Zl(v);return S=typeof S=="function"?S:t,id(go(v,1,ti,!0),t,S)});function Bfe(v){return v&&v.length?id(v):[]}function Vfe(v,S){return v&&v.length?id(v,hn(S,2)):[]}function Ufe(v,S){return S=typeof S=="function"?S:t,v&&v.length?id(v,t,S):[]}function OR(v){if(!(v&&v.length))return[];var S=0;return v=Hc(v,function(E){if(ti(E))return S=Fi(E.length,S),!0}),ft(S,function(E){return Vr(v,ne(E))})}function fW(v,S){if(!(v&&v.length))return[];var E=OR(v);return S==null?E:Vr(E,function(P){return Io(S,t,P)})}var Wfe=Yn(function(v,S){return ti(v)?Mx(v,S):[]}),Gfe=Yn(function(v){return wR(Hc(v,ti))}),Hfe=Yn(function(v){var S=Zl(v);return ti(S)&&(S=t),wR(Hc(v,ti),hn(S,2))}),jfe=Yn(function(v){var S=Zl(v);return S=typeof S=="function"?S:t,wR(Hc(v,ti),t,S)}),qfe=Yn(OR);function Xfe(v,S){return MU(v||[],S||[],Ax)}function Kfe(v,S){return MU(v||[],S||[],Rx)}var Yfe=Yn(function(v){var S=v.length,E=S>1?v[S-1]:t;return E=typeof E=="function"?(v.pop(),E):t,fW(v,E)});function dW(v){var S=q(v);return S.__chain__=!0,S}function Zfe(v,S){return S(v),v}function $k(v,S){return S(v)}var Jfe=Jh(function(v){var S=v.length,E=S?v[0]:0,P=this.__wrapped__,V=function(K){return aR(K,v)};return S>1||this.__actions__.length||!(P instanceof rr)||!Qh(E)?this.thru(V):(P=P.slice(E,+E+(S?1:0)),P.__actions__.push({func:$k,args:[V],thisArg:t}),new Xl(P,this.__chain__).thru(function(K){return S&&!K.length&&K.push(t),K}))});function Qfe(){return dW(this)}function ede(){return new Xl(this.value(),this.__chain__)}function tde(){this.__values__===t&&(this.__values__=EW(this.value()));var v=this.__index__>=this.__values__.length,S=v?t:this.__values__[this.__index__++];return{done:v,value:S}}function nde(){return this}function rde(v){for(var S,E=this;E instanceof yk;){var P=oW(E);P.__index__=0,P.__values__=t,S?V.__wrapped__=P:S=P;var V=P;E=E.__wrapped__}return V.__wrapped__=v,S}function sde(){var v=this.__wrapped__;if(v instanceof rr){var S=v;return this.__actions__.length&&(S=new rr(this)),S=S.reverse(),S.__actions__.push({func:$k,args:[DR],thisArg:t}),new Xl(S,this.__chain__)}return this.thru(DR)}function ide(){return AU(this.__wrapped__,this.__actions__)}var ode=Ck(function(v,S,E){Pr.call(v,E)?++v[E]:Yh(v,E,1)});function ade(v,S,E){var P=On(v)?nk:Zue;return E&&sa(v,S,E)&&(S=t),P(v,hn(S,3))}function lde(v,S){var E=On(v)?Hc:fU;return E(v,hn(S,3))}var cde=BU(aW),ude=BU(lW);function hde(v,S){return go(Rk(v,S),1)}function fde(v,S){return go(Rk(v,S),X)}function dde(v,S,E){return E=E===t?1:Gn(E),go(Rk(v,S),E)}function pW(v,S){var E=On(v)?Ia:sd;return E(v,hn(S,3))}function mW(v,S){var E=On(v)?Y$:hU;return E(v,hn(S,3))}var pde=Ck(function(v,S,E){Pr.call(v,E)?v[E].push(S):Yh(v,E,[S])});function mde(v,S,E,P){v=Na(v)?v:C0(v),E=E&&!P?Gn(E):0;var V=v.length;return E<0&&(E=Fi(V+E,0)),Lk(v)?E<=V&&v.indexOf(S,E)>-1:!!V&&T(v,S,E)>-1}var gde=Yn(function(v,S,E){var P=-1,V=typeof S=="function",K=Na(v)?Le(v.length):[];return sd(v,function(ae){K[++P]=V?Io(S,ae,E):Nx(ae,S,E)}),K}),yde=Ck(function(v,S,E){Yh(v,E,S)});function Rk(v,S){var E=On(v)?Vr:bU;return E(v,hn(S,3))}function bde(v,S,E,P){return v==null?[]:(On(S)||(S=S==null?[]:[S]),E=P?t:E,On(E)||(E=E==null?[]:[E]),SU(v,S,E))}var vde=Ck(function(v,S,E){v[E?0:1].push(S)},function(){return[[],[]]});function wde(v,S,E){var P=On(v)?xx:se,V=arguments.length<3;return P(v,hn(S,4),E,V,sd)}function xde(v,S,E){var P=On(v)?Z$:se,V=arguments.length<3;return P(v,hn(S,4),E,V,hU)}function Sde(v,S){var E=On(v)?Hc:fU;return E(v,Ok(hn(S,3)))}function _de(v){var S=On(v)?aU:mhe;return S(v)}function Cde(v,S,E){(E?sa(v,S,E):S===t)?S=1:S=Gn(S);var P=On(v)?jue:ghe;return P(v,S)}function kde(v){var S=On(v)?que:bhe;return S(v)}function Tde(v){if(v==null)return 0;if(Na(v))return Lk(v)?p0(v):v.length;var S=No(v);return S==Be||S==me?v.size:dR(v).length}function Ede(v,S,E){var P=On(v)?nd:vhe;return E&&sa(v,S,E)&&(S=t),P(v,hn(S,3))}var Ide=Yn(function(v,S){if(v==null)return[];var E=S.length;return E>1&&sa(v,S[0],S[1])?S=[]:E>2&&sa(S[0],S[1],S[2])&&(S=[S[0]]),SU(v,go(S,1),[])}),Pk=lue||function(){return di.Date.now()};function Ade(v,S){if(typeof S!="function")throw new ql(o);return v=Gn(v),function(){if(--v<1)return S.apply(this,arguments)}}function gW(v,S,E){return S=E?t:S,S=v&&S==null?v.length:S,Zh(v,k,t,t,t,t,S)}function yW(v,S){var E;if(typeof S!="function")throw new ql(o);return v=Gn(v),function(){return--v>0&&(E=S.apply(this,arguments)),v<=1&&(S=t),E}}var FR=Yn(function(v,S,E){var P=g;if(E.length){var V=Xu(E,S0(FR));P|=_}return Zh(v,P,S,E,V)}),bW=Yn(function(v,S,E){var P=g|y;if(E.length){var V=Xu(E,S0(bW));P|=_}return Zh(S,P,v,E,V)});function vW(v,S,E){S=E?t:S;var P=Zh(v,x,t,t,t,t,t,S);return P.placeholder=vW.placeholder,P}function wW(v,S,E){S=E?t:S;var P=Zh(v,w,t,t,t,t,t,S);return P.placeholder=wW.placeholder,P}function xW(v,S,E){var P,V,K,ae,we,Me,Je=0,et=!1,ct=!1,Ot=!0;if(typeof v!="function")throw new ql(o);S=Jl(S)||0,Ds(E)&&(et=!!E.leading,ct="maxWait"in E,K=ct?Fi(Jl(E.maxWait)||0,S):K,Ot="trailing"in E?!!E.trailing:Ot);function tn(ni){var Kc=P,nf=V;return P=V=t,Je=ni,ae=v.apply(nf,Kc),ae}function pn(ni){return Je=ni,we=Ox(tr,S),et?tn(ni):ae}function Xn(ni){var Kc=ni-Me,nf=ni-Je,BW=S-Kc;return ct?Mo(BW,K-nf):BW}function mn(ni){var Kc=ni-Me,nf=ni-Je;return Me===t||Kc>=S||Kc<0||ct&&nf>=K}function tr(){var ni=Pk();if(mn(ni))return ur(ni);we=Ox(tr,Xn(ni))}function ur(ni){return we=t,Ot&&P?tn(ni):(P=V=t,ae)}function cl(){we!==t&&NU(we),Je=0,P=Me=V=we=t}function ia(){return we===t?ae:ur(Pk())}function ul(){var ni=Pk(),Kc=mn(ni);if(P=arguments,V=this,Me=ni,Kc){if(we===t)return pn(Me);if(ct)return NU(we),we=Ox(tr,S),tn(Me)}return we===t&&(we=Ox(tr,S)),ae}return ul.cancel=cl,ul.flush=ia,ul}var Mde=Yn(function(v,S){return uU(v,1,S)}),Nde=Yn(function(v,S,E){return uU(v,Jl(S)||0,E)});function $de(v){return Zh(v,M)}function Dk(v,S){if(typeof v!="function"||S!=null&&typeof S!="function")throw new ql(o);var E=function(){var P=arguments,V=S?S.apply(this,P):P[0],K=E.cache;if(K.has(V))return K.get(V);var ae=v.apply(this,P);return E.cache=K.set(V,ae)||K,ae};return E.cache=new(Dk.Cache||Kh),E}Dk.Cache=Kh;function Ok(v){if(typeof v!="function")throw new ql(o);return function(){var S=arguments;switch(S.length){case 0:return!v.call(this);case 1:return!v.call(this,S[0]);case 2:return!v.call(this,S[0],S[1]);case 3:return!v.call(this,S[0],S[1],S[2])}return!v.apply(this,S)}}function Rde(v){return yW(2,v)}var Pde=whe(function(v,S){S=S.length==1&&On(S[0])?Vr(S[0],Ut(hn())):Vr(go(S,1),Ut(hn()));var E=S.length;return Yn(function(P){for(var V=-1,K=Mo(P.length,E);++V<K;)P[V]=S[V].call(this,P[V]);return Io(v,this,P)})}),LR=Yn(function(v,S){var E=Xu(S,S0(LR));return Zh(v,_,t,S,E)}),SW=Yn(function(v,S){var E=Xu(S,S0(SW));return Zh(v,C,t,S,E)}),Dde=Jh(function(v,S){return Zh(v,A,t,t,t,S)});function Ode(v,S){if(typeof v!="function")throw new ql(o);return S=S===t?S:Gn(S),Yn(v,S)}function Fde(v,S){if(typeof v!="function")throw new ql(o);return S=S==null?0:Fi(Gn(S),0),Yn(function(E){var P=E[S],V=ad(E,0,S);return P&&ju(V,P),Io(v,this,V)})}function Lde(v,S,E){var P=!0,V=!0;if(typeof v!="function")throw new ql(o);return Ds(E)&&(P="leading"in E?!!E.leading:P,V="trailing"in E?!!E.trailing:V),xW(v,S,{leading:P,maxWait:S,trailing:V})}function zde(v){return gW(v,1)}function Bde(v,S){return LR(SR(S),v)}function Vde(){if(!arguments.length)return[];var v=arguments[0];return On(v)?v:[v]}function Ude(v){return Kl(v,d)}function Wde(v,S){return S=typeof S=="function"?S:t,Kl(v,d,S)}function Gde(v){return Kl(v,h|d)}function Hde(v,S){return S=typeof S=="function"?S:t,Kl(v,h|d,S)}function jde(v,S){return S==null||cU(v,S,eo(S))}function Xc(v,S){return v===S||v!==v&&S!==S}var qde=Ik(uR),Xde=Ik(function(v,S){return v>=S}),Jp=mU(function(){return arguments}())?mU:function(v){return Ws(v)&&Pr.call(v,"callee")&&!tU.call(v,"callee")},On=Le.isArray,Kde=QC?Ut(QC):rhe;function Na(v){return v!=null&&Fk(v.length)&&!ef(v)}function ti(v){return Ws(v)&&Na(v)}function Yde(v){return v===!0||v===!1||Ws(v)&&ra(v)==it}var ld=uue||KR,Zde=vx?Ut(vx):she;function Jde(v){return Ws(v)&&v.nodeType===1&&!Fx(v)}function Qde(v){if(v==null)return!0;if(Na(v)&&(On(v)||typeof v=="string"||typeof v.splice=="function"||ld(v)||_0(v)||Jp(v)))return!v.length;var S=No(v);if(S==Be||S==me)return!v.size;if(Dx(v))return!dR(v).length;for(var E in v)if(Pr.call(v,E))return!1;return!0}function epe(v,S){return $x(v,S)}function tpe(v,S,E){E=typeof E=="function"?E:t;var P=E?E(v,S):t;return P===t?$x(v,S,t,E):!!P}function zR(v){if(!Ws(v))return!1;var S=ra(v);return S==ut||S==pt||typeof v.message=="string"&&typeof v.name=="string"&&!Fx(v)}function npe(v){return typeof v=="number"&&rU(v)}function ef(v){if(!Ds(v))return!1;var S=ra(v);return S==Ve||S==ze||S==Oe||S==nt}function _W(v){return typeof v=="number"&&v==Gn(v)}function Fk(v){return typeof v=="number"&&v>-1&&v%1==0&&v<=G}function Ds(v){var S=typeof v;return v!=null&&(S=="object"||S=="function")}function Ws(v){return v!=null&&typeof v=="object"}var CW=ek?Ut(ek):ohe;function rpe(v,S){return v===S||fR(v,S,AR(S))}function spe(v,S,E){return E=typeof E=="function"?E:t,fR(v,S,AR(S),E)}function ipe(v){return kW(v)&&v!=+v}function ope(v){if(Whe(v))throw new Pn(i);return gU(v)}function ape(v){return v===null}function lpe(v){return v==null}function kW(v){return typeof v=="number"||Ws(v)&&ra(v)==ht}function Fx(v){if(!Ws(v)||ra(v)!=Q)return!1;var S=uk(v);if(S===null)return!0;var E=Pr.call(S,"constructor")&&S.constructor;return typeof E=="function"&&E instanceof E&&ok.call(E)==sue}var BR=tk?Ut(tk):ahe;function cpe(v){return _W(v)&&v>=-G&&v<=G}var TW=c0?Ut(c0):lhe;function Lk(v){return typeof v=="string"||!On(v)&&Ws(v)&&ra(v)==Ye}function ll(v){return typeof v=="symbol"||Ws(v)&&ra(v)==bt}var _0=u0?Ut(u0):che;function upe(v){return v===t}function hpe(v){return Ws(v)&&No(v)==dt}function fpe(v){return Ws(v)&&ra(v)==le}var dpe=Ik(pR),ppe=Ik(function(v,S){return v<=S});function EW(v){if(!v)return[];if(Na(v))return Lk(v)?jc(v):Ma(v);if(Cx&&v[Cx])return tR(v[Cx]());var S=No(v),E=S==Be?_x:S==me?f0:C0;return E(v)}function tf(v){if(!v)return v===0?v:0;if(v=Jl(v),v===X||v===-X){var S=v<0?-1:1;return S*ee}return v===v?v:0}function Gn(v){var S=tf(v),E=S%1;return S===S?E?S-E:S:0}function IW(v){return v?Xp(Gn(v),0,oe):0}function Jl(v){if(typeof v=="number")return v;if(ll(v))return pe;if(Ds(v)){var S=typeof v.valueOf=="function"?v.valueOf():v;v=Ds(S)?S+"":S}if(typeof v!="string")return v===0?v:+v;v=un(v);var E=To.test(v);return E||po.test(v)?X$(v.slice(2),E?2:8):Ar.test(v)?pe:+v}function AW(v){return Yu(v,$a(v))}function mpe(v){return v?Xp(Gn(v),-G,G):v===0?v:0}function Mr(v){return v==null?"":al(v)}var gpe=w0(function(v,S){if(Dx(S)||Na(S)){Yu(S,eo(S),v);return}for(var E in S)Pr.call(S,E)&&Ax(v,E,S[E])}),MW=w0(function(v,S){Yu(S,$a(S),v)}),zk=w0(function(v,S,E,P){Yu(S,$a(S),v,P)}),ype=w0(function(v,S,E,P){Yu(S,eo(S),v,P)}),bpe=Jh(aR);function vpe(v,S){var E=v0(v);return S==null?E:lU(E,S)}var wpe=Yn(function(v,S){v=Jr(v);var E=-1,P=S.length,V=P>2?S[2]:t;for(V&&sa(S[0],S[1],V)&&(P=1);++E<P;)for(var K=S[E],ae=$a(K),we=-1,Me=ae.length;++we<Me;){var Je=ae[we],et=v[Je];(et===t||Xc(et,g0[Je])&&!Pr.call(v,Je))&&(v[Je]=K[Je])}return v}),xpe=Yn(function(v){return v.push(t,qU),Io(NW,t,v)});function Spe(v,S){return Sx(v,hn(S,3),Ku)}function _pe(v,S){return Sx(v,hn(S,3),cR)}function Cpe(v,S){return v==null?v:lR(v,hn(S,3),$a)}function kpe(v,S){return v==null?v:dU(v,hn(S,3),$a)}function Tpe(v,S){return v&&Ku(v,hn(S,3))}function Epe(v,S){return v&&cR(v,hn(S,3))}function Ipe(v){return v==null?[]:wk(v,eo(v))}function Ape(v){return v==null?[]:wk(v,$a(v))}function VR(v,S,E){var P=v==null?t:Kp(v,S);return P===t?E:P}function Mpe(v,S){return v!=null&&YU(v,S,Que)}function UR(v,S){return v!=null&&YU(v,S,ehe)}var Npe=UU(function(v,S,E){S!=null&&typeof S.toString!="function"&&(S=ak.call(S)),v[S]=E},GR(Ra)),$pe=UU(function(v,S,E){S!=null&&typeof S.toString!="function"&&(S=ak.call(S)),Pr.call(v,S)?v[S].push(E):v[S]=[E]},hn),Rpe=Yn(Nx);function eo(v){return Na(v)?oU(v):dR(v)}function $a(v){return Na(v)?oU(v,!0):uhe(v)}function Ppe(v,S){var E={};return S=hn(S,3),Ku(v,function(P,V,K){Yh(E,S(P,V,K),P)}),E}function Dpe(v,S){var E={};return S=hn(S,3),Ku(v,function(P,V,K){Yh(E,V,S(P,V,K))}),E}var Ope=w0(function(v,S,E){xk(v,S,E)}),NW=w0(function(v,S,E,P){xk(v,S,E,P)}),Fpe=Jh(function(v,S){var E={};if(v==null)return E;var P=!1;S=Vr(S,function(K){return K=od(K,v),P||(P=K.length>1),K}),Yu(v,ER(v),E),P&&(E=Kl(E,h|f|d,Nhe));for(var V=S.length;V--;)vR(E,S[V]);return E});function Lpe(v,S){return $W(v,Ok(hn(S)))}var zpe=Jh(function(v,S){return v==null?{}:fhe(v,S)});function $W(v,S){if(v==null)return{};var E=Vr(ER(v),function(P){return[P]});return S=hn(S),_U(v,E,function(P,V){return S(P,V[0])})}function Bpe(v,S,E){S=od(S,v);var P=-1,V=S.length;for(V||(V=1,v=t);++P<V;){var K=v==null?t:v[Zu(S[P])];K===t&&(P=V,K=E),v=ef(K)?K.call(v):K}return v}function Vpe(v,S,E){return v==null?v:Rx(v,S,E)}function Upe(v,S,E,P){return P=typeof P=="function"?P:t,v==null?v:Rx(v,S,E,P)}var RW=HU(eo),PW=HU($a);function Wpe(v,S,E){var P=On(v),V=P||ld(v)||_0(v);if(S=hn(S,4),E==null){var K=v&&v.constructor;V?E=P?new K:[]:Ds(v)?E=ef(K)?v0(uk(v)):{}:E={}}return(V?Ia:Ku)(v,function(ae,we,Me){return S(E,ae,we,Me)}),E}function Gpe(v,S){return v==null?!0:vR(v,S)}function Hpe(v,S,E){return v==null?v:IU(v,S,SR(E))}function jpe(v,S,E,P){return P=typeof P=="function"?P:t,v==null?v:IU(v,S,SR(E),P)}function C0(v){return v==null?[]:Nt(v,eo(v))}function qpe(v){return v==null?[]:Nt(v,$a(v))}function Xpe(v,S,E){return E===t&&(E=S,S=t),E!==t&&(E=Jl(E),E=E===E?E:0),S!==t&&(S=Jl(S),S=S===S?S:0),Xp(Jl(v),S,E)}function Kpe(v,S,E){return S=tf(S),E===t?(E=S,S=0):E=tf(E),v=Jl(v),the(v,S,E)}function Ype(v,S,E){if(E&&typeof E!="boolean"&&sa(v,S,E)&&(S=E=t),E===t&&(typeof S=="boolean"?(E=S,S=t):typeof v=="boolean"&&(E=v,v=t)),v===t&&S===t?(v=0,S=1):(v=tf(v),S===t?(S=v,v=0):S=tf(S)),v>S){var P=v;v=S,S=P}if(E||v%1||S%1){var V=sU();return Mo(v+V*(S-v+bx("1e-"+((V+"").length-1))),S)}return gR(v,S)}var Zpe=x0(function(v,S,E){return S=S.toLowerCase(),v+(E?DW(S):S)});function DW(v){return WR(Mr(v).toLowerCase())}function OW(v){return v=Mr(v),v&&v.replace($s,Di).replace(mx,"")}function Jpe(v,S,E){v=Mr(v),S=al(S);var P=v.length;E=E===t?P:Xp(Gn(E),0,P);var V=E;return E-=S.length,E>=0&&v.slice(E,V)==S}function Qpe(v){return v=Mr(v),v&&zh.test(v)?v.replace(Vc,Aa):v}function eme(v){return v=Mr(v),v&&zn.test(v)?v.replace(wt,"\\$&"):v}var tme=x0(function(v,S,E){return v+(E?"-":"")+S.toLowerCase()}),nme=x0(function(v,S,E){return v+(E?" ":"")+S.toLowerCase()}),rme=zU("toLowerCase");function sme(v,S,E){v=Mr(v),S=Gn(S);var P=S?p0(v):0;if(!S||P>=S)return v;var V=(S-P)/2;return Ek(pk(V),E)+v+Ek(dk(V),E)}function ime(v,S,E){v=Mr(v),S=Gn(S);var P=S?p0(v):0;return S&&P<S?v+Ek(S-P,E):v}function ome(v,S,E){v=Mr(v),S=Gn(S);var P=S?p0(v):0;return S&&P<S?Ek(S-P,E)+v:v}function ame(v,S,E){return E||S==null?S=0:S&&(S=+S),pue(Mr(v).replace(sn,""),S||0)}function lme(v,S,E){return(E?sa(v,S,E):S===t)?S=1:S=Gn(S),yR(Mr(v),S)}function cme(){var v=arguments,S=Mr(v[0]);return v.length<3?S:S.replace(v[1],v[2])}var ume=x0(function(v,S,E){return v+(E?"_":"")+S.toLowerCase()});function hme(v,S,E){return E&&typeof E!="number"&&sa(v,S,E)&&(S=E=t),E=E===t?oe:E>>>0,E?(v=Mr(v),v&&(typeof S=="string"||S!=null&&!BR(S))&&(S=al(S),!S&&Ss(v))?ad(jc(v),0,E):v.split(S,E)):[]}var fme=x0(function(v,S,E){return v+(E?" ":"")+WR(S)});function dme(v,S,E){return v=Mr(v),E=E==null?0:Xp(Gn(E),0,v.length),S=al(S),v.slice(E,E+S.length)==S}function pme(v,S,E){var P=q.templateSettings;E&&sa(v,S,E)&&(S=t),v=Mr(v),S=zk({},S,P,jU);var V=zk({},S.imports,P.imports,jU),K=eo(V),ae=Nt(V,K),we,Me,Je=0,et=S.interpolate||mo,ct="__p += '",Ot=nR((S.escape||mo).source+"|"+et.source+"|"+(et===re?wr:mo).source+"|"+(S.evaluate||mo).source+"|$","g"),tn="//# sourceURL="+(Pr.call(S,"sourceURL")?(S.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++q$+"]")+`
`;v.replace(Ot,function(mn,tr,ur,cl,ia,ul){return ur||(ur=cl),ct+=v.slice(Je,ul).replace(Vh,Ao),tr&&(we=!0,ct+=`' +
__e(`+tr+`) +
'`),ia&&(Me=!0,ct+=`';
`+ia+`;
__p += '`),ur&&(ct+=`' +
((__t = (`+ur+`)) == null ? '' : __t) +
'`),Je=ul+mn.length,mn}),ct+=`';
`;var pn=Pr.call(S,"variable")&&S.variable;if(!pn)ct=`with (obj) {
`+ct+`
}
`;else if(cr.test(pn))throw new Pn(a);ct=(Me?ct.replace(Gl,""):ct).replace(fo,"$1").replace(Hl,"$1;"),ct="function("+(pn||"obj")+`) {
`+(pn?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(we?", __e = _.escape":"")+(Me?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+ct+`return __p
}`;var Xn=LW(function(){return Tr(K,tn+"return "+ct).apply(t,ae)});if(Xn.source=ct,zR(Xn))throw Xn;return Xn}function mme(v){return Mr(v).toLowerCase()}function gme(v){return Mr(v).toUpperCase()}function yme(v,S,E){if(v=Mr(v),v&&(E||S===t))return un(v);if(!v||!(S=al(S)))return v;var P=jc(v),V=jc(S),K=Bn(P,V),ae=Ur(P,V)+1;return ad(P,K,ae).join("")}function bme(v,S,E){if(v=Mr(v),v&&(E||S===t))return v.slice(0,ZV(v)+1);if(!v||!(S=al(S)))return v;var P=jc(v),V=Ur(P,jc(S))+1;return ad(P,0,V).join("")}function vme(v,S,E){if(v=Mr(v),v&&(E||S===t))return v.replace(sn,"");if(!v||!(S=al(S)))return v;var P=jc(v),V=Bn(P,jc(S));return ad(P,V).join("")}function wme(v,S){var E=I,P=N;if(Ds(S)){var V="separator"in S?S.separator:V;E="length"in S?Gn(S.length):E,P="omission"in S?al(S.omission):P}v=Mr(v);var K=v.length;if(Ss(v)){var ae=jc(v);K=ae.length}if(E>=K)return v;var we=E-p0(P);if(we<1)return P;var Me=ae?ad(ae,0,we).join(""):v.slice(0,we);if(V===t)return Me+P;if(ae&&(we+=Me.length-we),BR(V)){if(v.slice(we).search(V)){var Je,et=Me;for(V.global||(V=nR(V.source,Mr(Yi.exec(V))+"g")),V.lastIndex=0;Je=V.exec(et);)var ct=Je.index;Me=Me.slice(0,ct===t?we:ct)}}else if(v.indexOf(al(V),we)!=we){var Ot=Me.lastIndexOf(V);Ot>-1&&(Me=Me.slice(0,Ot))}return Me+P}function xme(v){return v=Mr(v),v&&Ri.test(v)?v.replace(Bc,Yce):v}var Sme=x0(function(v,S,E){return v+(E?" ":"")+S.toUpperCase()}),WR=zU("toUpperCase");function FW(v,S,E){return v=Mr(v),S=E?t:S,S===t?qu(v)?Qce(v):eR(v):v.match(S)||[]}var LW=Yn(function(v,S){try{return Io(v,t,S)}catch(E){return zR(E)?E:new Pn(E)}}),_me=Jh(function(v,S){return Ia(S,function(E){E=Zu(E),Yh(v,E,FR(v[E],v))}),v});function Cme(v){var S=v==null?0:v.length,E=hn();return v=S?Vr(v,function(P){if(typeof P[1]!="function")throw new ql(o);return[E(P[0]),P[1]]}):[],Yn(function(P){for(var V=-1;++V<S;){var K=v[V];if(Io(K[0],this,P))return Io(K[1],this,P)}})}function kme(v){return Yue(Kl(v,h))}function GR(v){return function(){return v}}function Tme(v,S){return v==null||v!==v?S:v}var Eme=VU(),Ime=VU(!0);function Ra(v){return v}function HR(v){return yU(typeof v=="function"?v:Kl(v,h))}function Ame(v){return vU(Kl(v,h))}function Mme(v,S){return wU(v,Kl(S,h))}var Nme=Yn(function(v,S){return function(E){return Nx(E,v,S)}}),$me=Yn(function(v,S){return function(E){return Nx(v,E,S)}});function jR(v,S,E){var P=eo(S),V=wk(S,P);E==null&&!(Ds(S)&&(V.length||!P.length))&&(E=S,S=v,v=this,V=wk(S,eo(S)));var K=!(Ds(E)&&"chain"in E)||!!E.chain,ae=ef(v);return Ia(V,function(we){var Me=S[we];v[we]=Me,ae&&(v.prototype[we]=function(){var Je=this.__chain__;if(K||Je){var et=v(this.__wrapped__),ct=et.__actions__=Ma(this.__actions__);return ct.push({func:Me,args:arguments,thisArg:v}),et.__chain__=Je,et}return Me.apply(v,ju([this.value()],arguments))})}),v}function Rme(){return di._===this&&(di._=iue),this}function qR(){}function Pme(v){return v=Gn(v),Yn(function(S){return xU(S,v)})}var Dme=CR(Vr),Ome=CR(nk),Fme=CR(nd);function zW(v){return NR(v)?ne(Zu(v)):dhe(v)}function Lme(v){return function(S){return v==null?t:Kp(v,S)}}var zme=WU(),Bme=WU(!0);function XR(){return[]}function KR(){return!1}function Vme(){return{}}function Ume(){return""}function Wme(){return!0}function Gme(v,S){if(v=Gn(v),v<1||v>G)return[];var E=oe,P=Mo(v,oe);S=hn(S),v-=oe;for(var V=ft(P,S);++E<v;)S(E);return V}function Hme(v){return On(v)?Vr(v,Zu):ll(v)?[v]:Ma(iW(Mr(v)))}function jme(v){var S=++rue;return Mr(v)+S}var qme=Tk(function(v,S){return v+S},0),Xme=kR("ceil"),Kme=Tk(function(v,S){return v/S},1),Yme=kR("floor");function Zme(v){return v&&v.length?vk(v,Ra,uR):t}function Jme(v,S){return v&&v.length?vk(v,hn(S,2),uR):t}function Qme(v){return W(v,Ra)}function ege(v,S){return W(v,hn(S,2))}function tge(v){return v&&v.length?vk(v,Ra,pR):t}function nge(v,S){return v&&v.length?vk(v,hn(S,2),pR):t}var rge=Tk(function(v,S){return v*S},1),sge=kR("round"),ige=Tk(function(v,S){return v-S},0);function oge(v){return v&&v.length?Pe(v,Ra):0}function age(v,S){return v&&v.length?Pe(v,hn(S,2)):0}return q.after=Ade,q.ary=gW,q.assign=gpe,q.assignIn=MW,q.assignInWith=zk,q.assignWith=ype,q.at=bpe,q.before=yW,q.bind=FR,q.bindAll=_me,q.bindKey=bW,q.castArray=Vde,q.chain=dW,q.chunk=Yhe,q.compact=Zhe,q.concat=Jhe,q.cond=Cme,q.conforms=kme,q.constant=GR,q.countBy=ode,q.create=vpe,q.curry=vW,q.curryRight=wW,q.debounce=xW,q.defaults=wpe,q.defaultsDeep=xpe,q.defer=Mde,q.delay=Nde,q.difference=Qhe,q.differenceBy=efe,q.differenceWith=tfe,q.drop=nfe,q.dropRight=rfe,q.dropRightWhile=sfe,q.dropWhile=ife,q.fill=ofe,q.filter=lde,q.flatMap=hde,q.flatMapDeep=fde,q.flatMapDepth=dde,q.flatten=cW,q.flattenDeep=afe,q.flattenDepth=lfe,q.flip=$de,q.flow=Eme,q.flowRight=Ime,q.fromPairs=cfe,q.functions=Ipe,q.functionsIn=Ape,q.groupBy=pde,q.initial=hfe,q.intersection=ffe,q.intersectionBy=dfe,q.intersectionWith=pfe,q.invert=Npe,q.invertBy=$pe,q.invokeMap=gde,q.iteratee=HR,q.keyBy=yde,q.keys=eo,q.keysIn=$a,q.map=Rk,q.mapKeys=Ppe,q.mapValues=Dpe,q.matches=Ame,q.matchesProperty=Mme,q.memoize=Dk,q.merge=Ope,q.mergeWith=NW,q.method=Nme,q.methodOf=$me,q.mixin=jR,q.negate=Ok,q.nthArg=Pme,q.omit=Fpe,q.omitBy=Lpe,q.once=Rde,q.orderBy=bde,q.over=Dme,q.overArgs=Pde,q.overEvery=Ome,q.overSome=Fme,q.partial=LR,q.partialRight=SW,q.partition=vde,q.pick=zpe,q.pickBy=$W,q.property=zW,q.propertyOf=Lme,q.pull=bfe,q.pullAll=hW,q.pullAllBy=vfe,q.pullAllWith=wfe,q.pullAt=xfe,q.range=zme,q.rangeRight=Bme,q.rearg=Dde,q.reject=Sde,q.remove=Sfe,q.rest=Ode,q.reverse=DR,q.sampleSize=Cde,q.set=Vpe,q.setWith=Upe,q.shuffle=kde,q.slice=_fe,q.sortBy=Ide,q.sortedUniq=Mfe,q.sortedUniqBy=Nfe,q.split=hme,q.spread=Fde,q.tail=$fe,q.take=Rfe,q.takeRight=Pfe,q.takeRightWhile=Dfe,q.takeWhile=Ofe,q.tap=Zfe,q.throttle=Lde,q.thru=$k,q.toArray=EW,q.toPairs=RW,q.toPairsIn=PW,q.toPath=Hme,q.toPlainObject=AW,q.transform=Wpe,q.unary=zde,q.union=Ffe,q.unionBy=Lfe,q.unionWith=zfe,q.uniq=Bfe,q.uniqBy=Vfe,q.uniqWith=Ufe,q.unset=Gpe,q.unzip=OR,q.unzipWith=fW,q.update=Hpe,q.updateWith=jpe,q.values=C0,q.valuesIn=qpe,q.without=Wfe,q.words=FW,q.wrap=Bde,q.xor=Gfe,q.xorBy=Hfe,q.xorWith=jfe,q.zip=qfe,q.zipObject=Xfe,q.zipObjectDeep=Kfe,q.zipWith=Yfe,q.entries=RW,q.entriesIn=PW,q.extend=MW,q.extendWith=zk,jR(q,q),q.add=qme,q.attempt=LW,q.camelCase=Zpe,q.capitalize=DW,q.ceil=Xme,q.clamp=Xpe,q.clone=Ude,q.cloneDeep=Gde,q.cloneDeepWith=Hde,q.cloneWith=Wde,q.conformsTo=jde,q.deburr=OW,q.defaultTo=Tme,q.divide=Kme,q.endsWith=Jpe,q.eq=Xc,q.escape=Qpe,q.escapeRegExp=eme,q.every=ade,q.find=cde,q.findIndex=aW,q.findKey=Spe,q.findLast=ude,q.findLastIndex=lW,q.findLastKey=_pe,q.floor=Yme,q.forEach=pW,q.forEachRight=mW,q.forIn=Cpe,q.forInRight=kpe,q.forOwn=Tpe,q.forOwnRight=Epe,q.get=VR,q.gt=qde,q.gte=Xde,q.has=Mpe,q.hasIn=UR,q.head=uW,q.identity=Ra,q.includes=mde,q.indexOf=ufe,q.inRange=Kpe,q.invoke=Rpe,q.isArguments=Jp,q.isArray=On,q.isArrayBuffer=Kde,q.isArrayLike=Na,q.isArrayLikeObject=ti,q.isBoolean=Yde,q.isBuffer=ld,q.isDate=Zde,q.isElement=Jde,q.isEmpty=Qde,q.isEqual=epe,q.isEqualWith=tpe,q.isError=zR,q.isFinite=npe,q.isFunction=ef,q.isInteger=_W,q.isLength=Fk,q.isMap=CW,q.isMatch=rpe,q.isMatchWith=spe,q.isNaN=ipe,q.isNative=ope,q.isNil=lpe,q.isNull=ape,q.isNumber=kW,q.isObject=Ds,q.isObjectLike=Ws,q.isPlainObject=Fx,q.isRegExp=BR,q.isSafeInteger=cpe,q.isSet=TW,q.isString=Lk,q.isSymbol=ll,q.isTypedArray=_0,q.isUndefined=upe,q.isWeakMap=hpe,q.isWeakSet=fpe,q.join=mfe,q.kebabCase=tme,q.last=Zl,q.lastIndexOf=gfe,q.lowerCase=nme,q.lowerFirst=rme,q.lt=dpe,q.lte=ppe,q.max=Zme,q.maxBy=Jme,q.mean=Qme,q.meanBy=ege,q.min=tge,q.minBy=nge,q.stubArray=XR,q.stubFalse=KR,q.stubObject=Vme,q.stubString=Ume,q.stubTrue=Wme,q.multiply=rge,q.nth=yfe,q.noConflict=Rme,q.noop=qR,q.now=Pk,q.pad=sme,q.padEnd=ime,q.padStart=ome,q.parseInt=ame,q.random=Ype,q.reduce=wde,q.reduceRight=xde,q.repeat=lme,q.replace=cme,q.result=Bpe,q.round=sge,q.runInContext=Ie,q.sample=_de,q.size=Tde,q.snakeCase=ume,q.some=Ede,q.sortedIndex=Cfe,q.sortedIndexBy=kfe,q.sortedIndexOf=Tfe,q.sortedLastIndex=Efe,q.sortedLastIndexBy=Ife,q.sortedLastIndexOf=Afe,q.startCase=fme,q.startsWith=dme,q.subtract=ige,q.sum=oge,q.sumBy=age,q.template=pme,q.times=Gme,q.toFinite=tf,q.toInteger=Gn,q.toLength=IW,q.toLower=mme,q.toNumber=Jl,q.toSafeInteger=mpe,q.toString=Mr,q.toUpper=gme,q.trim=yme,q.trimEnd=bme,q.trimStart=vme,q.truncate=wme,q.unescape=xme,q.uniqueId=jme,q.upperCase=Sme,q.upperFirst=WR,q.each=pW,q.eachRight=mW,q.first=uW,jR(q,function(){var v={};return Ku(q,function(S,E){Pr.call(q.prototype,E)||(v[E]=S)}),v}(),{chain:!1}),q.VERSION=r,Ia(["bind","bindKey","curry","curryRight","partial","partialRight"],function(v){q[v].placeholder=q}),Ia(["drop","take"],function(v,S){rr.prototype[v]=function(E){E=E===t?1:Fi(Gn(E),0);var P=this.__filtered__&&!S?new rr(this):this.clone();return P.__filtered__?P.__takeCount__=Mo(E,P.__takeCount__):P.__views__.push({size:Mo(E,oe),type:v+(P.__dir__<0?"Right":"")}),P},rr.prototype[v+"Right"]=function(E){return this.reverse()[v](E).reverse()}}),Ia(["filter","map","takeWhile"],function(v,S){var E=S+1,P=E==D||E==B;rr.prototype[v]=function(V){var K=this.clone();return K.__iteratees__.push({iteratee:hn(V,3),type:E}),K.__filtered__=K.__filtered__||P,K}}),Ia(["head","last"],function(v,S){var E="take"+(S?"Right":"");rr.prototype[v]=function(){return this[E](1).value()[0]}}),Ia(["initial","tail"],function(v,S){var E="drop"+(S?"":"Right");rr.prototype[v]=function(){return this.__filtered__?new rr(this):this[E](1)}}),rr.prototype.compact=function(){return this.filter(Ra)},rr.prototype.find=function(v){return this.filter(v).head()},rr.prototype.findLast=function(v){return this.reverse().find(v)},rr.prototype.invokeMap=Yn(function(v,S){return typeof v=="function"?new rr(this):this.map(function(E){return Nx(E,v,S)})}),rr.prototype.reject=function(v){return this.filter(Ok(hn(v)))},rr.prototype.slice=function(v,S){v=Gn(v);var E=this;return E.__filtered__&&(v>0||S<0)?new rr(E):(v<0?E=E.takeRight(-v):v&&(E=E.drop(v)),S!==t&&(S=Gn(S),E=S<0?E.dropRight(-S):E.take(S-v)),E)},rr.prototype.takeRightWhile=function(v){return this.reverse().takeWhile(v).reverse()},rr.prototype.toArray=function(){return this.take(oe)},Ku(rr.prototype,function(v,S){var E=/^(?:filter|find|map|reject)|While$/.test(S),P=/^(?:head|last)$/.test(S),V=q[P?"take"+(S=="last"?"Right":""):S],K=P||/^find/.test(S);V&&(q.prototype[S]=function(){var ae=this.__wrapped__,we=P?[1]:arguments,Me=ae instanceof rr,Je=we[0],et=Me||On(ae),ct=function(tr){var ur=V.apply(q,ju([tr],we));return P&&Ot?ur[0]:ur};et&&E&&typeof Je=="function"&&Je.length!=1&&(Me=et=!1);var Ot=this.__chain__,tn=!!this.__actions__.length,pn=K&&!Ot,Xn=Me&&!tn;if(!K&&et){ae=Xn?ae:new rr(this);var mn=v.apply(ae,we);return mn.__actions__.push({func:$k,args:[ct],thisArg:t}),new Xl(mn,Ot)}return pn&&Xn?v.apply(this,we):(mn=this.thru(ct),pn?P?mn.value()[0]:mn.value():mn)})}),Ia(["pop","push","shift","sort","splice","unshift"],function(v){var S=sk[v],E=/^(?:push|sort|unshift)$/.test(v)?"tap":"thru",P=/^(?:pop|shift)$/.test(v);q.prototype[v]=function(){var V=arguments;if(P&&!this.__chain__){var K=this.value();return S.apply(On(K)?K:[],V)}return this[E](function(ae){return S.apply(On(ae)?ae:[],V)})}}),Ku(rr.prototype,function(v,S){var E=q[S];if(E){var P=E.name+"";Pr.call(b0,P)||(b0[P]=[]),b0[P].push({name:S,func:E})}}),b0[kk(t,y).name]=[{name:"wrapper",func:t}],rr.prototype.clone=xue,rr.prototype.reverse=Sue,rr.prototype.value=_ue,q.prototype.at=Jfe,q.prototype.chain=Qfe,q.prototype.commit=ede,q.prototype.next=tde,q.prototype.plant=rde,q.prototype.reverse=sde,q.prototype.toJSON=q.prototype.valueOf=q.prototype.value=ide,q.prototype.first=q.prototype.head,Cx&&(q.prototype[Cx]=nde),q},m0=eue();qh?((qh.exports=m0)._=m0,l0._=m0):di._=m0}).call(mt)})(GI,GI.exports);var vYe=GI.exports;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var xO=function(n,e){return xO=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])},xO(n,e)};function ko(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");xO(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var WB=function(n){var e="[object "+n+"]";return function(t){return wYe(t)===e}},wYe=function(n){return Object.prototype.toString.call(n)},ev=function(n){return n instanceof Date?n.getTime():Hw(n)?n.map(ev):n&&typeof n.toJSON=="function"?n.toJSON():n},Hw=WB("Array"),xYe=WB("Object"),SYe=WB("Function"),_Ye=function(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")&&!n.toJSON},SO=function(n,e){if(n==null&&n==e||n===e)return!0;if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(Hw(n)){if(n.length!==e.length)return!1;for(var t=0,r=n.length;t<r;t++)if(!SO(n[t],e[t]))return!1;return!0}else if(xYe(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var s in n)if(!SO(n[s],e[s]))return!1;return!0}return!1},_O=function(n,e,t,r,s,i){var o=e[r];if(Hw(n)&&isNaN(Number(o))){for(var a=0,l=n.length;a<l;a++)if(!_O(n[a],e,t,r,a,n))return!1}return r===e.length||n==null?t(n,s,i,r===0):_O(n[o],e,t,r+1,o,n)},Bu=function(){function n(e,t,r,s){this.params=e,this.owneryQuery=t,this.options=r,this.name=s,this.init()}return n.prototype.init=function(){},n.prototype.reset=function(){this.done=!1,this.keep=!1},n}(),GB=function(n){ko(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s)||this;return o.children=i,o}return e.prototype.reset=function(){this.keep=!1,this.done=!1;for(var t=0,r=this.children.length;t<r;t++)this.children[t].reset()},e.prototype.childrenNext=function(t,r,s,i){for(var o=!0,a=!0,l=0,c=this.children.length;l<c;l++){var u=this.children[l];if(u.done||u.next(t,r,s,i),u.keep||(a=!1),u.done){if(!u.keep)break}else o=!1}this.done=o,this.keep=a},e}(Bu),ate=function(n){ko(e,n);function e(t,r,s,i,o){var a=n.call(this,t,r,s,i)||this;return a.name=o,a}return e}(GB),CYe=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(GB),CO=function(n){ko(e,n);function e(t,r,s,i,o){var a=n.call(this,r,s,i,o)||this;return a.keyPath=t,a.propop=!0,a._nextNestedValue=function(l,c,u,h){return a.childrenNext(l,c,u,h),!a.done},a}return e.prototype.next=function(t,r,s){_O(t,this.keyPath,this._nextNestedValue,0,r,s)},e}(GB),HB=function(n,e){if(n instanceof Function)return n;if(n instanceof RegExp)return function(r){var s=typeof r=="string"&&n.test(r);return n.lastIndex=0,s};var t=ev(n);return function(r){return e(t,ev(r))}},$p=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=HB(this.params,this.options.compare)},e.prototype.next=function(t,r,s){(!Array.isArray(s)||s.hasOwnProperty(r))&&this._test(t,r,s)&&(this.done=!0,this.keep=!0)},e}(Bu),kYe=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(){this.done=!0,this.keep=!1},e}(Bu),TYe=function(n){return function(e,t,r,s){return e==null?new kYe(e,t,r,s):n(e,t,r,s)}},e$=function(n){return TYe(function(e,t,r,s){var i=typeof ev(e),o=n(e);return new $p(function(a){return typeof ev(a)===i&&o(a)},t,r,s)})},EYe=function(n,e,t,r){var s=r.operations[n];return s||lte(n),s(e,t,r,n)},lte=function(n){throw new Error("Unsupported operation: "+n)},cte=function(n,e){for(var t in n)if(e.operations.hasOwnProperty(t)||t.charAt(0)==="$")return!0;return!1},IYe=function(n,e,t,r,s){if(cte(e,s)){var i=ute(e,t,s),o=i[0],a=i[1];if(a.length)throw new Error("Property queries must contain only operations, or exact objects.");return new CO(n,e,r,s,o)}return new CO(n,e,r,s,[new $p(e,r,s)])},jw=function(n,e,t){e===void 0&&(e=null);var r=t===void 0?{}:t,s=r.compare,i=r.operations,o={compare:s||SO,operations:Object.assign({},i||{})},a=ute(n,null,o),l=a[0],c=a[1],u=[];return l.length&&u.push(new CO([],n,e,o,l)),u.push.apply(u,c),u.length===1?u[0]:new CYe(n,e,o,u)},ute=function(n,e,t){var r=[],s=[];if(!_Ye(n))return r.push(new $p(n,n,t)),[r,s];for(var i in n)if(t.operations.hasOwnProperty(i)){var o=EYe(i,n[i],n,t);if(o&&!o.propop&&e&&!t.operations[e])throw new Error("Malformed query. "+i+" cannot be matched against property.");o!=null&&r.push(o)}else i.charAt(0)==="$"?lte(i):s.push(IYe(i.split("."),n[i],i,n,t));return[r,s]},AYe=function(n){return function(e,t,r){return n.reset(),n.next(e,t,r),n.keep}},MYe=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=HB(this.params,this.options.compare)},e.prototype.reset=function(){n.prototype.reset.call(this),this.keep=!0},e.prototype.next=function(t){this._test(t)&&(this.done=!0,this.keep=!1)},e}(Bu),NYe=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){if(!this.params||typeof this.params!="object")throw new Error("Malformed query. $elemMatch must by an object.");this._queryOperation=jw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t){if(Hw(t)){for(var r=0,s=t.length;r<s;r++){this._queryOperation.reset();var i=t[r];this._queryOperation.next(i,r,t,!1),this.keep=this.keep||this._queryOperation.keep}this.done=!0}else this.done=!1,this.keep=!1},e}(Bu),$Ye=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._queryOperation=jw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t,r,s,i){this._queryOperation.next(t,r,s,i),this.done=this._queryOperation.done,this.keep=!this._queryOperation.keep},e}(Bu),hte=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){},e.prototype.next=function(t){Hw(t)&&t.length===this.params&&(this.done=!0,this.keep=!0)},e}(Bu),fte=function(n){if(n.length===0)throw new Error("$and/$or/$nor must be a nonempty array")},dte=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.init=function(){var t=this;fte(this.params),this._ops=this.params.map(function(r){return jw(r,null,t.options)})},e.prototype.reset=function(){this.done=!1,this.keep=!1;for(var t=0,r=this._ops.length;t<r;t++)this._ops[t].reset()},e.prototype.next=function(t,r,s){for(var i=!1,o=!1,a=0,l=this._ops.length;a<l;a++){var c=this._ops[a];if(c.next(t,r,s),c.keep){i=!0,o=c.keep;break}}this.keep=o,this.done=i},e}(Bu),RYe=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.next=function(t,r,s){n.prototype.next.call(this,t,r,s),this.keep=!this.keep},e}(dte),pte=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){var t=this;this._testers=this.params.map(function(r){if(cte(r,t.options))throw new Error("cannot nest $ under "+t.name.toLowerCase());return HB(r,t.options.compare)})},e.prototype.next=function(t,r,s){for(var i=!1,o=!1,a=0,l=this._testers.length;a<l;a++){var c=this._testers[a];if(c(t)){i=!0,o=!0;break}}this.keep=o,this.done=i},e}(Bu),PYe=function(n){ko(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,i)||this;return o.propop=!0,o._in=new pte(t,r,s,i),o}return e.prototype.next=function(t,r,s,i){this._in.next(t,r,s),Hw(s)&&!i?this._in.keep?(this.keep=!1,this.done=!0):r==s.length-1&&(this.keep=!0,this.done=!0):(this.keep=!this._in.keep,this.done=!0)},e.prototype.reset=function(){n.prototype.reset.call(this),this._in.reset()},e}(Bu),DYe=function(n){ko(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,s){s.hasOwnProperty(r)===this.params&&(this.done=!0,this.keep=!0)},e}(Bu),OYe=function(n){ko(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,t.map(function(a){return jw(a,r,s)}),i)||this;return o.propop=!1,fte(t),o}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(ate),FYe=function(n){ko(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,t.map(function(a){return jw(a,r,s)}),i)||this;return o.propop=!0,o}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(ate),LYe=function(n,e,t){return new $p(n,e,t)},zYe=function(n,e,t,r){return new MYe(n,e,t,r)},BYe=function(n,e,t,r){return new dte(n,e,t,r)},VYe=function(n,e,t,r){return new RYe(n,e,t,r)},UYe=function(n,e,t,r){return new NYe(n,e,t,r)},WYe=function(n,e,t,r){return new PYe(n,e,t,r)},GYe=function(n,e,t,r){return new pte(n,e,t,r)},HYe=e$(function(n){return function(e){return e<n}}),jYe=e$(function(n){return function(e){return e<=n}}),qYe=e$(function(n){return function(e){return e>n}}),XYe=e$(function(n){return function(e){return e>=n}}),KYe=function(n,e,t){var r=n[0],s=n[1];return new $p(function(i){return ev(i)%r===s},e,t)},YYe=function(n,e,t,r){return new DYe(n,e,t,r)},ZYe=function(n,e,t){return new $p(new RegExp(n,e.$options),e,t)},JYe=function(n,e,t,r){return new $Ye(n,e,t,r)},zH={number:function(n){return typeof n=="number"},string:function(n){return typeof n=="string"},bool:function(n){return typeof n=="boolean"},array:function(n){return Array.isArray(n)},null:function(n){return n===null},timestamp:function(n){return n instanceof Date}},QYe=function(n,e,t){return new $p(function(r){if(typeof n=="string"){if(!zH[n])throw new Error("Type alias does not exist");return zH[n](r)}return r!=null?r instanceof n||r.constructor===n:!1},e,t)},eZe=function(n,e,t,r){return new OYe(n,e,t,r)},tZe=function(n,e,t,r){return new FYe(n,e,t,r)},nZe=function(n,e,t){return new hte(n,e,t,"$size")},rZe=function(){return null},sZe=function(n,e,t){var r;if(SYe(n))r=n;else if(!{}.CSP_ENABLED)r=new Function("obj","return "+n);else throw new Error('In CSP mode, sift does not support strings in "$where" condition');return new $p(function(s){return r.bind(s)(s)},e,t)},iZe=Object.freeze({__proto__:null,$Size:hte,$eq:LYe,$ne:zYe,$or:BYe,$nor:VYe,$elemMatch:UYe,$nin:WYe,$in:GYe,$lt:HYe,$lte:jYe,$gt:qYe,$gte:XYe,$mod:KYe,$exists:YYe,$regex:ZYe,$not:JYe,$type:QYe,$and:eZe,$all:tZe,$size:nZe,$options:rZe,$where:sZe}),oZe=function(n,e,t){var r=t===void 0?{}:t,s=r.compare,i=r.operations;return jw(n,e,{compare:s,operations:Object.assign({},iZe,i||{})})},aZe=function(n,e){e===void 0&&(e={});var t=oZe(n,null,e);return AYe(t)};const BH=aZe;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lZe=Ee();lZe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ic;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ic||(ic={}));var VH;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(VH||(VH={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jB={};function cZe(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};jB[n]=t}function mte(n){return jB[n]}function uZe(n){delete jB[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F(n,e,t,r,s){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(i.type==="tensor")return oo(e.inputNames[c],t,r,s);if(i.type==="tensors"){const f=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((p,m)=>{var g;return((g=f[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(p=>oo(p,t,r,s))}const u=oo(e.inputNames[c],t,r,s),h=u.dataSync();return i.type==="number"?h[0]:El(u.shape,h)}const o=e.attrParams[n];return o&&o.value}function oo(n,e,t,r){const[s,i]=Fa(n,t);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[HI(s,a)]);return o!==void 0?e[HI(s,o)][i]:void 0}function UH(n,e,t){return e[HI(n,t.currentContextId)]}function gf(n,e){const[t,r,s]=Fa(n,e);return[HI(t,e&&e.currentContextId),r,s]}function HI(n,e){return e?`${n}-${e}`:n}function Fa(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const r=n.split(":");let s;if(r.length===1)s=[n,0,void 0];else{const i=r[0],o=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[i,a,o]}return t&&e.parseNodeNameCache.set(n,s),s}function FE(n,e,t){let r=F("pad",n,e,t);if(r==="explicit"){r=F("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[i*2],s[i][1]=r[i*2+1];return s}return r}function yf(n){return n.kept?n:mh(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],fZe=Object.freeze(Object.defineProperty({__proto__:null,json:hZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dZe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],pZe=Object.freeze(Object.defineProperty({__proto__:null,json:dZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],gZe=Object.freeze(Object.defineProperty({__proto__:null,json:mZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],bZe=Object.freeze(Object.defineProperty({__proto__:null,json:yZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vZe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],wZe=Object.freeze(Object.defineProperty({__proto__:null,json:vZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xZe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],SZe=Object.freeze(Object.defineProperty({__proto__:null,json:xZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ze=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],CZe=Object.freeze(Object.defineProperty({__proto__:null,json:_Ze},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kZe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],TZe=Object.freeze(Object.defineProperty({__proto__:null,json:kZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EZe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],IZe=Object.freeze(Object.defineProperty({__proto__:null,json:EZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],MZe=Object.freeze(Object.defineProperty({__proto__:null,json:AZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],$Ze=Object.freeze(Object.defineProperty({__proto__:null,json:NZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],PZe=Object.freeze(Object.defineProperty({__proto__:null,json:RZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],OZe=Object.freeze(Object.defineProperty({__proto__:null,json:DZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FZe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],LZe=Object.freeze(Object.defineProperty({__proto__:null,json:FZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zZe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],BZe=Object.freeze(Object.defineProperty({__proto__:null,json:zZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VZe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],UZe=Object.freeze(Object.defineProperty({__proto__:null,json:VZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WZe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],GZe=Object.freeze(Object.defineProperty({__proto__:null,json:WZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],jZe=Object.freeze(Object.defineProperty({__proto__:null,json:HZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],XZe=Object.freeze(Object.defineProperty({__proto__:null,json:qZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WH{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[fZe,pZe,gZe,bZe,wZe,SZe,CZe,TZe,IZe,MZe,$Ze,PZe,OZe,LZe,BZe,UZe,GZe,jZe,XZe],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],i=[],o=[],a=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?i.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const f=Object.keys(a);f.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[x,,w]=gf(y),_=a[x];if(_.outputs!=null){const C=_.outputs.indexOf(w);if(C!==-1){const k=`${x}:${C}`;g.inputNames[b]=k}}g.inputs.push(_),_.children.push(g)})}),Object.keys(h).length===0?f.forEach(m=>{const g=a[m];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(m=>{const[g]=gf(m),y=a[g];y!=null&&(y.signatureKey=h[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=gf(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:i,placeholders:s,signature:t,functions:d};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=mte(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=kO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=kO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=$O(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=$O(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=EO(e.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=EO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=NO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=NO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=TO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=TO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=PO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=PO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=MO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=MO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=RO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=RO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=IO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=IO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=AO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=AO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=GH(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=GH(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let i={};t!=null&&(i=t.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&s.push(h[f.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=gf(h.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:qB(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),i[f]=d}),Object.keys(i).forEach(h=>{const f=i[h];f.inputNames.forEach((d,p)=>{const[m,,g]=gf(d),y=i[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const x=`${m}:${b}`;f.inputNames[p]=x}}f.inputs.push(y),y.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[f,d]=gf(c[h.name]),p=i[f];p!=null&&(p.defaultOutput=d,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function KZe(n){const e=Ee().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function gte(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):KZe(n);return e?t:t.toLowerCase()}function kO(n,e,t,r=!1){const s=n[e];return s!=null?gte(s.s,r):t}function TO(n,e,t){const r=n[e];return r?r.b:t}function EO(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function qB(n){switch(typeof n=="string"&&(n=ic[n]),n){case ic.DT_FLOAT:case ic.DT_HALF:return"float32";case ic.DT_INT32:case ic.DT_INT64:case ic.DT_INT8:case ic.DT_UINT8:return"int32";case ic.DT_BOOL:return"bool";case ic.DT_DOUBLE:return"float32";case ic.DT_STRING:return"string";default:return null}}function GH(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function IO(n,e,t){const r=n[e];return r&&r.type?qB(r.type):t}function AO(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>qB(s)):t}function yte(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function MO(n,e,t){const r=n[e];return r&&r.shape?yte(r.shape):t}function NO(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function $O(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(i=>gte(i,r)):t}function RO(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>yte(s)):t}function PO(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YZe{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(e){return oo(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return oo(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return EO(this.node.rawAttrs,e,t);if(r.s!=null)return kO(this.node.rawAttrs,e,t);if(r.b!=null)return TO(this.node.rawAttrs,e,t);if(r.shape!=null)return MO(this.node.rawAttrs,e,t);if(r.type!=null)return IO(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return NO(this.node.rawAttrs,e,t);if(r.list.s!=null)return $O(this.node.rawAttrs,e,t);if(r.list.shape!=null)return RO(this.node.rawAttrs,e,t);if(r.list.b!=null)return PO(this.node.rawAttrs,e,t);if(r.list.type!=null)return AO(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ho=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:EL,abs:bi,acos:CX,acosh:kX,add:qe,addN:TX,all:FL,any:xI,argMax:sg,argMin:EX,asin:IX,asinh:AX,atan:MX,atan2:NX,atanh:$X,avgPool:AM,avgPool3d:zL,basicLSTMCell:RX,batchNorm:H2,batchNorm2d:BL,batchNorm3d:VL,batchNorm4d:UL,batchToSpaceND:MM,bincount:WL,bitwiseAnd:PX,booleanMaskAsync:WK,broadcastArgs:DX,broadcastTo:Tb,buffer:wn,cast:xt,ceil:OX,clipByValue:va,clone:mh,complex:Pf,concat:cs,concat1d:GL,concat2d:HL,concat3d:jL,concat4d:qL,conv1d:XL,conv2d:tp,conv2dTranspose:YL,conv3d:ZL,conv3dTranspose:JL,cos:NM,cosh:QL,cosineWindow:KM,cumprod:SI,cumsum:ez,denseBincount:_I,depthToSpace:LX,depthwiseConv2d:j2,diag:zX,dilation2d:BX,div:Ft,divNoNan:VX,dot:UX,dropout:Az,einsum:Im,elu:q2,enclosingPowerOfTwo:Mz,ensureShape:WX,equal:vu,erf:GX,euclideanNorm:qX,exp:Xo,expandDims:ii,expm1:XX,eye:$M,fft:GM,fill:Ny,floor:X2,floorDiv:OL,fused:JK,gather:K2,gatherND:qK,greater:el,greaterEqual:Tp,ifft:xS,imag:Y2,image:Si,inTopKAsync:XK,irfft:Sz,isFinite:KX,isInf:YX,isNaN:ZX,leakyRelu:RM,less:wS,lessEqual:$y,linalg:Rz,linspace:JX,localResponseNormalization:QX,log:$l,log1p:PM,logSigmoid:tK,logSoftmax:nz,logSumExp:OM,logicalAnd:Sh,logicalNot:FM,logicalOr:rz,logicalXor:nK,losses:rY,lowerBound:rK,matMul:jn,max:Sc,maxPool:zM,maxPool3d:sz,maxPoolWithArgmax:sK,maximum:Wf,mean:Os,meshgrid:iK,min:vS,minimum:rp,mirrorPad:iz,mod:oK,moments:Z2,movingAverage:GK,mul:fe,multiRNNCell:aK,multinomial:lK,neg:us,norm:Cw,notEqual:Gb,oneHot:Hb,ones:da,onesLike:Rl,op:he,outerProduct:cK,pad:wu,pad1d:uK,pad2d:hK,pad3d:fK,pad4d:dK,pool:pK,pow:np,prelu:VM,print:DL,prod:mK,raggedGather:gK,raggedRange:yK,raggedTensorToTensor:bK,rand:vK,randomGamma:CK,randomNormal:UM,randomStandardNormal:kK,randomUniform:Ep,randomUniformInt:TK,range:og,real:jb,reciprocal:EK,relu:Ph,relu6:mz,reshape:ve,reverse:Ec,reverse1d:IK,reverse2d:AK,reverse3d:MK,reverse4d:NK,rfft:HM,round:gz,rsqrt:yz,scalar:en,scatterND:HK,searchSorted:LM,selu:bz,separableConv2d:vz,setdiff1dAsync:$K,sigmoid:Il,sign:RK,signal:nY,sin:wz,sinh:xz,slice:fn,slice1d:J2,slice2d:WM,slice3d:Q2,slice4d:qb,softmax:eC,softplus:kw,spaceToBatchND:BM,sparse:sY,sparseToDense:jK,spectral:tY,split:Wa,sqrt:wo,square:Or,squaredDifference:_z,squeeze:gr,stack:wa,step:Ew,stridedSlice:PK,string:iY,sub:Rt,sum:Yt,tan:DK,tanh:Wb,tensor:ki,tensor1d:Xs,tensor2d:Ga,tensor3d:Cz,tensor4d:OK,tensor5d:FK,tensor6d:LK,tensorScatterUpdate:zK,tile:gc,topk:BK,transpose:nr,truncatedNormal:qM,unique:VK,unsortedSegmentSum:Tz,unstack:Ic,upperBound:UK,variable:Ez,where:vo,whereAsync:Iz,zeros:ms,zerosLike:ar},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZZe=(n,e,t,r=ho)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(F("a",n,e,t),F("b",n,e,t))];case"AddN":return[r.addN(F("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(F("a",n,e,t),F("b",n,e,t))];case"Mul":return[r.mul(F("a",n,e,t),F("b",n,e,t))];case"RealDiv":case"Div":return[r.div(F("a",n,e,t),F("b",n,e,t))];case"DivNoNan":return[r.divNoNan(F("a",n,e,t),F("b",n,e,t))];case"FloorDiv":return[r.floorDiv(F("a",n,e,t),F("b",n,e,t))];case"Sub":return[r.sub(F("a",n,e,t),F("b",n,e,t))];case"Minimum":return[r.minimum(F("a",n,e,t),F("b",n,e,t))];case"Maximum":return[r.maximum(F("a",n,e,t),F("b",n,e,t))];case"Pow":return[r.pow(F("a",n,e,t),F("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZe=(n,e,t,r=ho)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(F("x",n,e,t))];case"Acos":return[r.acos(F("x",n,e,t))];case"Acosh":return[r.acosh(F("x",n,e,t))];case"Asin":return[r.asin(F("x",n,e,t))];case"Asinh":return[r.asinh(F("x",n,e,t))];case"Atan":return[r.atan(F("x",n,e,t))];case"Atan2":return[r.atan2(F("x",n,e,t),F("y",n,e,t))];case"Atanh":return[r.atanh(F("x",n,e,t))];case"Ceil":return[r.ceil(F("x",n,e,t))];case"Complex":return[r.complex(F("real",n,e,t),F("imag",n,e,t))];case"Cos":return[r.cos(F("x",n,e,t))];case"Cosh":return[r.cosh(F("x",n,e,t))];case"Elu":return[r.elu(F("x",n,e,t))];case"Erf":return[r.erf(F("x",n,e,t))];case"Exp":return[r.exp(F("x",n,e,t))];case"Expm1":return[r.expm1(F("x",n,e,t))];case"Floor":return[r.floor(F("x",n,e,t))];case"Log":return[r.log(F("x",n,e,t))];case"Log1p":return[r.log1p(F("x",n,e,t))];case"Imag":return[r.imag(F("x",n,e,t))];case"Neg":return[r.neg(F("x",n,e,t))];case"Reciprocal":return[r.reciprocal(F("x",n,e,t))];case"Real":return[r.real(F("x",n,e,t))];case"Relu":return[r.relu(F("x",n,e,t))];case"Round":return[r.round(F("x",n,e,t))];case"Selu":return[r.selu(F("x",n,e,t))];case"Sigmoid":return[r.sigmoid(F("x",n,e,t))];case"Sin":return[r.sin(F("x",n,e,t))];case"Sign":return[r.sign(F("x",n,e,t))];case"Sinh":return[r.sinh(F("x",n,e,t))];case"Softplus":return[r.softplus(F("x",n,e,t))];case"Sqrt":return[r.sqrt(F("x",n,e,t))];case"Square":return[r.square(F("x",n,e,t))];case"Tanh":return[r.tanh(F("x",n,e,t))];case"Tan":return[r.tan(F("x",n,e,t))];case"ClipByValue":return[r.clipByValue(F("x",n,e,t),F("clipValueMin",n,e,t),F("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(F("x",n,e,t))];case"Rsqrt":return[r.rsqrt(oo(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(F("x",n,e,t),F("alpha",n,e,t))];case"Prelu":return[r.prelu(F("x",n,e,t),F("alpha",n,e,t))];case"IsNan":return[r.isNaN(oo(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(oo(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(oo(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cc(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){U(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=e[r];U(s<0||i<0||s===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function HH(n){return!(typeof n=="number"||n.some(e=>e<0))}function Vx(n,e,t){let r=DO(n,t);const s=!HH(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(i=>{r=DO(i.shape,r)}),!HH(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function DO(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],i=e[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QZe{constructor(e,t,r,s,i,o,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=en(0),qs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),cc(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,qs(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return ki([],[0].concat(this.elementShape));const r=this.readMany(e);return cc(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),wa(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ki([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return cc(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),cs(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Ic(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=r===0?0:t.size/r,o=[];Se(()=>{t=ve(t,[1,r,i]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:s[l-1],0],h=[1,e[l],i];o[l]=ve(fn(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dg{get id(){return this.idTensor.id}constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);cc(t,i.shape,"TensorList shape mismatch: "),qs(i)}),this.idTensor=en(0),this.maxNumElements=s,qs(this.idTensor)}copy(){return new dg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);cc(e,this.elementShape,"TensorList shape mismatch: ");const s=Vx(this.elementShape,this.tensors,e);return Se(()=>{const i=this.tensors.map(o=>ve(o,s));return wa(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Vx(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,cc(s.shape,e,"TensorList shape mismatch: "),ve(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(cc(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");qs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new dg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);cc(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Vx(this.elementShape,this.tensors,t);return ve(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);cc(this.elementShape,t.shape,"TensorList shape mismatch: "),qs(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);cc(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Vx(this.elementShape,this.tensors,r);return e.length===0?ki([],[0].concat(s)):Se(()=>{const i=e.map(o=>ve(this.tensors[o],s));return wa(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);cc(this.elementShape,t,"TensorList shape mismatch: ");const r=Vx(this.elementShape,this.tensors,t);return this.size()===0?ki([],[0].concat(r)):Se(()=>{const s=this.tensors.map(i=>ve(i,r));return cs(s,0)})}}function eJe(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);cc(s,e,"TensorList shape mismatch: ");const i=Ic(n);return new dg(i,e,r)}function tJe(n,e,t,r){return new dg([],n,e,r)}function nJe(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new dg([],t,n.dtype,r),o=Ic(n,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function rJe(n,e,t){let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=DO(i,t),a=r===0?0:n.size/r,l=Se(()=>{const u=[];n=ve(n,[1,r,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:s[h-1],0],p=[1,e[h],a];u[h]=ve(fn(n,d,p),o)}return n.dispose(),u}),c=new dg([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJe=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=F("thenBranch",n,e,t),s=F("elseBranch",n,e,t),i=F("cond",n,e,t),o=F("args",n,e,t);return(await i.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=F("body",n,e,t),s=F("cond",n,e,t),i=F("args",n,e,t),o=await t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),a=i.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=i;for(;l[0];){const u=c;c=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(d=>d.id);u.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const f=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{const r=F("pred",n,e,t);return[yf(r)]}case"Switch":{const r=F("pred",n,e,t);let s=F("data",n,e,t);return s.kept||(s=yf(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>oo(s,e,t)!==void 0);if(r){const s=oo(r,e,t);return[yf(s)]}return}case"Enter":{const r=F("frameName",n,e,t),s=F("tensor",n,e,t);return t.enterFrame(r),[yf(s)]}case"Exit":{const r=F("tensor",n,e,t);return t.exitFrame(),[yf(r)]}case"NextIteration":{const r=F("tensor",n,e,t);return t.nextIteration(),[yf(r)]}case"TensorArrayV3":{const r=F("size",n,e,t),s=F("dtype",n,e,t),i=F("elementShape",n,e,t),o=F("dynamicSize",n,e,t),a=F("clearAfterRead",n,e,t),l=F("identicalElementShapes",n,e,t),c=F("name",n,e,t),u=new QZe(c,s,r,i,l,o,a);return t.addTensorArray(u),[u.idTensor,en(1)]}case"TensorArrayWriteV3":{const r=F("tensorArrayId",n,e,t),s=F("index",n,e,t),i=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(s,i),[o.idTensor]}case"TensorArrayReadV3":{const r=F("tensorArrayId",n,e,t),s=F("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=F("tensorArrayId",n,e,t),s=F("indices",n,e,t),i=F("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,i)]}case"TensorArrayScatterV3":{const r=F("tensorArrayId",n,e,t),s=F("indices",n,e,t),i=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(s,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),i=F("dtype",n,e,t);return[s.concat(i)]}case"TensorArraySplitV3":{const r=F("tensorArrayId",n,e,t),s=F("tensor",n,e,t),i=F("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(i,s),[o.idTensor]}case"TensorArraySizeV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[en(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=F("tensorListId",n,e,t),s=F("index",n,e,t),i=F("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(s,i),[o.idTensor]}case"TensorListGetItem":{const r=F("tensorListId",n,e,t),s=F("index",n,e,t),i=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=F("indices",n,e,t),s=F("tensor",n,e,t),i=F("elementShape",n,e,t),o=F("numElements",n,e,t),a=nJe(s,r,i,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=F("elementShape",n,e,t),s=F("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=F(i,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=tJe(r,s,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=F("tensorListId",n,e,t),s=F("indices",n,e,t),i=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,o,i)]}case"TensorListStack":{const r=F("tensorListId",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t),o=F("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,i,o)]}case"TensorListFromTensor":{const r=F("tensor",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t),o=eJe(r,s,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=F("tensorListId",n,e,t),s=t.getTensorList(r.id),i=F("dtype",n,e,t),o=F("elementShape",n,e,t);return[s.concat(i,o)]}case"TensorListPushBack":{const r=F("tensorListId",n,e,t),s=F("tensor",n,e,t),i=t.getTensorList(r.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const r=F("tensorListId",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,i)]}case"TensorListSplit":{const r=F("tensor",n,e,t),s=F("elementShape",n,e,t),i=F("lengths",n,e,t),o=rJe(r,i,s);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=F("tensorListId",n,e,t),s=t.getTensorList(r.id);return[en(s.size(),"int32")]}case"TensorListResize":{const r=F("tensorListId",n,e,t),s=F("size",n,e,t),o=t.getTensorList(r.id).resize(s);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jH(n,e,t){const[r,s]=F("fusedOps",n,e,t),i=r==="biasadd",o=!i,a=s==="prelu",l=r==="fusedbatchnorm",c=F("numArgs",n,e,t);if(i){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=F("strides",n,e,t),h=FE(n,e,t),f=F("dataFormat",n,e,t).toUpperCase(),d=F("dilations",n,e,t);let[p,m]=F("args",n,e,t);o&&(m=p,p=void 0);const g=F("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:f,dilations:d,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:g}}const iJe=(n,e,t,r=ho)=>{switch(n.op){case"Conv1D":{const s=F("stride",n,e,t),i=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilation",n,e,t);return[r.conv1d(F("x",n,e,t),F("filter",n,e,t),s,i,o,a)]}case"Conv2D":{const s=F("strides",n,e,t),i=FE(n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv2d(F("x",n,e,t),F("filter",n,e,t),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=jH(n,e,t);return[r.fused.conv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=jH(n,e,t);return[r.fused.depthwiseConv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=F("outputShape",n,e,t),i=F("strides",n,e,t),o=FE(n,e,t);return[r.conv2dTranspose(F("x",n,e,t),F("filter",n,e,t),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=F("strides",n,e,t),i=FE(n,e,t),o=F("dilations",n,e,t),a=F("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(F("input",n,e,t),F("filter",n,e,t),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv3d(F("x",n,e,t),F("filter",n,e,t),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t),a=F("includeBatchInIndex",n,e,t),{result:l,indexes:c}=r.maxPoolWithArgmax(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i,a);return[l,c]}case"AvgPool3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("dilations",n,e,t),a=s[1],l=s[2],c=o[1],u=o[2];return[r.dilation2d(F("x",n,e,t),F("filter",n,e,t),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oJe=(n,e,t,r=ho)=>{switch(n.op){case"Fill":{const s=F("shape",n,e,t),i=F("dtype",n,e,t),o=F("value",n,e,t);return[r.fill(s,o,i)]}case"LinSpace":{const s=F("start",n,e,t),i=F("stop",n,e,t),o=F("num",n,e,t);return[r.linspace(s,i,o)]}case"Multinomial":{const s=F("logits",n,e,t),i=F("numSamples",n,e,t),o=F("seed",n,e,t);return[r.multinomial(s,i,o)]}case"OneHot":{const s=F("indices",n,e,t),i=F("depth",n,e,t),o=F("onValue",n,e,t),a=F("offValue",n,e,t),l=F("dtype",n,e,t);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(F("shape",n,e,t),F("dtype",n,e,t))];case"OnesLike":return[r.onesLike(F("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(F("shape",n,e,t),F("dtype",n,e,t),F("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("seed",n,e,t))];case"Range":{const s=F("start",n,e,t),i=F("stop",n,e,t),o=F("step",n,e,t);return[r.range(s,i,o,F("dtype",n,e,t))]}case"TruncatedNormal":{const s=F("shape",n,e,t),i=F("mean",n,e,t),o=F("stdDev",n,e,t),a=F("seed",n,e,t);return[r.truncatedNormal(s,i,o,F("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(F("shape",n,e,t),F("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3(n,e,t){const r=F("boxes",n,e,t),s=F("scores",n,e,t),i=F("maxOutputSize",n,e,t),o=F("iouThreshold",n,e,t),a=F("scoreThreshold",n,e,t),l=F("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const aJe=async(n,e,t,r,s=ho)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=x3(n,e,t),h=await s.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=x3(n,e,t),u=F("padToMaxOutputSize",n,e,t),h=await s.image.nonMaxSuppressionPaddedAsync(i,o,a,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=x3(n,e,t);return[await s.image.nonMaxSuppressionAsync(i,o,a,l,c)]}case"Where":{const i=s.cast(F("condition",n,e,t),"bool"),o=[await s.whereAsync(i)];return i.dispose(),o}case"ListDiff":return s.setdiff1dAsync(F("x",n,e,t),F("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lJe=(n,e,t,r=ho)=>{switch(n.op){case"LowerBound":{const s=F("sortedSequence",n,e,t),i=F("values",n,e,t);return[r.lowerBound(s,i)]}case"TopKV2":{const s=F("x",n,e,t),i=F("k",n,e,t),o=F("sorted",n,e,t),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=F("sortedSequence",n,e,t),i=F("values",n,e,t);return[r.upperBound(s,i)]}case"Unique":{const s=F("x",n,e,t),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=F("x",n,e,t),i=F("axis",n,e,t),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJe=(n,e,t,r=ho)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=F("default",n,e,t);return[oo(n.name,e,t)||s];case"Placeholder":return[oo(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=F("x",n,e,t);return[yf(u)]}case"IdentityN":return F("x",n,e,t).map(u=>yf(u));case"Snapshot":const i=F("x",n,e,t);return[yf(i)];case"Shape":return[r.tensor1d(F("x",n,e,t).shape,"int32")];case"ShapeN":return F("x",n,e,t).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(F("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(F("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=F("x",n,e,t),a=F("data",n,e,t),l=F("message",n,e,t),c=F("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uJe{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=en(0),this.tensorMap=new Map,qs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return en(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Se(()=>{const s=Ic(t),i=r.length,o=s.length;U(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=r[a],c=s[a];qs(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return Se(()=>{const s=[];for(let i=0;i<r.length;i++){const o=r[i],a=this.findWithDefault(o,t);s.push(a)}return wa(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hJe=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(n.name);if(s!=null)return[s];{const i=F("keyDType",n,e,t),o=F("valueDType",n,e,t),a=new uJe(i,o);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=F("tableHandle",n,e,t,r),i=F("keys",n,e,t),o=F("values",n,e,t);return[await r.getHashTableById(s.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=F("tableHandle",n,e,t,r),i=F("keys",n,e,t),o=F("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=F("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fJe=(n,e,t,r=ho)=>{switch(n.op){case"ResizeBilinear":{const s=F("images",n,e,t),i=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=F("images",n,e,t),i=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=F("image",n,e,t),i=F("boxes",n,e,t),o=F("boxInd",n,e,t),a=F("cropSize",n,e,t),l=F("method",n,e,t),c=F("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const s=F("images",n,e,t),i=F("transforms",n,e,t),o=F("outputShape",n,e,t),a=F("fillValue",n,e,t),l=F("interpolation",n,e,t),c=F("fillMode",n,e,t);return[r.image.transform(s,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dJe=(n,e,t,r=ho)=>{switch(n.op){case"Equal":return[r.equal(F("a",n,e,t),F("b",n,e,t))];case"NotEqual":return[r.notEqual(F("a",n,e,t),F("b",n,e,t))];case"Greater":return[r.greater(F("a",n,e,t),F("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(F("a",n,e,t),F("b",n,e,t))];case"Less":return[r.less(F("a",n,e,t),F("b",n,e,t))];case"LessEqual":return[r.lessEqual(F("a",n,e,t),F("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(F("a",n,e,t),F("b",n,e,t))];case"LogicalNot":return[r.logicalNot(F("a",n,e,t))];case"LogicalOr":return[r.logicalOr(F("a",n,e,t),F("b",n,e,t))];case"Select":case"SelectV2":return[r.where(F("condition",n,e,t),F("a",n,e,t),F("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pJe=(n,e,t,r=ho)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(F("a",n,e,t),F("b",n,e,t),F("transposeA",n,e,t),F("transposeB",n,e,t))];case"Einsum":return[r.einsum(F("equation",n,e,t),...F("tensors",n,e,t))];case"Transpose":return[r.transpose(F("x",n,e,t),F("perm",n,e,t))];case"_FusedMatMul":const[s,i]=F("fusedOps",n,e,t),o=s==="biasadd",a=i==="prelu",l=F("numArgs",n,e,t),c=F("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=F("args",n,e,t);return[r.fused.matMul({a:F("a",n,e,t),b:F("b",n,e,t),transposeA:F("transposeA",n,e,t),transposeB:F("transposeB",n,e,t),bias:u,activation:i,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(F("a",n,e,t),F("numLower",n,e,t),F("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mJe=(n,e,t,r=ho)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(F("x",n,e,t),F("axis",n,e,t),F("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(F("x",n,e,t),F("radius",n,e,t),F("bias",n,e,t),F("alpha",n,e,t),F("beta",n,e,t))];case"Softmax":return[r.softmax(F("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gJe=(n,e,t,r=ho)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(F("paramsNestedSplits",n,e,t),F("paramsDenseValues",n,e,t),F("indices",n,e,t),F("outputRaggedRank",n,e,t));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(F("starts",n,e,t),F("limits",n,e,t),F("splits",n,e,t));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(F("shape",n,e,t),F("values",n,e,t),F("defaultValue",n,e,t),F("rowPartitionTensors",n,e,t),F("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yJe=(n,e,t,r=ho)=>{switch(n.op){case"Max":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.max(F("x",n,e,t),a,l)]}case"Mean":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.mean(F("x",n,e,t),a,l)]}case"Min":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.min(F("x",n,e,t),a,l)]}case"Sum":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.sum(F("x",n,e,t),a,l)]}case"All":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.all(F("x",n,e,t),a,l)]}case"Any":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.any(F("x",n,e,t),a,l)]}case"ArgMax":{const a=F("axis",n,e,t);return[r.argMax(F("x",n,e,t),a)]}case"ArgMin":{const a=F("axis",n,e,t);return[r.argMin(F("x",n,e,t),a)]}case"Prod":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.prod(F("x",n,e,t),a,l)]}case"Cumprod":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumprod(F("x",n,e,t),a,l,c)]}case"Cumsum":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumsum(F("x",n,e,t),a,l,c)]}case"Bincount":const s=F("x",n,e,t),i=F("weights",n,e,t),o=F("size",n,e,t);return[r.bincount(s,i,o)];case"DenseBincount":{const a=F("x",n,e,t),l=F("weights",n,e,t),c=F("size",n,e,t),u=F("binaryOutput",n,e,t);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bJe=(n,e,t,r=ho)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=F("n",n,e,t),i=F("axis",n,e,t);let o=F("tensors",n,e,t);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=F("x",n,e,t),i=F("indices",n,e,t);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=F("axis",n,e,t),i=F("batchDims",n,e,t),o=F("x",n,e,t),a=F("indices",n,e,t);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=F("dims",n,e,t),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=F("x",n,e,t);return[r.reverse(o,i)]}case"ReverseV2":{const s=F("axis",n,e,t),i=F("x",n,e,t);return[r.reverse(i,s)]}case"Slice":{const s=F("begin",n,e,t),i=F("size",n,e,t);return[r.slice(F("x",n,e,t),s,i)]}case"StridedSlice":{const s=F("begin",n,e,t),i=F("end",n,e,t),o=F("strides",n,e,t),a=F("beginMask",n,e,t),l=F("endMask",n,e,t),c=F("ellipsisMask",n,e,t),u=F("newAxisMask",n,e,t),h=F("shrinkAxisMask",n,e,t),f=F("x",n,e,t);return[r.stridedSlice(f,s,i,o,a,l,c,u,h)]}case"Pack":return Se(()=>{const s=F("axis",n,e,t),i=F("tensors",n,e,t),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(c=>{const u=Mn(c.shape,o);if(!u&&!Mn(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,s)]});case"Unpack":{const s=F("axis",n,e,t),i=F("tensor",n,e,t);return r.unstack(i,s)}case"Tile":{const s=F("reps",n,e,t);return[r.tile(F("x",n,e,t),s)]}case"Split":case"SplitV":{const s=F("axis",n,e,t),i=F("numOrSizeSplits",n,e,t),o=F("x",n,e,t);return r.split(o,i,s)}case"ScatterNd":{const s=F("indices",n,e,t),i=F("values",n,e,t),o=F("shape",n,e,t);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=F("x",n,e,t),i=F("indices",n,e,t);return[r.gatherND(s,i)]}case"SparseToDense":{const s=F("sparseIndices",n,e,t),i=F("outputShape",n,e,t),o=F("sparseValues",n,e,t),a=F("defaultValue",n,e,t);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const s=F("indices",n,e,t),i=F("values",n,e,t),o=F("tensor",n,e,t);return[r.tensorScatterUpdate(o,s,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vJe=(n,e,t,r=ho)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(F("indices",n,e,t),F("values",n,e,t),F("denseShape",n,e,t),F("defaultValue",n,e,t));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(F("inputIndices",n,e,t),F("inputShape",n,e,t),F("newShape",n,e,t));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wJe=(n,e,t,r=ho)=>{switch(n.op){case"FFT":return[r.fft(F("x",n,e,t))];case"IFFT":return[r.ifft(F("x",n,e,t))];case"RFFT":return[r.rfft(F("x",n,e,t))];case"IRFFT":return[r.irfft(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xJe=(n,e,t,r=ho)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(F("input",n,e,t),F("pattern",n,e,t),F("rewrite",n,e,t),F("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(F("data",n,e,t),F("dataSplits",n,e,t),F("separator",n,e,t),F("nGramWidths",n,e,t),F("leftPad",n,e,t),F("rightPad",n,e,t),F("padWidth",n,e,t),F("preserveShortSequences",n,e,t));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(F("input",n,e,t),F("delimiter",n,e,t),F("skipEmpty",n,e,t));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(F("input",n,e,t),F("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SJe=(n,e,t,r=ho)=>{switch(n.op){case"Cast":return[r.cast(F("x",n,e,t),F("dtype",n,e,t))];case"ExpandDims":{const s=F("axis",n,e,t);return[r.expandDims(F("x",n,e,t),s)]}case"Squeeze":{const s=F("axis",n,e,t);return[r.squeeze(F("x",n,e,t),s)]}case"Reshape":return[r.reshape(F("x",n,e,t),F("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(F("x",n,e,t),F("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(F("x",n,e,t),F("padding",n,e,t),F("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(F("x",n,e,t),F("padding",n,e,t),F("constantValue",n,e,t))];case"SpaceToBatchND":{const s=F("blockShape",n,e,t),i=F("paddings",n,e,t);return[r.spaceToBatchND(F("x",n,e,t),s,i)]}case"BatchToSpaceND":{const s=F("blockShape",n,e,t),i=F("crops",n,e,t);return[r.batchToSpaceND(F("x",n,e,t),s,i)]}case"DepthToSpace":{const s=F("blockSize",n,e,t),i=F("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(F("x",n,e,t),s,i)]}case"BroadcastTo":return[r.broadcastTo(F("x",n,e,t),F("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(F("s0",n,e,t),F("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qH(n,e,t,r,s=Se){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>ZZe(o,a,l));case"basic_math":return s(()=>JZe(o,a,l));case"control":return sJe(o,a,l);case"convolution":return s(()=>iJe(o,a,l));case"creation":return s(()=>oJe(o,a,l));case"dynamic":return aJe(o,a,l);case"evaluation":return s(()=>lJe(o,a,l));case"image":return s(()=>fJe(o,a,l));case"graph":return s(()=>cJe(o,a,l));case"logical":return s(()=>dJe(o,a,l));case"matrices":return s(()=>pJe(o,a,l));case"normalization":return s(()=>mJe(o,a,l));case"ragged":return s(()=>gJe(o,a,l));case"reduction":return s(()=>yJe(o,a,l));case"slice_join":return s(()=>bJe(o,a,l));case"sparse":return s(()=>vJe(o,a,l));case"spectral":return s(()=>wJe(o,a,l));case"string":return s(()=>xJe(o,a,l));case"transformation":return s(()=>SJe(o,a,l));case"hash_table":return hJe(o,a,l,r);case"custom":const c=mte(o.op);if(c&&c.customExecutor)return c.customExecutor(new YZe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Qd(i)?i.then(o=>[].concat(o)):[].concat(i)}class XH{constructor(e={},t={},r={},s={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KH(n,e,t,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(n).map(f=>Fa(f)[0]));r=r||[];const u=new Set(r.map(f=>Fa(f.name)[0])),h=[...e];for(;h.length>0;){const f=h.pop();if((Nm(f)||MJe(f)||NJe(f))&&o==null&&(o=f,a=o.children.map(d=>d.name).filter(d=>s.has(d))),s.add(f.name),t[f.name]==null&&!c.has(f.name)&&!u.has(f.name)){if(f.inputs.length===0){i.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),h.push(d))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}function _Je(n,e){const{usedNodes:t,inputs:r}=e,s=Object.keys(r).map(g=>Fa(g)[0]).map(g=>n.nodes[g]),i=n.initNodes||[],o=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...s,...n.weights,...i]).filter(o),c=a([...l,...Object.values(n.nodes)]).filter(o),u=new Map(c.map(g=>[g.name,g])),h={};for(const g of c){h[g.name]=h[g.name]||0;for(const y of g.children)o(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const f=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),d=[...f];for(;f.length>0;){const g=f.pop(),y=u.get(g);for(const b of y.children.filter(o))--h[b.name]===0&&(d.push(b.name),f.push(b.name))}const p=d.map(g=>u.get(g)),m=CJe(p,l);return kJe(m,l),m}function CJe(n,e){const t=new Map(n.map(o=>[o.name,o])),r=e.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return n.filter(o=>s.has(o.name))}class rT extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function kJe(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new rT(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new rT(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!t.has(l.name))throw new rT(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new rT(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function TJe(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>Nm(a)?t:l),s=a=>{const l=r[e.get(a.name)];return l??-1},i=n.map((a,l)=>a.children.map(s).reduce((c,u)=>Math.max(c,u),r[l])),o=new Map;for(let a=0;a<n.length;++a){const l=i[a];if(l===t)continue;const c=n[a],u=n[l];o.has(u.name)||o.set(u.name,[]),o.get(u.name).push(c)}return o}const EJe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),IJe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),AJe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Nm(n){return EJe.has(n.op)}function MJe(n){return IJe.has(n.op)}function NJe(n){return AJe.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jI{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new jI(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(i=>i.name).sort(),s=t.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,t){const r=KH(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const c=t.map(h=>h.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}const a=_Je(this.graph,r),l=TJe(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return qs(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(f=>this.graph.nodes[Fa(f)[0]]),i=t.map(f=>Fa(f)[0]),o=new Set(i);let a=i.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const u={},h={};return Se(()=>{const f=new XH(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,x]=Fa(y,f),w=[];w[x]=e[y],d[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const p=this.getFrozenTensorIds(d),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(const y of m){if(d[y.name])continue;const b=qH(y,d,f,this._resourceManager);if(Qd(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,p,o,g.get(y.name))}return this.parent==null&&f.dispose(p),t.map(y=>oo(y,d,f))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,i,o,a){if(!(Nm(t)||o.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(Nm(l))continue;const c=UH(l.name,r,s);if(c!=null)for(const u of c){if(!u||u.kept||i.has(u.id))continue;const h=a[u.id];h===1?(u.dispose(),delete a[u.id]):h!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,s,i,o){function a(l){return Nm(l)||i.has(l.name)}if(!(Nm(e)||o==null))for(const l of o){if(a(l))continue;const c=UH(l.name,t,r);for(const u of c)!u||u.kept||s.has(u.id)||u.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,s={},i={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new XH(this.weightMap,s,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,r),l=t.map(f=>oo(f,a,o)),c=l.map(f=>f.id),u=Object.keys(e).map(f=>e[f].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(d=>{d&&!d.isDisposed&&!h.has(d.id)&&d.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,r){const s=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const i=Object.keys(e),o=i.map(w=>this.graph.nodes[Fa(w)[0]]),a=r.map(w=>Fa(w)[0]),l=new Set(a);let c=a.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:h,dynamicNode:f,syncInputs:d}=KH(e,c,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[_,C]=Fa(w),k=[];k[C]=e[w],m[_]=k});const g={},y=this.getFrozenTensorIds(m),b={};for(;p.length>0;){const w=this.processStack(o,p,t,m,b,y,l,g,u);await Promise.all(w)}f==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=c.filter(w=>!Nm(w)&&!oo(w.name,m,t)).map(w=>w.name);if(x.length>0){let w="";throw f!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${w}`)}return m}processStack(e,t,r,s,i,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&F("isConstant",h.node,s,r)&&([f]=gf(h.node.name,r)),s[h.node.name]==null){const d=qH(h.node,s,r,this._resourceManager);f||([f]=gf(h.node.name,r));const p=r.currentContext;Qd(d)?u.push(d.then(m=>(s[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(f,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,c),m))):(s[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,c))}else this.processChildNodes(h.node,t,r,s,i,c)}return u}processChildNodes(e,t,r,s,i,o){e.children.forEach(a=>{const[l]=gf(a.name,r);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!oo(c,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!oo(c,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=Fa(t),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,c)=>o[c]===-1||o[c]===l);U(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&U(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const s={};for(const i in e){const o=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[i];o!=null?s[o.name]=e[i]:s[i]=e[i]}return s}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=Fa(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,s;const i=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=Fa(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class $Je{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RJe="?tfjs-format=file",PJe="model.json";class XB{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=Vz){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new $Je}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Qd(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new jI(WH.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=WH.Instance.transformGraph(e.modelInitializer);this.initializer=new jI(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof qn?[e]:e,r={};return t.forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof qn)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return u!=null?i[o]=this.resourceIdToCapturedInput[u]:i[o]=e[s++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++){const i=r[s],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[s]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Pl(n,e={},t=Vz){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=OJe(n));const r=new XB(n,e,t);return await r.load(),r}function DJe(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[r,s]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const i=$L(r.weightsManifest),o=ML(r,i,s);e=CI(o)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=CI(n);else throw new Error("Unknown model format");const t=new XB(e);return t.load(),t}function OJe(n){return n.endsWith("/")||(n=n+"/"),`${n}${PJe}${RJe}`}/** @license See the LICENSE file. */const FJe="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LJe=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:XB,deregisterOp:uZe,loadGraphModel:Pl,loadGraphModelSync:DJe,registerOp:cZe,version_converter:FJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oh extends Error{constructor(e){super(e),Object.setPrototypeOf(this,oh.prototype)}}class bc extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bc.prototype)}}class xe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xe.prototype)}}class Fn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Fn.prototype)}}class KB extends Error{constructor(e){super(e),Object.setPrototypeOf(this,KB.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bte{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pg(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ah(n,e){if(!n)throw new KB(e)}function YH(n,e){let t=0;for(const r of n)r===e&&t++;return t}function ha(n){return n.length===1?n[0]:n}function Gr(n){return Array.isArray(n)?n:[n]}function bf(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function $m(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let ec={};function YB(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function OO(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>OO(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:OO(r))}}}function wC(n,e={},t={},r="object",s=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in ec)o=ec[i];else if(o=e[i],o==null)throw new xe(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new xe(`${r}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in t?[a,l]=t[o]:o in ec?[a,l]=ec.className:o in e&&([a,l]=e[o]),a==null)throw new xe(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const d of Object.keys(ec))c[d]=ec[d];for(const d of Object.keys(t))c[d]=t[d];const u=i.config;u.customObjects=c;const h=Object.assign({},ec);for(const d of Object.keys(t))ec[d]=t[d];OO(i.config);const f=l(a,i.config,t,s);return ec=Object.assign({},h),f}else{const c=Object.assign({},ec);for(const h of Object.keys(t))ec[h]=t[h];const u=new a(i.config);return ec=Object.assign({},c),u}}}function zJe(n,e){return n<e?-1:n>e?1:0}function sT(n,e){return-1*zJe(n,e)}function Ud(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function BJe(n){if(n==null)throw new xe(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function jy(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new xe(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function ZB(n,e,t=0,r=1/0){return ah(t>=0),ah(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(s=>typeof s===e)}function Ui(n,e){Array.isArray(n)?(U(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Ui(t,`element ${r+1} of ${e}`))):U(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${vte(n)}.`)}function vte(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>vte(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function VJe(n,e,t){let r=t!=null?t():ro(),s;return(...o)=>{const a=t!=null?t():ro();return a-r<e||(r=a,s=n(...o)),s}}function wte(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let UJe=0;function xte(){return UJe++}const iT={};function t$(n=""){return n in iT||(iT[n]=0),iT[n]+=1,n+iT[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const WJe=["channelsFirst","channelsLast"],GJe=["nearest","bilinear"],HJe=["valid","same","causal"],jJe=["max","avg"],qJe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $0=new Map;function ei(n){jy(WJe,"DataFormat",n)}function XJe(n){jy(GJe,"InterpolationFormat",n)}function Vl(n){jy(HJe,"PaddingMode",n)}function Ste(n){jy(jJe,"PoolMode",n)}const X1=[],ZH="/";function Gm(n,e){X1.push(n);try{const t=e();return X1.pop(),t}catch(t){throw X1.pop(),t}}function KJe(){return X1.length===0?"":X1.join(ZH)+ZH}function _te(n){if(!kte(n))throw new Error("Not a valid tensor name: '"+n+"'");return KJe()+n}function Cte(n){if(!kte(n))throw new Error("Not a valid tensor name: '"+n+"'");$0.has(n)||$0.set(n,0);const e=$0.get(n);if($0.set(n,$0.get(n)+1),e>0){const t=`${n}_${e}`;return $0.set(t,1),t}else return n}const YJe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function kte(n){return!!n.match(YJe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ZJe(n){return n===parseInt(n.toString(),10)}function Wd(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let s=e;s<t;++s)r*=n[s];return r}function tv(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function op(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function Cu(n,e){if(e<n)throw new xe(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let S3;function _i(){return S3==null&&(S3=rg().epsilon()),S3}function ku(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gh(n,e){return xt(n,e)}function xC(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ve(n,t)}function JJe(n,e){return Se(()=>{if(n.shape.length!==2)throw new xe(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=xC(n,1);return FO(t,[1,e,1])})}function QJe(n){const e=[Wd(n.shape)];return ve(n,e)}function eQe(n){if(n.rank<=1)throw new xe(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Wd(n.shape,1)];return ve(n,e)}function Hm(n,e,t){return Se(()=>{switch(n.rank){case 1:return J2(n,e,t);case 2:return WM(n,[e,0],[t,n.shape[1]]);case 3:return Q2(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return qb(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return fn(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return fn(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new xe(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function _3(n,e,t){return Se(()=>{switch(n.rank){case 1:return J2(n,e,t);case 2:return WM(n,[0,e],[n.shape[0],t]);case 3:return Q2(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return qb(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new xe(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function oT(n,e,t,r){return Se(()=>{switch(n.rank){case 1:return J2(n,e,t);case 2:switch(r){case 1:return Hm(n,e,t);case 2:return _3(n,e,t);default:throw new xe(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Hm(n,e,t);case 2:return Q2(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return _3(n,e,t);default:throw new xe(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Hm(n,e,t);case 2:return qb(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return qb(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return _3(n,e,t);default:throw new xe(`The axis is not within the rank of the tensor ${r}`)}default:throw new xe(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function JB(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),cs(n,e)}function JH(n,e){switch(n.rank){case 1:return GL([n,e]);case 2:return HL([n,e],0);case 3:return jL([n,e],0);case 4:return qL([n,e],0);default:throw new xe(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function FO(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new xe(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return gc(n,e)}function n$(n,e=0,t=1,r,s){return UM(n,e,t,r,s)}function yh(n,e,t,r){if(n.rank<2||e.rank<2)throw new Fn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const s=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(s!==i)throw new Fn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return wD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?LO(n.rank,r,ku()):null,activation:t});{const s=n.shape.slice(),i=s.pop();n=ve(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(p,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=ve(nr(e,u),[l,-1]);const h=[...s,...c];return ve(wD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?LO(n.rank,r,ku()):null,activation:t}),h)}}function Tte(n,e,t){return Se(()=>(Array.isArray(e)?e=Xs(e,"int32"):e=xt(e,"int32"),K2(n,e,t)))}function SC(n){return fe(n,n)}function LO(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new xe(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1,1]):ve(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1]):ve(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1]):ve(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,r[0]]):ve(e,[1].concat(r))}else if(n<3)return e;throw new xe(`Unsupported input rank by biasAdd: ${e.rank}`)}function Vu(n,e,t){return Se(()=>(t==null&&(t=ku()),ei(t),qe(n,LO(n.rank,e,t))))}function tQe(n,e=1){if(e!==1)throw new Fn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return q2(n)}function nQe(n){return Se(()=>Ft(n,qe(bi(n),1)))}function Ete(n,e,t,r){return Se(()=>Az(n,e,t,r))}function rQe(n){return Se(()=>{const e=qe(.5,fe(.2,n));return va(e,0,1)})}function _C(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const sQe=["fanIn","fanOut","fanAvg"],iQe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oQe(n){jy(sQe,"FanMode",n)}function aQe(n){jy(iQe,"Distribution",n)}class Oc extends Py{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Ite extends Oc{apply(e,t){return ms(e,t)}}Ite.className="Zeros";at(Ite);class QB extends Oc{apply(e,t){return da(e,t)}}QB.className="Ones";at(QB);class Ate extends Oc{constructor(e){if(super(),typeof e!="object")throw new xe(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new xe(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Se(()=>fe(en(this.value),da(e,t)))}getConfig(){return{value:this.value}}}Ate.className="Constant";at(Ate);class Mte extends Oc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ep(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Mte.className="RandomUniform";at(Mte);class Nte extends Oc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`randomNormal does not support dType ${t}.`);return n$(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Nte.className="RandomNormal";at(Nte);class $te extends Oc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`truncatedNormal does not support dType ${t}.`);return qM(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}$te.className="TruncatedNormal";at($te);let Rte=class extends Oc{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return Se(()=>{if(e.length!==2||e[0]!==e[1])throw new xe("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,$M(e[0]))})}getConfig(){return{gain:this.gain}}};Rte.className="Identity";at(Rte);function lQe(n,e="channelsLast"){let t,r;if(ei(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const s=Wd(n,2);t=n[1]*s,r=n[0]*s}else if(e==="channelsLast"){const s=Wd(n,0,n.length-2);t=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=Wd(n);t=Math.sqrt(s),r=Math.sqrt(s)}return[t,r]}class qa extends Oc{constructor(e){if(super(),e.scale<0)throw new xe(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,oQe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,aQe(this.distribution),this.seed=e.seed}apply(e,t){const r=lQe(e),s=r[0],i=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,s):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(s+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`${this.getClassName()} does not support dType ${t}.`);return qM(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Ep(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}qa.className="VarianceScaling";at(qa);class e4 extends qa{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return qa.className}}e4.className="GlorotUniform";at(e4);class t4 extends qa{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return qa.className}}t4.className="GlorotNormal";at(t4);class n4 extends qa{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return qa.className}}n4.className="HeNormal";at(n4);class r4 extends qa{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return qa.className}}r4.className="HeUniform";at(r4);class s4 extends qa{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return qa.className}}s4.className="LeCunNormal";at(s4);class i4 extends qa{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return qa.className}}i4.className="LeCunUniform";at(i4);class Pte extends Oc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Se(()=>{if(e.length<2)throw new Fn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const r=Te(e.slice(0,-1)),s=e[e.length-1],i=r*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(s,r),Math.min(s,r)],a=n$(o,0,1,t,this.seed),l=Rz.qr(a,!1);let c=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return c=fe(c,h.sign()),r<s&&(c=c.transpose()),fe(en(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Pte.className="Orthogonal";at(Pte);const QH={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function e6(n,e={}){return wC(n,Sl.getMap().classNameMap,e,"initializer")}function ks(n){return YB(n)}function ys(n){if(typeof n=="string"){const e=n in QH?QH[n]:n;if(e==="GlorotNormal")return new t4;if(e==="GlorotUniform")return new e4;if(e==="HeNormal")return new n4;if(e==="HeUniform")return new r4;if(e==="LeCunNormal")return new s4;if(e==="LeCunUniform")return new i4;{const t={};return t.className=e,t.config={},e6(t)}}else return n instanceof Oc?n:e6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zO(n){return Array.isArray(n)&&Array.isArray(n[0])}function qI(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function bn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new xe(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function vr(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new xe(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function XI(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,s)=>r*s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const t6="Variable";class cQe{constructor(e,t="float32",r=t6,s=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=xte(),r=r??t6,this.originalName=_te(r),this.name=Cte(this.originalName),this.trainable_=s,this.constraint=i,this.val=Ez(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),uQe(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function uQe(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function BO(n){return n.map(e=>e.read())}function o4(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ci{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class kh{constructor(e,t,r,s,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=xte(),o!=null&&(this.originalName=_te(o),this.name=Cte(this.originalName)),this.rank=t.length}}let hQe=0,r$=class{constructor(e,t){this.callArgs=t,this.id=hQe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},fQe=0;class Kn extends Py{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=fQe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=bf(r)+"_"+t$(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),r=[i].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new bc(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new xe(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return ha(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return ha(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new oh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new oh(`Layer ${this.name} is not connected, no input to return.`);return ha(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new oh(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new oh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ha(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Gr(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Gr(this.inputSpec);if(t.length!==r.length)throw new xe(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let s=0;s<t.length;s++){const i=t[s],o=r[s];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new xe(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new xe(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new xe(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new xe(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const c in o.axes){const u=Number(c),h=o.axes[c],f=u>=0?l[u]:l[l.length+u];if(h!=null&&[h,null].indexOf(f)===-1)throw new xe(`Input ${s} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=i.shape[l];if(c!=null&&u!=null&&c!==u)throw new xe(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Gr(e),s=mQe(e),i=gQe(e);if(s===i)throw new xe("Arguments to apply() must be all SymbolicTensors or all Tensors");return Gm(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Gr(e))o.push(a.shape);this.build(ha(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Gr(o),l=[];for(let c of a)r.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=ha(l),this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=dQe(e),a=this.computeOutputShape(o);let l;const c=pQe(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new kh(c,u,this,Gr(e),t,this.name,h)):l=new kh(c,a,this,Gr(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new oh(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new oh(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new bc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return XI(this.weights)}build(e){this.built=!0}getWeights(e=!1){return BO(e?this.trainableWeights:this.weights)}setWeights(e){Se(()=>{const t=this.weights;if(t.length!==e.length)throw new xe(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],s=BO(t);for(let i=0;i<s.length;++i){const o=s[i],a=t[i],l=e[i];if(!Mn(o.shape,l.shape))throw new xe(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}o4(r)})}addWeight(e,t,r,s,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new xe(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():ys("zeros"));const c=s.apply(t,r),u=new cQe(c,r,e,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Gr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;const s=this.computeMask(e,r);if(t instanceof Array&&s instanceof Array){if(t.length!==s.length)throw new Error(`${this.name} outputs ${t.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<t.length;i++)t[i].kerasMask=s[i]}else{if(s instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${s.length} masks`);if(t instanceof Array)throw new Error(`{this.name} outputs ${t.length} tensors but only one mask`);t.kerasMask=s}}addInboundNode(e,t,r,s,i,o,a=null){const l=Gr(e);t=Gr(t),r=Gr(r),s=Gr(s),i=qI(i),o=qI(o);const c=[],u=[],h=[];for(const f of l)c.push(f.sourceLayer),u.push(f.nodeIndex),h.push(f.tensorIndex);new r$({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function dQe(n){n=Gr(n);const e=[];for(const t of n)e.push(t.shape);return ha(e)}function pQe(n){return"float32"}function Dte(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const o=r.inputTensors[i],a=r.inboundLayers[i],l=r.nodeIndices[i],c=Dte(o,a,l);for(const u of c)s.indexOf(u)===-1&&s.push(u)}return s}}}function mQe(n){let e=!0;for(const t of Gr(n))if(!(t instanceof kh)){e=!1;break}return e}function gQe(n){let e=!0;for(const t of Gr(n))if(t instanceof kh){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CC extends Kn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:t$("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new xe("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new xe("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new xe("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const s=new kh(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new r$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new xe(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}CC.className="InputLayer";at(CC);function yQe(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new xe("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new CC({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bQe(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return xt(e,n.dtype)}catch{throw new xe(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class $d{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof $d)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=bQe(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new xe(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof kh){if(this.id2Value[e.id]==null)throw new xe(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new xe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof kh){if(this.id2Value[e.id]==null)throw new xe(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new xe(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&nn(this.id2Mask)}}const KI=new bte,YI=new bte;function vQe(n){KI!=null&&KI.setMaxEntries(n),YI!=null&&YI.setMaxEntries(n)}function C1(n,e,t,r){const s=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=e.names();for(const p of a)c.indexOf(p)!==-1?l.push(e.getValue(p)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+e.names().sort().join(",");let h=KI.get(u),f;if(h==null){const p=wQe(o,e);h=p.sorted,f=p.recipientCounts,KI.put(u,h),YI.put(u,f)}f={},s||Object.assign(f,YI.get(u));const d=new $d(e);for(let p=0;p<h.length;++p){if(r!=null){const M=wI().numTensors;M>r.maxNumTensors&&(r.maxNumTensors=M),M<r.minNumTensors&&(r.minNumTensors=M)}const m=h[p],g=m.sourceLayer;if(g instanceof CC)continue;const y=[],b=[],x=[];let w=!1;for(const M of m.inputs){const I=d.getValue(M),N=d.getMask(M);y.push(I),b.push(N),N!=null&&(w=!0),s||(f[M.name]--,f[M.name]===0&&!e.hasKey(M)&&a.indexOf(M.name)===-1&&!I.isDisposed&&M.sourceLayer.stateful!==!0&&x.push(I))}w&&(t=t||{},t.mask=b[0]);const _=Gr(g.apply(y,t));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const k=SQe(m),A=Array.isArray(k)?k:[k];for(let M=0;M<A.length;++M){d.hasKey(A[M])||d.add(A[M],_[M],Array.isArray(C)?C[0]:C);const I=a.indexOf(A[M].name);I!==-1&&(l[I]=_[M])}s||nn(x)}return d.disposeMasks(),i?l:l[0]}function wQe(n,e){U(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const s=n6(n[0],e);t=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=n6(i,e);for(const l of o)s.has(l.name)||(t.push(l),s.add(l.name));for(const l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:t,recipientCounts:xQe(r)}}function xQe(n){const e={};for(const t in n)e[t]=n[t].size;return e}function n6(n,e){const t=new Set,r=[],s={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),r.push(a),t.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)s[c.name]==null&&(s[c.name]=new Set),s[c.name].add(a.name),!t.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function SQe(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Qe=Ee();_Qe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,vQe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ote={kernelName:_v,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Ew(xt(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CQe={kernelName:Pg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Or(xt(t,"float32")),s=wo(Rt(en(1),r));return us(Ft(n,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kQe={kernelName:Dg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=wo(Rt(Or(xt(t,"float32")),1));return Ft(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TQe={kernelName:Sp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=ci(t.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=ci(r.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EQe={kernelName:Cv,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,s)=>{t[s]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IQe={kernelName:kv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ar(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AQe={kernelName:Tv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ar(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MQe={kernelName:Og,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,wo(Rt(en(1),Or(xt(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NQe={kernelName:Fg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=wo(qe(en(1),Or(xt(t,"float32"))));return Ft(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Qe={kernelName:Bg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=qe(Or(t),Or(r));let l=fe(n,Ft(r,a));const c=ci(t.shape,s);return c.length>0&&(l=Yt(l,c)),ve(l,t.shape)},b:()=>{const a=qe(Or(t),Or(r));let l=us(fe(n,Ft(t,a)));const c=ci(r.shape,s);return c.length>0&&(l=Yt(l,c)),ve(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RQe={kernelName:Lg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,qe(Or(xt(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PQe={kernelName:zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,Rt(en(1),Or(xt(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQe(n,e,t,r,s,i){const o=j(n,"dy","avgPool3dGrad"),a=j(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),U(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),U(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Jo("avgPool3dGrad",s,i);const h={dy:l,input:c},f={filterSize:t,strides:r,pad:s,dimRoundingMode:i},d=ce.runKernel(H_,h,f);return u?ve(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const OQe=he({avgPool3dGrad_:DQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FQe={kernelName:Iv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>OQe(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQe(n,e,t,r,s){const i=j(n,"dy","avgPoolGrad"),o=j(e,"input","avgPoolGrad");U(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),U(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:t,strides:r,pad:s},f=ce.runKernel(G_,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const zQe=he({avgPoolGrad_:LQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BQe={kernelName:Ev,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=t;return{x:()=>zQe(n,r,s,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VQe={kernelName:Av,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,s]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>jn(n,s,!1,!0),b:()=>jn(r,n,!0,!1)}:!i&&o?{a:()=>jn(n,s,!1,!1),b:()=>jn(n,r,!0,!1)}:i&&!o?{a:()=>jn(s,n,!1,!0),b:()=>jn(r,n,!1,!1)}:{a:()=>jn(s,n,!0,!0),b:()=>jn(n,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UQe={kernelName:Mv,gradFunc:(n,e,t)=>{const{blockShape:r,crops:s}=t;return{x:()=>BM(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WQe={kernelName:q7,gradFunc:(n,e,t)=>{const r=t,s=r.inputShape,i=r.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Yt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GQe={kernelName:Vg,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HQe={kernelName:Ug,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jQe={kernelName:Wg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=t;return{x:()=>vo(Sh(Tp(r,s),$y(r,i)),n,ar(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qQe={kernelName:Nv,inputsToSave:["x"],gradFunc:Ote.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XQe={kernelName:$v,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(l=>l.shape),{axis:s}=t,i=Tn(s,e[0].shape)[0],o=r.map(l=>l[i]);return Wa(n,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KQe={kernelName:Rv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=t;return U(ep(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>KL(r.shape,n,s,o,a,l),filter:()=>Nz(r,n,s.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YQe={kernelName:Pv,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>tp(n,s,i,o,a,1,l),filter:()=>Nz(n,r,s.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZQe(n,e,t,r,s){let i=n;n.rank===4&&(i=ve(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),U(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),U(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),U(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),U(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),U(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},l={strides:r,pad:s,filterShape:t};return ce.runKernel(Z_,a,l)}const JQe=he({conv3DBackpropFilter_:ZQe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QQe={kernelName:Dv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i}=t;U(ep(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>FX(o.shape,n,a,s,i),filter:()=>JQe(o,n,a.shape,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eet={kernelName:Gg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(us(wz(xt(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tet={kernelName:Hg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(xz(xt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const net={kernelName:Ov,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=t;return{x:()=>{const a=Lr([s],r.rank);let l=ez(n,s,i,!o);return a!=null&&(l=nr(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ret={kernelName:Fv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=t,a=r??[1,1];U(ep(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return U(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),U(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),U(Ni(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),Jo("depthwiseConv2d",i,o),{x:()=>ZK(l.shape,n,c,s,i,a,o),filter:()=>YK(l,n,c.shape,s,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const set={kernelName:Lv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>ce.runKernel(cS,i,t),filter:()=>ce.runKernel(uS,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet={kernelName:qg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>ce.runKernel(l2,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oet={kernelName:Xg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Xo(us(Or(t))),2/Math.sqrt(Math.PI));return{x:()=>fe(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aet={kernelName:Kg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cet={kernelName:Bv,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uet={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Xo(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const het={kernelName:Zg,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fet={kernelName:Jg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=Ft(n,xt(r,"float32")),l=ci(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{let a=fe(n,xt(t,"float32"));const l=ci(r.shape,s);l.length>0&&(a=ve(Yt(a,l),r.shape));const c=Or(r);return us(Ft(a,xt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const det={kernelName:Vv,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[s,i,o,a]=e,l=a??en(1),c=ci(i.shape,s.shape),u=[];if(i.rank===1){for(let w=0;w<s.shape.length-1;++w)u.push(s.shape[w]);u.push(1)}const h=Rt(s,i),f=fe(n,l),d=yz(qe(o,en(r))),p=fe(fe(fe(d,d),d),en(-.5));return{x:()=>i.rank===1?ve(fe(fe(n,gc(ve(d,[1,1,1,i.shape[0]]),u)),l),s.shape):ve(fe(fe(n,d),l),s.shape),mean:()=>{let w=fe(fe(d,en(-1)),f);return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)},variance:()=>{let w=fe(fe(p,h),f);return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)},scale:()=>{const w=fe(h,d);let _=fe(n,w);return i.rank===1&&(_=Yt(_,c)),ve(_,i.shape)},offset:()=>{let w=n;return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pet={kernelName:Uv,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,s]=e,{axis:i,batchDims:o}=t,a=Tn(i,r.shape)[0],l=(c,u,h)=>()=>{const f=c.shape,d=u.size,p=f.slice(0,a),m=p.length,g=f.slice(i,f.length).slice(1),y=g.length,b=r6(0,m),x=r6(m+1,m+1+y),w=s6([p,[d],g]),_=ve(h,w),C=ve(u,[d]),k=s6([[m],b,x]),A=nr(_,k);let M=Tz(A,C,c.shape[a]);const I=Rh(k);return M=nr(M,I),M};if(o===1){const c=r.shape[0],u=r.split(c,0);return{x:()=>wa(u.map((d,p)=>l(d,s.slice(p,1),n.slice(p,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,n),indices:()=>s}}};function r6(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function s6(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const met={kernelName:Qg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>ar(t),b:()=>ar(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const get={kernelName:ey,gradFunc:n=>({x:()=>xt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yet={kernelName:ty,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bet={kernelName:ny,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vet={kernelName:ry,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wet={kernelName:Gv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:s}=t,i=el(r,0);return{x:()=>vo(i,n,fe(n,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xet={kernelName:iy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,qe(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _et={kernelName:sy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,xt(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cet={kernelName:X7,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;return{logits:()=>{const o=Xo(r);return Rt(n,fe(Yt(n,s,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ket(n,e,t,r=5,s=1,i=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:r,bias:s,alpha:i,beta:o};return ce.runKernel(g2,a,l)}const Tet=he({localResponseNormalizationBackprop_:ket});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eet={kernelName:Yv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=t;return{x:()=>Tet(r,s,n,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte(n,e,t,r){return e.rank<t.rank&&(e=ve(e,Ls(e.shape,r))),n.rank<t.rank&&(n=ve(n,Ls(n.shape,r))),{x:()=>fe(n,xt(vu(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i6={kernelName:Zv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:s}=r,i=e[0],o=e[1],a=Tn(s,i.shape),l=Fte(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet={kernelName:oy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,xt(Tp(t,r),"float32")),b:()=>fe(n,xt(wS(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aet(n,e,t,r,s,i,o){const a=j(n,"dy","maxPool3dGrad"),l=j(e,"input","maxPool3dGrad"),c=j(t,"output","maxPool3dGrad");let u=a,h=l,f=c,d=!1;l.rank===4&&(d=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=ve(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),U(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),U(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),Jo("maxPool3dGrad",i,o);const p={dy:u,input:h,output:f},m={filterSize:r,strides:s,pad:i,dimRoundingMode:o},g=ce.runKernel(b2,p,m);return d?ve(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const Met=he({maxPool3dGrad_:Aet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Net={kernelName:Qv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>Met(n,r,s,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $et(n,e,t,r,s,i,o){const a=j(n,"dy","maxPoolGrad"),l=j(e,"input","maxPoolGrad"),c=j(t,"output","maxPoolGrad");U(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),U(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),U(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Jo("maxPoolGrad",i,o);const u={dy:a,input:l,output:c},h={filterSize:r,strides:s,pad:i,dimRoundingMode:o};return ce.runKernel(y2,u,h)}const Ret=he({maxPoolGrad_:$et});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pet={kernelName:Jv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>Ret(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Det={kernelName:ew,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t,i=Tn(s,r.shape),a=Js(r.shape,i)[1],l=Te(a);return{x:()=>{const u=r.shape.slice();i.forEach(d=>{u[d]=1});const h=ve(n,u);return Ft(fe(h,da(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oet={kernelName:tw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:s}=r,[i,o]=e,a=Tn(s,i.shape),l=Fte(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fet={kernelName:ay,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,xt($y(t,r),"float32")),b:()=>fe(n,xt(el(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Let={kernelName:nw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>fn(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zet={kernelName:ly,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=ci(t.shape,s);return a.length>0?ve(Yt(n,a),t.shape):n},b:()=>{const a=fe(n,us(X2(Ft(t,r)))),l=ci(r.shape,s);return l.length>0?ve(Yt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bet={kernelName:cy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=fe(n,xt(r,"float32")),l=ci(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{const a=fe(n,xt(t,"float32")),l=ci(r.shape,s);return l.length>0?ve(Yt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vet={kernelName:rw,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uet={kernelName:ow,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>ms(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wet={kernelName:iw,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Get={kernelName:aw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return Ic(n,r).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o6={kernelName:lw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>fn(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Het={kernelName:uy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,s]=e,i=t,o=r,a=ln(i.shape,o.shape);return{a:()=>{const u=xt(o,"float32");let h=fe(n,fe(u,np(i,Rt(u,en(1)))));const f=ci(i.shape,a);return f.length>0&&(h=Yt(h,f)),ve(h,i.shape)},b:()=>{const u=el(i,0),h=vo(u,$l(i),ar(i));let f=fe(n,fe(s,h));const d=ci(o.shape,a);return d.length>0&&(f=Yt(f,d)),ve(f,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jet={kernelName:cw,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,s=el(t,0);return{x:()=>vo(s,n,fe(n,r)),alpha:()=>{let i=vo(s,ar(n),fe(n,t));const o=ci(r.shape,n.shape);return o.length>0&&(i=Yt(i,o)),ve(i,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qet(n,e,t){const r=n.shape.slice();r[t]=1;const s=ve(e,r),i=SI(n,t,!0,!1),o=SI(n,t,!0,!0),a=fe(i,o);return fe(s,a)}function Xet(n,e,t){const r=n.shape.length,s=r-t.length,i=Lr(t,r);let o=n;i!=null&&(o=nr(n,i));const a=o.shape.slice(),c=a.splice(r-t.length,t.length).reduce((f,d)=>f*d,1);a.push(c);const u=o.reshape(a);let h=qet(u,e,s);if(h=h.reshape(o.shape),i!=null){const f=Rh(i);h=nr(h,f)}return h}const Ket={kernelName:uw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;let i=[];return s==null?i=r.shape.map((o,a)=>a):typeof s=="number"?i=[s]:i=s,{x:()=>Xet(r,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yet={kernelName:jg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=Ft(n,xt(r,"float32")),l=ci(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{let a=fe(n,xt(t,"float32"));const l=ci(r.shape,s);l.length>0&&(a=ve(Yt(a,l),r.shape));const c=Or(r);return us(Ft(a,xt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zet={kernelName:hy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,us(Or(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jet={kernelName:dy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe($y(t,6),Ew(t));return{x:()=>fe(n,xt(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet={kernelName:fy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,xt(Ew(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ett={kernelName:hw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ttt={kernelName:dw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>ce.runKernel(T2,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ntt={kernelName:fw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>ce.runKernel(k2,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rtt={kernelName:pw,gradFunc:(n,e,t)=>{const{dims:r}=t,s=Tn(r,n.shape);return{x:()=>Ec(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const stt={kernelName:py,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const itt={kernelName:my,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>us(Ft(n,fe(np(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ott={kernelName:mw,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>xt(ar(t),"float32"),t:()=>fe(n,xt(t,n.dtype)),e:()=>fe(n,xt(FM(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const att={kernelName:gy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=el(t,en(0)),s=en(aC),i=en(lC),o=fe(n,i),a=fe(fe(n,s),Xo(xt(t,"float32")));return vo(r,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ltt={kernelName:wy,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(t,Rt(en(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ctt={kernelName:vy,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const utt={kernelName:yy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(NM(xt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const htt={kernelName:by,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(QL(xt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ftt={kernelName:gw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:s,size:i}=t,o=r.shape,[a,l]=oC(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>wu(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dtt={kernelName:ww,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:s}=t,i=!0,o=fe(n,r);return{logits:()=>Rt(o,fe(Yt(o,[s],i),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ptt={kernelName:xy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Il(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a6={kernelName:bw,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:s}=t;return{x:()=>MM(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l6={kernelName:vw,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>cs(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mtt={kernelName:Sy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,fe(wo(xt(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gtt={kernelName:R2,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(xt(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ytt={kernelName:_y,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=en(2);return{a:()=>fe(n,fe(s,Rt(t,r))),b:()=>fe(n,fe(s,Rt(r,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const btt={kernelName:Iy,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vtt={kernelName:Cy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=ci(t.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=ci(r.shape,s);return l.length>0&&(a=Yt(a,l)),ve(us(a),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wtt={kernelName:yw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,s=r.shape.slice(),{axis:i}=t;Tn(i,r.shape).forEach(c=>{s[c]=1});const a=ve(n,s),l=fe(a,da(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xtt={kernelName:ky,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ft(n,Or(NM(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Stt={kernelName:Ty,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(Rt(en(1),Or(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _tt={kernelName:Ey,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:s}=t;return{x:()=>{let o=ar(r);if(r.rank===1)for(let a=0;a<s[0];++a)o=qe(o,fn(n,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=qe(o,fn(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=qe(o,fn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=qe(o,fn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ctt={kernelName:Bd,gradFunc:(n,e,t)=>{const r=t,{perm:s}=r,i=Rh(s);return{x:()=>nr(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ktt={kernelName:xw,gradFunc:(n,e,t)=>{const r=t,{axis:s}=r;return{value:()=>wa(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ttt={kernelName:Sw,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ett(n,t)}}};function Ett(n,e){const t=Wf(e,ar(e)),r=K2(n,t);let s=Tp(e,en(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=ii(s,a+1);s=Sh(s,da(r.shape,"bool"));const o=ar(r);return vo(s,r,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Itt={kernelName:_w,gradFunc:n=>({x:()=>ar(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Att=[Ote,CQe,kQe,TQe,EQe,IQe,AQe,MQe,NQe,$Qe,RQe,PQe,FQe,BQe,VQe,UQe,WQe,GQe,HQe,jQe,qQe,XQe,YQe,KQe,QQe,eet,tet,net,ret,set,Yet,iet,oet,aet,cet,uet,fet,het,det,pet,met,get,yet,bet,vet,wet,xet,_et,Cet,Eet,i6,i6,Iet,Net,Pet,Det,Oet,Fet,Let,zet,Bet,Vet,Uet,Wet,Get,o6,o6,Het,jet,Ket,Zet,Jet,Qet,ett,ttt,ntt,rtt,stt,itt,ott,att,ltt,ctt,utt,htt,ftt,dtt,ptt,a6,a6,l6,l6,mtt,ytt,gtt,btt,vtt,wtt,xtt,Stt,_tt,Ctt,ktt,Ttt,Itt];for(const n of Att)K7(n);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function a4(n,e){return Se(()=>wo(Yt(fe(n,n),e,!0)))}class kC extends Py{getConfig(){return{}}}class Lte extends kC{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=a4(e,this.axis),r=va(t,0,this.maxValue);return fe(e,Ft(r,qe(_i(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Lte.className="MaxNorm";at(Lte);class zte extends kC{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>Ft(e,qe(_i(),a4(e,this.axis))))}getConfig(){return{axis:this.axis}}}zte.className="UnitNorm";at(zte);class Bte extends kC{apply(e){return Ph(e)}}Bte.className="NonNeg";at(Bte);class Vte extends kC{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=a4(e,this.axis),r=qe(fe(this.rate,va(t,this.minValue,this.maxValue)),fe(1-this.rate,t));return fe(e,Ft(r,qe(_i(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Vte.className="MinMaxNorm";at(Vte);const c6={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ti(n){return YB(n)}function u6(n,e={}){return wC(n,Sl.getMap().classNameMap,e,"constraint")}function Ei(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in c6?c6[n]:n,config:{}};return u6(t)}else return n instanceof kC?n:u6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function tm(n){if(n==null)return;const e=[],t=[],r=[];for(const s in n){const i=n[s];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(s),r.push(o)}}if(e.length>0){const s=await Promise.all(e);for(let i=0;i<s.length;++i)n[t[i]]=s[i][0];nn(r)}}function Ute(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var h6;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(h6||(h6={}));const Mtt=125;class US{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Ntt{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class $tt extends US{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const s in t){const i=t[s];if(typeof i=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+i*r;else{let o;s in this.totals?o=this.totals[s]:this.totals[s]=0;const a=Se(()=>qe(this.totals[s],fe(i,r)));this.totals[s]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:Se(()=>{const s=fe(Ft(1,this.seen),this.totals[r]);t[r]=s,this.totals[r].dispose(),qs(t[r])}))}}class Rtt extends US{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(i),r.push(a)}}const s=await Promise.all(e);for(let i=0;i<s.length;++i)this.history[t[i]][r[i]].dispose(),this.history[t[i]][r[i]]=s[i][0]}}class Ptt extends US{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Gz,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Mtt),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");mI(this.yieldEvery)&&(this.maybeWait=VJe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const s=[];this.yield!=null&&(await tm(r),s.push(this.yield(e,t,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await tm(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await tm(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await tm(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await tm(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):mI(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await tm(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await tm(e),await this.trainEnd(e))}}function Wte(n,e){return n==null&&(n={}),n instanceof US?[n]:Array.isArray(n)&&n[0]instanceof US?n:Gr(n).map(r=>new Ptt(r,e))}class oc{constructor(){}static registerCallbackConstructor(e,t){U(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),oc.checkForDuplicate(t),oc.constructors[e]==null&&(oc.constructors[e]=[]),oc.constructors[e].push(t)}static checkForDuplicate(e){for(const t in oc.constructors)oc.constructors[+t].forEach(s=>{if(s===e)throw new xe("Duplicate callback constructor.")})}static clear(){oc.constructors={}}static createCallbacks(e){const t=[];for(const r in oc.constructors){const s=+r;e>=s&&t.push(...oc.constructors[s])}return t.map(r=>new r)}}oc.constructors={};function Gte(n,e,t,r,s,i,o,a,l){const c=new Rtt,u=[new $tt,...oc.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new Ntt(u);return h.setParams({epochs:t,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bh(n,e={},t=!1){return wC(n,Sl.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ZI(n,e){return Se(()=>{n.dtype!=="float32"&&(n=xt(n,"float32"));const t=Yt(SC(n),e,!0),r=Ny(t.shape,_i()),s=wo(Wf(t,r));return Ft(n,s)})}function s$(n,e){return Se(()=>Os(SC(Rt(e,n)),-1))}function l4(n,e){return Se(()=>Os(bi(Rt(e,n)),-1))}function c4(n,e){return Se(()=>{const t=Rt(n,e),r=va(bi(n),_i(),Number.MAX_VALUE),s=bi(Ft(t,r));return fe(100,Os(s,-1))})}function Dtt(n,e){return Se(()=>{const t=va(e,_i(),Number.MAX_VALUE),r=$l(qe(1,t)),s=va(n,_i(),Number.MAX_VALUE),i=$l(qe(1,s));return Os(SC(Rt(r,i)),-1)})}function Ott(n,e){return Se(()=>{const t=Wf(0,Rt(1,fe(n,e)));return Os(SC(t),-1)})}function Ftt(n,e){return Se(()=>{const t=Wf(0,Rt(1,fe(n,e)));return Os(t,-1)})}function Ltt(n,e){return Se(()=>{const t=Yt(fe(n,e),-1),r=Sc(fe(Rt(1,n),e),-1);return Wf(0,qe(1,Rt(r,t)))})}function ztt(n,e){return Se(()=>{const t=Math.log(2),r=Rt(e,n),s=Rt(qe(r,kw(fe(-2,r))),t);return Os(s,-1)})}function WS(n,e,t=!1){return Se(()=>{if(t)e=eC(e);else{const r=Yt(e,e.shape.length-1,!0);e=Ft(e,r)}return e=va(e,_i(),1-_i()),us(Yt(fe(xt(n,"float32"),$l(e)),e.shape.length-1))})}function JI(n,e,t=!1){return Se(()=>{const r=xt(X2(QJe(n)),"int32");e=va(e,_i(),1-_i());const s=e.shape,i=ve(Hb(r,s[s.length-1]),s);return WS(i,e,t)})}function Btt(n,e){if(!Mn(n.shape,e.shape))throw new xe(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return Se(()=>{const t=Ph(e),r=us(bi(e));return qe(Rt(t,fe(e,n)),PM(Xo(r)))})}function i$(n,e){return Se(()=>{let t;return t=va(e,_i(),1-_i()),t=$l(Ft(t,Rt(1,t))),Os(Btt(n,t),-1)})}function Vtt(n,e){return Se(()=>{const t=va(n,_i(),1),r=va(e,_i(),1);return Yt(fe(n,$l(Ft(t,r))),-1)})}function Utt(n,e){return Se(()=>{const t=$l(qe(_i(),e));return Os(Rt(e,fe(n,t)),-1)})}function Hte(n,e){return Se(()=>{const t=ZI(n,-1),r=ZI(e,-1),s=fe(t,r);return us(Yt(s,-1))})}const QI={meanSquaredError:s$,meanAbsoluteError:l4,meanAbsolutePercentageError:c4,meanSquaredLogarithmicError:Dtt,squaredHinge:Ott,hinge:Ftt,categoricalHinge:Ltt,logcosh:ztt,categoricalCrossentropy:WS,sparseCategoricalCrossentropy:JI,binaryCrossentropy:i$,kullbackLeiblerDivergence:Vtt,poisson:Utt,cosineProximity:Hte};function C3(n){if(typeof n=="string"){if(n in QI)return QI[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new xe(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jte(n,e){return Se(()=>{const t=fe(.5,Rl(e)),r=gh(el(e,t),n.dtype);return Os(vu(n,r),-1)})}function qte(n,e){return Se(()=>gh(vu(sg(n,-1),sg(e,-1)),"float32"))}function Wtt(n,e){return Se(()=>xt(Yt(Sh(vu(n,1),vu(e,1))),"float32"))}function Gtt(n,e){return Se(()=>xt(Yt(Sh(vu(n,0),vu(e,1))),"float32"))}function Htt(n,e){return Se(()=>{const t=Wtt(n,e),r=Gtt(n,e),s=qe(t,r);return xt(vo(el(s,0),Ft(t,s),0),"float32")})}function jtt(n,e){return i$(n,e)}function qtt(n,e){return n.rank===e.rank&&(n=gr(n,[n.rank-1])),e=sg(e,-1),e.dtype!==n.dtype&&(e=xt(e,n.dtype)),xt(vu(n,e),"float32")}const Xtt=s$,Ktt=s$,Ytt=l4,Ztt=l4,Jtt=c4,Qtt=c4,Xte=WS,ent=Hte,Kte=JI,eA={binaryAccuracy:jte,categoricalAccuracy:qte,precision:Htt,categoricalCrossentropy:Xte,sparseCategoricalCrossentropy:Kte,mse:Xtt,MSE:Ktt,mae:Ytt,MAE:Ztt,mape:Jtt,MAPE:Qtt,cosine:ent};function tnt(n){if(typeof n=="string"&&n in eA)return eA[n];if(typeof n!="string"&&n!=null)return n;throw new xe(`Unknown metric ${n}`)}function aT(n){if(ah(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(QI))if(QI[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(eA))if(eA[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nnt(n){const e={Adagrad:()=>Sd.adagrad(.01),Adadelta:()=>Sd.adadelta(1,.95,_i()),Adam:()=>Sd.adam(.001,.9,.999,_i()),Adamax:()=>Sd.adamax(.002,.9,.999,_i(),0),RMSProp:()=>Sd.rmsprop(.001,.9,0,_i()),SGD:()=>Sd.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new xe(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const f6=1*1024*1024;function d6(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!VO(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>f6&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${f6}.`)}}function VO(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!VO(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!VO(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rnt(n,e,t,r=console.log){const s=int(n),i=["Layer (type)","Input Shape","Output shape","Param #"];s?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(e)),tA(i,t,r),r("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)s?ont(a[u],t,r):ant(a[u],t,o,r),r((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=snt(n),c=XI(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(e))}function snt(n){let e;return n.collectedTrainableWeights!=null?e=XI(n.collectedTrainableWeights):e=XI(n.trainableWeights),e}function int(n){let e=!0;const t=[],r=[];for(const s in n.nodesByDepth)t.push(n.nodesByDepth[s]);for(const s of t){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(r.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function tA(n,e,t=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);t(r)}function ont(n,e,t){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,s,r,n.countParams().toString()];tA(a,e,t)}function ant(n,e,t,r){let s,i;try{i=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let f=0;f<h.inboundLayers.length;++f){const d=h.inboundLayers[f].name,p=h.nodeIndices[f],m=h.tensorIndices[f];o.push(`${d}[${p}][${m}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,i,s,n.countParams().toString(),c];tA(u,e,r);for(let h=1;h<o.length;++h)tA(["","","","",o[h]],e,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yte(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function nA(n,e){if(n===null)return null;if(typeof n=="string")return $m(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];Yte(e,s,i)?t.push(i):t.push(nA(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r];if(r==="name"&&typeof s=="string")t[r]=s;else{const i=$m(r);t[i]=nA(s,i)}}return t}}function UO(n,e){if(n==null)return null;if(typeof n=="string")return bf(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];Yte(e,s,i)?t.push(i):t.push(UO(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r],i=bf(r);(r==="name"||r==="className")&&typeof s=="string"?t[i]=s:t[i]=UO(s,r)}return t}}/** @license See the LICENSE file. */const Zte="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const lnt=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class su extends Kn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=t$(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ud(this.inputs).length!==this.inputs.length)throw new xe(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ud(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.sourceLayer,w=b.nodeIndex,_=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(_)}for(const b of this.inputs){const x=b.sourceLayer,w=b.nodeIndex,_=b.tensorIndex;ah(w===0,"input layer has >1 nodes"),ah(_===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(_)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const x=this.inputLayers[b];if(!(x instanceof CC))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},r={},s={},i={},o={},a=[],l=(b,x,w,_,C,k)=>{(_==null||C==null||k==null)&&(_=b.sourceLayer,C=b.nodeIndex,k=b.tensorIndex);const A=_.inboundNodes[C];if(w.indexOf(A)!==-1)throw new bc(`The tensor ${b.name} at layer "${_.name}" is part of a cycle.`);if(x.indexOf(A)!==-1)return;this.containerNodes.add(su.nodeKey(_,C)),_.id in o||(o[_.id]=Object.keys(o).length),w.indexOf(A)===-1&&w.push(A);const M=A.inboundLayers.length;for(let I=0;I<M;I++){const N=A.inputTensors[I],O=A.inboundLayers[I],R=A.nodeIndices[I],D=A.tensorIndices[I];l(N,x,w,O,R,D)}for(x.push(A);w.indexOf(A)>=0;)w.splice(w.indexOf(A),1);a.push(A)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const h=a.slice().reverse();for(const b of h){r[b.id]=b,b.id in t||(t[b.id]=0);let x=t[b.id];const w=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];x=Math.max(x,w),s[b.outboundLayer.id]=x,i[b.outboundLayer.id]=b.outboundLayer,t[b.id]=x;for(let _=0;_<b.inboundLayers.length;_++){const C=b.inboundLayers[_],k=b.nodeIndices[_],A=C.inboundNodes[k],M=t[A.id]==null?0:t[A.id];t[A.id]=Math.max(x+1,M),r[A.id]=A}}const f={};for(const b in t){const x=t[b];x in f||(f[x]=[]),f[x].push(r[b])}const d={};for(const b in s){const x=s[b];x in d||(d[x]=[]),d[x].push(i[b])}let p=Object.keys(d).map(b=>parseInt(b,10)).sort(sT);this.layers=[];for(const b of p){const x=d[b];x.sort((w,_)=>{const C=o[w.id],k=o[_.id];return C<k?-1:C>k?1:0});for(const w of x)w instanceof su&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=d,p=Object.keys(f).map(b=>parseInt(b,10)).sort(sT);const m=this.inputs.slice(),g=[];for(const b of p)for(const x of f[b]){const w=x.outboundLayer;if(w!=null){for(const _ of x.inputTensors)if(m.indexOf(_)===-1)throw new bc(`Graph disconnected: cannot obtain value for tensor ${_} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const _ of x.outputTensors)m.push(_);g.push(w.name)}}this.nodesByDepth=f;const y=this.layers.map(b=>b.name);for(const b of y){const x=y.filter(w=>w===b).length;if(x!==1)throw new bc(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new r$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new xe("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let s=0;const i=lnt(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(r[u]!=null)throw new xe(`Duplicate weight name: ${u}`);r[u]=c,s++}const o=[];for(const a in e){let l=a;if(r[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[l]!=null)o.push([r[l],e[a]]);else if(t)throw new xe(`Provided weight data has no target variable: ${a}`);delete r[l]}if(t){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new xe(`${a.length} of ${s} weights are not set: ${a}`)}o4(o)}parseWeights(e){for(const t in Object.keys(e)){const r=t.split("/"),s=["vars","layer_checkpoint_dependencies"],i=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!s.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Zte}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=UO(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return Se(()=>{e=Gr(e);const r=new $d;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return C1(this.outputs,r,t)})}computeMask(e,t){return Se(()=>{e=Gr(e);let r;return t==null?r=pg(null,e.length):r=Gr(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=qI(e);if(t.length!==this.inputLayers.length)throw new xe(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";r[u]=c}const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(sT);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;const h=[];for(let m=0;m<c.inboundLayers.length;m++){const g=c.inboundLayers[m],y=c.nodeIndices[m],b=c.tensorIndices[m],x=`${g.name}_${y}_${b}`,w=r[x];h.push(w)}const f=u.computeOutputShape(ha(h)),d=qI(f),p=u.inboundNodes.indexOf(c);for(let m=0;m<d.length;m++){const g=`${u.name}_${p}_${m}`;r[g]=d[m]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];ah(l in r),i.push(r[l])}return ha(i)}runInternalGraph(e,t){t==null&&(t=pg(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];r[c.id]=[u,h]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(sT);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,f=u.inputTensors,d=u.outputTensors,p=new Array;for(const m of f)m.id in r&&p.push(r[m.id]);if(p.length===f.length){let m={},g,y,b,x;if(u.callArgs!=null&&(m=u.callArgs),p.length===1){const[w,_]=p[0];m.mask==null&&(m.mask=_),b=Gr(h.call(w,m)),x=Gr(h.computeMask(w,_)),g=[w],y=[_]}else g=p.map(w=>w[0]),y=p.map(w=>w[1]),m.mask==null&&(m.mask=y),b=Gr(h.call(g,m)),x=Gr(h.computeMask(g,y));if(h.activityRegularizer)throw new Fn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<d.length;++w){const _=d[w],C=b[w],k=x[w];r[_.id]=[C,k]}}}}const i=[],o=[],a=[];for(const l of this.outputs){ah(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(e){const t={};let r;for(const s of this.layers){r=s instanceof su?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=su.nodeKey(s,i);this.containerNodes.has(o)&&(t[o]=r,r+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new xe("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new xe(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new xe(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Se(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const s=su.nodeKey(t,r);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const f=o.inboundNodes[h],d=su.nodeKey(o,h);let p={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),p=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(f.inboundLayers.length>0){const m=[];for(let g=0;g<f.inboundLayers.length;g++){const y=f.inboundLayers[g],b=f.nodeIndices[g],x=f.tensorIndices[g],w=su.nodeKey(y,b);let _=t[w];_==null&&(_=0),m.push([y.name,_,x,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}e.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=su.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];s.push([a.name,u,h])}e.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=su.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,u,h])}return e.outputLayers=i,e}static fromConfig(e,t,r={},s=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let x;for(const w of y){const _=w[0],C=w[1],k=w[2];if(x=w[3]==null?{}:w[3],!(_ in i)){a(g,y);return}const A=i[_];if(A.inboundNodes.length<=C){a(g,y);return}const M=A.inboundNodes[C];b.push(M.outputTensors[k])}b.length>0&&g.apply(ha(b),x)}function c(g){const y=g.name,b=bh(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(s),i[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new xe(`Corrupted configuration, expected array for nodeData: ${w}`);a(b,w)})}const u=t.name,h=t.layers;for(const g of h)c(g);for(;!BJe(o);)for(const g of h){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const x of b)l(y,x)}}const f=[],d=[],p=t.inputLayers;for(const g of p){const y=g[0],b=g[1],x=g[2];ah(y in i);const _=i[y].inboundNodes[b].outputTensors;f.push(_[x])}const m=t.outputLayers;for(const g of m){const y=g[0],b=g[1],x=g[2];ah(y in i);const _=i[y].inboundNodes[b].outputTensors;d.push(_[x])}return new e({inputs:f,outputs:d,name:u})}get stateful(){if(this._stateful)throw new xe("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cnt(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const s=[];return e.forEach(i=>{i in n?s.push(n[i]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function Jte(n,e){return cnt(n,e,"classWeight")}async function Qte(n,e,t,r){if(e!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const s=Se(()=>{if(n.shape.length===1)return mh(n);if(n.shape.length===2){if(n.shape[1]>1)return sg(n,1);if(n.shape[1]===1)return ve(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await s.data());nn(s);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Xs(o,"float32")}else return null}function unt(n,e){return fe(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const hnt=32;function ene(n,e){let t,r;const s=e;t=s.xs,r=s.ys,U(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=p6("input",n.inputNames,t),o=p6("output",n.outputNames,r),a=i[0].shape[0];U(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),U(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)U(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)U(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function p6(n,e,t){if(t instanceof qn)return[t];if(Array.isArray(t))return U(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const s of e){if(t[s]==null)throw new xe(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(t[s])}return r}}function fnt(n){if(n.length===3)throw new Fn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function dnt(n,e,t){const r=t.batchesPerEpoch!=null;if(U(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),U(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),U(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),U(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),U(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=t.validationData!=null;let i,o;if(s)if(m6(t.validationData))U(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=fnt(t.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;s?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();const u=Wte(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:f,history:d}=Gte(u,h,t.epochs,null,null,pnt(e,t),null,s,c);f.setModel(n),n.history=d,await f.onTrainBegin(),n.stopTraining_=!1;let p=t.initialEpoch==null?0:t.initialEpoch,m=await e.iterator();for(;p<t.epochs;){const g={};await f.onEpochBegin(p);let y=0,b=0;for(r||(m=await e.iterator());!r||y<t.batchesPerEpoch;){const x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:w,ys:_}=ene(n,x.value),C={};C.batch=b,C.size=w[0].shape[0],await f.onBatchBegin(b,C);const k=[];if(t.classWeight!=null){const I=Jte(t.classWeight,n.outputNames);for(let N=0;N<I.length;++N)k.push(await Qte(_[N],null,I[N]))}const A=w.concat(_).concat(k),M=a(A);nn(A);for(let I=0;I<l.length;++I){const N=l[I],O=M[I];C[N]=O,qs(O)}await f.onBatchEnd(b,C),Ute(C),b++,y++}if(r?y>=t.batchesPerEpoch:x.done){if(s){let w;m6(t.validationData)?w=Gr(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):w=Gr(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?hnt:t.validationBatchSize,verbose:0}));for(let _=0;_<n.metricsNames.length;++_)g[`val_${n.metricsNames[_]}`]=w[_]}break}if(n.stopTraining_)break}if(await f.onEpochEnd(p,g),p++,n.stopTraining_)break}return await f.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function pnt(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function m6(n){return typeof n.iterator=="function"}function mnt(n){return typeof n.next=="function"}async function gnt(n,e,t){t=t||{};const r=t.batches!=null,s=n.testFunction;let i=[];if(t.verbose>0)throw new Fn("Verbose mode is not implemented yet.");U(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=mnt(e)?e:await e.iterator();let a=0,l=0;for(;!r||l<t.batches;){const c=await o.next();if(i=Se(()=>{if(c.value){const{xs:u,ys:h}=ene(n,c.value),f=u.concat(h),d=Se(()=>s(f));if(nn(f),l===0)for(let m=0;m<d.length;++m)i.push(en(0));const p=f[0].shape[0];for(let m=0;m<d.length;++m){const g=d[m],y=i[m];i[m]=Se(()=>qe(i[m],fe(p,g))),l>0&&nn(y)}nn(d),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=Ft(i[c],a),nn(u)}return ha(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function k3(n){U(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Ux(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>Hm(r,e,t-e)):Hm(n,e,t-e)}function WO(n,e){return Se(()=>n==null?null:Array.isArray(n)?n.map(t=>WO(t,e)):Tte(n,e.dtype==="int32"?e:xt(e,"int32")))}function T3(n,e){const t=[];let r=0,s=null;for(;r<n;)s=r+e,s>=n&&(s=n),t.push([r,s]),r=s;return t}function tne(n){const e=[];n instanceof qn&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(xC(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Yc(n,e){if(n==null)return;const t=[];if(e instanceof qn)t.push(e.id);else if(Array.isArray(e))e.forEach(s=>t.push(s.id));else if(e!=null)for(const s in e){const i=e[s];t.push(i.id)}const r=[];if(n instanceof qn)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{t.indexOf(s.id)===-1&&r.push(s)});else if(n!=null)for(const s in n){const i=n[s];t.indexOf(i.id)===-1&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ynt(n){return n instanceof qn}function GO(n){return Array.isArray(n)}function g6(n){return!ynt(n)&&!GO(n)}function y6(n,e,t,r=!0,s=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(GO(n)&&n.length>0)o=!0;else if(g6(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new xe(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(g6(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new xe(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(GO(n)){if(n=n,n.length!==e.length)throw new xe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new xe(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=tne(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new xe(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new xe(`${s} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function bnt(n,e,t){const r=Ud(n.map(i=>i.shape[0]));r.sort();const s=Ud(e.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new xe(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new xe(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!Mn(r,s))throw new xe(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function vnt(n,e,t){const r=[s$,i$,WS];for(let s=0;s<n.length;++s){const i=n[s],o=e[s],a=t[s];if(o!=null){if(o===WS&&i.shape[i.shape.length-1]===1)throw new xe(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],f=c[u];if(f!=null&&h!==f)throw new xe(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function b6(n,e,t,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new xe(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new xe(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new xe(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new xe(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function wnt(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const s of e){let i=t.hasOwnProperty(s)?t[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}const xnt="layers-model";class Gd extends su{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new xe("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");rnt(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=nnt(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Hf))throw new xe("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new xe(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(C3(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new xe(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>C3(a))}else{const o=C3(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Gm("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const s=wnt(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Gm("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=s[o];(c=>{const u="";let h,f,d;for(const p of c){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const g=this.internalOutputShapes[o];g[g.length-1]===1||this.lossFunctions[o]===i$?["accuracy","acc"].indexOf(p)!==-1?f=jte:["crossentropy","ce"].indexOf(p)!==-1&&(f=jtt):this.lossFunctions[o]===JI?["accuracy","acc"].indexOf(p)!==-1?f=qtt:["crossentropy","ce"].indexOf(p)!==-1&&(f=Kte):["accuracy","acc"].indexOf(p)!==-1?f=qte:["crossentropy","ce"].indexOf(p)!==-1&&(f=Xte);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),d=f,h=u+y}else d=tnt(p),h=u+aT(p);let m;Gm(h,()=>{m=d}),i(o,h,m)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const s=r.batchSize==null?32:r.batchSize;k3(s);const i=!0,o=this.standardizeUserDataXY(e,t,i,s);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,s,r.verbose,r.steps);return ha(c)}finally{Yc(o[0],e),Yc(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),gnt(this,e,t)}checkNumSamples(e,t,r,s="steps"){let i;if(r!=null){if(i=null,t!=null)throw new xe(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new xe(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new xe("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),s=r?t:[t],i=this.retrieveSymbolicTensors(s),o=new $d;if(e instanceof qn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new xe(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new xe(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=C1(i,o);return r?a:a[0]}retrieveSymbolicTensors(e){const t=pg(null,e.length);let r=e.length;for(const s of this.layers){const i=Array.isArray(s.output)?s.output:[s.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=i[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw t.forEach((i,o)=>{i==null&&s.push(e[o])}),new xe(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return t}predictLoop(e,t=32,r=!1){return Se(()=>{const s=this.checkNumSamples(e);if(r)throw new Fn("Verbose predictLoop() is not implemented yet.");const i=T3(s,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)Se(()=>{const c=i[a][0],u=i[a][1],h=Ux(e,c,u),f=[];if(Array.isArray(h))for(let p=0;p<h.length;++p)f.push({key:this.inputs[p],value:h[p]});else f.push({key:this.inputs[0],value:h});const d=new $d(f);return C1(this.outputs,d)}).forEach((c,u)=>o[u].push(c));return ha(o.map(a=>cs(a,0)))})}predict(e,t={}){const r=tne(e);b6(r,this.inputNames,this.feedInputShapes,!1);try{const s=t.batchSize==null?32:t.batchSize;return k3(s),this.predictLoop(r,s)}finally{Yc(r,e)}}predictOnBatch(e){b6(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,s){if(this.optimizer_==null)throw new bc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===JI?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=y6(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=y6(t,this.feedOutputNames,i,!1,"target"),bnt(e,t),vnt(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new xe(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,s,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,i,o);if(r!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){const u=Jte(s,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await Qte(l[h],null,u[h]))}return[a,l,c]}testLoop(e,t,r,s=0,i){return Se(()=>{const o=this.checkNumSamples(t,r,i,"steps"),a=[];if(s>0)throw new Fn("Verbose mode is not implemented yet.");if(i!=null)throw new Fn("steps mode in testLoop() is not implemented yet");{const l=T3(o,r),c=Xs(Cu(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],f=l[u][1],d=Hm(c,h,f-h),p=WO(t,d),m=e(p);if(u===0)for(let g=0;g<m.length;++g)a.push(en(0));for(let g=0;g<m.length;++g){const y=m[g];a[g]=qe(a[g],fe(f-h,y))}}for(let u=0;u<a.length;++u)a[u]=Ft(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const s=e[r];let i=s;if(YH(e,s)>1){const o=YH(e.slice(0,r),s);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const f=new $d(h),d=C1(this.outputs,f,{training:!0});let p;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(s[m],d[m]);i[m]!=null&&(y=unt(y,i[m]));const b=Os(y);t.push(b),m===0?p=y:p=qe(p,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Os(y(s[b],d[b]))}qs(g),o.push(g)}return p=Os(p),this.calculateLosses().forEach(m=>{p=qe(p,m)}),p},l=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(a,c,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>Se(()=>{const t=[];let r;const s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:s[c]});const a=new $d(o),l=C1(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=Os(u(i[c],l[c]));c===0?r=h:r=qe(r,h),t.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],f=Os(u(i[h],l[h]));t.push(f)}return t})}async fit(e,t,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,i,o,a,l,c,u,h,f;try{const d=r.batchSize==null?32:r.batchSize;k3(d);const p=!1,m=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,p,d);s=m[0],i=m[1],f=m[2];let g=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)l=r.validationData[0],c=r.validationData[1];else throw r.validationData.length===3?new Fn("validationData including sample weights is not supported yet."):new xe(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const M=!0,I=await this.standardizeUserData(l,c,null,null,M,d);u=I[0],h=I[1],y=u.concat(h)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const M=Math.floor(s[0].shape[0]*(1-r.validationSplit)),I=s[0].shape[0];u=Ux(s,M,I),o=s,s=Ux(s,0,M),h=Ux(i,M,I),a=i,i=Ux(i,0,M),y=u.concat(h)}else r.validationSteps!=null&&(g=!0);const b=s.concat(i).concat(f);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let _,C;g?(this.makeTestFunction(),_=this.testFunction,C=w.slice().concat(w.map(M=>"val_"+M))):(_=null,y=[],C=w.slice());const k=Wte(r.callbacks,r.yieldEvery);return await this.fitLoop(x,b,w,d,r.epochs,r.verbose,k,_,y,r.shuffle,C,r.initialEpoch,null,null)}finally{this.isTraining=!1,Yc(s,e),Yc(i,t),Yc(o,e),Yc(a,t),Yc(u,l),Yc(h,c),f!=null&&nn(f)}}async fitLoop(e,t,r,s,i,o,a,l,c,u,h,f,d,p){s==null&&(s=32),i==null&&(i=1),u==null&&(u=!0),f==null&&(f=0);let m=!1;if(l!=null&&c!=null&&(m=!0),p!=null&&(m=!0,d==null))throw new xe("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,s,d,"steps_per_epoch");let y;g!=null&&(y=Cu(0,g)),o==null&&(o=1);const{callbackList:b,history:x}=Gte(a,o,i,f,g,d,s,m,h);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=f;w<i;++w){await b.onEpochBegin(w);const _={};if(d!=null)throw new Fn("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Fn("batch shuffling is not implemneted yet");u&&yL(y);const C=Xs(y),k=T3(g,s);for(let A=0;A<k.length;++A){const M={};if(await b.onBatchBegin(A,M),Se(()=>{const I=k[A][0],N=k[A][1],O=Hm(C,I,N-I);M.batch=A,M.size=N-I;const R=WO(t,O),D=e(R);for(let z=0;z<r.length;++z){const B=r[z],X=D[z];M[B]=X,qs(X)}if(A===k.length-1&&m){const z=this.testLoop(l,c,s);for(let B=0;B<r.length;++B){const X=r[B],G=z[B];qs(G),_["val_"+X]=G}}}),await b.onBatchEnd(A,M),Ute(M),this.stopTraining_)break}C.dispose()}if(await b.onEpochEnd(w,_),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return dnt(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),s=r[0],i=r[1],a=this.makeTrainFunction()(s.concat(i)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return nn(a),Yc(r[0],e),Yc(r[1],t),ha(l)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,i=this.getWeights(r);for(let o=0;o<s.length;++o)r&&!s[o].trainable||t.push({name:s[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=wI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-wI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=bf(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>bf(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const s of t)if(typeof r[s]=="string")e[s]=bf(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[bf(aT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>bf(aT(e)));{const e={};for(const t in this.metrics)e[t]=bf(aT(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=nA(e.optimizer_config),r=bh(t);let s;if(typeof e.loss=="string")s=$m(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(o=>$m(o));else if(e.loss!=null){s={};for(const o in e.loss)s[o]=$m(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>$m(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=$m(e.metrics[o])}this.compile({loss:s,metrics:i,optimizer:r})}async save(e,t){if(typeof e=="string"){const c=mX(e);if(c.length===0)throw new xe(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new xe(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new xe("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await pD(this.getNamedWeights(t)),s=!1,i=null,a={modelTopology:this.toJSON(i,s),format:xnt,generatedBy:`TensorFlow.js tfjs-layers v${Zte}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await pD(await this.optimizer.getWeights(),c);r.specs.push(...h),r.data=dX([r.data,u])}return this.userDefinedMetadata!=null&&(d6(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){d6(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Gd.className="Model";at(Gd);class nne extends Gd{}nne.className="Functional";at(nne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function GS(n,e){if(e==null&&(e={}),typeof n=="string"){const t=gX(n,e);if(t.length===0)t.push(uY(n,e));else if(t.length>1)throw new xe(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return Snt(n,void 0,e)}async function Snt(n,e,t){if(t==null&&(t={}),n.load==null)throw new xe("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await n.load();let s=r.modelTopology;s.model_config!=null&&(s=s.model_config);const i=t.strict==null?!0:t.strict,o=r.weightData!=null&&r.weightSpecs!=null&&i,a=bh(nA(s),e,o),l=r.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),r.userDefinedMetadata!=null&&a.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new xe("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=_nt(r.weightData,r.weightSpecs);a.loadWeights(c,i),a.optimizer!=null&&u.length>0&&await a.optimizer.setWeights(u),nn(c),nn(u.map(h=>h.tensor))}return a}function _nt(n,e){const t=IL(n,e),r={},s=[];return e.forEach(i=>{i.group==="optimizer"?s.push({name:i.name,tensor:t[i.name]}):r[i.name]=t[i.name]}),{modelWeights:r,optimizerWeights:s}}class nv extends Gd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:t$("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new xe(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof nv||e instanceof Gd;let r;if(t){if(r=e,r.outputs.length!==1)throw new xe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new xe("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new xe("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=yQe({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new xe(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new xe("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Dte(this.outputs[0])}this.inboundNodes=[],new r$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pg(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(vr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Gd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new bc("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},s=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new xe("Legacy serialization format not supported yet.");i=t}else U(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof nv))throw new Fn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const u=bh(l,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new xe("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new xe("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}nv.className="Sequential";at(nv);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cnt(n){return new nv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ka=class extends Py{getConfig(){return{}}};class rne extends ka{apply(e,t=1){return tQe(e,t)}}rne.className="elu";at(rne);class sne extends ka{apply(e){return bz(e)}}sne.className="selu";at(sne);class ine extends ka{apply(e){return Ph(e)}}ine.className="relu";at(ine);class one extends ka{apply(e){return Se(()=>rp(6,Ph(e)))}}one.className="relu6";at(one);class ane extends ka{apply(e){return e}}ane.className="linear";at(ane);class lne extends ka{apply(e){return Il(e)}}lne.className="sigmoid";at(lne);class cne extends ka{apply(e){return rQe(e)}}cne.className="hardSigmoid";at(cne);class une extends ka{apply(e){return kw(e)}}une.className="softplus";at(une);class hne extends ka{apply(e){return nQe(e)}}hne.className="softsign";at(hne);class fne extends ka{apply(e){return Wb(e)}}fne.className="tanh";at(fne);let u4=class extends ka{apply(e,t=-1){return eC(e,t)}};u4.className="softmax";at(u4);class dne extends ka{apply(e,t=-1){return nz(e,t)}}dne.className="logSoftmax";at(dne);class pne extends ka{apply(e,t=1){return Se(()=>fe(Il(fe(e,t)),e))}}pne.className="swish";at(pne);class mne extends ka{apply(e){return Se(()=>fe(e,Wb(kw(e))))}}mne.className="mish";at(mne);function ap(n){return n.getClassName()}function E3(n,e={}){return wC(n,Sl.getMap().classNameMap,e,"activation")}function lp(n){if(n==null){const e={};return e.className="linear",e.config={},E3(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},E3(e)}else return n instanceof ka?n:E3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function knt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class gne extends Py{}class yne extends gne{constructor(e){super(),knt(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Se(()=>{let t=ms([1]);return this.hasL1&&(t=qe(t,Yt(fe(this.l1,bi(e))))),this.hasL2&&(t=qe(t,Yt(fe(this.l2,SC(e))))),ve(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}yne.className="L1L2";at(yne);const v6={l1l2:"L1L2"};function jr(n){return YB(n)}function w6(n,e={}){return wC(n,Sl.getMap().classNameMap,e,"regularizer")}function ws(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in v6?v6[n]:n,config:{}};return w6(t)}else return n instanceof gne?n:w6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bne extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=bn(e);let r=Ph(e);return this.maxValue!=null&&(r=va(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}bne.className="ReLU";at(bne);class vne extends Kn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=bn(e);return RM(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}vne.className="LeakyReLU";at(vne);class wne extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ys(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ws(e.alphaRegularizer),this.alphaConstraint=Ei(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new xe(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=vr(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new Ci({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=bn(e),VM(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ks(this.alphaInitializer),alphaRegularizer:jr(this.alphaRegularizer),alphaConstraint:Ti(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}wne.className="PReLU";at(wne);class xne extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Fn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=bn(e);return q2(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}xne.className="ELU";at(xne);class Sne extends Kn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=bn(e);return fe(r,xt(el(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Sne.className="ThresholdedReLU";at(Sne);class _ne extends Kn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new u4().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return Se(()=>{let r=bn(e);const s=t.mask;if(s!=null){const i=fe(Rt(da(r.shape),xt(s,r.dtype)),en(-1e9));r=qe(r,i)}return this.axis instanceof Array?this.axis.length>1?Xo(Rt(r,OM(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}_ne.className="Softmax";at(_ne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ab(n,e,t){if(typeof n=="number")return pg(n,e);if(n.length!==e)throw new xe(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const s=n[r];if(!ZJe(s))throw new xe(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function yu(n,e,t,r,s=1){if(n==null)return n;const i=e+(e-1)*(s-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+r-1)/r)}function lh(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+op([t-e,0]);else if(r==="same")n=n*e;else throw new xe(`Unsupport padding mode: ${r}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function h4(n,e){return Se(()=>(ei(e),e==="channelsFirst"?nr(n,[0,2,3,1]):n))}function Cne(n,e){return Se(()=>(ei(e),e==="channelsFirst"?nr(n,[0,2,3,4,1]):n))}function Tnt(n,e,t,r=1,s="valid",i,o=1){return Se(()=>{if(i==null&&(i=ku()),ei(i),n.shape.length!==3)throw new xe(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new xe(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new xe(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=nr(n,[0,2,1])),s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=XL(n,e,r,s==="same"?"same":"valid","NWC",o);return t!=null&&(a=Vu(a,t)),a})}function x6(n,e,t,r=[1,1],s="valid",i,o,a=null){return Se(()=>{if(i==null&&(i=ku()),ei(i),n.rank!==3&&n.rank!==4)throw new xe(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new xe(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=h4(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=KK({x:l,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(l=nr(l,[0,3,1,2])),l})}function Ent(n,e,t,r=[1,1,1],s="valid",i,o){return Se(()=>{if(i==null&&(i=ku()),ei(i),n.rank!==4&&n.rank!==5)throw new xe(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new xe(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Cne(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=ZL(a,e,r,s==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Vu(a,t)),i==="channelsFirst"&&(a=nr(a,[0,4,1,2,3])),a})}class o$ extends Kn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",o$.verifyArgs(t),this.rank=e,Ui(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Fn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ab(t.kernelSize,e,"kernelSize"),this.strides=Ab(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Vl(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ei(this.dataFormat),this.activation=lp(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=ys(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ei(t.biasConstraint),this.biasRegularizer=ws(t.biasRegularizer),this.activityRegularizer=ws(t.activityRegularizer),this.dilationRate=Ab(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new xe(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new xe(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new xe(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ah("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!ZB(e.kernelSize,"number",1,3))throw new xe(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ap(this.activation),useBias:this.useBias,biasInitializer:ks(this.biasInitializer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),biasConstraint:Ti(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class qw extends o${constructor(e,t){super(e,t),this.kernel=null,qw.verifyArgs(t),this.filters=t.filters,Ui(this.filters,"filters"),this.kernelInitializer=ys(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ei(t.kernelConstraint),this.kernelRegularizer=ws(t.kernelRegularizer)}build(e){e=vr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new xe(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return Se(()=>{e=bn(e);let r;const s=this.bias==null?null:this.bias.read(),i=wte(this.activation.getClassName());if(i!=null&&this.rank===2)r=x6(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)r=Tnt(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=x6(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Ent(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Fn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=vr(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<r.length;++i){const o=yu(r[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:ks(this.kernelInitializer),kernelRegularizer:jr(this.kernelRegularizer),kernelConstraint:Ti(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new xe(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class TC extends qw{constructor(e){super(2,e),TC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!ZB(e.kernelSize,"number",1,2))throw new xe(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}TC.className="Conv2D";at(TC);class EC extends qw{constructor(e){super(3,e),EC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new xe(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}EC.className="Conv3D";at(EC);class kne extends TC{constructor(e){if(super(e),this.inputSpec=[new Ci({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new xe(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=vr(e),e.length!==4)throw new xe("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new xe("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ci({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=bn(e);if(r.shape.length!==4)throw new xe(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=s[o],c=s[a],u=this.kernelSize[0],h=this.kernelSize[1],f=this.strides[0],d=this.strides[1],p=lh(l,f,u,this.padding),m=lh(c,d,h,this.padding),g=[i,p,m,this.filters];this.dataFormat!=="channelsLast"&&(r=nr(r,[0,2,3,1]));let y=YL(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=nr(y,[0,3,1,2])),this.bias!=null&&(y=Vu(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=vr(e);const t=e.slice();let r,s,i;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3):(r=3,s=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[r]=this.filters,t[s]=lh(t[s],l,o,this.padding),t[i]=lh(t[i],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}kne.className="Conv2DTranspose";at(kne);class Tne extends EC{constructor(e){if(super(e),this.inputSpec=[new Ci({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new xe(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=vr(e),e.length!==5)throw new xe("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new xe("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ci({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=bn(e);if(r.shape.length!==5)throw new xe(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=s[l],u=s[o],h=s[a],f=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=lh(c,m,f,this.padding),x=lh(u,g,d,this.padding),w=lh(h,y,p,this.padding),_=[i,b,x,w,this.filters];this.dataFormat!=="channelsLast"&&(r=nr(r,[0,2,3,4,1]));let C=JL(r,this.kernel.read(),_,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(C=nr(C,[0,4,1,2,3])),this.bias!==null&&(C=Vu(C,this.bias.read(),this.dataFormat)),this.activation!==null&&(C=this.activation.apply(C)),C})}computeOutputShape(e){e=vr(e);const t=e.slice();let r,s,i,o;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3,o=4):(r=4,s=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],f=this.strides[2];return t[r]=this.filters,t[s]=lh(t[s],u,a,this.padding),t[i]=lh(t[i],h,l,this.padding),t[o]=lh(t[o],f,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Tne.className="Conv3DTranspose";at(Tne);class Ene extends qw{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new xe("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new xe("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new xe(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ys(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ws(t.depthwiseRegularizer),this.depthwiseConstraint=Ei(t.depthwiseConstraint),this.pointwiseInitializer=ys(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ws(t.pointwiseRegularizer),this.pointwiseConstraint=Ei(t.pointwiseConstraint)}build(e){if(e=vr(e),e.length<this.rank+2)throw new xe(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new xe(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],s=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Ci({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{e=bn(e);let r;if(this.rank===1)throw new Fn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=nr(e,[0,2,3,1])),r=vz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Vu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=nr(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ks(this.depthwiseInitializer),e.pointwiseInitializer=ks(this.pointwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.pointwiseRegularizer=jr(this.pointwiseRegularizer),e.depthwiseConstraint=Ti(this.depthwiseConstraint),e.pointwiseConstraint=Ti(this.pointwiseConstraint),e}}Ene.className="SeparableConv";class Ine extends Ene{constructor(e){super(2,e)}}Ine.className="SeparableConv2D";at(Ine);class a$ extends qw{constructor(e){super(1,e),a$.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!ZB(e.kernelSize,"number",1,1))throw new xe(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}a$.className="Conv1D";at(a$);class Ane extends Kn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Se(()=>{if(e=bn(e),this.dataFormat==="channelsLast"){const r=oT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return oT(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=oT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return oT(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Ane.className="Cropping2D";at(Ane);class Mne extends Kn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ei(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,XJe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return Se(()=>{let r=bn(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=nr(r,[0,2,3,1]);const i=this.size[0]*s[2],o=this.size[1]*s[3],a=this.interpolation==="nearest"?Si.resizeNearestNeighbor(r,[i,o]):Si.resizeBilinear(r,[i,o]);return nr(a,[0,3,1,2])}else{const i=this.size[0]*s[1],o=this.size[1]*s[2];return this.interpolation==="nearest"?Si.resizeNearestNeighbor(r,[i,o]):Si.resizeBilinear(r,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Mne.className="UpSampling2D";at(Mne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Int(n,e,t=[1,1],r="valid",s,i){return Se(()=>{s==null&&(s=ku()),ei(s);let o=h4(n,s);if(n.rank!==4)throw new xe(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new xe(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=j2(o,e,t,r==="same"?"same":"valid","NHWC",i),s==="channelsFirst"&&(o=nr(o,[0,3,1,2])),o})}class Nne extends o${constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ys(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ei(e.depthwiseConstraint),this.depthwiseRegularizer=ws(e.depthwiseRegularizer)}build(e){if(e=vr(e),e.length<4)throw new xe(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new xe(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{e=bn(e);let r=Int(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Vu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=vr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=yu(t,this.kernelSize[0],this.padding,this.strides[0]),o=yu(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,o]:[e[0],i,o,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ks(this.depthwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.depthwiseConstraint=Ti(this.depthwiseRegularizer),e}}Nne.className="DepthwiseConv2D";at(Nne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $ne(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new xe("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function s(i){return i==null||Array.isArray(i)?i:[i]}return e=s(e),t=s(t),{inputs:n,initialState:e,constants:t}}function Rne(n,e,t,r=!1,s,i,o=!1,a=!1){return Se(()=>{const l=e.shape.length;if(l<3)throw new xe(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Cu(2,l));if(e=nr(e,c),i!=null)throw new Fn("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=xt(xt(s,"bool"),"float32"),s.rank===l-1&&(s=ii(s,-1)),s=nr(s,c)),r&&(e=Ec(e,0),s!=null&&(s=Ec(s,0)));const u=[];let h,f=t;const d=e.shape[0],p=Ic(e);let m;s!=null&&(m=Ic(s));for(let y=0;y<d;++y){const b=p[y],x=Se(()=>n(b,f));if(s==null)h=x[0],f=x[1];else{const w=Se(()=>{const _=m[y],C=Rt(Rl(_),_),k=qe(fe(x[0],_),fe(f[0],C)),A=f.map((M,I)=>qe(fe(x[1][I],_),fe(M,C)));return{output:k,newStates:A}});h=w.output,f=w.newStates}a&&u.push(h)}let g;return a&&(g=wa(u,1)),[h,g,f]})}class Rp extends Kn{constructor(e){super(e);let t;if(e.cell==null)throw new xe("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new p4({cells:e.cell}):t=e.cell,t.stateSize==null)throw new xe("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ci({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Cu(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){zO(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let s;if(this.returnSequences?s=[e[0],e[1],r]:s=[e[0],r],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[s].concat(i)}else return s}computeMask(e,t){return Se(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const s=this.states.map(i=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Fn("Constants support is not implemented in RNN yet.");zO(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Ci({shape:[t,null,...r]});const s=[e[0]].concat(e.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Mn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new xe(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new Ci({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new oh("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new xe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ms([r,s])):this.states_=[ms([r,this.cell.stateSize])];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ms([r,s])):this.states_[0]=ms([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new xe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let s=0;s<this.states_.length;++s){const i=e[s],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,a=[r,o];if(!Mn(i.shape,a))throw new xe(`State ${s} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>qs(s.clone()))})}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=$ne(e,r,s,this.numConstants);e=i.inputs,r=i.initialState,s=i.constants;let o=[],a=[];if(r!=null){t.initialState=r,o=o.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new Ci({shape:c.shape}));a=a.concat(this.stateSpec)}if(s!=null&&(t.constants=s,o=o.concat(s),this.numConstants=s.length),o[0]instanceof kh){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t==null?null:t.mask,s=t==null?null:t.training;let i=t==null?null:t.initialState;e=bn(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new xe(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},c=Rne((p,m)=>{const g=this.cell.call([p].concat(m),a);return[g[0],g.slice(1)]},e,i,this.goBackwards,r,null,this.unroll,this.returnSequences),u=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,s);const d=this.returnSequences?h:u;return this.returnState?[d].concat(f):d})}getInitialState(e){return Se(()=>{let t=ms(e.shape);return t=Yt(t,[1,2]),t=xC(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?FO(t,[1,r]):t):this.cell.stateSize>1?[FO(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===Rp.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){const s=t.cell,i=bh(s,r);return new e(Object.assign(t,{cell:i}))}}Rp.className="RNN";at(Rp);class l$ extends Kn{}class f4 extends l${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ui(this.units,"units"),this.activation=lp(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ws(e.kernelRegularizer),this.recurrentRegularizer=ws(e.recurrentRegularizer),this.biasRegularizer=ws(e.biasRegularizer),this.kernelConstraint=Ei(e.kernelConstraint),this.recurrentConstraint=Ei(e.recurrentConstraint),this.biasConstraint=Ei(e.biasConstraint),this.dropout=tv([1,op([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=tv([1,op([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=vr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new xe(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=yh(fe(e,o),this.kernel.read()):i=yh(e,this.kernel.read()),this.bias!=null&&(i=Vu(i,this.bias.read())),a!=null&&(r=fe(r,a));let l=qe(i,yh(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ap(this.activation),useBias:this.useBias,kernelInitializer:ks(this.kernelInitializer),recurrentInitializer:ks(this.recurrentInitializer),biasInitializer:ks(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ti(this.kernelConstraint),recurrentConstraint:Ti(this.recurrentConstraint),biasConstraint:Ti(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}f4.className="SimpleRNNCell";at(f4);class Pne extends Rp{constructor(e){e.cell=new f4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return new e(t)}}Pne.className="SimpleRNN";at(Pne);class d4 extends l${constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new xe("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ui(this.units,"units"),this.activation=lp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=lp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ws(e.kernelRegularizer),this.recurrentRegularizer=ws(e.recurrentRegularizer),this.biasRegularizer=ws(e.biasRegularizer),this.kernelConstraint=Ei(e.kernelConstraint),this.recurrentConstraint=Ei(e.recurrentConstraint),this.biasConstraint=Ei(e.biasConstraint),this.dropout=tv([1,op([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=tv([1,op([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=vr(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new xe(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=fe(e,i[0]));let u=yh(e,this.kernel.read());this.useBias&&(u=Vu(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,o[0]));const h=this.recurrentKernel.read(),[f,d]=Wa(h,[2*this.units,this.units],h.rank-1),p=yh(s,f),[m,g,y]=Wa(u,3,u.rank-1),[b,x]=Wa(p,2,p.rank-1);a=this.recurrentActivation.apply(qe(m,b)),l=this.recurrentActivation.apply(qe(g,x));const w=yh(fe(l,s),d);c=this.activation.apply(qe(y,w));const _=qe(fe(a,s),fe(qe(1,us(a)),c));return[_,_]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ap(this.activation),recurrentActivation:ap(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ks(this.kernelInitializer),recurrentInitializer:ks(this.recurrentInitializer),biasInitializer:ks(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ti(this.kernelConstraint),recurrentConstraint:Ti(this.recurrentConstraint),biasConstraint:Ti(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}d4.className="GRUCell";at(d4);class Dne extends Rp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new d4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Dne.className="GRU";at(Dne);class c$ extends l${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ui(this.units,"units"),this.activation=lp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=lp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ws(e.kernelRegularizer),this.recurrentRegularizer=ws(e.recurrentRegularizer),this.biasRegularizer=ws(e.biasRegularizer),this.kernelConstraint=Ei(e.kernelConstraint),this.recurrentConstraint=Ei(e.recurrentConstraint),this.biasConstraint=Ei(e.biasConstraint),this.dropout=tv([1,op([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=tv([1,op([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=vr(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;s=new(t=class extends Oc{apply(l,c){const u=i.apply([o]),h=new QB().apply([o]),f=i.apply([o*2]);return JH(JH(u,h),f)}},t.className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new xe(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=fe(e,o[0]));let f=yh(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,a[0])),f=qe(f,yh(s,this.recurrentKernel.read())),this.useBias&&(f=Vu(f,this.bias.read()));const[d,p,m,g]=Wa(f,4,f.rank-1);l=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),u=qe(fe(c,i),fe(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=fe(h,this.activation.apply(u));return[y,y,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:ap(this.activation),recurrentActivation:ap(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ks(this.kernelInitializer),recurrentInitializer:ks(this.recurrentInitializer),biasInitializer:ks(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ti(this.kernelConstraint),recurrentConstraint:Ti(this.recurrentConstraint),biasConstraint:Ti(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}c$.className="LSTMCell";at(c$);class One extends Rp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new c$(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}One.className="LSTM";at(One);class p4 extends l${constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Se(()=>{e=e;let r=e.slice(1);const s=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?s.push(r.splice(0,a.stateSize.length)):s.push(r.splice(0,1));s.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];r=s[a],a===0?o=[e[0]].concat(r):o=[o[0]].concat(r),o=l.call(o,t),i.push(o.slice(1))}r=[];for(const a of i.slice().reverse())r.push(...a);return[o[0]].concat(r)})}build(e){zO(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,s)=>{Gm(`RNNCell_${s}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,t,r={}){const s=[];for(const i of t.cells)s.push(bh(i,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return BO(e)}setWeights(e){const t=[];for(const r of this.cells){const s=r.weights.length,i=e.splice(s);for(let o=0;o<r.weights.length;++o)t.push([r.weights[o],i[o]])}o4(t)}}p4.className="StackedRNNCells";at(p4);function cp(n){const{ones:e,rate:t,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):Ete(e(),t),a=()=>_C(o,e,r);return!s||s<=1?qs(a().clone()):Array(s).fill(void 0).map(a).map(c=>qs(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Ant=globalThis&&globalThis.__rest||function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(n);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(t[r[s]]=n[r[s]]);return t};class Fne extends Rp{constructor(e){if(e.unroll)throw new Fn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Fn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ci({ndim:5})]}call(e,t){return Se(()=>{if(this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new xe("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Se(()=>{const{stateSize:t}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)],o=ms(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new oh("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)];if(r[0]==null)throw new xe("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ms(i)):this.states_=[ms(i)];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ms(i)):this.states_[0]=ms(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new xe(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=i;if(!Mn(l.shape,c))throw new xe(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>qs(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:s,padding:i,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=yu(c,s[0],i,o[0],a[0]),f=yu(u,s[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[r,h,f]:[h,f,r]]}}Fne.className="ConvRNN2D";class m4 extends c${constructor(e){const{filters:t,kernelSize:r,strides:s,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ui(this.filters,"filters"),this.kernelSize=Ab(r,2,"kernelSize"),this.kernelSize.forEach(l=>Ui(l,"kernelSize")),this.strides=Ab(s||1,2,"strides"),this.strides.forEach(l=>Ui(l,"strides")),this.padding=i||"valid",Vl(this.padding),this.dataFormat=o||"channelsLast",ei(this.dataFormat),this.dilationRate=Ab(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ui(l,"dilationRate"))}build(e){var t;e=vr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new xe(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],i=4,o=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends Oc{apply(f,d){const p=c.apply([u]),m=da([u]),g=c.apply([u*2]);return JB([p,m,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Se(()=>{if(e.length!==3)throw new xe(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,s=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=cp({ones:()=>Rl(s),rate:this.dropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(pe,oe,Ne)=>!oe||!oe[Ne]?pe:fe(oe[Ne],pe);let u=c(s,l,0),h=c(s,l,1),f=c(s,l,2),d=c(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=cp({ones:()=>Rl(i),rate:this.recurrentDropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let m=c(i,p,0),g=c(i,p,1),y=c(i,p,2),b=c(i,p,3);const x=3,[w,_,C,k]=Wa(this.kernel.read(),a,x),[A,M,I,N]=this.useBias?Wa(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,w,A,this.padding),h=this.inputConv(h,_,M,this.padding),f=this.inputConv(f,C,I,this.padding),d=this.inputConv(d,k,N,this.padding);const[O,R,D,z]=Wa(this.recurrentKernel.read(),a,x);m=this.recurrentConv(m,O),g=this.recurrentConv(g,R),y=this.recurrentConv(y,D),b=this.recurrentConv(b,z);const B=this.recurrentActivation.apply(qe(u,m)),X=this.recurrentActivation.apply(qe(h,g)),G=qe(fe(X,o),fe(B,this.activation.apply(qe(f,y)))),ee=fe(this.recurrentActivation.apply(qe(d,b)),this.activation.apply(G));return[ee,ee,G]})}getConfig(){const e=super.getConfig(),t=Ant(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),r)}inputConv(e,t,r,s){const i=tp(e,t,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Vu(i,r,this.dataFormat):i}recurrentConv(e,t){return tp(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}m4.className="ConvLSTM2DCell";at(m4);class Lne extends Fne{constructor(e){const t=new m4(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}Lne.className="ConvLSTM2D";at(Lne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class g4 extends Kn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?t[s]:this.noiseShape[s]);return r}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e);if(0<this.rate&&this.rate<1){const s=t.training==null?!1:t.training,i=this.getNoiseShape(r);return _C(()=>Ete(r,this.rate,i,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}g4.className="Dropout";at(g4);class zne extends g4{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}zne.className="SpatialDropout1D";at(zne);class y4 extends Kn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ui(this.units,"units"),this.activation=lp(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ei(e.kernelConstraint),this.biasConstraint=Ei(e.biasConstraint),this.kernelRegularizer=ws(e.kernelRegularizer),this.biasRegularizer=ws(e.biasRegularizer),this.activityRegularizer=ws(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=vr(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=vr(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e),s=wte(this.activation.getClassName());let i;return s!=null?i=yh(r,this.kernel.read(),s,this.bias?this.bias.read():null):(i=yh(r,this.kernel.read()),this.bias!=null&&(i=Vu(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:ap(this.activation),useBias:this.useBias,kernelInitializer:ks(this.kernelInitializer),biasInitializer:ks(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ti(this.kernelConstraint),biasConstraint:Ti(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}y4.className="Dense";at(y4);class Bne extends Kn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=vr(e);for(const t of e.slice(1))if(t==null)throw new xe(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Wd(e,1)]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=bn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let i=2;i<r.rank;++i)s.push(i);s.push(1),r=nr(r,s)}return eQe(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}Bne.className="Flatten";at(Bne);class Vne extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.activation=lp(e.activation)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e);return this.activation.apply(r)})}getConfig(){const e={activation:ap(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}Vne.className="Activation";at(Vne);class Une extends Kn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Se(()=>(e=bn(e),JJe(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}Une.className="RepeatVector";at(Une);let Wne=class extends Kn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",s=t.slice();let i=1,o=null;for(let l=0;l<s.length;++l){const c=s[l];if(this.isUnknown(c))if(o===null)o=l;else throw new xe("Can only specifiy one unknown dimension.");else i*=c}const a=Wd(e);if(o!==null){if(i===0||a%i!==0)throw new xe(r);s[o]=a/i}else if(a!==i)throw new xe(r);return s}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e),s=r.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return ve(r,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Wne.className="Reshape";at(Wne);class Gne extends Kn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Cu(1,e.dims.length+1);if(!Mn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ci({ndim:this.dims.length+1})]}computeOutputShape(e){e=vr(e);const t=e.slice();return this.dims.forEach((r,s)=>{t[s+1]=e[r]}),t}call(e,t){return nr(bn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}Gne.className="Permute";at(Gne);class Hne extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=bn(e),s=-1;return xI(Gb(r,this.maskValue),s)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e),s=-1,i=!0,o=xI(Gb(r,this.maskValue),s,i);return fe(r,xt(o,r.dtype))})}}Hne.className="Masking";at(Hne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jne extends Kn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Gr(e.inputLength))}this.inputDim=e.inputDim,Ui(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ui(this.outputDim,"outputDim"),this.embeddingsInitializer=ys(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ws(e.embeddingsRegularizer),this.activityRegularizer=ws(e.activityRegularizer),this.embeddingsConstraint=Ei(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Se(()=>this.maskZero?(e=bn(e),Gb(e,ar(e))):null)}computeOutputShape(e){if(e=vr(e),this.inputLength==null)return[...e,this.outputDim];const t=Gr(this.inputLength);if(t.length!==e.length-1)throw new xe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<t.length;++s){const i=t[s],o=e[s+1];if(i!=null&&o!=null&&i!==o)throw new xe(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[r]=o),r++}}return[e[0],...t,this.outputDim]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=bn(e);r.dtype!=="int32"&&(r=gh(r,"int32"));const s=Tte(this.embeddings.read(),ve(r,[r.size]));return ve(s,vr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ks(this.embeddingsInitializer),embeddingsRegularizer:jr(this.embeddingsRegularizer),activityRegularizer:jr(this.activityRegularizer),embeddingsConstraint:Ti(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}jne.className="Embedding";at(jne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class qy extends Kn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Fn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const i=e[e.length-t.length+s],o=t[s];if(i==null||o==null||i<0||o<0)r.push(null);else if(i===1)r.push(o);else if(o===1)r.push(i);else{if(i!==o)throw new xe("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(i)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[vr(e)]),e=e,e.length<2)throw new xe(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Ud(t),t.length>1)throw new xe(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=e.map(i=>i.length);e.indexOf(null)===-1&&Ud(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Se(()=>{if(e=e,this.reshapeRequired){const r=[],s=e.map(i=>i.rank);if(s.indexOf(null)===-1){const i=op(s);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=xC(o,1);r.push(o)}return this.mergeFunction(r)}else{let i=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],f=u.slice(1).concat([h]);let d=ve(l,[h].concat(Wd(u.slice(1))));d=nr(d,[1,0]),d=ve(d,f),r.push(d),i=!0}else if(c>1){const u=Cu(1,c).concat([0]);r.push(nr(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=ve(nr(ve(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Cu(0,a-1));o=nr(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let s=1;s<e.length;++s){const i=e[s]==null?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=Ud(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return Se(()=>{if(t==null)return null;if(!Array.isArray(t))throw new xe("`mask` should be an Array");if(!Array.isArray(e))throw new xe("`inputs` should be an Array");if(t.length!==e.length)throw new xe(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(s=>s==null))return null;t=t.map(s=>s==null?s:ii(s,0));let r=t[0];for(let s=1;s<t.length-1;++s)r=Sh(r,t[s]);return r})}}let qne=class extends qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=qe(t,e[r]);return t})}};qne.className="Add";at(qne);let Xne=class extends qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=fe(t,e[r]);return t})}};Xne.className="Multiply";at(Xne);class Kne extends qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=qe(t,e[r]);return fe(1/e.length,t)})}}Kne.className="Average";at(Kne);class Yne extends qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Wf(t,e[r]);return t})}}Yne.className="Maximum";at(Yne);class Zne extends qy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=rp(t,e[r]);return t})}}Zne.className="Minimum";at(Zne);class Jne extends qy{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new xe("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const s of e)if(s!=null){t=!1;break}if(t)return;const r=[];for(let s=0;s<e.length;++s){const i=e[s].slice();i.splice(this.axis,1);let o=!1;for(const a of r)if(Mn(a,i)){o=!0;break}o||r.push(i)}if(r.length>1)throw new xe("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Se(()=>JB(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new xe("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const i of t.slice(1)){if(r[s]==null||i[s]==null){r[s]=null;break}r[s]+=i[s]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new xe("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new xe("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new xe(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Se(()=>{let r=!0;if(t.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const s=[];for(let o=0;o<e.length;++o)t[o]==null?s.push(xt(Rl(e[o]),"bool")):t[o].rank<e[o].rank?s.push(ii(t[o],-1)):s.push(t[o]);const i=cs(s,this.axis);return FL(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}Jne.className="Concatenate";at(Jne);function Wx(n,e){for(;n<0;)n+=e;return n}function Mnt(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Fn("batchDot is not implemented for tensors of 4D or higher rank yet");if(U(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),U(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Fn("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=e.shape.length;t==null&&(t=[r-1,s-2]);const i=t;return Se(()=>{let o;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);e=ve(e,e.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=ve(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=Yt(fe(n,e),i[0]):a=Yt(fe(nr(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===e.shape.length-1;a=jn(n,e,l,c)}if(o>0){let l;r>s?l=r+s-3:l=r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=gr(a,c)}return a.shape.length===1&&(a=ii(a,1)),a})}class Qne extends qy{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);if(t[s[0]]!==r[s[1]])throw new xe(`Dimension incompatibility: ${t[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new xe(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,o)=>Wx(i,e[o].shape.length)):s=[Wx(this.axes,t.shape.length),Wx(this.axes,r.shape.length)],this.normalize&&(t=ZI(t,s[0]),r=ZI(r,s[1])),Mnt(t,r,s)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[Wx(this.axes,e.length),Wx(this.axes,t.length)],r}computeOutputShape(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);t.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const i=t.concat(r);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}Qne.className="Dot";at(Qne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ere extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e);return _C(()=>qe(n$(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}ere.className="GaussianNoise";at(ere);class tre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=bn(e);return this.rate>0&&this.rate<1?_C(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return fe(r,n$(r.shape,1,i))},()=>r,t.training||!1):r})}}tre.className="GaussianDropout";at(tre);class nre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||bn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return _C(()=>{const i=bn(e),o=1.6732632423543772,a=1.0507009873554805,l=-o*a;let c=Tp(Ep(r),this.rate);c=gh(c,"float32");const u=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-u*l*this.rate,f=qe(fe(i,c),fe(qe(c,-1),l));return qe(fe(f,u),h)},()=>bn(e),t.training||!1)}return e})}}nre.className="AlphaDropout";at(nre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function HS(n,e,t,r,s,i=.001){let o;if(n.rank===2)o=BL(n,e,t,r,s,i);else if(n.rank===3)o=VL(n,e,t,r,s,i);else if(n.rank===4)o=UL(n,e,t,r,s,i);else throw new Fn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function Nnt(n,e,t,r,s=.001){return Se(()=>{const i=Z2(n,r),o=i.mean,a=i.variance;return[HS(n,o,a,t,e,s),o,a]})}function $nt(n,e,t,r,s=.001){return Se(()=>{const i=Z2(n,r),o=i.mean,a=i.variance,l=[];for(const p of Cu(0,n.rank))r.indexOf(p)!==-1?l.push(1):l.push(n.shape[p]);const c=ve(o,l),u=ve(a,l),h=e==null?null:ve(e,l),f=t==null?null:ve(t,l);return[HS(n,c,u,f,h,s),o,a]})}function Rnt(n,e,t,r,s=.001){return Mn(r.slice().sort(),Cu(0,n.rank-1))?Nnt(n,e,t,r,s):$nt(n,e,t,r,s)}class rre extends Kn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ys(e.betaInitializer||"zeros"),this.gammaInitializer=ys(e.gammaInitializer||"ones"),this.movingMeanInitializer=ys(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ys(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ei(e.betaConstraint),this.gammaConstraint=Ei(e.gammaConstraint),this.betaRegularizer=ws(e.betaRegularizer),this.gammaRegularizer=ws(e.gammaRegularizer)}build(e){e=vr(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new xe(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ci({ndim:e.length,axes:{[t]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training,s=bn(e),i=s.shape,o=i.length,a=Cu(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=pg(1,o);c[l]=i[l];const u=a.slice();u.sort();const h=!Mn(u,Cu(0,o).slice(0,o-1)),f=()=>{if(h){const b=ve(this.movingMean.read(),c),x=ve(this.movingVariance.read(),c),w=this.center?ve(this.beta.read(),c):null,_=this.scale?ve(this.gamma.read(),c):null;return HS(s,b,x,w,_,this.epsilon)}else return HS(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return f();const[d,p,m]=Rnt(s,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,x,w)=>{Se(()=>{const _=1-w,C=b.read(),k=fe(Rt(C,x),_);b.write(Rt(C,k))})};return(()=>{g(this.movingMean,p,this.momentum),g(this.movingVariance,m,this.momentum)})(),d})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ks(this.betaInitializer),gammaInitializer:ks(this.gammaInitializer),movingMeanInitializer:ks(this.movingMeanInitializer),movingVarianceInitializer:ks(this.movingVarianceInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer),betaConstraint:Ti(this.betaConstraint),gammaConstraint:Ti(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}rre.className="BatchNormalization";at(rre);class sre extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ys(e.betaInitializer||"zeros"),this.gammaInitializer=ys(e.gammaInitializer||"ones"),this.betaRegularizer=ws(e.betaRegularizer),this.gammaRegularizer=ws(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=vr(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ud(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,t){const r=bn(e),s=r.shape,i=s.length;return Se(()=>{let{mean:a,variance:l}=Z2(r,this.axis,!0);const c=pg(1,i);for(const m of this.axis)c[m]=s[m];const u=m=>m!=null&&m.shape.length!==i?ve(m,c):m;let h=this.scale?u(this.gamma.read()):null,f=this.center?u(this.beta.read()):null;const d=[],p=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(d.push(s[m]),p.push(1)):(d.push(1),p.push(s[m]));return a=gc(a,d),l=gc(l,d),h!=null&&(h=gc(h,p)),f!=null&&(f=gc(f,p)),HS(r,a,l,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ks(this.betaInitializer),gammaInitializer:ks(this.gammaInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}sre.className="LayerNormalization";at(sre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pnt(n,e,t){return Se(()=>{if(n.rank!==4)throw new xe(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new xe("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=ku()),t!=="channelsLast"&&t!=="channelsFirst")throw new xe(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],wu(n,r)})}class ire extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?ku():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new xe(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new xe(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new xe(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new Ci({ndim:4})]}computeOutputShape(e){e=vr(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return Se(()=>Pnt(bn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}ire.className="ZeroPadding2D";at(ire);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function u$(n,e,t,r,s,i){return Se(()=>{ei(s),Ste(i),Vl(r),t==null&&(t=[1,1]),r==null&&(r="valid"),s==null&&(s=ku()),i==null&&(i="max"),n=h4(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=zM(n,e,t,a):o=AM(n,e,t,a),s==="channelsFirst"&&(o=nr(o,[0,3,1,2])),o})}function ore(n,e,t,r,s,i){return Se(()=>{ei(s),Ste(i),Vl(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),s==null&&(s=ku()),i==null&&(i="max"),n=Cne(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=sz(n,e,t,a):o=zL(n,e,t,a),s==="channelsFirst"&&(o=nr(o,[0,4,1,2,3])),o})}class are extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new xe(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ui(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new xe(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ui(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Vl(this.padding),this.inputSpec=[new Ci({ndim:3})]}computeOutputShape(e){e=vr(e);const t=yu(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Se(()=>{this.invokeCallHook(e,t),e=xC(bn(e),2);const r=this.poolingFunction(bn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return gr(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class lre extends are{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ei(i),Vl(s),u$(e,t,r,s,i,"max")}}lre.className="MaxPooling1D";at(lre);class cre extends are{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ei(i),Vl(s),u$(e,t,r,s,i,"avg")}}cre.className="AveragePooling1D";at(cre);class ure extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new xe(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ui(this.poolSize,"poolSize"),Ui(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ei(this.dataFormat),Vl(this.padding),this.inputSpec=[new Ci({ndim:4})]}computeOutputShape(e){e=vr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=yu(t,this.poolSize[0],this.padding,this.strides[0]),r=yu(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(bn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class hre extends ure{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ei(i),Vl(s),u$(e,t,r,s,i,"max")}}hre.className="MaxPooling2D";at(hre);class fre extends ure{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ei(i),Vl(s),u$(e,t,r,s,i,"avg")}}fre.className="AveragePooling2D";at(fre);class dre extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new xe(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ui(this.poolSize,"poolSize"),Ui(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ei(this.dataFormat),Vl(this.padding),this.inputSpec=[new Ci({ndim:5})]}computeOutputShape(e){e=vr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=yu(t,this.poolSize[0],this.padding,this.strides[0]),r=yu(r,this.poolSize[1],this.padding,this.strides[1]),s=yu(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,s]:[e[0],t,r,s,e[4]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(bn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class pre extends dre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ei(i),Vl(s),ore(e,t,r,s,i,"max")}}pre.className="MaxPooling3D";at(pre);class mre extends dre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ei(i),Vl(s),ore(e,t,r,s,i,"avg")}}mre.className="AveragePooling3D";at(mre);class gre extends Kn{constructor(e){super(e),this.inputSpec=[new Ci({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Fn}}class yre extends gre{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=bn(e);return Os(r,1)})}}yre.className="GlobalAveragePooling1D";at(yre);class bre extends gre{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=bn(e);return Sc(r,1)})}}bre.className="GlobalMaxPooling1D";at(bre);class vre extends Kn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ei(this.dataFormat),this.inputSpec=[new Ci({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Fn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class wre extends vre{call(e,t){return Se(()=>{const r=bn(e);return this.dataFormat==="channelsLast"?Os(r,[1,2]):Os(r,[2,3])})}}wre.className="GlobalAveragePooling2D";at(wre);class xre extends vre{call(e,t){return Se(()=>{const r=bn(e);return this.dataFormat==="channelsLast"?Sc(r,[1,2]):Sc(r,[2,3])})}}xre.className="GlobalMaxPooling2D";at(xre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Sre extends Kn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const s=t.layer,i=bh(s,r);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class _re extends Sre{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=vr(e),e.length<3)throw new xe(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=vr(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,t){return Se(()=>(e=bn(e),Rne((o,a)=>[bn(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}_re.className="TimeDistributed";at(_re);function Dnt(n){jy(qJe,"BidirectionalMergeMode",n)}const Ont="concat";class Cre extends Sre{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=bh(r),t.goBackwards=t.goBackwards!==!0;const s={};if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=bh(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Ont:e.mergeMode,Dnt(this.mergeMode),e.weights)throw new Fn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,s,i;return this.returnState&&(i=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[r].concat(i).concat(i.slice()):ha(s)}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=$ne(e,r,s,this.numConstants);if(e=i.inputs,r=i.initialState,s=i.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,t);const o=[],a=[];if(r!=null){const c=r.length;if(c%2>0)throw new xe("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,o.push(...r);const u=r.map(h=>new Ci({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(s!=null)throw new Fn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof kh;for(const c of o)if(c instanceof kh!==l)throw new xe("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t.initialState;let s,i;if(r==null)s=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=r.slice(0,r.length/2),c=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(s)&&(o=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=Ec(i,1));let a;return this.mergeMode==="concat"?a=JB([s,i]):this.mergeMode==="sum"?a=qe(s,i):this.mergeMode==="ave"?a=fe(.5,qe(s,i)):this.mergeMode==="mul"?a=fe(s,i):this.mergeMode==null&&(a=[s,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Gm(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Gm(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(i).concat(i):[r].concat(i).concat(i)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=bh(t.layer);if(delete t.layer,t.numConstants!=null)throw new Fn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=r,new e(s)}}Cre.className="Bidirectional";at(Cre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class kre extends Kn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>(e=bn(e),e.dtype!=="float32"&&(e=gh(e,"float32")),qe(fe(e,this.scale),this.offset)))}}kre.className="Rescaling";at(kre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:Fnt,cropAndResize:Lnt}=Si;class Tre extends Kn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,s,i,o,a,l){return Se(()=>{let c,u=!1;const h=t/o,f=r/a,d=(s+t)/o,p=(i+r)/a,m=[h,f,d,p],g=[];e.rank===3?(u=!0,c=wa([e])):c=e;for(let _=0;_<c.shape[0];_++)g.push(m);const y=ki(g,[g.length,4]),b=og(0,g.length,1,"int32"),w=Lnt(c,y,b,[s,i],"nearest");return gh(u?bn(Ic(w)):w,l)})}upsize(e,t,r,s){return Se(()=>{const i=Fnt(e,[t,r]);return gh(i,s)})}call(e,t){return Se(()=>{const r=bn(e),s=r.dtype,i=r.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(r,l,c,this.height,this.width,o,a,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=vr(e);const t=e.length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}Tre.className="CenterCrop";at(Tre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function znt(n,e,t,r){let s=bn(n);if(s.dtype!=="int32"&&(s=gh(s,"int32")),e==="int")return s;const i=s.shape;if(s.rank===0&&(s=ii(s,-1)),e==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=ii(s,-1)),s.rank>2)throw new xe(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(e),a=s;let l;if(typeof r<"u"&&e==="count"?l=_I(a,r,t,o):l=_I(a,[],t,o),e!=="tfIdf")return l;if(r)return fe(l,r);throw new xe("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ere extends Kn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=vr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Se(()=>{e=bn(e),e.dtype!=="int32"&&(e=gh(e,"int32"));let r;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new xe(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=bn(t.countWeights)}const s=Sc(e),i=vS(e),o=el(this.numTokens,s).bufferSync().get(0),a=Tp(i,0).bufferSync().get(0);if(!(o&&a))throw new xe(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return znt(e,this.outputMode,this.numTokens,r)})}}Ere.className="CategoryEncoding";at(Ere);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Bnt=["bilinear","nearest"],S6=new Set(Bnt);class Ire extends Kn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(S6.has(e.interpolation))this.interpolation=e.interpolation;else throw new xe(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=vr(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return Si.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Si.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...S6]} are supported`)})}}Ire.className="Resizing";at(Ire);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Are{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}Are.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Mre extends Kn{constructor(e){super(e),this.randomGenerator=new Are(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}Mre.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Vnt=["bilinear","nearest"],_6=new Set(Vnt);class Nre extends Mre{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new xe(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new xe(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new xe(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(_6.has(r))this.interpolation=r;else throw new xe(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=vr(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return Se(()=>{const r=bn(e);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=Ep([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Si.resizeBilinear(e,o);case"nearest":return Si.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[..._6]} are supported`)}})}}Nre.className="RandomWidth";at(Nre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function C6(n){return new y4(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Unt(n,e){return $re(n,e)}function $re(n,e,t=new Map,r=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const s=e(n);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(h$(n)){const i=Array.isArray(n)?[]:{};r.add(n);for(const o in n){const a=n[o],l=$re(a,e,t,r);i[o]=l}return r.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,s.value),s.value}function Wnt(n,e=Pre){return Rre(n,e)}function Rre(n,e,t=new Set){const r=n[0];if(t.has(r))throw new Error("Circular references are not supported.");const s=e(n);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(h$(r)){const i=Array.isArray(r)?[]:{};t.add(r);for(const o in r){const a=n.map(c=>c[o]),l=Rre(a,e,t);i[o]=l}return t.delete(r),i}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function Pre(n){return n===null?null:h$(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}function h$(n){let e=!1;if(Ee().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof qn)&&!(n instanceof Promise)&&!e)}function Gnt(n){return n==null||Hnt(n)||Array.isArray(n)||typeof n=="object"&&n instanceof qn||wi(n)}function Hnt(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function jnt(n){return Unt(n,qnt)}function qnt(n){return n instanceof qn?{value:n.clone(),recurse:!1}:h$(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Dre{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),r=this.get(t);return this.set(t,this.pop()),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class f$ extends Dre{constructor(){super(f$.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),r=this.length();for(let s=0;s<r;s++)t[s]=this.get(this.wrap(this.begin+s));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}f$.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Xnt(n){return new Ynt(n)}function Ore(n){return new Znt(n)}function Knt(n,e){return new Fre(n,e)}class Ul{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let r=await e.next();for(;!r.done;)t.push(r.value),r=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),r=e(t.value);for(;!t.done&&r;)t=await this.next(),r=e(t.value)}handleErrors(e){return new srt(this,e)}filter(e){return new nrt(this,e)}map(e){return new rrt(this,e)}mapAsync(e){return new k6(this,e)}serialMapAsync(e){return new k6(this,e).serial()}flatmap(e){return new art(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new trt(this,e,t)}columnMajorBatch(e,t=!0,r=Pre){return this.rowMajorBatch(e,t).map(i=>Wnt(i,r))}concatenate(e,t){return new Fre(Xnt([this,e]),t)}take(e){return e<0||e==null?this:new ert(this,e)}skip(e){return e<0||e==null?this:new Qnt(this,e)}prefetch(e){return new Lre(this,e)}shuffle(e,t){return new lrt(this,e,t)}serial(){return new Jnt(this)}}class Ynt extends Ul{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:jnt(e),done:!1}}}class Znt extends Ul{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class Jnt extends Ul{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class Qnt extends Ul{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;nn(e.value)}return this.upstream.next()}}class ert extends Ul{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class trt extends Ul{constructor(e,t,r=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class nrt extends Ul{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nn(e.value)}}}class rrt extends Ul{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Rf(e.value),r=this.transform(e.value),s=Rf(r);for(const i of t)EM(i,s)||i.dispose();return{value:r,done:!1}}}class srt extends Ul{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class k6 extends Ul{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Rf(e.value),r=await this.transform(e.value),s=Rf(r);for(const i of t)EM(i,s)||i.dispose();return{value:r,done:!1}}}class irt extends Ul{constructor(){super(),this.outputQueue=new f$,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class art extends irt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Rf(e.value),r=this.transform(e.value),s=Rf(r);this.outputQueue.pushAll(r);for(const i of t)EM(i,s)||i.dispose();return!0}}class Fre extends Ul{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var T6;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(T6||(T6={}));class Lre extends Ul{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Dre(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class lrt extends Lre{constructor(e,t,r){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Tw.alea(r||ro().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let zre=class{constructor(){this.size=null}batch(e,t=!0){const r=this;U(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let s;return this.size===1/0||this.size==null?s=this.size:t?s=Math.ceil(this.size/e):s=Math.floor(this.size/e),ru(async()=>(await r.iterator()).columnMajorBatch(e,t,crt),s)}concatenate(e){const t=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,ru(async()=>(await t.iterator()).concatenate(await e.iterator()),r)}filter(e){const t=this;let r;return this.size===1/0?r=1/0:r=null,ru(async()=>(await t.iterator()).filter(s=>Se(()=>e(s))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return ru(async()=>(await t.iterator()).map(r=>Se(()=>e(r))),this.size)}mapAsync(e){const t=this;return ru(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return ru(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,ru(async()=>{const s=Ore(async()=>({value:await t.iterator(),done:!1}));return Knt(s.take(e))},r)}skip(e){const t=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,ru(async()=>(await t.iterator()).skip(e),r)}shuffle(e,t,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,i=Tw.alea(t||ro().toString());return ru(async()=>{let o=i.int32();return r&&(o+=i.int32()),(await s.iterator()).shuffle(e,o.toString())},this.size)}take(e){const t=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,ru(async()=>(await t.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};zre.MAX_BUFFER_SIZE=1e4;function ru(n,e=null){return new class extends zre{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function crt(n){if(n===null)return null;const e=n[0];return Gnt(e)?{value:urt(n),recurse:!1}:{value:null,recurse:!0}}function urt(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof qn?wa(n):ki(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function hrt(n){return ru(async()=>{const e=await n();return Ore(()=>e.next())})}var HO={exports:{}};const frt=Vf(LJe),drt=Vf(KY);/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(n,e){(function(t,r){r(e,frt,drt)})(mt,function(t,r,s){const i={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(l,c){this.modelPath=c||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await r.loadGraphModel(this.modelPath);const l=s.zeros([1,300,300,3],"int32"),c=await this.model.executeAsync(l);await Promise.all(c.map(u=>u.data())),c.map(u=>u.dispose()),l.dispose()}async infer(l,c,u){const h=s.tidy(()=>(l instanceof s.Tensor||(l=s.browser.fromPixels(l)),s.expandDims(l))),f=h.shape[1],d=h.shape[2],p=await this.model.executeAsync(h),m=p[0].dataSync(),g=p[1].dataSync();h.dispose(),s.dispose(p);const[y,b]=this.calculateMaxScores(m,p[0].shape[1],p[0].shape[2]),x=s.getBackend();s.getBackend()==="webgl"&&s.setBackend("cpu");const w=s.tidy(()=>{const C=s.tensor2d(g,[p[1].shape[1],p[1].shape[3]]);return s.image.nonMaxSuppression(C,y,c,u,u)}),_=w.dataSync();return w.dispose(),x!==s.getBackend()&&s.setBackend(x),this.buildDetectedObjects(d,f,g,y,_,b)}buildDetectedObjects(l,c,u,h,f,d){const p=f.length,m=[];for(let g=0;g<p;g++){const y=[];for(let C=0;C<4;C++)y[C]=u[4*f[g]+C];const b=y[0]*c,x=y[1]*l,w=y[2]*c,_=y[3]*l;y[0]=x,y[1]=b,y[2]=_-x,y[3]=w-b,m.push({bbox:y,class:i[d[f[g]]+1].displayName,score:h[f[g]]})}return m}calculateMaxScores(l,c,u){const h=[],f=[];for(let d=0;d<c;d++){let p=Number.MIN_VALUE,m=-1;for(let g=0;g<u;g++)l[d*u+g]>p&&(p=l[d*u+g],m=g);h[d]=p,f[d]=m}return[h,f]}async detect(l,c=20,u=.5){return this.infer(l,c,u)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=o,t.load=async function(a={}){if(s==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=a.base||"lite_mobilenet_v2",c=a.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const u=new o(l,c);return await u.load(),u},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})})})(HO,HO.exports);var E6=HO.exports;/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function IC(n){return n+.5|0}const Rd=(n,e,t)=>Math.max(Math.min(n,t),e);function k1(n){return Rd(IC(n*2.55),0,255)}function Hd(n){return Rd(IC(n*255),0,255)}function vf(n){return Rd(IC(n/2.55)/100,0,1)}function I6(n){return Rd(IC(n*100),0,100)}const tc={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},jO=[..."0123456789ABCDEF"],prt=n=>jO[n&15],mrt=n=>jO[(n&240)>>4]+jO[n&15],lT=n=>(n&240)>>4===(n&15),grt=n=>lT(n.r)&&lT(n.g)&&lT(n.b)&&lT(n.a);function yrt(n){var e=n.length,t;return n[0]==="#"&&(e===4||e===5?t={r:255&tc[n[1]]*17,g:255&tc[n[2]]*17,b:255&tc[n[3]]*17,a:e===5?tc[n[4]]*17:255}:(e===7||e===9)&&(t={r:tc[n[1]]<<4|tc[n[2]],g:tc[n[3]]<<4|tc[n[4]],b:tc[n[5]]<<4|tc[n[6]],a:e===9?tc[n[7]]<<4|tc[n[8]]:255})),t}const brt=(n,e)=>n<255?e(n):"";function vrt(n){var e=grt(n)?prt:mrt;return n?"#"+e(n.r)+e(n.g)+e(n.b)+brt(n.a,e):void 0}const wrt=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function Bre(n,e,t){const r=e*Math.min(t,1-t),s=(i,o=(i+n/30)%12)=>t-r*Math.max(Math.min(o-3,9-o,1),-1);return[s(0),s(8),s(4)]}function xrt(n,e,t){const r=(s,i=(s+n/60)%6)=>t-t*e*Math.max(Math.min(i,4-i,1),0);return[r(5),r(3),r(1)]}function Srt(n,e,t){const r=Bre(n,1,.5);let s;for(e+t>1&&(s=1/(e+t),e*=s,t*=s),s=0;s<3;s++)r[s]*=1-e-t,r[s]+=e;return r}function _rt(n,e,t,r,s){return n===s?(e-t)/r+(e<t?6:0):e===s?(t-n)/r+2:(n-e)/r+4}function b4(n){const t=n.r/255,r=n.g/255,s=n.b/255,i=Math.max(t,r,s),o=Math.min(t,r,s),a=(i+o)/2;let l,c,u;return i!==o&&(u=i-o,c=a>.5?u/(2-i-o):u/(i+o),l=_rt(t,r,s,u,i),l=l*60+.5),[l|0,c||0,a]}function v4(n,e,t,r){return(Array.isArray(e)?n(e[0],e[1],e[2]):n(e,t,r)).map(Hd)}function w4(n,e,t){return v4(Bre,n,e,t)}function Crt(n,e,t){return v4(Srt,n,e,t)}function krt(n,e,t){return v4(xrt,n,e,t)}function Vre(n){return(n%360+360)%360}function Trt(n){const e=wrt.exec(n);let t=255,r;if(!e)return;e[5]!==r&&(t=e[6]?k1(+e[5]):Hd(+e[5]));const s=Vre(+e[2]),i=+e[3]/100,o=+e[4]/100;return e[1]==="hwb"?r=Crt(s,i,o):e[1]==="hsv"?r=krt(s,i,o):r=w4(s,i,o),{r:r[0],g:r[1],b:r[2],a:t}}function Ert(n,e){var t=b4(n);t[0]=Vre(t[0]+e),t=w4(t),n.r=t[0],n.g=t[1],n.b=t[2]}function Irt(n){if(!n)return;const e=b4(n),t=e[0],r=I6(e[1]),s=I6(e[2]);return n.a<255?`hsla(${t}, ${r}%, ${s}%, ${vf(n.a)})`:`hsl(${t}, ${r}%, ${s}%)`}const A6={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},M6={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function Art(){const n={},e=Object.keys(M6),t=Object.keys(A6);let r,s,i,o,a;for(r=0;r<e.length;r++){for(o=a=e[r],s=0;s<t.length;s++)i=t[s],a=a.replace(i,A6[i]);i=parseInt(M6[o],16),n[a]=[i>>16&255,i>>8&255,i&255]}return n}let cT;function Mrt(n){cT||(cT=Art(),cT.transparent=[0,0,0,0]);const e=cT[n.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:e.length===4?e[3]:255}}const Nrt=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function $rt(n){const e=Nrt.exec(n);let t=255,r,s,i;if(e){if(e[7]!==r){const o=+e[7];t=e[8]?k1(o):Rd(o*255,0,255)}return r=+e[1],s=+e[3],i=+e[5],r=255&(e[2]?k1(r):Rd(r,0,255)),s=255&(e[4]?k1(s):Rd(s,0,255)),i=255&(e[6]?k1(i):Rd(i,0,255)),{r,g:s,b:i,a:t}}}function Rrt(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${vf(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}const I3=n=>n<=.0031308?n*12.92:Math.pow(n,1/2.4)*1.055-.055,R0=n=>n<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4);function Prt(n,e,t){const r=R0(vf(n.r)),s=R0(vf(n.g)),i=R0(vf(n.b));return{r:Hd(I3(r+t*(R0(vf(e.r))-r))),g:Hd(I3(s+t*(R0(vf(e.g))-s))),b:Hd(I3(i+t*(R0(vf(e.b))-i))),a:n.a+t*(e.a-n.a)}}function uT(n,e,t){if(n){let r=b4(n);r[e]=Math.max(0,Math.min(r[e]+r[e]*t,e===0?360:1)),r=w4(r),n.r=r[0],n.g=r[1],n.b=r[2]}}function Ure(n,e){return n&&Object.assign(e||{},n)}function N6(n){var e={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(e={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(e.a=Hd(n[3]))):(e=Ure(n,{r:0,g:0,b:0,a:1}),e.a=Hd(e.a)),e}function Drt(n){return n.charAt(0)==="r"?$rt(n):Trt(n)}let Wre=class qO{constructor(e){if(e instanceof qO)return e;const t=typeof e;let r;t==="object"?r=N6(e):t==="string"&&(r=yrt(e)||Mrt(e)||Drt(e)),this._rgb=r,this._valid=!!r}get valid(){return this._valid}get rgb(){var e=Ure(this._rgb);return e&&(e.a=vf(e.a)),e}set rgb(e){this._rgb=N6(e)}rgbString(){return this._valid?Rrt(this._rgb):void 0}hexString(){return this._valid?vrt(this._rgb):void 0}hslString(){return this._valid?Irt(this._rgb):void 0}mix(e,t){if(e){const r=this.rgb,s=e.rgb;let i;const o=t===i?.5:t,a=2*o-1,l=r.a-s.a,c=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;i=1-c,r.r=255&c*r.r+i*s.r+.5,r.g=255&c*r.g+i*s.g+.5,r.b=255&c*r.b+i*s.b+.5,r.a=o*r.a+(1-o)*s.a,this.rgb=r}return this}interpolate(e,t){return e&&(this._rgb=Prt(this._rgb,e._rgb,t)),this}clone(){return new qO(this.rgb)}alpha(e){return this._rgb.a=Hd(e),this}clearer(e){const t=this._rgb;return t.a*=1-e,this}greyscale(){const e=this._rgb,t=IC(e.r*.3+e.g*.59+e.b*.11);return e.r=e.g=e.b=t,this}opaquer(e){const t=this._rgb;return t.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return uT(this._rgb,2,e),this}darken(e){return uT(this._rgb,2,-e),this}saturate(e){return uT(this._rgb,1,e),this}desaturate(e){return uT(this._rgb,1,-e),this}rotate(e){return Ert(this._rgb,e),this}};/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */function rf(){}const Ort=(()=>{let n=0;return()=>n++})();function Nr(n){return n===null||typeof n>"u"}function gs(n){if(Array.isArray&&Array.isArray(n))return!0;const e=Object.prototype.toString.call(n);return e.slice(0,7)==="[object"&&e.slice(-6)==="Array]"}function sr(n){return n!==null&&Object.prototype.toString.call(n)==="[object Object]"}function Ys(n){return(typeof n=="number"||n instanceof Number)&&isFinite(+n)}function yl(n,e){return Ys(n)?n:e}function Wn(n,e){return typeof n>"u"?e:n}const Frt=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100:+n/e,Gre=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100*e:+n;function os(n,e,t){if(n&&typeof n.call=="function")return n.apply(t,e)}function Dr(n,e,t,r){let s,i,o;if(gs(n))if(i=n.length,r)for(s=i-1;s>=0;s--)e.call(t,n[s],s);else for(s=0;s<i;s++)e.call(t,n[s],s);else if(sr(n))for(o=Object.keys(n),i=o.length,s=0;s<i;s++)e.call(t,n[o[s]],o[s])}function rA(n,e){let t,r,s,i;if(!n||!e||n.length!==e.length)return!1;for(t=0,r=n.length;t<r;++t)if(s=n[t],i=e[t],s.datasetIndex!==i.datasetIndex||s.index!==i.index)return!1;return!0}function sA(n){if(gs(n))return n.map(sA);if(sr(n)){const e=Object.create(null),t=Object.keys(n),r=t.length;let s=0;for(;s<r;++s)e[t[s]]=sA(n[t[s]]);return e}return n}function Hre(n){return["__proto__","prototype","constructor"].indexOf(n)===-1}function Lrt(n,e,t,r){if(!Hre(n))return;const s=e[n],i=t[n];sr(s)&&sr(i)?jS(s,i,r):e[n]=sA(i)}function jS(n,e,t){const r=gs(e)?e:[e],s=r.length;if(!sr(n))return n;t=t||{};const i=t.merger||Lrt;let o;for(let a=0;a<s;++a){if(o=r[a],!sr(o))continue;const l=Object.keys(o);for(let c=0,u=l.length;c<u;++c)i(l[c],n,o,t)}return n}function K1(n,e){return jS(n,e,{merger:zrt})}function zrt(n,e,t){if(!Hre(n))return;const r=e[n],s=t[n];sr(r)&&sr(s)?K1(r,s):Object.prototype.hasOwnProperty.call(e,n)||(e[n]=sA(s))}const $6={"":n=>n,x:n=>n.x,y:n=>n.y};function Brt(n){const e=n.split("."),t=[];let r="";for(const s of e)r+=s,r.endsWith("\\")?r=r.slice(0,-1)+".":(t.push(r),r="");return t}function Vrt(n){const e=Brt(n);return t=>{for(const r of e){if(r==="")break;t=t&&t[r]}return t}}function up(n,e){return($6[e]||($6[e]=Vrt(e)))(n)}function x4(n){return n.charAt(0).toUpperCase()+n.slice(1)}const Mc=n=>typeof n<"u",hp=n=>typeof n=="function",R6=(n,e)=>{if(n.size!==e.size)return!1;for(const t of n)if(!e.has(t))return!1;return!0};function Urt(n){return n.type==="mouseup"||n.type==="click"||n.type==="contextmenu"}const Es=Math.PI,bs=2*Es,Wrt=bs+Es,iA=Number.POSITIVE_INFINITY,Grt=Es/180,Zs=Es/2,nm=Es/4,P6=Es*2/3,Pd=Math.log10,vh=Math.sign;function Y1(n,e,t){return Math.abs(n-e)<t}function D6(n){const e=Math.round(n);n=Y1(n,e,n/1e3)?e:n;const t=Math.pow(10,Math.floor(Pd(n))),r=n/t;return(r<=1?1:r<=2?2:r<=5?5:10)*t}function Hrt(n){const e=[],t=Math.sqrt(n);let r;for(r=1;r<t;r++)n%r===0&&(e.push(r),e.push(n/r));return t===(t|0)&&e.push(t),e.sort((s,i)=>s-i).pop(),e}function rv(n){return!isNaN(parseFloat(n))&&isFinite(n)}function jrt(n,e){const t=Math.round(n);return t-e<=n&&t+e>=n}function jre(n,e,t){let r,s,i;for(r=0,s=n.length;r<s;r++)i=n[r][t],isNaN(i)||(e.min=Math.min(e.min,i),e.max=Math.max(e.max,i))}function fu(n){return n*(Es/180)}function S4(n){return n*(180/Es)}function O6(n){if(!Ys(n))return;let e=1,t=0;for(;Math.round(n*e)/e!==n;)e*=10,t++;return t}function qre(n,e){const t=e.x-n.x,r=e.y-n.y,s=Math.sqrt(t*t+r*r);let i=Math.atan2(r,t);return i<-.5*Es&&(i+=bs),{angle:i,distance:s}}function XO(n,e){return Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2))}function qrt(n,e){return(n-e+Wrt)%bs-Es}function bl(n){return(n%bs+bs)%bs}function qS(n,e,t,r){const s=bl(n),i=bl(e),o=bl(t),a=bl(i-s),l=bl(o-s),c=bl(s-i),u=bl(s-o);return s===i||s===o||r&&i===o||a>l&&c<u}function jo(n,e,t){return Math.max(e,Math.min(t,n))}function Xrt(n){return jo(n,-32768,32767)}function Ef(n,e,t,r=1e-6){return n>=Math.min(e,t)-r&&n<=Math.max(e,t)+r}function _4(n,e,t){t=t||(o=>n[o]<e);let r=n.length-1,s=0,i;for(;r-s>1;)i=s+r>>1,t(i)?s=i:r=i;return{lo:s,hi:r}}const Fm=(n,e,t,r)=>_4(n,t,r?s=>{const i=n[s][e];return i<t||i===t&&n[s+1][e]===t}:s=>n[s][e]<t),Krt=(n,e,t)=>_4(n,t,r=>n[r][e]>=t);function Yrt(n,e,t){let r=0,s=n.length;for(;r<s&&n[r]<e;)r++;for(;s>r&&n[s-1]>t;)s--;return r>0||s<n.length?n.slice(r,s):n}const Xre=["push","pop","shift","splice","unshift"];function Zrt(n,e){if(n._chartjs){n._chartjs.listeners.push(e);return}Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),Xre.forEach(t=>{const r="_onData"+x4(t),s=n[t];Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value(...i){const o=s.apply(this,i);return n._chartjs.listeners.forEach(a=>{typeof a[r]=="function"&&a[r](...i)}),o}})})}function F6(n,e){const t=n._chartjs;if(!t)return;const r=t.listeners,s=r.indexOf(e);s!==-1&&r.splice(s,1),!(r.length>0)&&(Xre.forEach(i=>{delete n[i]}),delete n._chartjs)}function Kre(n){const e=new Set;let t,r;for(t=0,r=n.length;t<r;++t)e.add(n[t]);return e.size===r?n:Array.from(e)}const Yre=function(){return typeof window>"u"?function(n){return n()}:window.requestAnimationFrame}();function Zre(n,e){let t=[],r=!1;return function(...s){t=s,r||(r=!0,Yre.call(window,()=>{r=!1,n.apply(e,t)}))}}function Jrt(n,e){let t;return function(...r){return e?(clearTimeout(t),t=setTimeout(n,e,r)):n.apply(this,r),e}}const C4=n=>n==="start"?"left":n==="end"?"right":"center",Oo=(n,e,t)=>n==="start"?e:n==="end"?t:(e+t)/2,Qrt=(n,e,t,r)=>n===(r?"left":"right")?t:n==="center"?(e+t)/2:e;function Jre(n,e,t){const r=e.length;let s=0,i=r;if(n._sorted){const{iScale:o,_parsed:a}=n,l=o.axis,{min:c,max:u,minDefined:h,maxDefined:f}=o.getUserBounds();h&&(s=jo(Math.min(Fm(a,o.axis,c).lo,t?r:Fm(e,l,o.getPixelForValue(c)).lo),0,r-1)),f?i=jo(Math.max(Fm(a,o.axis,u,!0).hi+1,t?0:Fm(e,l,o.getPixelForValue(u),!0).hi+1),s,r)-s:i=r-s}return{start:s,count:i}}function Qre(n){const{xScale:e,yScale:t,_scaleRanges:r}=n,s={xmin:e.min,xmax:e.max,ymin:t.min,ymax:t.max};if(!r)return n._scaleRanges=s,!0;const i=r.xmin!==e.min||r.xmax!==e.max||r.ymin!==t.min||r.ymax!==t.max;return Object.assign(r,s),i}const hT=n=>n===0||n===1,L6=(n,e,t)=>-(Math.pow(2,10*(n-=1))*Math.sin((n-e)*bs/t)),z6=(n,e,t)=>Math.pow(2,-10*n)*Math.sin((n-e)*bs/t)+1,Z1={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>-Math.cos(n*Zs)+1,easeOutSine:n=>Math.sin(n*Zs),easeInOutSine:n=>-.5*(Math.cos(Es*n)-1),easeInExpo:n=>n===0?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>n===1?1:-Math.pow(2,-10*n)+1,easeInOutExpo:n=>hT(n)?n:n<.5?.5*Math.pow(2,10*(n*2-1)):.5*(-Math.pow(2,-10*(n*2-1))+2),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>hT(n)?n:L6(n,.075,.3),easeOutElastic:n=>hT(n)?n:z6(n,.075,.3),easeInOutElastic(n){return hT(n)?n:n<.5?.5*L6(n*2,.1125,.45):.5+.5*z6(n*2-1,.1125,.45)},easeInBack(n){return n*n*((1.70158+1)*n-1.70158)},easeOutBack(n){return(n-=1)*n*((1.70158+1)*n+1.70158)+1},easeInOutBack(n){let e=1.70158;return(n/=.5)<1?.5*(n*n*(((e*=1.525)+1)*n-e)):.5*((n-=2)*n*(((e*=1.525)+1)*n+e)+2)},easeInBounce:n=>1-Z1.easeOutBounce(1-n),easeOutBounce(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},easeInOutBounce:n=>n<.5?Z1.easeInBounce(n*2)*.5:Z1.easeOutBounce(n*2-1)*.5+.5};function ese(n){if(n&&typeof n=="object"){const e=n.toString();return e==="[object CanvasPattern]"||e==="[object CanvasGradient]"}return!1}function B6(n){return ese(n)?n:new Wre(n)}function A3(n){return ese(n)?n:new Wre(n).saturate(.5).darken(.1).hexString()}const est=["x","y","borderWidth","radius","tension"],tst=["color","borderColor","backgroundColor"];function nst(n){n.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),n.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>e!=="onProgress"&&e!=="onComplete"&&e!=="fn"}),n.set("animations",{colors:{type:"color",properties:tst},numbers:{type:"number",properties:est}}),n.describe("animations",{_fallback:"animation"}),n.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>e|0}}}})}function rst(n){n.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}const V6=new Map;function sst(n,e){e=e||{};const t=n+JSON.stringify(e);let r=V6.get(t);return r||(r=new Intl.NumberFormat(n,e),V6.set(t,r)),r}function AC(n,e,t){return sst(e,t).format(n)}const tse={values(n){return gs(n)?n:""+n},numeric(n,e,t){if(n===0)return"0";const r=this.chart.options.locale;let s,i=n;if(t.length>1){const c=Math.max(Math.abs(t[0].value),Math.abs(t[t.length-1].value));(c<1e-4||c>1e15)&&(s="scientific"),i=ist(n,t)}const o=Pd(Math.abs(i)),a=Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:s,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),AC(n,r,l)},logarithmic(n,e,t){if(n===0)return"0";const r=t[e].significand||n/Math.pow(10,Math.floor(Pd(n)));return[1,2,3,5,10,15].includes(r)||e>.8*t.length?tse.numeric.call(this,n,e,t):""}};function ist(n,e){let t=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;return Math.abs(t)>=1&&n!==Math.floor(n)&&(t=n-Math.floor(n)),t}var d$={formatters:tse};function ost(n){n.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:d$.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),n.route("scale.ticks","color","","color"),n.route("scale.grid","color","","borderColor"),n.route("scale.border","color","","borderColor"),n.route("scale.title","color","","color"),n.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&e!=="callback"&&e!=="parser",_indexable:e=>e!=="borderDash"&&e!=="tickBorderDash"&&e!=="dash"}),n.describe("scales",{_fallback:"scale"}),n.describe("scale.ticks",{_scriptable:e=>e!=="backdropPadding"&&e!=="callback",_indexable:e=>e!=="backdropPadding"})}const mg=Object.create(null),KO=Object.create(null);function J1(n,e){if(!e)return n;const t=e.split(".");for(let r=0,s=t.length;r<s;++r){const i=t[r];n=n[i]||(n[i]=Object.create(null))}return n}function M3(n,e,t){return typeof e=="string"?jS(J1(n,e),t):jS(J1(n,""),e)}class ast{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=r=>r.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(r,s)=>A3(s.backgroundColor),this.hoverBorderColor=(r,s)=>A3(s.borderColor),this.hoverColor=(r,s)=>A3(s.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return M3(this,e,t)}get(e){return J1(this,e)}describe(e,t){return M3(KO,e,t)}override(e,t){return M3(mg,e,t)}route(e,t,r,s){const i=J1(this,e),o=J1(this,r),a="_"+t;Object.defineProperties(i,{[a]:{value:i[t],writable:!0},[t]:{enumerable:!0,get(){const l=this[a],c=o[s];return sr(l)?Object.assign({},c,l):Wn(l,c)},set(l){this[a]=l}}})}apply(e){e.forEach(t=>t(this))}}var oi=new ast({_scriptable:n=>!n.startsWith("on"),_indexable:n=>n!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[nst,rst,ost]);function lst(n){return!n||Nr(n.size)||Nr(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}function oA(n,e,t,r,s){let i=e[s];return i||(i=e[s]=n.measureText(s).width,t.push(s)),i>r&&(r=i),r}function cst(n,e,t,r){r=r||{};let s=r.data=r.data||{},i=r.garbageCollect=r.garbageCollect||[];r.font!==e&&(s=r.data={},i=r.garbageCollect=[],r.font=e),n.save(),n.font=e;let o=0;const a=t.length;let l,c,u,h,f;for(l=0;l<a;l++)if(h=t[l],h!=null&&gs(h)!==!0)o=oA(n,s,i,o,h);else if(gs(h))for(c=0,u=h.length;c<u;c++)f=h[c],f!=null&&!gs(f)&&(o=oA(n,s,i,o,f));n.restore();const d=i.length/2;if(d>t.length){for(l=0;l<d;l++)delete s[i[l]];i.splice(0,d)}return o}function rm(n,e,t){const r=n.currentDevicePixelRatio,s=t!==0?Math.max(t/2,.5):0;return Math.round((e-s)*r)/r+s}function U6(n,e){e=e||n.getContext("2d"),e.save(),e.resetTransform(),e.clearRect(0,0,n.width,n.height),e.restore()}function YO(n,e,t,r){nse(n,e,t,r,null)}function nse(n,e,t,r,s){let i,o,a,l,c,u,h,f;const d=e.pointStyle,p=e.rotation,m=e.radius;let g=(p||0)*Grt;if(d&&typeof d=="object"&&(i=d.toString(),i==="[object HTMLImageElement]"||i==="[object HTMLCanvasElement]")){n.save(),n.translate(t,r),n.rotate(g),n.drawImage(d,-d.width/2,-d.height/2,d.width,d.height),n.restore();return}if(!(isNaN(m)||m<=0)){switch(n.beginPath(),d){default:s?n.ellipse(t,r,s/2,m,0,0,bs):n.arc(t,r,m,0,bs),n.closePath();break;case"triangle":u=s?s/2:m,n.moveTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=P6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=P6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),n.closePath();break;case"rectRounded":c=m*.516,l=m-c,o=Math.cos(g+nm)*l,h=Math.cos(g+nm)*(s?s/2-c:l),a=Math.sin(g+nm)*l,f=Math.sin(g+nm)*(s?s/2-c:l),n.arc(t-h,r-a,c,g-Es,g-Zs),n.arc(t+f,r-o,c,g-Zs,g),n.arc(t+h,r+a,c,g,g+Zs),n.arc(t-f,r+o,c,g+Zs,g+Es),n.closePath();break;case"rect":if(!p){l=Math.SQRT1_2*m,u=s?s/2:l,n.rect(t-u,r-l,2*u,2*l);break}g+=nm;case"rectRot":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+f,r-o),n.lineTo(t+h,r+a),n.lineTo(t-f,r+o),n.closePath();break;case"crossRot":g+=nm;case"cross":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"star":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o),g+=nm,h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"line":o=s?s/2:Math.cos(g)*m,a=Math.sin(g)*m,n.moveTo(t-o,r-a),n.lineTo(t+o,r+a);break;case"dash":n.moveTo(t,r),n.lineTo(t+Math.cos(g)*(s?s/2:m),r+Math.sin(g)*m);break;case!1:n.closePath();break}n.fill(),e.borderWidth>0&&n.stroke()}}function XS(n,e,t){return t=t||.5,!e||n&&n.x>e.left-t&&n.x<e.right+t&&n.y>e.top-t&&n.y<e.bottom+t}function p$(n,e){n.save(),n.beginPath(),n.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),n.clip()}function m$(n){n.restore()}function ust(n,e,t,r,s){if(!e)return n.lineTo(t.x,t.y);if(s==="middle"){const i=(e.x+t.x)/2;n.lineTo(i,e.y),n.lineTo(i,t.y)}else s==="after"!=!!r?n.lineTo(e.x,t.y):n.lineTo(t.x,e.y);n.lineTo(t.x,t.y)}function hst(n,e,t,r){if(!e)return n.lineTo(t.x,t.y);n.bezierCurveTo(r?e.cp1x:e.cp2x,r?e.cp1y:e.cp2y,r?t.cp2x:t.cp1x,r?t.cp2y:t.cp1y,t.x,t.y)}function gg(n,e,t,r,s,i={}){const o=gs(e)?e:[e],a=i.strokeWidth>0&&i.strokeColor!=="";let l,c;for(n.save(),n.font=s.string,fst(n,i),l=0;l<o.length;++l)c=o[l],i.backdrop&&pst(n,i.backdrop),a&&(i.strokeColor&&(n.strokeStyle=i.strokeColor),Nr(i.strokeWidth)||(n.lineWidth=i.strokeWidth),n.strokeText(c,t,r,i.maxWidth)),n.fillText(c,t,r,i.maxWidth),dst(n,t,r,c,i),r+=s.lineHeight;n.restore()}function fst(n,e){e.translation&&n.translate(e.translation[0],e.translation[1]),Nr(e.rotation)||n.rotate(e.rotation),e.color&&(n.fillStyle=e.color),e.textAlign&&(n.textAlign=e.textAlign),e.textBaseline&&(n.textBaseline=e.textBaseline)}function dst(n,e,t,r,s){if(s.strikethrough||s.underline){const i=n.measureText(r),o=e-i.actualBoundingBoxLeft,a=e+i.actualBoundingBoxRight,l=t-i.actualBoundingBoxAscent,c=t+i.actualBoundingBoxDescent,u=s.strikethrough?(l+c)/2:c;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=s.decorationWidth||2,n.moveTo(o,u),n.lineTo(a,u),n.stroke()}}function pst(n,e){const t=n.fillStyle;n.fillStyle=e.color,n.fillRect(e.left,e.top,e.width,e.height),n.fillStyle=t}function KS(n,e){const{x:t,y:r,w:s,h:i,radius:o}=e;n.arc(t+o.topLeft,r+o.topLeft,o.topLeft,-Zs,Es,!0),n.lineTo(t,r+i-o.bottomLeft),n.arc(t+o.bottomLeft,r+i-o.bottomLeft,o.bottomLeft,Es,Zs,!0),n.lineTo(t+s-o.bottomRight,r+i),n.arc(t+s-o.bottomRight,r+i-o.bottomRight,o.bottomRight,Zs,0,!0),n.lineTo(t+s,r+o.topRight),n.arc(t+s-o.topRight,r+o.topRight,o.topRight,0,-Zs,!0),n.lineTo(t+o.topLeft,r)}const mst=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,gst=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function yst(n,e){const t=(""+n).match(mst);if(!t||t[1]==="normal")return e*1.2;switch(n=+t[2],t[3]){case"px":return n;case"%":n/=100;break}return e*n}const bst=n=>+n||0;function k4(n,e){const t={},r=sr(e),s=r?Object.keys(e):e,i=sr(n)?r?o=>Wn(n[o],n[e[o]]):o=>n[o]:()=>n;for(const o of s)t[o]=bst(i(o));return t}function rse(n){return k4(n,{top:"y",right:"x",bottom:"y",left:"x"})}function jm(n){return k4(n,["topLeft","topRight","bottomLeft","bottomRight"])}function Yo(n){const e=rse(n);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Wi(n,e){n=n||{},e=e||oi.font;let t=Wn(n.size,e.size);typeof t=="string"&&(t=parseInt(t,10));let r=Wn(n.style,e.style);r&&!(""+r).match(gst)&&(console.warn('Invalid font style specified: "'+r+'"'),r=void 0);const s={family:Wn(n.family,e.family),lineHeight:yst(Wn(n.lineHeight,e.lineHeight),t),size:t,style:r,weight:Wn(n.weight,e.weight),string:""};return s.string=lst(s),s}function fT(n,e,t,r){let s=!0,i,o,a;for(i=0,o=n.length;i<o;++i)if(a=n[i],a!==void 0&&(e!==void 0&&typeof a=="function"&&(a=a(e),s=!1),t!==void 0&&gs(a)&&(a=a[t%a.length],s=!1),a!==void 0))return r&&!s&&(r.cacheable=!1),a}function vst(n,e,t){const{min:r,max:s}=n,i=Gre(e,(s-r)/2),o=(a,l)=>t&&a===0?0:a+l;return{min:o(r,-Math.abs(i)),max:o(s,i)}}function Pp(n,e){return Object.assign(Object.create(n),e)}function T4(n,e=[""],t=n,r,s=()=>n[0]){Mc(r)||(r=ase("_fallback",n));const i={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:t,_fallback:r,_getTarget:s,override:o=>T4([o,...n],e,t,r)};return new Proxy(i,{deleteProperty(o,a){return delete o[a],delete o._keys,delete n[0][a],!0},get(o,a){return ise(o,a,()=>Est(a,e,n,o))},getOwnPropertyDescriptor(o,a){return Reflect.getOwnPropertyDescriptor(o._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(n[0])},has(o,a){return G6(o).includes(a)},ownKeys(o){return G6(o)},set(o,a,l){const c=o._storage||(o._storage=s());return o[a]=c[a]=l,delete o._keys,!0}})}function sv(n,e,t,r){const s={_cacheable:!1,_proxy:n,_context:e,_subProxy:t,_stack:new Set,_descriptors:sse(n,r),setContext:i=>sv(n,i,t,r),override:i=>sv(n.override(i),e,t,r)};return new Proxy(s,{deleteProperty(i,o){return delete i[o],delete n[o],!0},get(i,o,a){return ise(i,o,()=>xst(i,o,a))},getOwnPropertyDescriptor(i,o){return i._descriptors.allKeys?Reflect.has(n,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,o)},getPrototypeOf(){return Reflect.getPrototypeOf(n)},has(i,o){return Reflect.has(n,o)},ownKeys(){return Reflect.ownKeys(n)},set(i,o,a){return n[o]=a,delete i[o],!0}})}function sse(n,e={scriptable:!0,indexable:!0}){const{_scriptable:t=e.scriptable,_indexable:r=e.indexable,_allKeys:s=e.allKeys}=n;return{allKeys:s,scriptable:t,indexable:r,isScriptable:hp(t)?t:()=>t,isIndexable:hp(r)?r:()=>r}}const wst=(n,e)=>n?n+x4(e):e,E4=(n,e)=>sr(e)&&n!=="adapters"&&(Object.getPrototypeOf(e)===null||e.constructor===Object);function ise(n,e,t){if(Object.prototype.hasOwnProperty.call(n,e))return n[e];const r=t();return n[e]=r,r}function xst(n,e,t){const{_proxy:r,_context:s,_subProxy:i,_descriptors:o}=n;let a=r[e];return hp(a)&&o.isScriptable(e)&&(a=Sst(e,a,n,t)),gs(a)&&a.length&&(a=_st(e,a,n,o.isIndexable)),E4(e,a)&&(a=sv(a,s,i&&i[e],o)),a}function Sst(n,e,t,r){const{_proxy:s,_context:i,_subProxy:o,_stack:a}=t;if(a.has(n))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+n);return a.add(n),e=e(i,o||r),a.delete(n),E4(n,e)&&(e=I4(s._scopes,s,n,e)),e}function _st(n,e,t,r){const{_proxy:s,_context:i,_subProxy:o,_descriptors:a}=t;if(Mc(i.index)&&r(n))e=e[i.index%e.length];else if(sr(e[0])){const l=e,c=s._scopes.filter(u=>u!==l);e=[];for(const u of l){const h=I4(c,s,n,u);e.push(sv(h,i,o&&o[n],a))}}return e}function ose(n,e,t){return hp(n)?n(e,t):n}const Cst=(n,e)=>n===!0?e:typeof n=="string"?up(e,n):void 0;function kst(n,e,t,r,s){for(const i of e){const o=Cst(t,i);if(o){n.add(o);const a=ose(o._fallback,t,s);if(Mc(a)&&a!==t&&a!==r)return a}else if(o===!1&&Mc(r)&&t!==r)return null}return!1}function I4(n,e,t,r){const s=e._rootScopes,i=ose(e._fallback,t,r),o=[...n,...s],a=new Set;a.add(r);let l=W6(a,o,t,i||t,r);return l===null||Mc(i)&&i!==t&&(l=W6(a,o,i,l,r),l===null)?!1:T4(Array.from(a),[""],s,i,()=>Tst(e,t,r))}function W6(n,e,t,r,s){for(;t;)t=kst(n,e,t,r,s);return t}function Tst(n,e,t){const r=n._getTarget();e in r||(r[e]={});const s=r[e];return gs(s)&&sr(t)?t:s||{}}function Est(n,e,t,r){let s;for(const i of e)if(s=ase(wst(i,n),t),Mc(s))return E4(n,s)?I4(t,r,n,s):s}function ase(n,e){for(const t of e){if(!t)continue;const r=t[n];if(Mc(r))return r}}function G6(n){let e=n._keys;return e||(e=n._keys=Ist(n._scopes)),e}function Ist(n){const e=new Set;for(const t of n)for(const r of Object.keys(t).filter(s=>!s.startsWith("_")))e.add(r);return Array.from(e)}function lse(n,e,t,r){const{iScale:s}=n,{key:i="r"}=this._parsing,o=new Array(r);let a,l,c,u;for(a=0,l=r;a<l;++a)c=a+t,u=e[c],o[a]={r:s.parse(up(u,i),c)};return o}const Ast=Number.EPSILON||1e-14,iv=(n,e)=>e<n.length&&!n[e].skip&&n[e],cse=n=>n==="x"?"y":"x";function Mst(n,e,t,r){const s=n.skip?e:n,i=e,o=t.skip?e:t,a=XO(i,s),l=XO(o,i);let c=a/(a+l),u=l/(a+l);c=isNaN(c)?0:c,u=isNaN(u)?0:u;const h=r*c,f=r*u;return{previous:{x:i.x-h*(o.x-s.x),y:i.y-h*(o.y-s.y)},next:{x:i.x+f*(o.x-s.x),y:i.y+f*(o.y-s.y)}}}function Nst(n,e,t){const r=n.length;let s,i,o,a,l,c=iv(n,0);for(let u=0;u<r-1;++u)if(l=c,c=iv(n,u+1),!(!l||!c)){if(Y1(e[u],0,Ast)){t[u]=t[u+1]=0;continue}s=t[u]/e[u],i=t[u+1]/e[u],a=Math.pow(s,2)+Math.pow(i,2),!(a<=9)&&(o=3/Math.sqrt(a),t[u]=s*o*e[u],t[u+1]=i*o*e[u])}}function $st(n,e,t="x"){const r=cse(t),s=n.length;let i,o,a,l=iv(n,0);for(let c=0;c<s;++c){if(o=a,a=l,l=iv(n,c+1),!a)continue;const u=a[t],h=a[r];o&&(i=(u-o[t])/3,a[`cp1${t}`]=u-i,a[`cp1${r}`]=h-i*e[c]),l&&(i=(l[t]-u)/3,a[`cp2${t}`]=u+i,a[`cp2${r}`]=h+i*e[c])}}function Rst(n,e="x"){const t=cse(e),r=n.length,s=Array(r).fill(0),i=Array(r);let o,a,l,c=iv(n,0);for(o=0;o<r;++o)if(a=l,l=c,c=iv(n,o+1),!!l){if(c){const u=c[e]-l[e];s[o]=u!==0?(c[t]-l[t])/u:0}i[o]=a?c?vh(s[o-1])!==vh(s[o])?0:(s[o-1]+s[o])/2:s[o-1]:s[o]}Nst(n,s,i),$st(n,i,e)}function dT(n,e,t){return Math.max(Math.min(n,t),e)}function Pst(n,e){let t,r,s,i,o,a=XS(n[0],e);for(t=0,r=n.length;t<r;++t)o=i,i=a,a=t<r-1&&XS(n[t+1],e),i&&(s=n[t],o&&(s.cp1x=dT(s.cp1x,e.left,e.right),s.cp1y=dT(s.cp1y,e.top,e.bottom)),a&&(s.cp2x=dT(s.cp2x,e.left,e.right),s.cp2y=dT(s.cp2y,e.top,e.bottom)))}function Dst(n,e,t,r,s){let i,o,a,l;if(e.spanGaps&&(n=n.filter(c=>!c.skip)),e.cubicInterpolationMode==="monotone")Rst(n,s);else{let c=r?n[n.length-1]:n[0];for(i=0,o=n.length;i<o;++i)a=n[i],l=Mst(c,a,n[Math.min(i+1,o-(r?0:1))%o],e.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}e.capBezierPoints&&Pst(n,t)}function use(){return typeof window<"u"&&typeof document<"u"}function A4(n){let e=n.parentNode;return e&&e.toString()==="[object ShadowRoot]"&&(e=e.host),e}function aA(n,e,t){let r;return typeof n=="string"?(r=parseInt(n,10),n.indexOf("%")!==-1&&(r=r/100*e.parentNode[t])):r=n,r}const g$=n=>n.ownerDocument.defaultView.getComputedStyle(n,null);function Ost(n,e){return g$(n).getPropertyValue(e)}const Fst=["top","right","bottom","left"];function qm(n,e,t){const r={};t=t?"-"+t:"";for(let s=0;s<4;s++){const i=Fst[s];r[i]=parseFloat(n[e+"-"+i+t])||0}return r.width=r.left+r.right,r.height=r.top+r.bottom,r}const Lst=(n,e,t)=>(n>0||e>0)&&(!t||!t.shadowRoot);function zst(n,e){const t=n.touches,r=t&&t.length?t[0]:n,{offsetX:s,offsetY:i}=r;let o=!1,a,l;if(Lst(s,i,n.target))a=s,l=i;else{const c=e.getBoundingClientRect();a=r.clientX-c.left,l=r.clientY-c.top,o=!0}return{x:a,y:l,box:o}}function vm(n,e){if("native"in n)return n;const{canvas:t,currentDevicePixelRatio:r}=e,s=g$(t),i=s.boxSizing==="border-box",o=qm(s,"padding"),a=qm(s,"border","width"),{x:l,y:c,box:u}=zst(n,t),h=o.left+(u&&a.left),f=o.top+(u&&a.top);let{width:d,height:p}=e;return i&&(d-=o.width+a.width,p-=o.height+a.height),{x:Math.round((l-h)/d*t.width/r),y:Math.round((c-f)/p*t.height/r)}}function Bst(n,e,t){let r,s;if(e===void 0||t===void 0){const i=A4(n);if(!i)e=n.clientWidth,t=n.clientHeight;else{const o=i.getBoundingClientRect(),a=g$(i),l=qm(a,"border","width"),c=qm(a,"padding");e=o.width-c.width-l.width,t=o.height-c.height-l.height,r=aA(a.maxWidth,i,"clientWidth"),s=aA(a.maxHeight,i,"clientHeight")}}return{width:e,height:t,maxWidth:r||iA,maxHeight:s||iA}}const pT=n=>Math.round(n*10)/10;function Vst(n,e,t,r){const s=g$(n),i=qm(s,"margin"),o=aA(s.maxWidth,n,"clientWidth")||iA,a=aA(s.maxHeight,n,"clientHeight")||iA,l=Bst(n,e,t);let{width:c,height:u}=l;if(s.boxSizing==="content-box"){const f=qm(s,"border","width"),d=qm(s,"padding");c-=d.width+f.width,u-=d.height+f.height}return c=Math.max(0,c-i.width),u=Math.max(0,r?c/r:u-i.height),c=pT(Math.min(c,o,l.maxWidth)),u=pT(Math.min(u,a,l.maxHeight)),c&&!u&&(u=pT(c/2)),(e!==void 0||t!==void 0)&&r&&l.height&&u>l.height&&(u=l.height,c=pT(Math.floor(u*r))),{width:c,height:u}}function H6(n,e,t){const r=e||1,s=Math.floor(n.height*r),i=Math.floor(n.width*r);n.height=Math.floor(n.height),n.width=Math.floor(n.width);const o=n.canvas;return o.style&&(t||!o.style.height&&!o.style.width)&&(o.style.height=`${n.height}px`,o.style.width=`${n.width}px`),n.currentDevicePixelRatio!==r||o.height!==s||o.width!==i?(n.currentDevicePixelRatio=r,o.height=s,o.width=i,n.ctx.setTransform(r,0,0,r,0,0),!0):!1}const Ust=function(){let n=!1;try{const e={get passive(){return n=!0,!1}};window.addEventListener("test",null,e),window.removeEventListener("test",null,e)}catch{}return n}();function j6(n,e){const t=Ost(n,e),r=t&&t.match(/^(\d+)(\.\d+)?px$/);return r?+r[1]:void 0}function wm(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:n.y+t*(e.y-n.y)}}function Wst(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:r==="middle"?t<.5?n.y:e.y:r==="after"?t<1?n.y:e.y:t>0?e.y:n.y}}function Gst(n,e,t,r){const s={x:n.cp2x,y:n.cp2y},i={x:e.cp1x,y:e.cp1y},o=wm(n,s,t),a=wm(s,i,t),l=wm(i,e,t),c=wm(o,a,t),u=wm(a,l,t);return wm(c,u,t)}const Hst=function(n,e){return{x(t){return n+n+e-t},setWidth(t){e=t},textAlign(t){return t==="center"?t:t==="right"?"left":"right"},xPlus(t,r){return t-r},leftForLtr(t,r){return t-r}}},jst=function(){return{x(n){return n},setWidth(n){},textAlign(n){return n},xPlus(n,e){return n+e},leftForLtr(n,e){return n}}};function Mb(n,e,t){return n?Hst(e,t):jst()}function hse(n,e){let t,r;(e==="ltr"||e==="rtl")&&(t=n.canvas.style,r=[t.getPropertyValue("direction"),t.getPropertyPriority("direction")],t.setProperty("direction",e,"important"),n.prevTextDirection=r)}function fse(n,e){e!==void 0&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",e[0],e[1]))}function dse(n){return n==="angle"?{between:qS,compare:qrt,normalize:bl}:{between:Ef,compare:(e,t)=>e-t,normalize:e=>e}}function q6({start:n,end:e,count:t,loop:r,style:s}){return{start:n%t,end:e%t,loop:r&&(e-n+1)%t===0,style:s}}function qst(n,e,t){const{property:r,start:s,end:i}=t,{between:o,normalize:a}=dse(r),l=e.length;let{start:c,end:u,loop:h}=n,f,d;if(h){for(c+=l,u+=l,f=0,d=l;f<d&&o(a(e[c%l][r]),s,i);++f)c--,u--;c%=l,u%=l}return u<c&&(u+=l),{start:c,end:u,loop:h,style:n.style}}function pse(n,e,t){if(!t)return[n];const{property:r,start:s,end:i}=t,o=e.length,{compare:a,between:l,normalize:c}=dse(r),{start:u,end:h,loop:f,style:d}=qst(n,e,t),p=[];let m=!1,g=null,y,b,x;const w=()=>l(s,x,y)&&a(s,x)!==0,_=()=>a(i,y)===0||l(i,x,y),C=()=>m||w(),k=()=>!m||_();for(let A=u,M=u;A<=h;++A)b=e[A%o],!b.skip&&(y=c(b[r]),y!==x&&(m=l(y,s,i),g===null&&C()&&(g=a(y,s)===0?A:M),g!==null&&k()&&(p.push(q6({start:g,end:A,loop:f,count:o,style:d})),g=null),M=A,x=y));return g!==null&&p.push(q6({start:g,end:h,loop:f,count:o,style:d})),p}function mse(n,e){const t=[],r=n.segments;for(let s=0;s<r.length;s++){const i=pse(r[s],n.points,e);i.length&&t.push(...i)}return t}function Xst(n,e,t,r){let s=0,i=e-1;if(t&&!r)for(;s<e&&!n[s].skip;)s++;for(;s<e&&n[s].skip;)s++;for(s%=e,t&&(i+=s);i>s&&n[i%e].skip;)i--;return i%=e,{start:s,end:i}}function Kst(n,e,t,r){const s=n.length,i=[];let o=e,a=n[e],l;for(l=e+1;l<=t;++l){const c=n[l%s];c.skip||c.stop?a.skip||(r=!1,i.push({start:e%s,end:(l-1)%s,loop:r}),e=o=c.stop?l:null):(o=l,a.skip&&(e=l)),a=c}return o!==null&&i.push({start:e%s,end:o%s,loop:r}),i}function Yst(n,e){const t=n.points,r=n.options.spanGaps,s=t.length;if(!s)return[];const i=!!n._loop,{start:o,end:a}=Xst(t,s,i,r);if(r===!0)return X6(n,[{start:o,end:a,loop:i}],t,e);const l=a<o?a+s:a,c=!!n._fullLoop&&o===0&&a===s-1;return X6(n,Kst(t,o,l,c),t,e)}function X6(n,e,t,r){return!r||!r.setContext||!t?e:Zst(n,e,t,r)}function Zst(n,e,t,r){const s=n._chart.getContext(),i=K6(n.options),{_datasetIndex:o,options:{spanGaps:a}}=n,l=t.length,c=[];let u=i,h=e[0].start,f=h;function d(p,m,g,y){const b=a?-1:1;if(p!==m){for(p+=l;t[p%l].skip;)p-=b;for(;t[m%l].skip;)m+=b;p%l!==m%l&&(c.push({start:p%l,end:m%l,loop:g,style:y}),u=y,h=m%l)}}for(const p of e){h=a?h:p.start;let m=t[h%l],g;for(f=h+1;f<=p.end;f++){const y=t[f%l];g=K6(r.setContext(Pp(s,{type:"segment",p0:m,p1:y,p0DataIndex:(f-1)%l,p1DataIndex:f%l,datasetIndex:o}))),Jst(g,u)&&d(h,f-1,p.loop,u),m=y,u=g}h<f-1&&d(h,f-1,p.loop,u)}return c}function K6(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function Jst(n,e){return e&&JSON.stringify(n)!==JSON.stringify(e)}/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class Qst{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,r,s){const i=t.listeners[s],o=t.duration;i.forEach(a=>a({chart:e,initial:t.initial,numSteps:o,currentStep:Math.min(r-t.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=Yre.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(e=Date.now()){let t=0;this._charts.forEach((r,s)=>{if(!r.running||!r.items.length)return;const i=r.items;let o=i.length-1,a=!1,l;for(;o>=0;--o)l=i[o],l._active?(l._total>r.duration&&(r.duration=l._total),l.tick(e),a=!0):(i[o]=i[i.length-1],i.pop());a&&(s.draw(),this._notify(s,r,e,"progress")),i.length||(r.running=!1,this._notify(s,r,e,"complete"),r.initial=!1),t+=i.length}),this._lastDate=e,t===0&&(this._running=!1)}_getAnims(e){const t=this._charts;let r=t.get(e);return r||(r={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,r)),r}listen(e,t,r){this._getAnims(e).listeners[t].push(r)}add(e,t){!t||!t.length||this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce((r,s)=>Math.max(r,s._duration),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!(!t||!t.running||!t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const r=t.items;let s=r.length-1;for(;s>=0;--s)r[s].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var hf=new Qst;const Y6="transparent",eit={boolean(n,e,t){return t>.5?e:n},color(n,e,t){const r=B6(n||Y6),s=r.valid&&B6(e||Y6);return s&&s.valid?s.mix(r,t).hexString():e},number(n,e,t){return n+(e-n)*t}};class tit{constructor(e,t,r,s){const i=t[r];s=fT([e.to,s,i,e.from]);const o=fT([e.from,i,s]);this._active=!0,this._fn=e.fn||eit[e.type||typeof o],this._easing=Z1[e.easing]||Z1.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=r,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(e,t,r){if(this._active){this._notify(!1);const s=this._target[this._prop],i=r-this._start,o=this._duration-i;this._start=r,this._duration=Math.floor(Math.max(o,e.duration)),this._total+=i,this._loop=!!e.loop,this._to=fT([e.to,t,s,e.from]),this._from=fT([e.from,s,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,r=this._duration,s=this._prop,i=this._from,o=this._loop,a=this._to;let l;if(this._active=i!==a&&(o||t<r),!this._active){this._target[s]=a,this._notify(!0);return}if(t<0){this._target[s]=i;return}l=t/r%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[s]=this._fn(i,a,l)}wait(){const e=this._promises||(this._promises=[]);return new Promise((t,r)=>{e.push({res:t,rej:r})})}_notify(e){const t=e?"res":"rej",r=this._promises||[];for(let s=0;s<r.length;s++)r[s][t]()}}class gse{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!sr(e))return;const t=Object.keys(oi.animation),r=this._properties;Object.getOwnPropertyNames(e).forEach(s=>{const i=e[s];if(!sr(i))return;const o={};for(const a of t)o[a]=i[a];(gs(i.properties)&&i.properties||[s]).forEach(a=>{(a===s||!r.has(a))&&r.set(a,o)})})}_animateOptions(e,t){const r=t.options,s=rit(e,r);if(!s)return[];const i=this._createAnimations(s,r);return r.$shared&&nit(e.options.$animations,r).then(()=>{e.options=r},()=>{}),i}_createAnimations(e,t){const r=this._properties,s=[],i=e.$animations||(e.$animations={}),o=Object.keys(t),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if(c.charAt(0)==="$")continue;if(c==="options"){s.push(...this._animateOptions(e,t));continue}const u=t[c];let h=i[c];const f=r.get(c);if(h)if(f&&h.active()){h.update(f,u,a);continue}else h.cancel();if(!f||!f.duration){e[c]=u;continue}i[c]=h=new tit(f,e,c,u),s.push(h)}return s}update(e,t){if(this._properties.size===0){Object.assign(e,t);return}const r=this._createAnimations(e,t);if(r.length)return hf.add(this._chart,r),!0}}function nit(n,e){const t=[],r=Object.keys(e);for(let s=0;s<r.length;s++){const i=n[r[s]];i&&i.active()&&t.push(i.wait())}return Promise.all(t)}function rit(n,e){if(!e)return;let t=n.options;if(!t){n.options=e;return}return t.$shared&&(n.options=t=Object.assign({},t,{$shared:!1,$animations:{}})),t}function Z6(n,e){const t=n&&n.options||{},r=t.reverse,s=t.min===void 0?e:0,i=t.max===void 0?e:0;return{start:r?i:s,end:r?s:i}}function sit(n,e,t){if(t===!1)return!1;const r=Z6(n,t),s=Z6(e,t);return{top:s.end,right:r.end,bottom:s.start,left:r.start}}function iit(n){let e,t,r,s;return sr(n)?(e=n.top,t=n.right,r=n.bottom,s=n.left):e=t=r=s=n,{top:e,right:t,bottom:r,left:s,disabled:n===!1}}function yse(n,e){const t=[],r=n._getSortedDatasetMetas(e);let s,i;for(s=0,i=r.length;s<i;++s)t.push(r[s].index);return t}function J6(n,e,t,r={}){const s=n.keys,i=r.mode==="single";let o,a,l,c;if(e!==null){for(o=0,a=s.length;o<a;++o){if(l=+s[o],l===t){if(r.all)continue;break}c=n.values[l],Ys(c)&&(i||e===0||vh(e)===vh(c))&&(e+=c)}return e}}function oit(n){const e=Object.keys(n),t=new Array(e.length);let r,s,i;for(r=0,s=e.length;r<s;++r)i=e[r],t[r]={x:i,y:n[i]};return t}function Q6(n,e){const t=n&&n.options.stacked;return t||t===void 0&&e.stack!==void 0}function ait(n,e,t){return`${n.id}.${e.id}.${t.stack||t.type}`}function lit(n){const{min:e,max:t,minDefined:r,maxDefined:s}=n.getUserBounds();return{min:r?e:Number.NEGATIVE_INFINITY,max:s?t:Number.POSITIVE_INFINITY}}function cit(n,e,t){const r=n[e]||(n[e]={});return r[t]||(r[t]={})}function e5(n,e,t,r){for(const s of e.getMatchingVisibleMetas(r).reverse()){const i=n[s.index];if(t&&i>0||!t&&i<0)return s.index}return null}function t5(n,e){const{chart:t,_cachedMeta:r}=n,s=t._stacks||(t._stacks={}),{iScale:i,vScale:o,index:a}=r,l=i.axis,c=o.axis,u=ait(i,o,r),h=e.length;let f;for(let d=0;d<h;++d){const p=e[d],{[l]:m,[c]:g}=p,y=p._stacks||(p._stacks={});f=y[c]=cit(s,u,m),f[a]=g,f._top=e5(f,o,!0,r.type),f._bottom=e5(f,o,!1,r.type);const b=f._visualValues||(f._visualValues={});b[a]=g}}function N3(n,e){const t=n.scales;return Object.keys(t).filter(r=>t[r].axis===e).shift()}function uit(n,e){return Pp(n,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}function hit(n,e,t){return Pp(n,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:t,index:e,mode:"default",type:"data"})}function Gx(n,e){const t=n.controller.index,r=n.vScale&&n.vScale.axis;if(r){e=e||n._parsed;for(const s of e){const i=s._stacks;if(!i||i[r]===void 0||i[r][t]===void 0)return;delete i[r][t],i[r]._visualValues!==void 0&&i[r]._visualValues[t]!==void 0&&delete i[r]._visualValues[t]}}}const $3=n=>n==="reset"||n==="none",n5=(n,e)=>e?n:Object.assign({},n),fit=(n,e,t)=>n&&!e.hidden&&e._stacked&&{keys:yse(t,!0),values:null};class bu{constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=Q6(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&Gx(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,r=this.getDataset(),s=(h,f,d,p)=>h==="x"?f:h==="r"?p:d,i=t.xAxisID=Wn(r.xAxisID,N3(e,"x")),o=t.yAxisID=Wn(r.yAxisID,N3(e,"y")),a=t.rAxisID=Wn(r.rAxisID,N3(e,"r")),l=t.indexAxis,c=t.iAxisID=s(l,i,o,a),u=t.vAxisID=s(l,o,i,a);t.xScale=this.getScaleForId(i),t.yScale=this.getScaleForId(o),t.rScale=this.getScaleForId(a),t.iScale=this.getScaleForId(c),t.vScale=this.getScaleForId(u)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&F6(this._data,this),e._stacked&&Gx(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),r=this._data;if(sr(t))this._data=oit(t);else if(r!==t){if(r){F6(r,this);const s=this._cachedMeta;Gx(s),s._parsed=[]}t&&Object.isExtensible(t)&&Zrt(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,r=this.getDataset();let s=!1;this._dataCheck();const i=t._stacked;t._stacked=Q6(t.vScale,t),t.stack!==r.stack&&(s=!0,Gx(t),t.stack=r.stack),this._resyncElements(e),(s||i!==t._stacked)&&t5(this,t._parsed)}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),r=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(r,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:r,_data:s}=this,{iScale:i,_stacked:o}=r,a=i.axis;let l=e===0&&t===s.length?!0:r._sorted,c=e>0&&r._parsed[e-1],u,h,f;if(this._parsing===!1)r._parsed=s,r._sorted=!0,f=s;else{gs(s[e])?f=this.parseArrayData(r,s,e,t):sr(s[e])?f=this.parseObjectData(r,s,e,t):f=this.parsePrimitiveData(r,s,e,t);const d=()=>h[a]===null||c&&h[a]<c[a];for(u=0;u<t;++u)r._parsed[u+e]=h=f[u],l&&(d()&&(l=!1),c=h);r._sorted=l}o&&t5(this,f)}parsePrimitiveData(e,t,r,s){const{iScale:i,vScale:o}=e,a=i.axis,l=o.axis,c=i.getLabels(),u=i===o,h=new Array(s);let f,d,p;for(f=0,d=s;f<d;++f)p=f+r,h[f]={[a]:u||i.parse(c[p],p),[l]:o.parse(t[p],p)};return h}parseArrayData(e,t,r,s){const{xScale:i,yScale:o}=e,a=new Array(s);let l,c,u,h;for(l=0,c=s;l<c;++l)u=l+r,h=t[u],a[l]={x:i.parse(h[0],u),y:o.parse(h[1],u)};return a}parseObjectData(e,t,r,s){const{xScale:i,yScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=new Array(s);let u,h,f,d;for(u=0,h=s;u<h;++u)f=u+r,d=t[f],c[u]={x:i.parse(up(d,a),f),y:o.parse(up(d,l),f)};return c}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,r){const s=this.chart,i=this._cachedMeta,o=t[e.axis],a={keys:yse(s,!0),values:t._stacks[e.axis]._visualValues};return J6(a,o,i.index,{mode:r})}updateRangeFromParsed(e,t,r,s){const i=r[t.axis];let o=i===null?NaN:i;const a=s&&r._stacks[t.axis];s&&a&&(s.values=a,o=J6(s,i,this._cachedMeta.index)),e.min=Math.min(e.min,o),e.max=Math.max(e.max,o)}getMinMax(e,t){const r=this._cachedMeta,s=r._parsed,i=r._sorted&&e===r.iScale,o=s.length,a=this._getOtherScale(e),l=fit(t,r,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:u,max:h}=lit(a);let f,d;function p(){d=s[f];const m=d[a.axis];return!Ys(d[e.axis])||u>m||h<m}for(f=0;f<o&&!(!p()&&(this.updateRangeFromParsed(c,e,d,l),i));++f);if(i){for(f=o-1;f>=0;--f)if(!p()){this.updateRangeFromParsed(c,e,d,l);break}}return c}getAllParsedValues(e){const t=this._cachedMeta._parsed,r=[];let s,i,o;for(s=0,i=t.length;s<i;++s)o=t[s][e.axis],Ys(o)&&r.push(o);return r}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,r=t.iScale,s=t.vScale,i=this.getParsed(e);return{label:r?""+r.getLabelForValue(i[r.axis]):"",value:s?""+s.getLabelForValue(i[s.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=iit(Wn(this.options.clip,sit(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,r=this._cachedMeta,s=r.data||[],i=t.chartArea,o=[],a=this._drawStart||0,l=this._drawCount||s.length-a,c=this.options.drawActiveElementsOnTop;let u;for(r.dataset&&r.dataset.draw(e,i,a,l),u=a;u<a+l;++u){const h=s[u];h.hidden||(h.active&&c?o.push(h):h.draw(e,i))}for(u=0;u<o.length;++u)o[u].draw(e,i)}getStyle(e,t){const r=t?"active":"default";return e===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(r):this.resolveDataElementOptions(e||0,r)}getContext(e,t,r){const s=this.getDataset();let i;if(e>=0&&e<this._cachedMeta.data.length){const o=this._cachedMeta.data[e];i=o.$context||(o.$context=hit(this.getContext(),e,o)),i.parsed=this.getParsed(e),i.raw=s.data[e],i.index=i.dataIndex=e}else i=this.$context||(this.$context=uit(this.chart.getContext(),this.index)),i.dataset=s,i.index=i.datasetIndex=this.index;return i.active=!!t,i.mode=r,i}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e,t="default",r){const s=t==="active",i=this._cachedDataOpts,o=e+"-"+t,a=i[o],l=this.enableOptionSharing&&Mc(r);if(a)return n5(a,l);const c=this.chart.config,u=c.datasetElementScopeKeys(this._type,e),h=s?[`${e}Hover`,"hover",e,""]:[e,""],f=c.getOptionScopes(this.getDataset(),u),d=Object.keys(oi.elements[e]),p=()=>this.getContext(r,s,t),m=c.resolveNamedOptions(f,d,p,h);return m.$shared&&(m.$shared=l,i[o]=Object.freeze(n5(m,l))),m}_resolveAnimations(e,t,r){const s=this.chart,i=this._cachedDataOpts,o=`animation-${t}`,a=i[o];if(a)return a;let l;if(s.options.animation!==!1){const u=this.chart.config,h=u.datasetAnimationScopeKeys(this._type,t),f=u.getOptionScopes(this.getDataset(),h);l=u.createResolver(f,this.getContext(e,r,t))}const c=new gse(s,l&&l.animations);return l&&l._cacheable&&(i[o]=Object.freeze(c)),c}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||$3(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const r=this.resolveDataElementOptions(e,t),s=this._sharedOptions,i=this.getSharedOptions(r),o=this.includeOptions(t,i)||i!==s;return this.updateSharedOptions(i,t,r),{sharedOptions:i,includeOptions:o}}updateElement(e,t,r,s){$3(s)?Object.assign(e,r):this._resolveAnimations(t,s).update(e,r)}updateSharedOptions(e,t,r){e&&!$3(t)&&this._resolveAnimations(void 0,t).update(e,r)}_setStyle(e,t,r,s){e.active=s;const i=this.getStyle(t,s);this._resolveAnimations(t,r,s).update(e,{options:!s&&this.getSharedOptions(i)||i})}removeHoverStyle(e,t,r){this._setStyle(e,r,"active",!1)}setHoverStyle(e,t,r){this._setStyle(e,r,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,r=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const s=r.length,i=t.length,o=Math.min(i,s);o&&this.parse(0,o),i>s?this._insertElements(s,i-s,e):i<s&&this._removeElements(i,s-i)}_insertElements(e,t,r=!0){const s=this._cachedMeta,i=s.data,o=e+t;let a;const l=c=>{for(c.length+=t,a=c.length-1;a>=o;a--)c[a]=c[a-t]};for(l(i),a=e;a<o;++a)i[a]=new this.dataElementType;this._parsing&&l(s._parsed),this.parse(e,t),r&&this.updateElements(i,e,t,"reset")}updateElements(e,t,r,s){}_removeElements(e,t){const r=this._cachedMeta;if(this._parsing){const s=r._parsed.splice(e,t);r._stacked&&Gx(r,s)}r.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,r,s]=e;this[t](r,s)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const r=arguments.length-2;r&&this._sync(["_insertElements",e,r])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}zt(bu,"defaults",{}),zt(bu,"datasetElementType",null),zt(bu,"dataElementType",null);function dit(n,e){if(!n._cache.$bar){const t=n.getMatchingVisibleMetas(e);let r=[];for(let s=0,i=t.length;s<i;s++)r=r.concat(t[s].controller.getAllParsedValues(n));n._cache.$bar=Kre(r.sort((s,i)=>s-i))}return n._cache.$bar}function pit(n){const e=n.iScale,t=dit(e,n.type);let r=e._length,s,i,o,a;const l=()=>{o===32767||o===-32768||(Mc(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,i=t.length;s<i;++s)o=e.getPixelForValue(t[s]),l();for(a=void 0,s=0,i=e.ticks.length;s<i;++s)o=e.getPixelForTick(s),l();return r}function mit(n,e,t,r){const s=t.barThickness;let i,o;return Nr(s)?(i=e.min*t.categoryPercentage,o=t.barPercentage):(i=s*r,o=1),{chunk:i/r,ratio:o,start:e.pixels[n]-i/2}}function git(n,e,t,r){const s=e.pixels,i=s[n];let o=n>0?s[n-1]:null,a=n<s.length-1?s[n+1]:null;const l=t.categoryPercentage;o===null&&(o=i-(a===null?e.end-e.start:a-i)),a===null&&(a=i+i-o);const c=i-(i-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/r,ratio:t.barPercentage,start:c}}function yit(n,e,t,r){const s=t.parse(n[0],r),i=t.parse(n[1],r),o=Math.min(s,i),a=Math.max(s,i);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),e[t.axis]=c,e._custom={barStart:l,barEnd:c,start:s,end:i,min:o,max:a}}function bse(n,e,t,r){return gs(n)?yit(n,e,t,r):e[t.axis]=t.parse(n,r),e}function r5(n,e,t,r){const s=n.iScale,i=n.vScale,o=s.getLabels(),a=s===i,l=[];let c,u,h,f;for(c=t,u=t+r;c<u;++c)f=e[c],h={},h[s.axis]=a||s.parse(o[c],c),l.push(bse(f,h,i,c));return l}function R3(n){return n&&n.barStart!==void 0&&n.barEnd!==void 0}function bit(n,e,t){return n!==0?vh(n):(e.isHorizontal()?1:-1)*(e.min>=t?1:-1)}function vit(n){let e,t,r,s,i;return n.horizontal?(e=n.base>n.x,t="left",r="right"):(e=n.base<n.y,t="bottom",r="top"),e?(s="end",i="start"):(s="start",i="end"),{start:t,end:r,reverse:e,top:s,bottom:i}}function wit(n,e,t,r){let s=e.borderSkipped;const i={};if(!s){n.borderSkipped=i;return}if(s===!0){n.borderSkipped={top:!0,right:!0,bottom:!0,left:!0};return}const{start:o,end:a,reverse:l,top:c,bottom:u}=vit(n);s==="middle"&&t&&(n.enableBorderRadius=!0,(t._top||0)===r?s=c:(t._bottom||0)===r?s=u:(i[s5(u,o,a,l)]=!0,s=c)),i[s5(s,o,a,l)]=!0,n.borderSkipped=i}function s5(n,e,t,r){return r?(n=xit(n,e,t),n=i5(n,t,e)):n=i5(n,e,t),n}function xit(n,e,t){return n===e?t:n===t?e:n}function i5(n,e,t){return n==="start"?e:n==="end"?t:n}function Sit(n,{inflateAmount:e},t){n.inflateAmount=e==="auto"?t===1?.33:0:e}class LE extends bu{parsePrimitiveData(e,t,r,s){return r5(e,t,r,s)}parseArrayData(e,t,r,s){return r5(e,t,r,s)}parseObjectData(e,t,r,s){const{iScale:i,vScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=i.axis==="x"?a:l,u=o.axis==="x"?a:l,h=[];let f,d,p,m;for(f=r,d=r+s;f<d;++f)m=t[f],p={},p[i.axis]=i.parse(up(m,c),f),h.push(bse(up(m,u),p,o,f));return h}updateRangeFromParsed(e,t,r,s){super.updateRangeFromParsed(e,t,r,s);const i=r._custom;i&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,i.min),e.max=Math.max(e.max,i.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:r,vScale:s}=t,i=this.getParsed(e),o=i._custom,a=R3(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(i[s.axis]);return{label:""+r.getLabelForValue(i[r.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const e=this._cachedMeta;e.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,r,s){const i=s==="reset",{index:o,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),u=this._getRuler(),{sharedOptions:h,includeOptions:f}=this._getSharedOptions(t,s);for(let d=t;d<t+r;d++){const p=this.getParsed(d),m=i||Nr(p[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(d),g=this._calculateBarIndexPixels(d,u),y=(p._stacks||{})[a.axis],b={horizontal:c,base:m.base,enableBorderRadius:!y||R3(p._custom)||o===y._top||o===y._bottom,x:c?m.head:g.center,y:c?g.center:m.head,height:c?g.size:Math.abs(m.size),width:c?Math.abs(m.size):g.size};f&&(b.options=h||this.resolveDataElementOptions(d,e[d].active?"active":s));const x=b.options||e[d].options;wit(b,x,y,o),Sit(b,x,u.ratio),this.updateElement(e[d],d,b,s)}}_getStacks(e,t){const{iScale:r}=this._cachedMeta,s=r.getMatchingVisibleMetas(this._type).filter(l=>l.controller.options.grouped),i=r.options.stacked,o=[],a=l=>{const c=l.controller.getParsed(t),u=c&&c[l.vScale.axis];if(Nr(u)||isNaN(u))return!0};for(const l of s)if(!(t!==void 0&&a(l))&&((i===!1||o.indexOf(l.stack)===-1||i===void 0&&l.stack===void 0)&&o.push(l.stack),l.index===e))break;return o.length||o.push(void 0),o}_getStackCount(e){return this._getStacks(void 0,e).length}_getStackIndex(e,t,r){const s=this._getStacks(e,r),i=t!==void 0?s.indexOf(t):-1;return i===-1?s.length-1:i}_getRuler(){const e=this.options,t=this._cachedMeta,r=t.iScale,s=[];let i,o;for(i=0,o=t.data.length;i<o;++i)s.push(r.getPixelForValue(this.getParsed(i)[r.axis],i));const a=e.barThickness;return{min:a||pit(t),pixels:s,start:r._startPixel,end:r._endPixel,stackCount:this._getStackCount(),scale:r,grouped:e.grouped,ratio:a?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:r,index:s},options:{base:i,minBarLength:o}}=this,a=i||0,l=this.getParsed(e),c=l._custom,u=R3(c);let h=l[t.axis],f=0,d=r?this.applyStack(t,l,r):h,p,m;d!==h&&(f=d-h,d=h),u&&(h=c.barStart,d=c.barEnd-c.barStart,h!==0&&vh(h)!==vh(c.barEnd)&&(f=0),f+=h);const g=!Nr(i)&&!u?i:f;let y=t.getPixelForValue(g);if(this.chart.getDataVisibility(e)?p=t.getPixelForValue(f+d):p=y,m=p-y,Math.abs(m)<o){m=bit(m,t,a)*o,h===a&&(y-=m/2);const b=t.getPixelForDecimal(0),x=t.getPixelForDecimal(1),w=Math.min(b,x),_=Math.max(b,x);y=Math.max(Math.min(y,_),w),p=y+m,r&&!u&&(l._stacks[t.axis]._visualValues[s]=t.getValueForPixel(p)-t.getValueForPixel(y))}if(y===t.getPixelForValue(a)){const b=vh(m)*t.getLineWidthForValue(a)/2;y+=b,m-=b}return{size:m,base:y,head:p,center:p+m/2}}_calculateBarIndexPixels(e,t){const r=t.scale,s=this.options,i=s.skipNull,o=Wn(s.maxBarThickness,1/0);let a,l;if(t.grouped){const c=i?this._getStackCount(e):t.stackCount,u=s.barThickness==="flex"?git(e,t,s,c):mit(e,t,s,c),h=this._getStackIndex(this.index,this._cachedMeta.stack,i?e:void 0);a=u.start+u.chunk*h+u.chunk/2,l=Math.min(o,u.chunk*u.ratio)}else a=r.getPixelForValue(this.getParsed(e)[r.axis],e),l=Math.min(o,t.min*t.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const e=this._cachedMeta,t=e.vScale,r=e.data,s=r.length;let i=0;for(;i<s;++i)this.getParsed(i)[t.axis]!==null&&r[i].draw(this._ctx)}}zt(LE,"id","bar"),zt(LE,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),zt(LE,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class zE extends bu{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,r,s){const i=super.parsePrimitiveData(e,t,r,s);for(let o=0;o<i.length;o++)i[o]._custom=this.resolveDataElementOptions(o+r).radius;return i}parseArrayData(e,t,r,s){const i=super.parseArrayData(e,t,r,s);for(let o=0;o<i.length;o++){const a=t[r+o];i[o]._custom=Wn(a[2],this.resolveDataElementOptions(o+r).radius)}return i}parseObjectData(e,t,r,s){const i=super.parseObjectData(e,t,r,s);for(let o=0;o<i.length;o++){const a=t[r+o];i[o]._custom=Wn(a&&a.r&&+a.r,this.resolveDataElementOptions(o+r).radius)}return i}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let r=e.length-1;r>=0;--r)t=Math.max(t,e[r].size(this.resolveDataElementOptions(r))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:s,yScale:i}=t,o=this.getParsed(e),a=s.getLabelForValue(o.x),l=i.getLabelForValue(o.y),c=o._custom;return{label:r[e]||"",value:"("+a+", "+l+(c?", "+c:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:l,includeOptions:c}=this._getSharedOptions(t,s),u=o.axis,h=a.axis;for(let f=t;f<t+r;f++){const d=e[f],p=!i&&this.getParsed(f),m={},g=m[u]=i?o.getPixelForDecimal(.5):o.getPixelForValue(p[u]),y=m[h]=i?a.getBasePixel():a.getPixelForValue(p[h]);m.skip=isNaN(g)||isNaN(y),c&&(m.options=l||this.resolveDataElementOptions(f,d.active?"active":s),i&&(m.options.radius=0)),this.updateElement(d,f,m,s)}}resolveDataElementOptions(e,t){const r=this.getParsed(e);let s=super.resolveDataElementOptions(e,t);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const i=s.radius;return t!=="active"&&(s.radius=0),s.radius+=Wn(r&&r._custom,i),s}}zt(zE,"id","bubble"),zt(zE,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),zt(zE,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});function _it(n,e,t){let r=1,s=1,i=0,o=0;if(e<bs){const a=n,l=a+e,c=Math.cos(a),u=Math.sin(a),h=Math.cos(l),f=Math.sin(l),d=(x,w,_)=>qS(x,a,l,!0)?1:Math.max(w,w*t,_,_*t),p=(x,w,_)=>qS(x,a,l,!0)?-1:Math.min(w,w*t,_,_*t),m=d(0,c,h),g=d(Zs,u,f),y=p(Es,c,h),b=p(Es+Zs,u,f);r=(m-y)/2,s=(g-b)/2,i=-(m+y)/2,o=-(g+b)/2}return{ratioX:r,ratioY:s,offsetX:i,offsetY:o}}class vb extends bu{constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const r=this.getDataset().data,s=this._cachedMeta;if(this._parsing===!1)s._parsed=r;else{let i=l=>+r[l];if(sr(r[e])){const{key:l="value"}=this._parsing;i=c=>+up(r[c],l)}let o,a;for(o=e,a=e+t;o<a;++o)s._parsed[o]=i(o)}}_getRotation(){return fu(this.options.rotation-90)}_getCircumference(){return fu(this.options.circumference)}_getRotationExtents(){let e=bs,t=-bs;for(let r=0;r<this.chart.data.datasets.length;++r)if(this.chart.isDatasetVisible(r)&&this.chart.getDatasetMeta(r).type===this._type){const s=this.chart.getDatasetMeta(r).controller,i=s._getRotation(),o=s._getCircumference();e=Math.min(e,i),t=Math.max(t,i+o)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:r}=t,s=this._cachedMeta,i=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(i)+this.options.spacing,a=Math.max((Math.min(r.width,r.height)-o)/2,0),l=Math.min(Frt(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:u,rotation:h}=this._getRotationExtents(),{ratioX:f,ratioY:d,offsetX:p,offsetY:m}=_it(h,u,l),g=(r.width-o)/f,y=(r.height-o)/d,b=Math.max(Math.min(g,y)/2,0),x=Gre(this.options.radius,b),w=Math.max(x*l,0),_=(x-w)/this._getVisibleDatasetWeightTotal();this.offsetX=p*x,this.offsetY=m*x,s.total=this.calculateTotal(),this.outerRadius=x-_*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-_*c,0),this.updateElements(i,0,i.length,e)}_circumference(e,t){const r=this.options,s=this._cachedMeta,i=this._getCircumference();return t&&r.animation.animateRotate||!this.chart.getDataVisibility(e)||s._parsed[e]===null||s.data[e].hidden?0:this.calculateCircumference(s._parsed[e]*i/bs)}updateElements(e,t,r,s){const i=s==="reset",o=this.chart,a=o.chartArea,c=o.options.animation,u=(a.left+a.right)/2,h=(a.top+a.bottom)/2,f=i&&c.animateScale,d=f?0:this.innerRadius,p=f?0:this.outerRadius,{sharedOptions:m,includeOptions:g}=this._getSharedOptions(t,s);let y=this._getRotation(),b;for(b=0;b<t;++b)y+=this._circumference(b,i);for(b=t;b<t+r;++b){const x=this._circumference(b,i),w=e[b],_={x:u+this.offsetX,y:h+this.offsetY,startAngle:y,endAngle:y+x,circumference:x,outerRadius:p,innerRadius:d};g&&(_.options=m||this.resolveDataElementOptions(b,w.active?"active":s)),y+=x,this.updateElement(w,b,_,s)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let r=0,s;for(s=0;s<t.length;s++){const i=e._parsed[s];i!==null&&!isNaN(i)&&this.chart.getDataVisibility(s)&&!t[s].hidden&&(r+=Math.abs(i))}return r}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?bs*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,s=r.data.labels||[],i=AC(t._parsed[e],r.options.locale);return{label:s[e]||"",value:i}}getMaxBorderWidth(e){let t=0;const r=this.chart;let s,i,o,a,l;if(!e){for(s=0,i=r.data.datasets.length;s<i;++s)if(r.isDatasetVisible(s)){o=r.getDatasetMeta(s),e=o.data,a=o.controller;break}}if(!e)return 0;for(s=0,i=e.length;s<i;++s)l=a.resolveDataElementOptions(s),l.borderAlign!=="inner"&&(t=Math.max(t,l.borderWidth||0,l.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let r=0,s=e.length;r<s;++r){const i=this.resolveDataElementOptions(r);t=Math.max(t,i.offset||0,i.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let r=0;r<e;++r)this.chart.isDatasetVisible(r)&&(t+=this._getRingWeight(r));return t}_getRingWeight(e){return Math.max(Wn(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}zt(vb,"id","doughnut"),zt(vb,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),zt(vb,"descriptors",{_scriptable:e=>e!=="spacing",_indexable:e=>e!=="spacing"}),zt(vb,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:s}}=e.legend.options;return t.labels.map((i,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:i,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:s,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}}});class BE extends bu{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:r,data:s=[],_dataset:i}=t,o=this.chart._animationsDisabled;let{start:a,count:l}=Jre(t,s,o);this._drawStart=a,this._drawCount=l,Qre(t)&&(a=0,l=s.length),r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!i._decimated,r.points=s;const c=this.resolveDatasetElementOptions(e);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(r,void 0,{animated:!o,options:c},e),this.updateElements(s,a,l,e)}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,{sharedOptions:u,includeOptions:h}=this._getSharedOptions(t,s),f=o.axis,d=a.axis,{spanGaps:p,segment:m}=this.options,g=rv(p)?p:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||i||s==="none",b=t+r,x=e.length;let w=t>0&&this.getParsed(t-1);for(let _=0;_<x;++_){const C=e[_],k=y?C:{};if(_<t||_>=b){k.skip=!0;continue}const A=this.getParsed(_),M=Nr(A[d]),I=k[f]=o.getPixelForValue(A[f],_),N=k[d]=i||M?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,A,l):A[d],_);k.skip=isNaN(I)||isNaN(N)||M,k.stop=_>0&&Math.abs(A[f]-w[f])>g,m&&(k.parsed=A,k.raw=c.data[_]),h&&(k.options=u||this.resolveDataElementOptions(_,C.active?"active":s)),y||this.updateElement(C,_,k,s),w=A}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,r=t.options&&t.options.borderWidth||0,s=e.data||[];if(!s.length)return r;const i=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(r,i,o)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}zt(BE,"id","line"),zt(BE,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),zt(BE,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class VE extends bu{constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,s=r.data.labels||[],i=AC(t._parsed[e].r,r.options.locale);return{label:s[e]||"",value:i}}parseObjectData(e,t,r,s){return lse.bind(this)(e,t,r,s)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach((r,s)=>{const i=this.getParsed(s).r;!isNaN(i)&&this.chart.getDataVisibility(s)&&(i<t.min&&(t.min=i),i>t.max&&(t.max=i))}),t}_updateRadius(){const e=this.chart,t=e.chartArea,r=e.options,s=Math.min(t.right-t.left,t.bottom-t.top),i=Math.max(s/2,0),o=Math.max(r.cutoutPercentage?i/100*r.cutoutPercentage:1,0),a=(i-o)/e.getVisibleDatasetCount();this.outerRadius=i-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(e,t,r,s){const i=s==="reset",o=this.chart,l=o.options.animation,c=this._cachedMeta.rScale,u=c.xCenter,h=c.yCenter,f=c.getIndexAngle(0)-.5*Es;let d=f,p;const m=360/this.countVisibleElements();for(p=0;p<t;++p)d+=this._computeAngle(p,s,m);for(p=t;p<t+r;p++){const g=e[p];let y=d,b=d+this._computeAngle(p,s,m),x=o.getDataVisibility(p)?c.getDistanceFromCenterForValue(this.getParsed(p).r):0;d=b,i&&(l.animateScale&&(x=0),l.animateRotate&&(y=b=f));const w={x:u,y:h,innerRadius:0,outerRadius:x,startAngle:y,endAngle:b,options:this.resolveDataElementOptions(p,g.active?"active":s)};this.updateElement(g,p,w,s)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach((r,s)=>{!isNaN(this.getParsed(s).r)&&this.chart.getDataVisibility(s)&&t++}),t}_computeAngle(e,t,r){return this.chart.getDataVisibility(e)?fu(this.resolveDataElementOptions(e,t).angle||r):0}}zt(VE,"id","polarArea"),zt(VE,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),zt(VE,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:s}}=e.legend.options;return t.labels.map((i,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:i,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:s,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class ZO extends vb{}zt(ZO,"id","pie"),zt(ZO,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class UE extends bu{getLabelAndValue(e){const t=this._cachedMeta.vScale,r=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(r[t.axis])}}parseObjectData(e,t,r,s){return lse.bind(this)(e,t,r,s)}update(e){const t=this._cachedMeta,r=t.dataset,s=t.data||[],i=t.iScale.getLabels();if(r.points=s,e!=="resize"){const o=this.resolveDatasetElementOptions(e);this.options.showLine||(o.borderWidth=0);const a={_loop:!0,_fullLoop:i.length===s.length,options:o};this.updateElement(r,void 0,a,e)}this.updateElements(s,0,s.length,e)}updateElements(e,t,r,s){const i=this._cachedMeta.rScale,o=s==="reset";for(let a=t;a<t+r;a++){const l=e[a],c=this.resolveDataElementOptions(a,l.active?"active":s),u=i.getPointPositionForValue(a,this.getParsed(a).r),h=o?i.xCenter:u.x,f=o?i.yCenter:u.y,d={x:h,y:f,angle:u.angle,skip:isNaN(h)||isNaN(f),options:c};this.updateElement(l,a,d,s)}}}zt(UE,"id","radar"),zt(UE,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),zt(UE,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class WE extends bu{getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:s,yScale:i}=t,o=this.getParsed(e),a=s.getLabelForValue(o.x),l=i.getLabelForValue(o.y);return{label:r[e]||"",value:"("+a+", "+l+")"}}update(e){const t=this._cachedMeta,{data:r=[]}=t,s=this.chart._animationsDisabled;let{start:i,count:o}=Jre(t,r,s);if(this._drawStart=i,this._drawCount=o,Qre(t)&&(i=0,o=r.length),this.options.showLine){const{dataset:a,_dataset:l}=t;a._chart=this.chart,a._datasetIndex=this.index,a._decimated=!!l._decimated,a.points=r;const c=this.resolveDatasetElementOptions(e);c.segment=this.options.segment,this.updateElement(a,void 0,{animated:!s,options:c},e)}this.updateElements(r,i,o,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,u=this.resolveDataElementOptions(t,s),h=this.getSharedOptions(u),f=this.includeOptions(s,h),d=o.axis,p=a.axis,{spanGaps:m,segment:g}=this.options,y=rv(m)?m:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||i||s==="none";let x=t>0&&this.getParsed(t-1);for(let w=t;w<t+r;++w){const _=e[w],C=this.getParsed(w),k=b?_:{},A=Nr(C[p]),M=k[d]=o.getPixelForValue(C[d],w),I=k[p]=i||A?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,C,l):C[p],w);k.skip=isNaN(M)||isNaN(I)||A,k.stop=w>0&&Math.abs(C[d]-x[d])>y,g&&(k.parsed=C,k.raw=c.data[w]),f&&(k.options=h||this.resolveDataElementOptions(w,_.active?"active":s)),b||this.updateElement(_,w,k,s),x=C}this.updateSharedOptions(h,s,u)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let a=0;for(let l=t.length-1;l>=0;--l)a=Math.max(a,t[l].size(this.resolveDataElementOptions(l))/2);return a>0&&a}const r=e.dataset,s=r.options&&r.options.borderWidth||0;if(!t.length)return s;const i=t[0].size(this.resolveDataElementOptions(0)),o=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(s,i,o)/2}}zt(WE,"id","scatter"),zt(WE,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),zt(WE,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});function sm(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class M4{static override(e){Object.assign(M4.prototype,e)}constructor(e){this.options=e||{}}init(){}formats(){return sm()}parse(){return sm()}format(){return sm()}add(){return sm()}diff(){return sm()}startOf(){return sm()}endOf(){return sm()}}var vse={_date:M4};function Cit(n,e,t,r){const{controller:s,data:i,_sorted:o}=n,a=s._cachedMeta.iScale;if(a&&e===a.axis&&e!=="r"&&o&&i.length){const l=a._reversePixels?Krt:Fm;if(r){if(s._sharedOptions){const c=i[0],u=typeof c.getRange=="function"&&c.getRange(e);if(u){const h=l(i,e,t-u),f=l(i,e,t+u);return{lo:h.lo,hi:f.hi}}}}else return l(i,e,t)}return{lo:0,hi:i.length-1}}function MC(n,e,t,r,s){const i=n.getSortedVisibleDatasetMetas(),o=t[e];for(let a=0,l=i.length;a<l;++a){const{index:c,data:u}=i[a],{lo:h,hi:f}=Cit(i[a],e,o,s);for(let d=h;d<=f;++d){const p=u[d];p.skip||r(p,c,d)}}}function kit(n){const e=n.indexOf("x")!==-1,t=n.indexOf("y")!==-1;return function(r,s){const i=e?Math.abs(r.x-s.x):0,o=t?Math.abs(r.y-s.y):0;return Math.sqrt(Math.pow(i,2)+Math.pow(o,2))}}function P3(n,e,t,r,s){const i=[];return!s&&!n.isPointInArea(e)||MC(n,t,e,function(a,l,c){!s&&!XS(a,n.chartArea,0)||a.inRange(e.x,e.y,r)&&i.push({element:a,datasetIndex:l,index:c})},!0),i}function Tit(n,e,t,r){let s=[];function i(o,a,l){const{startAngle:c,endAngle:u}=o.getProps(["startAngle","endAngle"],r),{angle:h}=qre(o,{x:e.x,y:e.y});qS(h,c,u)&&s.push({element:o,datasetIndex:a,index:l})}return MC(n,t,e,i),s}function Eit(n,e,t,r,s,i){let o=[];const a=kit(t);let l=Number.POSITIVE_INFINITY;function c(u,h,f){const d=u.inRange(e.x,e.y,s);if(r&&!d)return;const p=u.getCenterPoint(s);if(!(!!i||n.isPointInArea(p))&&!d)return;const g=a(e,p);g<l?(o=[{element:u,datasetIndex:h,index:f}],l=g):g===l&&o.push({element:u,datasetIndex:h,index:f})}return MC(n,t,e,c),o}function D3(n,e,t,r,s,i){return!i&&!n.isPointInArea(e)?[]:t==="r"&&!r?Tit(n,e,t,s):Eit(n,e,t,r,s,i)}function o5(n,e,t,r,s){const i=[],o=t==="x"?"inXRange":"inYRange";let a=!1;return MC(n,t,e,(l,c,u)=>{l[o](e[t],s)&&(i.push({element:l,datasetIndex:c,index:u}),a=a||l.inRange(e.x,e.y,s))}),r&&!a?[]:i}var Iit={evaluateInteractionItems:MC,modes:{index(n,e,t,r){const s=vm(e,n),i=t.axis||"x",o=t.includeInvisible||!1,a=t.intersect?P3(n,s,i,r,o):D3(n,s,i,!1,r,o),l=[];return a.length?(n.getSortedVisibleDatasetMetas().forEach(c=>{const u=a[0].index,h=c.data[u];h&&!h.skip&&l.push({element:h,datasetIndex:c.index,index:u})}),l):[]},dataset(n,e,t,r){const s=vm(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;let a=t.intersect?P3(n,s,i,r,o):D3(n,s,i,!1,r,o);if(a.length>0){const l=a[0].datasetIndex,c=n.getDatasetMeta(l).data;a=[];for(let u=0;u<c.length;++u)a.push({element:c[u],datasetIndex:l,index:u})}return a},point(n,e,t,r){const s=vm(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;return P3(n,s,i,r,o)},nearest(n,e,t,r){const s=vm(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;return D3(n,s,i,t.intersect,r,o)},x(n,e,t,r){const s=vm(e,n);return o5(n,s,"x",t.intersect,r)},y(n,e,t,r){const s=vm(e,n);return o5(n,s,"y",t.intersect,r)}}};const wse=["left","top","right","bottom"];function Hx(n,e){return n.filter(t=>t.pos===e)}function a5(n,e){return n.filter(t=>wse.indexOf(t.pos)===-1&&t.box.axis===e)}function jx(n,e){return n.sort((t,r)=>{const s=e?r:t,i=e?t:r;return s.weight===i.weight?s.index-i.index:s.weight-i.weight})}function Ait(n){const e=[];let t,r,s,i,o,a;for(t=0,r=(n||[]).length;t<r;++t)s=n[t],{position:i,options:{stack:o,stackWeight:a=1}}=s,e.push({index:t,box:s,pos:i,horizontal:s.isHorizontal(),weight:s.weight,stack:o&&i+o,stackWeight:a});return e}function Mit(n){const e={};for(const t of n){const{stack:r,pos:s,stackWeight:i}=t;if(!r||!wse.includes(s))continue;const o=e[r]||(e[r]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=i}return e}function Nit(n,e){const t=Mit(n),{vBoxMaxWidth:r,hBoxMaxHeight:s}=e;let i,o,a;for(i=0,o=n.length;i<o;++i){a=n[i];const{fullSize:l}=a.box,c=t[a.stack],u=c&&a.stackWeight/c.weight;a.horizontal?(a.width=u?u*r:l&&e.availableWidth,a.height=s):(a.width=r,a.height=u?u*s:l&&e.availableHeight)}return t}function $it(n){const e=Ait(n),t=jx(e.filter(c=>c.box.fullSize),!0),r=jx(Hx(e,"left"),!0),s=jx(Hx(e,"right")),i=jx(Hx(e,"top"),!0),o=jx(Hx(e,"bottom")),a=a5(e,"x"),l=a5(e,"y");return{fullSize:t,leftAndTop:r.concat(i),rightAndBottom:s.concat(l).concat(o).concat(a),chartArea:Hx(e,"chartArea"),vertical:r.concat(s).concat(l),horizontal:i.concat(o).concat(a)}}function l5(n,e,t,r){return Math.max(n[t],e[t])+Math.max(n[r],e[r])}function xse(n,e){n.top=Math.max(n.top,e.top),n.left=Math.max(n.left,e.left),n.bottom=Math.max(n.bottom,e.bottom),n.right=Math.max(n.right,e.right)}function Rit(n,e,t,r){const{pos:s,box:i}=t,o=n.maxPadding;if(!sr(s)){t.size&&(n[s]-=t.size);const h=r[t.stack]||{size:0,count:1};h.size=Math.max(h.size,t.horizontal?i.height:i.width),t.size=h.size/h.count,n[s]+=t.size}i.getPadding&&xse(o,i.getPadding());const a=Math.max(0,e.outerWidth-l5(o,n,"left","right")),l=Math.max(0,e.outerHeight-l5(o,n,"top","bottom")),c=a!==n.w,u=l!==n.h;return n.w=a,n.h=l,t.horizontal?{same:c,other:u}:{same:u,other:c}}function Pit(n){const e=n.maxPadding;function t(r){const s=Math.max(e[r]-n[r],0);return n[r]+=s,s}n.y+=t("top"),n.x+=t("left"),t("right"),t("bottom")}function Dit(n,e){const t=e.maxPadding;function r(s){const i={left:0,top:0,right:0,bottom:0};return s.forEach(o=>{i[o]=Math.max(e[o],t[o])}),i}return r(n?["left","right"]:["top","bottom"])}function T1(n,e,t,r){const s=[];let i,o,a,l,c,u;for(i=0,o=n.length,c=0;i<o;++i){a=n[i],l=a.box,l.update(a.width||e.w,a.height||e.h,Dit(a.horizontal,e));const{same:h,other:f}=Rit(e,t,a,r);c|=h&&s.length,u=u||f,l.fullSize||s.push(a)}return c&&T1(s,e,t,r)||u}function mT(n,e,t,r,s){n.top=t,n.left=e,n.right=e+r,n.bottom=t+s,n.width=r,n.height=s}function c5(n,e,t,r){const s=t.padding;let{x:i,y:o}=e;for(const a of n){const l=a.box,c=r[a.stack]||{count:1,placed:0,weight:1},u=a.stackWeight/c.weight||1;if(a.horizontal){const h=e.w*u,f=c.size||l.height;Mc(c.start)&&(o=c.start),l.fullSize?mT(l,s.left,o,t.outerWidth-s.right-s.left,f):mT(l,e.left+c.placed,o,h,f),c.start=o,c.placed+=h,o=l.bottom}else{const h=e.h*u,f=c.size||l.width;Mc(c.start)&&(i=c.start),l.fullSize?mT(l,i,s.top,f,t.outerHeight-s.bottom-s.top):mT(l,i,e.top+c.placed,f,h),c.start=i,c.placed+=h,i=l.right}}e.x=i,e.y=o}var vc={addBox(n,e){n.boxes||(n.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},n.boxes.push(e)},removeBox(n,e){const t=n.boxes?n.boxes.indexOf(e):-1;t!==-1&&n.boxes.splice(t,1)},configure(n,e,t){e.fullSize=t.fullSize,e.position=t.position,e.weight=t.weight},update(n,e,t,r){if(!n)return;const s=Yo(n.options.layout.padding),i=Math.max(e-s.width,0),o=Math.max(t-s.height,0),a=$it(n.boxes),l=a.vertical,c=a.horizontal;Dr(n.boxes,m=>{typeof m.beforeLayout=="function"&&m.beforeLayout()});const u=l.reduce((m,g)=>g.box.options&&g.box.options.display===!1?m:m+1,0)||1,h=Object.freeze({outerWidth:e,outerHeight:t,padding:s,availableWidth:i,availableHeight:o,vBoxMaxWidth:i/2/u,hBoxMaxHeight:o/2}),f=Object.assign({},s);xse(f,Yo(r));const d=Object.assign({maxPadding:f,w:i,h:o,x:s.left,y:s.top},s),p=Nit(l.concat(c),h);T1(a.fullSize,d,h,p),T1(l,d,h,p),T1(c,d,h,p)&&T1(l,d,h,p),Pit(d),c5(a.leftAndTop,d,h,p),d.x+=d.w,d.y+=d.h,c5(a.rightAndBottom,d,h,p),n.chartArea={left:d.left,top:d.top,right:d.left+d.w,bottom:d.top+d.h,height:d.h,width:d.w},Dr(a.chartArea,m=>{const g=m.box;Object.assign(g,n.chartArea),g.update(d.w,d.h,{left:0,top:0,right:0,bottom:0})})}};class Sse{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,r){}removeEventListener(e,t,r){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,r,s){return t=Math.max(0,t||e.width),r=r||e.height,{width:t,height:Math.max(0,s?Math.floor(t/s):r)}}isAttached(e){return!0}updateConfig(e){}}class Oit extends Sse{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const GE="$chartjs",Fit={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},u5=n=>n===null||n==="";function Lit(n,e){const t=n.style,r=n.getAttribute("height"),s=n.getAttribute("width");if(n[GE]={initial:{height:r,width:s,style:{display:t.display,height:t.height,width:t.width}}},t.display=t.display||"block",t.boxSizing=t.boxSizing||"border-box",u5(s)){const i=j6(n,"width");i!==void 0&&(n.width=i)}if(u5(r))if(n.style.height==="")n.height=n.width/(e||2);else{const i=j6(n,"height");i!==void 0&&(n.height=i)}return n}const _se=Ust?{passive:!0}:!1;function zit(n,e,t){n.addEventListener(e,t,_se)}function Bit(n,e,t){n.canvas.removeEventListener(e,t,_se)}function Vit(n,e){const t=Fit[n.type]||n.type,{x:r,y:s}=vm(n,e);return{type:t,chart:e,native:n,x:r!==void 0?r:null,y:s!==void 0?s:null}}function lA(n,e){for(const t of n)if(t===e||t.contains(e))return!0}function Uit(n,e,t){const r=n.canvas,s=new MutationObserver(i=>{let o=!1;for(const a of i)o=o||lA(a.addedNodes,r),o=o&&!lA(a.removedNodes,r);o&&t()});return s.observe(document,{childList:!0,subtree:!0}),s}function Wit(n,e,t){const r=n.canvas,s=new MutationObserver(i=>{let o=!1;for(const a of i)o=o||lA(a.removedNodes,r),o=o&&!lA(a.addedNodes,r);o&&t()});return s.observe(document,{childList:!0,subtree:!0}),s}const YS=new Map;let h5=0;function Cse(){const n=window.devicePixelRatio;n!==h5&&(h5=n,YS.forEach((e,t)=>{t.currentDevicePixelRatio!==n&&e()}))}function Git(n,e){YS.size||window.addEventListener("resize",Cse),YS.set(n,e)}function Hit(n){YS.delete(n),YS.size||window.removeEventListener("resize",Cse)}function jit(n,e,t){const r=n.canvas,s=r&&A4(r);if(!s)return;const i=Zre((a,l)=>{const c=s.clientWidth;t(a,l),c<s.clientWidth&&t()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,u=l.contentRect.height;c===0&&u===0||i(c,u)});return o.observe(s),Git(n,i),o}function O3(n,e,t){t&&t.disconnect(),e==="resize"&&Hit(n)}function qit(n,e,t){const r=n.canvas,s=Zre(i=>{n.ctx!==null&&t(Vit(i,n))},n);return zit(r,e,s),s}class Xit extends Sse{acquireContext(e,t){const r=e&&e.getContext&&e.getContext("2d");return r&&r.canvas===e?(Lit(e,t),r):null}releaseContext(e){const t=e.canvas;if(!t[GE])return!1;const r=t[GE].initial;["height","width"].forEach(i=>{const o=r[i];Nr(o)?t.removeAttribute(i):t.setAttribute(i,o)});const s=r.style||{};return Object.keys(s).forEach(i=>{t.style[i]=s[i]}),t.width=t.width,delete t[GE],!0}addEventListener(e,t,r){this.removeEventListener(e,t);const s=e.$proxies||(e.$proxies={}),o={attach:Uit,detach:Wit,resize:jit}[t]||qit;s[t]=o(e,t,r)}removeEventListener(e,t){const r=e.$proxies||(e.$proxies={}),s=r[t];if(!s)return;({attach:O3,detach:O3,resize:O3}[t]||Bit)(e,t,s),r[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,r,s){return Vst(e,t,r,s)}isAttached(e){const t=A4(e);return!!(t&&t.isConnected)}}function Kit(n){return!use()||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas?Oit:Xit}class Tu{constructor(){zt(this,"active",!1)}tooltipPosition(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}hasValue(){return rv(this.x)&&rv(this.y)}getProps(e,t){const r=this.$animations;if(!t||!r)return this;const s={};return e.forEach(i=>{s[i]=r[i]&&r[i].active()?r[i]._to:this[i]}),s}}zt(Tu,"defaults",{}),zt(Tu,"defaultRoutes");function Yit(n,e){const t=n.options.ticks,r=Zit(n),s=Math.min(t.maxTicksLimit||r,r),i=t.major.enabled?Qit(e):[],o=i.length,a=i[0],l=i[o-1],c=[];if(o>s)return eot(e,c,i,o/s),c;const u=Jit(i,e,s);if(o>0){let h,f;const d=o>1?Math.round((l-a)/(o-1)):null;for(gT(e,c,u,Nr(d)?0:a-d,a),h=0,f=o-1;h<f;h++)gT(e,c,u,i[h],i[h+1]);return gT(e,c,u,l,Nr(d)?e.length:l+d),c}return gT(e,c,u),c}function Zit(n){const e=n.options.offset,t=n._tickSize(),r=n._length/t+(e?0:1),s=n._maxLength/t;return Math.floor(Math.min(r,s))}function Jit(n,e,t){const r=tot(n),s=e.length/t;if(!r)return Math.max(s,1);const i=Hrt(r);for(let o=0,a=i.length-1;o<a;o++){const l=i[o];if(l>s)return l}return Math.max(s,1)}function Qit(n){const e=[];let t,r;for(t=0,r=n.length;t<r;t++)n[t].major&&e.push(t);return e}function eot(n,e,t,r){let s=0,i=t[0],o;for(r=Math.ceil(r),o=0;o<n.length;o++)o===i&&(e.push(n[o]),s++,i=t[s*r])}function gT(n,e,t,r,s){const i=Wn(r,0),o=Math.min(Wn(s,n.length),n.length);let a=0,l,c,u;for(t=Math.ceil(t),s&&(l=s-r,t=l/Math.floor(l/t)),u=i;u<0;)a++,u=Math.round(i+a*t);for(c=Math.max(i,0);c<o;c++)c===u&&(e.push(n[c]),a++,u=Math.round(i+a*t))}function tot(n){const e=n.length;let t,r;if(e<2)return!1;for(r=n[0],t=1;t<e;++t)if(n[t]-n[t-1]!==r)return!1;return r}const not=n=>n==="left"?"right":n==="right"?"left":n,f5=(n,e,t)=>e==="top"||e==="left"?n[e]+t:n[e]-t,d5=(n,e)=>Math.min(e||n,n);function p5(n,e){const t=[],r=n.length/e,s=n.length;let i=0;for(;i<s;i+=r)t.push(n[Math.floor(i)]);return t}function rot(n,e,t){const r=n.ticks.length,s=Math.min(e,r-1),i=n._startPixel,o=n._endPixel,a=1e-6;let l=n.getPixelForTick(s),c;if(!(t&&(r===1?c=Math.max(l-i,o-l):e===0?c=(n.getPixelForTick(1)-l)/2:c=(l-n.getPixelForTick(s-1))/2,l+=s<e?c:-c,l<i-a||l>o+a)))return l}function sot(n,e){Dr(n,t=>{const r=t.gc,s=r.length/2;let i;if(s>e){for(i=0;i<s;++i)delete t.data[r[i]];r.splice(0,s)}})}function qx(n){return n.drawTicks?n.tickLength:0}function m5(n,e){if(!n.display)return 0;const t=Wi(n.font,e),r=Yo(n.padding);return(gs(n.text)?n.text.length:1)*t.lineHeight+r.height}function iot(n,e){return Pp(n,{scale:e,type:"scale"})}function oot(n,e,t){return Pp(n,{tick:t,index:e,type:"tick"})}function aot(n,e,t){let r=C4(n);return(t&&e!=="right"||!t&&e==="right")&&(r=not(r)),r}function lot(n,e,t,r){const{top:s,left:i,bottom:o,right:a,chart:l}=n,{chartArea:c,scales:u}=l;let h=0,f,d,p;const m=o-s,g=a-i;if(n.isHorizontal()){if(d=Oo(r,i,a),sr(t)){const y=Object.keys(t)[0],b=t[y];p=u[y].getPixelForValue(b)+m-e}else t==="center"?p=(c.bottom+c.top)/2+m-e:p=f5(n,t,e);f=a-i}else{if(sr(t)){const y=Object.keys(t)[0],b=t[y];d=u[y].getPixelForValue(b)-g+e}else t==="center"?d=(c.left+c.right)/2-g+e:d=f5(n,t,e);p=Oo(r,o,s),h=t==="left"?-Zs:Zs}return{titleX:d,titleY:p,maxWidth:f,rotation:h}}class Xy extends Tu{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:r,_suggestedMax:s}=this;return e=yl(e,Number.POSITIVE_INFINITY),t=yl(t,Number.NEGATIVE_INFINITY),r=yl(r,Number.POSITIVE_INFINITY),s=yl(s,Number.NEGATIVE_INFINITY),{min:yl(e,r),max:yl(t,s),minDefined:Ys(e),maxDefined:Ys(t)}}getMinMax(e){let{min:t,max:r,minDefined:s,maxDefined:i}=this.getUserBounds(),o;if(s&&i)return{min:t,max:r};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,e),s||(t=Math.min(t,o.min)),i||(r=Math.max(r,o.max));return t=i&&t>r?r:t,r=s&&t>r?t:r,{min:yl(t,yl(r,t)),max:yl(r,yl(t,r))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(e=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){os(this.options.beforeUpdate,[this])}update(e,t,r){const{beginAtZero:s,grace:i,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=r=Object.assign({left:0,right:0,top:0,bottom:0},r),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+r.left+r.right:this.height+r.top+r.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=vst(this,i,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?p5(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||o.source==="auto")&&(this.ticks=Yit(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e=this.options.reverse,t,r;this.isHorizontal()?(t=this.left,r=this.right):(t=this.top,r=this.bottom,e=!e),this._startPixel=t,this._endPixel=r,this._reversePixels=e,this._length=r-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){os(this.options.afterUpdate,[this])}beforeSetDimensions(){os(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){os(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),os(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){os(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let r,s,i;for(r=0,s=e.length;r<s;r++)i=e[r],i.label=os(t.callback,[i.value,r,e],this)}afterTickToLabelConversion(){os(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){os(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,r=d5(this.ticks.length,e.ticks.maxTicksLimit),s=t.minRotation||0,i=t.maxRotation;let o=s,a,l,c;if(!this._isVisible()||!t.display||s>=i||r<=1||!this.isHorizontal()){this.labelRotation=s;return}const u=this._getLabelSizes(),h=u.widest.width,f=u.highest.height,d=jo(this.chart.width-h,0,this.maxWidth);a=e.offset?this.maxWidth/r:d/(r-1),h+6>a&&(a=d/(r-(e.offset?.5:1)),l=this.maxHeight-qx(e.grid)-t.padding-m5(e.title,this.chart.options.font),c=Math.sqrt(h*h+f*f),o=S4(Math.min(Math.asin(jo((u.highest.height+6)/a,-1,1)),Math.asin(jo(l/c,-1,1))-Math.asin(jo(f/c,-1,1)))),o=Math.max(s,Math.min(i,o))),this.labelRotation=o}afterCalculateLabelRotation(){os(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){os(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:r,title:s,grid:i}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=m5(s,t.options.font);if(a?(e.width=this.maxWidth,e.height=qx(i)+l):(e.height=this.maxHeight,e.width=qx(i)+l),r.display&&this.ticks.length){const{first:c,last:u,widest:h,highest:f}=this._getLabelSizes(),d=r.padding*2,p=fu(this.labelRotation),m=Math.cos(p),g=Math.sin(p);if(a){const y=r.mirror?0:g*h.width+m*f.height;e.height=Math.min(this.maxHeight,e.height+y+d)}else{const y=r.mirror?0:m*h.width+g*f.height;e.width=Math.min(this.maxWidth,e.width+y+d)}this._calculatePadding(c,u,g,m)}}this._handleMargins(),a?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,r,s){const{ticks:{align:i,padding:o},position:a}=this.options,l=this.labelRotation!==0,c=a!=="top"&&this.axis==="x";if(this.isHorizontal()){const u=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let f=0,d=0;l?c?(f=s*e.width,d=r*t.height):(f=r*e.height,d=s*t.width):i==="start"?d=t.width:i==="end"?f=e.width:i!=="inner"&&(f=e.width/2,d=t.width/2),this.paddingLeft=Math.max((f-u+o)*this.width/(this.width-u),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let u=t.height/2,h=e.height/2;i==="start"?(u=0,h=e.height):i==="end"&&(u=t.height,h=0),this.paddingTop=u+o,this.paddingBottom=h+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){os(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return t==="top"||t==="bottom"||e==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){this.beforeTickToLabelConversion(),this.generateTickLabels(e);let t,r;for(t=0,r=e.length;t<r;t++)Nr(e[t].label)&&(e.splice(t,1),r--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let r=this.ticks;t<r.length&&(r=p5(r,t)),this._labelSizes=e=this._computeLabelSizes(r,r.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,r){const{ctx:s,_longestTextCache:i}=this,o=[],a=[],l=Math.floor(t/d5(t,r));let c=0,u=0,h,f,d,p,m,g,y,b,x,w,_;for(h=0;h<t;h+=l){if(p=e[h].label,m=this._resolveTickFontOptions(h),s.font=g=m.string,y=i[g]=i[g]||{data:{},gc:[]},b=m.lineHeight,x=w=0,!Nr(p)&&!gs(p))x=oA(s,y.data,y.gc,x,p),w=b;else if(gs(p))for(f=0,d=p.length;f<d;++f)_=p[f],!Nr(_)&&!gs(_)&&(x=oA(s,y.data,y.gc,x,_),w+=b);o.push(x),a.push(w),c=Math.max(x,c),u=Math.max(w,u)}sot(i,t);const C=o.indexOf(c),k=a.indexOf(u),A=M=>({width:o[M]||0,height:a[M]||0});return{first:A(0),last:A(t-1),widest:A(C),highest:A(k),widths:o,heights:a}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return Xrt(this._alignToPixels?rm(this.chart,t,0):t)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const r=t[e];return r.$context||(r.$context=oot(this.getContext(),e,r))}return this.$context||(this.$context=iot(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=fu(this.labelRotation),r=Math.abs(Math.cos(t)),s=Math.abs(Math.sin(t)),i=this._getLabelSizes(),o=e.autoSkipPadding||0,a=i?i.widest.width+o:0,l=i?i.highest.height+o:0;return this.isHorizontal()?l*r>a*s?a/r:l/s:l*s<a*r?l/r:a/s}_isVisible(){const e=this.options.display;return e!=="auto"?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,r=this.chart,s=this.options,{grid:i,position:o,border:a}=s,l=i.offset,c=this.isHorizontal(),h=this.ticks.length+(l?1:0),f=qx(i),d=[],p=a.setContext(this.getContext()),m=p.display?p.width:0,g=m/2,y=function(B){return rm(r,B,m)};let b,x,w,_,C,k,A,M,I,N,O,R;if(o==="top")b=y(this.bottom),k=this.bottom-f,M=b-g,N=y(e.top)+g,R=e.bottom;else if(o==="bottom")b=y(this.top),N=e.top,R=y(e.bottom)-g,k=b+g,M=this.top+f;else if(o==="left")b=y(this.right),C=this.right-f,A=b-g,I=y(e.left)+g,O=e.right;else if(o==="right")b=y(this.left),I=e.left,O=y(e.right)-g,C=b+g,A=this.left+f;else if(t==="x"){if(o==="center")b=y((e.top+e.bottom)/2+.5);else if(sr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}N=e.top,R=e.bottom,k=b+g,M=k+f}else if(t==="y"){if(o==="center")b=y((e.left+e.right)/2);else if(sr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}C=b-g,A=C-f,I=e.left,O=e.right}const D=Wn(s.ticks.maxTicksLimit,h),z=Math.max(1,Math.ceil(h/D));for(x=0;x<h;x+=z){const B=this.getContext(x),X=i.setContext(B),G=a.setContext(B),ee=X.lineWidth,pe=X.color,oe=G.dash||[],Ne=G.dashOffset,ke=X.tickWidth,De=X.tickColor,ge=X.tickBorderDash||[],Xe=X.tickBorderDashOffset;w=rot(this,x,l),w!==void 0&&(_=rm(r,w,ee),c?C=A=I=O=_:k=M=N=R=_,d.push({tx1:C,ty1:k,tx2:A,ty2:M,x1:I,y1:N,x2:O,y2:R,width:ee,color:pe,borderDash:oe,borderDashOffset:Ne,tickWidth:ke,tickColor:De,tickBorderDash:ge,tickBorderDashOffset:Xe}))}return this._ticksLength=h,this._borderValue=b,d}_computeLabelItems(e){const t=this.axis,r=this.options,{position:s,ticks:i}=r,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:u,mirror:h}=i,f=qx(r.grid),d=f+u,p=h?-u:d,m=-fu(this.labelRotation),g=[];let y,b,x,w,_,C,k,A,M,I,N,O,R="middle";if(s==="top")C=this.bottom-p,k=this._getXAxisLabelAlignment();else if(s==="bottom")C=this.top+p,k=this._getXAxisLabelAlignment();else if(s==="left"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,_=z.x}else if(s==="right"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,_=z.x}else if(t==="x"){if(s==="center")C=(e.top+e.bottom)/2+d;else if(sr(s)){const z=Object.keys(s)[0],B=s[z];C=this.chart.scales[z].getPixelForValue(B)+d}k=this._getXAxisLabelAlignment()}else if(t==="y"){if(s==="center")_=(e.left+e.right)/2-d;else if(sr(s)){const z=Object.keys(s)[0],B=s[z];_=this.chart.scales[z].getPixelForValue(B)}k=this._getYAxisLabelAlignment(f).textAlign}t==="y"&&(l==="start"?R="top":l==="end"&&(R="bottom"));const D=this._getLabelSizes();for(y=0,b=a.length;y<b;++y){x=a[y],w=x.label;const z=i.setContext(this.getContext(y));A=this.getPixelForTick(y)+i.labelOffset,M=this._resolveTickFontOptions(y),I=M.lineHeight,N=gs(w)?w.length:1;const B=N/2,X=z.color,G=z.textStrokeColor,ee=z.textStrokeWidth;let pe=k;o?(_=A,k==="inner"&&(y===b-1?pe=this.options.reverse?"left":"right":y===0?pe=this.options.reverse?"right":"left":pe="center"),s==="top"?c==="near"||m!==0?O=-N*I+I/2:c==="center"?O=-D.highest.height/2-B*I+I:O=-D.highest.height+I/2:c==="near"||m!==0?O=I/2:c==="center"?O=D.highest.height/2-B*I:O=D.highest.height-N*I,h&&(O*=-1),m!==0&&!z.showLabelBackdrop&&(_+=I/2*Math.sin(m))):(C=A,O=(1-N)*I/2);let oe;if(z.showLabelBackdrop){const Ne=Yo(z.backdropPadding),ke=D.heights[y],De=D.widths[y];let ge=O-Ne.top,Xe=0-Ne.left;switch(R){case"middle":ge-=ke/2;break;case"bottom":ge-=ke;break}switch(k){case"center":Xe-=De/2;break;case"right":Xe-=De;break}oe={left:Xe,top:ge,width:De+Ne.width,height:ke+Ne.height,color:z.backdropColor}}g.push({label:w,font:M,textOffset:O,options:{rotation:m,color:X,strokeColor:G,strokeWidth:ee,textAlign:pe,textBaseline:R,translation:[_,C],backdrop:oe}})}return g}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-fu(this.labelRotation))return e==="top"?"left":"right";let s="center";return t.align==="start"?s="left":t.align==="end"?s="right":t.align==="inner"&&(s="inner"),s}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:r,mirror:s,padding:i}}=this.options,o=this._getLabelSizes(),a=e+i,l=o.widest.width;let c,u;return t==="left"?s?(u=this.right+i,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u+=l)):(u=this.right-a,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u=this.left)):t==="right"?s?(u=this.left+i,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u-=l)):(u=this.left+a,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u=this.right)):c="right",{textAlign:c,x:u}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;if(t==="left"||t==="right")return{top:0,left:this.left,bottom:e.height,right:this.right};if(t==="top"||t==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:e.width}}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:r,top:s,width:i,height:o}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(r,s,i,o),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const s=this.ticks.findIndex(i=>i.value===e);return s>=0?t.setContext(this.getContext(s)).lineWidth:0}drawGrid(e){const t=this.options.grid,r=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let i,o;const a=(l,c,u)=>{!u.width||!u.color||(r.save(),r.lineWidth=u.width,r.strokeStyle=u.color,r.setLineDash(u.borderDash||[]),r.lineDashOffset=u.borderDashOffset,r.beginPath(),r.moveTo(l.x,l.y),r.lineTo(c.x,c.y),r.stroke(),r.restore())};if(t.display)for(i=0,o=s.length;i<o;++i){const l=s[i];t.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),t.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:r,grid:s}}=this,i=r.setContext(this.getContext()),o=r.display?i.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,l=this._borderValue;let c,u,h,f;this.isHorizontal()?(c=rm(e,this.left,o)-o/2,u=rm(e,this.right,a)+a/2,h=f=l):(h=rm(e,this.top,o)-o/2,f=rm(e,this.bottom,a)+a/2,c=u=l),t.save(),t.lineWidth=i.width,t.strokeStyle=i.color,t.beginPath(),t.moveTo(c,h),t.lineTo(u,f),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const r=this.ctx,s=this._computeLabelArea();s&&p$(r,s);const i=this.getLabelItems(e);for(const o of i){const a=o.options,l=o.font,c=o.label,u=o.textOffset;gg(r,c,0,u,l,a)}s&&m$(r)}drawTitle(){const{ctx:e,options:{position:t,title:r,reverse:s}}=this;if(!r.display)return;const i=Wi(r.font),o=Yo(r.padding),a=r.align;let l=i.lineHeight/2;t==="bottom"||t==="center"||sr(t)?(l+=o.bottom,gs(r.text)&&(l+=i.lineHeight*(r.text.length-1))):l+=o.top;const{titleX:c,titleY:u,maxWidth:h,rotation:f}=lot(this,l,t,a);gg(e,r.text,0,0,i,{color:r.color,maxWidth:h,rotation:f,textAlign:aot(a,t,s),textBaseline:"middle",translation:[c,u]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,r=Wn(e.grid&&e.grid.z,-1),s=Wn(e.border&&e.border.z,0);return!this._isVisible()||this.draw!==Xy.prototype.draw?[{z:t,draw:i=>{this.draw(i)}}]:[{z:r,draw:i=>{this.drawBackground(),this.drawGrid(i),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:t,draw:i=>{this.drawLabels(i)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),r=this.axis+"AxisID",s=[];let i,o;for(i=0,o=t.length;i<o;++i){const a=t[i];a[r]===this.id&&(!e||a.type===e)&&s.push(a)}return s}_resolveTickFontOptions(e){const t=this.options.ticks.setContext(this.getContext(e));return Wi(t.font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class yT{constructor(e,t,r){this.type=e,this.scope=t,this.override=r,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let r;hot(t)&&(r=this.register(t));const s=this.items,i=e.id,o=this.scope+"."+i;if(!i)throw new Error("class does not have id: "+e);return i in s||(s[i]=e,cot(e,o,r),this.override&&oi.override(e.id,e.overrides)),o}get(e){return this.items[e]}unregister(e){const t=this.items,r=e.id,s=this.scope;r in t&&delete t[r],s&&r in oi[s]&&(delete oi[s][r],this.override&&delete mg[r])}}function cot(n,e,t){const r=jS(Object.create(null),[t?oi.get(t):{},oi.get(e),n.defaults]);oi.set(e,r),n.defaultRoutes&&uot(e,n.defaultRoutes),n.descriptors&&oi.describe(e,n.descriptors)}function uot(n,e){Object.keys(e).forEach(t=>{const r=t.split("."),s=r.pop(),i=[n].concat(r).join("."),o=e[t].split("."),a=o.pop(),l=o.join(".");oi.route(i,s,l,a)})}function hot(n){return"id"in n&&"defaults"in n}class fot{constructor(){this.controllers=new yT(bu,"datasets",!0),this.elements=new yT(Tu,"elements"),this.plugins=new yT(Object,"plugins"),this.scales=new yT(Xy,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...e){this._each("register",e)}remove(...e){this._each("unregister",e)}addControllers(...e){this._each("register",e,this.controllers)}addElements(...e){this._each("register",e,this.elements)}addPlugins(...e){this._each("register",e,this.plugins)}addScales(...e){this._each("register",e,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(...e){this._each("unregister",e,this.controllers)}removeElements(...e){this._each("unregister",e,this.elements)}removePlugins(...e){this._each("unregister",e,this.plugins)}removeScales(...e){this._each("unregister",e,this.scales)}_each(e,t,r){[...t].forEach(s=>{const i=r||this._getRegistryForType(s);r||i.isForType(s)||i===this.plugins&&s.id?this._exec(e,i,s):Dr(s,o=>{const a=r||this._getRegistryForType(o);this._exec(e,a,o)})})}_exec(e,t,r){const s=x4(e);os(r["before"+s],[],r),t[e](r),os(r["after"+s],[],r)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const r=this._typedRegistries[t];if(r.isForType(e))return r}return this.plugins}_get(e,t,r){const s=t.get(e);if(s===void 0)throw new Error('"'+e+'" is not a registered '+r+".");return s}}var sh=new fot;class dot{constructor(){this._init=[]}notify(e,t,r,s){t==="beforeInit"&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install"));const i=s?this._descriptors(e).filter(s):this._descriptors(e),o=this._notify(i,e,t,r);return t==="afterDestroy"&&(this._notify(i,e,"stop"),this._notify(this._init,e,"uninstall")),o}_notify(e,t,r,s){s=s||{};for(const i of e){const o=i.plugin,a=o[r],l=[t,s,i.options];if(os(a,l,o)===!1&&s.cancelable)return!1}return!0}invalidate(){Nr(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const r=e&&e.config,s=Wn(r.options&&r.options.plugins,{}),i=pot(r);return s===!1&&!t?[]:got(e,i,s,t)}_notifyStateChanges(e){const t=this._oldCache||[],r=this._cache,s=(i,o)=>i.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(s(t,r),e,"stop"),this._notify(s(r,t),e,"start")}}function pot(n){const e={},t=[],r=Object.keys(sh.plugins.items);for(let i=0;i<r.length;i++)t.push(sh.getPlugin(r[i]));const s=n.plugins||[];for(let i=0;i<s.length;i++){const o=s[i];t.indexOf(o)===-1&&(t.push(o),e[o.id]=!0)}return{plugins:t,localIds:e}}function mot(n,e){return!e&&n===!1?null:n===!0?{}:n}function got(n,{plugins:e,localIds:t},r,s){const i=[],o=n.getContext();for(const a of e){const l=a.id,c=mot(r[l],s);c!==null&&i.push({plugin:a,options:yot(n.config,{plugin:a,local:t[l]},c,o)})}return i}function yot(n,{plugin:e,local:t},r,s){const i=n.pluginScopeKeys(e),o=n.getOptionScopes(r,i);return t&&e.defaults&&o.push(e.defaults),n.createResolver(o,s,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function JO(n,e){const t=oi.datasets[n]||{};return((e.datasets||{})[n]||{}).indexAxis||e.indexAxis||t.indexAxis||"x"}function bot(n,e){let t=n;return n==="_index_"?t=e:n==="_value_"&&(t=e==="x"?"y":"x"),t}function vot(n,e){return n===e?"_index_":"_value_"}function wot(n){if(n==="top"||n==="bottom")return"x";if(n==="left"||n==="right")return"y"}function cA(n,e){if(n==="x"||n==="y"||n==="r"||(n=e.axis||wot(e.position)||n.length>1&&cA(n[0].toLowerCase(),e),n))return n;throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`)}function xot(n,e){const t=mg[n.type]||{scales:{}},r=e.scales||{},s=JO(n.type,e),i=Object.create(null);return Object.keys(r).forEach(o=>{const a=r[o];if(!sr(a))return console.error(`Invalid scale configuration for scale: ${o}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${o}`);const l=cA(o,a),c=vot(l,s),u=t.scales||{};i[o]=K1(Object.create(null),[{axis:l},a,u[l],u[c]])}),n.data.datasets.forEach(o=>{const a=o.type||n.type,l=o.indexAxis||JO(a,e),u=(mg[a]||{}).scales||{};Object.keys(u).forEach(h=>{const f=bot(h,l),d=o[f+"AxisID"]||f;i[d]=i[d]||Object.create(null),K1(i[d],[{axis:f},r[d],u[h]])})}),Object.keys(i).forEach(o=>{const a=i[o];K1(a,[oi.scales[a.type],oi.scale])}),i}function kse(n){const e=n.options||(n.options={});e.plugins=Wn(e.plugins,{}),e.scales=xot(n,e)}function Tse(n){return n=n||{},n.datasets=n.datasets||[],n.labels=n.labels||[],n}function Sot(n){return n=n||{},n.data=Tse(n.data),kse(n),n}const g5=new Map,Ese=new Set;function bT(n,e){let t=g5.get(n);return t||(t=e(),g5.set(n,t),Ese.add(t)),t}const Xx=(n,e,t)=>{const r=up(e,t);r!==void 0&&n.add(r)};class _ot{constructor(e){this._config=Sot(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=Tse(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),kse(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return bT(e,()=>[[`datasets.${e}`,""]])}datasetAnimationScopeKeys(e,t){return bT(`${e}.transition.${t}`,()=>[[`datasets.${e}.transitions.${t}`,`transitions.${t}`],[`datasets.${e}`,""]])}datasetElementScopeKeys(e,t){return bT(`${e}-${t}`,()=>[[`datasets.${e}.elements.${t}`,`datasets.${e}`,`elements.${t}`,""]])}pluginScopeKeys(e){const t=e.id,r=this.type;return bT(`${r}-plugin-${t}`,()=>[[`plugins.${t}`,...e.additionalOptionScopes||[]]])}_cachedScopes(e,t){const r=this._scopeCache;let s=r.get(e);return(!s||t)&&(s=new Map,r.set(e,s)),s}getOptionScopes(e,t,r){const{options:s,type:i}=this,o=this._cachedScopes(e,r),a=o.get(t);if(a)return a;const l=new Set;t.forEach(u=>{e&&(l.add(e),u.forEach(h=>Xx(l,e,h))),u.forEach(h=>Xx(l,s,h)),u.forEach(h=>Xx(l,mg[i]||{},h)),u.forEach(h=>Xx(l,oi,h)),u.forEach(h=>Xx(l,KO,h))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Ese.has(t)&&o.set(t,c),c}chartOptionScopes(){const{options:e,type:t}=this;return[e,mg[t]||{},oi.datasets[t]||{},{type:t},oi,KO]}resolveNamedOptions(e,t,r,s=[""]){const i={$shared:!0},{resolver:o,subPrefixes:a}=y5(this._resolverCache,e,s);let l=o;if(kot(o,t)){i.$shared=!1,r=hp(r)?r():r;const c=this.createResolver(e,r,a);l=sv(o,r,c)}for(const c of t)i[c]=l[c];return i}createResolver(e,t,r=[""],s){const{resolver:i}=y5(this._resolverCache,e,r);return sr(t)?sv(i,t,void 0,s):i}}function y5(n,e,t){let r=n.get(e);r||(r=new Map,n.set(e,r));const s=t.join();let i=r.get(s);return i||(i={resolver:T4(e,t),subPrefixes:t.filter(a=>!a.toLowerCase().includes("hover"))},r.set(s,i)),i}const Cot=n=>sr(n)&&Object.getOwnPropertyNames(n).reduce((e,t)=>e||hp(n[t]),!1);function kot(n,e){const{isScriptable:t,isIndexable:r}=sse(n);for(const s of e){const i=t(s),o=r(s),a=(o||i)&&n[s];if(i&&(hp(a)||Cot(a))||o&&gs(a))return!0}return!1}var Tot="4.2.1";const Eot=["top","bottom","left","right","chartArea"];function b5(n,e){return n==="top"||n==="bottom"||Eot.indexOf(n)===-1&&e==="x"}function v5(n,e){return function(t,r){return t[n]===r[n]?t[e]-r[e]:t[n]-r[n]}}function w5(n){const e=n.chart,t=e.options.animation;e.notifyPlugins("afterRender"),os(t&&t.onComplete,[n],e)}function Iot(n){const e=n.chart,t=e.options.animation;os(t&&t.onProgress,[n],e)}function Ise(n){return use()&&typeof n=="string"?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const HE={},x5=n=>{const e=Ise(n);return Object.values(HE).filter(t=>t.canvas===e).pop()};function Aot(n,e,t){const r=Object.keys(n);for(const s of r){const i=+s;if(i>=e){const o=n[s];delete n[s],(t>0||i>e)&&(n[i+t]=o)}}}function Mot(n,e,t,r){return!t||n.type==="mouseout"?null:r?e:n}function Not(n){const{xScale:e,yScale:t}=n;if(e&&t)return{left:e.left,right:e.right,top:t.top,bottom:t.bottom}}class wf{static register(...e){sh.add(...e),S5()}static unregister(...e){sh.remove(...e),S5()}constructor(e,t){const r=this.config=new _ot(t),s=Ise(e),i=x5(s);if(i)throw new Error("Canvas is already in use. Chart with ID '"+i.id+"' must be destroyed before the canvas with ID '"+i.canvas.id+"' can be reused.");const o=r.createResolver(r.chartOptionScopes(),this.getContext());this.platform=new(r.platform||Kit(s)),this.platform.updateConfig(r);const a=this.platform.acquireContext(s,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,u=l&&l.width;if(this.id=Ort(),this.ctx=a,this.canvas=l,this.width=u,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new dot,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=Jrt(h=>this.update(h),o.resizeDelay||0),this._dataChanges=[],HE[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}hf.listen(this,"complete",w5),hf.listen(this,"progress",Iot),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:r,height:s,_aspectRatio:i}=this;return Nr(e)?t&&i?i:s?r/s:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return sh}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():H6(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return U6(this.canvas,this.ctx),this}stop(){return hf.stop(this),this}resize(e,t){hf.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const r=this.options,s=this.canvas,i=r.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,e,t,i),a=r.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,H6(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),os(r.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const t=this.options.scales||{};Dr(t,(r,s)=>{r.id=s})}buildOrUpdateScales(){const e=this.options,t=e.scales,r=this.scales,s=Object.keys(r).reduce((o,a)=>(o[a]=!1,o),{});let i=[];t&&(i=i.concat(Object.keys(t).map(o=>{const a=t[o],l=cA(o,a),c=l==="r",u=l==="x";return{options:a,dposition:c?"chartArea":u?"bottom":"left",dtype:c?"radialLinear":u?"category":"linear"}}))),Dr(i,o=>{const a=o.options,l=a.id,c=cA(l,a),u=Wn(a.type,o.dtype);(a.position===void 0||b5(a.position,c)!==b5(o.dposition))&&(a.position=o.dposition),s[l]=!0;let h=null;if(l in r&&r[l].type===u)h=r[l];else{const f=sh.getScale(u);h=new f({id:l,type:u,ctx:this.ctx,chart:this}),r[h.id]=h}h.init(a,e)}),Dr(s,(o,a)=>{o||delete r[a]}),Dr(r,o=>{vc.configure(this,o,o.options),vc.addBox(this,o)})}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,r=e.length;if(e.sort((s,i)=>s.index-i.index),r>t){for(let s=t;s<r;++s)this._destroyDatasetMeta(s);e.splice(t,r-t)}this._sortedMetasets=e.slice(0).sort(v5("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach((r,s)=>{t.filter(i=>i===r._dataset).length===0&&this._destroyDatasetMeta(s)})}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let r,s;for(this._removeUnreferencedMetasets(),r=0,s=t.length;r<s;r++){const i=t[r];let o=this.getDatasetMeta(r);const a=i.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(r),o=this.getDatasetMeta(r)),o.type=a,o.indexAxis=i.indexAxis||JO(a,this.options),o.order=i.order||0,o.index=r,o.label=""+i.label,o.visible=this.isDatasetVisible(r),o.controller)o.controller.updateIndex(r),o.controller.linkScales();else{const l=sh.getController(a),{datasetElementType:c,dataElementType:u}=oi.datasets[a];Object.assign(l,{dataElementType:sh.getElement(u),datasetElementType:c&&sh.getElement(c)}),o.controller=new l(this,r),e.push(o.controller)}}return this._updateMetasets(),e}_resetElements(){Dr(this.data.datasets,(e,t)=>{this.getDatasetMeta(t).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const r=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!r.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0})===!1)return;const i=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,u=this.data.datasets.length;c<u;c++){const{controller:h}=this.getDatasetMeta(c),f=!s&&i.indexOf(h)===-1;h.buildOrUpdateElements(f),o=Math.max(+h.getMaxOverflow(),o)}o=this._minPadding=r.layout.autoPadding?o:0,this._updateLayout(o),s||Dr(i,c=>{c.reset()}),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(v5("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){Dr(this.scales,e=>{vc.removeBox(this,e)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),r=new Set(e.events);(!R6(t,r)||!!this._responsiveListeners!==e.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:r,start:s,count:i}of t){const o=r==="_removeElements"?-i:i;Aot(e,s,o)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,r=i=>new Set(e.filter(o=>o[0]===i).map((o,a)=>a+","+o.splice(1).join(","))),s=r(0);for(let i=1;i<t;i++)if(!R6(s,r(i)))return;return Array.from(s).map(i=>i.split(",")).map(i=>({method:i[1],start:+i[2],count:+i[3]}))}_updateLayout(e){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;vc.update(this,this.width,this.height,e);const t=this.chartArea,r=t.width<=0||t.height<=0;this._layers=[],Dr(this.boxes,s=>{r&&s.position==="chartArea"||(s.configure&&s.configure(),this._layers.push(...s._layers()))},this),this._layers.forEach((s,i)=>{s._idx=i}),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})!==!1){for(let t=0,r=this.data.datasets.length;t<r;++t)this.getDatasetMeta(t).controller.configure();for(let t=0,r=this.data.datasets.length;t<r;++t)this._updateDataset(t,hp(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const r=this.getDatasetMeta(e),s={meta:r,index:e,mode:t,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",s)!==!1&&(r.controller._update(t),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(hf.has(this)?this.attached&&!hf.running(this)&&hf.start(this):(this.draw(),w5({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:r,height:s}=this._resizeBeforeDraw;this._resize(r,s),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,r=[];let s,i;for(s=0,i=t.length;s<i;++s){const o=t[s];(!e||o.visible)&&r.push(o)}return r}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,r=e._clip,s=!r.disabled,i=Not(e)||this.chartArea,o={meta:e,index:e.index,cancelable:!0};this.notifyPlugins("beforeDatasetDraw",o)!==!1&&(s&&p$(t,{left:r.left===!1?0:i.left-r.left,right:r.right===!1?this.width:i.right+r.right,top:r.top===!1?0:i.top-r.top,bottom:r.bottom===!1?this.height:i.bottom+r.bottom}),e.controller.draw(),s&&m$(t),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}isPointInArea(e){return XS(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,r,s){const i=Iit.modes[t];return typeof i=="function"?i(this,e,r,s):[]}getDatasetMeta(e){const t=this.data.datasets[e],r=this._metasets;let s=r.filter(i=>i&&i._dataset===t).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},r.push(s)),s}getContext(){return this.$context||(this.$context=Pp(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const r=this.getDatasetMeta(e);return typeof r.hidden=="boolean"?!r.hidden:!t.hidden}setDatasetVisibility(e,t){const r=this.getDatasetMeta(e);r.hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,r){const s=r?"show":"hide",i=this.getDatasetMeta(e),o=i.controller._resolveAnimations(void 0,s);Mc(t)?(i.data[t].hidden=!r,this.update()):(this.setDatasetVisibility(e,r),o.update(i,{visible:r}),this.update(a=>a.datasetIndex===e?s:void 0))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),hf.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),U6(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete HE[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...e){return this.canvas.toDataURL(...e)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,r=(i,o)=>{t.addEventListener(this,i,o),e[i]=o},s=(i,o,a)=>{i.offsetX=o,i.offsetY=a,this._eventHandler(i)};Dr(this.options.events,i=>r(i,s))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,r=(l,c)=>{t.addEventListener(this,l,c),e[l]=c},s=(l,c)=>{e[l]&&(t.removeEventListener(this,l,c),delete e[l])},i=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{s("attach",a),this.attached=!0,this.resize(),r("resize",i),r("detach",o)};o=()=>{this.attached=!1,s("resize",i),this._stop(),this._resize(0,0),r("attach",a)},t.isAttached(this.canvas)?a():o()}unbindEvents(){Dr(this._listeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._listeners={},Dr(this._responsiveListeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._responsiveListeners=void 0}updateHoverStyle(e,t,r){const s=r?"set":"remove";let i,o,a,l;for(t==="dataset"&&(i=this.getDatasetMeta(e[0].datasetIndex),i.controller["_"+s+"DatasetHoverStyle"]()),a=0,l=e.length;a<l;++a){o=e[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],r=e.map(({datasetIndex:i,index:o})=>{const a=this.getDatasetMeta(i);if(!a)throw new Error("No dataset found at index "+i);return{datasetIndex:i,element:a.data[o],index:o}});!rA(r,t)&&(this._active=r,this._lastEvent=null,this._updateHoverStyles(r,t))}notifyPlugins(e,t,r){return this._plugins.notify(this,e,t,r)}isPluginEnabled(e){return this._plugins._cache.filter(t=>t.plugin.id===e).length===1}_updateHoverStyles(e,t,r){const s=this.options.hover,i=(l,c)=>l.filter(u=>!c.some(h=>u.datasetIndex===h.datasetIndex&&u.index===h.index)),o=i(t,e),a=r?e:i(e,t);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(e,t){const r={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},s=o=>(o.options.events||this.options.events).includes(e.native.type);if(this.notifyPlugins("beforeEvent",r,s)===!1)return;const i=this._handleEvent(e,t,r.inChartArea);return r.cancelable=!1,this.notifyPlugins("afterEvent",r,s),(i||r.changed)&&this.render(),this}_handleEvent(e,t,r){const{_active:s=[],options:i}=this,o=t,a=this._getActiveElements(e,s,r,o),l=Urt(e),c=Mot(e,this._lastEvent,r,l);r&&(this._lastEvent=null,os(i.onHover,[e,a,this],this),l&&os(i.onClick,[e,a,this],this));const u=!rA(a,s);return(u||t)&&(this._active=a,this._updateHoverStyles(a,s,t)),this._lastEvent=c,u}_getActiveElements(e,t,r,s){if(e.type==="mouseout")return[];if(!r)return t;const i=this.options.hover;return this.getElementsAtEventForMode(e,i.mode,i,s)}}zt(wf,"defaults",oi),zt(wf,"instances",HE),zt(wf,"overrides",mg),zt(wf,"registry",sh),zt(wf,"version",Tot),zt(wf,"getChart",x5);function S5(){return Dr(wf.instances,n=>n._plugins.invalidate())}function $ot(n,e,t){const{startAngle:r,pixelMargin:s,x:i,y:o,outerRadius:a,innerRadius:l}=e;let c=s/a;n.beginPath(),n.arc(i,o,a,r-c,t+c),l>s?(c=s/l,n.arc(i,o,l,t+c,r-c,!0)):n.arc(i,o,s,t+Zs,r-Zs),n.closePath(),n.clip()}function Rot(n){return k4(n,["outerStart","outerEnd","innerStart","innerEnd"])}function Pot(n,e,t,r){const s=Rot(n.options.borderRadius),i=(t-e)/2,o=Math.min(i,r*e/2),a=l=>{const c=(t-Math.min(i,l))*r/2;return jo(l,0,Math.min(i,c))};return{outerStart:a(s.outerStart),outerEnd:a(s.outerEnd),innerStart:jo(s.innerStart,0,o),innerEnd:jo(s.innerEnd,0,o)}}function P0(n,e,t,r){return{x:t+n*Math.cos(e),y:r+n*Math.sin(e)}}function uA(n,e,t,r,s,i){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:u}=e,h=Math.max(e.outerRadius+r+t-c,0),f=u>0?u+r+t+c:0;let d=0;const p=s-l;if(r){const z=u>0?u-r:0,B=h>0?h-r:0,X=(z+B)/2,G=X!==0?p*X/(X+r):p;d=(p-G)/2}const m=Math.max(.001,p*h-t/Es)/h,g=(p-m)/2,y=l+g+d,b=s-g-d,{outerStart:x,outerEnd:w,innerStart:_,innerEnd:C}=Pot(e,f,h,b-y),k=h-x,A=h-w,M=y+x/k,I=b-w/A,N=f+_,O=f+C,R=y+_/N,D=b-C/O;if(n.beginPath(),i){const z=(M+I)/2;if(n.arc(o,a,h,M,z),n.arc(o,a,h,z,I),w>0){const ee=P0(A,I,o,a);n.arc(ee.x,ee.y,w,I,b+Zs)}const B=P0(O,b,o,a);if(n.lineTo(B.x,B.y),C>0){const ee=P0(O,D,o,a);n.arc(ee.x,ee.y,C,b+Zs,D+Math.PI)}const X=(b-C/f+(y+_/f))/2;if(n.arc(o,a,f,b-C/f,X,!0),n.arc(o,a,f,X,y+_/f,!0),_>0){const ee=P0(N,R,o,a);n.arc(ee.x,ee.y,_,R+Math.PI,y-Zs)}const G=P0(k,y,o,a);if(n.lineTo(G.x,G.y),x>0){const ee=P0(k,M,o,a);n.arc(ee.x,ee.y,x,y-Zs,M)}}else{n.moveTo(o,a);const z=Math.cos(M)*h+o,B=Math.sin(M)*h+a;n.lineTo(z,B);const X=Math.cos(I)*h+o,G=Math.sin(I)*h+a;n.lineTo(X,G)}n.closePath()}function Dot(n,e,t,r,s){const{fullCircles:i,startAngle:o,circumference:a}=e;let l=e.endAngle;if(i){uA(n,e,t,r,l,s);for(let c=0;c<i;++c)n.fill();isNaN(a)||(l=o+(a%bs||bs))}return uA(n,e,t,r,l,s),n.fill(),l}function Oot(n,e,t,r,s){const{fullCircles:i,startAngle:o,circumference:a,options:l}=e,{borderWidth:c,borderJoinStyle:u}=l,h=l.borderAlign==="inner";if(!c)return;h?(n.lineWidth=c*2,n.lineJoin=u||"round"):(n.lineWidth=c,n.lineJoin=u||"bevel");let f=e.endAngle;if(i){uA(n,e,t,r,f,s);for(let d=0;d<i;++d)n.stroke();isNaN(a)||(f=o+(a%bs||bs))}h&&$ot(n,e,f),i||(uA(n,e,t,r,f,s),n.stroke())}class jE extends Tu{constructor(e){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,r){const s=this.getProps(["x","y"],r),{angle:i,distance:o}=qre(s,{x:e,y:t}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:u,circumference:h}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],r),f=this.options.spacing/2,p=Wn(h,l-a)>=bs||qS(i,a,l),m=Ef(o,c+f,u+f);return p&&m}getCenterPoint(e){const{x:t,y:r,startAngle:s,endAngle:i,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:l,spacing:c}=this.options,u=(s+i)/2,h=(o+a+c+l)/2;return{x:t+Math.cos(u)*h,y:r+Math.sin(u)*h}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:r}=this,s=(t.offset||0)/4,i=(t.spacing||0)/2,o=t.circular;if(this.pixelMargin=t.borderAlign==="inner"?.33:0,this.fullCircles=r>bs?Math.floor(r/bs):0,r===0||this.innerRadius<0||this.outerRadius<0)return;e.save();const a=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(a)*s,Math.sin(a)*s);const l=1-Math.sin(Math.min(Es,r||0)),c=s*l;e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,Dot(e,this,c,i,o),Oot(e,this,c,i,o),e.restore()}}zt(jE,"id","arc"),zt(jE,"defaults",{borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0}),zt(jE,"defaultRoutes",{backgroundColor:"backgroundColor"});function Ase(n,e,t=e){n.lineCap=Wn(t.borderCapStyle,e.borderCapStyle),n.setLineDash(Wn(t.borderDash,e.borderDash)),n.lineDashOffset=Wn(t.borderDashOffset,e.borderDashOffset),n.lineJoin=Wn(t.borderJoinStyle,e.borderJoinStyle),n.lineWidth=Wn(t.borderWidth,e.borderWidth),n.strokeStyle=Wn(t.borderColor,e.borderColor)}function Fot(n,e,t){n.lineTo(t.x,t.y)}function Lot(n){return n.stepped?ust:n.tension||n.cubicInterpolationMode==="monotone"?hst:Fot}function Mse(n,e,t={}){const r=n.length,{start:s=0,end:i=r-1}=t,{start:o,end:a}=e,l=Math.max(s,o),c=Math.min(i,a),u=s<o&&i<o||s>a&&i>a;return{count:r,start:l,loop:e.loop,ilen:c<l&&!u?r+c-l:c-l}}function zot(n,e,t,r){const{points:s,options:i}=e,{count:o,start:a,loop:l,ilen:c}=Mse(s,t,r),u=Lot(i);let{move:h=!0,reverse:f}=r||{},d,p,m;for(d=0;d<=c;++d)p=s[(a+(f?c-d:d))%o],!p.skip&&(h?(n.moveTo(p.x,p.y),h=!1):u(n,m,p,f,i.stepped),m=p);return l&&(p=s[(a+(f?c:0))%o],u(n,m,p,f,i.stepped)),!!l}function Bot(n,e,t,r){const s=e.points,{count:i,start:o,ilen:a}=Mse(s,t,r),{move:l=!0,reverse:c}=r||{};let u=0,h=0,f,d,p,m,g,y;const b=w=>(o+(c?a-w:w))%i,x=()=>{m!==g&&(n.lineTo(u,g),n.lineTo(u,m),n.lineTo(u,y))};for(l&&(d=s[b(0)],n.moveTo(d.x,d.y)),f=0;f<=a;++f){if(d=s[b(f)],d.skip)continue;const w=d.x,_=d.y,C=w|0;C===p?(_<m?m=_:_>g&&(g=_),u=(h*u+w)/++h):(x(),n.lineTo(w,_),p=C,h=0,m=g=_),y=_}x()}function QO(n){const e=n.options,t=e.borderDash&&e.borderDash.length;return!n._decimated&&!n._loop&&!e.tension&&e.cubicInterpolationMode!=="monotone"&&!e.stepped&&!t?Bot:zot}function Vot(n){return n.stepped?Wst:n.tension||n.cubicInterpolationMode==="monotone"?Gst:wm}function Uot(n,e,t,r){let s=e._path;s||(s=e._path=new Path2D,e.path(s,t,r)&&s.closePath()),Ase(n,e.options),n.stroke(s)}function Wot(n,e,t,r){const{segments:s,options:i}=e,o=QO(e);for(const a of s)Ase(n,i,a.style),n.beginPath(),o(n,e,a,{start:t,end:t+r-1})&&n.closePath(),n.stroke()}const Got=typeof Path2D=="function";function Hot(n,e,t,r){Got&&!e.options.segment?Uot(n,e,t,r):Wot(n,e,t,r)}class Dd extends Tu{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const r=this.options;if((r.tension||r.cubicInterpolationMode==="monotone")&&!r.stepped&&!this._pointsUpdated){const s=r.spanGaps?this._loop:this._fullLoop;Dst(this._points,r,e,s,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=Yst(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,r=e.length;return r&&t[e[r-1].end]}interpolate(e,t){const r=this.options,s=e[t],i=this.points,o=mse(this,{property:t,start:s,end:s});if(!o.length)return;const a=[],l=Vot(r);let c,u;for(c=0,u=o.length;c<u;++c){const{start:h,end:f}=o[c],d=i[h],p=i[f];if(d===p){a.push(d);continue}const m=Math.abs((s-d[t])/(p[t]-d[t])),g=l(d,p,m,r.stepped);g[t]=e[t],a.push(g)}return a.length===1?a[0]:a}pathSegment(e,t,r){return QO(this)(e,this,t,r)}path(e,t,r){const s=this.segments,i=QO(this);let o=this._loop;t=t||0,r=r||this.points.length-t;for(const a of s)o&=i(e,this,a,{start:t,end:t+r-1});return!!o}draw(e,t,r,s){const i=this.options||{};(this.points||[]).length&&i.borderWidth&&(e.save(),Hot(e,this,r,s),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}zt(Dd,"id","line"),zt(Dd,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),zt(Dd,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),zt(Dd,"descriptors",{_scriptable:!0,_indexable:e=>e!=="borderDash"&&e!=="fill"});function _5(n,e,t,r){const s=n.options,{[t]:i}=n.getProps([t],r);return Math.abs(e-i)<s.radius+s.hitRadius}class qE extends Tu{constructor(e){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,r){const s=this.options,{x:i,y:o}=this.getProps(["x","y"],r);return Math.pow(e-i,2)+Math.pow(t-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(e,t){return _5(this,e,"x",t)}inYRange(e,t){return _5(this,e,"y",t)}getCenterPoint(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}size(e){e=e||this.options||{};let t=e.radius||0;t=Math.max(t,t&&e.hoverRadius||0);const r=t&&e.borderWidth||0;return(t+r)*2}draw(e,t){const r=this.options;this.skip||r.radius<.1||!XS(this,t,this.size(r)/2)||(e.strokeStyle=r.borderColor,e.lineWidth=r.borderWidth,e.fillStyle=r.backgroundColor,YO(e,r,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}zt(qE,"id","point"),zt(qE,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),zt(qE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function Nse(n,e){const{x:t,y:r,base:s,width:i,height:o}=n.getProps(["x","y","base","width","height"],e);let a,l,c,u,h;return n.horizontal?(h=o/2,a=Math.min(t,s),l=Math.max(t,s),c=r-h,u=r+h):(h=i/2,a=t-h,l=t+h,c=Math.min(r,s),u=Math.max(r,s)),{left:a,top:c,right:l,bottom:u}}function Od(n,e,t,r){return n?0:jo(e,t,r)}function jot(n,e,t){const r=n.options.borderWidth,s=n.borderSkipped,i=rse(r);return{t:Od(s.top,i.top,0,t),r:Od(s.right,i.right,0,e),b:Od(s.bottom,i.bottom,0,t),l:Od(s.left,i.left,0,e)}}function qot(n,e,t){const{enableBorderRadius:r}=n.getProps(["enableBorderRadius"]),s=n.options.borderRadius,i=jm(s),o=Math.min(e,t),a=n.borderSkipped,l=r||sr(s);return{topLeft:Od(!l||a.top||a.left,i.topLeft,0,o),topRight:Od(!l||a.top||a.right,i.topRight,0,o),bottomLeft:Od(!l||a.bottom||a.left,i.bottomLeft,0,o),bottomRight:Od(!l||a.bottom||a.right,i.bottomRight,0,o)}}function Xot(n){const e=Nse(n),t=e.right-e.left,r=e.bottom-e.top,s=jot(n,t/2,r/2),i=qot(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r,radius:i},inner:{x:e.left+s.l,y:e.top+s.t,w:t-s.l-s.r,h:r-s.t-s.b,radius:{topLeft:Math.max(0,i.topLeft-Math.max(s.t,s.l)),topRight:Math.max(0,i.topRight-Math.max(s.t,s.r)),bottomLeft:Math.max(0,i.bottomLeft-Math.max(s.b,s.l)),bottomRight:Math.max(0,i.bottomRight-Math.max(s.b,s.r))}}}}function F3(n,e,t,r){const s=e===null,i=t===null,a=n&&!(s&&i)&&Nse(n,r);return a&&(s||Ef(e,a.left,a.right))&&(i||Ef(t,a.top,a.bottom))}function Kot(n){return n.topLeft||n.topRight||n.bottomLeft||n.bottomRight}function Yot(n,e){n.rect(e.x,e.y,e.w,e.h)}function L3(n,e,t={}){const r=n.x!==t.x?-e:0,s=n.y!==t.y?-e:0,i=(n.x+n.w!==t.x+t.w?e:0)-r,o=(n.y+n.h!==t.y+t.h?e:0)-s;return{x:n.x+r,y:n.y+s,w:n.w+i,h:n.h+o,radius:n.radius}}class XE extends Tu{constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:r,backgroundColor:s}}=this,{inner:i,outer:o}=Xot(this),a=Kot(o.radius)?KS:Yot;e.save(),(o.w!==i.w||o.h!==i.h)&&(e.beginPath(),a(e,L3(o,t,i)),e.clip(),a(e,L3(i,-t,o)),e.fillStyle=r,e.fill("evenodd")),e.beginPath(),a(e,L3(i,t)),e.fillStyle=s,e.fill(),e.restore()}inRange(e,t,r){return F3(this,e,t,r)}inXRange(e,t){return F3(this,e,null,t)}inYRange(e,t){return F3(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,base:s,horizontal:i}=this.getProps(["x","y","base","horizontal"],e);return{x:i?(t+s)/2:t,y:i?r:(r+s)/2}}getRange(e){return e==="x"?this.width/2:this.height/2}}zt(XE,"id","bar"),zt(XE,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),zt(XE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function Zot(n,e,t){const r=n.segments,s=n.points,i=e.points,o=[];for(const a of r){let{start:l,end:c}=a;c=N4(l,c,s);const u=eF(t,s[l],s[c],a.loop);if(!e.segments){o.push({source:a,target:u,start:s[l],end:s[c]});continue}const h=mse(e,u);for(const f of h){const d=eF(t,i[f.start],i[f.end],f.loop),p=pse(a,s,d);for(const m of p)o.push({source:m,target:f,start:{[t]:C5(u,d,"start",Math.max)},end:{[t]:C5(u,d,"end",Math.min)}})}}return o}function eF(n,e,t,r){if(r)return;let s=e[n],i=t[n];return n==="angle"&&(s=bl(s),i=bl(i)),{property:n,start:s,end:i}}function Jot(n,e){const{x:t=null,y:r=null}=n||{},s=e.points,i=[];return e.segments.forEach(({start:o,end:a})=>{a=N4(o,a,s);const l=s[o],c=s[a];r!==null?(i.push({x:l.x,y:r}),i.push({x:c.x,y:r})):t!==null&&(i.push({x:t,y:l.y}),i.push({x:t,y:c.y}))}),i}function N4(n,e,t){for(;e>n;e--){const r=t[e];if(!isNaN(r.x)&&!isNaN(r.y))break}return e}function C5(n,e,t,r){return n&&e?r(n[t],e[t]):n?n[t]:e?e[t]:0}function $se(n,e){let t=[],r=!1;return gs(n)?(r=!0,t=n):t=Jot(n,e),t.length?new Dd({points:t,options:{tension:0},_loop:r,_fullLoop:r}):null}function k5(n){return n&&n.fill!==!1}function Qot(n,e,t){let s=n[e].fill;const i=[e];let o;if(!t)return s;for(;s!==!1&&i.indexOf(s)===-1;){if(!Ys(s))return s;if(o=n[s],!o)return!1;if(o.visible)return s;i.push(s),s=o.fill}return!1}function eat(n,e,t){const r=sat(n);if(sr(r))return isNaN(r.value)?!1:r;let s=parseFloat(r);return Ys(s)&&Math.floor(s)===s?tat(r[0],e,s,t):["origin","start","end","stack","shape"].indexOf(r)>=0&&r}function tat(n,e,t,r){return(n==="-"||n==="+")&&(t=e+t),t===e||t<0||t>=r?!1:t}function nat(n,e){let t=null;return n==="start"?t=e.bottom:n==="end"?t=e.top:sr(n)?t=e.getPixelForValue(n.value):e.getBasePixel&&(t=e.getBasePixel()),t}function rat(n,e,t){let r;return n==="start"?r=t:n==="end"?r=e.options.reverse?e.min:e.max:sr(n)?r=n.value:r=e.getBaseValue(),r}function sat(n){const e=n.options,t=e.fill;let r=Wn(t&&t.target,t);return r===void 0&&(r=!!e.backgroundColor),r===!1||r===null?!1:r===!0?"origin":r}function iat(n){const{scale:e,index:t,line:r}=n,s=[],i=r.segments,o=r.points,a=oat(e,t);a.push($se({x:null,y:e.bottom},r));for(let l=0;l<i.length;l++){const c=i[l];for(let u=c.start;u<=c.end;u++)aat(s,o[u],a)}return new Dd({points:s,options:{}})}function oat(n,e){const t=[],r=n.getMatchingVisibleMetas("line");for(let s=0;s<r.length;s++){const i=r[s];if(i.index===e)break;i.hidden||t.unshift(i.dataset)}return t}function aat(n,e,t){const r=[];for(let s=0;s<t.length;s++){const i=t[s],{first:o,last:a,point:l}=lat(i,e,"x");if(!(!l||o&&a)){if(o)r.unshift(l);else if(n.push(l),!a)break}}n.push(...r)}function lat(n,e,t){const r=n.interpolate(e,t);if(!r)return{};const s=r[t],i=n.segments,o=n.points;let a=!1,l=!1;for(let c=0;c<i.length;c++){const u=i[c],h=o[u.start][t],f=o[u.end][t];if(Ef(s,h,f)){a=s===h,l=s===f;break}}return{first:a,last:l,point:r}}class Rse{constructor(e){this.x=e.x,this.y=e.y,this.radius=e.radius}pathSegment(e,t,r){const{x:s,y:i,radius:o}=this;return t=t||{start:0,end:bs},e.arc(s,i,o,t.end,t.start,!0),!r.bounds}interpolate(e){const{x:t,y:r,radius:s}=this,i=e.angle;return{x:t+Math.cos(i)*s,y:r+Math.sin(i)*s,angle:i}}}function cat(n){const{chart:e,fill:t,line:r}=n;if(Ys(t))return uat(e,t);if(t==="stack")return iat(n);if(t==="shape")return!0;const s=hat(n);return s instanceof Rse?s:$se(s,r)}function uat(n,e){const t=n.getDatasetMeta(e);return t&&n.isDatasetVisible(e)?t.dataset:null}function hat(n){return(n.scale||{}).getPointPositionForValue?dat(n):fat(n)}function fat(n){const{scale:e={},fill:t}=n,r=nat(t,e);if(Ys(r)){const s=e.isHorizontal();return{x:s?r:null,y:s?null:r}}return null}function dat(n){const{scale:e,fill:t}=n,r=e.options,s=e.getLabels().length,i=r.reverse?e.max:e.min,o=rat(t,e,i),a=[];if(r.grid.circular){const l=e.getPointPositionForValue(0,i);return new Rse({x:l.x,y:l.y,radius:e.getDistanceFromCenterForValue(o)})}for(let l=0;l<s;++l)a.push(e.getPointPositionForValue(l,o));return a}function z3(n,e,t){const r=cat(e),{line:s,scale:i,axis:o}=e,a=s.options,l=a.fill,c=a.backgroundColor,{above:u=c,below:h=c}=l||{};r&&s.points.length&&(p$(n,t),pat(n,{line:s,target:r,above:u,below:h,area:t,scale:i,axis:o}),m$(n))}function pat(n,e){const{line:t,target:r,above:s,below:i,area:o,scale:a}=e,l=t._loop?"angle":e.axis;n.save(),l==="x"&&i!==s&&(T5(n,r,o.top),E5(n,{line:t,target:r,color:s,scale:a,property:l}),n.restore(),n.save(),T5(n,r,o.bottom)),E5(n,{line:t,target:r,color:i,scale:a,property:l}),n.restore()}function T5(n,e,t){const{segments:r,points:s}=e;let i=!0,o=!1;n.beginPath();for(const a of r){const{start:l,end:c}=a,u=s[l],h=s[N4(l,c,s)];i?(n.moveTo(u.x,u.y),i=!1):(n.lineTo(u.x,t),n.lineTo(u.x,u.y)),o=!!e.pathSegment(n,a,{move:o}),o?n.closePath():n.lineTo(h.x,t)}n.lineTo(e.first().x,t),n.closePath(),n.clip()}function E5(n,e){const{line:t,target:r,property:s,color:i,scale:o}=e,a=Zot(t,r,s);for(const{source:l,target:c,start:u,end:h}of a){const{style:{backgroundColor:f=i}={}}=l,d=r!==!0;n.save(),n.fillStyle=f,mat(n,o,d&&eF(s,u,h)),n.beginPath();const p=!!t.pathSegment(n,l);let m;if(d){p?n.closePath():I5(n,r,h,s);const g=!!r.pathSegment(n,c,{move:p,reverse:!0});m=p&&g,m||I5(n,r,u,s)}n.closePath(),n.fill(m?"evenodd":"nonzero"),n.restore()}}function mat(n,e,t){const{top:r,bottom:s}=e.chart.chartArea,{property:i,start:o,end:a}=t||{};i==="x"&&(n.beginPath(),n.rect(o,r,a-o,s-r),n.clip())}function I5(n,e,t,r){const s=e.interpolate(t,r);s&&n.lineTo(s.x,s.y)}var gat={id:"filler",afterDatasetsUpdate(n,e,t){const r=(n.data.datasets||[]).length,s=[];let i,o,a,l;for(o=0;o<r;++o)i=n.getDatasetMeta(o),a=i.dataset,l=null,a&&a.options&&a instanceof Dd&&(l={visible:n.isDatasetVisible(o),index:o,fill:eat(a,o,r),chart:n,axis:i.controller.options.indexAxis,scale:i.vScale,line:a}),i.$filler=l,s.push(l);for(o=0;o<r;++o)l=s[o],!(!l||l.fill===!1)&&(l.fill=Qot(s,o,t.propagate))},beforeDraw(n,e,t){const r=t.drawTime==="beforeDraw",s=n.getSortedVisibleDatasetMetas(),i=n.chartArea;for(let o=s.length-1;o>=0;--o){const a=s[o].$filler;a&&(a.line.updateControlPoints(i,a.axis),r&&a.fill&&z3(n.ctx,a,i))}},beforeDatasetsDraw(n,e,t){if(t.drawTime!=="beforeDatasetsDraw")return;const r=n.getSortedVisibleDatasetMetas();for(let s=r.length-1;s>=0;--s){const i=r[s].$filler;k5(i)&&z3(n.ctx,i,n.chartArea)}},beforeDatasetDraw(n,e,t){const r=e.meta.$filler;!k5(r)||t.drawTime!=="beforeDatasetDraw"||z3(n.ctx,r,n.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const A5=(n,e)=>{let{boxHeight:t=e,boxWidth:r=e}=n;return n.usePointStyle&&(t=Math.min(t,e),r=n.pointStyleWidth||Math.min(r,e)),{boxWidth:r,boxHeight:t,itemHeight:Math.max(e,t)}},yat=(n,e)=>n!==null&&e!==null&&n.datasetIndex===e.datasetIndex&&n.index===e.index;class M5 extends Tu{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,r){this.maxWidth=e,this.maxHeight=t,this._margins=r,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=os(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter(r=>e.filter(r,this.chart.data))),e.sort&&(t=t.sort((r,s)=>e.sort(r,s,this.chart.data))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display){this.width=this.height=0;return}const r=e.labels,s=Wi(r.font),i=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=A5(r,i);let c,u;t.font=s.string,this.isHorizontal()?(c=this.maxWidth,u=this._fitRows(o,i,a,l)+10):(u=this.maxHeight,c=this._fitCols(o,s,a,l)+10),this.width=Math.min(c,e.maxWidth||this.maxWidth),this.height=Math.min(u,e.maxHeight||this.maxHeight)}_fitRows(e,t,r,s){const{ctx:i,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],u=s+a;let h=e;i.textAlign="left",i.textBaseline="middle";let f=-1,d=-u;return this.legendItems.forEach((p,m)=>{const g=r+t/2+i.measureText(p.text).width;(m===0||c[c.length-1]+g+2*a>o)&&(h+=u,c[c.length-(m>0?0:1)]=0,d+=u,f++),l[m]={left:0,top:d,row:f,width:g,height:s},c[c.length-1]+=g+a}),h}_fitCols(e,t,r,s){const{ctx:i,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],u=o-e;let h=a,f=0,d=0,p=0,m=0;return this.legendItems.forEach((g,y)=>{const{itemWidth:b,itemHeight:x}=bat(r,t,i,g,s);y>0&&d+x+2*a>u&&(h+=f+a,c.push({width:f,height:d}),p+=f+a,m++,f=d=0),l[y]={left:p,top:d,col:m,width:b,height:x},f=Math.max(f,b),d+=x+a}),h+=f,c.push({width:f,height:d}),h}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:r,labels:{padding:s},rtl:i}}=this,o=Mb(i,this.left,this.width);if(this.isHorizontal()){let a=0,l=Oo(r,this.left+s,this.right-this.lineWidths[a]);for(const c of t)a!==c.row&&(a=c.row,l=Oo(r,this.left+s,this.right-this.lineWidths[a])),c.top+=this.top+e+s,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+s}else{let a=0,l=Oo(r,this.top+e+s,this.bottom-this.columnSizes[a].height);for(const c of t)c.col!==a&&(a=c.col,l=Oo(r,this.top+e+s,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+s,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+s}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const e=this.ctx;p$(e,this),this._draw(),m$(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:r,ctx:s}=this,{align:i,labels:o}=e,a=oi.color,l=Mb(e.rtl,this.left,this.width),c=Wi(o.font),{padding:u}=o,h=c.size,f=h/2;let d;this.drawTitle(),s.textAlign=l.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=c.string;const{boxWidth:p,boxHeight:m,itemHeight:g}=A5(o,h),y=function(C,k,A){if(isNaN(p)||p<=0||isNaN(m)||m<0)return;s.save();const M=Wn(A.lineWidth,1);if(s.fillStyle=Wn(A.fillStyle,a),s.lineCap=Wn(A.lineCap,"butt"),s.lineDashOffset=Wn(A.lineDashOffset,0),s.lineJoin=Wn(A.lineJoin,"miter"),s.lineWidth=M,s.strokeStyle=Wn(A.strokeStyle,a),s.setLineDash(Wn(A.lineDash,[])),o.usePointStyle){const I={radius:m*Math.SQRT2/2,pointStyle:A.pointStyle,rotation:A.rotation,borderWidth:M},N=l.xPlus(C,p/2),O=k+f;nse(s,I,N,O,o.pointStyleWidth&&p)}else{const I=k+Math.max((h-m)/2,0),N=l.leftForLtr(C,p),O=jm(A.borderRadius);s.beginPath(),Object.values(O).some(R=>R!==0)?KS(s,{x:N,y:I,w:p,h:m,radius:O}):s.rect(N,I,p,m),s.fill(),M!==0&&s.stroke()}s.restore()},b=function(C,k,A){gg(s,A.text,C,k+g/2,c,{strikethrough:A.hidden,textAlign:l.textAlign(A.textAlign)})},x=this.isHorizontal(),w=this._computeTitleHeight();x?d={x:Oo(i,this.left+u,this.right-r[0]),y:this.top+u+w,line:0}:d={x:this.left+u,y:Oo(i,this.top+w+u,this.bottom-t[0].height),line:0},hse(this.ctx,e.textDirection);const _=g+u;this.legendItems.forEach((C,k)=>{s.strokeStyle=C.fontColor,s.fillStyle=C.fontColor;const A=s.measureText(C.text).width,M=l.textAlign(C.textAlign||(C.textAlign=o.textAlign)),I=p+f+A;let N=d.x,O=d.y;l.setWidth(this.width),x?k>0&&N+I+u>this.right&&(O=d.y+=_,d.line++,N=d.x=Oo(i,this.left+u,this.right-r[d.line])):k>0&&O+_>this.bottom&&(N=d.x=N+t[d.line].width+u,d.line++,O=d.y=Oo(i,this.top+w+u,this.bottom-t[d.line].height));const R=l.x(N);if(y(R,O,C),N=Qrt(M,N+p+f,x?N+I:this.right,e.rtl),b(l.x(N),O,C),x)d.x+=I+u;else if(typeof C.text!="string"){const D=c.lineHeight;d.y+=Pse(C,D)}else d.y+=_}),fse(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,r=Wi(t.font),s=Yo(t.padding);if(!t.display)return;const i=Mb(e.rtl,this.left,this.width),o=this.ctx,a=t.position,l=r.size/2,c=s.top+l;let u,h=this.left,f=this.width;if(this.isHorizontal())f=Math.max(...this.lineWidths),u=this.top+c,h=Oo(e.align,h,this.right-f);else{const p=this.columnSizes.reduce((m,g)=>Math.max(m,g.height),0);u=c+Oo(e.align,this.top,this.bottom-p-e.labels.padding-this._computeTitleHeight())}const d=Oo(a,h,h+f);o.textAlign=i.textAlign(C4(a)),o.textBaseline="middle",o.strokeStyle=t.color,o.fillStyle=t.color,o.font=r.string,gg(o,t.text,d,u,r)}_computeTitleHeight(){const e=this.options.title,t=Wi(e.font),r=Yo(e.padding);return e.display?t.lineHeight+r.height:0}_getLegendItemAt(e,t){let r,s,i;if(Ef(e,this.left,this.right)&&Ef(t,this.top,this.bottom)){for(i=this.legendHitBoxes,r=0;r<i.length;++r)if(s=i[r],Ef(e,s.left,s.left+s.width)&&Ef(t,s.top,s.top+s.height))return this.legendItems[r]}return null}handleEvent(e){const t=this.options;if(!xat(e.type,t))return;const r=this._getLegendItemAt(e.x,e.y);if(e.type==="mousemove"||e.type==="mouseout"){const s=this._hoveredItem,i=yat(s,r);s&&!i&&os(t.onLeave,[e,s,this],this),this._hoveredItem=r,r&&!i&&os(t.onHover,[e,r,this],this)}else r&&os(t.onClick,[e,r,this],this)}}function bat(n,e,t,r,s){const i=vat(r,n,e,t),o=wat(s,r,e.lineHeight);return{itemWidth:i,itemHeight:o}}function vat(n,e,t,r){let s=n.text;return s&&typeof s!="string"&&(s=s.reduce((i,o)=>i.length>o.length?i:o)),e+t.size/2+r.measureText(s).width}function wat(n,e,t){let r=n;return typeof e.text!="string"&&(r=Pse(e,t)),r}function Pse(n,e){const t=n.text?n.text.length+.5:0;return e*t}function xat(n,e){return!!((n==="mousemove"||n==="mouseout")&&(e.onHover||e.onLeave)||e.onClick&&(n==="click"||n==="mouseup"))}var Sat={id:"legend",_element:M5,start(n,e,t){const r=n.legend=new M5({ctx:n.ctx,options:t,chart:n});vc.configure(n,r,t),vc.addBox(n,r)},stop(n){vc.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,e,t){const r=n.legend;vc.configure(n,r,t),r.options=t},afterUpdate(n){const e=n.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(n,e){e.replay||n.legend.handleEvent(e.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,e,t){const r=e.datasetIndex,s=t.chart;s.isDatasetVisible(r)?(s.hide(r),e.hidden=!0):(s.show(r),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const e=n.data.datasets,{labels:{usePointStyle:t,pointStyle:r,textAlign:s,color:i,useBorderRadius:o,borderRadius:a}}=n.legend.options;return n._getSortedDatasetMetas().map(l=>{const c=l.controller.getStyle(t?0:void 0),u=Yo(c.borderWidth);return{text:e[l.index].label,fillStyle:c.backgroundColor,fontColor:i,hidden:!l.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(u.width+u.height)/4,strokeStyle:c.borderColor,pointStyle:r||c.pointStyle,rotation:c.rotation,textAlign:s||c.textAlign,borderRadius:o&&(a||c.borderRadius),datasetIndex:l.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};class Dse extends Tu{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const r=this.options;if(this.left=0,this.top=0,!r.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=e,this.height=this.bottom=t;const s=gs(r.text)?r.text.length:1;this._padding=Yo(r.padding);const i=s*Wi(r.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=i:this.width=i}isHorizontal(){const e=this.options.position;return e==="top"||e==="bottom"}_drawArgs(e){const{top:t,left:r,bottom:s,right:i,options:o}=this,a=o.align;let l=0,c,u,h;return this.isHorizontal()?(u=Oo(a,r,i),h=t+e,c=i-r):(o.position==="left"?(u=r+e,h=Oo(a,s,t),l=Es*-.5):(u=i-e,h=Oo(a,t,s),l=Es*.5),c=s-t),{titleX:u,titleY:h,maxWidth:c,rotation:l}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const r=Wi(t.font),i=r.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(i);gg(e,t.text,0,0,r,{color:t.color,maxWidth:l,rotation:c,textAlign:C4(t.align),textBaseline:"middle",translation:[o,a]})}}function _at(n,e){const t=new Dse({ctx:n.ctx,options:e,chart:n});vc.configure(n,t,e),vc.addBox(n,t),n.titleBlock=t}var Cat={id:"title",_element:Dse,start(n,e,t){_at(n,t)},stop(n){const e=n.titleBlock;vc.removeBox(n,e),delete n.titleBlock},beforeUpdate(n,e,t){const r=n.titleBlock;vc.configure(n,r,t),r.options=t},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const E1={average(n){if(!n.length)return!1;let e,t,r=0,s=0,i=0;for(e=0,t=n.length;e<t;++e){const o=n[e].element;if(o&&o.hasValue()){const a=o.tooltipPosition();r+=a.x,s+=a.y,++i}}return{x:r/i,y:s/i}},nearest(n,e){if(!n.length)return!1;let t=e.x,r=e.y,s=Number.POSITIVE_INFINITY,i,o,a;for(i=0,o=n.length;i<o;++i){const l=n[i].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),u=XO(e,c);u<s&&(s=u,a=l)}}if(a){const l=a.tooltipPosition();t=l.x,r=l.y}return{x:t,y:r}}};function Qu(n,e){return e&&(gs(e)?Array.prototype.push.apply(n,e):n.push(e)),n}function ff(n){return(typeof n=="string"||n instanceof String)&&n.indexOf(`
`)>-1?n.split(`
`):n}function kat(n,e){const{element:t,datasetIndex:r,index:s}=e,i=n.getDatasetMeta(r).controller,{label:o,value:a}=i.getLabelAndValue(s);return{chart:n,label:o,parsed:i.getParsed(s),raw:n.data.datasets[r].data[s],formattedValue:a,dataset:i.getDataset(),dataIndex:s,datasetIndex:r,element:t}}function N5(n,e){const t=n.chart.ctx,{body:r,footer:s,title:i}=n,{boxWidth:o,boxHeight:a}=e,l=Wi(e.bodyFont),c=Wi(e.titleFont),u=Wi(e.footerFont),h=i.length,f=s.length,d=r.length,p=Yo(e.padding);let m=p.height,g=0,y=r.reduce((w,_)=>w+_.before.length+_.lines.length+_.after.length,0);if(y+=n.beforeBody.length+n.afterBody.length,h&&(m+=h*c.lineHeight+(h-1)*e.titleSpacing+e.titleMarginBottom),y){const w=e.displayColors?Math.max(a,l.lineHeight):l.lineHeight;m+=d*w+(y-d)*l.lineHeight+(y-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*u.lineHeight+(f-1)*e.footerSpacing);let b=0;const x=function(w){g=Math.max(g,t.measureText(w).width+b)};return t.save(),t.font=c.string,Dr(n.title,x),t.font=l.string,Dr(n.beforeBody.concat(n.afterBody),x),b=e.displayColors?o+2+e.boxPadding:0,Dr(r,w=>{Dr(w.before,x),Dr(w.lines,x),Dr(w.after,x)}),b=0,t.font=u.string,Dr(n.footer,x),t.restore(),g+=p.width,{width:g,height:m}}function Tat(n,e){const{y:t,height:r}=e;return t<r/2?"top":t>n.height-r/2?"bottom":"center"}function Eat(n,e,t,r){const{x:s,width:i}=r,o=t.caretSize+t.caretPadding;if(n==="left"&&s+i+o>e.width||n==="right"&&s-i-o<0)return!0}function Iat(n,e,t,r){const{x:s,width:i}=t,{width:o,chartArea:{left:a,right:l}}=n;let c="center";return r==="center"?c=s<=(a+l)/2?"left":"right":s<=i/2?c="left":s>=o-i/2&&(c="right"),Eat(c,n,e,t)&&(c="center"),c}function $5(n,e,t){const r=t.yAlign||e.yAlign||Tat(n,t);return{xAlign:t.xAlign||e.xAlign||Iat(n,e,t,r),yAlign:r}}function Aat(n,e){let{x:t,width:r}=n;return e==="right"?t-=r:e==="center"&&(t-=r/2),t}function Mat(n,e,t){let{y:r,height:s}=n;return e==="top"?r+=t:e==="bottom"?r-=s+t:r-=s/2,r}function R5(n,e,t,r){const{caretSize:s,caretPadding:i,cornerRadius:o}=n,{xAlign:a,yAlign:l}=t,c=s+i,{topLeft:u,topRight:h,bottomLeft:f,bottomRight:d}=jm(o);let p=Aat(e,a);const m=Mat(e,l,c);return l==="center"?a==="left"?p+=c:a==="right"&&(p-=c):a==="left"?p-=Math.max(u,f)+s:a==="right"&&(p+=Math.max(h,d)+s),{x:jo(p,0,r.width-e.width),y:jo(m,0,r.height-e.height)}}function vT(n,e,t){const r=Yo(t.padding);return e==="center"?n.x+n.width/2:e==="right"?n.x+n.width-r.right:n.x+r.left}function P5(n){return Qu([],ff(n))}function Nat(n,e,t){return Pp(n,{tooltip:e,tooltipItems:t,type:"tooltip"})}function D5(n,e){const t=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return t?n.override(t):n}const Ose={beforeTitle:rf,title(n){if(n.length>0){const e=n[0],t=e.chart.data.labels,r=t?t.length:0;if(this&&this.options&&this.options.mode==="dataset")return e.dataset.label||"";if(e.label)return e.label;if(r>0&&e.dataIndex<r)return t[e.dataIndex]}return""},afterTitle:rf,beforeBody:rf,beforeLabel:rf,label(n){if(this&&this.options&&this.options.mode==="dataset")return n.label+": "+n.formattedValue||n.formattedValue;let e=n.dataset.label||"";e&&(e+=": ");const t=n.formattedValue;return Nr(t)||(e+=t),e},labelColor(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:rf,afterBody:rf,beforeFooter:rf,footer:rf,afterFooter:rf};function Da(n,e,t,r){const s=n[e].call(t,r);return typeof s>"u"?Ose[e].call(t,r):s}class tF extends Tu{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,r=this.options.setContext(this.getContext()),s=r.enabled&&t.options.animation&&r.animations,i=new gse(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(i)),i}getContext(){return this.$context||(this.$context=Nat(this.chart.getContext(),this,this._tooltipItems))}getTitle(e,t){const{callbacks:r}=t,s=Da(r,"beforeTitle",this,e),i=Da(r,"title",this,e),o=Da(r,"afterTitle",this,e);let a=[];return a=Qu(a,ff(s)),a=Qu(a,ff(i)),a=Qu(a,ff(o)),a}getBeforeBody(e,t){return P5(Da(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:r}=t,s=[];return Dr(e,i=>{const o={before:[],lines:[],after:[]},a=D5(r,i);Qu(o.before,ff(Da(a,"beforeLabel",this,i))),Qu(o.lines,Da(a,"label",this,i)),Qu(o.after,ff(Da(a,"afterLabel",this,i))),s.push(o)}),s}getAfterBody(e,t){return P5(Da(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:r}=t,s=Da(r,"beforeFooter",this,e),i=Da(r,"footer",this,e),o=Da(r,"afterFooter",this,e);let a=[];return a=Qu(a,ff(s)),a=Qu(a,ff(i)),a=Qu(a,ff(o)),a}_createItems(e){const t=this._active,r=this.chart.data,s=[],i=[],o=[];let a=[],l,c;for(l=0,c=t.length;l<c;++l)a.push(kat(this.chart,t[l]));return e.filter&&(a=a.filter((u,h,f)=>e.filter(u,h,f,r))),e.itemSort&&(a=a.sort((u,h)=>e.itemSort(u,h,r))),Dr(a,u=>{const h=D5(e.callbacks,u);s.push(Da(h,"labelColor",this,u)),i.push(Da(h,"labelPointStyle",this,u)),o.push(Da(h,"labelTextColor",this,u))}),this.labelColors=s,this.labelPointStyles=i,this.labelTextColors=o,this.dataPoints=a,a}update(e,t){const r=this.options.setContext(this.getContext()),s=this._active;let i,o=[];if(!s.length)this.opacity!==0&&(i={opacity:0});else{const a=E1[r.position].call(this,s,this._eventPosition);o=this._createItems(r),this.title=this.getTitle(o,r),this.beforeBody=this.getBeforeBody(o,r),this.body=this.getBody(o,r),this.afterBody=this.getAfterBody(o,r),this.footer=this.getFooter(o,r);const l=this._size=N5(this,r),c=Object.assign({},a,l),u=$5(this.chart,r,c),h=R5(r,c,u,this.chart);this.xAlign=u.xAlign,this.yAlign=u.yAlign,i={opacity:1,x:h.x,y:h.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=o,this.$context=void 0,i&&this._resolveAnimations().update(this,i),e&&r.external&&r.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,r,s){const i=this.getCaretPosition(e,r,s);t.lineTo(i.x1,i.y1),t.lineTo(i.x2,i.y2),t.lineTo(i.x3,i.y3)}getCaretPosition(e,t,r){const{xAlign:s,yAlign:i}=this,{caretSize:o,cornerRadius:a}=r,{topLeft:l,topRight:c,bottomLeft:u,bottomRight:h}=jm(a),{x:f,y:d}=e,{width:p,height:m}=t;let g,y,b,x,w,_;return i==="center"?(w=d+m/2,s==="left"?(g=f,y=g-o,x=w+o,_=w-o):(g=f+p,y=g+o,x=w-o,_=w+o),b=g):(s==="left"?y=f+Math.max(l,u)+o:s==="right"?y=f+p-Math.max(c,h)-o:y=this.caretX,i==="top"?(x=d,w=x-o,g=y-o,b=y+o):(x=d+m,w=x+o,g=y+o,b=y-o),_=x),{x1:g,x2:y,x3:b,y1:x,y2:w,y3:_}}drawTitle(e,t,r){const s=this.title,i=s.length;let o,a,l;if(i){const c=Mb(r.rtl,this.x,this.width);for(e.x=vT(this,r.titleAlign,r),t.textAlign=c.textAlign(r.titleAlign),t.textBaseline="middle",o=Wi(r.titleFont),a=r.titleSpacing,t.fillStyle=r.titleColor,t.font=o.string,l=0;l<i;++l)t.fillText(s[l],c.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+a,l+1===i&&(e.y+=r.titleMarginBottom-a)}}_drawColorBox(e,t,r,s,i){const o=this.labelColors[r],a=this.labelPointStyles[r],{boxHeight:l,boxWidth:c,boxPadding:u}=i,h=Wi(i.bodyFont),f=vT(this,"left",i),d=s.x(f),p=l<h.lineHeight?(h.lineHeight-l)/2:0,m=t.y+p;if(i.usePointStyle){const g={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},y=s.leftForLtr(d,c)+c/2,b=m+l/2;e.strokeStyle=i.multiKeyBackground,e.fillStyle=i.multiKeyBackground,YO(e,g,y,b),e.strokeStyle=o.borderColor,e.fillStyle=o.backgroundColor,YO(e,g,y,b)}else{e.lineWidth=sr(o.borderWidth)?Math.max(...Object.values(o.borderWidth)):o.borderWidth||1,e.strokeStyle=o.borderColor,e.setLineDash(o.borderDash||[]),e.lineDashOffset=o.borderDashOffset||0;const g=s.leftForLtr(d,c-u),y=s.leftForLtr(s.xPlus(d,1),c-u-2),b=jm(o.borderRadius);Object.values(b).some(x=>x!==0)?(e.beginPath(),e.fillStyle=i.multiKeyBackground,KS(e,{x:g,y:m,w:c,h:l,radius:b}),e.fill(),e.stroke(),e.fillStyle=o.backgroundColor,e.beginPath(),KS(e,{x:y,y:m+1,w:c-2,h:l-2,radius:b}),e.fill()):(e.fillStyle=i.multiKeyBackground,e.fillRect(g,m,c,l),e.strokeRect(g,m,c,l),e.fillStyle=o.backgroundColor,e.fillRect(y,m+1,c-2,l-2))}e.fillStyle=this.labelTextColors[r]}drawBody(e,t,r){const{body:s}=this,{bodySpacing:i,bodyAlign:o,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:u}=r,h=Wi(r.bodyFont);let f=h.lineHeight,d=0;const p=Mb(r.rtl,this.x,this.width),m=function(A){t.fillText(A,p.x(e.x+d),e.y+f/2),e.y+=f+i},g=p.textAlign(o);let y,b,x,w,_,C,k;for(t.textAlign=o,t.textBaseline="middle",t.font=h.string,e.x=vT(this,g,r),t.fillStyle=r.bodyColor,Dr(this.beforeBody,m),d=a&&g!=="right"?o==="center"?c/2+u:c+2+u:0,w=0,C=s.length;w<C;++w){for(y=s[w],b=this.labelTextColors[w],t.fillStyle=b,Dr(y.before,m),x=y.lines,a&&x.length&&(this._drawColorBox(t,e,w,p,r),f=Math.max(h.lineHeight,l)),_=0,k=x.length;_<k;++_)m(x[_]),f=h.lineHeight;Dr(y.after,m)}d=0,f=h.lineHeight,Dr(this.afterBody,m),e.y-=i}drawFooter(e,t,r){const s=this.footer,i=s.length;let o,a;if(i){const l=Mb(r.rtl,this.x,this.width);for(e.x=vT(this,r.footerAlign,r),e.y+=r.footerMarginTop,t.textAlign=l.textAlign(r.footerAlign),t.textBaseline="middle",o=Wi(r.footerFont),t.fillStyle=r.footerColor,t.font=o.string,a=0;a<i;++a)t.fillText(s[a],l.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+r.footerSpacing}}drawBackground(e,t,r,s){const{xAlign:i,yAlign:o}=this,{x:a,y:l}=e,{width:c,height:u}=r,{topLeft:h,topRight:f,bottomLeft:d,bottomRight:p}=jm(s.cornerRadius);t.fillStyle=s.backgroundColor,t.strokeStyle=s.borderColor,t.lineWidth=s.borderWidth,t.beginPath(),t.moveTo(a+h,l),o==="top"&&this.drawCaret(e,t,r,s),t.lineTo(a+c-f,l),t.quadraticCurveTo(a+c,l,a+c,l+f),o==="center"&&i==="right"&&this.drawCaret(e,t,r,s),t.lineTo(a+c,l+u-p),t.quadraticCurveTo(a+c,l+u,a+c-p,l+u),o==="bottom"&&this.drawCaret(e,t,r,s),t.lineTo(a+d,l+u),t.quadraticCurveTo(a,l+u,a,l+u-d),o==="center"&&i==="left"&&this.drawCaret(e,t,r,s),t.lineTo(a,l+h),t.quadraticCurveTo(a,l,a+h,l),t.closePath(),t.fill(),s.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,r=this.$animations,s=r&&r.x,i=r&&r.y;if(s||i){const o=E1[e.position].call(this,this._active,this._eventPosition);if(!o)return;const a=this._size=N5(this,e),l=Object.assign({},o,this._size),c=$5(t,e,l),u=R5(e,l,c,t);(s._to!==u.x||i._to!==u.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=o.x,this.caretY=o.y,this._resolveAnimations().update(this,u))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let r=this.opacity;if(!r)return;this._updateAnimationTarget(t);const s={width:this.width,height:this.height},i={x:this.x,y:this.y};r=Math.abs(r)<.001?0:r;const o=Yo(t.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&a&&(e.save(),e.globalAlpha=r,this.drawBackground(i,e,s,t),hse(e,t.textDirection),i.y+=o.top,this.drawTitle(i,e,t),this.drawBody(i,e,t),this.drawFooter(i,e,t),fse(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const r=this._active,s=e.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:c.data[l],index:l}}),i=!rA(r,s),o=this._positionChanged(s,t);(i||o)&&(this._active=s,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t,r=!0){if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,i=this._active||[],o=this._getActiveElements(e,i,t,r),a=this._positionChanged(o,e),l=t||!rA(o,i)||a;return l&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),l}_getActiveElements(e,t,r,s){const i=this.options;if(e.type==="mouseout")return[];if(!s)return t;const o=this.chart.getElementsAtEventForMode(e,i.mode,i,r);return i.reverse&&o.reverse(),o}_positionChanged(e,t){const{caretX:r,caretY:s,options:i}=this,o=E1[i.position].call(this,e,t);return o!==!1&&(r!==o.x||s!==o.y)}}zt(tF,"positioners",E1);var $at={id:"tooltip",_element:tF,positioners:E1,afterInit(n,e,t){t&&(n.tooltip=new tF({chart:n,options:t}))},beforeUpdate(n,e,t){n.tooltip&&n.tooltip.initialize(t)},reset(n,e,t){n.tooltip&&n.tooltip.initialize(t)},afterDraw(n){const e=n.tooltip;if(e&&e._willRender()){const t={tooltip:e};if(n.notifyPlugins("beforeTooltipDraw",{...t,cancelable:!0})===!1)return;e.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",t)}},afterEvent(n,e){if(n.tooltip){const t=e.replay;n.tooltip.handleEvent(e.event,t,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,e)=>e.bodyFont.size,boxWidth:(n,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Ose},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>n!=="filter"&&n!=="itemSort"&&n!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const Rat=(n,e,t,r)=>(typeof e=="string"?(t=n.push(e)-1,r.unshift({index:t,label:e})):isNaN(e)&&(t=null),t);function Pat(n,e,t,r){const s=n.indexOf(e);if(s===-1)return Rat(n,e,t,r);const i=n.lastIndexOf(e);return s!==i?t:s}const Dat=(n,e)=>n===null?null:jo(Math.round(n),0,e);function O5(n){const e=this.getLabels();return n>=0&&n<e.length?e[n]:n}class nF extends Xy{constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const r=this.getLabels();for(const{index:s,label:i}of t)r[s]===i&&r.splice(s,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(Nr(e))return null;const r=this.getLabels();return t=isFinite(t)&&r[t]===e?t:Pat(r,e,Wn(t,e),this._addedLabels),Dat(t,r.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:r,max:s}=this.getMinMax(!0);this.options.bounds==="ticks"&&(e||(r=0),t||(s=this.getLabels().length-1)),this.min=r,this.max=s}buildTicks(){const e=this.min,t=this.max,r=this.options.offset,s=[];let i=this.getLabels();i=e===0&&t===i.length-1?i:i.slice(e,t+1),this._valueRange=Math.max(i.length-(r?0:1),1),this._startValue=this.min-(r?.5:0);for(let o=e;o<=t;o++)s.push({value:o});return s}getLabelForValue(e){return O5.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return typeof e!="number"&&(e=this.parse(e)),e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}zt(nF,"id","category"),zt(nF,"defaults",{ticks:{callback:O5}});function Oat(n,e){const t=[],{bounds:s,step:i,min:o,max:a,precision:l,count:c,maxTicks:u,maxDigits:h,includeBounds:f}=n,d=i||1,p=u-1,{min:m,max:g}=e,y=!Nr(o),b=!Nr(a),x=!Nr(c),w=(g-m)/(h+1);let _=D6((g-m)/p/d)*d,C,k,A,M;if(_<1e-14&&!y&&!b)return[{value:m},{value:g}];M=Math.ceil(g/_)-Math.floor(m/_),M>p&&(_=D6(M*_/p/d)*d),Nr(l)||(C=Math.pow(10,l),_=Math.ceil(_*C)/C),s==="ticks"?(k=Math.floor(m/_)*_,A=Math.ceil(g/_)*_):(k=m,A=g),y&&b&&i&&jrt((a-o)/i,_/1e3)?(M=Math.round(Math.min((a-o)/_,u)),_=(a-o)/M,k=o,A=a):x?(k=y?o:k,A=b?a:A,M=c-1,_=(A-k)/M):(M=(A-k)/_,Y1(M,Math.round(M),_/1e3)?M=Math.round(M):M=Math.ceil(M));const I=Math.max(O6(_),O6(k));C=Math.pow(10,Nr(l)?I:l),k=Math.round(k*C)/C,A=Math.round(A*C)/C;let N=0;for(y&&(f&&k!==o?(t.push({value:o}),k<o&&N++,Y1(Math.round((k+N*_)*C)/C,o,F5(o,w,n))&&N++):k<o&&N++);N<M;++N)t.push({value:Math.round((k+N*_)*C)/C});return b&&f&&A!==a?t.length&&Y1(t[t.length-1].value,a,F5(a,w,n))?t[t.length-1].value=a:t.push({value:a}):(!b||A===a)&&t.push({value:A}),t}function F5(n,e,{horizontal:t,minRotation:r}){const s=fu(r),i=(t?Math.sin(s):Math.cos(s))||.001,o=.75*e*(""+n).length;return Math.min(e/i,o)}class hA extends Xy{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return Nr(e)||(typeof e=="number"||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:r}=this.getUserBounds();let{min:s,max:i}=this;const o=l=>s=t?s:l,a=l=>i=r?i:l;if(e){const l=vh(s),c=vh(i);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(s===i){let l=i===0?1:Math.abs(i*.05);a(i+l),e||o(s-l)}this.min=s,this.max=i}getTickLimit(){const e=this.options.ticks;let{maxTicksLimit:t,stepSize:r}=e,s;return r?(s=Math.ceil(this.max/r)-Math.floor(this.min/r)+1,s>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${s} ticks. Limiting to 1000.`),s=1e3)):(s=this.computeTickLimit(),t=t||11),t&&(s=Math.min(t,s)),s}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let r=this.getTickLimit();r=Math.max(2,r);const s={maxTicks:r,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:t.includeBounds!==!1},i=this._range||this,o=Oat(s,i);return e.bounds==="ticks"&&jre(o,this,"value"),e.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const e=this.ticks;let t=this.min,r=this.max;if(super.configure(),this.options.offset&&e.length){const s=(r-t)/Math.max(e.length-1,1)/2;t-=s,r+=s}this._startValue=t,this._endValue=r,this._valueRange=r-t}getLabelForValue(e){return AC(e,this.chart.options.locale,this.options.ticks.format)}}class rF extends hA{determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Ys(e)?e:0,this.max=Ys(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,r=fu(this.options.ticks.minRotation),s=(e?Math.sin(r):Math.cos(r))||.001,i=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,i.lineHeight/s))}getPixelForValue(e){return e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}zt(rF,"id","linear"),zt(rF,"defaults",{ticks:{callback:d$.formatters.numeric}});const ZS=n=>Math.floor(Pd(n)),im=(n,e)=>Math.pow(10,ZS(n)+e);function L5(n){return n/Math.pow(10,ZS(n))===1}function z5(n,e,t){const r=Math.pow(10,t),s=Math.floor(n/r);return Math.ceil(e/r)-s}function Fat(n,e){const t=e-n;let r=ZS(t);for(;z5(n,e,r)>10;)r++;for(;z5(n,e,r)<10;)r--;return Math.min(r,ZS(n))}function Lat(n,{min:e,max:t}){e=yl(n.min,e);const r=[],s=ZS(e);let i=Fat(e,t),o=i<0?Math.pow(10,Math.abs(i)):1;const a=Math.pow(10,i),l=s>i?Math.pow(10,s):0,c=Math.round((e-l)*o)/o,u=Math.floor((e-l)/a/10)*a*10;let h=Math.floor((c-u)/Math.pow(10,i)),f=yl(n.min,Math.round((l+u+h*Math.pow(10,i))*o)/o);for(;f<t;)r.push({value:f,major:L5(f),significand:h}),h>=10?h=h<15?15:20:h++,h>=20&&(i++,h=2,o=i>=0?1:o),f=Math.round((l+u+h*Math.pow(10,i))*o)/o;const d=yl(n.max,f);return r.push({value:d,major:L5(d),significand:h}),r}class sF extends Xy{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const r=hA.prototype.parse.apply(this,[e,t]);if(r===0){this._zero=!0;return}return Ys(r)&&r>0?r:null}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Ys(e)?Math.max(0,e):null,this.max=Ys(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Ys(this._userMin)&&(this.min=e===im(this.min,0)?im(this.min,-1):im(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let r=this.min,s=this.max;const i=a=>r=e?r:a,o=a=>s=t?s:a;r===s&&(r<=0?(i(1),o(10)):(i(im(r,-1)),o(im(s,1)))),r<=0&&i(im(s,-1)),s<=0&&o(im(r,1)),this.min=r,this.max=s}buildTicks(){const e=this.options,t={min:this._userMin,max:this._userMax},r=Lat(t,this);return e.bounds==="ticks"&&jre(r,this,"value"),e.reverse?(r.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),r}getLabelForValue(e){return e===void 0?"0":AC(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=Pd(e),this._valueRange=Pd(this.max)-Pd(e)}getPixelForValue(e){return(e===void 0||e===0)&&(e=this.min),e===null||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:(Pd(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}zt(sF,"id","logarithmic"),zt(sF,"defaults",{ticks:{callback:d$.formatters.logarithmic,major:{enabled:!0}}});function iF(n){const e=n.ticks;if(e.display&&n.display){const t=Yo(e.backdropPadding);return Wn(e.font&&e.font.size,oi.font.size)+t.height}return 0}function zat(n,e,t){return t=gs(t)?t:[t],{w:cst(n,e.string,t),h:t.length*e.lineHeight}}function B5(n,e,t,r,s){return n===r||n===s?{start:e-t/2,end:e+t/2}:n<r||n>s?{start:e-t,end:e}:{start:e,end:e+t}}function Bat(n){const e={l:n.left+n._padding.left,r:n.right-n._padding.right,t:n.top+n._padding.top,b:n.bottom-n._padding.bottom},t=Object.assign({},e),r=[],s=[],i=n._pointLabels.length,o=n.options.pointLabels,a=o.centerPointLabels?Es/i:0;for(let l=0;l<i;l++){const c=o.setContext(n.getPointLabelContext(l));s[l]=c.padding;const u=n.getPointPosition(l,n.drawingArea+s[l],a),h=Wi(c.font),f=zat(n.ctx,h,n._pointLabels[l]);r[l]=f;const d=bl(n.getIndexAngle(l)+a),p=Math.round(S4(d)),m=B5(p,u.x,f.w,0,180),g=B5(p,u.y,f.h,90,270);Vat(t,e,d,m,g)}n.setCenterPoint(e.l-t.l,t.r-e.r,e.t-t.t,t.b-e.b),n._pointLabelItems=Uat(n,r,s)}function Vat(n,e,t,r,s){const i=Math.abs(Math.sin(t)),o=Math.abs(Math.cos(t));let a=0,l=0;r.start<e.l?(a=(e.l-r.start)/i,n.l=Math.min(n.l,e.l-a)):r.end>e.r&&(a=(r.end-e.r)/i,n.r=Math.max(n.r,e.r+a)),s.start<e.t?(l=(e.t-s.start)/o,n.t=Math.min(n.t,e.t-l)):s.end>e.b&&(l=(s.end-e.b)/o,n.b=Math.max(n.b,e.b+l))}function Uat(n,e,t){const r=[],s=n._pointLabels.length,i=n.options,o=iF(i)/2,a=n.drawingArea,l=i.pointLabels.centerPointLabels?Es/s:0;for(let c=0;c<s;c++){const u=n.getPointPosition(c,a+o+t[c],l),h=Math.round(S4(bl(u.angle+Zs))),f=e[c],d=Hat(u.y,f.h,h),p=Wat(h),m=Gat(u.x,f.w,p);r.push({x:u.x,y:d,textAlign:p,left:m,top:d,right:m+f.w,bottom:d+f.h})}return r}function Wat(n){return n===0||n===180?"center":n<180?"left":"right"}function Gat(n,e,t){return t==="right"?n-=e:t==="center"&&(n-=e/2),n}function Hat(n,e,t){return t===90||t===270?n-=e/2:(t>270||t<90)&&(n-=e),n}function jat(n,e){const{ctx:t,options:{pointLabels:r}}=n;for(let s=e-1;s>=0;s--){const i=r.setContext(n.getPointLabelContext(s)),o=Wi(i.font),{x:a,y:l,textAlign:c,left:u,top:h,right:f,bottom:d}=n._pointLabelItems[s],{backdropColor:p}=i;if(!Nr(p)){const m=jm(i.borderRadius),g=Yo(i.backdropPadding);t.fillStyle=p;const y=u-g.left,b=h-g.top,x=f-u+g.width,w=d-h+g.height;Object.values(m).some(_=>_!==0)?(t.beginPath(),KS(t,{x:y,y:b,w:x,h:w,radius:m}),t.fill()):t.fillRect(y,b,x,w)}gg(t,n._pointLabels[s],a,l+o.lineHeight/2,o,{color:i.color,textAlign:c,textBaseline:"middle"})}}function Fse(n,e,t,r){const{ctx:s}=n;if(t)s.arc(n.xCenter,n.yCenter,e,0,bs);else{let i=n.getPointPosition(0,e);s.moveTo(i.x,i.y);for(let o=1;o<r;o++)i=n.getPointPosition(o,e),s.lineTo(i.x,i.y)}}function qat(n,e,t,r,s){const i=n.ctx,o=e.circular,{color:a,lineWidth:l}=e;!o&&!r||!a||!l||t<0||(i.save(),i.strokeStyle=a,i.lineWidth=l,i.setLineDash(s.dash),i.lineDashOffset=s.dashOffset,i.beginPath(),Fse(n,t,o,r),i.closePath(),i.stroke(),i.restore())}function Xat(n,e,t){return Pp(n,{label:t,index:e,type:"pointLabel"})}class I1 extends hA{constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=Yo(iF(this.options)/2),t=this.width=this.maxWidth-e.width,r=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+r/2+e.top),this.drawingArea=Math.floor(Math.min(t,r)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=Ys(e)&&!isNaN(e)?e:0,this.max=Ys(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/iF(this.options))}generateTickLabels(e){hA.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map((t,r)=>{const s=os(this.options.pointLabels.callback,[t,r],this);return s||s===0?s:""}).filter((t,r)=>this.chart.getDataVisibility(r))}fit(){const e=this.options;e.display&&e.pointLabels.display?Bat(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,r,s){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((r-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,r,s))}getIndexAngle(e){const t=bs/(this._pointLabels.length||1),r=this.options.startAngle||0;return bl(e*t+fu(r))}getDistanceFromCenterForValue(e){if(Nr(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(Nr(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const r=t[e];return Xat(this.getContext(),e,r)}}getPointPosition(e,t,r=0){const s=this.getIndexAngle(e)-Zs+r;return{x:Math.cos(s)*t+this.xCenter,y:Math.sin(s)*t+this.yCenter,angle:s}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:r,right:s,bottom:i}=this._pointLabelItems[e];return{left:t,top:r,right:s,bottom:i}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const r=this.ctx;r.save(),r.beginPath(),Fse(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),r.closePath(),r.fillStyle=e,r.fill(),r.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:r,grid:s,border:i}=t,o=this._pointLabels.length;let a,l,c;if(t.pointLabels.display&&jat(this,o),s.display&&this.ticks.forEach((u,h)=>{if(h!==0){l=this.getDistanceFromCenterForValue(u.value);const f=this.getContext(h),d=s.setContext(f),p=i.setContext(f);qat(this,d,l,o,p)}}),r.display){for(e.save(),a=o-1;a>=0;a--){const u=r.setContext(this.getPointLabelContext(a)),{color:h,lineWidth:f}=u;!f||!h||(e.lineWidth=f,e.strokeStyle=h,e.setLineDash(u.borderDash),e.lineDashOffset=u.borderDashOffset,l=this.getDistanceFromCenterForValue(t.ticks.reverse?this.min:this.max),c=this.getPointPosition(a,l),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(c.x,c.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,r=t.ticks;if(!r.display)return;const s=this.getIndexAngle(0);let i,o;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(s),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&!t.reverse)return;const c=r.setContext(this.getContext(l)),u=Wi(c.font);if(i=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){e.font=u.string,o=e.measureText(a.label).width,e.fillStyle=c.backdropColor;const h=Yo(c.backdropPadding);e.fillRect(-o/2-h.left,-i-u.size/2-h.top,o+h.width,u.size+h.height)}gg(e,a.label,0,-i,u,{color:c.color})}),e.restore()}drawTitle(){}}zt(I1,"id","radialLinear"),zt(I1,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:d$.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(e){return e},padding:5,centerPointLabels:!1}}),zt(I1,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),zt(I1,"descriptors",{angleLines:{_fallback:"grid"}});const y$={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Ba=Object.keys(y$);function Kat(n,e){return n-e}function V5(n,e){if(Nr(e))return null;const t=n._adapter,{parser:r,round:s,isoWeekday:i}=n._parseOpts;let o=e;return typeof r=="function"&&(o=r(o)),Ys(o)||(o=typeof r=="string"?t.parse(o,r):t.parse(o)),o===null?null:(s&&(o=s==="week"&&(rv(i)||i===!0)?t.startOf(o,"isoWeek",i):t.startOf(o,s)),+o)}function U5(n,e,t,r){const s=Ba.length;for(let i=Ba.indexOf(n);i<s-1;++i){const o=y$[Ba[i]],a=o.steps?o.steps:Number.MAX_SAFE_INTEGER;if(o.common&&Math.ceil((t-e)/(a*o.size))<=r)return Ba[i]}return Ba[s-1]}function Yat(n,e,t,r,s){for(let i=Ba.length-1;i>=Ba.indexOf(t);i--){const o=Ba[i];if(y$[o].common&&n._adapter.diff(s,r,o)>=e-1)return o}return Ba[t?Ba.indexOf(t):0]}function Zat(n){for(let e=Ba.indexOf(n)+1,t=Ba.length;e<t;++e)if(y$[Ba[e]].common)return Ba[e]}function W5(n,e,t){if(!t)n[e]=!0;else if(t.length){const{lo:r,hi:s}=_4(t,e),i=t[r]>=e?t[r]:t[s];n[i]=!0}}function Jat(n,e,t,r){const s=n._adapter,i=+s.startOf(e[0].value,r),o=e[e.length-1].value;let a,l;for(a=i;a<=o;a=+s.add(a,1,r))l=t[a],l>=0&&(e[l].major=!0);return e}function G5(n,e,t){const r=[],s={},i=e.length;let o,a;for(o=0;o<i;++o)a=e[o],s[a]=o,r.push({value:a,major:!1});return i===0||!t?r:Jat(n,r,s,t)}class JS extends Xy{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e,t={}){const r=e.time||(e.time={}),s=this._adapter=new vse._date(e.adapters.date);s.init(t),K1(r.displayFormats,s.formats()),this._parseOpts={parser:r.parser,round:r.round,isoWeekday:r.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return e===void 0?null:V5(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,r=e.time.unit||"day";let{min:s,max:i,minDefined:o,maxDefined:a}=this.getUserBounds();function l(c){!o&&!isNaN(c.min)&&(s=Math.min(s,c.min)),!a&&!isNaN(c.max)&&(i=Math.max(i,c.max))}(!o||!a)&&(l(this._getLabelBounds()),(e.bounds!=="ticks"||e.ticks.source!=="labels")&&l(this.getMinMax(!1))),s=Ys(s)&&!isNaN(s)?s:+t.startOf(Date.now(),r),i=Ys(i)&&!isNaN(i)?i:+t.endOf(Date.now(),r)+1,this.min=Math.min(s,i-1),this.max=Math.max(s+1,i)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],r=e[e.length-1]),{min:t,max:r}}buildTicks(){const e=this.options,t=e.time,r=e.ticks,s=r.source==="labels"?this.getLabelTimestamps():this._generate();e.bounds==="ticks"&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const i=this.min,o=this.max,a=Yrt(s,i,o);return this._unit=t.unit||(r.autoSkip?U5(t.minUnit,this.min,this.max,this._getLabelCapacity(i)):Yat(this,a.length,t.minUnit,this.min,this.max)),this._majorUnit=!r.major.enabled||this._unit==="year"?void 0:Zat(this._unit),this.initOffsets(s),e.reverse&&a.reverse(),G5(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(e=[]){let t=0,r=0,s,i;this.options.offset&&e.length&&(s=this.getDecimalForValue(e[0]),e.length===1?t=1-s:t=(this.getDecimalForValue(e[1])-s)/2,i=this.getDecimalForValue(e[e.length-1]),e.length===1?r=i:r=(i-this.getDecimalForValue(e[e.length-2]))/2);const o=e.length<3?.5:.25;t=jo(t,0,o),r=jo(r,0,o),this._offsets={start:t,end:r,factor:1/(t+1+r)}}_generate(){const e=this._adapter,t=this.min,r=this.max,s=this.options,i=s.time,o=i.unit||U5(i.minUnit,t,r,this._getLabelCapacity(t)),a=Wn(s.ticks.stepSize,1),l=o==="week"?i.isoWeekday:!1,c=rv(l)||l===!0,u={};let h=t,f,d;if(c&&(h=+e.startOf(h,"isoWeek",l)),h=+e.startOf(h,c?"day":o),e.diff(r,t,o)>1e5*a)throw new Error(t+" and "+r+" are too far apart with stepSize of "+a+" "+o);const p=s.ticks.source==="data"&&this.getDataTimestamps();for(f=h,d=0;f<r;f=+e.add(f,a,o),d++)W5(u,f,p);return(f===r||s.bounds==="ticks"||d===1)&&W5(u,f,p),Object.keys(u).sort((m,g)=>m-g).map(m=>+m)}getLabelForValue(e){const t=this._adapter,r=this.options.time;return r.tooltipFormat?t.format(e,r.tooltipFormat):t.format(e,r.displayFormats.datetime)}format(e,t){const s=this.options.time.displayFormats,i=this._unit,o=t||s[i];return this._adapter.format(e,o)}_tickFormatFunction(e,t,r,s){const i=this.options,o=i.ticks.callback;if(o)return os(o,[e,t,r],this);const a=i.time.displayFormats,l=this._unit,c=this._majorUnit,u=l&&a[l],h=c&&a[c],f=r[t],d=c&&h&&f&&f.major;return this._adapter.format(e,s||(d?h:u))}generateTickLabels(e){let t,r,s;for(t=0,r=e.length;t<r;++t)s=e[t],s.label=this._tickFormatFunction(s.value,t,e)}getDecimalForValue(e){return e===null?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,r=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+r)*t.factor)}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+r*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,r=this.ctx.measureText(e).width,s=fu(this.isHorizontal()?t.maxRotation:t.minRotation),i=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:r*i+a*o,h:r*o+a*i}}_getLabelCapacity(e){const t=this.options.time,r=t.displayFormats,s=r[t.unit]||r.millisecond,i=this._tickFormatFunction(e,0,G5(this,[e],this._majorUnit),s),o=this._getLabelSize(i),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let e=this._cache.data||[],t,r;if(e.length)return e;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,r=s.length;t<r;++t)e=e.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(e)}getLabelTimestamps(){const e=this._cache.labels||[];let t,r;if(e.length)return e;const s=this.getLabels();for(t=0,r=s.length;t<r;++t)e.push(V5(this,s[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return Kre(e.sort(Kat))}}zt(JS,"id","time"),zt(JS,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});function wT(n,e,t){let r=0,s=n.length-1,i,o,a,l;t?(e>=n[r].pos&&e<=n[s].pos&&({lo:r,hi:s}=Fm(n,"pos",e)),{pos:i,time:a}=n[r],{pos:o,time:l}=n[s]):(e>=n[r].time&&e<=n[s].time&&({lo:r,hi:s}=Fm(n,"time",e)),{time:i,pos:a}=n[r],{time:o,pos:l}=n[s]);const c=o-i;return c?a+(l-a)*(e-i)/c:a}class oF extends JS{constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=wT(t,this.min),this._tableRange=wT(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:r}=this,s=[],i=[];let o,a,l,c,u;for(o=0,a=e.length;o<a;++o)c=e[o],c>=t&&c<=r&&s.push(c);if(s.length<2)return[{time:t,pos:0},{time:r,pos:1}];for(o=0,a=s.length;o<a;++o)u=s[o+1],l=s[o-1],c=s[o],Math.round((u+l)/2)!==c&&i.push({time:c,pos:o/(a-1)});return i}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),r=this.getLabelTimestamps();return t.length&&r.length?e=this.normalize(t.concat(r)):e=t.length?t:r,e=this._cache.all=e,e}getDecimalForValue(e){return(wT(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return wT(this._table,r*this._tableRange+this._minPos,!0)}}zt(oF,"id","timeseries"),zt(oF,"defaults",JS.defaults);class Ky extends Error{}class Qat extends Ky{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}}class elt extends Ky{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}}class tlt extends Ky{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}}class A1 extends Ky{}class Lse extends Ky{constructor(e){super(`Invalid unit ${e}`)}}class hc extends Ky{}class cd extends Ky{constructor(){super("Zone is an abstract class")}}const Lt="numeric",Eu="short",Al="long",fA={year:Lt,month:Lt,day:Lt},zse={year:Lt,month:Eu,day:Lt},nlt={year:Lt,month:Eu,day:Lt,weekday:Eu},Bse={year:Lt,month:Al,day:Lt},Vse={year:Lt,month:Al,day:Lt,weekday:Al},Use={hour:Lt,minute:Lt},Wse={hour:Lt,minute:Lt,second:Lt},Gse={hour:Lt,minute:Lt,second:Lt,timeZoneName:Eu},Hse={hour:Lt,minute:Lt,second:Lt,timeZoneName:Al},jse={hour:Lt,minute:Lt,hourCycle:"h23"},qse={hour:Lt,minute:Lt,second:Lt,hourCycle:"h23"},Xse={hour:Lt,minute:Lt,second:Lt,hourCycle:"h23",timeZoneName:Eu},Kse={hour:Lt,minute:Lt,second:Lt,hourCycle:"h23",timeZoneName:Al},Yse={year:Lt,month:Lt,day:Lt,hour:Lt,minute:Lt},Zse={year:Lt,month:Lt,day:Lt,hour:Lt,minute:Lt,second:Lt},Jse={year:Lt,month:Eu,day:Lt,hour:Lt,minute:Lt},Qse={year:Lt,month:Eu,day:Lt,hour:Lt,minute:Lt,second:Lt},rlt={year:Lt,month:Eu,day:Lt,weekday:Eu,hour:Lt,minute:Lt},eie={year:Lt,month:Al,day:Lt,hour:Lt,minute:Lt,timeZoneName:Eu},tie={year:Lt,month:Al,day:Lt,hour:Lt,minute:Lt,second:Lt,timeZoneName:Eu},nie={year:Lt,month:Al,day:Lt,weekday:Al,hour:Lt,minute:Lt,timeZoneName:Al},rie={year:Lt,month:Al,day:Lt,weekday:Al,hour:Lt,minute:Lt,second:Lt,timeZoneName:Al};class NC{get type(){throw new cd}get name(){throw new cd}get ianaName(){return this.name}get isUniversal(){throw new cd}offsetName(e,t){throw new cd}formatOffset(e,t){throw new cd}offset(e){throw new cd}equals(e){throw new cd}get isValid(){throw new cd}}let B3=null;class b$ extends NC{static get instance(){return B3===null&&(B3=new b$),B3}get type(){return"system"}get name(){return new Intl.DateTimeFormat().resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return iie(e,t,r)}formatOffset(e,t){return eS(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return e.type==="system"}get isValid(){return!0}}let KE={};function slt(n){return KE[n]||(KE[n]=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:n,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"})),KE[n]}const ilt={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function olt(n,e){const t=n.format(e).replace(/\u200E/g,""),r=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t),[,s,i,o,a,l,c,u]=r;return[o,s,i,a,l,c,u]}function alt(n,e){const t=n.formatToParts(e),r=[];for(let s=0;s<t.length;s++){const{type:i,value:o}=t[s],a=ilt[i];i==="era"?r[a]=o:hr(a)||(r[a]=parseInt(o,10))}return r}let xT={};class Of extends NC{static create(e){return xT[e]||(xT[e]=new Of(e)),xT[e]}static resetCache(){xT={},KE={}}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch{return!1}}constructor(e){super(),this.zoneName=e,this.valid=Of.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return iie(e,t,r,this.name)}formatOffset(e,t){return eS(this.offset(e),t)}offset(e){const t=new Date(e);if(isNaN(t))return NaN;const r=slt(this.name);let[s,i,o,a,l,c,u]=r.formatToParts?alt(r,t):olt(r,t);a==="BC"&&(s=-Math.abs(s)+1);const f=w$({year:s,month:i,day:o,hour:l===24?0:l,minute:c,second:u,millisecond:0});let d=+t;const p=d%1e3;return d-=p>=0?p:1e3+p,(f-d)/(60*1e3)}equals(e){return e.type==="iana"&&e.name===this.name}get isValid(){return this.valid}}let H5={};function llt(n,e={}){const t=JSON.stringify([n,e]);let r=H5[t];return r||(r=new Intl.ListFormat(n,e),H5[t]=r),r}let aF={};function lF(n,e={}){const t=JSON.stringify([n,e]);let r=aF[t];return r||(r=new Intl.DateTimeFormat(n,e),aF[t]=r),r}let cF={};function clt(n,e={}){const t=JSON.stringify([n,e]);let r=cF[t];return r||(r=new Intl.NumberFormat(n,e),cF[t]=r),r}let uF={};function ult(n,e={}){const{base:t,...r}=e,s=JSON.stringify([n,r]);let i=uF[s];return i||(i=new Intl.RelativeTimeFormat(n,e),uF[s]=i),i}let M1=null;function hlt(){return M1||(M1=new Intl.DateTimeFormat().resolvedOptions().locale,M1)}function flt(n){const e=n.indexOf("-x-");e!==-1&&(n=n.substring(0,e));const t=n.indexOf("-u-");if(t===-1)return[n];{let r,s;try{r=lF(n).resolvedOptions(),s=n}catch{const l=n.substring(0,t);r=lF(l).resolvedOptions(),s=l}const{numberingSystem:i,calendar:o}=r;return[s,i,o]}}function dlt(n,e,t){return(t||e)&&(n.includes("-u-")||(n+="-u"),t&&(n+=`-ca-${t}`),e&&(n+=`-nu-${e}`)),n}function plt(n){const e=[];for(let t=1;t<=12;t++){const r=yn.utc(2009,t,1);e.push(n(r))}return e}function mlt(n){const e=[];for(let t=1;t<=7;t++){const r=yn.utc(2016,11,13+t);e.push(n(r))}return e}function ST(n,e,t,r){const s=n.listingMode();return s==="error"?null:s==="en"?t(e):r(e)}function glt(n){return n.numberingSystem&&n.numberingSystem!=="latn"?!1:n.numberingSystem==="latn"||!n.locale||n.locale.startsWith("en")||new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem==="latn"}class ylt{constructor(e,t,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;const{padTo:s,floor:i,...o}=r;if(!t||Object.keys(o).length>0){const a={useGrouping:!1,...r};r.padTo>0&&(a.minimumIntegerDigits=r.padTo),this.inf=clt(e,a)}}format(e){if(this.inf){const t=this.floor?Math.floor(e):e;return this.inf.format(t)}else{const t=this.floor?Math.floor(e):R4(e,3);return yi(t,this.padTo)}}}class blt{constructor(e,t,r){this.opts=r,this.originalZone=void 0;let s;if(this.opts.timeZone)this.dt=e;else if(e.zone.type==="fixed"){const o=-1*(e.offset/60),a=o>=0?`Etc/GMT+${o}`:`Etc/GMT${o}`;e.offset!==0&&Of.create(a).valid?(s=a,this.dt=e):(s="UTC",this.dt=e.offset===0?e:e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone)}else e.zone.type==="system"?this.dt=e:e.zone.type==="iana"?(this.dt=e,s=e.zone.name):(s="UTC",this.dt=e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone);const i={...this.opts};i.timeZone=i.timeZone||s,this.dtf=lF(t,i)}format(){return this.originalZone?this.formatToParts().map(({value:e})=>e).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const e=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?e.map(t=>{if(t.type==="timeZoneName"){const r=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return{...t,value:r}}else return t}):e}resolvedOptions(){return this.dtf.resolvedOptions()}}class vlt{constructor(e,t,r){this.opts={style:"long",...r},!t&&sie()&&(this.rtf=ult(e,r))}format(e,t){return this.rtf?this.rtf.format(e,t):Olt(t,e,this.opts.numeric,this.opts.style!=="long")}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}}class ds{static fromOpts(e){return ds.create(e.locale,e.numberingSystem,e.outputCalendar,e.defaultToEN)}static create(e,t,r,s=!1){const i=e||mi.defaultLocale,o=i||(s?"en-US":hlt()),a=t||mi.defaultNumberingSystem,l=r||mi.defaultOutputCalendar;return new ds(o,a,l,i)}static resetCache(){M1=null,aF={},cF={},uF={}}static fromObject({locale:e,numberingSystem:t,outputCalendar:r}={}){return ds.create(e,t,r)}constructor(e,t,r,s){const[i,o,a]=flt(e);this.locale=i,this.numberingSystem=t||o||null,this.outputCalendar=r||a||null,this.intl=dlt(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=s,this.fastNumbersCached=null}get fastNumbers(){return this.fastNumbersCached==null&&(this.fastNumbersCached=glt(this)),this.fastNumbersCached}listingMode(){const e=this.isEnglish(),t=(this.numberingSystem===null||this.numberingSystem==="latn")&&(this.outputCalendar===null||this.outputCalendar==="gregory");return e&&t?"en":"intl"}clone(e){return!e||Object.getOwnPropertyNames(e).length===0?this:ds.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,e.defaultToEN||!1)}redefaultToEN(e={}){return this.clone({...e,defaultToEN:!0})}redefaultToSystem(e={}){return this.clone({...e,defaultToEN:!1})}months(e,t=!1){return ST(this,e,lie,()=>{const r=t?{month:e,day:"numeric"}:{month:e},s=t?"format":"standalone";return this.monthsCache[s][e]||(this.monthsCache[s][e]=plt(i=>this.extract(i,r,"month"))),this.monthsCache[s][e]})}weekdays(e,t=!1){return ST(this,e,hie,()=>{const r=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},s=t?"format":"standalone";return this.weekdaysCache[s][e]||(this.weekdaysCache[s][e]=mlt(i=>this.extract(i,r,"weekday"))),this.weekdaysCache[s][e]})}meridiems(){return ST(this,void 0,()=>fie,()=>{if(!this.meridiemCache){const e={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[yn.utc(2016,11,13,9),yn.utc(2016,11,13,19)].map(t=>this.extract(t,e,"dayperiod"))}return this.meridiemCache})}eras(e){return ST(this,e,die,()=>{const t={era:e};return this.eraCache[e]||(this.eraCache[e]=[yn.utc(-40,1,1),yn.utc(2017,1,1)].map(r=>this.extract(r,t,"era"))),this.eraCache[e]})}extract(e,t,r){const s=this.dtFormatter(e,t),i=s.formatToParts(),o=i.find(a=>a.type.toLowerCase()===r);return o?o.value:null}numberFormatter(e={}){return new ylt(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e,t={}){return new blt(e,this.intl,t)}relFormatter(e={}){return new vlt(this.intl,this.isEnglish(),e)}listFormatter(e={}){return llt(this.intl,e)}isEnglish(){return this.locale==="en"||this.locale.toLowerCase()==="en-us"||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}}let V3=null;class pa extends NC{static get utcInstance(){return V3===null&&(V3=new pa(0)),V3}static instance(e){return e===0?pa.utcInstance:new pa(e)}static parseSpecifier(e){if(e){const t=e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(t)return new pa(x$(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return this.fixed===0?"UTC":`UTC${eS(this.fixed,"narrow")}`}get ianaName(){return this.fixed===0?"Etc/UTC":`Etc/GMT${eS(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return eS(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return e.type==="fixed"&&e.fixed===this.fixed}get isValid(){return!0}}class wlt extends NC{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function Ed(n,e){if(hr(n)||n===null)return e;if(n instanceof NC)return n;if(xlt(n)){const t=n.toLowerCase();return t==="default"?e:t==="local"||t==="system"?b$.instance:t==="utc"||t==="gmt"?pa.utcInstance:pa.parseSpecifier(t)||Of.create(n)}else return Xm(n)?pa.instance(n):typeof n=="object"&&"offset"in n&&typeof n.offset=="function"?n:new wlt(n)}let j5=()=>Date.now(),q5="system",X5=null,K5=null,Y5=null,Z5=60,J5;class mi{static get now(){return j5}static set now(e){j5=e}static set defaultZone(e){q5=e}static get defaultZone(){return Ed(q5,b$.instance)}static get defaultLocale(){return X5}static set defaultLocale(e){X5=e}static get defaultNumberingSystem(){return K5}static set defaultNumberingSystem(e){K5=e}static get defaultOutputCalendar(){return Y5}static set defaultOutputCalendar(e){Y5=e}static get twoDigitCutoffYear(){return Z5}static set twoDigitCutoffYear(e){Z5=e%100}static get throwOnInvalid(){return J5}static set throwOnInvalid(e){J5=e}static resetCaches(){ds.resetCache(),Of.resetCache()}}function hr(n){return typeof n>"u"}function Xm(n){return typeof n=="number"}function v$(n){return typeof n=="number"&&n%1===0}function xlt(n){return typeof n=="string"}function Slt(n){return Object.prototype.toString.call(n)==="[object Date]"}function sie(){try{return typeof Intl<"u"&&!!Intl.RelativeTimeFormat}catch{return!1}}function _lt(n){return Array.isArray(n)?n:[n]}function Q5(n,e,t){if(n.length!==0)return n.reduce((r,s)=>{const i=[e(s),s];return r&&t(r[0],i[0])===r[0]?r:i},null)[1]}function Clt(n,e){return e.reduce((t,r)=>(t[r]=n[r],t),{})}function ov(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function If(n,e,t){return v$(n)&&n>=e&&n<=t}function klt(n,e){return n-e*Math.floor(n/e)}function yi(n,e=2){const t=n<0;let r;return t?r="-"+(""+-n).padStart(e,"0"):r=(""+n).padStart(e,"0"),r}function kd(n){if(!(hr(n)||n===null||n===""))return parseInt(n,10)}function om(n){if(!(hr(n)||n===null||n===""))return parseFloat(n)}function $4(n){if(!(hr(n)||n===null||n==="")){const e=parseFloat("0."+n)*1e3;return Math.floor(e)}}function R4(n,e,t=!1){const r=10**e;return(t?Math.trunc:Math.round)(n*r)/r}function $C(n){return n%4===0&&(n%100!==0||n%400===0)}function Q1(n){return $C(n)?366:365}function dA(n,e){const t=klt(e-1,12)+1,r=n+(e-t)/12;return t===2?$C(r)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][t-1]}function w$(n){let e=Date.UTC(n.year,n.month-1,n.day,n.hour,n.minute,n.second,n.millisecond);return n.year<100&&n.year>=0&&(e=new Date(e),e.setUTCFullYear(n.year,n.month-1,n.day)),+e}function pA(n){const e=(n+Math.floor(n/4)-Math.floor(n/100)+Math.floor(n/400))%7,t=n-1,r=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return e===4||r===3?53:52}function hF(n){return n>99?n:n>mi.twoDigitCutoffYear?1900+n:2e3+n}function iie(n,e,t,r=null){const s=new Date(n),i={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(i.timeZone=r);const o={timeZoneName:e,...i},a=new Intl.DateTimeFormat(t,o).formatToParts(s).find(l=>l.type.toLowerCase()==="timezonename");return a?a.value:null}function x$(n,e){let t=parseInt(n,10);Number.isNaN(t)&&(t=0);const r=parseInt(e,10)||0,s=t<0||Object.is(t,-0)?-r:r;return t*60+s}function oie(n){const e=Number(n);if(typeof n=="boolean"||n===""||Number.isNaN(e))throw new hc(`Invalid unit value ${n}`);return e}function mA(n,e){const t={};for(const r in n)if(ov(n,r)){const s=n[r];if(s==null)continue;t[e(r)]=oie(s)}return t}function eS(n,e){const t=Math.trunc(Math.abs(n/60)),r=Math.trunc(Math.abs(n%60)),s=n>=0?"+":"-";switch(e){case"short":return`${s}${yi(t,2)}:${yi(r,2)}`;case"narrow":return`${s}${t}${r>0?`:${r}`:""}`;case"techie":return`${s}${yi(t,2)}${yi(r,2)}`;default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function S$(n){return Clt(n,["hour","minute","second","millisecond"])}const Tlt=["January","February","March","April","May","June","July","August","September","October","November","December"],aie=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],Elt=["J","F","M","A","M","J","J","A","S","O","N","D"];function lie(n){switch(n){case"narrow":return[...Elt];case"short":return[...aie];case"long":return[...Tlt];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const cie=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],uie=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],Ilt=["M","T","W","T","F","S","S"];function hie(n){switch(n){case"narrow":return[...Ilt];case"short":return[...uie];case"long":return[...cie];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const fie=["AM","PM"],Alt=["Before Christ","Anno Domini"],Mlt=["BC","AD"],Nlt=["B","A"];function die(n){switch(n){case"narrow":return[...Nlt];case"short":return[...Mlt];case"long":return[...Alt];default:return null}}function $lt(n){return fie[n.hour<12?0:1]}function Rlt(n,e){return hie(e)[n.weekday-1]}function Plt(n,e){return lie(e)[n.month-1]}function Dlt(n,e){return die(e)[n.year<0?0:1]}function Olt(n,e,t="always",r=!1){const s={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},i=["hours","minutes","seconds"].indexOf(n)===-1;if(t==="auto"&&i){const h=n==="days";switch(e){case 1:return h?"tomorrow":`next ${s[n][0]}`;case-1:return h?"yesterday":`last ${s[n][0]}`;case 0:return h?"today":`this ${s[n][0]}`}}const o=Object.is(e,-0)||e<0,a=Math.abs(e),l=a===1,c=s[n],u=r?l?c[1]:c[2]||c[1]:l?s[n][0]:n;return o?`${a} ${u} ago`:`in ${a} ${u}`}function ej(n,e){let t="";for(const r of n)r.literal?t+=r.val:t+=e(r.val);return t}const Flt={D:fA,DD:zse,DDD:Bse,DDDD:Vse,t:Use,tt:Wse,ttt:Gse,tttt:Hse,T:jse,TT:qse,TTT:Xse,TTTT:Kse,f:Yse,ff:Jse,fff:eie,ffff:nie,F:Zse,FF:Qse,FFF:tie,FFFF:rie};class Wo{static create(e,t={}){return new Wo(e,t)}static parseFormat(e){let t=null,r="",s=!1;const i=[];for(let o=0;o<e.length;o++){const a=e.charAt(o);a==="'"?(r.length>0&&i.push({literal:s||/^\s+$/.test(r),val:r}),t=null,r="",s=!s):s||a===t?r+=a:(r.length>0&&i.push({literal:/^\s+$/.test(r),val:r}),r=a,t=a)}return r.length>0&&i.push({literal:s||/^\s+$/.test(r),val:r}),i}static macroTokenToFormatOpts(e){return Flt[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){return this.systemLoc===null&&(this.systemLoc=this.loc.redefaultToSystem()),this.systemLoc.dtFormatter(e,{...this.opts,...t}).format()}dtFormatter(e,t={}){return this.loc.dtFormatter(e,{...this.opts,...t})}formatDateTime(e,t){return this.dtFormatter(e,t).format()}formatDateTimeParts(e,t){return this.dtFormatter(e,t).formatToParts()}formatInterval(e,t){return this.dtFormatter(e.start,t).dtf.formatRange(e.start.toJSDate(),e.end.toJSDate())}resolvedOptions(e,t){return this.dtFormatter(e,t).resolvedOptions()}num(e,t=0){if(this.opts.forceSimple)return yi(e,t);const r={...this.opts};return t>0&&(r.padTo=t),this.loc.numberFormatter(r).format(e)}formatDateTimeFromString(e,t){const r=this.loc.listingMode()==="en",s=this.loc.outputCalendar&&this.loc.outputCalendar!=="gregory",i=(d,p)=>this.loc.extract(e,d,p),o=d=>e.isOffsetFixed&&e.offset===0&&d.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,d.format):"",a=()=>r?$lt(e):i({hour:"numeric",hourCycle:"h12"},"dayperiod"),l=(d,p)=>r?Plt(e,d):i(p?{month:d}:{month:d,day:"numeric"},"month"),c=(d,p)=>r?Rlt(e,d):i(p?{weekday:d}:{weekday:d,month:"long",day:"numeric"},"weekday"),u=d=>{const p=Wo.macroTokenToFormatOpts(d);return p?this.formatWithSystemDefault(e,p):d},h=d=>r?Dlt(e,d):i({era:d},"era"),f=d=>{switch(d){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12===0?12:e.hour%12);case"hh":return this.num(e.hour%12===0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return o({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return o({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return o({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return a();case"d":return s?i({day:"numeric"},"day"):this.num(e.day);case"dd":return s?i({day:"2-digit"},"day"):this.num(e.day,2);case"c":return this.num(e.weekday);case"ccc":return c("short",!0);case"cccc":return c("long",!0);case"ccccc":return c("narrow",!0);case"E":return this.num(e.weekday);case"EEE":return c("short",!1);case"EEEE":return c("long",!1);case"EEEEE":return c("narrow",!1);case"L":return s?i({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return s?i({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return l("short",!0);case"LLLL":return l("long",!0);case"LLLLL":return l("narrow",!0);case"M":return s?i({month:"numeric"},"month"):this.num(e.month);case"MM":return s?i({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return l("short",!1);case"MMMM":return l("long",!1);case"MMMMM":return l("narrow",!1);case"y":return s?i({year:"numeric"},"year"):this.num(e.year);case"yy":return s?i({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return s?i({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return s?i({year:"numeric"},"year"):this.num(e.year,6);case"G":return h("short");case"GG":return h("long");case"GGGGG":return h("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return u(d)}};return ej(Wo.parseFormat(t),f)}formatDurationFromString(e,t){const r=l=>{switch(l[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},s=l=>c=>{const u=r(c);return u?this.num(l.get(u),c.length):c},i=Wo.parseFormat(t),o=i.reduce((l,{literal:c,val:u})=>c?l:l.concat(u),[]),a=e.shiftTo(...o.map(r).filter(l=>l));return ej(i,s(a))}}class du{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const pie=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function Xw(...n){const e=n.reduce((t,r)=>t+r.source,"");return RegExp(`^${e}$`)}function Kw(...n){return e=>n.reduce(([t,r,s],i)=>{const[o,a,l]=i(e,s);return[{...t,...o},a||r,l]},[{},null,1]).slice(0,2)}function Yw(n,...e){if(n==null)return[null,null];for(const[t,r]of e){const s=t.exec(n);if(s)return r(s)}return[null,null]}function mie(...n){return(e,t)=>{const r={};let s;for(s=0;s<n.length;s++)r[n[s]]=kd(e[t+s]);return[r,null,t+s]}}const gie=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,Llt=`(?:${gie.source}?(?:\\[(${pie.source})\\])?)?`,P4=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,yie=RegExp(`${P4.source}${Llt}`),D4=RegExp(`(?:T${yie.source})?`),zlt=/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,Blt=/(\d{4})-?W(\d\d)(?:-?(\d))?/,Vlt=/(\d{4})-?(\d{3})/,Ult=mie("weekYear","weekNumber","weekDay"),Wlt=mie("year","ordinal"),Glt=/(\d{4})-(\d\d)-(\d\d)/,bie=RegExp(`${P4.source} ?(?:${gie.source}|(${pie.source}))?`),Hlt=RegExp(`(?: ${bie.source})?`);function Nb(n,e,t){const r=n[e];return hr(r)?t:kd(r)}function jlt(n,e){return[{year:Nb(n,e),month:Nb(n,e+1,1),day:Nb(n,e+2,1)},null,e+3]}function Zw(n,e){return[{hours:Nb(n,e,0),minutes:Nb(n,e+1,0),seconds:Nb(n,e+2,0),milliseconds:$4(n[e+3])},null,e+4]}function RC(n,e){const t=!n[e]&&!n[e+1],r=x$(n[e+1],n[e+2]),s=t?null:pa.instance(r);return[{},s,e+3]}function PC(n,e){const t=n[e]?Of.create(n[e]):null;return[{},t,e+1]}const qlt=RegExp(`^T?${P4.source}$`),Xlt=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function Klt(n){const[e,t,r,s,i,o,a,l,c]=n,u=e[0]==="-",h=l&&l[0]==="-",f=(d,p=!1)=>d!==void 0&&(p||d&&u)?-d:d;return[{years:f(om(t)),months:f(om(r)),weeks:f(om(s)),days:f(om(i)),hours:f(om(o)),minutes:f(om(a)),seconds:f(om(l),l==="-0"),milliseconds:f($4(c),h)}]}const Ylt={GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};function O4(n,e,t,r,s,i,o){const a={year:e.length===2?hF(kd(e)):kd(e),month:aie.indexOf(t)+1,day:kd(r),hour:kd(s),minute:kd(i)};return o&&(a.second=kd(o)),n&&(a.weekday=n.length>3?cie.indexOf(n)+1:uie.indexOf(n)+1),a}const Zlt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function Jlt(n){const[,e,t,r,s,i,o,a,l,c,u,h]=n,f=O4(e,s,r,t,i,o,a);let d;return l?d=Ylt[l]:c?d=0:d=x$(u,h),[f,new pa(d)]}function Qlt(n){return n.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}const ect=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,tct=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,nct=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function tj(n){const[,e,t,r,s,i,o,a]=n;return[O4(e,s,r,t,i,o,a),pa.utcInstance]}function rct(n){const[,e,t,r,s,i,o,a]=n;return[O4(e,a,t,r,s,i,o),pa.utcInstance]}const sct=Xw(zlt,D4),ict=Xw(Blt,D4),oct=Xw(Vlt,D4),act=Xw(yie),vie=Kw(jlt,Zw,RC,PC),lct=Kw(Ult,Zw,RC,PC),cct=Kw(Wlt,Zw,RC,PC),uct=Kw(Zw,RC,PC);function hct(n){return Yw(n,[sct,vie],[ict,lct],[oct,cct],[act,uct])}function fct(n){return Yw(Qlt(n),[Zlt,Jlt])}function dct(n){return Yw(n,[ect,tj],[tct,tj],[nct,rct])}function pct(n){return Yw(n,[Xlt,Klt])}const mct=Kw(Zw);function gct(n){return Yw(n,[qlt,mct])}const yct=Xw(Glt,Hlt),bct=Xw(bie),vct=Kw(Zw,RC,PC);function wct(n){return Yw(n,[yct,vie],[bct,vct])}const nj="Invalid Duration",wie={weeks:{days:7,hours:7*24,minutes:7*24*60,seconds:7*24*60*60,milliseconds:7*24*60*60*1e3},days:{hours:24,minutes:24*60,seconds:24*60*60,milliseconds:24*60*60*1e3},hours:{minutes:60,seconds:60*60,milliseconds:60*60*1e3},minutes:{seconds:60,milliseconds:60*1e3},seconds:{milliseconds:1e3}},xct={years:{quarters:4,months:12,weeks:52,days:365,hours:365*24,minutes:365*24*60,seconds:365*24*60*60,milliseconds:365*24*60*60*1e3},quarters:{months:3,weeks:13,days:91,hours:91*24,minutes:91*24*60,seconds:91*24*60*60,milliseconds:91*24*60*60*1e3},months:{weeks:4,days:30,hours:30*24,minutes:30*24*60,seconds:30*24*60*60,milliseconds:30*24*60*60*1e3},...wie},nc=146097/400,D0=146097/4800,Sct={years:{quarters:4,months:12,weeks:nc/7,days:nc,hours:nc*24,minutes:nc*24*60,seconds:nc*24*60*60,milliseconds:nc*24*60*60*1e3},quarters:{months:3,weeks:nc/28,days:nc/4,hours:nc*24/4,minutes:nc*24*60/4,seconds:nc*24*60*60/4,milliseconds:nc*24*60*60*1e3/4},months:{weeks:D0/7,days:D0,hours:D0*24,minutes:D0*24*60,seconds:D0*24*60*60,milliseconds:D0*24*60*60*1e3},...wie},Lm=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],_ct=Lm.slice(0).reverse();function ud(n,e,t=!1){const r={values:t?e.values:{...n.values,...e.values||{}},loc:n.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||n.conversionAccuracy,matrix:e.matrix||n.matrix};return new Sr(r)}function xie(n,e){let t=e.milliseconds??0;for(const r of _ct.slice(1))e[r]&&(t+=e[r]*n[r].milliseconds);return t}function rj(n,e){const t=xie(n,e)<0?-1:1;Lm.reduceRight((r,s)=>{if(hr(e[s]))return r;if(r){const i=e[r]*t,o=n[s][r],a=Math.floor(i/o);e[s]+=a*t,e[r]-=a*o*t}return s},null),Lm.reduce((r,s)=>{if(hr(e[s]))return r;if(r){const i=e[r]%1;e[r]-=i,e[s]+=i*n[r][s]}return s},null)}function Cct(n){const e={};for(const[t,r]of Object.entries(n))r!==0&&(e[t]=r);return e}class Sr{constructor(e){const t=e.conversionAccuracy==="longterm"||!1;let r=t?Sct:xct;e.matrix&&(r=e.matrix),this.values=e.values,this.loc=e.loc||ds.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=r,this.isLuxonDuration=!0}static fromMillis(e,t){return Sr.fromObject({milliseconds:e},t)}static fromObject(e,t={}){if(e==null||typeof e!="object")throw new hc(`Duration.fromObject: argument expected to be an object, got ${e===null?"null":typeof e}`);return new Sr({values:mA(e,Sr.normalizeUnit),loc:ds.fromObject(t),conversionAccuracy:t.conversionAccuracy,matrix:t.matrix})}static fromDurationLike(e){if(Xm(e))return Sr.fromMillis(e);if(Sr.isDuration(e))return e;if(typeof e=="object")return Sr.fromObject(e);throw new hc(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){const[r]=pct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static fromISOTime(e,t){const[r]=gct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static invalid(e,t=null){if(!e)throw new hc("need to specify a reason the Duration is invalid");const r=e instanceof du?e:new du(e,t);if(mi.throwOnInvalid)throw new tlt(r);return new Sr({invalid:r})}static normalizeUnit(e){const t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e&&e.toLowerCase()];if(!t)throw new Lse(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e,t={}){const r={...t,floor:t.round!==!1&&t.floor!==!1};return this.isValid?Wo.create(this.loc,r).formatDurationFromString(this,e):nj}toHuman(e={}){if(!this.isValid)return nj;const t=Lm.map(r=>{const s=this.values[r];return hr(s)?null:this.loc.numberFormatter({style:"unit",unitDisplay:"long",...e,unit:r.slice(0,-1)}).format(s)}).filter(r=>r);return this.loc.listFormatter({type:"conjunction",style:e.listStyle||"narrow",...e}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let e="P";return this.years!==0&&(e+=this.years+"Y"),(this.months!==0||this.quarters!==0)&&(e+=this.months+this.quarters*3+"M"),this.weeks!==0&&(e+=this.weeks+"W"),this.days!==0&&(e+=this.days+"D"),(this.hours!==0||this.minutes!==0||this.seconds!==0||this.milliseconds!==0)&&(e+="T"),this.hours!==0&&(e+=this.hours+"H"),this.minutes!==0&&(e+=this.minutes+"M"),(this.seconds!==0||this.milliseconds!==0)&&(e+=R4(this.seconds+this.milliseconds/1e3,3)+"S"),e==="P"&&(e+="T0S"),e}toISOTime(e={}){if(!this.isValid)return null;const t=this.toMillis();return t<0||t>=864e5?null:(e={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended",...e,includeOffset:!1},yn.fromMillis(t,{zone:"UTC"}).toISOTime(e))}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.isValid?xie(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e),r={};for(const s of Lm)(ov(t.values,s)||ov(this.values,s))&&(r[s]=t.get(s)+this.get(s));return ud(this,{values:r},!0)}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;const t={};for(const r of Object.keys(this.values))t[r]=oie(e(this.values[r],r));return ud(this,{values:t},!0)}get(e){return this[Sr.normalizeUnit(e)]}set(e){if(!this.isValid)return this;const t={...this.values,...mA(e,Sr.normalizeUnit)};return ud(this,{values:t})}reconfigure({locale:e,numberingSystem:t,conversionAccuracy:r,matrix:s}={}){const o={loc:this.loc.clone({locale:e,numberingSystem:t}),matrix:s,conversionAccuracy:r};return ud(this,o)}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;const e=this.toObject();return rj(this.matrix,e),ud(this,{values:e},!0)}rescale(){if(!this.isValid)return this;const e=Cct(this.normalize().shiftToAll().toObject());return ud(this,{values:e},!0)}shiftTo(...e){if(!this.isValid)return this;if(e.length===0)return this;e=e.map(o=>Sr.normalizeUnit(o));const t={},r={},s=this.toObject();let i;for(const o of Lm)if(e.indexOf(o)>=0){i=o;let a=0;for(const c in r)a+=this.matrix[c][o]*r[c],r[c]=0;Xm(s[o])&&(a+=s[o]);const l=Math.trunc(a);t[o]=l,r[o]=(a*1e3-l*1e3)/1e3}else Xm(s[o])&&(r[o]=s[o]);for(const o in r)r[o]!==0&&(t[i]+=o===i?r[o]:r[o]/this.matrix[i][o]);return rj(this.matrix,t),ud(this,{values:t},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const e={};for(const t of Object.keys(this.values))e[t]=this.values[t]===0?0:-this.values[t];return ud(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid||!this.loc.equals(e.loc))return!1;function t(r,s){return r===void 0||r===0?s===void 0||s===0:r===s}for(const r of Lm)if(!t(this.values[r],e.values[r]))return!1;return!0}}const O0="Invalid Interval";function kct(n,e){return!n||!n.isValid?Hs.invalid("missing or invalid start"):!e||!e.isValid?Hs.invalid("missing or invalid end"):e<n?Hs.invalid("end before start",`The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`):null}class Hs{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e,t=null){if(!e)throw new hc("need to specify a reason the Interval is invalid");const r=e instanceof du?e:new du(e,t);if(mi.throwOnInvalid)throw new elt(r);return new Hs({invalid:r})}static fromDateTimes(e,t){const r=Yx(e),s=Yx(t),i=kct(r,s);return i??new Hs({start:r,end:s})}static after(e,t){const r=Sr.fromDurationLike(t),s=Yx(e);return Hs.fromDateTimes(s,s.plus(r))}static before(e,t){const r=Sr.fromDurationLike(t),s=Yx(e);return Hs.fromDateTimes(s.minus(r),s)}static fromISO(e,t){const[r,s]=(e||"").split("/",2);if(r&&s){let i,o;try{i=yn.fromISO(r,t),o=i.isValid}catch{o=!1}let a,l;try{a=yn.fromISO(s,t),l=a.isValid}catch{l=!1}if(o&&l)return Hs.fromDateTimes(i,a);if(o){const c=Sr.fromISO(s,t);if(c.isValid)return Hs.after(i,c)}else if(l){const c=Sr.fromISO(r,t);if(c.isValid)return Hs.before(a,c)}}return Hs.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return this.invalidReason===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(e="milliseconds"){return this.isValid?this.toDuration(e).get(e):NaN}count(e="milliseconds"){if(!this.isValid)return NaN;const t=this.start.startOf(e),r=this.end.startOf(e);return Math.floor(r.diff(t,e).get(e))+(r.valueOf()!==this.end.valueOf())}hasSame(e){return this.isValid?this.isEmpty()||this.e.minus(1).hasSame(this.s,e):!1}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return this.isValid?this.s>e:!1}isBefore(e){return this.isValid?this.e<=e:!1}contains(e){return this.isValid?this.s<=e&&this.e>e:!1}set({start:e,end:t}={}){return this.isValid?Hs.fromDateTimes(e||this.s,t||this.e):this}splitAt(...e){if(!this.isValid)return[];const t=e.map(Yx).filter(o=>this.contains(o)).sort(),r=[];let{s}=this,i=0;for(;s<this.e;){const o=t[i]||this.e,a=+o>+this.e?this.e:o;r.push(Hs.fromDateTimes(s,a)),s=a,i+=1}return r}splitBy(e){const t=Sr.fromDurationLike(e);if(!this.isValid||!t.isValid||t.as("milliseconds")===0)return[];let{s:r}=this,s=1,i;const o=[];for(;r<this.e;){const a=this.start.plus(t.mapUnits(l=>l*s));i=+a>+this.e?this.e:a,o.push(Hs.fromDateTimes(r,i)),r=i,s+=1}return o}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return this.isValid?+this.e==+e.s:!1}abutsEnd(e){return this.isValid?+e.e==+this.s:!1}engulfs(e){return this.isValid?this.s<=e.s&&this.e>=e.e:!1}equals(e){return!this.isValid||!e.isValid?!1:this.s.equals(e.s)&&this.e.equals(e.e)}intersection(e){if(!this.isValid)return this;const t=this.s>e.s?this.s:e.s,r=this.e<e.e?this.e:e.e;return t>=r?null:Hs.fromDateTimes(t,r)}union(e){if(!this.isValid)return this;const t=this.s<e.s?this.s:e.s,r=this.e>e.e?this.e:e.e;return Hs.fromDateTimes(t,r)}static merge(e){const[t,r]=e.sort((s,i)=>s.s-i.s).reduce(([s,i],o)=>i?i.overlaps(o)||i.abutsStart(o)?[s,i.union(o)]:[s.concat([i]),o]:[s,o],[[],null]);return r&&t.push(r),t}static xor(e){let t=null,r=0;const s=[],i=e.map(l=>[{time:l.s,type:"s"},{time:l.e,type:"e"}]),o=Array.prototype.concat(...i),a=o.sort((l,c)=>l.time-c.time);for(const l of a)r+=l.type==="s"?1:-1,r===1?t=l.time:(t&&+t!=+l.time&&s.push(Hs.fromDateTimes(t,l.time)),t=null);return Hs.merge(s)}difference(...e){return Hs.xor([this].concat(e)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()}  ${this.e.toISO()})`:O0}toLocaleString(e=fA,t={}){return this.isValid?Wo.create(this.s.loc.clone(t),e).formatInterval(this):O0}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:O0}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:O0}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:O0}toFormat(e,{separator:t="  "}={}){return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:O0}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):Sr.invalid(this.invalidReason)}mapEndpoints(e){return Hs.fromDateTimes(e(this.s),e(this.e))}}class _T{static hasDST(e=mi.defaultZone){const t=yn.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return Of.isValidZone(e)}static normalizeZone(e){return Ed(e,mi.defaultZone)}static months(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||ds.create(t,r,i)).months(e)}static monthsFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||ds.create(t,r,i)).months(e,!0)}static weekdays(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||ds.create(t,r,null)).weekdays(e)}static weekdaysFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||ds.create(t,r,null)).weekdays(e,!0)}static meridiems({locale:e=null}={}){return ds.create(e).meridiems()}static eras(e="short",{locale:t=null}={}){return ds.create(t,null,"gregory").eras(e)}static features(){return{relative:sie()}}}function sj(n,e){const t=s=>s.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=t(e)-t(n);return Math.floor(Sr.fromMillis(r).as("days"))}function Tct(n,e,t){const r=[["years",(l,c)=>c.year-l.year],["quarters",(l,c)=>c.quarter-l.quarter+(c.year-l.year)*4],["months",(l,c)=>c.month-l.month+(c.year-l.year)*12],["weeks",(l,c)=>{const u=sj(l,c);return(u-u%7)/7}],["days",sj]],s={},i=n;let o,a;for(const[l,c]of r)t.indexOf(l)>=0&&(o=l,s[l]=c(n,e),a=i.plus(s),a>e?(s[l]--,n=i.plus(s),n>e&&(a=n,s[l]--,n=i.plus(s))):n=a);return[n,s,a,o]}function Ect(n,e,t,r){let[s,i,o,a]=Tct(n,e,t);const l=e-s,c=t.filter(h=>["hours","minutes","seconds","milliseconds"].indexOf(h)>=0);c.length===0&&(o<e&&(o=s.plus({[a]:1})),o!==s&&(i[a]=(i[a]||0)+l/(o-s)));const u=Sr.fromObject(i,r);return c.length>0?Sr.fromMillis(l,r).shiftTo(...c).plus(u):u}const F4={arab:"[-]",arabext:"[-]",bali:"[-]",beng:"[-]",deva:"[-]",fullwide:"[-]",gujr:"[-]",hanidec:"[|||||||||]",khmr:"[-]",knda:"[-]",laoo:"[-]",limb:"[-]",mlym:"[-]",mong:"[-]",mymr:"[-]",orya:"[-]",tamldec:"[-]",telu:"[-]",thai:"[-]",tibt:"[-]",latn:"\\d"},ij={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},Ict=F4.hanidec.replace(/[\[|\]]/g,"").split("");function Act(n){let e=parseInt(n,10);if(isNaN(e)){e="";for(let t=0;t<n.length;t++){const r=n.charCodeAt(t);if(n[t].search(F4.hanidec)!==-1)e+=Ict.indexOf(n[t]);else for(const s in ij){const[i,o]=ij[s];r>=i&&r<=o&&(e+=r-i)}}return parseInt(e,10)}else return e}function Zc({numberingSystem:n},e=""){return new RegExp(`${F4[n||"latn"]}${e}`)}const Mct="missing Intl.DateTimeFormat.formatToParts support";function Er(n,e=t=>t){return{regex:n,deser:([t])=>e(Act(t))}}const Nct=String.fromCharCode(160),Sie=`[ ${Nct}]`,_ie=new RegExp(Sie,"g");function $ct(n){return n.replace(/\./g,"\\.?").replace(_ie,Sie)}function oj(n){return n.replace(/\./g,"").replace(_ie," ").toLowerCase()}function Jc(n,e){return n===null?null:{regex:RegExp(n.map($ct).join("|")),deser:([t])=>n.findIndex(r=>oj(t)===oj(r))+e}}function aj(n,e){return{regex:n,deser:([,t,r])=>x$(t,r),groups:e}}function CT(n){return{regex:n,deser:([e])=>e}}function Rct(n){return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}function Pct(n,e){const t=Zc(e),r=Zc(e,"{2}"),s=Zc(e,"{3}"),i=Zc(e,"{4}"),o=Zc(e,"{6}"),a=Zc(e,"{1,2}"),l=Zc(e,"{1,3}"),c=Zc(e,"{1,6}"),u=Zc(e,"{1,9}"),h=Zc(e,"{2,4}"),f=Zc(e,"{4,6}"),d=g=>({regex:RegExp(Rct(g.val)),deser:([y])=>y,literal:!0}),m=(g=>{if(n.literal)return d(g);switch(g.val){case"G":return Jc(e.eras("short"),0);case"GG":return Jc(e.eras("long"),0);case"y":return Er(c);case"yy":return Er(h,hF);case"yyyy":return Er(i);case"yyyyy":return Er(f);case"yyyyyy":return Er(o);case"M":return Er(a);case"MM":return Er(r);case"MMM":return Jc(e.months("short",!0),1);case"MMMM":return Jc(e.months("long",!0),1);case"L":return Er(a);case"LL":return Er(r);case"LLL":return Jc(e.months("short",!1),1);case"LLLL":return Jc(e.months("long",!1),1);case"d":return Er(a);case"dd":return Er(r);case"o":return Er(l);case"ooo":return Er(s);case"HH":return Er(r);case"H":return Er(a);case"hh":return Er(r);case"h":return Er(a);case"mm":return Er(r);case"m":return Er(a);case"q":return Er(a);case"qq":return Er(r);case"s":return Er(a);case"ss":return Er(r);case"S":return Er(l);case"SSS":return Er(s);case"u":return CT(u);case"uu":return CT(a);case"uuu":return Er(t);case"a":return Jc(e.meridiems(),0);case"kkkk":return Er(i);case"kk":return Er(h,hF);case"W":return Er(a);case"WW":return Er(r);case"E":case"c":return Er(t);case"EEE":return Jc(e.weekdays("short",!1),1);case"EEEE":return Jc(e.weekdays("long",!1),1);case"ccc":return Jc(e.weekdays("short",!0),1);case"cccc":return Jc(e.weekdays("long",!0),1);case"Z":case"ZZ":return aj(new RegExp(`([+-]${a.source})(?::(${r.source}))?`),2);case"ZZZ":return aj(new RegExp(`([+-]${a.source})(${r.source})?`),2);case"z":return CT(/[a-z_+-/]{1,256}?/i);case" ":return CT(/[^\S\n\r]/);default:return d(g)}})(n)||{invalidReason:Mct};return m.token=n,m}const Dct={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};function Oct(n,e,t){const{type:r,value:s}=n;if(r==="literal"){const l=/^\s+$/.test(s);return{literal:!l,val:l?" ":s}}const i=e[r];let o=r;r==="hour"&&(e.hour12!=null?o=e.hour12?"hour12":"hour24":e.hourCycle!=null?e.hourCycle==="h11"||e.hourCycle==="h12"?o="hour12":o="hour24":o=t.hour12?"hour12":"hour24");let a=Dct[o];if(typeof a=="object"&&(a=a[i]),a)return{literal:!1,val:a}}function Fct(n){return[`^${n.map(t=>t.regex).reduce((t,r)=>`${t}(${r.source})`,"")}$`,n]}function Lct(n,e,t){const r=n.match(e);if(r){const s={};let i=1;for(const o in t)if(ov(t,o)){const a=t[o],l=a.groups?a.groups+1:1;!a.literal&&a.token&&(s[a.token.val[0]]=a.deser(r.slice(i,i+l))),i+=l}return[r,s]}else return[r,{}]}function zct(n){const e=i=>{switch(i){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}};let t=null,r;return hr(n.z)||(t=Of.create(n.z)),hr(n.Z)||(t||(t=new pa(n.Z)),r=n.Z),hr(n.q)||(n.M=(n.q-1)*3+1),hr(n.h)||(n.h<12&&n.a===1?n.h+=12:n.h===12&&n.a===0&&(n.h=0)),n.G===0&&n.y&&(n.y=-n.y),hr(n.u)||(n.S=$4(n.u)),[Object.keys(n).reduce((i,o)=>{const a=e(o);return a&&(i[a]=n[o]),i},{}),t,r]}let U3=null;function Bct(){return U3||(U3=yn.fromMillis(1555555555555)),U3}function Vct(n,e){if(n.literal)return n;const t=Wo.macroTokenToFormatOpts(n.val),r=Tie(t,e);return r==null||r.includes(void 0)?n:r}function Cie(n,e){return Array.prototype.concat(...n.map(t=>Vct(t,e)))}function kie(n,e,t){const r=Cie(Wo.parseFormat(t),n),s=r.map(o=>Pct(o,n)),i=s.find(o=>o.invalidReason);if(i)return{input:e,tokens:r,invalidReason:i.invalidReason};{const[o,a]=Fct(s),l=RegExp(o,"i"),[c,u]=Lct(e,l,a),[h,f,d]=u?zct(u):[null,null,void 0];if(ov(u,"a")&&ov(u,"H"))throw new A1("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:r,regex:l,rawMatches:c,matches:u,result:h,zone:f,specificOffset:d}}}function Uct(n,e,t){const{result:r,zone:s,specificOffset:i,invalidReason:o}=kie(n,e,t);return[r,s,i,o]}function Tie(n,e){if(!n)return null;const r=Wo.create(e,n).dtFormatter(Bct()),s=r.formatToParts(),i=r.resolvedOptions();return s.map(o=>Oct(o,n,i))}const Eie=[0,31,59,90,120,151,181,212,243,273,304,334],Iie=[0,31,60,91,121,152,182,213,244,274,305,335];function wc(n,e){return new du("unit out of range",`you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`)}function Aie(n,e,t){const r=new Date(Date.UTC(n,e-1,t));n<100&&n>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);const s=r.getUTCDay();return s===0?7:s}function Mie(n,e,t){return t+($C(n)?Iie:Eie)[e-1]}function Nie(n,e){const t=$C(n)?Iie:Eie,r=t.findIndex(i=>i<e),s=e-t[r];return{month:r+1,day:s}}function fF(n){const{year:e,month:t,day:r}=n,s=Mie(e,t,r),i=Aie(e,t,r);let o=Math.floor((s-i+10)/7),a;return o<1?(a=e-1,o=pA(a)):o>pA(e)?(a=e+1,o=1):a=e,{weekYear:a,weekNumber:o,weekday:i,...S$(n)}}function lj(n){const{weekYear:e,weekNumber:t,weekday:r}=n,s=Aie(e,1,4),i=Q1(e);let o=t*7+r-s-3,a;o<1?(a=e-1,o+=Q1(a)):o>i?(a=e+1,o-=Q1(e)):a=e;const{month:l,day:c}=Nie(a,o);return{year:a,month:l,day:c,...S$(n)}}function W3(n){const{year:e,month:t,day:r}=n,s=Mie(e,t,r);return{year:e,ordinal:s,...S$(n)}}function cj(n){const{year:e,ordinal:t}=n,{month:r,day:s}=Nie(e,t);return{year:e,month:r,day:s,...S$(n)}}function Wct(n){const e=v$(n.weekYear),t=If(n.weekNumber,1,pA(n.weekYear)),r=If(n.weekday,1,7);return e?t?r?!1:wc("weekday",n.weekday):wc("week",n.week):wc("weekYear",n.weekYear)}function Gct(n){const e=v$(n.year),t=If(n.ordinal,1,Q1(n.year));return e?t?!1:wc("ordinal",n.ordinal):wc("year",n.year)}function $ie(n){const e=v$(n.year),t=If(n.month,1,12),r=If(n.day,1,dA(n.year,n.month));return e?t?r?!1:wc("day",n.day):wc("month",n.month):wc("year",n.year)}function Rie(n){const{hour:e,minute:t,second:r,millisecond:s}=n,i=If(e,0,23)||e===24&&t===0&&r===0&&s===0,o=If(t,0,59),a=If(r,0,59),l=If(s,0,999);return i?o?a?l?!1:wc("millisecond",s):wc("second",r):wc("minute",t):wc("hour",e)}const G3="Invalid DateTime",uj=864e13;function kT(n){return new du("unsupported zone",`the zone "${n.name}" is not supported`)}function H3(n){return n.weekData===null&&(n.weekData=fF(n.c)),n.weekData}function am(n,e){const t={ts:n.ts,zone:n.zone,c:n.c,o:n.o,loc:n.loc,invalid:n.invalid};return new yn({...t,...e,old:t})}function Pie(n,e,t){let r=n-e*60*1e3;const s=t.offset(r);if(e===s)return[r,e];r-=(s-e)*60*1e3;const i=t.offset(r);return s===i?[r,s]:[n-Math.min(s,i)*60*1e3,Math.max(s,i)]}function TT(n,e){n+=e*60*1e3;const t=new Date(n);return{year:t.getUTCFullYear(),month:t.getUTCMonth()+1,day:t.getUTCDate(),hour:t.getUTCHours(),minute:t.getUTCMinutes(),second:t.getUTCSeconds(),millisecond:t.getUTCMilliseconds()}}function YE(n,e,t){return Pie(w$(n),e,t)}function hj(n,e){const t=n.o,r=n.c.year+Math.trunc(e.years),s=n.c.month+Math.trunc(e.months)+Math.trunc(e.quarters)*3,i={...n.c,year:r,month:s,day:Math.min(n.c.day,dA(r,s))+Math.trunc(e.days)+Math.trunc(e.weeks)*7},o=Sr.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as("milliseconds"),a=w$(i);let[l,c]=Pie(a,t,n.zone);return o!==0&&(l+=o,c=n.zone.offset(l)),{ts:l,o:c}}function Kx(n,e,t,r,s,i){const{setZone:o,zone:a}=t;if(n&&Object.keys(n).length!==0||e){const l=e||a,c=yn.fromObject(n,{...t,zone:l,specificOffset:i});return o?c:c.setZone(a)}else return yn.invalid(new du("unparsable",`the input "${s}" can't be parsed as ${r}`))}function ET(n,e,t=!0){return n.isValid?Wo.create(ds.create("en-US"),{allowZ:t,forceSimple:!0}).formatDateTimeFromString(n,e):null}function j3(n,e){const t=n.c.year>9999||n.c.year<0;let r="";return t&&n.c.year>=0&&(r+="+"),r+=yi(n.c.year,t?6:4),e?(r+="-",r+=yi(n.c.month),r+="-",r+=yi(n.c.day)):(r+=yi(n.c.month),r+=yi(n.c.day)),r}function fj(n,e,t,r,s,i){let o=yi(n.c.hour);return e?(o+=":",o+=yi(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=":")):o+=yi(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=yi(n.c.second),(n.c.millisecond!==0||!r)&&(o+=".",o+=yi(n.c.millisecond,3))),s&&(n.isOffsetFixed&&n.offset===0&&!i?o+="Z":n.o<0?(o+="-",o+=yi(Math.trunc(-n.o/60)),o+=":",o+=yi(Math.trunc(-n.o%60))):(o+="+",o+=yi(Math.trunc(n.o/60)),o+=":",o+=yi(Math.trunc(n.o%60)))),i&&(o+="["+n.zone.ianaName+"]"),o}const Die={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},Hct={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},jct={ordinal:1,hour:0,minute:0,second:0,millisecond:0},Oie=["year","month","day","hour","minute","second","millisecond"],qct=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],Xct=["year","ordinal","hour","minute","second","millisecond"];function dj(n){const e={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[n.toLowerCase()];if(!e)throw new Lse(n);return e}function pj(n,e){const t=Ed(e.zone,mi.defaultZone),r=ds.fromObject(e),s=mi.now();let i,o;if(hr(n.year))i=s;else{for(const c of Oie)hr(n[c])&&(n[c]=Die[c]);const a=$ie(n)||Rie(n);if(a)return yn.invalid(a);const l=t.offset(s);[i,o]=YE(n,l,t)}return new yn({ts:i,zone:t,loc:r,o})}function mj(n,e,t){const r=hr(t.round)?!0:t.round,s=(o,a)=>(o=R4(o,r||t.calendary?0:2,!0),e.loc.clone(t).relFormatter(t).format(o,a)),i=o=>t.calendary?e.hasSame(n,o)?0:e.startOf(o).diff(n.startOf(o),o).get(o):e.diff(n,o).get(o);if(t.unit)return s(i(t.unit),t.unit);for(const o of t.units){const a=i(o);if(Math.abs(a)>=1)return s(a,o)}return s(n>e?-0:0,t.units[t.units.length-1])}function gj(n){let e={},t;return n.length>0&&typeof n[n.length-1]=="object"?(e=n[n.length-1],t=Array.from(n).slice(0,n.length-1)):t=Array.from(n),[e,t]}class yn{constructor(e){const t=e.zone||mi.defaultZone;let r=e.invalid||(Number.isNaN(e.ts)?new du("invalid input"):null)||(t.isValid?null:kT(t));this.ts=hr(e.ts)?mi.now():e.ts;let s=null,i=null;if(!r)if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[s,i]=[e.old.c,e.old.o];else{const a=t.offset(this.ts);s=TT(this.ts,a),r=Number.isNaN(s.year)?new du("invalid input"):null,s=r?null:s,i=r?null:a}this._zone=t,this.loc=e.loc||ds.create(),this.invalid=r,this.weekData=null,this.c=s,this.o=i,this.isLuxonDateTime=!0}static now(){return new yn({})}static local(){const[e,t]=gj(arguments),[r,s,i,o,a,l,c]=t;return pj({year:r,month:s,day:i,hour:o,minute:a,second:l,millisecond:c},e)}static utc(){const[e,t]=gj(arguments),[r,s,i,o,a,l,c]=t;return e.zone=pa.utcInstance,pj({year:r,month:s,day:i,hour:o,minute:a,second:l,millisecond:c},e)}static fromJSDate(e,t={}){const r=Slt(e)?e.valueOf():NaN;if(Number.isNaN(r))return yn.invalid("invalid input");const s=Ed(t.zone,mi.defaultZone);return s.isValid?new yn({ts:r,zone:s,loc:ds.fromObject(t)}):yn.invalid(kT(s))}static fromMillis(e,t={}){if(Xm(e))return e<-uj||e>uj?yn.invalid("Timestamp out of range"):new yn({ts:e,zone:Ed(t.zone,mi.defaultZone),loc:ds.fromObject(t)});throw new hc(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e,t={}){if(Xm(e))return new yn({ts:e*1e3,zone:Ed(t.zone,mi.defaultZone),loc:ds.fromObject(t)});throw new hc("fromSeconds requires a numerical input")}static fromObject(e,t={}){e=e||{};const r=Ed(t.zone,mi.defaultZone);if(!r.isValid)return yn.invalid(kT(r));const s=mi.now(),i=hr(t.specificOffset)?r.offset(s):t.specificOffset,o=mA(e,dj),a=!hr(o.ordinal),l=!hr(o.year),c=!hr(o.month)||!hr(o.day),u=l||c,h=o.weekYear||o.weekNumber,f=ds.fromObject(t);if((u||a)&&h)throw new A1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(c&&a)throw new A1("Can't mix ordinal dates with month/day");const d=h||o.weekday&&!u;let p,m,g=TT(s,i);d?(p=qct,m=Hct,g=fF(g)):a?(p=Xct,m=jct,g=W3(g)):(p=Oie,m=Die);let y=!1;for(const A of p){const M=o[A];hr(M)?y?o[A]=m[A]:o[A]=g[A]:y=!0}const b=d?Wct(o):a?Gct(o):$ie(o),x=b||Rie(o);if(x)return yn.invalid(x);const w=d?lj(o):a?cj(o):o,[_,C]=YE(w,i,r),k=new yn({ts:_,zone:r,o:C,loc:f});return o.weekday&&u&&e.weekday!==k.weekday?yn.invalid("mismatched weekday",`you can't specify both a weekday of ${o.weekday} and a date of ${k.toISO()}`):k}static fromISO(e,t={}){const[r,s]=hct(e);return Kx(r,s,t,"ISO 8601",e)}static fromRFC2822(e,t={}){const[r,s]=fct(e);return Kx(r,s,t,"RFC 2822",e)}static fromHTTP(e,t={}){const[r,s]=dct(e);return Kx(r,s,t,"HTTP",t)}static fromFormat(e,t,r={}){if(hr(e)||hr(t))throw new hc("fromFormat requires an input string and a format");const{locale:s=null,numberingSystem:i=null}=r,o=ds.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0}),[a,l,c,u]=Uct(o,e,t);return u?yn.invalid(u):Kx(a,l,r,`format ${t}`,e,c)}static fromString(e,t,r={}){return yn.fromFormat(e,t,r)}static fromSQL(e,t={}){const[r,s]=wct(e);return Kx(r,s,t,"SQL",e)}static invalid(e,t=null){if(!e)throw new hc("need to specify a reason the DateTime is invalid");const r=e instanceof du?e:new du(e,t);if(mi.throwOnInvalid)throw new Qat(r);return new yn({invalid:r})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}static parseFormatForOpts(e,t={}){const r=Tie(e,ds.fromObject(t));return r?r.map(s=>s?s.val:null).join(""):null}static expandFormat(e,t={}){return Cie(Wo.parseFormat(e),ds.fromObject(t)).map(s=>s.val).join("")}get(e){return this[e]}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?H3(this).weekYear:NaN}get weekNumber(){return this.isValid?H3(this).weekNumber:NaN}get weekday(){return this.isValid?H3(this).weekday:NaN}get ordinal(){return this.isValid?W3(this.c).ordinal:NaN}get monthShort(){return this.isValid?_T.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?_T.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?_T.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?_T.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return this.isOffsetFixed?!1:this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const e=864e5,t=6e4,r=w$(this.c),s=this.zone.offset(r-e),i=this.zone.offset(r+e),o=this.zone.offset(r-s*t),a=this.zone.offset(r-i*t);if(o===a)return[this];const l=r-o*t,c=r-a*t,u=TT(l,o),h=TT(c,a);return u.hour===h.hour&&u.minute===h.minute&&u.second===h.second&&u.millisecond===h.millisecond?[am(this,{ts:l}),am(this,{ts:c})]:[this]}get isInLeapYear(){return $C(this.year)}get daysInMonth(){return dA(this.year,this.month)}get daysInYear(){return this.isValid?Q1(this.year):NaN}get weeksInWeekYear(){return this.isValid?pA(this.weekYear):NaN}resolvedLocaleOptions(e={}){const{locale:t,numberingSystem:r,calendar:s}=Wo.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:r,outputCalendar:s}}toUTC(e=0,t={}){return this.setZone(pa.instance(e),t)}toLocal(){return this.setZone(mi.defaultZone)}setZone(e,{keepLocalTime:t=!1,keepCalendarTime:r=!1}={}){if(e=Ed(e,mi.defaultZone),e.equals(this.zone))return this;if(e.isValid){let s=this.ts;if(t||r){const i=e.offset(this.ts),o=this.toObject();[s]=YE(o,i,e)}return am(this,{ts:s,zone:e})}else return yn.invalid(kT(e))}reconfigure({locale:e,numberingSystem:t,outputCalendar:r}={}){const s=this.loc.clone({locale:e,numberingSystem:t,outputCalendar:r});return am(this,{loc:s})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;const t=mA(e,dj),r=!hr(t.weekYear)||!hr(t.weekNumber)||!hr(t.weekday),s=!hr(t.ordinal),i=!hr(t.year),o=!hr(t.month)||!hr(t.day),a=i||o,l=t.weekYear||t.weekNumber;if((a||s)&&l)throw new A1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&s)throw new A1("Can't mix ordinal dates with month/day");let c;r?c=lj({...fF(this.c),...t}):hr(t.ordinal)?(c={...this.toObject(),...t},hr(t.day)&&(c.day=Math.min(dA(c.year,c.month),c.day))):c=cj({...W3(this.c),...t});const[u,h]=YE(c,this.o,this.zone);return am(this,{ts:u,o:h})}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return am(this,hj(this,t))}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e).negate();return am(this,hj(this,t))}startOf(e){if(!this.isValid)return this;const t={},r=Sr.normalizeUnit(e);switch(r){case"years":t.month=1;case"quarters":case"months":t.day=1;case"weeks":case"days":t.hour=0;case"hours":t.minute=0;case"minutes":t.second=0;case"seconds":t.millisecond=0;break}if(r==="weeks"&&(t.weekday=1),r==="quarters"){const s=Math.ceil(this.month/3);t.month=(s-1)*3+1}return this.set(t)}endOf(e){return this.isValid?this.plus({[e]:1}).startOf(e).minus(1):this}toFormat(e,t={}){return this.isValid?Wo.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):G3}toLocaleString(e=fA,t={}){return this.isValid?Wo.create(this.loc.clone(t),e).formatDateTime(this):G3}toLocaleParts(e={}){return this.isValid?Wo.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO({format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:r=!1,includeOffset:s=!0,extendedZone:i=!1}={}){if(!this.isValid)return null;const o=e==="extended";let a=j3(this,o);return a+="T",a+=fj(this,o,t,r,s,i),a}toISODate({format:e="extended"}={}){return this.isValid?j3(this,e==="extended"):null}toISOWeekDate(){return ET(this,"kkkk-'W'WW-c")}toISOTime({suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:r=!0,includePrefix:s=!1,extendedZone:i=!1,format:o="extended"}={}){return this.isValid?(s?"T":"")+fj(this,o==="extended",t,e,r,i):null}toRFC2822(){return ET(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return ET(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?j3(this,!0):null}toSQLTime({includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:r=!0}={}){let s="HH:mm:ss.SSS";return(t||e)&&(r&&(s+=" "),t?s+="z":e&&(s+="ZZ")),ET(this,s,!0)}toSQL(e={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():G3}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(e={}){if(!this.isValid)return{};const t={...this.c};return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e,t="milliseconds",r={}){if(!this.isValid||!e.isValid)return Sr.invalid("created by diffing an invalid DateTime");const s={locale:this.locale,numberingSystem:this.numberingSystem,...r},i=_lt(t).map(Sr.normalizeUnit),o=e.valueOf()>this.valueOf(),a=o?this:e,l=o?e:this,c=Ect(a,l,i,s);return o?c.negate():c}diffNow(e="milliseconds",t={}){return this.diff(yn.now(),e,t)}until(e){return this.isValid?Hs.fromDateTimes(this,e):this}hasSame(e,t){if(!this.isValid)return!1;const r=e.valueOf(),s=this.setZone(e.zone,{keepLocalTime:!0});return s.startOf(t)<=r&&r<=s.endOf(t)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(e={}){if(!this.isValid)return null;const t=e.base||yn.fromObject({},{zone:this.zone}),r=e.padding?this<t?-e.padding:e.padding:0;let s=["years","months","days","hours","minutes","seconds"],i=e.unit;return Array.isArray(e.unit)&&(s=e.unit,i=void 0),mj(t,this.plus(r),{...e,numeric:"always",units:s,unit:i})}toRelativeCalendar(e={}){return this.isValid?mj(e.base||yn.fromObject({},{zone:this.zone}),this,{...e,numeric:"auto",units:["years","months","days"],calendary:!0}):null}static min(...e){if(!e.every(yn.isDateTime))throw new hc("min requires all arguments be DateTimes");return Q5(e,t=>t.valueOf(),Math.min)}static max(...e){if(!e.every(yn.isDateTime))throw new hc("max requires all arguments be DateTimes");return Q5(e,t=>t.valueOf(),Math.max)}static fromFormatExplain(e,t,r={}){const{locale:s=null,numberingSystem:i=null}=r,o=ds.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0});return kie(o,e,t)}static fromStringExplain(e,t,r={}){return yn.fromFormatExplain(e,t,r)}static get DATE_SHORT(){return fA}static get DATE_MED(){return zse}static get DATE_MED_WITH_WEEKDAY(){return nlt}static get DATE_FULL(){return Bse}static get DATE_HUGE(){return Vse}static get TIME_SIMPLE(){return Use}static get TIME_WITH_SECONDS(){return Wse}static get TIME_WITH_SHORT_OFFSET(){return Gse}static get TIME_WITH_LONG_OFFSET(){return Hse}static get TIME_24_SIMPLE(){return jse}static get TIME_24_WITH_SECONDS(){return qse}static get TIME_24_WITH_SHORT_OFFSET(){return Xse}static get TIME_24_WITH_LONG_OFFSET(){return Kse}static get DATETIME_SHORT(){return Yse}static get DATETIME_SHORT_WITH_SECONDS(){return Zse}static get DATETIME_MED(){return Jse}static get DATETIME_MED_WITH_SECONDS(){return Qse}static get DATETIME_MED_WITH_WEEKDAY(){return rlt}static get DATETIME_FULL(){return eie}static get DATETIME_FULL_WITH_SECONDS(){return tie}static get DATETIME_HUGE(){return nie}static get DATETIME_HUGE_WITH_SECONDS(){return rie}}function Yx(n){if(yn.isDateTime(n))return n;if(n&&n.valueOf&&Xm(n.valueOf()))return yn.fromJSDate(n);if(n&&typeof n=="object")return yn.fromObject(n);throw new hc(`Unknown datetime argument: ${n}, of type ${typeof n}`)}/*!
 * chartjs-adapter-luxon v1.3.1
 * https://www.chartjs.org
 * (c) 2023 chartjs-adapter-luxon Contributors
 * Released under the MIT license
 */const Kct={datetime:yn.DATETIME_MED_WITH_SECONDS,millisecond:"h:mm:ss.SSS a",second:yn.TIME_WITH_SECONDS,minute:yn.TIME_SIMPLE,hour:{hour:"numeric"},day:{day:"numeric",month:"short"},week:"DD",month:{month:"short",year:"numeric"},quarter:"'Q'q - yyyy",year:{year:"numeric"}};vse._date.override({_id:"luxon",_create:function(n){return yn.fromMillis(n,this.options)},init(n){this.options.locale||(this.options.locale=n.locale)},formats:function(){return Kct},parse:function(n,e){const t=this.options,r=typeof n;return n===null||r==="undefined"?null:(r==="number"?n=this._create(n):r==="string"?typeof e=="string"?n=yn.fromFormat(n,e,t):n=yn.fromISO(n,t):n instanceof Date?n=yn.fromJSDate(n,t):r==="object"&&!(n instanceof yn)&&(n=yn.fromObject(n,t)),n.isValid?n.valueOf():null)},format:function(n,e){const t=this._create(n);return typeof e=="string"?t.toFormat(e):t.toLocaleString(e)},add:function(n,e,t){const r={};return r[t]=e,this._create(n).plus(r).valueOf()},diff:function(n,e,t){return this._create(n).diff(this._create(e)).as(t).valueOf()},startOf:function(n,e,t){if(e==="isoWeek"){t=Math.trunc(Math.min(Math.max(0,t),6));const r=this._create(n);return r.minus({days:(r.weekday-t+7)%7}).startOf("day").valueOf()}return e?this._create(n).startOf(e).valueOf():n},endOf:function(n,e){return this._create(n).endOf(e).valueOf()}});var Yct={exports:{}};/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */(function(n){(function(e,t,r,s){var i=["","webkit","Moz","MS","ms","o"],o=t.createElement("div"),a="function",l=Math.round,c=Math.abs,u=Date.now;function h(H,Y,de){return setTimeout(x(H,de),Y)}function f(H,Y,de){return Array.isArray(H)?(d(H,de[Y],de),!0):!1}function d(H,Y,de){var $e;if(H)if(H.forEach)H.forEach(Y,de);else if(H.length!==s)for($e=0;$e<H.length;)Y.call(de,H[$e],$e,H),$e++;else for($e in H)H.hasOwnProperty($e)&&Y.call(de,H[$e],$e,H)}function p(H,Y,de){var $e="DEPRECATED METHOD: "+Y+`
`+de+` AT 
`;return function(){var lt=new Error("get-stack-trace"),Vt=lt&&lt.stack?lt.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",An=e.console&&(e.console.warn||e.console.log);return An&&An.call(e.console,$e,Vt),H.apply(this,arguments)}}var m;typeof Object.assign!="function"?m=function(Y){if(Y===s||Y===null)throw new TypeError("Cannot convert undefined or null to object");for(var de=Object(Y),$e=1;$e<arguments.length;$e++){var lt=arguments[$e];if(lt!==s&&lt!==null)for(var Vt in lt)lt.hasOwnProperty(Vt)&&(de[Vt]=lt[Vt])}return de}:m=Object.assign;var g=p(function(Y,de,$e){for(var lt=Object.keys(de),Vt=0;Vt<lt.length;)(!$e||$e&&Y[lt[Vt]]===s)&&(Y[lt[Vt]]=de[lt[Vt]]),Vt++;return Y},"extend","Use `assign`."),y=p(function(Y,de){return g(Y,de,!0)},"merge","Use `assign`.");function b(H,Y,de){var $e=Y.prototype,lt;lt=H.prototype=Object.create($e),lt.constructor=H,lt._super=$e,de&&m(lt,de)}function x(H,Y){return function(){return H.apply(Y,arguments)}}function w(H,Y){return typeof H==a?H.apply(Y&&Y[0]||s,Y):H}function _(H,Y){return H===s?Y:H}function C(H,Y,de){d(I(Y),function($e){H.addEventListener($e,de,!1)})}function k(H,Y,de){d(I(Y),function($e){H.removeEventListener($e,de,!1)})}function A(H,Y){for(;H;){if(H==Y)return!0;H=H.parentNode}return!1}function M(H,Y){return H.indexOf(Y)>-1}function I(H){return H.trim().split(/\s+/g)}function N(H,Y,de){if(H.indexOf&&!de)return H.indexOf(Y);for(var $e=0;$e<H.length;){if(de&&H[$e][de]==Y||!de&&H[$e]===Y)return $e;$e++}return-1}function O(H){return Array.prototype.slice.call(H,0)}function R(H,Y,de){for(var $e=[],lt=[],Vt=0;Vt<H.length;){var An=Y?H[Vt][Y]:H[Vt];N(lt,An)<0&&$e.push(H[Vt]),lt[Vt]=An,Vt++}return de&&(Y?$e=$e.sort(function(Us,fi){return Us[Y]>fi[Y]}):$e=$e.sort()),$e}function D(H,Y){for(var de,$e,lt=Y[0].toUpperCase()+Y.slice(1),Vt=0;Vt<i.length;){if(de=i[Vt],$e=de?de+lt:Y,$e in H)return $e;Vt++}return s}var z=1;function B(){return z++}function X(H){var Y=H.ownerDocument||H;return Y.defaultView||Y.parentWindow||e}var G=/mobile|tablet|ip(ad|hone|od)|android/i,ee="ontouchstart"in e,pe=D(e,"PointerEvent")!==s,oe=ee&&G.test(navigator.userAgent),Ne="touch",ke="pen",De="mouse",ge="kinect",Xe=25,Oe=1,it=2,Ge=4,pt=8,ut=1,Ve=2,ze=4,Be=8,ht=16,Ke=Ve|ze,Q=Be|ht,Z=Ke|Q,nt=["x","y"],He=["clientX","clientY"];function me(H,Y){var de=this;this.manager=H,this.callback=Y,this.element=H.element,this.target=H.options.inputTarget,this.domHandler=function($e){w(H.options.enable,[H])&&de.handler($e)},this.init()}me.prototype={handler:function(){},init:function(){this.evEl&&C(this.element,this.evEl,this.domHandler),this.evTarget&&C(this.target,this.evTarget,this.domHandler),this.evWin&&C(X(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&k(this.element,this.evEl,this.domHandler),this.evTarget&&k(this.target,this.evTarget,this.domHandler),this.evWin&&k(X(this.element),this.evWin,this.domHandler)}};function Ye(H){var Y,de=H.options.inputClass;return de?Y=de:pe?Y=Ri:oe?Y=wt:ee?Y=Cn:Y=Gl,new Y(H,bt)}function bt(H,Y,de){var $e=de.pointers.length,lt=de.changedPointers.length,Vt=Y&Oe&&$e-lt===0,An=Y&(Ge|pt)&&$e-lt===0;de.isFirst=!!Vt,de.isFinal=!!An,Vt&&(H.session={}),de.eventType=Y,kt(H,de),H.emit("hammer.input",de),H.recognize(de),H.session.prevInput=de}function kt(H,Y){var de=H.session,$e=Y.pointers,lt=$e.length;de.firstInput||(de.firstInput=tt(Y)),lt>1&&!de.firstMultiple?de.firstMultiple=tt(Y):lt===1&&(de.firstMultiple=!1);var Vt=de.firstInput,An=de.firstMultiple,Ps=An?An.center:Vt.center,Us=Y.center=Ct($e);Y.timeStamp=u(),Y.deltaTime=Y.timeStamp-Vt.timeStamp,Y.angle=_r(Ps,Us),Y.distance=En(Ps,Us),dt(de,Y),Y.offsetDirection=Ht(Y.deltaX,Y.deltaY);var fi=yt(Y.deltaTime,Y.deltaX,Y.deltaY);Y.overallVelocityX=fi.x,Y.overallVelocityY=fi.y,Y.overallVelocity=c(fi.x)>c(fi.y)?fi.x:fi.y,Y.scale=An?Ms(An.pointers,$e):1,Y.rotation=An?Bs(An.pointers,$e):0,Y.maxPointers=de.prevInput?Y.pointers.length>de.prevInput.maxPointers?Y.pointers.length:de.prevInput.maxPointers:Y.pointers.length,le(de,Y);var Ea=H.element;A(Y.srcEvent.target,Ea)&&(Ea=Y.srcEvent.target),Y.target=Ea}function dt(H,Y){var de=Y.center,$e=H.offsetDelta||{},lt=H.prevDelta||{},Vt=H.prevInput||{};(Y.eventType===Oe||Vt.eventType===Ge)&&(lt=H.prevDelta={x:Vt.deltaX||0,y:Vt.deltaY||0},$e=H.offsetDelta={x:de.x,y:de.y}),Y.deltaX=lt.x+(de.x-$e.x),Y.deltaY=lt.y+(de.y-$e.y)}function le(H,Y){var de=H.lastInterval||Y,$e=Y.timeStamp-de.timeStamp,lt,Vt,An,Ps;if(Y.eventType!=pt&&($e>Xe||de.velocity===s)){var Us=Y.deltaX-de.deltaX,fi=Y.deltaY-de.deltaY,Ea=yt($e,Us,fi);Vt=Ea.x,An=Ea.y,lt=c(Ea.x)>c(Ea.y)?Ea.x:Ea.y,Ps=Ht(Us,fi),H.lastInterval=Y}else lt=de.velocity,Vt=de.velocityX,An=de.velocityY,Ps=de.direction;Y.velocity=lt,Y.velocityX=Vt,Y.velocityY=An,Y.direction=Ps}function tt(H){for(var Y=[],de=0;de<H.pointers.length;)Y[de]={clientX:l(H.pointers[de].clientX),clientY:l(H.pointers[de].clientY)},de++;return{timeStamp:u(),pointers:Y,center:Ct(Y),deltaX:H.deltaX,deltaY:H.deltaY}}function Ct(H){var Y=H.length;if(Y===1)return{x:l(H[0].clientX),y:l(H[0].clientY)};for(var de=0,$e=0,lt=0;lt<Y;)de+=H[lt].clientX,$e+=H[lt].clientY,lt++;return{x:l(de/Y),y:l($e/Y)}}function yt(H,Y,de){return{x:Y/H||0,y:de/H||0}}function Ht(H,Y){return H===Y?ut:c(H)>=c(Y)?H<0?Ve:ze:Y<0?Be:ht}function En(H,Y,de){de||(de=nt);var $e=Y[de[0]]-H[de[0]],lt=Y[de[1]]-H[de[1]];return Math.sqrt($e*$e+lt*lt)}function _r(H,Y,de){de||(de=nt);var $e=Y[de[0]]-H[de[0]],lt=Y[de[1]]-H[de[1]];return Math.atan2(lt,$e)*180/Math.PI}function Bs(H,Y){return _r(Y[1],Y[0],He)+_r(H[1],H[0],He)}function Ms(H,Y){return En(Y[0],Y[1],He)/En(H[0],H[1],He)}var Ns={mousedown:Oe,mousemove:it,mouseup:Ge},Lh="mousedown",Wl="mousemove mouseup";function Gl(){this.evEl=Lh,this.evWin=Wl,this.pressed=!1,me.apply(this,arguments)}b(Gl,me,{handler:function(Y){var de=Ns[Y.type];de&Oe&&Y.button===0&&(this.pressed=!0),de&it&&Y.which!==1&&(de=Ge),this.pressed&&(de&Ge&&(this.pressed=!1),this.callback(this.manager,de,{pointers:[Y],changedPointers:[Y],pointerType:De,srcEvent:Y}))}});var fo={pointerdown:Oe,pointermove:it,pointerup:Ge,pointercancel:pt,pointerout:pt},Hl={2:Ne,3:ke,4:De,5:ge},Bc="pointerdown",Vc="pointermove pointerup pointercancel";e.MSPointerEvent&&!e.PointerEvent&&(Bc="MSPointerDown",Vc="MSPointerMove MSPointerUp MSPointerCancel");function Ri(){this.evEl=Bc,this.evWin=Vc,me.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}b(Ri,me,{handler:function(Y){var de=this.store,$e=!1,lt=Y.type.toLowerCase().replace("ms",""),Vt=fo[lt],An=Hl[Y.pointerType]||Y.pointerType,Ps=An==Ne,Us=N(de,Y.pointerId,"pointerId");Vt&Oe&&(Y.button===0||Ps)?Us<0&&(de.push(Y),Us=de.length-1):Vt&(Ge|pt)&&($e=!0),!(Us<0)&&(de[Us]=Y,this.callback(this.manager,Vt,{pointers:de,changedPointers:[Y],pointerType:An,srcEvent:Y}),$e&&de.splice(Us,1))}});var zh={touchstart:Oe,touchmove:it,touchend:Ge,touchcancel:pt},sl="touchstart",Bh="touchstart touchmove touchend touchcancel";function re(){this.evTarget=sl,this.evWin=Bh,this.started=!1,me.apply(this,arguments)}b(re,me,{handler:function(Y){var de=zh[Y.type];if(de===Oe&&(this.started=!0),!!this.started){var $e=We.call(this,Y,de);de&(Ge|pt)&&$e[0].length-$e[1].length===0&&(this.started=!1),this.callback(this.manager,de,{pointers:$e[0],changedPointers:$e[1],pointerType:Ne,srcEvent:Y})}}});function We(H,Y){var de=O(H.touches),$e=O(H.changedTouches);return Y&(Ge|pt)&&(de=R(de.concat($e),"identifier",!0)),[de,$e]}var Fe={touchstart:Oe,touchmove:it,touchend:Ge,touchcancel:pt},Ze="touchstart touchmove touchend touchcancel";function wt(){this.evTarget=Ze,this.targetIds={},me.apply(this,arguments)}b(wt,me,{handler:function(Y){var de=Fe[Y.type],$e=zn.call(this,Y,de);$e&&this.callback(this.manager,de,{pointers:$e[0],changedPointers:$e[1],pointerType:Ne,srcEvent:Y})}});function zn(H,Y){var de=O(H.touches),$e=this.targetIds;if(Y&(Oe|it)&&de.length===1)return $e[de[0].identifier]=!0,[de,de];var lt,Vt,An=O(H.changedTouches),Ps=[],Us=this.target;if(Vt=de.filter(function(fi){return A(fi.target,Us)}),Y===Oe)for(lt=0;lt<Vt.length;)$e[Vt[lt].identifier]=!0,lt++;for(lt=0;lt<An.length;)$e[An[lt].identifier]&&Ps.push(An[lt]),Y&(Ge|pt)&&delete $e[An[lt].identifier],lt++;if(Ps.length)return[R(Vt.concat(Ps),"identifier",!0),Ps]}var sn=2500,_n=25;function Cn(){me.apply(this,arguments);var H=x(this.handler,this);this.touch=new wt(this.manager,H),this.mouse=new Gl(this.manager,H),this.primaryTouch=null,this.lastTouches=[]}b(Cn,me,{handler:function(Y,de,$e){var lt=$e.pointerType==Ne,Vt=$e.pointerType==De;if(!(Vt&&$e.sourceCapabilities&&$e.sourceCapabilities.firesTouchEvents)){if(lt)In.call(this,de,$e);else if(Vt&&vn.call(this,$e))return;this.callback(Y,de,$e)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});function In(H,Y){H&Oe?(this.primaryTouch=Y.changedPointers[0].identifier,er.call(this,Y)):H&(Ge|pt)&&er.call(this,Y)}function er(H){var Y=H.changedPointers[0];if(Y.identifier===this.primaryTouch){var de={x:Y.clientX,y:Y.clientY};this.lastTouches.push(de);var $e=this.lastTouches,lt=function(){var Vt=$e.indexOf(de);Vt>-1&&$e.splice(Vt,1)};setTimeout(lt,sn)}}function vn(H){for(var Y=H.srcEvent.clientX,de=H.srcEvent.clientY,$e=0;$e<this.lastTouches.length;$e++){var lt=this.lastTouches[$e],Vt=Math.abs(Y-lt.x),An=Math.abs(de-lt.y);if(Vt<=_n&&An<=_n)return!0}return!1}var cr=D(o.style,"touchAction"),Pi=cr!==s,wr="compute",Yi="auto",Ar="manipulation",To="none",ss="pan-x",po="pan-y",Eo=Vh();function $s(H,Y){this.manager=H,this.set(Y)}$s.prototype={set:function(H){H==wr&&(H=this.compute()),Pi&&this.manager.element.style&&Eo[H]&&(this.manager.element.style[cr]=H),this.actions=H.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var H=[];return d(this.manager.recognizers,function(Y){w(Y.options.enable,[Y])&&(H=H.concat(Y.getTouchAction()))}),mo(H.join(" "))},preventDefaults:function(H){var Y=H.srcEvent,de=H.offsetDirection;if(this.manager.session.prevented){Y.preventDefault();return}var $e=this.actions,lt=M($e,To)&&!Eo[To],Vt=M($e,po)&&!Eo[po],An=M($e,ss)&&!Eo[ss];if(lt){var Ps=H.pointers.length===1,Us=H.distance<2,fi=H.deltaTime<250;if(Ps&&Us&&fi)return}if(!(An&&Vt)&&(lt||Vt&&de&Ke||An&&de&Q))return this.preventSrc(Y)},preventSrc:function(H){this.manager.session.prevented=!0,H.preventDefault()}};function mo(H){if(M(H,To))return To;var Y=M(H,ss),de=M(H,po);return Y&&de?To:Y||de?Y?ss:po:M(H,Ar)?Ar:Yi}function Vh(){if(!Pi)return!1;var H={},Y=e.CSS&&e.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(de){H[de]=Y?e.CSS.supports("touch-action",de):!0}),H}var il=1,Zi=2,Uc=4,Ta=8,Rs=Ta,Wc=16,Ji=32;function Vs(H){this.options=m({},this.defaults,H||{}),this.id=B(),this.manager=null,this.options.enable=_(this.options.enable,!0),this.state=il,this.simultaneous={},this.requireFail=[]}Vs.prototype={defaults:{},set:function(H){return m(this.options,H),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(H){if(f(H,"recognizeWith",this))return this;var Y=this.simultaneous;return H=Wh(H,this),Y[H.id]||(Y[H.id]=H,H.recognizeWith(this)),this},dropRecognizeWith:function(H){return f(H,"dropRecognizeWith",this)?this:(H=Wh(H,this),delete this.simultaneous[H.id],this)},requireFailure:function(H){if(f(H,"requireFailure",this))return this;var Y=this.requireFail;return H=Wh(H,this),N(Y,H)===-1&&(Y.push(H),H.requireFailure(this)),this},dropRequireFailure:function(H){if(f(H,"dropRequireFailure",this))return this;H=Wh(H,this);var Y=N(this.requireFail,H);return Y>-1&&this.requireFail.splice(Y,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(H){return!!this.simultaneous[H.id]},emit:function(H){var Y=this,de=this.state;function $e(lt){Y.manager.emit(lt,H)}de<Ta&&$e(Y.options.event+Uh(de)),$e(Y.options.event),H.additionalEvent&&$e(H.additionalEvent),de>=Ta&&$e(Y.options.event+Uh(de))},tryEmit:function(H){if(this.canEmit())return this.emit(H);this.state=Ji},canEmit:function(){for(var H=0;H<this.requireFail.length;){if(!(this.requireFail[H].state&(Ji|il)))return!1;H++}return!0},recognize:function(H){var Y=m({},H);if(!w(this.options.enable,[this,Y])){this.reset(),this.state=Ji;return}this.state&(Rs|Wc|Ji)&&(this.state=il),this.state=this.process(Y),this.state&(Zi|Uc|Ta|Wc)&&this.tryEmit(Y)},process:function(H){},getTouchAction:function(){},reset:function(){}};function Uh(H){return H&Wc?"cancel":H&Ta?"end":H&Uc?"move":H&Zi?"start":""}function r0(H){return H==ht?"down":H==Be?"up":H==Ve?"left":H==ze?"right":""}function Wh(H,Y){var de=Y.manager;return de?de.get(H):H}function Qi(){Vs.apply(this,arguments)}b(Qi,Vs,{defaults:{pointers:1},attrTest:function(H){var Y=this.options.pointers;return Y===0||H.pointers.length===Y},process:function(H){var Y=this.state,de=H.eventType,$e=Y&(Zi|Uc),lt=this.attrTest(H);return $e&&(de&pt||!lt)?Y|Wc:$e||lt?de&Ge?Y|Ta:Y&Zi?Y|Uc:Zi:Ji}});function Gh(){Qi.apply(this,arguments),this.pX=null,this.pY=null}b(Gh,Qi,{defaults:{event:"pan",threshold:10,pointers:1,direction:Z},getTouchAction:function(){var H=this.options.direction,Y=[];return H&Ke&&Y.push(po),H&Q&&Y.push(ss),Y},directionTest:function(H){var Y=this.options,de=!0,$e=H.distance,lt=H.direction,Vt=H.deltaX,An=H.deltaY;return lt&Y.direction||(Y.direction&Ke?(lt=Vt===0?ut:Vt<0?Ve:ze,de=Vt!=this.pX,$e=Math.abs(H.deltaX)):(lt=An===0?ut:An<0?Be:ht,de=An!=this.pY,$e=Math.abs(H.deltaY))),H.direction=lt,de&&$e>Y.threshold&&lt&Y.direction},attrTest:function(H){return Qi.prototype.attrTest.call(this,H)&&(this.state&Zi||!(this.state&Zi)&&this.directionTest(H))},emit:function(H){this.pX=H.deltaX,this.pY=H.deltaY;var Y=r0(H.direction);Y&&(H.additionalEvent=this.options.event+Y),this._super.emit.call(this,H)}});function Zf(){Qi.apply(this,arguments)}b(Zf,Qi,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[To]},attrTest:function(H){return this._super.attrTest.call(this,H)&&(Math.abs(H.scale-1)>this.options.threshold||this.state&Zi)},emit:function(H){if(H.scale!==1){var Y=H.scale<1?"in":"out";H.additionalEvent=this.options.event+Y}this._super.emit.call(this,H)}});function Hu(){Vs.apply(this,arguments),this._timer=null,this._input=null}b(Hu,Vs,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[Yi]},process:function(H){var Y=this.options,de=H.pointers.length===Y.pointers,$e=H.distance<Y.threshold,lt=H.deltaTime>Y.time;if(this._input=H,!$e||!de||H.eventType&(Ge|pt)&&!lt)this.reset();else if(H.eventType&Oe)this.reset(),this._timer=h(function(){this.state=Rs,this.tryEmit()},Y.time,this);else if(H.eventType&Ge)return Rs;return Ji},reset:function(){clearTimeout(this._timer)},emit:function(H){this.state===Rs&&(H&&H.eventType&Ge?this.manager.emit(this.options.event+"up",H):(this._input.timeStamp=u(),this.manager.emit(this.options.event,this._input)))}});function Jf(){Qi.apply(this,arguments)}b(Jf,Qi,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[To]},attrTest:function(H){return this._super.attrTest.call(this,H)&&(Math.abs(H.rotation)>this.options.threshold||this.state&Zi)}});function Hh(){Qi.apply(this,arguments)}b(Hh,Qi,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Ke|Q,pointers:1},getTouchAction:function(){return Gh.prototype.getTouchAction.call(this)},attrTest:function(H){var Y=this.options.direction,de;return Y&(Ke|Q)?de=H.overallVelocity:Y&Ke?de=H.overallVelocityX:Y&Q&&(de=H.overallVelocityY),this._super.attrTest.call(this,H)&&Y&H.offsetDirection&&H.distance>this.options.threshold&&H.maxPointers==this.options.pointers&&c(de)>this.options.velocity&&H.eventType&Ge},emit:function(H){var Y=r0(H.offsetDirection);Y&&this.manager.emit(this.options.event+Y,H),this.manager.emit(this.options.event,H)}});function jl(){Vs.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}b(jl,Vs,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[Ar]},process:function(H){var Y=this.options,de=H.pointers.length===Y.pointers,$e=H.distance<Y.threshold,lt=H.deltaTime<Y.time;if(this.reset(),H.eventType&Oe&&this.count===0)return this.failTimeout();if($e&&lt&&de){if(H.eventType!=Ge)return this.failTimeout();var Vt=this.pTime?H.timeStamp-this.pTime<Y.interval:!0,An=!this.pCenter||En(this.pCenter,H.center)<Y.posThreshold;this.pTime=H.timeStamp,this.pCenter=H.center,!An||!Vt?this.count=1:this.count+=1,this._input=H;var Ps=this.count%Y.taps;if(Ps===0)return this.hasRequireFailures()?(this._timer=h(function(){this.state=Rs,this.tryEmit()},Y.interval,this),Zi):Rs}return Ji},failTimeout:function(){return this._timer=h(function(){this.state=Ji},this.options.interval,this),Ji},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==Rs&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}});function Zr(H,Y){return Y=Y||{},Y.recognizers=_(Y.recognizers,Zr.defaults.preset),new Gc(H,Y)}Zr.VERSION="2.0.7",Zr.defaults={domEvents:!1,touchAction:wr,enable:!0,inputTarget:null,inputClass:null,preset:[[Jf,{enable:!1}],[Zf,{enable:!1},["rotate"]],[Hh,{direction:Ke}],[Gh,{direction:Ke},["swipe"]],[jl],[jl,{event:"doubletap",taps:2},["tap"]],[Hu]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var s0=1,Qf=2;function Gc(H,Y){this.options=m({},Zr.defaults,Y||{}),this.options.inputTarget=this.options.inputTarget||H,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=H,this.input=Ye(this),this.touchAction=new $s(this,this.options.touchAction),jh(this,!0),d(this.options.recognizers,function(de){var $e=this.add(new de[0](de[1]));de[2]&&$e.recognizeWith(de[2]),de[3]&&$e.requireFailure(de[3])},this)}Gc.prototype={set:function(H){return m(this.options,H),H.touchAction&&this.touchAction.update(),H.inputTarget&&(this.input.destroy(),this.input.target=H.inputTarget,this.input.init()),this},stop:function(H){this.session.stopped=H?Qf:s0},recognize:function(H){var Y=this.session;if(!Y.stopped){this.touchAction.preventDefaults(H);var de,$e=this.recognizers,lt=Y.curRecognizer;(!lt||lt&&lt.state&Rs)&&(lt=Y.curRecognizer=null);for(var Vt=0;Vt<$e.length;)de=$e[Vt],Y.stopped!==Qf&&(!lt||de==lt||de.canRecognizeWith(lt))?de.recognize(H):de.reset(),!lt&&de.state&(Zi|Uc|Ta)&&(lt=Y.curRecognizer=de),Vt++}},get:function(H){if(H instanceof Vs)return H;for(var Y=this.recognizers,de=0;de<Y.length;de++)if(Y[de].options.event==H)return Y[de];return null},add:function(H){if(f(H,"add",this))return this;var Y=this.get(H.options.event);return Y&&this.remove(Y),this.recognizers.push(H),H.manager=this,this.touchAction.update(),H},remove:function(H){if(f(H,"remove",this))return this;if(H=this.get(H),H){var Y=this.recognizers,de=N(Y,H);de!==-1&&(Y.splice(de,1),this.touchAction.update())}return this},on:function(H,Y){if(H!==s&&Y!==s){var de=this.handlers;return d(I(H),function($e){de[$e]=de[$e]||[],de[$e].push(Y)}),this}},off:function(H,Y){if(H!==s){var de=this.handlers;return d(I(H),function($e){Y?de[$e]&&de[$e].splice(N(de[$e],Y),1):delete de[$e]}),this}},emit:function(H,Y){this.options.domEvents&&i0(H,Y);var de=this.handlers[H]&&this.handlers[H].slice();if(!(!de||!de.length)){Y.type=H,Y.preventDefault=function(){Y.srcEvent.preventDefault()};for(var $e=0;$e<de.length;)de[$e](Y),$e++}},destroy:function(){this.element&&jh(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}};function jh(H,Y){var de=H.element;if(de.style){var $e;d(H.options.cssProps,function(lt,Vt){$e=D(de.style,Vt),Y?(H.oldCssProps[$e]=de.style[$e],de.style[$e]=lt):de.style[$e]=H.oldCssProps[$e]||""}),Y||(H.oldCssProps={})}}function i0(H,Y){var de=t.createEvent("Event");de.initEvent(H,!0,!0),de.gesture=Y,Y.target.dispatchEvent(de)}m(Zr,{INPUT_START:Oe,INPUT_MOVE:it,INPUT_END:Ge,INPUT_CANCEL:pt,STATE_POSSIBLE:il,STATE_BEGAN:Zi,STATE_CHANGED:Uc,STATE_ENDED:Ta,STATE_RECOGNIZED:Rs,STATE_CANCELLED:Wc,STATE_FAILED:Ji,DIRECTION_NONE:ut,DIRECTION_LEFT:Ve,DIRECTION_RIGHT:ze,DIRECTION_UP:Be,DIRECTION_DOWN:ht,DIRECTION_HORIZONTAL:Ke,DIRECTION_VERTICAL:Q,DIRECTION_ALL:Z,Manager:Gc,Input:me,TouchAction:$s,TouchInput:wt,MouseInput:Gl,PointerEventInput:Ri,TouchMouseInput:Cn,SingleTouchInput:re,Recognizer:Vs,AttrRecognizer:Qi,Tap:jl,Pan:Gh,Swipe:Hh,Pinch:Zf,Rotate:Jf,Press:Hu,on:C,off:k,each:d,merge:y,extend:g,assign:m,inherit:b,bindFn:x,prefixed:D});var o0=typeof e<"u"?e:typeof self<"u"?self:{};o0.Hammer=Zr,typeof s=="function"&&s.amd?s(function(){return Zr}):n.exports?n.exports=Zr:e[r]=Zr})(window,document,"Hammer")})(Yct);var Fie={exports:{}};(function(n){(function(e){var t=e.URL||e.webkitURL;function r(c){return t?t.createObjectURL(c):!1}function s(c){return t?t.revokeObjectURL(c):!1}function i(c,u){c&&c.slice(0,5)==="blob:"&&!(u&&u.noRevoke)&&s(c)}function o(c,u,h,f){if(!e.FileReader)return!1;var d=new FileReader;d.onload=function(){u.call(d,this.result)},h&&(d.onabort=d.onerror=function(){h.call(d,this.error)});var p=d[f||"readAsDataURL"];if(p)return p.call(d,c),d}function a(c,u){return Object.prototype.toString.call(u)==="[object "+c+"]"}function l(c,u,h){function f(d,p){var m=document.createElement("img"),g;function y(x,w){if(d===p){d&&d(x,w);return}else if(x instanceof Error){p(x);return}w=w||{},w.image=x,d(w)}function b(x,w){w&&e.console&&console.log(w),x&&a("Blob",x)?(c=x,g=r(c)):(g=c,h&&h.crossOrigin&&(m.crossOrigin=h.crossOrigin)),m.src=g}if(m.onerror=function(x){i(g,h),p&&p.call(m,x)},m.onload=function(){i(g,h);var x={originalWidth:m.naturalWidth||m.width,originalHeight:m.naturalHeight||m.height};try{l.transform(m,h,y,c,x)}catch(w){p&&p(w)}},typeof c=="string")return l.requiresMetaData(h)?l.fetchBlob(c,b,h):b(),m;if(a("Blob",c)||a("File",c))return g=r(c),g?(m.src=g,m):o(c,function(x){m.src=x},p)}return e.Promise&&typeof u!="function"?(h=u,new Promise(f)):f(u,u)}l.requiresMetaData=function(c){return c&&c.meta},l.fetchBlob=function(c,u){u()},l.transform=function(c,u,h,f,d){h(c,d)},l.global=e,l.readFile=o,l.isInstanceOf=a,l.createObjectURL=r,l.revokeObjectURL=s,n.exports?n.exports=l:e.loadImage=l})(typeof window<"u"&&window||mt)})(Fie);var Dp=Fie.exports,Lie={exports:{}};(function(n){(function(e){n.exports?e(Dp):e(window.loadImage)})(function(e){var t=e.transform;e.createCanvas=function(r,s,i){if(i&&e.global.OffscreenCanvas)return new OffscreenCanvas(r,s);var o=document.createElement("canvas");return o.width=r,o.height=s,o},e.transform=function(r,s,i,o,a){t.call(e,e.scale(r,s,a),s,i,o,a)},e.transformCoordinates=function(){},e.getTransformedOptions=function(r,s){var i=s.aspectRatio,o,a,l,c;if(!i)return s;o={};for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(o[a]=s[a]);return o.crop=!0,l=r.naturalWidth||r.width,c=r.naturalHeight||r.height,l/c>i?(o.maxWidth=c*i,o.maxHeight=c):(o.maxWidth=l,o.maxHeight=l/i),o},e.drawImage=function(r,s,i,o,a,l,c,u,h){var f=s.getContext("2d");return h.imageSmoothingEnabled===!1?(f.msImageSmoothingEnabled=!1,f.imageSmoothingEnabled=!1):h.imageSmoothingQuality&&(f.imageSmoothingQuality=h.imageSmoothingQuality),f.drawImage(r,i,o,a,l,0,0,c,u),f},e.requiresCanvas=function(r){return r.canvas||r.crop||!!r.aspectRatio},e.scale=function(r,s,i){s=s||{},i=i||{};var o=r.getContext||e.requiresCanvas(s)&&!!e.global.HTMLCanvasElement,a=r.naturalWidth||r.width,l=r.naturalHeight||r.height,c=a,u=l,h,f,d,p,m,g,y,b,x,w,_,C;function k(){var M=Math.max((d||c)/c,(p||u)/u);M>1&&(c*=M,u*=M)}function A(){var M=Math.min((h||c)/c,(f||u)/u);M<1&&(c*=M,u*=M)}if(o&&(s=e.getTransformedOptions(r,s,i),y=s.left||0,b=s.top||0,s.sourceWidth?(m=s.sourceWidth,s.right!==void 0&&s.left===void 0&&(y=a-m-s.right)):m=a-y-(s.right||0),s.sourceHeight?(g=s.sourceHeight,s.bottom!==void 0&&s.top===void 0&&(b=l-g-s.bottom)):g=l-b-(s.bottom||0),c=m,u=g),h=s.maxWidth,f=s.maxHeight,d=s.minWidth,p=s.minHeight,o&&h&&f&&s.crop?(c=h,u=f,_=m/g-h/f,_<0?(g=f*m/h,s.top===void 0&&s.bottom===void 0&&(b=(l-g)/2)):_>0&&(m=h*g/f,s.left===void 0&&s.right===void 0&&(y=(a-m)/2))):((s.contain||s.cover)&&(d=h=h||d,p=f=f||p),s.cover?(A(),k()):(k(),A())),o){if(x=s.pixelRatio,x>1&&!(r.style.width&&Math.floor(parseFloat(r.style.width,10))===Math.floor(a/x))&&(c*=x,u*=x),e.orientationCropBug&&!r.getContext&&(y||b||m!==a||g!==l)&&(_=r,r=e.createCanvas(a,l,!0),e.drawImage(_,r,0,0,a,l,a,l,s)),w=s.downsamplingRatio,w>0&&w<1&&c<m&&u<g)for(;m*w>c;)C=e.createCanvas(m*w,g*w,!0),e.drawImage(r,C,y,b,m,g,C.width,C.height,s),y=0,b=0,m=C.width,g=C.height,r=C;return C=e.createCanvas(c,u),e.transformCoordinates(C,s,i),x>1&&(C.style.width=C.width/x+"px"),e.drawImage(r,C,y,b,m,g,c,u,s).setTransform(1,0,0,1,0,0),C}return r.width=c,r.height=u,r}})})(Lie);var Zct=Lie.exports,zie={exports:{}};(function(n){(function(e){n.exports?e(Dp):e(window.loadImage)})(function(e){var t=e.global,r=e.transform,s=t.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice),i=t.ArrayBuffer&&ArrayBuffer.prototype.slice||function(u,h){h=h||this.byteLength-u;var f=new Uint8Array(this,u,h),d=new Uint8Array(h);return d.set(f),d.buffer},o={jpeg:{65505:[],65517:[]}};function a(u,h,f,d){var p=this;function m(g,y){if(!(t.DataView&&s&&u&&u.size>=12&&u.type==="image/jpeg"))return g(d);var b=f.maxMetaDataSize||262144;e.readFile(s.call(u,0,b),function(x){var w=new DataView(x);if(w.getUint16(0)!==65496)return y(new Error("Invalid JPEG file: Missing JPEG marker."));for(var _=2,C=w.byteLength-4,k=_,A,M,I,N;_<C&&(A=w.getUint16(_),A>=65504&&A<=65519||A===65534);){if(M=w.getUint16(_+2)+2,_+M>w.byteLength){console.log("Invalid JPEG metadata: Invalid segment size.");break}if(I=o.jpeg[A],I&&!f.disableMetaDataParsers)for(N=0;N<I.length;N+=1)I[N].call(p,w,_,M,d,f);_+=M,k=_}!f.disableImageHead&&k>6&&(d.imageHead=i.call(x,0,k)),g(d)},y,"readAsArrayBuffer")||g(d)}return f=f||{},t.Promise&&typeof h!="function"?(f=h||{},d=f,new Promise(m)):(d=d||{},m(h,h))}function l(u,h,f){return!u||!h||!f?null:new Blob([f,s.call(u,h.byteLength)],{type:"image/jpeg"})}function c(u,h,f){var d={maxMetaDataSize:1024,disableMetaDataParsers:!0};if(!f&&t.Promise)return a(u,d).then(function(p){return l(u,p.imageHead,h)});a(u,function(p){f(l(u,p.imageHead,h))},d)}e.transform=function(u,h,f,d,p){e.requiresMetaData(h)?(p=p||{},a(d,function(m){m!==p&&(t.console&&console.log(m),m=p),r.call(e,u,h,f,d,m)},h,p)):r.apply(e,arguments)},e.blobSlice=s,e.bufferSlice=i,e.replaceHead=c,e.parseMetaData=a,e.metaDataParsers=o})})(zie);var L4=zie.exports,Jct={exports:{}};(function(n){(function(e){n.exports?e(Dp):e(window.loadImage)})(function(e){var t=e.global;t.fetch&&t.Request&&t.Response&&t.Response.prototype.blob?e.fetchBlob=function(r,s,i){function o(a){return a.blob()}if(t.Promise&&typeof s!="function")return fetch(new Request(r,s)).then(o);fetch(new Request(r,i)).then(o).then(s).catch(function(a){s(null,a)})}:t.XMLHttpRequest&&new XMLHttpRequest().responseType===""&&(e.fetchBlob=function(r,s,i){function o(a,l){i=i||{};var c=new XMLHttpRequest;c.open(i.method||"GET",r),i.headers&&Object.keys(i.headers).forEach(function(u){c.setRequestHeader(u,i.headers[u])}),c.withCredentials=i.credentials==="include",c.responseType="blob",c.onload=function(){a(c.response)},c.onerror=c.onabort=c.ontimeout=function(u){a===l?l(null,u):l(u)},c.send(i.body)}return t.Promise&&typeof s!="function"?(i=s,new Promise(o)):o(s,s)})})})(Jct);var Bie={exports:{}};(function(n){(function(e){n.exports?e(Dp,L4):e(window.loadImage)})(function(e){function t(c){c&&(Object.defineProperty(this,"map",{value:this.ifds[c].map}),Object.defineProperty(this,"tags",{value:this.tags&&this.tags[c]||{}}))}t.prototype.map={Orientation:274,Thumbnail:"ifd1",Blob:513,Exif:34665,GPSInfo:34853,Interoperability:40965},t.prototype.ifds={ifd1:{name:"Thumbnail",map:t.prototype.map},34665:{name:"Exif",map:{}},34853:{name:"GPSInfo",map:{}},40965:{name:"Interoperability",map:{}}},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){if(h){if(u+h>c.byteLength){console.log("Invalid Exif data: Invalid thumbnail data.");return}return new Blob([e.bufferSlice.call(c.buffer,u,u+h)],{type:"image/jpeg"})}}var s={1:{getValue:function(c,u){return c.getUint8(u)},size:1},2:{getValue:function(c,u){return String.fromCharCode(c.getUint8(u))},size:1,ascii:!0},3:{getValue:function(c,u,h){return c.getUint16(u,h)},size:2},4:{getValue:function(c,u,h){return c.getUint32(u,h)},size:4},5:{getValue:function(c,u,h){return c.getUint32(u,h)/c.getUint32(u+4,h)},size:8},9:{getValue:function(c,u,h){return c.getInt32(u,h)},size:4},10:{getValue:function(c,u,h){return c.getInt32(u,h)/c.getInt32(u+4,h)},size:8}};s[7]=s[1];function i(c,u,h,f,d,p){var m=s[f],g,y,b,x,w,_;if(!m){console.log("Invalid Exif data: Invalid tag type.");return}if(g=m.size*d,y=g>4?u+c.getUint32(h+8,p):h+8,y+g>c.byteLength){console.log("Invalid Exif data: Invalid data offset.");return}if(d===1)return m.getValue(c,y,p);for(b=[],x=0;x<d;x+=1)b[x]=m.getValue(c,y+x*m.size,p);if(m.ascii){for(w="",x=0;x<b.length&&(_=b[x],_!=="\0");x+=1)w+=_;return w}return b}function o(c,u,h){return(!c||c[h])&&(!u||u[h]!==!0)}function a(c,u,h,f,d,p,m,g){var y,b,x,w,_,C;if(h+6>c.byteLength){console.log("Invalid Exif data: Invalid directory offset.");return}if(y=c.getUint16(h,f),b=h+2+12*y,b+4>c.byteLength){console.log("Invalid Exif data: Invalid directory size.");return}for(x=0;x<y;x+=1)w=h+2+12*x,_=c.getUint16(w,f),o(m,g,_)&&(C=i(c,u,w,c.getUint16(w+2,f),c.getUint32(w+4,f),f),d[_]=C,p&&(p[_]=w));return c.getUint32(b,f)}function l(c,u,h,f,d,p,m){var g=c.exif[u];g&&(c.exif[u]=new t(u),c.exifOffsets&&(c.exifOffsets[u]=new t(u)),a(h,f,f+g,d,c.exif[u],c.exifOffsets&&c.exifOffsets[u],p&&p[u],m&&m[u]))}e.parseExifData=function(c,u,h,f,d){if(!d.disableExif){var p=d.includeExifTags,m=d.excludeExifTags||{34665:{37500:!0}},g=u+10,y,b,x;if(c.getUint32(u+4)===1165519206){if(g+8>c.byteLength){console.log("Invalid Exif data: Invalid segment size.");return}if(c.getUint16(u+8)!==0){console.log("Invalid Exif data: Missing byte alignment offset.");return}switch(c.getUint16(g)){case 18761:y=!0;break;case 19789:y=!1;break;default:console.log("Invalid Exif data: Invalid byte alignment marker.");return}if(c.getUint16(g+2,y)!==42){console.log("Invalid Exif data: Missing TIFF marker.");return}b=c.getUint32(g+4,y),f.exif=new t,d.disableExifOffsets||(f.exifOffsets=new t,f.exifTiffOffset=g,f.exifLittleEndian=y),b=a(c,g,g+b,y,f.exif,f.exifOffsets,p,m),b&&o(p,m,"ifd1")&&(f.exif.ifd1=b,f.exifOffsets&&(f.exifOffsets.ifd1=g+b)),Object.keys(f.exif.ifds).forEach(function(w){l(f,w,c,g,y,p,m)}),x=f.exif.ifd1,x&&x[513]&&(x[513]=r(c,g+x[513],x[514]))}}},e.metaDataParsers.jpeg[65505].push(e.parseExifData),e.exifWriters={274:function(c,u,h){var f=u.exifOffsets[274];if(!f)return c;var d=new DataView(c,f+8,2);return d.setUint16(0,h,u.exifLittleEndian),c}},e.writeExifData=function(c,u,h,f){return e.exifWriters[u.exif.map[h]](c,u,f)},e.ExifMap=t})})(Bie);var Qct=Bie.exports,eut={exports:{}};(function(n){(function(e){n.exports?e(Dp,Qct):e(window.loadImage)})(function(e){var t=e.ExifMap.prototype;t.tags={256:"ImageWidth",257:"ImageHeight",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",34665:{36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",36880:"OffsetTime",36881:"OffsetTimeOriginal",36882:"OffsetTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber"},34853:{0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},40965:{1:"InteroperabilityIndex"}},t.tags.ifd1=t.tags,t.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"Original",2:"Horizontal flip",3:"Rotate 180 CCW",4:"Vertical flip",5:"Vertical flip + Rotate 90 CW",6:"Rotate 90 CW",7:"Horizontal flip + Rotate 90 CW",8:"Rotate 90 CCW"}},t.getText=function(r){var s=this.get(r);switch(r){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[r][s];case"ExifVersion":case"FlashpixVersion":return s?String.fromCharCode(s[0],s[1],s[2],s[3]):void 0;case"ComponentsConfiguration":return s?this.stringValues[r][s[0]]+this.stringValues[r][s[1]]+this.stringValues[r][s[2]]+this.stringValues[r][s[3]]:void 0;case"GPSVersionID":return s?s[0]+"."+s[1]+"."+s[2]+"."+s[3]:void 0}return String(s)},t.getAll=function(){var r={},s,i,o;for(s in this)Object.prototype.hasOwnProperty.call(this,s)&&(i=this[s],i&&i.getAll?r[this.ifds[s].name]=i.getAll():(o=this.tags[s],o&&(r[o]=this.getText(o))));return r},t.getName=function(r){var s=this.tags[r];return typeof s=="object"?this.ifds[r].name:s},function(){var r=t.tags,s,i,o;for(s in r)if(Object.prototype.hasOwnProperty.call(r,s))if(i=t.ifds[s],i){o=r[s];for(s in o)Object.prototype.hasOwnProperty.call(o,s)&&(i.map[o[s]]=Number(s))}else t.map[r[s]]=Number(s)}()})})(eut);var Vie={exports:{}};(function(n){(function(e){n.exports?e(Dp,L4):e(window.loadImage)})(function(e){function t(){}t.prototype.map={ObjectName:5},t.prototype.types={0:"Uint16",200:"Uint16",201:"Uint16",202:"binary"},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){for(var f="",d=u+h,p=u;p<d;p+=1)f+=String.fromCharCode(c.getUint8(p));return f}function s(c,u,h,f,d){return u.types[c]==="binary"?new Blob([h.buffer.slice(f,f+d)]):u.types[c]==="Uint16"?h.getUint16(f):r(h,f,d)}function i(c,u){return c===void 0?u:c instanceof Array?(c.push(u),c):[c,u]}function o(c,u,h,f,d,p){for(var m,g,y,b=u+h,x=u;x<b;)c.getUint8(x)===28&&c.getUint8(x+1)===2&&(y=c.getUint8(x+2),(!d||d[y])&&(!p||!p[y])&&(g=c.getInt16(x+3),m=s(y,f.iptc,c,x+5,g),f.iptc[y]=i(f.iptc[y],m),f.iptcOffsets&&(f.iptcOffsets[y]=x))),x+=1}function a(c,u){return c.getUint32(u)===943868237&&c.getUint16(u+4)===1028}function l(c,u){var h=c.getUint8(u+7);return h%2!==0&&(h+=1),h===0&&(h=4),h}e.parseIptcData=function(c,u,h,f,d){if(!d.disableIptc)for(var p=u+h;u+8<p;){if(a(c,u)){var m=l(c,u),g=u+8+m;if(g>p){console.log("Invalid IPTC data: Invalid segment offset.");break}var y=c.getUint16(u+6+m);if(u+y>p){console.log("Invalid IPTC data: Invalid segment size.");break}f.iptc=new t,d.disableIptcOffsets||(f.iptcOffsets=new t),o(c,g,y,f,d.includeIptcTags,d.excludeIptcTags||{202:!0});return}u+=1}},e.metaDataParsers.jpeg[65517].push(e.parseIptcData),e.IptcMap=t})})(Vie);var tut=Vie.exports,nut={exports:{}};(function(n){(function(e){n.exports?e(Dp,tut):e(window.loadImage)})(function(e){var t=e.IptcMap.prototype;t.tags={0:"ApplicationRecordVersion",3:"ObjectTypeReference",4:"ObjectAttributeReference",5:"ObjectName",7:"EditStatus",8:"EditorialUpdate",10:"Urgency",12:"SubjectReference",15:"Category",20:"SupplementalCategories",22:"FixtureIdentifier",25:"Keywords",26:"ContentLocationCode",27:"ContentLocationName",30:"ReleaseDate",35:"ReleaseTime",37:"ExpirationDate",38:"ExpirationTime",40:"SpecialInstructions",42:"ActionAdvised",45:"ReferenceService",47:"ReferenceDate",50:"ReferenceNumber",55:"DateCreated",60:"TimeCreated",62:"DigitalCreationDate",63:"DigitalCreationTime",65:"OriginatingProgram",70:"ProgramVersion",75:"ObjectCycle",80:"Byline",85:"BylineTitle",90:"City",92:"Sublocation",95:"State",100:"CountryCode",101:"Country",103:"OriginalTransmissionReference",105:"Headline",110:"Credit",115:"Source",116:"CopyrightNotice",118:"Contact",120:"Caption",121:"LocalCaption",122:"Writer",125:"RasterizedCaption",130:"ImageType",131:"ImageOrientation",135:"LanguageIdentifier",150:"AudioType",151:"AudioSamplingRate",152:"AudioSamplingResolution",153:"AudioDuration",154:"AudioOutcue",184:"JobID",185:"MasterDocumentID",186:"ShortDocumentID",187:"UniqueDocumentID",188:"OwnerID",200:"ObjectPreviewFileFormat",201:"ObjectPreviewFileVersion",202:"ObjectPreviewData",221:"Prefs",225:"ClassifyState",228:"SimilarityIndex",230:"DocumentNotes",231:"DocumentHistory",232:"ExifCameraInfo",255:"CatalogSets"},t.stringValues={10:{0:"0 (reserved)",1:"1 (most urgent)",2:"2",3:"3",4:"4",5:"5 (normal urgency)",6:"6",7:"7",8:"8 (least urgent)",9:"9 (user-defined priority)"},75:{a:"Morning",b:"Both Morning and Evening",p:"Evening"},131:{L:"Landscape",P:"Portrait",S:"Square"}},t.getText=function(r){var s=this.get(r),i=this.map[r],o=this.stringValues[i];return o?o[s]:String(s)},t.getAll=function(){var r={},s,i;for(s in this)Object.prototype.hasOwnProperty.call(this,s)&&(i=this.tags[s],i&&(r[i]=this.getText(i)));return r},t.getName=function(r){return this.tags[r]},function(){var r=t.tags,s=t.map||{},i;for(i in r)Object.prototype.hasOwnProperty.call(r,i)&&(s[r[i]]=Number(i))}()})})(nut);var rut={exports:{}};(function(n){(function(e){n.exports?e(Dp,Zct,L4):e(window.loadImage)})(function(e){var t=e.transform,r=e.requiresCanvas,s=e.requiresMetaData,i=e.transformCoordinates,o=e.getTransformedOptions;(function(u){if(u.global.document){var h="data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/xABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAAAAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQvoP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXwH/9k=",f=document.createElement("img");f.onload=function(){if(u.orientation=f.width===2&&f.height===3,u.orientation){var d=u.createCanvas(1,1,!0),p=d.getContext("2d");p.drawImage(f,1,1,1,1,0,0,1,1),u.orientationCropBug=p.getImageData(0,0,1,1).data.toString()!=="255,255,255,255"}},f.src=h}})(e);function a(u,h){var f=u&&u.orientation;return f===!0&&!e.orientation||f===1&&e.orientation||(!h||e.orientation)&&f>1&&f<9}function l(u,h){return u!==h&&(u===1&&h>1&&h<9||u>1&&u<9)}function c(u,h){if(h>1&&h<9)switch(u){case 2:case 4:return h>4;case 5:case 7:return h%2===0;case 6:case 8:return h===2||h===4||h===5||h===7}return!1}e.requiresCanvas=function(u){return a(u)||r.call(e,u)},e.requiresMetaData=function(u){return a(u,!0)||s.call(e,u)},e.transform=function(u,h,f,d,p){t.call(e,u,h,function(m,g){if(g){var y=e.orientation&&g.exif&&g.exif.get("Orientation");if(y>4&&y<9){var b=g.originalWidth,x=g.originalHeight;g.originalWidth=x,g.originalHeight=b}}f(m,g)},d,p)},e.getTransformedOptions=function(u,h,f){var d=o.call(e,u,h),p=f.exif&&f.exif.get("Orientation"),m=d.orientation,g=e.orientation&&p;if(m===!0&&(m=p),!l(m,g))return d;var y=d.top,b=d.right,x=d.bottom,w=d.left,_={};for(var C in d)Object.prototype.hasOwnProperty.call(d,C)&&(_[C]=d[C]);if(_.orientation=m,(m>4&&!(g>4)||m<5&&g>4)&&(_.maxWidth=d.maxHeight,_.maxHeight=d.maxWidth,_.minWidth=d.minHeight,_.minHeight=d.minWidth,_.sourceWidth=d.sourceHeight,_.sourceHeight=d.sourceWidth),g>1){switch(g){case 2:b=d.left,w=d.right;break;case 3:y=d.bottom,b=d.left,x=d.top,w=d.right;break;case 4:y=d.bottom,x=d.top;break;case 5:y=d.left,b=d.bottom,x=d.right,w=d.top;break;case 6:y=d.left,b=d.top,x=d.right,w=d.bottom;break;case 7:y=d.right,b=d.top,x=d.left,w=d.bottom;break;case 8:y=d.right,b=d.bottom,x=d.left,w=d.top;break}if(c(m,g)){var k=y,A=b;y=x,b=w,x=k,w=A}}switch(_.top=y,_.right=b,_.bottom=x,_.left=w,m){case 2:_.right=w,_.left=b;break;case 3:_.top=x,_.right=w,_.bottom=y,_.left=b;break;case 4:_.top=x,_.bottom=y;break;case 5:_.top=w,_.right=x,_.bottom=b,_.left=y;break;case 6:_.top=b,_.right=x,_.bottom=w,_.left=y;break;case 7:_.top=b,_.right=y,_.bottom=w,_.left=x;break;case 8:_.top=w,_.right=y,_.bottom=b,_.left=x;break}return _},e.transformCoordinates=function(u,h,f){i.call(e,u,h,f);var d=h.orientation,p=e.orientation&&f.exif&&f.exif.get("Orientation");if(l(d,p)){var m=u.getContext("2d"),g=u.width,y=u.height,b=g,x=y;switch((d>4&&!(p>4)||d<5&&p>4)&&(u.width=y,u.height=g),d>4&&(b=y,x=g),p){case 2:m.translate(b,0),m.scale(-1,1);break;case 3:m.translate(b,x),m.rotate(Math.PI);break;case 4:m.translate(0,x),m.scale(1,-1);break;case 5:m.rotate(-.5*Math.PI),m.scale(-1,1);break;case 6:m.rotate(-.5*Math.PI),m.translate(-b,0);break;case 7:m.rotate(-.5*Math.PI),m.translate(-b,x),m.scale(1,-1);break;case 8:m.rotate(.5*Math.PI),m.translate(0,-x);break}switch(c(d,p)&&(m.translate(b,x),m.rotate(Math.PI)),d){case 2:m.translate(g,0),m.scale(-1,1);break;case 3:m.translate(g,y),m.rotate(Math.PI);break;case 4:m.translate(0,y),m.scale(1,-1);break;case 5:m.rotate(.5*Math.PI),m.scale(1,-1);break;case 6:m.rotate(.5*Math.PI),m.translate(0,-y);break;case 7:m.rotate(.5*Math.PI),m.translate(g,-y),m.scale(-1,1);break;case 8:m.rotate(-.5*Math.PI),m.translate(-g,0);break}}}})})(rut);function _$(n,e){let t=0;for(let r=0;r<n.length;r++)t+=(n[r]-e[r])*(n[r]-e[r]);return t}const q3={distanceFunction:_$};function sut(n,e,t=q3){const r=t.distanceFunction||q3.distanceFunction,s=t.similarityFunction||q3.similarityFunction;let i=-1;if(typeof s=="function"){let o=Number.MIN_VALUE;for(let a=0;a<n.length;a++){const l=s(e,n[a]);l>o&&(o=l,i=a)}}else if(typeof r=="function"){let o=Number.MAX_VALUE;for(let a=0;a<n.length;a++){const l=r(e,n[a]);l<o&&(o=l,i=a)}}else throw new Error("A similarity or distance function it's required");return i}function iut(n,e){for(var t=new Array(n.length),r=0;r<n.length;++r)for(var s=r;s<n.length;++s){t[r]||(t[r]=new Array(n.length)),t[s]||(t[s]=new Array(n.length));const i=e(n[r],n[s]);t[r][s]=i,t[s][r]=i}return t}function Uie(n,e,t,r){for(var s=0;s<n.length;s++)t[s]=sut(e,n[s],{distanceFunction:r});return t}function out(n,e,t,r){const s=e[0].length;for(var i=new Array(r),o=new Array(r),a=0;a<r;a++){i[a]=new Array(s),o[a]=0;for(var l=0;l<s;l++)i[a][l]=0}for(var c=0;c<e.length;c++){o[t[c]]++;for(var u=0;u<s;u++)i[t[c]][u]+=e[c][u]}for(var h=0;h<r;h++)for(var f=0;f<s;f++)o[h]?i[h][f]/=o[h]:i[h][f]=n[h][f];return i}function aut(n,e,t,r){for(var s=0;s<n.length;s++)if(t(n[s],e[s])>r)return!1;return!0}const yj=8,lut=1/16777216,cut=15,uut=18,hut=11;function fut(n,e){n>>>=0,e>>>=0;const t=n&65535;return((n-t)*e>>>0)+t*e>>>0}class dut{constructor(e=Date.now()){this.state=new Uint32Array(4),this.init(e),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*lut}init(e){if(!Number.isInteger(e))throw new TypeError("seed must be an integer");this.state[0]=e,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<yj;t++)this.state[t&3]^=t+fut(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<yj;t++)this.nextState()}periodCertification(){this.state[0]===0&&this.state[1]===0&&this.state[2]===0&&this.state[3]===0&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let e=this.state[0];e^=e<<cut,e^=e>>>uut,e^=this.state[3]<<hut,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=e}}const put=1e-8;function bj(n,e={},t=Math.random){const{size:r=1,replace:s=!1,probabilities:i}=e;let o,a;if(typeof n=="number"?o=mut(n):o=n.slice(),i){if(!s)throw new Error("choice with probabilities and no replacement is not implemented");if(i.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[i[0]];for(let c=1;c<i.length;c++)a[c]=a[c-1]+i[c];if(Math.abs(1-a[a.length-1])>put)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(s===!1&&r>o.length)throw new Error("size option is too large");const l=[];for(let c=0;c<r;c++){const u=gut(o.length,t,a);l.push(o[u]),s||o.splice(u,1)}return l}function mut(n){const e=[];for(let t=0;t<n;t++)e.push(t);return e}function gut(n,e,t){const r=e();if(t){let s=0;for(;r>t[s];)s++;return s}else return Math.floor(r*n)}class z4{constructor(e=Math.random){if(typeof e=="number"){const t=new dut(e);this.randomGenerator=t.random}else this.randomGenerator=e}choice(e,t){return typeof e=="number"?bj(e,t,this.randomGenerator):bj(e,t,this.randomGenerator)}random(){return this.randomGenerator()}randInt(e,t){return t===void 0&&(t=e,e=0),e+Math.floor(this.randomGenerator()*(t-e))}randomSample(e){const t=[];for(let r=0;r<e;r++)t.push(this.random());return t}}var lr={};const yut=Object.prototype.toString;function QS(n){const e=yut.call(n);return e.endsWith("Array]")&&!e.includes("Big")}const but=Object.freeze(Object.defineProperty({__proto__:null,isAnyArray:QS},Symbol.toStringTag,{value:"Module"})),vut=Vf(but);function wut(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!QS(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,s=e.toIndex,i=s===void 0?n.length:s;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=r||i>n.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<i;a++)n[a]>o&&(o=n[a]);return o}function xut(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!QS(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,s=e.toIndex,i=s===void 0?n.length:s;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=r||i>n.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<i;a++)n[a]<o&&(o=n[a]);return o}function Sut(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(QS(n)){if(n.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var t;if(e.output!==void 0){if(!QS(e.output))throw new TypeError("output option must be an array if specified");t=e.output}else t=new Array(n.length);var r=xut(n),s=wut(n);if(r===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var i=e.min,o=i===void 0?e.autoMinMax?r:0:i,a=e.max,l=a===void 0?e.autoMinMax?s:1:a;if(o>=l)throw new RangeError("min option must be smaller than max option");for(var c=(l-o)/(s-r),u=0;u<n.length;u++)t[u]=(n[u]-r)*c+o;return t}const _ut=Object.freeze(Object.defineProperty({__proto__:null,default:Sut},Symbol.toStringTag,{value:"Module"})),Cut=Vf(_ut);var La=vut,vj=Cut;const IT=" ".repeat(2),Wie=" ".repeat(4);function kut(){return Gie(this)}function Gie(n,e={}){const{maxRows:t=15,maxColumns:r=10,maxNumSize:s=8,padMinus:i="auto"}=e;return`${n.constructor.name} {
${IT}[
${Wie}${Tut(n,t,r,s,i)}
${IT}]
${IT}rows: ${n.rows}
${IT}columns: ${n.columns}
}`}function Tut(n,e,t,r,s){const{rows:i,columns:o}=n,a=Math.min(i,e),l=Math.min(o,t),c=[];if(s==="auto"){s=!1;e:for(let u=0;u<a;u++)for(let h=0;h<l;h++)if(n.get(u,h)<0){s=!0;break e}}for(let u=0;u<a;u++){let h=[];for(let f=0;f<l;f++)h.push(Eut(n.get(u,f),r,s));c.push(`${h.join(" ")}`)}return l!==o&&(c[c.length-1]+=` ... ${o-t} more columns`),a!==i&&c.push(`... ${i-e} more rows`),c.join(`
${Wie}`)}function Eut(n,e,t){return(n>=0&&t?` ${wj(n,e-1)}`:wj(n,e)).padEnd(e)}function wj(n,e){let t=n.toString();if(t.length<=e)return t;let r=n.toFixed(e);if(r.length>e&&(r=n.toFixed(Math.max(0,e-(r.length-e)))),r.length<=e&&!r.startsWith("0.000")&&!r.startsWith("-0.000"))return r;let s=n.toExponential(e);return s.length>e&&(s=n.toExponential(Math.max(0,e-(s.length-e)))),s.slice(0)}function Iut(n,e){n.prototype.add=function(r){return typeof r=="number"?this.addS(r):this.addM(r)},n.prototype.addS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)+r);return this},n.prototype.addM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)+r.get(s,i));return this},n.add=function(r,s){return new e(r).add(s)},n.prototype.sub=function(r){return typeof r=="number"?this.subS(r):this.subM(r)},n.prototype.subS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)-r);return this},n.prototype.subM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)-r.get(s,i));return this},n.sub=function(r,s){return new e(r).sub(s)},n.prototype.subtract=n.prototype.sub,n.prototype.subtractS=n.prototype.subS,n.prototype.subtractM=n.prototype.subM,n.subtract=n.sub,n.prototype.mul=function(r){return typeof r=="number"?this.mulS(r):this.mulM(r)},n.prototype.mulS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)*r);return this},n.prototype.mulM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)*r.get(s,i));return this},n.mul=function(r,s){return new e(r).mul(s)},n.prototype.multiply=n.prototype.mul,n.prototype.multiplyS=n.prototype.mulS,n.prototype.multiplyM=n.prototype.mulM,n.multiply=n.mul,n.prototype.div=function(r){return typeof r=="number"?this.divS(r):this.divM(r)},n.prototype.divS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)/r);return this},n.prototype.divM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)/r.get(s,i));return this},n.div=function(r,s){return new e(r).div(s)},n.prototype.divide=n.prototype.div,n.prototype.divideS=n.prototype.divS,n.prototype.divideM=n.prototype.divM,n.divide=n.div,n.prototype.mod=function(r){return typeof r=="number"?this.modS(r):this.modM(r)},n.prototype.modS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)%r);return this},n.prototype.modM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)%r.get(s,i));return this},n.mod=function(r,s){return new e(r).mod(s)},n.prototype.modulus=n.prototype.mod,n.prototype.modulusS=n.prototype.modS,n.prototype.modulusM=n.prototype.modM,n.modulus=n.mod,n.prototype.and=function(r){return typeof r=="number"?this.andS(r):this.andM(r)},n.prototype.andS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)&r);return this},n.prototype.andM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)&r.get(s,i));return this},n.and=function(r,s){return new e(r).and(s)},n.prototype.or=function(r){return typeof r=="number"?this.orS(r):this.orM(r)},n.prototype.orS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)|r);return this},n.prototype.orM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)|r.get(s,i));return this},n.or=function(r,s){return new e(r).or(s)},n.prototype.xor=function(r){return typeof r=="number"?this.xorS(r):this.xorM(r)},n.prototype.xorS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)^r);return this},n.prototype.xorM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)^r.get(s,i));return this},n.xor=function(r,s){return new e(r).xor(s)},n.prototype.leftShift=function(r){return typeof r=="number"?this.leftShiftS(r):this.leftShiftM(r)},n.prototype.leftShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)<<r);return this},n.prototype.leftShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)<<r.get(s,i));return this},n.leftShift=function(r,s){return new e(r).leftShift(s)},n.prototype.signPropagatingRightShift=function(r){return typeof r=="number"?this.signPropagatingRightShiftS(r):this.signPropagatingRightShiftM(r)},n.prototype.signPropagatingRightShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>r);return this},n.prototype.signPropagatingRightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>r.get(s,i));return this},n.signPropagatingRightShift=function(r,s){return new e(r).signPropagatingRightShift(s)},n.prototype.rightShift=function(r){return typeof r=="number"?this.rightShiftS(r):this.rightShiftM(r)},n.prototype.rightShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>>r);return this},n.prototype.rightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>>r.get(s,i));return this},n.rightShift=function(r,s){return new e(r).rightShift(s)},n.prototype.zeroFillRightShift=n.prototype.rightShift,n.prototype.zeroFillRightShiftS=n.prototype.rightShiftS,n.prototype.zeroFillRightShiftM=n.prototype.rightShiftM,n.zeroFillRightShift=n.rightShift,n.prototype.not=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,~this.get(r,s));return this},n.not=function(r){return new e(r).not()},n.prototype.abs=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.abs(this.get(r,s)));return this},n.abs=function(r){return new e(r).abs()},n.prototype.acos=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.acos(this.get(r,s)));return this},n.acos=function(r){return new e(r).acos()},n.prototype.acosh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.acosh(this.get(r,s)));return this},n.acosh=function(r){return new e(r).acosh()},n.prototype.asin=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.asin(this.get(r,s)));return this},n.asin=function(r){return new e(r).asin()},n.prototype.asinh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.asinh(this.get(r,s)));return this},n.asinh=function(r){return new e(r).asinh()},n.prototype.atan=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.atan(this.get(r,s)));return this},n.atan=function(r){return new e(r).atan()},n.prototype.atanh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.atanh(this.get(r,s)));return this},n.atanh=function(r){return new e(r).atanh()},n.prototype.cbrt=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cbrt(this.get(r,s)));return this},n.cbrt=function(r){return new e(r).cbrt()},n.prototype.ceil=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.ceil(this.get(r,s)));return this},n.ceil=function(r){return new e(r).ceil()},n.prototype.clz32=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.clz32(this.get(r,s)));return this},n.clz32=function(r){return new e(r).clz32()},n.prototype.cos=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cos(this.get(r,s)));return this},n.cos=function(r){return new e(r).cos()},n.prototype.cosh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cosh(this.get(r,s)));return this},n.cosh=function(r){return new e(r).cosh()},n.prototype.exp=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.exp(this.get(r,s)));return this},n.exp=function(r){return new e(r).exp()},n.prototype.expm1=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.expm1(this.get(r,s)));return this},n.expm1=function(r){return new e(r).expm1()},n.prototype.floor=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.floor(this.get(r,s)));return this},n.floor=function(r){return new e(r).floor()},n.prototype.fround=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.fround(this.get(r,s)));return this},n.fround=function(r){return new e(r).fround()},n.prototype.log=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log(this.get(r,s)));return this},n.log=function(r){return new e(r).log()},n.prototype.log1p=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log1p(this.get(r,s)));return this},n.log1p=function(r){return new e(r).log1p()},n.prototype.log10=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log10(this.get(r,s)));return this},n.log10=function(r){return new e(r).log10()},n.prototype.log2=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log2(this.get(r,s)));return this},n.log2=function(r){return new e(r).log2()},n.prototype.round=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.round(this.get(r,s)));return this},n.round=function(r){return new e(r).round()},n.prototype.sign=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sign(this.get(r,s)));return this},n.sign=function(r){return new e(r).sign()},n.prototype.sin=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sin(this.get(r,s)));return this},n.sin=function(r){return new e(r).sin()},n.prototype.sinh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sinh(this.get(r,s)));return this},n.sinh=function(r){return new e(r).sinh()},n.prototype.sqrt=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sqrt(this.get(r,s)));return this},n.sqrt=function(r){return new e(r).sqrt()},n.prototype.tan=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.tan(this.get(r,s)));return this},n.tan=function(r){return new e(r).tan()},n.prototype.tanh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.tanh(this.get(r,s)));return this},n.tanh=function(r){return new e(r).tanh()},n.prototype.trunc=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.trunc(this.get(r,s)));return this},n.trunc=function(r){return new e(r).trunc()},n.pow=function(r,s){return new e(r).pow(s)},n.prototype.pow=function(r){return typeof r=="number"?this.powS(r):this.powM(r)},n.prototype.powS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,Math.pow(this.get(s,i),r));return this},n.prototype.powM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,Math.pow(this.get(s,i),r.get(s,i)));return this}}function ac(n,e,t){let r=t?n.rows:n.rows-1;if(e<0||e>r)throw new RangeError("Row index out of range")}function lc(n,e,t){let r=t?n.columns:n.columns-1;if(e<0||e>r)throw new RangeError("Column index out of range")}function hb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function fb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function B4(n,e){if(!La.isAnyArray(e))throw new TypeError("row indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.rows)throw new RangeError("row indices are out of range")}function V4(n,e){if(!La.isAnyArray(e))throw new TypeError("column indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.columns)throw new RangeError("column indices are out of range")}function dF(n,e,t,r,s){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(AT("startRow",e),AT("endRow",t),AT("startColumn",r),AT("endColumn",s),e>t||r>s||e<0||e>=n.rows||t<0||t>=n.rows||r<0||r>=n.columns||s<0||s>=n.columns)throw new RangeError("Submatrix indices are out of range")}function C$(n,e=0){let t=[];for(let r=0;r<n;r++)t.push(e);return t}function AT(n,e){if(typeof e!="number")throw new TypeError(`${n} must be a number`)}function F0(n){if(n.isEmpty())throw new Error("Empty matrix has no elements to index")}function Aut(n){let e=C$(n.rows);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]+=n.get(t,r);return e}function Mut(n){let e=C$(n.columns);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]+=n.get(t,r);return e}function Nut(n){let e=0;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e+=n.get(t,r);return e}function $ut(n){let e=C$(n.rows,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]*=n.get(t,r);return e}function Rut(n){let e=C$(n.columns,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]*=n.get(t,r);return e}function Put(n){let e=1;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e*=n.get(t,r);return e}function Dut(n,e,t){const r=n.rows,s=n.columns,i=[];for(let o=0;o<r;o++){let a=0,l=0,c=0;for(let u=0;u<s;u++)c=n.get(o,u)-t[o],a+=c,l+=c*c;e?i.push((l-a*a/s)/(s-1)):i.push((l-a*a/s)/s)}return i}function Out(n,e,t){const r=n.rows,s=n.columns,i=[];for(let o=0;o<s;o++){let a=0,l=0,c=0;for(let u=0;u<r;u++)c=n.get(u,o)-t[o],a+=c,l+=c*c;e?i.push((l-a*a/r)/(r-1)):i.push((l-a*a/r)/r)}return i}function Fut(n,e,t){const r=n.rows,s=n.columns,i=r*s;let o=0,a=0,l=0;for(let c=0;c<r;c++)for(let u=0;u<s;u++)l=n.get(c,u)-t,o+=l,a+=l*l;return e?(a-o*o/i)/(i-1):(a-o*o/i)/i}function Lut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[t])}function zut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[r])}function But(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e)}function Vut(n){const e=[];for(let t=0;t<n.rows;t++){let r=0;for(let s=0;s<n.columns;s++)r+=Math.pow(n.get(t,s),2)/(n.columns-1);e.push(Math.sqrt(r))}return e}function Uut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[t])}function Wut(n){const e=[];for(let t=0;t<n.columns;t++){let r=0;for(let s=0;s<n.rows;s++)r+=Math.pow(n.get(s,t),2)/(n.rows-1);e.push(Math.sqrt(r))}return e}function Gut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[r])}function Hut(n){const e=n.size-1;let t=0;for(let r=0;r<n.columns;r++)for(let s=0;s<n.rows;s++)t+=Math.pow(n.get(s,r),2)/e;return Math.sqrt(t)}function jut(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e)}class Hn{static from1DArray(e,t,r){if(e*t!==r.length)throw new RangeError("data length does not match given dimensions");let i=new Wt(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)i.set(o,a,r[o*t+a]);return i}static rowVector(e){let t=new Wt(1,e.length);for(let r=0;r<e.length;r++)t.set(0,r,e[r]);return t}static columnVector(e){let t=new Wt(e.length,1);for(let r=0;r<e.length;r++)t.set(r,0,e[r]);return t}static zeros(e,t){return new Wt(e,t)}static ones(e,t){return new Wt(e,t).fill(1)}static rand(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{random:s=Math.random}=r;let i=new Wt(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)i.set(o,a,s());return i}static randInt(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:s=0,max:i=1e3,random:o=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(i))throw new TypeError("max must be an integer");if(s>=i)throw new RangeError("min must be smaller than max");let a=i-s,l=new Wt(e,t);for(let c=0;c<e;c++)for(let u=0;u<t;u++){let h=s+Math.round(o()*a);l.set(c,u,h)}return l}static eye(e,t,r){t===void 0&&(t=e),r===void 0&&(r=1);let s=Math.min(e,t),i=this.zeros(e,t);for(let o=0;o<s;o++)i.set(o,o,r);return i}static diag(e,t,r){let s=e.length;t===void 0&&(t=s),r===void 0&&(r=t);let i=Math.min(s,t,r),o=this.zeros(t,r);for(let a=0;a<i;a++)o.set(a,a,e[a]);return o}static min(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,s=e.columns,i=new Wt(r,s);for(let o=0;o<r;o++)for(let a=0;a<s;a++)i.set(o,a,Math.min(e.get(o,a),t.get(o,a)));return i}static max(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,s=e.columns,i=new this(r,s);for(let o=0;o<r;o++)for(let a=0;a<s;a++)i.set(o,a,Math.max(e.get(o,a),t.get(o,a)));return i}static checkMatrix(e){return Hn.isMatrix(e)?e:new Wt(e)}static isMatrix(e){return e!=null&&e.klass==="Matrix"}get size(){return this.rows*this.columns}apply(e){if(typeof e!="function")throw new TypeError("callback must be a function");for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.call(this,t,r);return this}to1DArray(){let e=[];for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}to2DArray(){let e=[];for(let t=0;t<this.rows;t++){e.push([]);for(let r=0;r<this.columns;r++)e[t].push(this.get(t,r))}return e}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let e=0;e<this.rows;e++)for(let t=0;t<=e;t++)if(this.get(e,t)!==this.get(t,e))return!1;return!0}return!1}isEchelonForm(){let e=0,t=0,r=-1,s=!0,i=!1;for(;e<this.rows&&s;){for(t=0,i=!1;t<this.columns&&i===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(i=!0,r=t):(s=!1,i=!0);e++}return s}isReducedEchelonForm(){let e=0,t=0,r=-1,s=!0,i=!1;for(;e<this.rows&&s;){for(t=0,i=!1;t<this.columns&&i===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(i=!0,r=t):(s=!1,i=!0);for(let o=t+1;o<this.rows;o++)this.get(e,o)!==0&&(s=!1);e++}return s}echelonForm(){let e=this.clone(),t=0,r=0;for(;t<e.rows&&r<e.columns;){let s=t;for(let i=t;i<e.rows;i++)e.get(i,r)>e.get(s,r)&&(s=i);if(e.get(s,r)===0)r++;else{e.swapRows(t,s);let i=e.get(t,r);for(let o=r;o<e.columns;o++)e.set(t,o,e.get(t,o)/i);for(let o=t+1;o<e.rows;o++){let a=e.get(o,r)/e.get(t,r);e.set(o,r,0);for(let l=r+1;l<e.columns;l++)e.set(o,l,e.get(o,l)-e.get(t,l)*a)}t++,r++}}return e}reducedEchelonForm(){let e=this.echelonForm(),t=e.columns,r=e.rows,s=r-1;for(;s>=0;)if(e.maxRow(s)===0)s--;else{let i=0,o=!1;for(;i<r&&o===!1;)e.get(s,i)===1?o=!0:i++;for(let a=0;a<s;a++){let l=e.get(a,i);for(let c=i;c<t;c++){let u=e.get(a,c)-l*e.get(s,c);e.set(a,c,u)}}s--}return e}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{rows:t=1,columns:r=1}=e;if(!Number.isInteger(t)||t<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new Wt(this.rows*t,this.columns*r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)s.setSubMatrix(this,this.rows*i,this.columns*o);return s}fill(e){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,e);return this}neg(){return this.mulS(-1)}getRow(e){ac(this,e);let t=[];for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}getRowVector(e){return Wt.rowVector(this.getRow(e))}setRow(e,t){ac(this,e),t=hb(this,t);for(let r=0;r<this.columns;r++)this.set(e,r,t[r]);return this}swapRows(e,t){ac(this,e),ac(this,t);for(let r=0;r<this.columns;r++){let s=this.get(e,r);this.set(e,r,this.get(t,r)),this.set(t,r,s)}return this}getColumn(e){lc(this,e);let t=[];for(let r=0;r<this.rows;r++)t.push(this.get(r,e));return t}getColumnVector(e){return Wt.columnVector(this.getColumn(e))}setColumn(e,t){lc(this,e),t=fb(this,t);for(let r=0;r<this.rows;r++)this.set(r,e,t[r]);return this}swapColumns(e,t){lc(this,e),lc(this,t);for(let r=0;r<this.rows;r++){let s=this.get(r,e);this.set(r,e,this.get(r,t)),this.set(r,t,s)}return this}addRowVector(e){e=hb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[r]);return this}subRowVector(e){e=hb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[r]);return this}mulRowVector(e){e=hb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[r]);return this}divRowVector(e){e=hb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[r]);return this}addColumnVector(e){e=fb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[t]);return this}subColumnVector(e){e=fb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[t]);return this}mulColumnVector(e){e=fb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[t]);return this}divColumnVector(e){e=fb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[t]);return this}mulRow(e,t){ac(this,e);for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this}mulColumn(e,t){lc(this,e);for(let r=0;r<this.rows;r++)this.set(r,e,this.get(r,e)*t);return this}max(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t[r]&&(t[r]=this.get(r,s));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t[s]&&(t[s]=this.get(r,s));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s));return t}default:throw new Error(`invalid option: ${e}`)}}maxIndex(){F0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>e&&(e=this.get(r,s),t[0]=r,t[1]=s);return t}min(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t[r]&&(t[r]=this.get(r,s));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t[s]&&(t[s]=this.get(r,s));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s));return t}default:throw new Error(`invalid option: ${e}`)}}minIndex(){F0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<e&&(e=this.get(r,s),t[0]=r,t[1]=s);return t}maxRow(e){if(ac(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxRowIndex(e){ac(this,e),F0(this);let t=this.get(e,0),r=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)>t&&(t=this.get(e,s),r[1]=s);return r}minRow(e){if(ac(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minRowIndex(e){ac(this,e),F0(this);let t=this.get(e,0),r=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)<t&&(t=this.get(e,s),r[1]=s);return r}maxColumn(e){if(lc(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)>t&&(t=this.get(r,e));return t}maxColumnIndex(e){lc(this,e),F0(this);let t=this.get(0,e),r=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)>t&&(t=this.get(s,e),r[0]=s);return r}minColumn(e){if(lc(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)<t&&(t=this.get(r,e));return t}minColumnIndex(e){lc(this,e),F0(this);let t=this.get(0,e),r=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)<t&&(t=this.get(s,e),r[0]=s);return r}diag(){let e=Math.min(this.rows,this.columns),t=[];for(let r=0;r<e;r++)t.push(this.get(r,r));return t}norm(e="frobenius"){switch(e){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${e}`)}}cumulativeSum(){let e=0;for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r),this.set(t,r,e);return this}dot(e){Hn.isMatrix(e)&&(e=e.to1DArray());let t=this.to1DArray();if(t.length!==e.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<t.length;s++)r+=t[s]*e[s];return r}mmul(e){e=Wt.checkMatrix(e);let t=this.rows,r=this.columns,s=e.columns,i=new Wt(t,s),o=new Float64Array(r);for(let a=0;a<s;a++){for(let l=0;l<r;l++)o[l]=e.get(l,a);for(let l=0;l<t;l++){let c=0;for(let u=0;u<r;u++)c+=this.get(l,u)*o[u];i.set(l,a,c)}}return i}strassen2x2(e){e=Wt.checkMatrix(e);let t=new Wt(2,2);const r=this.get(0,0),s=e.get(0,0),i=this.get(0,1),o=e.get(0,1),a=this.get(1,0),l=e.get(1,0),c=this.get(1,1),u=e.get(1,1),h=(r+c)*(s+u),f=(a+c)*s,d=r*(o-u),p=c*(l-s),m=(r+i)*u,g=(a-r)*(s+o),y=(i-c)*(l+u),b=h+p-m+y,x=d+m,w=f+p,_=h-f+d+g;return t.set(0,0,b),t.set(0,1,x),t.set(1,0,w),t.set(1,1,_),t}strassen3x3(e){e=Wt.checkMatrix(e);let t=new Wt(3,3);const r=this.get(0,0),s=this.get(0,1),i=this.get(0,2),o=this.get(1,0),a=this.get(1,1),l=this.get(1,2),c=this.get(2,0),u=this.get(2,1),h=this.get(2,2),f=e.get(0,0),d=e.get(0,1),p=e.get(0,2),m=e.get(1,0),g=e.get(1,1),y=e.get(1,2),b=e.get(2,0),x=e.get(2,1),w=e.get(2,2),_=(r+s+i-o-a-u-h)*g,C=(r-o)*(-d+g),k=a*(-f+d+m-g-y-b+w),A=(-r+o+a)*(f-d+g),M=(o+a)*(-f+d),I=r*f,N=(-r+c+u)*(f-p+y),O=(-r+c)*(p-y),R=(c+u)*(-f+p),D=(r+s+i-a-l-c-u)*y,z=u*(-f+p+m-g-y-b+x),B=(-i+u+h)*(g+b-x),X=(i-h)*(g-x),G=i*b,ee=(u+h)*(-b+x),pe=(-i+a+l)*(y+b-w),oe=(i-l)*(y-w),Ne=(a+l)*(-b+w),ke=s*m,De=l*x,ge=o*p,Xe=c*d,Oe=h*w,it=I+G+ke,Ge=_+A+M+I+B+G+ee,pt=I+N+R+D+G+pe+Ne,ut=C+k+A+I+G+pe+oe,Ve=C+A+M+I+De,ze=G+pe+oe+Ne+ge,Be=I+N+O+z+B+X+G,ht=B+X+G+ee+Xe,Ke=I+N+O+R+Oe;return t.set(0,0,it),t.set(0,1,Ge),t.set(0,2,pt),t.set(1,0,ut),t.set(1,1,Ve),t.set(1,2,ze),t.set(2,0,Be),t.set(2,1,ht),t.set(2,2,Ke),t}mmulStrassen(e){e=Wt.checkMatrix(e);let t=this.clone(),r=t.rows,s=t.columns,i=e.rows,o=e.columns;s!==i&&console.warn(`Multiplying ${r} x ${s} and ${i} x ${o} matrix: dimensions do not match.`);function a(h,f,d){let p=h.rows,m=h.columns;if(p===f&&m===d)return h;{let g=Hn.zeros(f,d);return g=g.setSubMatrix(h,0,0),g}}let l=Math.max(r,i),c=Math.max(s,o);t=a(t,l,c),e=a(e,l,c);function u(h,f,d,p){if(d<=512||p<=512)return h.mmul(f);d%2===1&&p%2===1?(h=a(h,d+1,p+1),f=a(f,d+1,p+1)):d%2===1?(h=a(h,d+1,p),f=a(f,d+1,p)):p%2===1&&(h=a(h,d,p+1),f=a(f,d,p+1));let m=parseInt(h.rows/2,10),g=parseInt(h.columns/2,10),y=h.subMatrix(0,m-1,0,g-1),b=f.subMatrix(0,m-1,0,g-1),x=h.subMatrix(0,m-1,g,h.columns-1),w=f.subMatrix(0,m-1,g,f.columns-1),_=h.subMatrix(m,h.rows-1,0,g-1),C=f.subMatrix(m,f.rows-1,0,g-1),k=h.subMatrix(m,h.rows-1,g,h.columns-1),A=f.subMatrix(m,f.rows-1,g,f.columns-1),M=u(Hn.add(y,k),Hn.add(b,A),m,g),I=u(Hn.add(_,k),b,m,g),N=u(y,Hn.sub(w,A),m,g),O=u(k,Hn.sub(C,b),m,g),R=u(Hn.add(y,x),A,m,g),D=u(Hn.sub(_,y),Hn.add(b,w),m,g),z=u(Hn.sub(x,k),Hn.add(C,A),m,g),B=Hn.add(M,O);B.sub(R),B.add(z);let X=Hn.add(N,R),G=Hn.add(I,O),ee=Hn.sub(M,I);ee.add(N),ee.add(D);let pe=Hn.zeros(2*B.rows,2*B.columns);return pe=pe.setSubMatrix(B,0,0),pe=pe.setSubMatrix(X,B.rows,0),pe=pe.setSubMatrix(G,0,B.columns),pe=pe.setSubMatrix(ee,B.rows,B.columns),pe.subMatrix(0,d-1,0,p-1)}return u(t,e,l,c)}scaleRows(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let s=new Wt(this.rows,this.columns);for(let i=0;i<this.rows;i++){const o=this.getRow(i);o.length>0&&vj(o,{min:t,max:r,output:o}),s.setRow(i,o)}return s}scaleColumns(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let s=new Wt(this.rows,this.columns);for(let i=0;i<this.columns;i++){const o=this.getColumn(i);o.length&&vj(o,{min:t,max:r,output:o}),s.setColumn(i,o)}return s}flipRows(){const e=Math.ceil(this.columns/2);for(let t=0;t<this.rows;t++)for(let r=0;r<e;r++){let s=this.get(t,r),i=this.get(t,this.columns-1-r);this.set(t,r,i),this.set(t,this.columns-1-r,s)}return this}flipColumns(){const e=Math.ceil(this.rows/2);for(let t=0;t<this.columns;t++)for(let r=0;r<e;r++){let s=this.get(r,t),i=this.get(this.rows-1-r,t);this.set(r,t,i),this.set(this.rows-1-r,t,s)}return this}kroneckerProduct(e){e=Wt.checkMatrix(e);let t=this.rows,r=this.columns,s=e.rows,i=e.columns,o=new Wt(t*s,r*i);for(let a=0;a<t;a++)for(let l=0;l<r;l++)for(let c=0;c<s;c++)for(let u=0;u<i;u++)o.set(s*a+c,i*l+u,this.get(a,l)*e.get(c,u));return o}kroneckerSum(e){if(e=Wt.checkMatrix(e),!this.isSquare()||!e.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let t=this.rows,r=e.rows,s=this.kroneckerProduct(Wt.eye(r,r)),i=Wt.eye(t,t).kroneckerProduct(e);return s.add(i)}transpose(){let e=new Wt(this.columns,this.rows);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(r,t,this.get(t,r));return e}sortRows(e=xj){for(let t=0;t<this.rows;t++)this.setRow(t,this.getRow(t).sort(e));return this}sortColumns(e=xj){for(let t=0;t<this.columns;t++)this.setColumn(t,this.getColumn(t).sort(e));return this}subMatrix(e,t,r,s){dF(this,e,t,r,s);let i=new Wt(t-e+1,s-r+1);for(let o=e;o<=t;o++)for(let a=r;a<=s;a++)i.set(o-e,a-r,this.get(o,a));return i}subMatrixRow(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.columns-1),t>r||t<0||t>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new Wt(e.length,r-t+1);for(let i=0;i<e.length;i++)for(let o=t;o<=r;o++){if(e[i]<0||e[i]>=this.rows)throw new RangeError(`Row index out of range: ${e[i]}`);s.set(i,o-t,this.get(e[i],o))}return s}subMatrixColumn(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.rows-1),t>r||t<0||t>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new Wt(r-t+1,e.length);for(let i=0;i<e.length;i++)for(let o=t;o<=r;o++){if(e[i]<0||e[i]>=this.columns)throw new RangeError(`Column index out of range: ${e[i]}`);s.set(o-t,i,this.get(o,e[i]))}return s}setSubMatrix(e,t,r){if(e=Wt.checkMatrix(e),e.isEmpty())return this;let s=t+e.rows-1,i=r+e.columns-1;dF(this,t,s,r,i);for(let o=0;o<e.rows;o++)for(let a=0;a<e.columns;a++)this.set(t+o,r+a,e.get(o,a));return this}selection(e,t){B4(this,e),V4(this,t);let r=new Wt(e.length,t.length);for(let s=0;s<e.length;s++){let i=e[s];for(let o=0;o<t.length;o++){let a=t[o];r.set(s,o,this.get(i,a))}}return r}trace(){let e=Math.min(this.rows,this.columns),t=0;for(let r=0;r<e;r++)t+=this.get(r,r);return t}clone(){let e=new Wt(this.rows,this.columns);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(t,r,this.get(t,r));return e}sum(e){switch(e){case"row":return Aut(this);case"column":return Mut(this);case void 0:return Nut(this);default:throw new Error(`invalid option: ${e}`)}}product(e){switch(e){case"row":return $ut(this);case"column":return Rut(this);case void 0:return Put(this);default:throw new Error(`invalid option: ${e}`)}}mean(e){const t=this.sum(e);switch(e){case"row":{for(let r=0;r<this.rows;r++)t[r]/=this.columns;return t}case"column":{for(let r=0;r<this.columns;r++)t[r]/=this.rows;return t}case void 0:return t/this.size;default:throw new Error(`invalid option: ${e}`)}}variance(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(e)}=t;if(typeof r!="boolean")throw new TypeError("unbiased must be a boolean");switch(e){case"row":{if(!La.isAnyArray(s))throw new TypeError("mean must be an array");return Dut(this,r,s)}case"column":{if(!La.isAnyArray(s))throw new TypeError("mean must be an array");return Out(this,r,s)}case void 0:{if(typeof s!="number")throw new TypeError("mean must be a number");return Fut(this,r,s)}default:throw new Error(`invalid option: ${e}`)}}standardDeviation(e,t){typeof e=="object"&&(t=e,e=void 0);const r=this.variance(e,t);if(e===void 0)return Math.sqrt(r);for(let s=0;s<r.length;s++)r[s]=Math.sqrt(r[s]);return r}center(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{center:r=this.mean(e)}=t;switch(e){case"row":{if(!La.isAnyArray(r))throw new TypeError("center must be an array");return Lut(this,r),this}case"column":{if(!La.isAnyArray(r))throw new TypeError("center must be an array");return zut(this,r),this}case void 0:{if(typeof r!="number")throw new TypeError("center must be a number");return But(this,r),this}default:throw new Error(`invalid option: ${e}`)}}scale(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");let r=t.scale;switch(e){case"row":{if(r===void 0)r=Vut(this);else if(!La.isAnyArray(r))throw new TypeError("scale must be an array");return Uut(this,r),this}case"column":{if(r===void 0)r=Wut(this);else if(!La.isAnyArray(r))throw new TypeError("scale must be an array");return Gut(this,r),this}case void 0:{if(r===void 0)r=Hut(this);else if(typeof r!="number")throw new TypeError("scale must be a number");return jut(this,r),this}default:throw new Error(`invalid option: ${e}`)}}toString(e){return Gie(this,e)}}Hn.prototype.klass="Matrix";typeof Symbol<"u"&&(Hn.prototype[Symbol.for("nodejs.util.inspect.custom")]=kut);function xj(n,e){return n-e}function qut(n){return n.every(e=>typeof e=="number")}Hn.random=Hn.rand;Hn.randomInt=Hn.randInt;Hn.diagonal=Hn.diag;Hn.prototype.diagonal=Hn.prototype.diag;Hn.identity=Hn.eye;Hn.prototype.negate=Hn.prototype.neg;Hn.prototype.tensorProduct=Hn.prototype.kroneckerProduct;let Wt=class Hie extends Hn{constructor(e,t){if(super(),Hie.isMatrix(e))return e.clone();if(Number.isInteger(e)&&e>=0)if(this.data=[],Number.isInteger(t)&&t>=0)for(let r=0;r<e;r++)this.data.push(new Float64Array(t));else throw new TypeError("nColumns must be a positive integer");else if(La.isAnyArray(e)){const r=e;if(e=r.length,t=e?r[0].length:0,typeof t!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<e;s++){if(r[s].length!==t)throw new RangeError("Inconsistent array dimensions");if(!qut(r[s]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(r[s]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=e,this.columns=t}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}removeRow(e){return ac(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,t){return t===void 0&&(t=e,e=this.rows),ac(this,e,!0),t=Float64Array.from(hb(this,t)),this.data.splice(e,0,t),this.rows+=1,this}removeColumn(e){lc(this,e);for(let t=0;t<this.rows;t++){const r=new Float64Array(this.columns-1);for(let s=0;s<e;s++)r[s]=this.data[t][s];for(let s=e+1;s<this.columns;s++)r[s-1]=this.data[t][s];this.data[t]=r}return this.columns-=1,this}addColumn(e,t){typeof t>"u"&&(t=e,e=this.columns),lc(this,e,!0),t=fb(this,t);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let i=0;for(;i<e;i++)s[i]=this.data[r][i];for(s[i++]=t[r];i<this.columns+1;i++)s[i]=this.data[r][i-1];this.data[r]=s}return this.columns+=1,this}};Iut(Hn,Wt);class Xf extends Hn{constructor(e,t,r){super(),this.matrix=e,this.rows=t,this.columns=r}}class Xut extends Xf{constructor(e,t){lc(e,t),super(e,e.rows,1),this.column=t}set(e,t,r){return this.matrix.set(e,this.column,r),this}get(e){return this.matrix.get(e,this.column)}}class Kut extends Xf{constructor(e,t){V4(e,t),super(e,e.rows,t.length),this.columnIndices=t}set(e,t,r){return this.matrix.set(e,this.columnIndices[t],r),this}get(e,t){return this.matrix.get(e,this.columnIndices[t])}}class Yut extends Xf{constructor(e){super(e,e.rows,e.columns)}set(e,t,r){return this.matrix.set(e,this.columns-t-1,r),this}get(e,t){return this.matrix.get(e,this.columns-t-1)}}class Zut extends Xf{constructor(e){super(e,e.rows,e.columns)}set(e,t,r){return this.matrix.set(this.rows-e-1,t,r),this}get(e,t){return this.matrix.get(this.rows-e-1,t)}}class Jut extends Xf{constructor(e,t){ac(e,t),super(e,1,e.columns),this.row=t}set(e,t,r){return this.matrix.set(this.row,t,r),this}get(e,t){return this.matrix.get(this.row,t)}}class Qut extends Xf{constructor(e,t){B4(e,t),super(e,t.length,e.columns),this.rowIndices=t}set(e,t,r){return this.matrix.set(this.rowIndices[e],t,r),this}get(e,t){return this.matrix.get(this.rowIndices[e],t)}}class ZE extends Xf{constructor(e,t,r){B4(e,t),V4(e,r),super(e,t.length,r.length),this.rowIndices=t,this.columnIndices=r}set(e,t,r){return this.matrix.set(this.rowIndices[e],this.columnIndices[t],r),this}get(e,t){return this.matrix.get(this.rowIndices[e],this.columnIndices[t])}}class eht extends Xf{constructor(e,t,r,s,i){dF(e,t,r,s,i),super(e,r-t+1,i-s+1),this.startRow=t,this.startColumn=s}set(e,t,r){return this.matrix.set(this.startRow+e,this.startColumn+t,r),this}get(e,t){return this.matrix.get(this.startRow+e,this.startColumn+t)}}class tht extends Xf{constructor(e){super(e,e.columns,e.rows)}set(e,t,r){return this.matrix.set(t,e,r),this}get(e,t){return this.matrix.get(t,e)}}class jie extends Hn{constructor(e,t={}){const{rows:r=1}=t;if(e.length%r!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=e.length/r,this.data=e}set(e,t,r){let s=this._calculateIndex(e,t);return this.data[s]=r,this}get(e,t){let r=this._calculateIndex(e,t);return this.data[r]}_calculateIndex(e,t){return e*this.columns+t}}class Dl extends Hn{constructor(e){super(),this.data=e,this.rows=e.length,this.columns=e[0].length}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}}function nht(n,e){if(La.isAnyArray(n))return n[0]&&La.isAnyArray(n[0])?new Dl(n):new jie(n,e);throw new Error("the argument is not an array")}class k${constructor(e){e=Dl.checkMatrix(e);let t=e.clone(),r=t.rows,s=t.columns,i=new Float64Array(r),o=1,a,l,c,u,h,f,d,p,m;for(a=0;a<r;a++)i[a]=a;for(p=new Float64Array(r),l=0;l<s;l++){for(a=0;a<r;a++)p[a]=t.get(a,l);for(a=0;a<r;a++){for(m=Math.min(a,l),h=0,c=0;c<m;c++)h+=t.get(a,c)*p[c];p[a]-=h,t.set(a,l,p[a])}for(u=l,a=l+1;a<r;a++)Math.abs(p[a])>Math.abs(p[u])&&(u=a);if(u!==l){for(c=0;c<s;c++)f=t.get(u,c),t.set(u,c,t.get(l,c)),t.set(l,c,f);d=i[u],i[u]=i[l],i[l]=d,o=-o}if(l<r&&t.get(l,l)!==0)for(a=l+1;a<r;a++)t.set(a,l,t.get(a,l)/t.get(l,l))}this.LU=t,this.pivotVector=i,this.pivotSign=o}isSingular(){let e=this.LU,t=e.columns;for(let r=0;r<t;r++)if(e.get(r,r)===0)return!0;return!1}solve(e){e=Wt.checkMatrix(e);let t=this.LU;if(t.rows!==e.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let s=e.columns,i=e.subMatrixRow(this.pivotVector,0,s-1),o=t.columns,a,l,c;for(c=0;c<o;c++)for(a=c+1;a<o;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c));for(c=o-1;c>=0;c--){for(l=0;l<s;l++)i.set(c,l,i.get(c,l)/t.get(c,c));for(a=0;a<c;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c))}return i}get determinant(){let e=this.LU;if(!e.isSquare())throw new Error("Matrix must be square");let t=this.pivotSign,r=e.columns;for(let s=0;s<r;s++)t*=e.get(s,s);return t}get lowerTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,s=new Wt(t,r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)i>o?s.set(i,o,e.get(i,o)):i===o?s.set(i,o,1):s.set(i,o,0);return s}get upperTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,s=new Wt(t,r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)i<=o?s.set(i,o,e.get(i,o)):s.set(i,o,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function xf(n,e){let t=0;return Math.abs(n)>Math.abs(e)?(t=e/n,Math.abs(n)*Math.sqrt(1+t*t)):e!==0?(t=n/e,Math.abs(e)*Math.sqrt(1+t*t)):0}class U4{constructor(e){e=Dl.checkMatrix(e);let t=e.clone(),r=e.rows,s=e.columns,i=new Float64Array(s),o,a,l,c;for(l=0;l<s;l++){let u=0;for(o=l;o<r;o++)u=xf(u,t.get(o,l));if(u!==0){for(t.get(l,l)<0&&(u=-u),o=l;o<r;o++)t.set(o,l,t.get(o,l)/u);for(t.set(l,l,t.get(l,l)+1),a=l+1;a<s;a++){for(c=0,o=l;o<r;o++)c+=t.get(o,l)*t.get(o,a);for(c=-c/t.get(l,l),o=l;o<r;o++)t.set(o,a,t.get(o,a)+c*t.get(o,l))}}i[l]=-u}this.QR=t,this.Rdiag=i}solve(e){e=Wt.checkMatrix(e);let t=this.QR,r=t.rows;if(e.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s=e.columns,i=e.clone(),o=t.columns,a,l,c,u;for(c=0;c<o;c++)for(l=0;l<s;l++){for(u=0,a=c;a<r;a++)u+=t.get(a,c)*i.get(a,l);for(u=-u/t.get(c,c),a=c;a<r;a++)i.set(a,l,i.get(a,l)+u*t.get(a,c))}for(c=o-1;c>=0;c--){for(l=0;l<s;l++)i.set(c,l,i.get(c,l)/this.Rdiag[c]);for(a=0;a<c;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c))}return i.subMatrix(0,o-1,0,s-1)}isFullRank(){let e=this.QR.columns;for(let t=0;t<e;t++)if(this.Rdiag[t]===0)return!1;return!0}get upperTriangularMatrix(){let e=this.QR,t=e.columns,r=new Wt(t,t),s,i;for(s=0;s<t;s++)for(i=0;i<t;i++)s<i?r.set(s,i,e.get(s,i)):s===i?r.set(s,i,this.Rdiag[s]):r.set(s,i,0);return r}get orthogonalMatrix(){let e=this.QR,t=e.rows,r=e.columns,s=new Wt(t,r),i,o,a,l;for(a=r-1;a>=0;a--){for(i=0;i<t;i++)s.set(i,a,0);for(s.set(a,a,1),o=a;o<r;o++)if(e.get(a,a)!==0){for(l=0,i=a;i<t;i++)l+=e.get(i,a)*s.get(i,o);for(l=-l/e.get(a,a),i=a;i<t;i++)s.set(i,o,s.get(i,o)+l*e.get(i,a))}}return s}}class Jw{constructor(e,t={}){if(e=Dl.checkMatrix(e),e.isEmpty())throw new Error("Matrix must be non-empty");let r=e.rows,s=e.columns;const{computeLeftSingularVectors:i=!0,computeRightSingularVectors:o=!0,autoTranspose:a=!1}=t;let l=!!i,c=!!o,u=!1,h;if(r<s)if(!a)h=e.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{h=e.transpose(),r=h.rows,s=h.columns,u=!0;let I=l;l=c,c=I}else h=e.clone();let f=Math.min(r,s),d=Math.min(r+1,s),p=new Float64Array(d),m=new Wt(r,f),g=new Wt(s,s),y=new Float64Array(s),b=new Float64Array(r),x=new Float64Array(d);for(let I=0;I<d;I++)x[I]=I;let w=Math.min(r-1,s),_=Math.max(0,Math.min(s-2,r)),C=Math.max(w,_);for(let I=0;I<C;I++){if(I<w){p[I]=0;for(let N=I;N<r;N++)p[I]=xf(p[I],h.get(N,I));if(p[I]!==0){h.get(I,I)<0&&(p[I]=-p[I]);for(let N=I;N<r;N++)h.set(N,I,h.get(N,I)/p[I]);h.set(I,I,h.get(I,I)+1)}p[I]=-p[I]}for(let N=I+1;N<s;N++){if(I<w&&p[I]!==0){let O=0;for(let R=I;R<r;R++)O+=h.get(R,I)*h.get(R,N);O=-O/h.get(I,I);for(let R=I;R<r;R++)h.set(R,N,h.get(R,N)+O*h.get(R,I))}y[N]=h.get(I,N)}if(l&&I<w)for(let N=I;N<r;N++)m.set(N,I,h.get(N,I));if(I<_){y[I]=0;for(let N=I+1;N<s;N++)y[I]=xf(y[I],y[N]);if(y[I]!==0){y[I+1]<0&&(y[I]=0-y[I]);for(let N=I+1;N<s;N++)y[N]/=y[I];y[I+1]+=1}if(y[I]=-y[I],I+1<r&&y[I]!==0){for(let N=I+1;N<r;N++)b[N]=0;for(let N=I+1;N<r;N++)for(let O=I+1;O<s;O++)b[N]+=y[O]*h.get(N,O);for(let N=I+1;N<s;N++){let O=-y[N]/y[I+1];for(let R=I+1;R<r;R++)h.set(R,N,h.get(R,N)+O*b[R])}}if(c)for(let N=I+1;N<s;N++)g.set(N,I,y[N])}}let k=Math.min(s,r+1);if(w<s&&(p[w]=h.get(w,w)),r<k&&(p[k-1]=0),_+1<k&&(y[_]=h.get(_,k-1)),y[k-1]=0,l){for(let I=w;I<f;I++){for(let N=0;N<r;N++)m.set(N,I,0);m.set(I,I,1)}for(let I=w-1;I>=0;I--)if(p[I]!==0){for(let N=I+1;N<f;N++){let O=0;for(let R=I;R<r;R++)O+=m.get(R,I)*m.get(R,N);O=-O/m.get(I,I);for(let R=I;R<r;R++)m.set(R,N,m.get(R,N)+O*m.get(R,I))}for(let N=I;N<r;N++)m.set(N,I,-m.get(N,I));m.set(I,I,1+m.get(I,I));for(let N=0;N<I-1;N++)m.set(N,I,0)}else{for(let N=0;N<r;N++)m.set(N,I,0);m.set(I,I,1)}}if(c)for(let I=s-1;I>=0;I--){if(I<_&&y[I]!==0)for(let N=I+1;N<s;N++){let O=0;for(let R=I+1;R<s;R++)O+=g.get(R,I)*g.get(R,N);O=-O/g.get(I+1,I);for(let R=I+1;R<s;R++)g.set(R,N,g.get(R,N)+O*g.get(R,I))}for(let N=0;N<s;N++)g.set(N,I,0);g.set(I,I,1)}let A=k-1,M=Number.EPSILON;for(;k>0;){let I,N;for(I=k-2;I>=-1&&I!==-1;I--){const O=Number.MIN_VALUE+M*Math.abs(p[I]+Math.abs(p[I+1]));if(Math.abs(y[I])<=O||Number.isNaN(y[I])){y[I]=0;break}}if(I===k-2)N=4;else{let O;for(O=k-1;O>=I&&O!==I;O--){let R=(O!==k?Math.abs(y[O]):0)+(O!==I+1?Math.abs(y[O-1]):0);if(Math.abs(p[O])<=M*R){p[O]=0;break}}O===I?N=3:O===k-1?N=1:(N=2,I=O)}switch(I++,N){case 1:{let O=y[k-2];y[k-2]=0;for(let R=k-2;R>=I;R--){let D=xf(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,R!==I&&(O=-B*y[R-1],y[R-1]=z*y[R-1]),c)for(let X=0;X<s;X++)D=z*g.get(X,R)+B*g.get(X,k-1),g.set(X,k-1,-B*g.get(X,R)+z*g.get(X,k-1)),g.set(X,R,D)}break}case 2:{let O=y[I-1];y[I-1]=0;for(let R=I;R<k;R++){let D=xf(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,O=-B*y[R],y[R]=z*y[R],l)for(let X=0;X<r;X++)D=z*m.get(X,R)+B*m.get(X,I-1),m.set(X,I-1,-B*m.get(X,R)+z*m.get(X,I-1)),m.set(X,R,D)}break}case 3:{const O=Math.max(Math.abs(p[k-1]),Math.abs(p[k-2]),Math.abs(y[k-2]),Math.abs(p[I]),Math.abs(y[I])),R=p[k-1]/O,D=p[k-2]/O,z=y[k-2]/O,B=p[I]/O,X=y[I]/O,G=((D+R)*(D-R)+z*z)/2,ee=R*z*(R*z);let pe=0;(G!==0||ee!==0)&&(G<0?pe=0-Math.sqrt(G*G+ee):pe=Math.sqrt(G*G+ee),pe=ee/(G+pe));let oe=(B+R)*(B-R)+pe,Ne=B*X;for(let ke=I;ke<k-1;ke++){let De=xf(oe,Ne);De===0&&(De=Number.MIN_VALUE);let ge=oe/De,Xe=Ne/De;if(ke!==I&&(y[ke-1]=De),oe=ge*p[ke]+Xe*y[ke],y[ke]=ge*y[ke]-Xe*p[ke],Ne=Xe*p[ke+1],p[ke+1]=ge*p[ke+1],c)for(let Oe=0;Oe<s;Oe++)De=ge*g.get(Oe,ke)+Xe*g.get(Oe,ke+1),g.set(Oe,ke+1,-Xe*g.get(Oe,ke)+ge*g.get(Oe,ke+1)),g.set(Oe,ke,De);if(De=xf(oe,Ne),De===0&&(De=Number.MIN_VALUE),ge=oe/De,Xe=Ne/De,p[ke]=De,oe=ge*y[ke]+Xe*p[ke+1],p[ke+1]=-Xe*y[ke]+ge*p[ke+1],Ne=Xe*y[ke+1],y[ke+1]=ge*y[ke+1],l&&ke<r-1)for(let Oe=0;Oe<r;Oe++)De=ge*m.get(Oe,ke)+Xe*m.get(Oe,ke+1),m.set(Oe,ke+1,-Xe*m.get(Oe,ke)+ge*m.get(Oe,ke+1)),m.set(Oe,ke,De)}y[k-2]=oe;break}case 4:{if(p[I]<=0&&(p[I]=p[I]<0?-p[I]:0,c))for(let O=0;O<=A;O++)g.set(O,I,-g.get(O,I));for(;I<A&&!(p[I]>=p[I+1]);){let O=p[I];if(p[I]=p[I+1],p[I+1]=O,c&&I<s-1)for(let R=0;R<s;R++)O=g.get(R,I+1),g.set(R,I+1,g.get(R,I)),g.set(R,I,O);if(l&&I<r-1)for(let R=0;R<r;R++)O=m.get(R,I+1),m.set(R,I+1,m.get(R,I)),m.set(R,I,O);I++}k--;break}}}if(u){let I=g;g=m,m=I}this.m=r,this.n=s,this.s=p,this.U=m,this.V=g}solve(e){let t=e,r=this.threshold,s=this.s.length,i=Wt.zeros(s,s);for(let f=0;f<s;f++)Math.abs(this.s[f])<=r?i.set(f,f,0):i.set(f,f,1/this.s[f]);let o=this.U,a=this.rightSingularVectors,l=a.mmul(i),c=a.rows,u=o.rows,h=Wt.zeros(c,u);for(let f=0;f<c;f++)for(let d=0;d<u;d++){let p=0;for(let m=0;m<s;m++)p+=l.get(f,m)*o.get(d,m);h.set(f,d,p)}return h.mmul(t)}solveForDiagonal(e){return this.solve(Wt.diag(e))}inverse(){let e=this.V,t=this.threshold,r=e.rows,s=e.columns,i=new Wt(r,this.s.length);for(let u=0;u<r;u++)for(let h=0;h<s;h++)Math.abs(this.s[h])>t&&i.set(u,h,e.get(u,h)/this.s[h]);let o=this.U,a=o.rows,l=o.columns,c=new Wt(r,a);for(let u=0;u<r;u++)for(let h=0;h<a;h++){let f=0;for(let d=0;d<l;d++)f+=i.get(u,d)*o.get(h,d);c.set(u,h,f)}return c}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let e=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,t=0,r=this.s;for(let s=0,i=r.length;s<i;s++)r[s]>e&&t++;return t}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Wt.diag(this.s)}}function rht(n,e=!1){return n=Dl.checkMatrix(n),e?new Jw(n).inverse():qie(n,Wt.eye(n.rows))}function qie(n,e,t=!1){return n=Dl.checkMatrix(n),e=Dl.checkMatrix(e),t?new Jw(n).solve(e):n.isSquare()?new k$(n).solve(e):new U4(n).solve(e)}function JE(n){if(n=Wt.checkMatrix(n),n.isSquare()){if(n.columns===0)return 1;let e,t,r,s;if(n.columns===2)return e=n.get(0,0),t=n.get(0,1),r=n.get(1,0),s=n.get(1,1),e*s-t*r;if(n.columns===3){let i,o,a;return i=new ZE(n,[1,2],[1,2]),o=new ZE(n,[1,2],[0,2]),a=new ZE(n,[1,2],[0,1]),e=n.get(0,0),t=n.get(0,1),r=n.get(0,2),e*JE(i)-t*JE(o)+r*JE(a)}else return new k$(n).determinant}else throw Error("determinant can only be calculated for a square matrix")}function sht(n,e){let t=[];for(let r=0;r<n;r++)r!==e&&t.push(r);return t}function iht(n,e,t,r=1e-9,s=1e-9){if(n>s)return new Array(e.rows+1).fill(0);{let i=e.addRow(t,[0]);for(let o=0;o<i.rows;o++)Math.abs(i.get(o,0))<r&&i.set(o,0,0);return i.to1DArray()}}function oht(n,e={}){const{thresholdValue:t=1e-9,thresholdError:r=1e-9}=e;n=Wt.checkMatrix(n);let s=n.rows,i=new Wt(s,s);for(let o=0;o<s;o++){let a=Wt.columnVector(n.getRow(o)),l=n.subMatrixRow(sht(s,o)).transpose(),u=new Jw(l).solve(a),h=Wt.sub(a,l.mmul(u)).abs().max();i.setRow(o,iht(h,u,o,t,r))}return i}function aht(n,e=Number.EPSILON){if(n=Wt.checkMatrix(n),n.isEmpty())return n.transpose();let t=new Jw(n,{autoTranspose:!0}),r=t.leftSingularVectors,s=t.rightSingularVectors,i=t.diagonal;for(let o=0;o<i.length;o++)Math.abs(i[o])>e?i[o]=1/i[o]:i[o]=0;return s.mmul(Wt.diag(i).mmul(r.transpose()))}function lht(n,e=n,t={}){n=new Wt(n);let r=!1;if(typeof e=="object"&&!Wt.isMatrix(e)&&!La.isAnyArray(e)?(t=e,e=n,r=!0):e=new Wt(e),n.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0}=t;s&&(n=n.center("column"),r||(e=e.center("column")));const i=n.transpose().mmul(e);for(let o=0;o<i.rows;o++)for(let a=0;a<i.columns;a++)i.set(o,a,i.get(o,a)*(1/(n.rows-1)));return i}function cht(n,e=n,t={}){n=new Wt(n);let r=!1;if(typeof e=="object"&&!Wt.isMatrix(e)&&!La.isAnyArray(e)?(t=e,e=n,r=!0):e=new Wt(e),n.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0,scale:i=!0}=t;s&&(n.center("column"),r||e.center("column")),i&&(n.scale("column"),r||e.scale("column"));const o=n.standardDeviation("column",{unbiased:!0}),a=r?o:e.standardDeviation("column",{unbiased:!0}),l=n.transpose().mmul(e);for(let c=0;c<l.rows;c++)for(let u=0;u<l.columns;u++)l.set(c,u,l.get(c,u)*(1/(o[c]*a[u]))*(1/(n.rows-1)));return l}class Xie{constructor(e,t={}){const{assumeSymmetric:r=!1}=t;if(e=Dl.checkMatrix(e),!e.isSquare())throw new Error("Matrix is not a square matrix");if(e.isEmpty())throw new Error("Matrix must be non-empty");let s=e.columns,i=new Wt(s,s),o=new Float64Array(s),a=new Float64Array(s),l=e,c,u,h=!1;if(r?h=!0:h=e.isSymmetric(),h){for(c=0;c<s;c++)for(u=0;u<s;u++)i.set(c,u,l.get(c,u));uht(s,a,o,i),hht(s,a,o,i)}else{let f=new Wt(s,s),d=new Float64Array(s);for(u=0;u<s;u++)for(c=0;c<s;c++)f.set(c,u,l.get(c,u));fht(s,f,d,i),dht(s,a,o,i,f)}this.n=s,this.e=a,this.d=o,this.V=i}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let e=this.n,t=this.e,r=this.d,s=new Wt(e,e),i,o;for(i=0;i<e;i++){for(o=0;o<e;o++)s.set(i,o,0);s.set(i,i,r[i]),t[i]>0?s.set(i,i+1,t[i]):t[i]<0&&s.set(i,i-1,t[i])}return s}}function uht(n,e,t,r){let s,i,o,a,l,c,u,h;for(l=0;l<n;l++)t[l]=r.get(n-1,l);for(a=n-1;a>0;a--){for(h=0,o=0,c=0;c<a;c++)h=h+Math.abs(t[c]);if(h===0)for(e[a]=t[a-1],l=0;l<a;l++)t[l]=r.get(a-1,l),r.set(a,l,0),r.set(l,a,0);else{for(c=0;c<a;c++)t[c]/=h,o+=t[c]*t[c];for(s=t[a-1],i=Math.sqrt(o),s>0&&(i=-i),e[a]=h*i,o=o-s*i,t[a-1]=s-i,l=0;l<a;l++)e[l]=0;for(l=0;l<a;l++){for(s=t[l],r.set(l,a,s),i=e[l]+r.get(l,l)*s,c=l+1;c<=a-1;c++)i+=r.get(c,l)*t[c],e[c]+=r.get(c,l)*s;e[l]=i}for(s=0,l=0;l<a;l++)e[l]/=o,s+=e[l]*t[l];for(u=s/(o+o),l=0;l<a;l++)e[l]-=u*t[l];for(l=0;l<a;l++){for(s=t[l],i=e[l],c=l;c<=a-1;c++)r.set(c,l,r.get(c,l)-(s*e[c]+i*t[c]));t[l]=r.get(a-1,l),r.set(a,l,0)}}t[a]=o}for(a=0;a<n-1;a++){if(r.set(n-1,a,r.get(a,a)),r.set(a,a,1),o=t[a+1],o!==0){for(c=0;c<=a;c++)t[c]=r.get(c,a+1)/o;for(l=0;l<=a;l++){for(i=0,c=0;c<=a;c++)i+=r.get(c,a+1)*r.get(c,l);for(c=0;c<=a;c++)r.set(c,l,r.get(c,l)-i*t[c])}}for(c=0;c<=a;c++)r.set(c,a+1,0)}for(l=0;l<n;l++)t[l]=r.get(n-1,l),r.set(n-1,l,0);r.set(n-1,n-1,1),e[0]=0}function hht(n,e,t,r){let s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x;for(o=1;o<n;o++)e[o-1]=e[o];e[n-1]=0;let w=0,_=0,C=Number.EPSILON;for(c=0;c<n;c++){for(_=Math.max(_,Math.abs(t[c])+Math.abs(e[c])),u=c;u<n&&!(Math.abs(e[u])<=C*_);)u++;if(u>c)do{for(s=t[c],h=(t[c+1]-s)/(2*e[c]),f=xf(h,1),h<0&&(f=-f),t[c]=e[c]/(h+f),t[c+1]=e[c]*(h+f),d=t[c+1],i=s-t[c],o=c+2;o<n;o++)t[o]-=i;for(w=w+i,h=t[u],p=1,m=p,g=p,y=e[c+1],b=0,x=0,o=u-1;o>=c;o--)for(g=m,m=p,x=b,s=p*e[o],i=p*h,f=xf(h,e[o]),e[o+1]=b*f,b=e[o]/f,p=h/f,h=p*t[o]-b*s,t[o+1]=i+b*(p*s+b*t[o]),l=0;l<n;l++)i=r.get(l,o+1),r.set(l,o+1,b*r.get(l,o)+p*i),r.set(l,o,p*r.get(l,o)-b*i);h=-b*x*g*y*e[c]/d,e[c]=b*h,t[c]=p*h}while(Math.abs(e[c])>C*_);t[c]=t[c]+w,e[c]=0}for(o=0;o<n-1;o++){for(l=o,h=t[o],a=o+1;a<n;a++)t[a]<h&&(l=a,h=t[a]);if(l!==o)for(t[l]=t[o],t[o]=h,a=0;a<n;a++)h=r.get(a,o),r.set(a,o,r.get(a,l)),r.set(a,l,h)}}function fht(n,e,t,r){let s=0,i=n-1,o,a,l,c,u,h,f;for(h=s+1;h<=i-1;h++){for(f=0,c=h;c<=i;c++)f=f+Math.abs(e.get(c,h-1));if(f!==0){for(l=0,c=i;c>=h;c--)t[c]=e.get(c,h-1)/f,l+=t[c]*t[c];for(a=Math.sqrt(l),t[h]>0&&(a=-a),l=l-t[h]*a,t[h]=t[h]-a,u=h;u<n;u++){for(o=0,c=i;c>=h;c--)o+=t[c]*e.get(c,u);for(o=o/l,c=h;c<=i;c++)e.set(c,u,e.get(c,u)-o*t[c])}for(c=0;c<=i;c++){for(o=0,u=i;u>=h;u--)o+=t[u]*e.get(c,u);for(o=o/l,u=h;u<=i;u++)e.set(c,u,e.get(c,u)-o*t[u])}t[h]=f*t[h],e.set(h,h-1,f*a)}}for(c=0;c<n;c++)for(u=0;u<n;u++)r.set(c,u,c===u?1:0);for(h=i-1;h>=s+1;h--)if(e.get(h,h-1)!==0){for(c=h+1;c<=i;c++)t[c]=e.get(c,h-1);for(u=h;u<=i;u++){for(a=0,c=h;c<=i;c++)a+=t[c]*r.get(c,u);for(a=a/t[h]/e.get(h,h-1),c=h;c<=i;c++)r.set(c,u,r.get(c,u)+a*t[c])}}}function dht(n,e,t,r,s){let i=n-1,o=0,a=n-1,l=Number.EPSILON,c=0,u=0,h=0,f=0,d=0,p=0,m=0,g=0,y,b,x,w,_,C,k,A,M,I,N,O,R,D,z;for(y=0;y<n;y++)for((y<o||y>a)&&(t[y]=s.get(y,y),e[y]=0),b=Math.max(y-1,0);b<n;b++)u=u+Math.abs(s.get(y,b));for(;i>=o;){for(w=i;w>o&&(p=Math.abs(s.get(w-1,w-1))+Math.abs(s.get(w,w)),p===0&&(p=u),!(Math.abs(s.get(w,w-1))<l*p));)w--;if(w===i)s.set(i,i,s.get(i,i)+c),t[i]=s.get(i,i),e[i]=0,i--,g=0;else if(w===i-1){if(k=s.get(i,i-1)*s.get(i-1,i),h=(s.get(i-1,i-1)-s.get(i,i))/2,f=h*h+k,m=Math.sqrt(Math.abs(f)),s.set(i,i,s.get(i,i)+c),s.set(i-1,i-1,s.get(i-1,i-1)+c),A=s.get(i,i),f>=0){for(m=h>=0?h+m:h-m,t[i-1]=A+m,t[i]=t[i-1],m!==0&&(t[i]=A-k/m),e[i-1]=0,e[i]=0,A=s.get(i,i-1),p=Math.abs(A)+Math.abs(m),h=A/p,f=m/p,d=Math.sqrt(h*h+f*f),h=h/d,f=f/d,b=i-1;b<n;b++)m=s.get(i-1,b),s.set(i-1,b,f*m+h*s.get(i,b)),s.set(i,b,f*s.get(i,b)-h*m);for(y=0;y<=i;y++)m=s.get(y,i-1),s.set(y,i-1,f*m+h*s.get(y,i)),s.set(y,i,f*s.get(y,i)-h*m);for(y=o;y<=a;y++)m=r.get(y,i-1),r.set(y,i-1,f*m+h*r.get(y,i)),r.set(y,i,f*r.get(y,i)-h*m)}else t[i-1]=A+h,t[i]=A+h,e[i-1]=m,e[i]=-m;i=i-2,g=0}else{if(A=s.get(i,i),M=0,k=0,w<i&&(M=s.get(i-1,i-1),k=s.get(i,i-1)*s.get(i-1,i)),g===10){for(c+=A,y=o;y<=i;y++)s.set(y,y,s.get(y,y)-A);p=Math.abs(s.get(i,i-1))+Math.abs(s.get(i-1,i-2)),A=M=.75*p,k=-.4375*p*p}if(g===30&&(p=(M-A)/2,p=p*p+k,p>0)){for(p=Math.sqrt(p),M<A&&(p=-p),p=A-k/((M-A)/2+p),y=o;y<=i;y++)s.set(y,y,s.get(y,y)-p);c+=p,A=M=k=.964}for(g=g+1,_=i-2;_>=w&&(m=s.get(_,_),d=A-m,p=M-m,h=(d*p-k)/s.get(_+1,_)+s.get(_,_+1),f=s.get(_+1,_+1)-m-d-p,d=s.get(_+2,_+1),p=Math.abs(h)+Math.abs(f)+Math.abs(d),h=h/p,f=f/p,d=d/p,!(_===w||Math.abs(s.get(_,_-1))*(Math.abs(f)+Math.abs(d))<l*(Math.abs(h)*(Math.abs(s.get(_-1,_-1))+Math.abs(m)+Math.abs(s.get(_+1,_+1))))));)_--;for(y=_+2;y<=i;y++)s.set(y,y-2,0),y>_+2&&s.set(y,y-3,0);for(x=_;x<=i-1&&(D=x!==i-1,x!==_&&(h=s.get(x,x-1),f=s.get(x+1,x-1),d=D?s.get(x+2,x-1):0,A=Math.abs(h)+Math.abs(f)+Math.abs(d),A!==0&&(h=h/A,f=f/A,d=d/A)),A!==0);x++)if(p=Math.sqrt(h*h+f*f+d*d),h<0&&(p=-p),p!==0){for(x!==_?s.set(x,x-1,-p*A):w!==_&&s.set(x,x-1,-s.get(x,x-1)),h=h+p,A=h/p,M=f/p,m=d/p,f=f/h,d=d/h,b=x;b<n;b++)h=s.get(x,b)+f*s.get(x+1,b),D&&(h=h+d*s.get(x+2,b),s.set(x+2,b,s.get(x+2,b)-h*m)),s.set(x,b,s.get(x,b)-h*A),s.set(x+1,b,s.get(x+1,b)-h*M);for(y=0;y<=Math.min(i,x+3);y++)h=A*s.get(y,x)+M*s.get(y,x+1),D&&(h=h+m*s.get(y,x+2),s.set(y,x+2,s.get(y,x+2)-h*d)),s.set(y,x,s.get(y,x)-h),s.set(y,x+1,s.get(y,x+1)-h*f);for(y=o;y<=a;y++)h=A*r.get(y,x)+M*r.get(y,x+1),D&&(h=h+m*r.get(y,x+2),r.set(y,x+2,r.get(y,x+2)-h*d)),r.set(y,x,r.get(y,x)-h),r.set(y,x+1,r.get(y,x+1)-h*f)}}}if(u!==0){for(i=n-1;i>=0;i--)if(h=t[i],f=e[i],f===0)for(w=i,s.set(i,i,1),y=i-1;y>=0;y--){for(k=s.get(y,y)-h,d=0,b=w;b<=i;b++)d=d+s.get(y,b)*s.get(b,i);if(e[y]<0)m=k,p=d;else if(w=y,e[y]===0?s.set(y,i,k!==0?-d/k:-d/(l*u)):(A=s.get(y,y+1),M=s.get(y+1,y),f=(t[y]-h)*(t[y]-h)+e[y]*e[y],C=(A*p-m*d)/f,s.set(y,i,C),s.set(y+1,i,Math.abs(A)>Math.abs(m)?(-d-k*C)/A:(-p-M*C)/m)),C=Math.abs(s.get(y,i)),l*C*C>1)for(b=y;b<=i;b++)s.set(b,i,s.get(b,i)/C)}else if(f<0)for(w=i-1,Math.abs(s.get(i,i-1))>Math.abs(s.get(i-1,i))?(s.set(i-1,i-1,f/s.get(i,i-1)),s.set(i-1,i,-(s.get(i,i)-h)/s.get(i,i-1))):(z=MT(0,-s.get(i-1,i),s.get(i-1,i-1)-h,f),s.set(i-1,i-1,z[0]),s.set(i-1,i,z[1])),s.set(i,i-1,0),s.set(i,i,1),y=i-2;y>=0;y--){for(I=0,N=0,b=w;b<=i;b++)I=I+s.get(y,b)*s.get(b,i-1),N=N+s.get(y,b)*s.get(b,i);if(k=s.get(y,y)-h,e[y]<0)m=k,d=I,p=N;else if(w=y,e[y]===0?(z=MT(-I,-N,k,f),s.set(y,i-1,z[0]),s.set(y,i,z[1])):(A=s.get(y,y+1),M=s.get(y+1,y),O=(t[y]-h)*(t[y]-h)+e[y]*e[y]-f*f,R=(t[y]-h)*2*f,O===0&&R===0&&(O=l*u*(Math.abs(k)+Math.abs(f)+Math.abs(A)+Math.abs(M)+Math.abs(m))),z=MT(A*d-m*I+f*N,A*p-m*N-f*I,O,R),s.set(y,i-1,z[0]),s.set(y,i,z[1]),Math.abs(A)>Math.abs(m)+Math.abs(f)?(s.set(y+1,i-1,(-I-k*s.get(y,i-1)+f*s.get(y,i))/A),s.set(y+1,i,(-N-k*s.get(y,i)-f*s.get(y,i-1))/A)):(z=MT(-d-M*s.get(y,i-1),-p-M*s.get(y,i),m,f),s.set(y+1,i-1,z[0]),s.set(y+1,i,z[1]))),C=Math.max(Math.abs(s.get(y,i-1)),Math.abs(s.get(y,i))),l*C*C>1)for(b=y;b<=i;b++)s.set(b,i-1,s.get(b,i-1)/C),s.set(b,i,s.get(b,i)/C)}for(y=0;y<n;y++)if(y<o||y>a)for(b=y;b<n;b++)r.set(y,b,s.get(y,b));for(b=n-1;b>=o;b--)for(y=o;y<=a;y++){for(m=0,x=o;x<=Math.min(b,a);x++)m=m+r.get(y,x)*s.get(x,b);r.set(y,b,m)}}}function MT(n,e,t,r){let s,i;return Math.abs(t)>Math.abs(r)?(s=r/t,i=t+s*r,[(n+s*e)/i,(e-s*n)/i]):(s=t/r,i=r+s*t,[(s*n+e)/i,(s*e-n)/i])}class Kie{constructor(e){if(e=Dl.checkMatrix(e),!e.isSymmetric())throw new Error("Matrix is not symmetric");let t=e,r=t.rows,s=new Wt(r,r),i=!0,o,a,l;for(a=0;a<r;a++){let c=0;for(l=0;l<a;l++){let u=0;for(o=0;o<l;o++)u+=s.get(l,o)*s.get(a,o);u=(t.get(a,l)-u)/s.get(l,l),s.set(a,l,u),c=c+u*u}for(c=t.get(a,a)-c,i&=c>0,s.set(a,a,Math.sqrt(Math.max(c,0))),l=a+1;l<r;l++)s.set(a,l,0)}this.L=s,this.positiveDefinite=!!i}isPositiveDefinite(){return this.positiveDefinite}solve(e){e=Dl.checkMatrix(e);let t=this.L,r=t.rows;if(e.rows!==r)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let s=e.columns,i=e.clone(),o,a,l;for(l=0;l<r;l++)for(a=0;a<s;a++){for(o=0;o<l;o++)i.set(l,a,i.get(l,a)-i.get(o,a)*t.get(l,o));i.set(l,a,i.get(l,a)/t.get(l,l))}for(l=r-1;l>=0;l--)for(a=0;a<s;a++){for(o=l+1;o<r;o++)i.set(l,a,i.get(l,a)-i.get(o,a)*t.get(o,l));i.set(l,a,i.get(l,a)/t.get(l,l))}return i}get lowerTriangularMatrix(){return this.L}}class Yie{constructor(e,t={}){e=Dl.checkMatrix(e);let{Y:r}=t;const{scaleScores:s=!1,maxIterations:i=1e3,terminationCriteria:o=1e-10}=t;let a;if(r){if(La.isAnyArray(r)&&typeof r[0]=="number"?r=Wt.columnVector(r):r=Dl.checkMatrix(r),r.rows!==e.rows)throw new Error("Y should have the same number of rows as X");a=r.getColumnVector(0)}else a=e.getColumnVector(0);let l=1,c,u,h,f;for(let d=0;d<i&&l>o;d++)h=e.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),h=h.div(h.norm()),c=e.mmul(h).div(h.transpose().mmul(h).get(0,0)),d>0&&(l=c.clone().sub(f).pow(2).sum()),f=c.clone(),r?(u=r.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0)),u=u.div(u.norm()),a=r.mmul(u).div(u.transpose().mmul(u).get(0,0))):a=c;if(r){let d=e.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0));d=d.div(d.norm());let p=e.clone().sub(c.clone().mmul(d.transpose())),m=a.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0)),g=r.clone().sub(c.clone().mulS(m.get(0,0)).mmul(u.transpose()));this.t=c,this.p=d.transpose(),this.w=h.transpose(),this.q=u,this.u=a,this.s=c.transpose().mmul(c),this.xResidual=p,this.yResidual=g,this.betas=m}else this.w=h.transpose(),this.s=c.transpose().mmul(c).sqrt(),s?this.t=c.clone().div(this.s.get(0,0)):this.t=c,this.xResidual=e.sub(c.mmul(h.transpose()))}}lr.AbstractMatrix=Hn;lr.CHO=Kie;lr.CholeskyDecomposition=Kie;lr.EVD=Xie;lr.EigenvalueDecomposition=Xie;lr.LU=k$;lr.LuDecomposition=k$;lr.Matrix=Wt;lr.MatrixColumnSelectionView=Kut;lr.MatrixColumnView=Xut;lr.MatrixFlipColumnView=Yut;lr.MatrixFlipRowView=Zut;lr.MatrixRowSelectionView=Qut;lr.MatrixRowView=Jut;lr.MatrixSelectionView=ZE;lr.MatrixSubView=eht;lr.MatrixTransposeView=tht;lr.NIPALS=Yie;lr.Nipals=Yie;lr.QR=U4;lr.QrDecomposition=U4;lr.SVD=Jw;lr.SingularValueDecomposition=Jw;lr.WrapperMatrix1D=jie;lr.WrapperMatrix2D=Dl;lr.correlation=cht;lr.covariance=lht;lr.default=Wt;lr.determinant=JE;lr.inverse=rht;lr.linearDependencies=oht;lr.pseudoInverse=aht;lr.solve=qie;lr.wrap=nht;const hh=lr.Matrix,pht=lr.inverse;function mht(n,e,t){return new z4(t).choice(n,{size:e})}function ght(n,e,t,r){const s=new z4(r);var i=new Array(e);if(i[0]=Math.floor(s.random()*n.length),e>1){for(var o={dist:-1,index:-1},a=0;a<n.length;++a)t[i[0]][a]>o.dist&&(o.dist=t[i[0]][a],o.index=a);if(i[1]=o.index,e>2)for(var l=2;l<e;++l){for(var c={dist:-1,index:-1},u=0;u<n.length;++u){for(var h={dist:Number.MAX_VALUE,index:-1},f=0;f<l;++f)t[f][u]<h.dist&&i.indexOf(u)===-1&&(h={dist:t[f][u],index:u});h.dist!==Number.MAX_VALUE&&h.dist>c.dist&&(c=Object.assign({},h))}i[l]=c.index}}return i.map(d=>n[d])}function yht(n,e,t={}){n=new hh(n);const r=n.rows,s=new z4(t.seed),i=[],o=t.localTrials||2+Math.floor(Math.log(e)),a=s.randInt(r);i.push(n.getRow(a));let l=new hh(1,n.rows);for(let f=0;f<n.rows;f++)l.set(0,f,_$(n.getRow(f),i[0]));let c=[Sj(l.getRow(0))];const u=1/c[0][r-1];let h=hh.mul(l,u);for(let f=1;f<e;f++){const d=s.choice(r,{replace:!0,size:o,probabilities:h[0]}),p=n.selection(d,vht(n.columns)),m=bht(p,n);let g,y,b;for(let x=0;x<o;x++){const w=hh.min(l,[m.getRow(x)]),_=w.sum();(g===void 0||_<y)&&(g=d[x],y=_,b=w)}i[f]=n.getRow(g),l=b,c=[Sj(l.getRow(0))],h=hh.mul(l,1/c[0][r-1])}return i}function bht(n,e){const t=new hh(n.rows,e.rows);for(let r=0;r<n.rows;r++)for(let s=0;s<e.rows;s++)t.set(r,s,_$(n.getRow(r),e.getRow(s)));return t}function vht(n){let e=[];for(let t=0;t<n;t++)e.push(t);return e}function Sj(n){let e=[n[0]];for(let t=1;t<n.length;t++)e[t]=e[t-1]+n[t];return e}const NT=Symbol("distance");class W4{constructor(e,t,r,s,i){this.clusters=e,this.centroids=t,this.converged=r,this.iterations=s,this[NT]=i}nearest(e){const t=new Array(e.length),r=this.centroids.map(function(s){return s.centroid});return Uie(e,r,t,this[NT])}computeInformation(e){for(var t=this.centroids.map(function(i){return{centroid:i,error:0,size:0}}),r=0;r<e.length;r++)t[this.clusters[r]].error+=this[NT](e[r],this.centroids[this.clusters[r]]),t[this.clusters[r]].size++;for(var s=0;s<this.centroids.length;s++)t[s].size?t[s].error/=t[s].size:t[s].error=null;return new W4(this.clusters,t,this.converged,this.iterations,this[NT])}}const wht={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:_$};function Zie(n,e,t,r,s,i){t=Uie(e,n,t,s.distanceFunction);var o=out(n,e,t,r),a=aut(o,n,s.distanceFunction,s.tolerance);return new W4(t,o,a,i,s.distanceFunction)}function*xht(n,e,t,r,s){for(var i=!1,o=0,a;!i&&o<s.maxIterations;)a=Zie(n,e,t,r,s,++o),yield a.computeInformation(e),i=a.converged,n=a.centroids}function Sht(n,e,t){if(t=Object.assign({},wht,t),e<=0||e>n.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var r;if(Array.isArray(t.initialization)){if(t.initialization.length!==e)throw new Error("The initial centers should have the same length as K");r=t.initialization}else switch(t.initialization){case"kmeans++":r=yht(n,e,t);break;case"random":r=mht(n,e,t.seed);break;case"mostDistant":r=ght(n,e,iut(n,t.distanceFunction),t.seed);break;default:throw new Error(`Unknown initialization method: "${t.initialization}"`)}t.maxIterations===0&&(t.maxIterations=Number.MAX_VALUE);var s=new Array(n.length);if(t.withIterations)return xht(r,n,s,e,t);for(var i=!1,o=0,a;!i&&o<t.maxIterations;)a=Zie(r,n,s,e,t,++o),i=a.converged,r=a.centroids;return a.computeInformation(n)}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    *//*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function _ht(n,e,t,r){function s(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(h){o(h)}}function l(u){try{c(r.throw(u))}catch(h){o(h)}}function c(u){u.done?i(u.value):s(u.value).then(a,l)}c((r=r.apply(n,e||[])).next())})}function Cht(n,e){var t={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},r,s,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(i=c[0]&2?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,s=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(i=t.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){t.label=c[1];break}if(c[0]===6&&t.label<i[1]){t.label=i[1],i=c;break}if(i&&t.label<i[2]){t.label=i[2],t.ops.push(c);break}i[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],s=0}finally{r=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kht(n,e){return n==null&&e==null?null:n==null?e.clone():e===null?n.clone():cs([n,e],0)}function Tht(n,e){for(var t=[],r=0;r<n.length;r++)t.push({value:n[r],index:r});t.sort(function(o,a){return a.value-o.value});for(var s=new Float32Array(e),i=new Int32Array(e),r=0;r<e;r++)s[r]=t[r].value,i[r]=t[r].index;return{values:s,indices:i}}var Eht=function(){function n(){this.classDatasetMatrices={},this.classExampleCount={},this.labelToClassId={},this.nextClassId=0}return n.prototype.addExample=function(e,t){var r=this;if(this.exampleShape==null&&(this.exampleShape=e.shape),!Mn(this.exampleShape,e.shape))throw new Error("Example shape provided, ".concat(e.shape," does not match ")+"previously provided example shapes ".concat(this.exampleShape,"."));this.clearTrainDatasetMatrix(),t in this.labelToClassId||(this.labelToClassId[t]=this.nextClassId++),Se(function(){var s=r.normalizeVectorToUnitLength(ve(e,[e.size])),i=s.shape[0];if(r.classDatasetMatrices[t]==null)r.classDatasetMatrices[t]=ve(s,[1,i]);else{var o=cs([ve(r.classDatasetMatrices[t],[r.classExampleCount[t],i]),ve(s,[1,i])],0);r.classDatasetMatrices[t].dispose(),r.classDatasetMatrices[t]=o}qs(r.classDatasetMatrices[t]),r.classExampleCount[t]==null&&(r.classExampleCount[t]=0),r.classExampleCount[t]++})},n.prototype.similarities=function(e){var t=this;return Se(function(){var r=t.normalizeVectorToUnitLength(ve(e,[e.size])),s=r.shape[0];if(t.trainDatasetMatrix==null){var i=null;for(var o in t.classDatasetMatrices)i=kht(i,t.classDatasetMatrices[o]);t.trainDatasetMatrix=i}if(t.trainDatasetMatrix==null)return console.warn("Cannot predict without providing training examples."),null;qs(t.trainDatasetMatrix);var a=t.getNumExamples();return ve(jn(ve(t.trainDatasetMatrix,[a,s]),ve(r,[s,1])),[a])})},n.prototype.predictClass=function(e,t){return t===void 0&&(t=3),_ht(this,void 0,void 0,function(){var r,s,i,o,a=this;return Cht(this,function(l){switch(l.label){case 0:if(t<1)throw new Error("Please provide a positive integer k value to predictClass.");if(this.getNumExamples()===0)throw new Error("You have not added any examples to the KNN classifier. Please add examples before calling predictClass.");return r=Se(function(){return xt(a.similarities(e),"float32")}),s=Math.min(t,this.getNumExamples()),o=Tht,[4,r.data()];case 1:return i=o.apply(void 0,[l.sent(),s]).indices,r.dispose(),[2,this.calculateTopClass(i,s)]}})})},n.prototype.clearClass=function(e){if(this.classDatasetMatrices[e]==null)throw new Error("Cannot clear invalid class ".concat(e));this.classDatasetMatrices[e].dispose(),delete this.classDatasetMatrices[e],delete this.classExampleCount[e],this.clearTrainDatasetMatrix()},n.prototype.clearAllClasses=function(){for(var e in this.classDatasetMatrices)this.clearClass(e)},n.prototype.getClassExampleCount=function(){return this.classExampleCount},n.prototype.getClassifierDataset=function(){return this.classDatasetMatrices},n.prototype.getNumClasses=function(){return Object.keys(this.classExampleCount).length},n.prototype.setClassifierDataset=function(e){this.clearTrainDatasetMatrix(),this.classDatasetMatrices=e;for(var t in e)this.classExampleCount[t]=e[t].shape[0]},n.prototype.calculateTopClass=function(e,t){var r,s={};if(e==null)return{classIndex:this.labelToClassId[r],label:r,confidences:s};var i={},o=0;for(var a in this.classDatasetMatrices)o+=this.classExampleCount[a],i[a]=o;var l={};for(var a in this.classDatasetMatrices)l[a]=0;for(var c=0;c<e.length;c++){var u=e[c];for(var a in this.classDatasetMatrices)if(u<i[a]){l[a]++;break}}var h=0;for(var a in this.classDatasetMatrices){var f=l[a]/t;f>h&&(h=f,r=a),s[a]=f}return{classIndex:this.labelToClassId[r],label:r,confidences:s}},n.prototype.clearTrainDatasetMatrix=function(){this.trainDatasetMatrix!=null&&(this.trainDatasetMatrix.dispose(),this.trainDatasetMatrix=null)},n.prototype.normalizeVectorToUnitLength=function(e){return Se(function(){var t=Cw(e);return Ft(e,t)})},n.prototype.getNumExamples=function(){var e=0;for(var t in this.classDatasetMatrices)e+=this.classExampleCount[t];return e},n.prototype.dispose=function(){this.clearTrainDatasetMatrix();for(var e in this.classDatasetMatrices)this.classDatasetMatrices[e].dispose()},n}();/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function gA(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?s(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function yA(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&u[0]?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(s=(s=o.trys).length>0&&s[s.length-1])&&(u[0]===6||u[0]===2)){o=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){o.label=u[1];break}if(u[0]===6&&o.label<s[1]){o.label=s[1],s=u;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(u);break}s[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}var Iht={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},hd=224,Aht={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},db={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function _j(n){return n===void 0&&(n={version:1,alpha:1}),gA(this,void 0,void 0,function(){var e,t,r,s,i,o,a;return yA(this,function(l){switch(l.label){case 0:if(KY==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e=n.version.toFixed(2),t=n.alpha?n.alpha.toFixed(2):"",r=-1,s=1,n.modelUrl==null){if(!(e in db))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(db));if(!(t in db[e]))throw new Error("MobileNet constructed with invalid alpha "+n.alpha+". Valid multipliers for this version are: "+Object.keys(db[e])+".");o=db[e][t].inputRange,r=o[0],s=o[1]}return n.inputRange!=null&&(a=n.inputRange,r=a[0],s=a[1]),[4,(i=new Mht(e,t,n.modelUrl,r,s)).load()];case 1:return l.sent(),[2,i]}})})}var Mht=function(){function n(e,t,r,s,i){s===void 0&&(s=-1),i===void 0&&(i=1),this.version=e,this.alpha=t,this.modelUrl=r,this.inputMin=s,this.inputMax=i,this.normalizationConstant=(i-s)/255}return n.prototype.load=function(){return gA(this,void 0,void 0,function(){var e,t,r,s,i=this;return yA(this,function(o){switch(o.label){case 0:return this.modelUrl?(e=this,[4,Pl(this.modelUrl)]):[3,2];case 1:return e.model=o.sent(),[3,4];case 2:return t=db[this.version][this.alpha].url,r=this,[4,Pl(t,{fromTFHub:!0})];case 3:r.model=o.sent(),o.label=4;case 4:return[4,(s=Se(function(){return i.model.predict(ms([1,hd,hd,3]))})).data()];case 5:return o.sent(),s.dispose(),[2]}})})},n.prototype.infer=function(e,t){var r=this;return t===void 0&&(t=!1),Se(function(){e instanceof qn||(e=sC(e));var s=qe(fe(xt(e,"float32"),r.normalizationConstant),r.inputMin),i=s;(e.shape[0]!==hd||e.shape[1]!==hd)&&(i=Si.resizeBilinear(s,[hd,hd],!0));var o,a=ve(i,[-1,hd,hd,3]);if(t){var l=Aht[r.version],c=r.model.execute(a,l);o=gr(c,[1,2])}else{var u=r.model.predict(a);o=fn(u,[0,1],[-1,1e3])}return o})},n.prototype.classify=function(e,t){return t===void 0&&(t=3),gA(this,void 0,void 0,function(){var r,s;return yA(this,function(i){switch(i.label){case 0:return[4,Nht(r=this.infer(e),t)];case 1:return s=i.sent(),r.dispose(),[2,s]}})})},n}();function Nht(n,e){return gA(this,void 0,void 0,function(){var t,r,s,i,o,a,l;return yA(this,function(c){switch(c.label){case 0:return[4,(t=eC(n)).data()];case 1:for(r=c.sent(),t.dispose(),s=[],l=0;l<r.length;l++)s.push({value:r[l],index:l});for(s.sort(function(u,h){return h.value-u.value}),i=new Float32Array(e),o=new Int32Array(e),l=0;l<e;l++)i[l]=s[l].value,o[l]=s[l].index;for(a=[],l=0;l<o.length;l++)a.push({className:Iht[o[l]],probability:i[l]});return[2,a]}})})}var $ht={};(function(){var n;function e(T){var $=0;return function(){return $<T.length?{done:!1,value:T[$++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,$,L){return T==Array.prototype||T==Object.prototype||(T[$]=L.value),T};function r(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof mt=="object"&&mt];for(var $=0;$<T.length;++$){var L=T[$];if(L&&L.Math==Math)return L}throw Error("Cannot find global object")}var s=r(this);function i(T,$){if($)e:{var L=s;T=T.split(".");for(var W=0;W<T.length-1;W++){var ne=T[W];if(!(ne in L))break e;L=L[ne]}T=T[T.length-1],W=L[T],$=$(W),$!=W&&$!=null&&t(L,T,{configurable:!0,writable:!0,value:$})}}i("Symbol",function(T){function $(ie){if(this instanceof $)throw new TypeError("Symbol is not a constructor");return new L(W+(ie||"")+"_"+ne++,ie)}function L(ie,se){this.h=ie,t(this,"description",{configurable:!0,writable:!0,value:se})}if(T)return T;L.prototype.toString=function(){return this.h};var W="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ne=0;return $}),i("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var $="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),L=0;L<$.length;L++){var W=s[$[L]];typeof W=="function"&&typeof W.prototype[T]!="function"&&t(W.prototype,T,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return T});function o(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function a(T){var $=typeof Symbol<"u"&&Symbol.iterator&&T[Symbol.iterator];return $?$.call(T):{next:e(T)}}function l(T){if(!(T instanceof Array)){T=a(T);for(var $,L=[];!($=T.next()).done;)L.push($.value);T=L}return T}var c=typeof Object.assign=="function"?Object.assign:function(T,$){for(var L=1;L<arguments.length;L++){var W=arguments[L];if(W)for(var ne in W)Object.prototype.hasOwnProperty.call(W,ne)&&(T[ne]=W[ne])}return T};i("Object.assign",function(T){return T||c});var u=typeof Object.create=="function"?Object.create:function(T){function $(){}return $.prototype=T,new $},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var f;e:{var d={a:!0},p={};try{p.__proto__=d,f=p.a;break e}catch{}f=!1}h=f?function(T,$){if(T.__proto__=$,T.__proto__!==$)throw new TypeError(T+" is not extensible");return T}:null}var m=h;function g(T,$){if(T.prototype=u($.prototype),T.prototype.constructor=T,m)m(T,$);else for(var L in $)if(L!="prototype")if(Object.defineProperties){var W=Object.getOwnPropertyDescriptor($,L);W&&Object.defineProperty(T,L,W)}else T[L]=$[L];T.za=$.prototype}function y(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function b(T){if(T.m)throw new TypeError("Generator is already running");T.m=!0}y.prototype.u=function(T){this.i=T};function x(T,$){T.l={ma:$,na:!0},T.h=T.s||T.v}y.prototype.return=function(T){this.l={return:T},this.h=this.v};function w(T,$,L){return T.h=L,{value:$}}function _(T){this.h=new y,this.i=T}function C(T,$){b(T.h);var L=T.h.j;return L?k(T,"return"in L?L.return:function(W){return{value:W,done:!0}},$,T.h.return):(T.h.return($),A(T))}function k(T,$,L,W){try{var ne=$.call(T.h.j,L);if(!(ne instanceof Object))throw new TypeError("Iterator result "+ne+" is not an object");if(!ne.done)return T.h.m=!1,ne;var ie=ne.value}catch(se){return T.h.j=null,x(T.h,se),A(T)}return T.h.j=null,W.call(T.h,ie),A(T)}function A(T){for(;T.h.h;)try{var $=T.i(T.h);if($)return T.h.m=!1,{value:$.value,done:!1}}catch(L){T.h.i=void 0,x(T.h,L)}if(T.h.m=!1,T.h.l){if($=T.h.l,T.h.l=null,$.na)throw $.ma;return{value:$.return,done:!0}}return{value:void 0,done:!0}}function M(T){this.next=function($){return b(T.h),T.h.j?$=k(T,T.h.j.next,$,T.h.u):(T.h.u($),$=A(T)),$},this.throw=function($){return b(T.h),T.h.j?$=k(T,T.h.j.throw,$,T.h.u):(x(T.h,$),$=A(T)),$},this.return=function($){return C(T,$)},this[Symbol.iterator]=function(){return this}}function I(T){function $(W){return T.next(W)}function L(W){return T.throw(W)}return new Promise(function(W,ne){function ie(se){se.done?W(se.value):Promise.resolve(se.value).then($,L).then(ie,ne)}ie(T.next())})}function N(T){return I(new M(new _(T)))}i("Promise",function(T){function $(se){this.i=0,this.j=void 0,this.h=[],this.u=!1;var _e=this.l();try{se(_e.resolve,_e.reject)}catch(Pe){_e.reject(Pe)}}function L(){this.h=null}function W(se){return se instanceof $?se:new $(function(_e){_e(se)})}if(T)return T;L.prototype.i=function(se){if(this.h==null){this.h=[];var _e=this;this.j(function(){_e.m()})}this.h.push(se)};var ne=s.setTimeout;L.prototype.j=function(se){ne(se,0)},L.prototype.m=function(){for(;this.h&&this.h.length;){var se=this.h;this.h=[];for(var _e=0;_e<se.length;++_e){var Pe=se[_e];se[_e]=null;try{Pe()}catch(ft){this.l(ft)}}}this.h=null},L.prototype.l=function(se){this.j(function(){throw se})},$.prototype.l=function(){function se(ft){return function(Tt){Pe||(Pe=!0,ft.call(_e,Tt))}}var _e=this,Pe=!1;return{resolve:se(this.I),reject:se(this.m)}},$.prototype.I=function(se){if(se===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(se instanceof $)this.L(se);else{e:switch(typeof se){case"object":var _e=se!=null;break e;case"function":_e=!0;break e;default:_e=!1}_e?this.F(se):this.s(se)}},$.prototype.F=function(se){var _e=void 0;try{_e=se.then}catch(Pe){this.m(Pe);return}typeof _e=="function"?this.M(_e,se):this.s(se)},$.prototype.m=function(se){this.v(2,se)},$.prototype.s=function(se){this.v(1,se)},$.prototype.v=function(se,_e){if(this.i!=0)throw Error("Cannot settle("+se+", "+_e+"): Promise already settled in state"+this.i);this.i=se,this.j=_e,this.i===2&&this.K(),this.H()},$.prototype.K=function(){var se=this;ne(function(){if(se.D()){var _e=s.console;typeof _e<"u"&&_e.error(se.j)}},1)},$.prototype.D=function(){if(this.u)return!1;var se=s.CustomEvent,_e=s.Event,Pe=s.dispatchEvent;return typeof Pe>"u"?!0:(typeof se=="function"?se=new se("unhandledrejection",{cancelable:!0}):typeof _e=="function"?se=new _e("unhandledrejection",{cancelable:!0}):(se=s.document.createEvent("CustomEvent"),se.initCustomEvent("unhandledrejection",!1,!0,se)),se.promise=this,se.reason=this.j,Pe(se))},$.prototype.H=function(){if(this.h!=null){for(var se=0;se<this.h.length;++se)ie.i(this.h[se]);this.h=null}};var ie=new L;return $.prototype.L=function(se){var _e=this.l();se.T(_e.resolve,_e.reject)},$.prototype.M=function(se,_e){var Pe=this.l();try{se.call(_e,Pe.resolve,Pe.reject)}catch(ft){Pe.reject(ft)}},$.prototype.then=function(se,_e){function Pe(Ut,Nt){return typeof Ut=="function"?function(an){try{ft(Ut(an))}catch(Bn){Tt(Bn)}}:Nt}var ft,Tt,un=new $(function(Ut,Nt){ft=Ut,Tt=Nt});return this.T(Pe(se,ft),Pe(_e,Tt)),un},$.prototype.catch=function(se){return this.then(void 0,se)},$.prototype.T=function(se,_e){function Pe(){switch(ft.i){case 1:se(ft.j);break;case 2:_e(ft.j);break;default:throw Error("Unexpected state: "+ft.i)}}var ft=this;this.h==null?ie.i(Pe):this.h.push(Pe),this.u=!0},$.resolve=W,$.reject=function(se){return new $(function(_e,Pe){Pe(se)})},$.race=function(se){return new $(function(_e,Pe){for(var ft=a(se),Tt=ft.next();!Tt.done;Tt=ft.next())W(Tt.value).T(_e,Pe)})},$.all=function(se){var _e=a(se),Pe=_e.next();return Pe.done?W([]):new $(function(ft,Tt){function un(an){return function(Bn){Ut[an]=Bn,Nt--,Nt==0&&ft(Ut)}}var Ut=[],Nt=0;do Ut.push(void 0),Nt++,W(Pe.value).T(un(Ut.length-1),Tt),Pe=_e.next();while(!Pe.done)})},$});function O(T,$){T instanceof String&&(T+="");var L=0,W=!1,ne={next:function(){if(!W&&L<T.length){var ie=L++;return{value:$(ie,T[ie]),done:!1}}return W=!0,{done:!0,value:void 0}}};return ne[Symbol.iterator]=function(){return ne},ne}i("Array.prototype.keys",function(T){return T||function(){return O(this,function($){return $})}}),i("Array.prototype.fill",function(T){return T||function($,L,W){var ne=this.length||0;for(0>L&&(L=Math.max(0,ne+L)),(W==null||W>ne)&&(W=ne),W=Number(W),0>W&&(W=Math.max(0,ne+W)),L=Number(L||0);L<W;L++)this[L]=$;return this}});function R(T){return T||Array.prototype.fill}i("Int8Array.prototype.fill",R),i("Uint8Array.prototype.fill",R),i("Uint8ClampedArray.prototype.fill",R),i("Int16Array.prototype.fill",R),i("Uint16Array.prototype.fill",R),i("Int32Array.prototype.fill",R),i("Uint32Array.prototype.fill",R),i("Float32Array.prototype.fill",R),i("Float64Array.prototype.fill",R),i("Object.is",function(T){return T||function($,L){return $===L?$!==0||1/$===1/L:$!==$&&L!==L}}),i("Array.prototype.includes",function(T){return T||function($,L){var W=this;W instanceof String&&(W=String(W));var ne=W.length;for(L=L||0,0>L&&(L=Math.max(L+ne,0));L<ne;L++){var ie=W[L];if(ie===$||Object.is(ie,$))return!0}return!1}}),i("String.prototype.includes",function(T){return T||function($,L){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if($ instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf($,L||0)!==-1}});var D=this||self;function z(T,$){T=T.split(".");var L=D;T[0]in L||typeof L.execScript>"u"||L.execScript("var "+T[0]);for(var W;T.length&&(W=T.shift());)T.length||$===void 0?L[W]&&L[W]!==Object.prototype[W]?L=L[W]:L=L[W]={}:L[W]=$}function B(T){var $;e:{if(($=D.navigator)&&($=$.userAgent))break e;$=""}return $.indexOf(T)!=-1}var X=Array.prototype.map?function(T,$){return Array.prototype.map.call(T,$,void 0)}:function(T,$){for(var L=T.length,W=Array(L),ne=typeof T=="string"?T.split(""):T,ie=0;ie<L;ie++)ie in ne&&(W[ie]=$.call(void 0,ne[ie],ie,T));return W},G={},ee=null;function pe(T){var $=T.length,L=3*$/4;L%3?L=Math.floor(L):"=.".indexOf(T[$-1])!=-1&&(L="=.".indexOf(T[$-2])!=-1?L-2:L-1);var W=new Uint8Array(L),ne=0;return oe(T,function(ie){W[ne++]=ie}),ne!==L?W.subarray(0,ne):W}function oe(T,$){function L(Pe){for(;W<T.length;){var ft=T.charAt(W++),Tt=ee[ft];if(Tt!=null)return Tt;if(!/^[\s\xa0]*$/.test(ft))throw Error("Unknown base64 encoding at char: "+ft)}return Pe}Ne();for(var W=0;;){var ne=L(-1),ie=L(0),se=L(64),_e=L(64);if(_e===64&&ne===-1)break;$(ne<<2|ie>>4),se!=64&&($(ie<<4&240|se>>2),_e!=64&&$(se<<6&192|_e))}}function Ne(){if(!ee){ee={};for(var T="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),$=["+/=","+/","-_=","-_.","-_"],L=0;5>L;L++){var W=T.concat($[L].split(""));G[L]=W;for(var ne=0;ne<W.length;ne++){var ie=W[ne];ee[ie]===void 0&&(ee[ie]=ne)}}}}var ke=typeof Uint8Array<"u",De=!(B("Trident")||B("MSIE"))&&typeof D.btoa=="function";function ge(T){if(!De){var $;$===void 0&&($=0),Ne(),$=G[$];for(var L=Array(Math.floor(T.length/3)),W=$[64]||"",ne=0,ie=0;ne<T.length-2;ne+=3){var se=T[ne],_e=T[ne+1],Pe=T[ne+2],ft=$[se>>2];se=$[(se&3)<<4|_e>>4],_e=$[(_e&15)<<2|Pe>>6],Pe=$[Pe&63],L[ie++]=ft+se+_e+Pe}switch(ft=0,Pe=W,T.length-ne){case 2:ft=T[ne+1],Pe=$[(ft&15)<<2]||W;case 1:T=T[ne],L[ie]=$[T>>2]+$[(T&3)<<4|ft>>4]+Pe+W}return L.join("")}for($="";10240<T.length;)$+=String.fromCharCode.apply(null,T.subarray(0,10240)),T=T.subarray(10240);return $+=String.fromCharCode.apply(null,T),btoa($)}var Xe=RegExp("[-_.]","g");function Oe(T){switch(T){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function it(T){if(!De)return pe(T);Xe.test(T)&&(T=T.replace(Xe,Oe)),T=atob(T);for(var $=new Uint8Array(T.length),L=0;L<T.length;L++)$[L]=T.charCodeAt(L);return $}var Ge;function pt(){return Ge||(Ge=new Uint8Array(0))}var ut={},Ve=typeof Uint8Array.prototype.slice=="function",ze=0,Be=0;function ht(T){var $=0>T;T=Math.abs(T);var L=T>>>0;T=Math.floor((T-L)/4294967296),$&&(L=a(Q(L,T)),$=L.next().value,T=L.next().value,L=$),ze=L>>>0,Be=T>>>0}var Ke=typeof BigInt=="function";function Q(T,$){return $=~$,T?T=~T+1:$+=1,[T,$]}function Z(T,$){this.i=T>>>0,this.h=$>>>0}function nt(T){if(!T)return He||(He=new Z(0,0));if(!/^-?\d+$/.test(T))return null;if(16>T.length)ht(Number(T));else if(Ke)T=BigInt(T),ze=Number(T&BigInt(4294967295))>>>0,Be=Number(T>>BigInt(32)&BigInt(4294967295));else{var $=+(T[0]==="-");Be=ze=0;for(var L=T.length,W=$,ne=(L-$)%6+$;ne<=L;W=ne,ne+=6)W=Number(T.slice(W,ne)),Be*=1e6,ze=1e6*ze+W,4294967296<=ze&&(Be+=ze/4294967296|0,ze%=4294967296);$&&($=a(Q(ze,Be)),T=$.next().value,$=$.next().value,ze=T,Be=$)}return new Z(ze,Be)}var He;function me(T,$){return Error("Invalid wire type: "+T+" (at position "+$+")")}function Ye(){return Error("Failed to read varint, encoding is invalid.")}function bt(T,$){return Error("Tried to read past the end of the data "+$+" > "+T)}function kt(){throw Error("Invalid UTF8")}function dt(T,$){return $=String.fromCharCode.apply(null,$),T==null?$:T+$}var le=void 0,tt,Ct=typeof TextDecoder<"u",yt,Ht=typeof TextEncoder<"u",En;function _r(T){if(T!==ut)throw Error("illegal external caller")}function Bs(T,$){if(_r($),this.V=T,T!=null&&T.length===0)throw Error("ByteString should be constructed with non-empty values")}function Ms(){return En||(En=new Bs(null,ut))}function Ns(T){_r(ut);var $=T.V;return $=$==null||ke&&$!=null&&$ instanceof Uint8Array?$:typeof $=="string"?it($):null,$==null?$:T.V=$}function Lh(T){if(typeof T=="string")return{buffer:it(T),C:!1};if(Array.isArray(T))return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Uint8Array)return{buffer:T,C:!1};if(T.constructor===ArrayBuffer)return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Bs)return{buffer:Ns(T)||pt(),C:!0};if(T instanceof Uint8Array)return{buffer:new Uint8Array(T.buffer,T.byteOffset,T.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Wl(T,$){this.i=null,this.m=!1,this.h=this.j=this.l=0,Gl(this,T,$)}function Gl(T,$,L){L=L===void 0?{}:L,T.S=L.S===void 0?!1:L.S,$&&($=Lh($),T.i=$.buffer,T.m=$.C,T.l=0,T.j=T.i.length,T.h=T.l)}Wl.prototype.reset=function(){this.h=this.l};function fo(T,$){if(T.h=$,$>T.j)throw bt(T.j,$)}function Hl(T){var $=T.i,L=T.h,W=$[L++],ne=W&127;if(W&128&&(W=$[L++],ne|=(W&127)<<7,W&128&&(W=$[L++],ne|=(W&127)<<14,W&128&&(W=$[L++],ne|=(W&127)<<21,W&128&&(W=$[L++],ne|=W<<28,W&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128)))))throw Ye();return fo(T,L),ne}function Bc(T,$){if(0>$)throw Error("Tried to read a negative byte length: "+$);var L=T.h,W=L+$;if(W>T.j)throw bt($,T.j-L);return T.h=W,L}var Vc=[];function Ri(){this.h=[]}Ri.prototype.length=function(){return this.h.length},Ri.prototype.end=function(){var T=this.h;return this.h=[],T};function zh(T,$,L){for(;0<L||127<$;)T.h.push($&127|128),$=($>>>7|L<<25)>>>0,L>>>=7;T.h.push($)}function sl(T,$){for(;127<$;)T.h.push($&127|128),$>>>=7;T.h.push($)}function Bh(T,$){if(Vc.length){var L=Vc.pop();Gl(L,T,$),T=L}else T=new Wl(T,$);this.h=T,this.j=this.h.h,this.i=this.l=-1,this.setOptions($)}Bh.prototype.setOptions=function(T){T=T===void 0?{}:T,this.ca=T.ca===void 0?!1:T.ca},Bh.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function re(T){var $=T.h;if($.h==$.j)return!1;T.j=T.h.h;var L=Hl(T.h)>>>0;if($=L>>>3,L&=7,!(0<=L&&5>=L))throw me(L,T.j);if(1>$)throw Error("Invalid field number: "+$+" (at position "+T.j+")");return T.l=$,T.i=L,!0}function We(T){switch(T.i){case 0:if(T.i!=0)We(T);else e:{T=T.h;for(var $=T.h,L=$+10,W=T.i;$<L;)if(!(W[$++]&128)){fo(T,$);break e}throw Ye()}break;case 1:T=T.h,fo(T,T.h+8);break;case 2:T.i!=2?We(T):($=Hl(T.h)>>>0,T=T.h,fo(T,T.h+$));break;case 5:T=T.h,fo(T,T.h+4);break;case 3:$=T.l;do{if(!re(T))throw Error("Unmatched start-group tag: stream EOF");if(T.i==4){if(T.l!=$)throw Error("Unmatched end-group tag");break}We(T)}while(1);break;default:throw me(T.i,T.j)}}var Fe=[];function Ze(){this.j=[],this.i=0,this.h=new Ri}function wt(T,$){$.length!==0&&(T.j.push($),T.i+=$.length)}function zn(T,$){if($=$.R){wt(T,T.h.end());for(var L=0;L<$.length;L++)wt(T,Ns($[L])||pt())}}var sn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function _n(T,$){return sn?T[sn]|=$:T.A!==void 0?T.A|=$:(Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}}),$)}function Cn(T,$){sn?T[sn]&&(T[sn]&=~$):T.A!==void 0&&(T.A&=~$)}function In(T){var $;return sn?$=T[sn]:$=T.A,$??0}function er(T,$){sn?T[sn]=$:T.A!==void 0?T.A=$:Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}})}function vn(T){return _n(T,1),T}function cr(T,$){er($,(T|0)&-51)}function Pi(T,$){er($,(T|18)&-41)}var wr={};function Yi(T){return T!==null&&typeof T=="object"&&!Array.isArray(T)&&T.constructor===Object}var Ar,To=[];er(To,23),Ar=Object.freeze(To);function ss(T){if(In(T.o)&2)throw Error("Cannot mutate an immutable Message")}function po(T){var $=T.length;($=$?T[$-1]:void 0)&&Yi($)?$.g=1:($={},T.push(($.g=1,$)))}function Eo(T){var $=T.i+T.G;return T.B||(T.B=T.o[$]={})}function $s(T,$){return $===-1?null:$>=T.i?T.B?T.B[$]:void 0:T.o[$+T.G]}function mo(T,$,L,W){ss(T),Vh(T,$,L,W)}function Vh(T,$,L,W){T.j&&(T.j=void 0),$>=T.i||W?Eo(T)[$]=L:(T.o[$+T.G]=L,(T=T.B)&&$ in T&&delete T[$])}function il(T,$,L,W){var ne=$s(T,$);Array.isArray(ne)||(ne=Ar);var ie=In(ne);if(ie&1||vn(ne),W)ie&2||_n(ne,2),L&1||Object.freeze(ne);else{W=!(L&2);var se=ie&2;L&1||!se?W&&ie&16&&!se&&Cn(ne,16):(ne=vn(Array.prototype.slice.call(ne)),Vh(T,$,ne))}return ne}function Zi(T,$){var L=$s(T,$),W=L==null?L:typeof L=="number"||L==="NaN"||L==="Infinity"||L==="-Infinity"?Number(L):void 0;return W!=null&&W!==L&&Vh(T,$,W),W}function Uc(T,$,L,W,ne){T.h||(T.h={});var ie=T.h[L],se=il(T,L,3,ne);if(!ie){var _e=se;ie=[];var Pe=!!(In(T.o)&16);se=!!(In(_e)&2);var ft=_e;!ne&&se&&(_e=Array.prototype.slice.call(_e));for(var Tt=se,un=0;un<_e.length;un++){var Ut=_e[un],Nt=$,an=!1;if(an=an===void 0?!1:an,Ut=Array.isArray(Ut)?new Nt(Ut):an?new Nt:void 0,Ut!==void 0){Nt=Ut.o;var Bn=an=In(Nt);se&&(Bn|=2),Pe&&(Bn|=16),Bn!=an&&er(Nt,Bn),Nt=Bn,Tt=Tt||!!(2&Nt),ie.push(Ut)}}return T.h[L]=ie,Pe=In(_e),$=Pe|33,$=Tt?$&-9:$|8,Pe!=$&&(Tt=_e,Object.isFrozen(Tt)&&(Tt=Array.prototype.slice.call(Tt)),er(Tt,$),_e=Tt),ft!==_e&&Vh(T,L,_e),(ne||W&&se)&&_n(ie,2),W&&Object.freeze(ie),ie}return ne||(ne=Object.isFrozen(ie),W&&!ne?Object.freeze(ie):!W&&ne&&(ie=Array.prototype.slice.call(ie),T.h[L]=ie)),ie}function Ta(T,$,L){var W=!!(In(T.o)&2);if($=Uc(T,$,L,W,W),T=il(T,L,3,W),!(W||In(T)&8)){for(W=0;W<$.length;W++){if(L=$[W],In(L.o)&2){var ne=jl(L,!1);ne.j=L}else ne=L;L!==ne&&($[W]=ne,T[W]=ne.o)}_n(T,8)}return $}function Rs(T,$,L){if(L!=null&&typeof L!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof L+": "+L);mo(T,$,L)}function Wc(T,$,L,W,ne){ss(T);var ie=Uc(T,L,$,!1,!1);return L=W??new L,T=il(T,$,2,!1),ne!=null?(ie.splice(ne,0,L),T.splice(ne,0,L.o)):(ie.push(L),T.push(L.o)),L.C()&&Cn(T,8),L}function Ji(T,$){return T??$}function Vs(T,$,L){return L=L===void 0?0:L,Ji(Zi(T,$),L)}var Uh;function r0(T){switch(typeof T){case"number":return isFinite(T)?T:String(T);case"object":if(T)if(Array.isArray(T)){if(In(T)&128)return T=Array.prototype.slice.call(T),po(T),T}else{if(ke&&T!=null&&T instanceof Uint8Array)return ge(T);if(T instanceof Bs){var $=T.V;return $==null?"":typeof $=="string"?$:T.V=ge($)}}}return T}function Wh(T,$,L,W){if(T!=null){if(Array.isArray(T))T=Qi(T,$,L,W!==void 0);else if(Yi(T)){var ne={},ie;for(ie in T)ne[ie]=Wh(T[ie],$,L,W);T=ne}else T=$(T,W);return T}}function Qi(T,$,L,W){var ne=In(T);W=W?!!(ne&16):void 0,T=Array.prototype.slice.call(T);for(var ie=0;ie<T.length;ie++)T[ie]=Wh(T[ie],$,L,W);return L(ne,T),T}function Gh(T){return T.ja===wr?T.toJSON():r0(T)}function Zf(T,$){T&128&&po($)}function Hu(T,$,L){if(L=L===void 0?Pi:L,T!=null){if(ke&&T instanceof Uint8Array)return T.length?new Bs(new Uint8Array(T),ut):Ms();if(Array.isArray(T)){var W=In(T);return W&2?T:$&&!(W&32)&&(W&16||W===0)?(er(T,W|2),T):(T=Qi(T,Hu,W&4?Pi:L,!0),$=In(T),$&4&&$&2&&Object.freeze(T),T)}return T.ja===wr?Hh(T):T}}function Jf(T,$,L,W,ne,ie,se){if(T=T.h&&T.h[L]){if(W=In(T),W&2?W=T:(ie=X(T,Hh),Pi(W,ie),Object.freeze(ie),W=ie),ss($),se=W==null?Ar:vn([]),W!=null){for(ie=!!W.length,T=0;T<W.length;T++){var _e=W[T];ie=ie&&!(In(_e.o)&2),se[T]=_e.o}ie=(ie?8:0)|1,T=In(se),(T&ie)!==ie&&(Object.isFrozen(se)&&(se=Array.prototype.slice.call(se)),er(se,T|ie)),$.h||($.h={}),$.h[L]=W}else $.h&&($.h[L]=void 0);Vh($,L,se,ne)}else mo($,L,Hu(W,ie,se),ne)}function Hh(T){return In(T.o)&2||(T=jl(T,!0),_n(T.o,2)),T}function jl(T,$){var L=T.o,W=[];_n(W,16);var ne=T.constructor.h;if(ne&&W.push(ne),ne=T.B,ne){W.length=L.length,W.fill(void 0,W.length,L.length);var ie={};W[W.length-1]=ie}In(L)&128&&po(W),$=$||T.C()?Pi:cr,ie=T.constructor,Uh=W,W=new ie(W),Uh=void 0,T.R&&(W.R=T.R.slice()),ie=!!(In(L)&16);for(var se=ne?L.length-1:L.length,_e=0;_e<se;_e++)Jf(T,W,_e-T.G,L[_e],!1,ie,$);if(ne)for(var Pe in ne)Jf(T,W,+Pe,ne[Pe],!0,ie,$);return W}function Zr(T,$,L){T==null&&(T=Uh),Uh=void 0;var W=this.constructor.i||0,ne=0<W,ie=this.constructor.h,se=!1;if(T==null){T=ie?[ie]:[];var _e=48,Pe=!0;ne&&(W=0,_e|=128),er(T,_e)}else{if(!Array.isArray(T)||ie&&ie!==T[0])throw Error();var ft=_e=_n(T,0);if((Pe=(16&ft)!==0)&&((se=(32&ft)!==0)||(ft|=32)),ne){if(128&ft)W=0;else if(0<T.length){var Tt=T[T.length-1];if(Yi(Tt)&&"g"in Tt){W=0,ft|=128,delete Tt.g;var un=!0,Ut;for(Ut in Tt){un=!1;break}un&&T.pop()}}}else if(128&ft)throw Error();_e!==ft&&er(T,ft)}this.G=(ie?0:-1)-W,this.h=void 0,this.o=T;e:{if(ie=this.o.length,W=ie-1,ie&&(ie=this.o[W],Yi(ie))){this.B=ie,this.i=W-this.G;break e}$!==void 0&&-1<$?(this.i=Math.max($,W+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!ne&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(L){$=Pe&&!se&&!0,ne=this.i;var Nt;for(Pe=0;Pe<L.length;Pe++)se=L[Pe],se<ne?(se+=this.G,(W=T[se])?s0(W,$):T[se]=Ar):(Nt||(Nt=Eo(this)),(W=Nt[se])?s0(W,$):Nt[se]=Ar)}}Zr.prototype.toJSON=function(){return Qi(this.o,Gh,Zf)},Zr.prototype.C=function(){return!!(In(this.o)&2)};function s0(T,$){if(Array.isArray(T)){var L=In(T),W=1;!$||L&2||(W|=16),(L&W)!==W&&er(T,L|W)}}Zr.prototype.ja=wr,Zr.prototype.toString=function(){return this.o.toString()};function Qf(T,$,L){if(L){var W={},ne;for(ne in L){var ie=L[ne],se=ie.ra;se||(W.J=ie.xa||ie.oa.W,ie.ia?(W.aa=lt(ie.ia),se=function(_e){return function(Pe,ft,Tt){return _e.J(Pe,ft,Tt,_e.aa)}}(W)):ie.ka?(W.Z=Vt(ie.da.P,ie.ka),se=function(_e){return function(Pe,ft,Tt){return _e.J(Pe,ft,Tt,_e.Z)}}(W)):se=W.J,ie.ra=se),se($,T,ie.da),W={J:W.J,aa:W.aa,Z:W.Z}}}zn($,T)}var Gc=Symbol();function jh(T,$,L){return T[Gc]||(T[Gc]=function(W,ne){return $(W,ne,L)})}function i0(T){var $=T[Gc];if(!$){var L=mx(T);$=function(W,ne){return a0(W,ne,L)},T[Gc]=$}return $}function o0(T){var $=T.ia;if($)return i0($);if($=T.wa)return jh(T.da.P,$,T.ka)}function H(T){var $=o0(T),L=T.da,W=T.oa.U;return $?function(ne,ie){return W(ne,ie,L,$)}:function(ne,ie){return W(ne,ie,L)}}function Y(T,$){var L=T[$];return typeof L=="function"&&L.length===0&&(L=L(),T[$]=L),Array.isArray(L)&&(Vp in L||An in L||0<L.length&&typeof L[0]=="function")?L:void 0}function de(T,$,L,W,ne,ie){$.P=T[0];var se=1;if(T.length>se&&typeof T[se]!="number"){var _e=T[se++];L($,_e)}for(;se<T.length;){L=T[se++];for(var Pe=se+1;Pe<T.length&&typeof T[Pe]!="number";)Pe++;switch(_e=T[se++],Pe-=se,Pe){case 0:W($,L,_e);break;case 1:(Pe=Y(T,se))?(se++,ne($,L,_e,Pe)):W($,L,_e,T[se++]);break;case 2:Pe=se++,Pe=Y(T,Pe),ne($,L,_e,Pe,T[se++]);break;case 3:ie($,L,_e,T[se++],T[se++],T[se++]);break;case 4:ie($,L,_e,T[se++],T[se++],T[se++],T[se++]);break;default:throw Error("unexpected number of binary field arguments: "+Pe)}}return $}var $e=Symbol();function lt(T){var $=T[$e];if(!$){var L=px(T);$=function(W,ne){return KC(W,ne,L)},T[$e]=$}return $}function Vt(T,$){var L=T[$e];return L||(L=function(W,ne){return Qf(W,ne,$)},T[$e]=L),L}var An=Symbol();function Ps(T,$){T.push($)}function Us(T,$,L){T.push($,L.W)}function fi(T,$,L,W){var ne=lt(W),ie=px(W).P,se=L.W;T.push($,function(_e,Pe,ft){return se(_e,Pe,ft,ie,ne)})}function Ea(T,$,L,W,ne,ie){var se=Vt(W,ie),_e=L.W;T.push($,function(Pe,ft,Tt){return _e(Pe,ft,Tt,W,se)})}function px(T){var $=T[An];return $||($=de(T,T[An]=[],Ps,Us,fi,Ea),Vp in T&&An in T&&(T.length=0),$)}var Vp=Symbol();function XC(T,$){T[0]=$}function W$(T,$,L,W){var ne=L.U;T[$]=W?function(ie,se,_e){return ne(ie,se,_e,W)}:ne}function G$(T,$,L,W,ne){var ie=L.U,se=i0(W),_e=mx(W).P;T[$]=function(Pe,ft,Tt){return ie(Pe,ft,Tt,_e,se,ne)}}function H$(T,$,L,W,ne,ie,se){var _e=L.U,Pe=jh(W,ne,ie);T[$]=function(ft,Tt,un){return _e(ft,Tt,un,W,Pe,se)}}function mx(T){var $=T[Vp];return $||($=de(T,T[Vp]={},XC,W$,G$,H$),Vp in T&&An in T&&(T.length=0),$)}function a0(T,$,L){for(;re($)&&$.i!=4;){var W=$.l,ne=L[W];if(!ne){var ie=L[0];ie&&(ie=ie[W])&&(ne=L[W]=H(ie))}if(!ne||!ne($,T,W)){ne=$,W=T,ie=ne.j,We(ne);var se=ne;if(!se.ca){if(ne=se.h.h-ie,se.h.h=ie,se=se.h,ne==0)ne=Ms();else{if(ie=Bc(se,ne),se.S&&se.m)ne=se.i.subarray(ie,ie+ne);else{se=se.i;var _e=ie;ne=ie+ne,ne=_e===ne?pt():Ve?se.slice(_e,ne):new Uint8Array(se.subarray(_e,ne))}ne=ne.length==0?Ms():new Bs(ne,ut)}(ie=W.R)?ie.push(ne):W.R=[ne]}}}return T}function KC(T,$,L){for(var W=L.length,ne=W%2==1,ie=ne?1:0;ie<W;ie+=2)(0,L[ie+1])($,T,L[ie]);Qf(T,$,ne?L[0]:void 0)}function Up(T,$){return{U:T,W:$}}var ol=Up(function(T,$,L){if(T.i!==5)return!1;T=T.h;var W=T.i,ne=T.h,ie=W[ne],se=W[ne+1],_e=W[ne+2];return W=W[ne+3],fo(T,T.h+4),se=(ie<<0|se<<8|_e<<16|W<<24)>>>0,T=2*(se>>31)+1,ie=se>>>23&255,se&=8388607,mo($,L,ie==255?se?NaN:1/0*T:ie==0?T*Math.pow(2,-149)*se:T*Math.pow(2,ie-150)*(se+Math.pow(2,23))),!0},function(T,$,L){if($=Zi($,L),$!=null){sl(T.h,8*L+5),T=T.h;var W=+$;W===0?0<1/W?ze=Be=0:(Be=0,ze=2147483648):isNaN(W)?(Be=0,ze=2147483647):(W=(L=0>W?-2147483648:0)?-W:W,34028234663852886e22<W?(Be=0,ze=(L|2139095040)>>>0):11754943508222875e-54>W?(W=Math.round(W/Math.pow(2,-149)),Be=0,ze=(L|W)>>>0):($=Math.floor(Math.log(W)/Math.LN2),W*=Math.pow(2,-$),W=Math.round(8388608*W),16777216<=W&&++$,Be=0,ze=(L|$+127<<23|W&8388607)>>>0)),L=ze,T.h.push(L>>>0&255),T.h.push(L>>>8&255),T.h.push(L>>>16&255),T.h.push(L>>>24&255)}}),j$=Up(function(T,$,L){if(T.i!==0)return!1;var W=T.h,ne=0,ie=T=0,se=W.i,_e=W.h;do{var Pe=se[_e++];ne|=(Pe&127)<<ie,ie+=7}while(32>ie&&Pe&128);for(32<ie&&(T|=(Pe&127)>>4),ie=3;32>ie&&Pe&128;ie+=7)Pe=se[_e++],T|=(Pe&127)<<ie;if(fo(W,_e),128>Pe)W=ne>>>0,Pe=T>>>0,(T=Pe&2147483648)&&(W=~W+1>>>0,Pe=~Pe>>>0,W==0&&(Pe=Pe+1>>>0)),W=4294967296*Pe+(W>>>0);else throw Ye();return mo($,L,T?-W:W),!0},function(T,$,L){$=$s($,L),$!=null&&(typeof $=="string"&&nt($),$!=null&&(sl(T.h,8*L),typeof $=="number"?(T=T.h,ht($),zh(T,ze,Be)):(L=nt($),zh(T.h,L.i,L.h))))}),q$=Up(function(T,$,L){return T.i!==0?!1:(mo($,L,Hl(T.h)),!0)},function(T,$,L){if($=$s($,L),$!=null&&$!=null)if(sl(T.h,8*L),T=T.h,L=$,0<=L)sl(T,L);else{for($=0;9>$;$++)T.h.push(L&127|128),L>>=7;T.h.push(1)}}),Br=Up(function(T,$,L){if(T.i!==2)return!1;var W=Hl(T.h)>>>0;T=T.h;var ne=Bc(T,W);if(T=T.i,Ct){var ie=T,se;(se=tt)||(se=tt=new TextDecoder("utf-8",{fatal:!0})),T=ne+W,ie=ne===0&&T===ie.length?ie:ie.subarray(ne,T);try{var _e=se.decode(ie)}catch(un){if(le===void 0){try{se.decode(new Uint8Array([128]))}catch{}try{se.decode(new Uint8Array([97])),le=!0}catch{le=!1}}throw!le&&(tt=void 0),un}}else{_e=ne,W=_e+W,ne=[];for(var Pe=null,ft,Tt;_e<W;)ft=T[_e++],128>ft?ne.push(ft):224>ft?_e>=W?kt():(Tt=T[_e++],194>ft||(Tt&192)!==128?(_e--,kt()):ne.push((ft&31)<<6|Tt&63)):240>ft?_e>=W-1?kt():(Tt=T[_e++],(Tt&192)!==128||ft===224&&160>Tt||ft===237&&160<=Tt||((ie=T[_e++])&192)!==128?(_e--,kt()):ne.push((ft&15)<<12|(Tt&63)<<6|ie&63)):244>=ft?_e>=W-2?kt():(Tt=T[_e++],(Tt&192)!==128||(ft<<28)+(Tt-144)>>30||((ie=T[_e++])&192)!==128||((se=T[_e++])&192)!==128?(_e--,kt()):(ft=(ft&7)<<18|(Tt&63)<<12|(ie&63)<<6|se&63,ft-=65536,ne.push((ft>>10&1023)+55296,(ft&1023)+56320))):kt(),8192<=ne.length&&(Pe=dt(Pe,ne),ne.length=0);_e=dt(Pe,ne)}return mo($,L,_e),!0},function(T,$,L){if($=$s($,L),$!=null){var W=!1;if(W=W===void 0?!1:W,Ht){if(W&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test($))throw Error("Found an unpaired surrogate");$=(yt||(yt=new TextEncoder)).encode($)}else{for(var ne=0,ie=new Uint8Array(3*$.length),se=0;se<$.length;se++){var _e=$.charCodeAt(se);if(128>_e)ie[ne++]=_e;else{if(2048>_e)ie[ne++]=_e>>6|192;else{if(55296<=_e&&57343>=_e){if(56319>=_e&&se<$.length){var Pe=$.charCodeAt(++se);if(56320<=Pe&&57343>=Pe){_e=1024*(_e-55296)+Pe-56320+65536,ie[ne++]=_e>>18|240,ie[ne++]=_e>>12&63|128,ie[ne++]=_e>>6&63|128,ie[ne++]=_e&63|128;continue}else se--}if(W)throw Error("Found an unpaired surrogate");_e=65533}ie[ne++]=_e>>12|224,ie[ne++]=_e>>6&63|128}ie[ne++]=_e&63|128}}$=ne===ie.length?ie:ie.subarray(0,ne)}sl(T.h,8*L+2),sl(T.h,$.length),wt(T,T.h.end()),wt(T,$)}}),Rr=Up(function(T,$,L,W,ne){if(T.i!==2)return!1;$=Wc($,L,W),L=T.h.j,W=Hl(T.h)>>>0;var ie=T.h.h+W,se=ie-L;if(0>=se&&(T.h.j=ie,ne($,T,void 0,void 0,void 0),se=ie-T.h.h),se)throw Error("Message parsing ended unexpectedly. Expected to read "+(W+" bytes, instead read "+(W-se)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return T.h.h=ie,T.h.j=L,!0},function(T,$,L,W,ne){if($=Ta($,W,L),$!=null)for(W=0;W<$.length;W++){var ie=T;sl(ie.h,8*L+2);var se=ie.h.end();wt(ie,se),se.push(ie.i),ie=se,ne($[W],T),se=T;var _e=ie.pop();for(_e=se.i+se.h.length()-_e;127<_e;)ie.push(_e&127|128),_e>>>=7,se.i++;ie.push(_e),se.i++}});function gx(T){return function($,L){e:{if(Fe.length){var W=Fe.pop();W.setOptions(L),Gl(W.h,$,L),$=W}else $=new Bh($,L);try{var ne=mx(T),ie=a0(new ne.P,$,ne);break e}finally{ne=$.h,ne.i=null,ne.m=!1,ne.l=0,ne.j=0,ne.h=0,ne.S=!1,$.l=-1,$.i=-1,100>Fe.length&&Fe.push($)}ie=void 0}return ie}}function yx(T){return function(){var $=new Ze;KC(this,$,px(T)),wt($,$.h.end());for(var L=new Uint8Array($.i),W=$.j,ne=W.length,ie=0,se=0;se<ne;se++){var _e=W[se];L.set(_e,ie),ie+=_e.length}return $.j=[L],L}}function ed(T){Zr.call(this,T)}g(ed,Zr);var YC=[ed,1,q$,2,ol,3,Br,4,Br];ed.prototype.l=yx(YC);function bx(T){Zr.call(this,T,-1,X$)}g(bx,Zr),bx.prototype.addClassification=function(T,$){return Wc(this,1,ed,T,$),this};var X$=[1],ZC=gx([bx,1,Rr,YC]);function Wp(T){Zr.call(this,T)}g(Wp,Zr);var di=[Wp,1,ol,2,ol,3,ol,4,ol,5,ol];Wp.prototype.l=yx(di);function l0(T){Zr.call(this,T,-1,qh)}g(l0,Zr);var qh=[1],JC=gx([l0,1,Rr,di]);function td(T){Zr.call(this,T)}g(td,Zr);var na=[td,1,ol,2,ol,3,ol,4,ol,5,ol,6,j$],QC=gx(na);td.prototype.l=yx(na);function vx(T,$,L){if(L=T.createShader(L===0?T.VERTEX_SHADER:T.FRAGMENT_SHADER),T.shaderSource(L,$),T.compileShader(L),!T.getShaderParameter(L,T.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+T.getShaderInfoLog(L));return L}function ek(T){return Ta(T,ed,1).map(function($){var L=$s($,1);return{index:L??0,qa:Vs($,2),label:$s($,3)!=null?Ji($s($,3),""):void 0,displayName:$s($,4)!=null?Ji($s($,4),""):void 0}})}function tk(T){return{x:Vs(T,1),y:Vs(T,2),z:Vs(T,3),visibility:Zi(T,4)!=null?Vs(T,4):void 0}}function c0(T){return Ta(JC(T),Wp,1).map(tk)}function u0(T,$){this.i=T,this.h=$,this.m=0}function Io(T,$,L){return K$(T,$),typeof T.h.canvas.transferToImageBitmap=="function"?Promise.resolve(T.h.canvas.transferToImageBitmap()):L?Promise.resolve(T.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(T.h.canvas):(T.j===void 0&&(T.j=document.createElement("canvas")),new Promise(function(W){T.j.height=T.h.canvas.height,T.j.width=T.h.canvas.width,T.j.getContext("2d",{}).drawImage(T.h.canvas,0,0,T.h.canvas.width,T.h.canvas.height),W(T.j)}))}function K$(T,$){var L=T.h;if(T.s===void 0){var W=vx(L,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ne=vx(L,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),ie=L.createProgram();if(L.attachShader(ie,W),L.attachShader(ie,ne),L.linkProgram(ie),!L.getProgramParameter(ie,L.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+L.getProgramInfoLog(ie));W=T.s=ie,L.useProgram(W),ne=L.getUniformLocation(W,"sampler0"),T.l={O:L.getAttribLocation(W,"aVertex"),N:L.getAttribLocation(W,"aTex"),ya:ne},T.v=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.enableVertexAttribArray(T.l.O),L.vertexAttribPointer(T.l.O,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),T.u=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.enableVertexAttribArray(T.l.N),L.vertexAttribPointer(T.l.N,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),L.uniform1i(ne,0)}W=T.l,L.useProgram(T.s),L.canvas.width=$.width,L.canvas.height=$.height,L.viewport(0,0,$.width,$.height),L.activeTexture(L.TEXTURE0),T.i.bindTexture2d($.glName),L.enableVertexAttribArray(W.O),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.vertexAttribPointer(W.O,2,L.FLOAT,!1,0,0),L.enableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.vertexAttribPointer(W.N,2,L.FLOAT,!1,0,0),L.bindFramebuffer(L.DRAW_FRAMEBUFFER?L.DRAW_FRAMEBUFFER:L.FRAMEBUFFER,null),L.clearColor(0,0,0,0),L.clear(L.COLOR_BUFFER_BIT),L.colorMask(!0,!0,!0,!0),L.drawArrays(L.TRIANGLE_FAN,0,4),L.disableVertexAttribArray(W.O),L.disableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,null),T.i.bindTexture2d(0)}function Ia(T){this.h=T}var Y$=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function nk(T,$){return $+T}function Hc(T,$){window[T]=$}function h0(T){var $=document.createElement("script");return $.setAttribute("src",T),$.setAttribute("crossorigin","anonymous"),new Promise(function(L){$.addEventListener("load",function(){L()},!1),$.addEventListener("error",function(){L()},!1),document.body.appendChild($)})}function wx(){return N(function(T){switch(T.h){case 1:return T.s=2,w(T,WebAssembly.instantiate(Y$),4);case 4:T.h=3,T.s=0;break;case 2:return T.s=0,T.l=null,T.return(!1);case 3:return T.return(!0)}})}function Vr(T){if(this.h=T,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=T&&T.locateFile||nk,typeof window=="object")var $=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")$=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=$,T.options){$=a(Object.keys(T.options));for(var L=$.next();!L.done;L=$.next()){L=L.value;var W=T.options[L].default;W!==void 0&&(this.l[L]=typeof W=="function"?W():W)}}}n=Vr.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function ju(T){var $,L,W,ne,ie,se,_e,Pe,ft,Tt,un;return N(function(Ut){switch(Ut.h){case 1:return T.ga?($=T.h.files===void 0?[]:typeof T.h.files=="function"?T.h.files(T.l):T.h.files,w(Ut,wx(),2)):Ut.return();case 2:if(L=Ut.i,typeof window=="object")return Hc("createMediapipeSolutionsWasm",{locateFile:T.locateFile}),Hc("createMediapipeSolutionsPackedAssets",{locateFile:T.locateFile}),se=$.filter(function(Nt){return Nt.data!==void 0}),_e=$.filter(function(Nt){return Nt.data===void 0}),Pe=Promise.all(se.map(function(Nt){var an=nd(T,Nt.url);if(Nt.path!==void 0){var Bn=Nt.path;an=an.then(function(Ur){return T.overrideFile(Bn,Ur),Promise.resolve(Ur)})}return an})),ft=Promise.all(_e.map(function(Nt){return Nt.simd===void 0||Nt.simd&&L||!Nt.simd&&!L?h0(T.locateFile(Nt.url,T.ha)):Promise.resolve()})).then(function(){var Nt,an,Bn;return N(function(Ur){if(Ur.h==1)return Nt=window.createMediapipeSolutionsWasm,an=window.createMediapipeSolutionsPackedAssets,Bn=T,w(Ur,Nt(an),2);Bn.i=Ur.i,Ur.h=0})}),Tt=function(){return N(function(Nt){return T.h.graph&&T.h.graph.url?Nt=w(Nt,nd(T,T.h.graph.url),0):(Nt.h=0,Nt=void 0),Nt})}(),w(Ut,Promise.all([ft,Pe,Tt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return W=$.filter(function(Nt){return Nt.simd===void 0||Nt.simd&&L||!Nt.simd&&!L}).map(function(Nt){return T.locateFile(Nt.url,T.ha)}),importScripts.apply(null,l(W)),ne=T,w(Ut,createMediapipeSolutionsWasm(Module),6);case 6:ne.i=Ut.i,T.m=new OffscreenCanvas(1,1),T.i.canvas=T.m,ie=T.i.GL.createContext(T.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),T.i.GL.makeContextCurrent(ie),Ut.h=4;break;case 7:if(T.m=document.createElement("canvas"),un=T.m.getContext("webgl2",{}),!un&&(un=T.m.getContext("webgl",{}),!un))return alert("Failed to create WebGL canvas context when passing video frame."),Ut.return();T.K=un,T.i.canvas=T.m,T.i.createContext(T.m,!0,!0,{});case 4:T.j=new T.i.SolutionWasm,T.ga=!1,Ut.h=0}})}function xx(T){var $,L,W,ne,ie,se,_e,Pe;return N(function(ft){if(ft.h==1){if(T.h.graph&&T.h.graph.url&&T.fa===T.h.graph.url)return ft.return();if(T.u=!0,!T.h.graph||!T.h.graph.url){ft.h=2;return}return T.fa=T.h.graph.url,w(ft,nd(T,T.h.graph.url),3)}for(ft.h!=2&&($=ft.i,T.j.loadGraph($)),L=a(Object.keys(T.D)),W=L.next();!W.done;W=L.next())ne=W.value,T.j.overrideFile(ne,T.D[ne]);if(T.D={},T.h.listeners)for(ie=a(T.h.listeners),se=ie.next();!se.done;se=ie.next())_e=se.value,eR(T,_e);Pe=T.l,T.l={},T.setOptions(Pe),ft.h=0})}n.reset=function(){var T=this;return N(function($){T.j&&(T.j.reset(),T.s={},T.v={}),$.h=0})},n.setOptions=function(T,$){var L=this;if($=$||this.h.options){for(var W=[],ne=[],ie={},se=a(Object.keys(T)),_e=se.next();!_e.done;ie={X:ie.X,Y:ie.Y},_e=se.next())if(_e=_e.value,!(_e in this.l&&this.l[_e]===T[_e])){this.l[_e]=T[_e];var Pe=$[_e];Pe!==void 0&&(Pe.onChange&&(ie.X=Pe.onChange,ie.Y=T[_e],W.push(function(ft){return function(){var Tt;return N(function(un){if(un.h==1)return w(un,ft.X(ft.Y),2);Tt=un.i,Tt===!0&&(L.u=!0),un.h=0})}}(ie))),Pe.graphOptionXref&&(_e=Object.assign({},{calculatorName:"",calculatorIndex:0},Pe.graphOptionXref,{valueNumber:Pe.type===1?T[_e]:0,valueBoolean:Pe.type===0?T[_e]:!1,valueString:Pe.type===2?T[_e]:""}),ne.push(_e)))}(W.length!==0||ne.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(ne),this.F=(this.F===void 0?[]:this.F).concat(W))}};function Z$(T){var $,L,W,ne,ie,se,_e;return N(function(Pe){switch(Pe.h){case 1:if(!T.u)return Pe.return();if(!T.F){Pe.h=2;break}$=a(T.F),L=$.next();case 3:if(L.done){Pe.h=5;break}return W=L.value,w(Pe,W(),4);case 4:L=$.next(),Pe.h=3;break;case 5:T.F=void 0;case 2:if(T.H){for(ne=new T.i.GraphOptionChangeRequestList,ie=a(T.H),se=ie.next();!se.done;se=ie.next())_e=se.value,ne.push_back(_e);T.j.changeOptions(ne),ne.delete(),T.H=void 0}T.u=!1,Pe.h=0}})}n.initialize=function(){var T=this;return N(function($){return $.h==1?w($,ju(T),2):$.h!=3?w($,xx(T),3):w($,Z$(T),0)})};function nd(T,$){var L,W;return N(function(ne){return $ in T.L?ne.return(T.L[$]):(L=T.locateFile($,""),W=fetch(L).then(function(ie){return ie.arrayBuffer()}),T.L[$]=W,ne.return(W))})}n.overrideFile=function(T,$){this.j?this.j.overrideFile(T,$):this.D[T]=$},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(T,$){var L=this,W,ne,ie,se,_e,Pe,ft,Tt,un;return N(function(Ut){switch(Ut.h){case 1:return L.h.inputs?(W=1e3*($??performance.now()),w(Ut,L.I,2)):Ut.return();case 2:return w(Ut,L.initialize(),3);case 3:for(ne=new L.i.PacketDataList,ie=a(Object.keys(T)),se=ie.next();!se.done;se=ie.next())if(_e=se.value,Pe=L.h.inputs[_e]){e:{var Nt=T[_e];switch(Pe.type){case"video":var an=L.s[Pe.stream];if(an||(an=new u0(L.i,L.K),L.s[Pe.stream]=an),an.m===0&&(an.m=an.i.createTexture()),typeof HTMLVideoElement<"u"&&Nt instanceof HTMLVideoElement)var Bn=Nt.videoWidth,Ur=Nt.videoHeight;else typeof HTMLImageElement<"u"&&Nt instanceof HTMLImageElement?(Bn=Nt.naturalWidth,Ur=Nt.naturalHeight):(Bn=Nt.width,Ur=Nt.height);Ur={glName:an.m,width:Bn,height:Ur},Bn=an.h,Bn.canvas.width=Ur.width,Bn.canvas.height=Ur.height,Bn.activeTexture(Bn.TEXTURE0),an.i.bindTexture2d(an.m),Bn.texImage2D(Bn.TEXTURE_2D,0,Bn.RGBA,Bn.RGBA,Bn.UNSIGNED_BYTE,Nt),an.i.bindTexture2d(0),an=Ur;break e;case"detections":for(an=L.s[Pe.stream],an||(an=new Ia(L.i),L.s[Pe.stream]=an),an.data||(an.data=new an.h.DetectionListData),an.data.reset(Nt.length),Ur=0;Ur<Nt.length;++Ur){Bn=Nt[Ur];var Wr=an.data,Di=Wr.setBoundingBox,Aa=Ur,Ao=Bn.la,mr=new td;if(Rs(mr,1,Ao.sa),Rs(mr,2,Ao.ta),Rs(mr,3,Ao.height),Rs(mr,4,Ao.width),Rs(mr,5,Ao.rotation),mo(mr,6,Ao.pa),Ao=mr.l(),Di.call(Wr,Aa,Ao),Bn.ea)for(Wr=0;Wr<Bn.ea.length;++Wr){mr=Bn.ea[Wr],Di=an.data,Aa=Di.addNormalizedLandmark,Ao=Ur,mr=Object.assign({},mr,{visibility:mr.visibility?mr.visibility:0});var Ss=new Wp;Rs(Ss,1,mr.x),Rs(Ss,2,mr.y),Rs(Ss,3,mr.z),mr.visibility&&Rs(Ss,4,mr.visibility),mr=Ss.l(),Aa.call(Di,Ao,mr)}if(Bn.ba)for(Wr=0;Wr<Bn.ba.length;++Wr)Di=an.data,Aa=Di.addClassification,Ao=Ur,mr=Bn.ba[Wr],Ss=new ed,Rs(Ss,2,mr.qa),mr.index&&mo(Ss,1,mr.index),mr.label&&mo(Ss,3,mr.label),mr.displayName&&mo(Ss,4,mr.displayName),mr=Ss.l(),Aa.call(Di,Ao,mr)}an=an.data;break e;default:an={}}}switch(ft=an,Tt=Pe.stream,Pe.type){case"video":ne.pushTexture2d(Object.assign({},ft,{stream:Tt,timestamp:W}));break;case"detections":un=ft,un.stream=Tt,un.timestamp=W,ne.pushDetectionList(un);break;default:throw Error("Unknown input config type: '"+Pe.type+"'")}}return L.j.send(ne),w(Ut,L.I,4);case 4:ne.delete(),Ut.h=0}})};function J$(T,$,L){var W,ne,ie,se,_e,Pe,ft,Tt,un,Ut,Nt,an,Bn,Ur;return N(function(Wr){switch(Wr.h){case 1:if(!L)return Wr.return($);for(W={},ne=0,ie=a(Object.keys(L)),se=ie.next();!se.done;se=ie.next())_e=se.value,Pe=L[_e],typeof Pe!="string"&&Pe.type==="texture"&&$[Pe.stream]!==void 0&&++ne;1<ne&&(T.M=!1),ft=a(Object.keys(L)),se=ft.next();case 2:if(se.done){Wr.h=4;break}if(Tt=se.value,un=L[Tt],typeof un=="string")return Bn=W,Ur=Tt,w(Wr,Q$(T,Tt,$[un]),14);if(Ut=$[un.stream],un.type==="detection_list"){if(Ut){for(var Di=Ut.getRectList(),Aa=Ut.getLandmarksList(),Ao=Ut.getClassificationsList(),mr=[],Ss=0;Ss<Di.size();++Ss){var qu=QC(Di.get(Ss)),tR=Vs(qu,1),_x=Vs(qu,2),rk=Vs(qu,3),Xu=Vs(qu,4),f0=Vs(qu,5,0),d0=void 0;d0=d0===void 0?0:d0,qu={la:{sa:tR,ta:_x,height:rk,width:Xu,rotation:f0,pa:Ji($s(qu,6),d0)},ea:c0(Aa.get(Ss)),ba:ek(ZC(Ao.get(Ss)))},mr.push(qu)}Di=mr}else Di=[];W[Tt]=Di,Wr.h=7;break}if(un.type==="proto_list"){if(Ut){for(Di=Array(Ut.size()),Aa=0;Aa<Ut.size();Aa++)Di[Aa]=Ut.get(Aa);Ut.delete()}else Di=[];W[Tt]=Di,Wr.h=7;break}if(Ut===void 0){Wr.h=3;break}if(un.type==="float_list"){W[Tt]=Ut,Wr.h=7;break}if(un.type==="proto"){W[Tt]=Ut,Wr.h=7;break}if(un.type!=="texture")throw Error("Unknown output config type: '"+un.type+"'");return Nt=T.v[Tt],Nt||(Nt=new u0(T.i,T.K),T.v[Tt]=Nt),w(Wr,Io(Nt,Ut,T.M),13);case 13:an=Wr.i,W[Tt]=an;case 7:un.transform&&W[Tt]&&(W[Tt]=un.transform(W[Tt])),Wr.h=3;break;case 14:Bn[Ur]=Wr.i;case 3:se=ft.next(),Wr.h=2;break;case 4:return Wr.return(W)}})}function Q$(T,$,L){var W;return N(function(ne){return typeof L=="number"||L instanceof Uint8Array||L instanceof T.i.Uint8BlobList?ne.return(L):L instanceof T.i.Texture2dDataOut?(W=T.v[$],W||(W=new u0(T.i,T.K),T.v[$]=W),ne.return(Io(W,L,T.M))):ne.return(void 0)})}function eR(T,$){for(var L=$.name||"$",W=[].concat(l($.wants)),ne=new T.i.StringList,ie=a($.wants),se=ie.next();!se.done;se=ie.next())ne.push_back(se.value);ie=T.i.PacketListener.implement({onResults:function(_e){for(var Pe={},ft=0;ft<$.wants.length;++ft)Pe[W[ft]]=_e.get(ft);var Tt=T.listeners[L];Tt&&(T.I=J$(T,Pe,$.outs).then(function(un){un=Tt(un);for(var Ut=0;Ut<$.wants.length;++Ut){var Nt=Pe[W[Ut]];typeof Nt=="object"&&Nt.hasOwnProperty&&Nt.hasOwnProperty("delete")&&Nt.delete()}un&&(T.I=un)}))}}),T.j.attachMultiListener(ne,ie),ne.delete()}n.onResults=function(T,$){this.listeners[$||"$"]=T},z("Solution",Vr),z("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Sx(T){switch(T===void 0&&(T=0),T){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Gp(T){var $=this;T=T||{},this.h=new Vr({locateFile:T.locateFile,files:function(L){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Sx(L.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:c0},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:c0},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(L){var W,ne,ie;return N(function(se){return se.h==1?(W=Sx(L),ne="third_party/mediapipe/modules/pose_landmark/"+W,w(se,nd($.h,W),2)):(ie=se.i,$.h.overrideFile(ne,ie),se.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Gp.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(T){this.h.onResults(T)},n.initialize=function(){var T=this;return N(function($){return w($,T.h.initialize(),0)})},n.send=function(T,$){var L=this;return N(function(W){return w(W,L.h.send(T,$),0)})},n.setOptions=function(T){this.h.setOptions(T)},z("Pose",Gp),z("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),z("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),z("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),z("VERSION","0.5.1675469404")}).call(mt);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Jie=function(n,e){return(Jie=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])})(n,e)};function Qie(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}Jie(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var qr=function(){return(qr=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function ir(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?s(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function or(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&u[0]?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){o.label=u[1];break}if(u[0]===6&&o.label<s[1]){o.label=s[1],s=u;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(u);break}s[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function zm(n,e,t){if(t||arguments.length===2)for(var r,s=0,i=e.length;s<i;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return n.concat(r||Array.prototype.slice.call(e))}var Th=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],e_=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],Rht={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},Pht={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Dht=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],Oht=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function bA(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function eoe(n){return ir(this,void 0,void 0,function(){var e,t;return or(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof qn?[4,rC(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=bA(n.width),e.height=bA(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function toe(n){return ir(this,void 0,void 0,function(){var e,t,r,s,i,o;return or(this,function(a){switch(a.label){case 0:return n instanceof qn?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,rC(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,t]))];case 2:return i=document.createElement("canvas"),o=i.getContext("2d"),i.width=bA(n.width),i.height=bA(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,i.width,i.height)]}})})}function Fht(n){return ir(this,void 0,void 0,function(){var e,t;return or(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,eoe(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,sC(e,4)]}})})}function noe(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var Zx={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},Lht=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,toe(this.mask)]})})},n.prototype.toTensor=function(){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,Fht(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function zht(n){return noe(n),"person"}var Bht=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new $ht.Pose({locateFile:function(s,i){if(e.solutionPath){var o=e.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(s)}return"".concat(i,"/").concat(s)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var i=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(i.segmentation={maskValueToLabel:zht,mask:new Lht(s.segmentationMask)}),r.poses=[i]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(i,o){return{x:i.x*r.width,y:i.y*r.height,z:i.z,score:i.visibility,name:e_[o]}})};return t!=null&&(s.keypoints3D=t.map(function(i,o){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:e_[o]}})),s},n.prototype.estimatePoses=function(e,t,r){return ir(this,void 0,void 0,function(){var s,i;return or(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof qn?(i=ImageData.bind,[4,rC(e)]):[3,2];case 1:return s=new(i.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,o.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return o.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function Vht(n){return ir(this,void 0,void 0,function(){var e,t;return or(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return qr({},Zx);var i=qr({},s);return i.runtime="mediapipe",i.enableSegmentation==null&&(i.enableSegmentation=Zx.enableSegmentation),i.enableSmoothing==null&&(i.enableSmoothing=Zx.enableSmoothing),i.smoothSegmentation==null&&(i.smoothSegmentation=Zx.smoothSegmentation),i.modelType==null&&(i.modelType=Zx.modelType),i}(n),[4,(t=new Bht(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function av(n){return n instanceof qn?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function roe(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function G4(n){return n instanceof qn?n:sC(n)}function soe(n,e,t){return pF(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function pF(n,e){U(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),U(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function X3(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,i=n.locationData,o=i.relativeKeypoints[r].x*e.width,a=i.relativeKeypoints[r].y*e.height,l=i.relativeKeypoints[s].x*e.width,c=i.relativeKeypoints[s].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=function(f,d,p){var m,g=f.locationData,y=p.rotationVectorStartKeypointIndex,b=p.rotationVectorEndKeypointIndex;m=p.rotationVectorTargetAngle?p.rotationVectorTargetAngle:Math.PI*p.rotationVectorTargetAngleDegree/180;var x=g.relativeKeypoints[y].x*d.width,w=g.relativeKeypoints[y].y*d.height,_=g.relativeKeypoints[b].x*d.width,C=g.relativeKeypoints[b].y*d.height;return roe(m-Math.atan2(-(C-w),_-x))}(n,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function ioe(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function K3(n,e,t,r,s,i,o){return n[e][s]*(n[t][i]*n[r][o]-n[t][o]*n[r][i])}function $o(n,e,t){var r=(e+1)%4,s=(e+2)%4,i=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return K3(n,r,s,i,o,a,l)+K3(n,s,i,r,o,a,l)+K3(n,i,r,s,o,a,l)}function Cj(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,i=n;s<i.length;s++){var o=i[s],a=o.x-.5,l=o.y-.5,c=t.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var f=o.z*e.width,d=qr({},o);d.x=u,d.y=h,d.z=f,r.push(d)}return r}function ooe(n,e){var t=function(r,s,i,o){var a=s-r,l=o-i;if(a===0)throw new Error("Original min and max are both ".concat(r,", range cannot be 0."));var c=l/a;return{scale:c,offset:i-r*c}}(0,255,e[0],e[1]);return Se(function(){return qe(fe(n,t.scale),t.offset)})}function mF(n,e,t){var r,s,i,o,a,l,c,u,h,f,d,p,m,g,y=e.outputTensorSize,b=e.keepAspectRatio,x=e.borderMode,w=e.outputTensorFloatRange,_=av(n),C=function(M,I){return I?{xCenter:I.xCenter*M.width,yCenter:I.yCenter*M.height,width:I.width*M.width,height:I.height*M.height,rotation:I.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(_,t),k=function(M,I,N){if(N===void 0&&(N=!1),!N)return{top:0,left:0,right:0,bottom:0};var O=I.height,R=I.width;pF(I,"targetSize"),pF(M,"roi");var D,z,B=O/R,X=M.height/M.width,G=0,ee=0;return B>X?(D=M.width,z=M.width*B,ee=(1-X/B)/2):(D=M.height/B,z=M.height,G=(1-B/X)/2),M.width=D,M.height=z,{top:ee,left:G,right:G,bottom:ee}}(C,y,b),A=(r=C,s=_.width,i=_.height,o=!1,a=r.width,l=r.height,c=o?-1:1,u=Math.cos(r.rotation),h=Math.sin(r.rotation),f=r.xCenter,d=r.yCenter,p=1/s,m=1/i,(g=new Array(16))[0]=a*u*c*p,g[1]=-l*h*p,g[2]=0,g[3]=(-.5*a*u*c+.5*l*h+f)*p,g[4]=a*h*c*m,g[5]=l*u*m,g[6]=0,g[7]=(-.5*l*u-.5*a*h*c+d)*m,g[8]=0,g[9]=0,g[10]=a*p,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,ioe(g));return{imageTensor:Se(function(){var M=G4(n),I=Ga(soe(A,_,y),[1,8]),N=x==="zero"?"constant":"nearest",O=Si.transform(ii(xt(M,"float32")),I,"bilinear",N,0,[y.height,y.width]);return w!=null?ooe(O,w):O}),padding:k,transformationMatrix:A}}function kj(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function Uht(n){return Se(function(){var e=function(s){return Se(function(){return[fn(s,[0,0,0],[1,-1,1]),fn(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:gr(r),logits:gr(t)}})}function aoe(n){return n!=null&&n.currentTime!=null}function Tj(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var a=n[o];t=Math.min(t,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),i=Math.max(i,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:i,width:r-t,height:i-s},e}function Wht(n,e,t,r){return ir(this,void 0,void 0,function(){var s,i,o,a,l;return or(this,function(c){switch(c.label){case 0:return n.sort(function(u,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,u.score)}),s=Ga(n.map(function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]})),i=Xs(n.map(function(u){return u.score[0]})),[4,Si.nonMaxSuppressionAsync(s,i,e,t)];case 1:return[4,(o=c.sent()).array()];case 2:return a=c.sent(),l=n.filter(function(u,h){return a.indexOf(h)>-1}),nn([s,i,o]),[2,l]}})})}function loe(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function Ght(n,e,t){return ir(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,_,C,k,A,M,I;return or(this,function(N){switch(N.label){case 0:if(r=gr(e,[0]),s=r.shape,i=s[0],o=s[1],a=s[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=N.sent(),u=0;u<n.length;u++)if(h=n[u],f=qr({},h),l.push(f),d=Math.trunc(f.x*o),p=Math.trunc(f.y*i),!(d<0||d>=o||p<0||d>=i)){for(m=Math.trunc((t.kernelSize-1)/2),g=Math.max(0,d-m),y=Math.min(o,d+m+1),b=Math.max(0,p-m),x=Math.min(i,p+m+1),w=0,_=0,C=0,k=0,A=b;A<x;++A)for(M=g;M<y;++M)I=c.get(A,M,u),w+=I,k=Math.max(k,I),_+=M*I,C+=A*I;k>=t.minConfidenceToRefine&&w>0&&(f.x=_/o/w,f.y=C/i/w)}return r.dispose(),[2,l]}})})}function Ej(n,e){var t=e.left,r=e.top,s=e.left+e.right,i=e.top+e.bottom;return n.map(function(o){return qr(qr({},o),{x:(o.x-t)/(1-s),y:(o.y-r)/(1-i),z:o.z/(1-s)})})}function Hht(n,e,t){return gS()==="webgl"?function(r,s,i){var o=i.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(o,`);

      setOutput(outputValue);
    }
`)},l=rg();return Se(function(){var c=l.compileAndRun(a,[r,s]);return bo().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):Se(function(){var r=Rt(e,.5),s=Or(r),i=Rt(1,rp(1,fe(s,qe(5.68842,fe(s,qe(-.748699,fe(s,qe(-57.8051,fe(s,qe(291.309,fe(s,-624.717)))))))))));return qe(e,fe(Rt(n,e),fe(i,t.combineWithPreviousRatio)))})}function jht(n,e,t){return ir(this,void 0,void 0,function(){var r,s,i,o,a;return or(this,function(l){switch(l.label){case 0:return r=n[0],s=n[1],i=function(c,u,h){return Se(function(){var f,d,p,m;h.reverseOutputOrder?(d=gr(fn(c,[0,h.boxCoordOffset+0],[-1,1])),f=gr(fn(c,[0,h.boxCoordOffset+1],[-1,1])),m=gr(fn(c,[0,h.boxCoordOffset+2],[-1,1])),p=gr(fn(c,[0,h.boxCoordOffset+3],[-1,1]))):(f=gr(fn(c,[0,h.boxCoordOffset+0],[-1,1])),d=gr(fn(c,[0,h.boxCoordOffset+1],[-1,1])),p=gr(fn(c,[0,h.boxCoordOffset+2],[-1,1])),m=gr(fn(c,[0,h.boxCoordOffset+3],[-1,1]))),d=qe(fe(Ft(d,h.xScale),u.w),u.x),f=qe(fe(Ft(f,h.yScale),u.h),u.y),h.applyExponentialOnBoxSize?(p=fe(Xo(Ft(p,h.hScale)),u.h),m=fe(Xo(Ft(m,h.wScale)),u.w)):(p=fe(Ft(p,h.hScale),u.h),m=fe(Ft(m,h.wScale),u.h));var g=Rt(f,Ft(p,2)),y=Rt(d,Ft(m,2)),b=qe(f,Ft(p,2)),x=qe(d,Ft(m,2)),w=cs([ve(g,[h.numBoxes,1]),ve(y,[h.numBoxes,1]),ve(b,[h.numBoxes,1]),ve(x,[h.numBoxes,1])],1);if(h.numKeypoints)for(var _=0;_<h.numKeypoints;++_){var C=h.keypointCoordOffset+_*h.numValuesPerKeypoint,k=void 0,A=void 0;h.reverseOutputOrder?(k=gr(fn(c,[0,C],[-1,1])),A=gr(fn(c,[0,C+1],[-1,1]))):(A=gr(fn(c,[0,C],[-1,1])),k=gr(fn(c,[0,C+1],[-1,1])));var M=qe(fe(Ft(k,h.xScale),u.w),u.x),I=qe(fe(Ft(A,h.yScale),u.h),u.y);w=cs([w,ve(M,[h.numBoxes,1]),ve(I,[h.numBoxes,1])],1)}return w})}(s,e,t),o=Se(function(){var c=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=va(r,-t.scoreClippingThresh,t.scoreClippingThresh)),c=Il(c)):c}),[4,qht(i,o,t)];case 1:return a=l.sent(),nn([i,o]),[2,a]}})})}function qht(n,e,t){return ir(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p;return or(this,function(m){switch(m.label){case 0:return r=[],[4,n.data()];case 1:return s=m.sent(),[4,e.data()];case 2:for(i=m.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&i[o]<t.minScoreThresh||(a=o*t.numCoords,l=Xht(s[a+0],s[a+1],s[a+2],s[a+3],i[o],t.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,f=0;f<h;f+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+f,p={x:s[d+0],y:t.flipVertically?1-s[d+1]:s[d+1]},u.relativeKeypoints.push(p);r.push(l)}return[2,r]}})})}function Xht(n,e,t,r,s,i,o){return{score:[s],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-t:n,xMax:r,yMax:i?1-n:t,width:r-e,height:t-n}}}}function Kht(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Ij(n,e,t,r){return ir(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h;return or(this,function(f){switch(f.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,i=s/e.numLandmarks,[4,n.data()];case 1:for(o=f.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*i,(h={x:0,y:0}).x=t?e.inputImageWidth-o[c]:o[c],i>1&&(h.y=r?e.inputImageHeight-o[c+1]:o[c+1]),i>2&&(h.z=o[c+2]),i>3&&(h.score=Kht(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Aj(n,e,t){var r=n.width,s=n.height,i=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(i=function(u,h){return h.rotation!=null?u+=h.rotation:h.rotationDegree!=null&&(u+=Math.PI*h.rotationDegree/180),roe(u)}(i,t)),i===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var o=(e.width*r*t.shiftX*Math.cos(i)-e.height*s*t.shiftY*Math.sin(i))/e.width,a=(e.width*r*t.shiftX*Math.sin(i)+e.height*s*t.shiftY*Math.cos(i))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+a}if(t.squareLong){var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}else if(t.squareShort){var c=Math.min(r*e.width,s*e.height);r=c/e.width,s=c/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function Yht(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var Fd=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Y3=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Fd(this.getAlpha(this.minCutOff)),this.dx=new Fd(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,o=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),gF=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return zm([],e,!0);i=1/r}return e.map(function(o,a){var l=qr(qr({},o),{x:s.xFilters[a].apply(o.x,t,i),y:s.yFilters[a].apply(o.y,t,i)});return o.z!=null&&(l.z=s.zFilters[a].apply(o.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Y3(t.config)}),this.yFilters=e.map(function(r){return new Y3(t.config)}),this.zFilters=e.map(function(r){return new Y3(t.config)}))},n}(),Z3=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Fd(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(this.lastTimestamp===-1)s=1;else{for(var o=e*r-this.lastValue*this.lastValueScale,a=i-this.lastTimestamp,l=o,c=a,u=(1+this.window.length)*(1e6/30),h=0,f=this.window;h<f.length;h++){var d=f[h];if(c+d.duration>u)break;l+=d.distance,c+=d.duration}var p=l/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,s)},n}(),Zht=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return zm([],e,!0);i=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(o,a){var l=qr(qr({},o),{x:s.xFilters[a].apply(o.x,t,i),y:s.yFilters[a].apply(o.y,t,i)});return o.z!=null&&(l.z=s.zFilters[a].apply(o.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Z3(t.config)}),this.yFilters=e.map(function(r){return new Z3(t.config)}),this.zFilters=e.map(function(r){return new Z3(t.config)}))},n}(),J3=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new Zht(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new gF(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,i){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var o=i!=null?function(c,u){return(c.width*u.width+c.height*u.height)/2}(i,r):1,a=s?loe(e,r):e,l=this.keypointsFilter.apply(a,t,o);return s?Yht(l,r):l},n}(),Mj=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Fd(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var i=e[s],o=qr({},i);o.score=this.visibilityFilters[s].apply(i.score),r.push(o)}return r},n}(),Jht={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},L0={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Qht={maxPoses:1,flipHorizontal:!1},eft={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},tft=.3,Nj={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},nft={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},rft={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},sft={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},ift={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},oft={kernelSize:7,minConfidenceToRefine:.5},$j={alpha:.1},aft={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},lft={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},cft={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},uft={activation:"none"},hft={combineWithPreviousRatio:.7},fft=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,eoe(this.mask)]})})},n.prototype.toImageData=function(){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,toe(this.mask)]})})},n.prototype.toTensor=function(){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function dft(n){return noe(n),"person"}var pft=function(){function n(e,t,r,s,i,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=i,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var f=[],d=0;d<h.numLayers;){for(var p=[],m=[],g=[],y=[],b=d;b<h.strides.length&&h.strides[b]===h.strides[d];){var x=kj(h.minScale,h.maxScale,b,h.strides.length);if(b===0&&h.reduceBoxesInLowestLayer)g.push(1),g.push(2),g.push(.5),y.push(.1),y.push(x),y.push(x);else{for(var w=0;w<h.aspectRatios.length;++w)g.push(h.aspectRatios[w]),y.push(x);if(h.interpolatedScaleAspectRatio>0){var _=b===h.strides.length-1?1:kj(h.minScale,h.maxScale,b+1,h.strides.length);y.push(Math.sqrt(x*_)),g.push(h.interpolatedScaleAspectRatio)}}b++}for(var C=0;C<g.length;++C){var k=Math.sqrt(g[C]);p.push(y[C]/k),m.push(y[C]*k)}var A=0,M=0;if(h.featureMapHeight.length>0)A=h.featureMapHeight[d],M=h.featureMapWidth[d];else{var I=h.strides[d];A=Math.ceil(h.inputSizeHeight/I),M=Math.ceil(h.inputSizeWidth/I)}for(var N=0;N<A;++N)for(var O=0;O<M;++O)for(var R=0;R<p.length;++R){var D={xCenter:(O+h.anchorOffsetX)/M,yCenter:(N+h.anchorOffsetY)/A,width:0,height:0};h.fixedAnchorSize?(D.width=1,D.height=1):(D.width=m[R],D.height=p[R]),f.push(D)}d=b}return f}(Jht);var a=Xs(this.anchors.map(function(h){return h.width})),l=Xs(this.anchors.map(function(h){return h.height})),c=Xs(this.anchors.map(function(h){return h.xCenter})),u=Xs(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:c,y:u,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?Ga([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return ir(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,_,C,k,A,M,I;return or(this,function(N){switch(N.label){case 0:return s=function(O){var R;if((R=O==null?Qht:qr({},O)).maxPoses==null&&(R.maxPoses=1),R.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(R.maxPoses,". Should be > 0."));if(R.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return R}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:aoe(e)?1e6*e.currentTime:null,i=av(e),o=Se(function(){return xt(G4(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=N.sent()).length===0)return this.reset(),o.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,i),N.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return u=N.sent(),o.dispose(),u==null?(this.reset(),[2,[]]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,g=this.poseLandmarkFiltering(h,f,p,i),y=g.actualLandmarksFiltered,b=g.auxiliaryLandmarksFiltered,x=g.actualWorldLandmarksFiltered,w=this.poseLandmarksToRoi(b,i),this.regionOfInterest=w,_=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(C=y!=null?loe(y,i):null)!=null&&C.forEach(function(O,R){O.name=e_[R]}),(k=x)!=null&&k.forEach(function(O,R){O.name=e_[R]}),A={score:d,keypoints:C,keypoints3D:k},_!==null&&(M=Se(function(){var O=ii(_,2),R=wu(O,[[0,0],[0,0],[0,1]]);return iz(R,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||nn(_),I={maskValueToLabel:dft,mask:new fft(M)},A.segmentation=I),[2,[A]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=Hht(t,e,hft),nn(e)),nn(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),nn([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(nn(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Ga([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return ir(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c,u,h;return or(this,function(f){switch(f.label){case 0:return t=mF(e,nft),r=t.imageTensor,s=t.padding,i=this.detectorModel.predict(r),o=Uht(i),a=o.boxes,[4,jht([l=o.logits,a],this.anchorTensor,eft)];case 1:return(c=f.sent()).length===0?(nn([r,i,l,a]),[2,c]):[4,Wht(c,this.maxPoses,tft)];case 2:return u=f.sent(),h=function(d,p){d===void 0&&(d=[]);for(var m=p.left,g=p.top,y=p.left+p.right,b=p.top+p.bottom,x=0;x<d.length;x++){var w=d[x],_=w.locationData.relativeBoundingBox,C=(_.xMin-m)/(1-y),k=(_.yMin-g)/(1-b),A=_.width/(1-y),M=_.height/(1-b);_.xMin=C,_.yMin=k,_.width=A,_.height=M,_.xMax=C+A,_.yMax=k+M;var I=w.locationData.relativeKeypoints;I&&I.forEach(function(N){var O=(N.x-m)/(1-y),R=(N.y-g)/(1-b);N.x=O,N.y=R})}return d}(u,s),nn([r,i,l,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return Aj(X3(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Nj)},n.prototype.poseLandmarksByRoi=function(e,t){return ir(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p,m,g;return or(this,function(y){switch(y.label){case 0:if(r=av(t),s=mF(t,rft,e),i=s.imageTensor,o=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(i,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(u=y.sent())==null?(nn(c),nn(i),[2,null]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,o,a,h,f,p,m)]);case 2:return g=y.sent(),nn(c),nn(i),[2,qr({poseScore:d},g)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,i,o,a,l){return ir(this,void 0,void 0,function(){var c,u,h,f,d,p;return or(this,function(m){return c=Ej(i,r),u=Ej(o,r),h=Cj(c,t),f=Cj(u,t),d=function(g,y){for(var b=[],x=0,w=g;x<w.length;x++){var _=w[x],C=_.x,k=_.y,A=y.rotation,M=Math.cos(A)*C-Math.sin(A)*k,I=Math.sin(A)*C+Math.cos(A)*k,N=qr({},_);N.x=M,N.y=I,b.push(N)}return b}(a,t),p=null,this.enableSegmentation&&(p=Se(function(){var g=l.shape,y=g[0],b=g[1],x=function(C){var k=ioe(new Array(16).fill(0));k[0][0]=$o(C,0,0),k[1][0]=-$o(C,0,1),k[2][0]=$o(C,0,2),k[3][0]=-$o(C,0,3),k[0][2]=$o(C,2,0),k[1][2]=-$o(C,2,1),k[2][2]=$o(C,2,2),k[3][2]=-$o(C,2,3),k[0][1]=-$o(C,1,0),k[1][1]=$o(C,1,1),k[2][1]=-$o(C,1,2),k[3][1]=$o(C,1,3),k[0][3]=-$o(C,3,0),k[1][3]=$o(C,3,1),k[2][3]=-$o(C,3,2),k[3][3]=$o(C,3,3);for(var A=C[0][0]*k[0][0]+C[1][0]*k[0][1]+C[2][0]*k[0][2]+C[3][0]*k[0][3],M=0;M<k.length;M++)for(var I=0;I<k.length;I++)k[M][I]/=A;return k}(s),w=Ga(soe(x,{width:b,height:y},e),[1,8]),_=[1,y,b,1];return gr(Si.transform(ve(l,_),w,"bilinear","constant",0,[e.height,e.width]),[0,3])}),nn(l)),[2,{landmarks:h,auxiliaryLandmarks:f,worldLandmarks:d,segmentationMask:p}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return ir(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c,u,h,f,d,p;return or(this,function(m){switch(m.label){case 0:return t=e[0],r=e[1],s=e[2],i=e[3],o=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,Ij(t,sft)];case 2:return[4,Ght(m.sent(),s,oft)];case 3:return l=m.sent(),c=l.slice(0,33),u=l.slice(33,35),[4,Ij(i,ift)];case 4:return h=m.sent(),f=h.slice(0,33),d=function(g,y,b){b===void 0&&(b=!0);for(var x=[],w=0;w<g.length;w++){var _=qr({},y[w]);b&&(_.score=g[w].score),x.push(_)}return x}(c,f,!0),p=this.enableSegmentation?function(g,y,b){return Se(function(){var x=gr(g,[0]),w=x.shape[2];if(w===1){var _=x;switch(y.activation){case"none":break;case"sigmoid":_=Il(_);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(y.activation,")"))}var C=b?Si.resizeBilinear(_,[b.height,b.width]):_;return gr(C,[2])}throw new Error("Unsupported number of tensor channels ".concat(w))})}(o,uft):null,[2,{landmarks:c,auxiliaryLandmarks:u,poseScore:a,worldLandmarks:d,segmentationMask:p}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return Aj(X3(Tj(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Nj)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var i,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=X3(Tj(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new Mj($j)),i=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new Mj($j)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new J3(aft)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new J3(lft)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new J3(cft)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else i=e,o=t,a=r;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},n}();function mft(n){return ir(this,void 0,void 0,function(){var e,t,r,s,i,o;return or(this,function(a){switch(a.label){case 0:return e=function(l){var c=qr({},l??L0);if(c.enableSmoothing==null&&(c.enableSmoothing=L0.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=L0.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=L0.smoothSegmentation),c.modelType==null&&(c.modelType=L0.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=L0.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Pl(e.detectorModelUrl,{fromTFHub:t}),Pl(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),i=s[0],o=s[1],[2,new pft(i,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Km,so,coe=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var i=s[r];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),i=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(s.length!==0){for(var c=-1,u=-1,h=0,f=s;h<f.length;h++){var d=f[h],p=t[l][d];p>=this.minSimilarity&&p>u&&(c=d,u=p)}if(c>=0){var m=this.tracks[c];m=Object.assign(m,this.createTrack(e[l],r,m.id)),e[l].id=m.id;var g=s.indexOf(c);s.splice(g,1)}else i.push(l)}else i.push(l)}for(var y=0,b=i;y<b.length;y++){l=b[y];var x=this.createTrack(e[l],r);this.tracks.push(x),e[l].id=x.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:zm([],e.keypoints,!0).map(function(i){return qr({},i)})};return e.box!==void 0&&(s.box=qr({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),gft=function(n){function e(t){return n.call(this,t)||this}return Qie(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(i){return r.iou(s,i)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),i=Math.max(t.box.yMin,r.box.yMin),o=Math.min(t.box.xMax,r.box.xMax),a=Math.min(t.box.yMax,r.box.yMax);if(s>=o||i>=a)return 0;var l=(o-s)*(a-i);return l/(t.box.width*t.box.height+r.box.width*r.box.height-l)},e}(coe),yft=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return Qie(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,i=t;s<i.length;s++){for(var o=i[s],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}r.push(a)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,i=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),h=2*this.keypointFalloff[a];i+=Math.exp(-1*u/(2*s*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:i/o},e.prototype.area=function(t){var r=this,s=t.filter(function(l){return l.score>r.keypointThreshold}),i=Math.min.apply(Math,zm([1],s.map(function(l){return l.x}),!1)),o=Math.max.apply(Math,zm([0],s.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,zm([1],s.map(function(l){return l.y}),!1));return(o-i)*(Math.max.apply(Math,zm([0],s.map(function(l){return l.y}),!1))-a)},e}(coe);function uoe(n){switch(n){case so.BlazePose:return e_.reduce(function(e,t,r){return e[t]=r,e},{});case so.PoseNet:case so.MoveNet:return Th.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Km||(Km={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(so||(so={}));var Rj=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case so.BlazePose:return Rht;case so.PoseNet:case so.MoveNet:return Pht;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case so.BlazePose:return Oht;case so.PoseNet:case so.MoveNet:return Dht;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:uoe}),Pj=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],hoe={modelType:"SinglePose.Lightning",enableSmoothing:!0},Dj={},Oj={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Q3={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Fj={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function bft(n,e,t,r){for(var s={},i=0,o=Th;i<o.length;i++){var a=o[i];s[a]=[e[t[a]].y*r.height,e[t[a]].x*r.width]}if(function(b,x){return(b[x.left_hip].score>.2||b[x.right_hip].score>.2)&&(b[x.left_shoulder].score>.2||b[x.right_shoulder].score>.2)}(e,t)){var l=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,u=function(b,x,w,_,C){for(var k=["left_shoulder","right_shoulder","left_hip","right_hip"],A=0,M=0,I=0;I<k.length;I++)(z=Math.abs(_-w[k[I]][0]))>A&&(A=z),(B=Math.abs(C-w[k[I]][1]))>M&&(M=B);for(var N=0,O=0,R=0,D=Object.keys(w);R<D.length;R++){var z,B,X=D[R];b[x[X]].score<.2||((z=Math.abs(_-w[X][0]))>N&&(N=z),(B=Math.abs(C-w[X][1]))>O&&(O=B))}return[A,M,N,O]}(e,t,s,l,c),h=u[0],f=u[1],d=u[2],p=u[3],m=Math.max(1.9*f,1.9*h,1.2*d,1.2*p),g=[l-(m=Math.min(m,Math.max(c,r.width-c,l,r.height-l))),c-m];if(m>Math.max(r.width,r.height)/2)return yF(n==null,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return yF(n==null,r)}function yF(n,e){var t,r,s,i;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,i=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,i=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,i=0):(t=1,r=e.height/e.width,s=0,i=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:i,yMax:s+t,xMax:i+r,height:t,width:r}}function vft(n){var e,t=n==null?hoe:qr({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(Pj.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(Pj));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Km.BoundingBox),t.trackerType===Km.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=Lj(Q3,r);return s.keypointTrackerParams=qr({},Q3.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=Q3;else{if(t.trackerType!==Km.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Lj(Fj,e)):t.trackerConfig=Fj}return t}function Lj(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var wft=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=uoe(so.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new gF(Oj),this.cropRegionFilterYMin=new Fd(.9),this.cropRegionFilterXMin=new Fd(.9),this.cropRegionFilterYMax=new Fd(.9),this.cropRegionFilterXMax=new Fd(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Km.Keypoint?this.tracker=new yft(t.trackerConfig):t.trackerType===Km.BoundingBox&&(this.tracker=new gft(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return ir(this,void 0,void 0,function(){var t,r,s,i,o;return or(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return gS()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=a.sent(),a.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},i=0,o=0;o<17;++o)s.keypoints[o]={y:r[3*o],x:r[3*o+1],score:r[3*o+2]},s.keypoints[o].score>.2&&(++i,s.score+=s.keypoints[o].score);return i>0&&(s.score/=i),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return ir(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c;return or(this,function(u){switch(u.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return gS()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=u.sent(),u.label=3;case 3:for(t.dispose(),s=[],i=r.length/56,o=0;o<i;++o)for(s[o]={keypoints:[]},a=56*o+51,s[o].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*o+55,s[o].score=r[l],s[o].keypoints=[],c=0;c<17;++c)s[o].keypoints[c]={y:r[56*o+3*c],x:r[56*o+3*c+1],score:r[56*o+3*c+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=Dj),ir(this,void 0,void 0,function(){var s,i,o,a,l,c;return or(this,function(u){switch(u.label){case 0:return t=function(h){return h==null?Dj:qr({},h)}(t),e==null?(this.reset(),[2,[]]):(r==null?aoe(e)&&(r=1e6*e.currentTime):r*=1e3,s=G4(e),i=av(s),o=ii(s,0),e instanceof qn||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,i,r)]);case 1:return a=u.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,i,r)];case 3:a=u.sent(),u.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Th[c],a[l].keypoints[c].y*=i.height,a[l].keypoints[c].x*=i.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,r){return ir(this,void 0,void 0,function(){var s,i,o,a,l=this;return or(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=yF(this.cropRegion==null,t)),s=Se(function(){var u=Ga([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=ms([1],"int32"),f=[l.modelInputResolution.height,l.modelInputResolution.width];return xt(Si.cropAndResize(e,u,h,f,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(i=c.sent(),s.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<i.keypoints.length;++o)i.keypoints[o].y=this.cropRegion.yMin+i.keypoints[o].y*this.cropRegion.height,i.keypoints[o].x=this.cropRegion.xMin+i.keypoints[o].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,r,1)),a=bft(this.cropRegion,i.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[i]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return ir(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m=this;return or(this,function(g){switch(g.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=Si.resizeBilinear(e,[o,i]),l=i,c=32*Math.ceil(o/32),a=wu(s,[[0,0],[0,c-o],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,s=Si.resizeBilinear(e,[o,i]),l=32*Math.ceil(i/32),c=o,a=wu(s,[[0,0],[0,0],[0,l-i],[0,0]])),s.dispose(),e.dispose(),u=xt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(u)];case 1:for(h=g.sent(),u.dispose(),h=h.filter(function(y){return y.score>=m.minPoseScore}),d=0;d<h.length;++d)for(f=0;f<h[d].keypoints.length;++f)h[d].keypoints[f].y*=c/o,h[d].keypoints[f].x*=l/i;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new gF(Oj)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,r,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(y,b){p.has(b)||m.keypointFilterMap.delete(b)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:i,height:s-t,width:i-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function xft(n){return n===void 0&&(n=hoe),ir(this,void 0,void 0,function(){var e,t,r,s;return or(this,function(i){switch(i.label){case 0:return e=vft(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Pl(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=i.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Pl(s,{fromTFHub:r})];case 3:t=i.sent(),i.label=4;case 4:return gS()==="webgl"&&Ee().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new wft(t,e)]}})})}var zj={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Bj=["MobileNetV1","ResNet50"],Vj={MobileNetV1:[8,16],ResNet50:[16]},Sft=[8,16,32],Uj={MobileNetV1:[.5,.75,1],ResNet50:[1]},Wj=[1,2,4],Gj={maxPoses:1,flipHorizontal:!1},_ft={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},Cft=[-123.15,-115.9,-103.06];function eP(n){return Math.floor(n/2)}var kft=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(eP(e),e);)this.exchange(e,eP(e)),e=eP(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function Tft(n,e,t,r,s,i){for(var o=i.shape,a=o[0],l=o[1],c=!0,u=Math.max(t-s,0),h=Math.min(t+s+1,a),f=u;f<h;++f){for(var d=Math.max(r-s,0),p=Math.min(r+s+1,l),m=d;m<p;++m)if(i.get(f,m,n)>e){c=!1;break}if(!c)break}return c}function Eft(n){return ir(this,void 0,void 0,function(){return or(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function foe(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function doe(n,e,t){var r=foe(n.heatmapY,n.heatmapX,n.id,t),s=r.y,i=r.x;return{x:n.heatmapX*e+i,y:n.heatmapY*e+s}}function poe(n,e,t,r){var s=t.x,i=t.y;return n.some(function(o){var a,l,c,u,h,f,d=o.keypoints;return a=i,l=s,c=d[r].y,u=d[r].x,(h=c-a)*h+(f=u-l)*f<=e})}var Hj=Th.reduce(function(n,e,t){return n[e]=t,n},{}),moe=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[Hj[e],Hj[t]]}),tP=moe.map(function(n){return n[1]}),jj=moe.map(function(n){return n[0]});function qj(n,e,t){return n<e?e:n>t?t:n}function nP(n,e,t,r){return{y:qj(Math.round(n.y/e),0,t-1),x:qj(Math.round(n.x/e),0,r-1)}}function Xj(n,e){return{x:n.x+e.x,y:n.y+e.y}}function Kj(n,e,t,r,s,i,o,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},f=Xj(h,function(b,x,w){var _=w.shape[2]/2;return{y:w.get(x.y,x.x,b),x:w.get(x.y,x.x,_+b)}}(n,nP(h,i,c,u),o)),d=0;d<a;d++){var p=nP(f,i,c,u),m=foe(p.y,p.x,t,s);f=Xj({x:p.x*i,y:p.y*i},{x:m.x,y:m.y})}var g=nP(f,i,c,u),y=r.get(g.y,g.x,t);return{y:f.y,x:f.x,name:Th[t],score:y}}function Ift(n,e,t,r,s,i){var o=e.shape[2],a=tP.length,l=new Array(o),c=n.part,u=n.score,h=doe(c,r,t);l[c.id]={score:u,name:Th[c.id],y:h.y,x:h.x};for(var f=a-1;f>=0;--f){var d=tP[f],p=jj[f];l[d]&&!l[p]&&(l[p]=Kj(f,l[d],p,e,t,r,i))}for(f=0;f<a;++f)d=jj[f],p=tP[f],l[d]&&!l[p]&&(l[p]=Kj(f,l[d],p,e,t,r,s));return l}function Aft(n,e,t){return t.reduce(function(r,s,i){var o=s.y,a=s.x,l=s.score;return poe(n,e,{y:o,x:a},i)||(r+=l),r},0)/t.length}function Mft(n,e,t,r,s,i,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),ir(this,void 0,void 0,function(){var l,c,u,h,f,d,p,m,g,y,b,x;return or(this,function(w){switch(w.label){case 0:return[4,Eft([n,e,t,r])];case 1:for(l=w.sent(),c=l[0],u=l[1],h=l[2],f=l[3],d=[],p=function(_,C,k){for(var A=k.shape,M=A[0],I=A[1],N=A[2],O=new kft(M*I*N,function(X){return X.score}),R=0;R<M;++R)for(var D=0;D<I;++D)for(var z=0;z<N;++z){var B=k.get(R,D,z);B<_||Tft(z,B,R,D,C,k)&&O.enqueue({score:B,part:{heatmapY:R,heatmapX:D,id:z}})}return O}(o,1,c),m=a*a;d.length<i&&!p.empty();)g=p.dequeue(),y=doe(g.part,s,u),poe(d,m,y,g.part.id)||(b=Ift(g,c,u,s,h,f),x=Aft(d,m,b),d.push({keypoints:b,score:x}));return[2,d]}})})}function goe(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var Nft=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Dt(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(goe("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function $ft(n,e){if(rg()instanceof Fw)return function(t,r){var s=rg(),i=new Nft(r.shape),o=s.runWebGPUProgram(i,[t,r],"float32");return bo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var Rft=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Dt(t),this.dispatch=_t(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(goe("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function Pft(n,e){if(rg()instanceof Fw)return function(t,r){var s=rg(),i=new Rft(t.shape),o=s.runWebGPUProgram(i,[t,r],"float32");return bo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function yoe(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return Se(function(){var i,o,a=ve(n,[t*r,s]),l=sg(a,0),c=ii(Ft(l,en(r,"int32")),1),u=ii((i=l,o=r,Se(function(){var h=Ft(i,en(o,"int32"));return Rt(i,fe(h,en(o,"int32")))})),1);return cs([c,u],1)})}function Dft(n,e,t){return Se(function(){var r=function(s,i){for(var o=[],a=0;a<Th.length;a++){var l=s.get(a,0).valueOf(),c=s.get(a,1).valueOf(),u=Oft(l,c,a,i),h=u.x,f=u.y;o.push(f),o.push(h)}return Ga(o,[Th.length,2])}(n,t);return qe(xt(fe(n.toTensor(),en(e,"int32")),"float32"),r)})}function Oft(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+Th.length)}}function Fft(n,e,t){return ir(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f;return or(this,function(d){switch(d.label){case 0:return r=0,s=yoe(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return i=d.sent(),o=i[0],a=i[1],l=i[2],[4,(c=Dft(l,t,a)).buffer()];case 2:return u=d.sent(),h=Array.from(function(p,m){for(var g=m.shape[0],y=new Float32Array(g),b=0;b<g;b++){var x=m.get(b,0),w=m.get(b,1);y[b]=p.get(x,w,b)}return y}(o,l)),f=h.map(function(p,m){return r+=p,{y:u.get(m,0),x:u.get(m,1),score:p,name:Th[m]}}),s.dispose(),c.dispose(),[2,{keypoints:f,score:r/f.length}]}})})}function Lft(n,e,t){return ir(this,void 0,void 0,function(){var r,s,i;return or(this,function(o){return r=yoe(n),s=function(a,l,c){return Se(function(){var u=Pft(a,c);return qe(xt(fe(a,en(l,"int32")),"float32"),u)})}(r,t,e),i=$ft(n,r),[2,[s,i]]})})}function Yj(n,e){return(n-1)%e==0}var Zj="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Jj="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Qj(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var e8=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;U(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,i,o=(s=t.inputResolution,i=t.outputStride,{height:Qj(s.height,i),width:Qj(s.width,i)});(function(a){U(Sft.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(a,l){U(Yj(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),U(Yj(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=Gj),ir(this,void 0,void 0,function(){return or(this,function(r){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,r){return t===void 0&&(t=Gj),r===void 0&&(r=!1),ir(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,_;return or(this,function(C){switch(C.label){case 0:return s=function(k){var A=k;if(A.maxPoses==null&&(A.maxPoses=1),A.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(A.maxPoses,". Should be > 0."));if(A.maxPoses>1){if((A=qr(qr({},_ft),A)).scoreThreshold<0||A.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(A.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(A.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(A.nmsRadius,"."))}return A}(t),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,i=mF(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=i.imageTensor,a=i.padding,l=this.architecture==="ResNet50"?qe(o,Cft):ooe(o,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(u=gr(c[2],[0]),h=gr(c[3],[0]),f=gr(c[0],[0]),d=gr(c[1],[0])):(u=gr(c[0],[0]),h=gr(c[1],[0]),f=gr(c[2],[0]),d=gr(c[3],[0])),p=Il(h),this.maxPoses!==1?[3,5]:r?[4,Lft(p,u,this.outputStride)]:[3,2]);case 1:return g=C.sent(),b=g[0],y=g[1],m=[b,y],[3,4];case 2:return[4,Fft(p,u,this.outputStride)];case 3:b=C.sent(),m=[b],C.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,Mft(p,u,f,d,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:m=C.sent(),C.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");x=this.getCanvasInfo(av(e),this.inputResolution,a)}else _=av(e),w=function(k,A,M,I){var N=A.height,O=A.width,R=N/(M.height*(1-I.top-I.bottom)),D=O/(M.width*(1-I.left-I.right)),z=-I.top*M.height,B=-I.left*M.width;if(D===1&&R===1&&z===0&&B===0)return k;for(var X=0,G=k;X<G.length;X++)for(var ee=0,pe=G[X].keypoints;ee<pe.length;ee++){var oe=pe[ee];oe.x=(oe.x+B)*D,oe.y=(oe.y+z)*R}return k}(m,_,this.inputResolution,a),s.flipHorizontal&&(w=function(k,A){for(var M=0,I=k;M<I.length;M++)for(var N=0,O=I[M].keypoints;N<O.length;N++){var R=O[N];R.x=A.width-1-R.x}return k}(w,_));return o.dispose(),l.dispose(),nn(c),u.dispose(),h.dispose(),f.dispose(),d.dispose(),p.dispose(),[2,r?[m,x]:w]}})})},n.prototype.getCanvasInfo=function(e,t,r){var s=e.height,i=e.width,o=s/(t.height*(1-r.top-r.bottom)),a=i/(t.width*(1-r.left-r.right)),l=-r.top*t.height;return[-r.left*t.width,l,a,o,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function zft(n){return n===void 0&&(n=zj),ir(this,void 0,void 0,function(){var e,t,r,s,i;return or(this,function(o){switch(o.label){case 0:return(e=function(u){var h=u||zj;if(h.architecture==null&&(h.architecture="MobileNetV1"),Bj.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(Bj));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),Vj[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(Vj[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),Uj[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(Uj[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),Wj.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(Wj," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),t=l===4?Jj+"float/"+c:Jj+"quant".concat(l,"/")+c,[4,Pl(e.modelUrl||t)]);case 1:return r=o.sent(),[2,new e8(r,e)];case 2:return s=function(u,h,f){var d={1:"100",.75:"075",.5:"050"},p="model-stride".concat(u,".json");return f===4?Zj+"float/".concat(d[h],"/")+p:Zj+"quant".concat(f,"/").concat(d[h],"/")+p}(e.outputStride,e.multiplier,e.quantBytes),[4,Pl(e.modelUrl||s)];case 3:return i=o.sent(),[2,new e8(i,e)]}var a,l,c})})}function Bft(n,e){return ir(this,void 0,void 0,function(){var t,r;return or(this,function(s){switch(n){case so.PoseNet:return[2,zft(e)];case so.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,mft(e)];if(t.runtime==="mediapipe")return[2,Vht(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case so.MoveNet:return[2,xft(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}var H4={},j4={},q4={};const X4="125",Sf={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},_f={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},boe=0,bF=1,voe=2,Vft=3,Uft=0,K4=1,woe=2,wb=3,Qw=0,pi=1,DC=2,Y4=1,Wft=2,Nf=0,$b=1,vF=2,wF=3,xF=4,xoe=5,Rm=100,Soe=101,_oe=102,SF=103,_F=104,Coe=200,koe=201,Toe=202,Eoe=203,Z4=204,J4=205,Ioe=206,Aoe=207,Moe=208,Noe=209,$oe=210,Roe=0,Poe=1,Doe=2,vA=3,Ooe=4,Foe=5,Loe=6,zoe=7,OC=0,Boe=1,Voe=2,Ym=0,Uoe=1,Woe=2,Goe=3,Hoe=4,joe=5,T$=300,FC=301,LC=302,wA=303,xA=304,ex=306,zC=307,t_=1e3,fa=1001,n_=1002,Bi=1003,SA=1004,Gft=1004,_A=1005,Hft=1005,ao=1006,Q4=1007,jft=1007,tx=1008,qft=1008,nx=1009,qoe=1010,Xoe=1011,r_=1012,Koe=1013,tS=1014,Tf=1015,s_=1016,Yoe=1017,Zoe=1018,Joe=1019,Rb=1020,Qoe=1021,jd=1022,Ml=1023,eae=1024,tae=1025,nae=Ml,Zm=1026,lv=1027,rae=1028,sae=1029,iae=1030,oae=1031,aae=1032,lae=1033,CF=33776,kF=33777,TF=33778,EF=33779,IF=35840,AF=35841,MF=35842,NF=35843,cae=36196,$F=37492,RF=37496,uae=37808,hae=37809,fae=37810,dae=37811,pae=37812,mae=37813,gae=37814,yae=37815,bae=37816,vae=37817,wae=37818,xae=37819,Sae=37820,_ae=37821,Cae=36492,kae=37840,Tae=37841,Eae=37842,Iae=37843,Aae=37844,Mae=37845,Nae=37846,$ae=37847,Rae=37848,Pae=37849,Dae=37850,Oae=37851,Fae=37852,Lae=37853,zae=2200,Bae=2201,Vae=2202,i_=2300,nS=2301,QE=2302,Bm=2400,Vm=2401,o_=2402,E$=2500,eV=2501,Uae=0,Xft=1,Kft=2,Sa=3e3,BC=3001,I$=3007,A$=3002,Wae=3003,tV=3004,nV=3005,rV=3006,Gae=3200,Hae=3201,Yy=0,jae=1,Yft=0,eI=7680,Zft=7681,Jft=7682,Qft=7683,edt=34055,tdt=34056,ndt=5386,rdt=512,sdt=513,idt=514,odt=515,adt=516,ldt=517,cdt=518,qae=519,VC=35044,yg=35048,udt=35040,hdt=35045,fdt=35049,ddt=35041,pdt=35046,mdt=35050,gdt=35042,ydt="100",PF="300 es";function Uu(){}Object.assign(Uu.prototype,{addEventListener:function(n,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[n]===void 0&&(t[n]=[]),t[n].indexOf(e)===-1&&t[n].push(e)},hasEventListener:function(n,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[n]!==void 0&&t[n].indexOf(e)!==-1},removeEventListener:function(n,e){if(this._listeners===void 0)return;const r=this._listeners[n];if(r!==void 0){const s=r.indexOf(e);s!==-1&&r.splice(s,1)}},dispatchEvent:function(n){if(this._listeners===void 0)return;const t=this._listeners[n.type];if(t!==void 0){n.target=this;const r=t.slice(0);for(let s=0,i=r.length;s<i;s++)r[s].call(this,n)}}});const yo=[];for(let n=0;n<256;n++)yo[n]=(n<16?"0":"")+n.toString(16);let $T=1234567;const kn={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(yo[n&255]+yo[n>>8&255]+yo[n>>16&255]+yo[n>>24&255]+"-"+yo[e&255]+yo[e>>8&255]+"-"+yo[e>>16&15|64]+yo[e>>24&255]+"-"+yo[t&63|128]+yo[t>>8&255]+"-"+yo[t>>16&255]+yo[t>>24&255]+yo[r&255]+yo[r>>8&255]+yo[r>>16&255]+yo[r>>24&255]).toUpperCase()},clamp:function(n,e,t){return Math.max(e,Math.min(t,n))},euclideanModulo:function(n,e){return(n%e+e)%e},mapLinear:function(n,e,t,r,s){return r+(n-e)*(s-r)/(t-e)},lerp:function(n,e,t){return(1-t)*n+t*e},damp:function(n,e,t,r){return kn.lerp(n,e,1-Math.exp(-t*r))},pingpong:function(n,e=1){return e-Math.abs(kn.euclideanModulo(n,e*2)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){return n!==void 0&&($T=n%2147483647),$T=$T*16807%2147483647,($T-1)/2147483646},degToRad:function(n){return n*kn.DEG2RAD},radToDeg:function(n){return n*kn.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)===0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))},setQuaternionFromProperEuler:function(n,e,t,r,s){const i=Math.cos,o=Math.sin,a=i(t/2),l=o(t/2),c=i((e+r)/2),u=o((e+r)/2),h=i((e-r)/2),f=o((e-r)/2),d=i((r-e)/2),p=o((r-e)/2);switch(s){case"XYX":n.set(a*u,l*h,l*f,a*c);break;case"YZY":n.set(l*f,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*f,a*u,a*c);break;case"XZX":n.set(a*u,l*p,l*d,a*c);break;case"YXY":n.set(l*d,a*u,l*p,a*c);break;case"ZYZ":n.set(l*p,l*d,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}};class rt{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6],this.y=s[1]*t+s[4]*r+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),s=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*r-o*s+e.x,this.y=i*s+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class kl{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,s,i,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=s,u[2]=a,u[3]=t,u[4]=i,u[5]=l,u[6]=r,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[3],l=r[6],c=r[1],u=r[4],h=r[7],f=r[2],d=r[5],p=r[8],m=s[0],g=s[3],y=s[6],b=s[1],x=s[4],w=s[7],_=s[2],C=s[5],k=s[8];return i[0]=o*m+a*b+l*_,i[3]=o*g+a*x+l*C,i[6]=o*y+a*w+l*k,i[1]=c*m+u*b+h*_,i[4]=c*g+u*x+h*C,i[7]=c*y+u*w+h*k,i[2]=f*m+d*b+p*_,i[5]=f*g+d*x+p*C,i[8]=f*y+d*w+p*k,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-r*i*u+r*a*l+s*i*c-s*o*l}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,f=a*l-u*i,d=c*i-o*l,p=t*h+r*f+s*d;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(s*c-u*r)*m,e[2]=(a*r-s*o)*m,e[3]=f*m,e[4]=(u*t-s*l)*m,e[5]=(s*i-a*t)*m,e[6]=d*m,e[7]=(r*l-c*t)*m,e[8]=(o*t-r*i)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,s,i,o,a){const l=Math.cos(i),c=Math.sin(i);return this.set(r*l,r*c,-r*(l*o+c*a)+o+e,-s*c,s*l,-s*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const r=this.elements;return r[0]*=e,r[3]*=e,r[6]*=e,r[1]*=t,r[4]*=t,r[7]*=t,this}rotate(e){const t=Math.cos(e),r=Math.sin(e),s=this.elements,i=s[0],o=s[3],a=s[6],l=s[1],c=s[4],u=s[7];return s[0]=t*i+r*l,s[3]=t*o+r*c,s[6]=t*a+r*u,s[1]=-r*i+t*l,s[4]=-r*o+t*c,s[7]=-r*a+t*u,this}translate(e,t){const r=this.elements;return r[0]+=e*r[2],r[3]+=e*r[5],r[6]+=e*r[8],r[1]+=t*r[2],r[4]+=t*r[5],r[7]+=t*r[8],this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<9;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}}let z0;const Zy={getDataURL:function(n){if(/^data:/i.test(n.src)||typeof HTMLCanvasElement>"u")return n.src;let e;if(n instanceof HTMLCanvasElement)e=n;else{z0===void 0&&(z0=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),z0.width=n.width,z0.height=n.height;const t=z0.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=z0}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let bdt=0;function Kr(n=Kr.DEFAULT_IMAGE,e=Kr.DEFAULT_MAPPING,t=fa,r=fa,s=ao,i=tx,o=Ml,a=nx,l=1,c=Sa){Object.defineProperty(this,"id",{value:bdt++}),this.uuid=kn.generateUUID(),this.name="",this.image=n,this.mipmaps=[],this.mapping=e,this.wrapS=t,this.wrapT=r,this.magFilter=s,this.minFilter=i,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new rt(0,0),this.repeat=new rt(1,1),this.center=new rt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new kl,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}Kr.DEFAULT_IMAGE=void 0;Kr.DEFAULT_MAPPING=T$;Kr.prototype=Object.assign(Object.create(Uu.prototype),{constructor:Kr,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.name=n.name,this.image=n.image,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this},toJSON:function(n){const e=n===void 0||typeof n=="string";if(!e&&n.textures[this.uuid]!==void 0)return n.textures[this.uuid];const t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=kn.generateUUID()),!e&&n.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let i=0,o=r.length;i<o;i++)r[i].isDataTexture?s.push(rP(r[i].image)):s.push(rP(r[i]))}else s=rP(r);n.images[r.uuid]={uuid:r.uuid,url:s}}t.image=r.uuid}return e||(n.textures[this.uuid]=t),t},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(n){if(this.mapping!==T$)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case t_:n.x=n.x-Math.floor(n.x);break;case fa:n.x=n.x<0?0:1;break;case n_:Math.abs(Math.floor(n.x)%2)===1?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x);break}if(n.y<0||n.y>1)switch(this.wrapT){case t_:n.y=n.y-Math.floor(n.y);break;case fa:n.y=n.y<0?0:1;break;case n_:Math.abs(Math.floor(n.y)%2)===1?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y);break}return this.flipY&&(n.y=1-n.y),n}});Object.defineProperty(Kr.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function rP(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Zy.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Hr{constructor(e=0,t=0,r=0,s=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=r,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,s){return this.x=e,this.y=t,this.z=r,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*s+o[12]*i,this.y=o[1]*t+o[5]*r+o[9]*s+o[13]*i,this.z=o[2]*t+o[6]*r+o[10]*s+o[14]*i,this.w=o[3]*t+o[7]*r+o[11]*s+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,s,i;const l=e.elements,c=l[0],u=l[4],h=l[8],f=l[1],d=l[5],p=l[9],m=l[2],g=l[6],y=l[10];if(Math.abs(u-f)<.01&&Math.abs(h-m)<.01&&Math.abs(p-g)<.01){if(Math.abs(u+f)<.1&&Math.abs(h+m)<.1&&Math.abs(p+g)<.1&&Math.abs(c+d+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const x=(c+1)/2,w=(d+1)/2,_=(y+1)/2,C=(u+f)/4,k=(h+m)/4,A=(p+g)/4;return x>w&&x>_?x<.01?(r=0,s=.707106781,i=.707106781):(r=Math.sqrt(x),s=C/r,i=k/r):w>_?w<.01?(r=.707106781,s=0,i=.707106781):(s=Math.sqrt(w),r=C/s,i=A/s):_<.01?(r=.707106781,s=.707106781,i=0):(i=Math.sqrt(_),r=k/i,s=A/i),this.set(r,s,i,t),this}let b=Math.sqrt((g-p)*(g-p)+(h-m)*(h-m)+(f-u)*(f-u));return Math.abs(b)<.001&&(b=1),this.x=(g-p)/b,this.y=(h-m)/b,this.z=(f-u)/b,this.w=Math.acos((c+d+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class qd extends Uu{constructor(e,t,r){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=e,this.height=t,this.scissor=new Hr(0,0,e,t),this.scissorTest=!1,this.viewport=new Hr(0,0,e,t),r=r||{},this.texture=new Kr(void 0,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=r.generateMipmaps!==void 0?r.generateMipmaps:!1,this.texture.minFilter=r.minFilter!==void 0?r.minFilter:ao,this.depthBuffer=r.depthBuffer!==void 0?r.depthBuffer:!0,this.stencilBuffer=r.stencilBuffer!==void 0?r.stencilBuffer:!1,this.depthTexture=r.depthTexture!==void 0?r.depthTexture:null}setSize(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class vdt extends qd{constructor(e,t,r){super(e,t,r),Object.defineProperty(this,"isWebGLMultisampleRenderTarget",{value:!0}),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}class lo{constructor(e=0,t=0,r=0,s=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=r,this._w=s}static slerp(e,t,r,s){return r.copy(e).slerp(t,s)}static slerpFlat(e,t,r,s,i,o,a){let l=r[s+0],c=r[s+1],u=r[s+2],h=r[s+3];const f=i[o+0],d=i[o+1],p=i[o+2],m=i[o+3];if(h!==m||l!==f||c!==d||u!==p){let g=1-a;const y=l*f+c*d+u*p+h*m,b=y>=0?1:-1,x=1-y*y;if(x>Number.EPSILON){const _=Math.sqrt(x),C=Math.atan2(_,y*b);g=Math.sin(g*C)/_,a=Math.sin(a*C)/_}const w=a*b;if(l=l*g+f*w,c=c*g+d*w,u=u*g+p*w,h=h*g+m*w,g===1-a){const _=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=_,c*=_,u*=_,h*=_}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,r,s,i,o){const a=r[s],l=r[s+1],c=r[s+2],u=r[s+3],h=i[o],f=i[o+1],d=i[o+2],p=i[o+3];return e[t]=a*p+u*h+l*d-c*f,e[t+1]=l*p+u*f+c*h-a*d,e[t+2]=c*p+u*d+a*f-l*h,e[t+3]=u*p-a*h-l*f-c*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const r=e._x,s=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(r/2),u=a(s/2),h=a(i/2),f=l(r/2),d=l(s/2),p=l(i/2);switch(o){case"XYZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"YXZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"ZXY":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"ZYX":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"YZX":this._x=f*u*h+c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h-f*d*p;break;case"XZY":this._x=f*u*h-c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h+f*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,s=Math.sin(r);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],s=t[4],i=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],f=r+a+h;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(u-l)*d,this._y=(i-c)*d,this._z=(o-s)*d}else if(r>a&&r>h){const d=2*Math.sqrt(1+r-a-h);this._w=(u-l)/d,this._x=.25*d,this._y=(s+o)/d,this._z=(i+c)/d}else if(a>h){const d=2*Math.sqrt(1+a-r-h);this._w=(i-c)/d,this._x=(s+o)/d,this._y=.25*d,this._z=(l+u)/d}else{const d=2*Math.sqrt(1+h-r-a);this._w=(o-s)/d,this._x=(i+c)/d,this._y=(l+u)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<1e-6?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(kn.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const s=Math.min(1,t/r);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,s=e._y,i=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=r*u+o*a+s*c-i*l,this._y=s*u+o*l+i*a-r*c,this._z=i*u+o*c+r*l-s*a,this._w=o*u-r*a-s*l-i*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,s=this._y,i=this._z,o=this._w;let a=o*e._w+r*e._x+s*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=s,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const d=1-t;return this._w=d*o+t*this._w,this._x=d*r+t*this._x,this._y=d*s+t*this._y,this._z=d*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,f=Math.sin(t*u)/c;return this._w=o*h+this._w*f,this._x=r*h+this._x*f,this._y=s*h+this._y*f,this._z=i*h+this._z*f,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class J{constructor(e=0,t=0,r=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(t8.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(t8.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6]*s,this.y=i[1]*t+i[4]*r+i[7]*s,this.z=i[2]*t+i[5]*r+i[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=e.elements,o=1/(i[3]*t+i[7]*r+i[11]*s+i[15]);return this.x=(i[0]*t+i[4]*r+i[8]*s+i[12])*o,this.y=(i[1]*t+i[5]*r+i[9]*s+i[13])*o,this.z=(i[2]*t+i[6]*r+i[10]*s+i[14])*o,this}applyQuaternion(e){const t=this.x,r=this.y,s=this.z,i=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*s-a*r,u=l*r+a*t-i*s,h=l*s+i*r-o*t,f=-i*t-o*r-a*s;return this.x=c*l+f*-i+u*-a-h*-o,this.y=u*l+f*-o+h*-i-c*-a,this.z=h*l+f*-a+c*-o-u*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[4]*r+i[8]*s,this.y=i[1]*t+i[5]*r+i[9]*s,this.z=i[2]*t+i[6]*r+i[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,s=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=s*l-i*a,this.y=i*o-r*l,this.z=r*a-s*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return sP.copy(this).projectOnVector(e),this.sub(sP)}reflect(e){return this.sub(sP.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(kn.clamp(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,s=this.z-e.z;return t*t+r*r+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const s=Math.sin(t)*e;return this.x=s*Math.sin(r),this.y=Math.cos(t)*e,this.z=s*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const sP=new J,t8=new lo;class Kf{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=e!==void 0?e:new J(1/0,1/0,1/0),this.max=t!==void 0?t:new J(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],f=e[l+2];u<t&&(t=u),h<r&&(r=h),f<s&&(s=f),u>i&&(i=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,s),this.max.set(i,o,a),this}setFromBufferAttribute(e){let t=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),f=e.getZ(l);u<t&&(t=u),h<r&&(r=h),f<s&&(s=f),u>i&&(i=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,s),this.max.set(i,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=Jx.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new J),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new J),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),oP.copy(t.boundingBox),oP.applyMatrix4(e.matrixWorld),this.union(oP));const r=e.children;for(let s=0,i=r.length;s<i;s++)this.expandByObject(r[s]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new J),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Jx),Jx.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Qx),RT.subVectors(this.max,Qx),B0.subVectors(e.a,Qx),V0.subVectors(e.b,Qx),U0.subVectors(e.c,Qx),fd.subVectors(V0,B0),dd.subVectors(U0,V0),lm.subVectors(B0,U0);let t=[0,-fd.z,fd.y,0,-dd.z,dd.y,0,-lm.z,lm.y,fd.z,0,-fd.x,dd.z,0,-dd.x,lm.z,0,-lm.x,-fd.y,fd.x,0,-dd.y,dd.x,0,-lm.y,lm.x,0];return!iP(t,B0,V0,U0,RT)||(t=[1,0,0,0,1,0,0,0,1],!iP(t,B0,V0,U0,RT))?!1:(PT.crossVectors(fd,dd),t=[PT.x,PT.y,PT.z],iP(t,B0,V0,U0,RT))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new J),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Jx.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(Jx).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(sf[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),sf[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),sf[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),sf[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),sf[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),sf[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),sf[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),sf[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(sf),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function iP(n,e,t,r,s){for(let i=0,o=n.length-3;i<=o;i+=3){cm.fromArray(n,i);const a=s.x*Math.abs(cm.x)+s.y*Math.abs(cm.y)+s.z*Math.abs(cm.z),l=e.dot(cm),c=t.dot(cm),u=r.dot(cm);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const sf=[new J,new J,new J,new J,new J,new J,new J,new J],Jx=new J,oP=new Kf,B0=new J,V0=new J,U0=new J,fd=new J,dd=new J,lm=new J,Qx=new J,RT=new J,PT=new J,cm=new J,wdt=new Kf;class Op{constructor(e,t){this.center=e!==void 0?e:new J,this.radius=t!==void 0?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):wdt.setFromPoints(e).getCenter(r);let s=0;for(let i=0,o=e.length;i<o;i++)s=Math.max(s,r.distanceToSquared(e[i]));return this.radius=Math.sqrt(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new J),t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Kf),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const of=new J,aP=new J,DT=new J,pd=new J,lP=new J,OT=new J,cP=new J;class rx{constructor(e,t){this.origin=e!==void 0?e:new J,this.direction=t!==void 0?t:new J(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new J),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,of)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new J),t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=of.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(of.copy(this.direction).multiplyScalar(t).add(this.origin),of.distanceToSquared(e))}distanceSqToSegment(e,t,r,s){aP.copy(e).add(t).multiplyScalar(.5),DT.copy(t).sub(e).normalize(),pd.copy(this.origin).sub(aP);const i=e.distanceTo(t)*.5,o=-this.direction.dot(DT),a=pd.dot(this.direction),l=-pd.dot(DT),c=pd.lengthSq(),u=Math.abs(1-o*o);let h,f,d,p;if(u>0)if(h=o*l-a,f=o*a-l,p=i*u,h>=0)if(f>=-p)if(f<=p){const m=1/u;h*=m,f*=m,d=h*(h+o*f+2*a)+f*(o*h+f+2*l)+c}else f=i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f=-i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f<=-p?(h=Math.max(0,-(-o*i+a)),f=h>0?-i:Math.min(Math.max(-i,-l),i),d=-h*h+f*(f+2*l)+c):f<=p?(h=0,f=Math.min(Math.max(-i,-l),i),d=f*(f+2*l)+c):(h=Math.max(0,-(o*i+a)),f=h>0?i:Math.min(Math.max(-i,-l),i),d=-h*h+f*(f+2*l)+c);else f=o>0?-i:i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;return r&&r.copy(this.direction).multiplyScalar(h).add(this.origin),s&&s.copy(DT).multiplyScalar(f).add(aP),d}intersectSphere(e,t){of.subVectors(e.center,this.origin);const r=of.dot(this.direction),s=of.dot(of)-r*r,i=e.radius*e.radius;if(s>i)return null;const o=Math.sqrt(i-s),a=r-o,l=r+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,s,i,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,f=this.origin;return c>=0?(r=(e.min.x-f.x)*c,s=(e.max.x-f.x)*c):(r=(e.max.x-f.x)*c,s=(e.min.x-f.x)*c),u>=0?(i=(e.min.y-f.y)*u,o=(e.max.y-f.y)*u):(i=(e.max.y-f.y)*u,o=(e.min.y-f.y)*u),r>o||i>s||((i>r||r!==r)&&(r=i),(o<s||s!==s)&&(s=o),h>=0?(a=(e.min.z-f.z)*h,l=(e.max.z-f.z)*h):(a=(e.max.z-f.z)*h,l=(e.min.z-f.z)*h),r>l||a>s)||((a>r||r!==r)&&(r=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(r>=0?r:s,t)}intersectsBox(e){return this.intersectBox(e,of)!==null}intersectTriangle(e,t,r,s,i){lP.subVectors(t,e),OT.subVectors(r,e),cP.crossVectors(lP,OT);let o=this.direction.dot(cP),a;if(o>0){if(s)return null;a=1}else if(o<0)a=-1,o=-o;else return null;pd.subVectors(this.origin,e);const l=a*this.direction.dot(OT.crossVectors(pd,OT));if(l<0)return null;const c=a*this.direction.dot(lP.cross(pd));if(c<0||l+c>o)return null;const u=-a*pd.dot(cP);return u<0?null:this.at(u/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Zn{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g){const y=this.elements;return y[0]=e,y[4]=t,y[8]=r,y[12]=s,y[1]=i,y[5]=o,y[9]=a,y[13]=l,y[2]=c,y[6]=u,y[10]=h,y[14]=f,y[3]=d,y[7]=p,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Zn().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,s=1/W0.setFromMatrixColumn(e,0).length(),i=1/W0.setFromMatrixColumn(e,1).length(),o=1/W0.setFromMatrixColumn(e,2).length();return t[0]=r[0]*s,t[1]=r[1]*s,t[2]=r[2]*s,t[3]=0,t[4]=r[4]*i,t[5]=r[5]*i,t[6]=r[6]*i,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,r=e.x,s=e.y,i=e.z,o=Math.cos(r),a=Math.sin(r),l=Math.cos(s),c=Math.sin(s),u=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=d+p*c,t[5]=f-m*c,t[9]=-a*l,t[2]=m-f*c,t[6]=p+d*c,t[10]=o*l}else if(e.order==="YXZ"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f+m*a,t[4]=p*a-d,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=d*a-p,t[6]=m+f*a,t[10]=o*l}else if(e.order==="ZXY"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f-m*a,t[4]=-o*h,t[8]=p+d*a,t[1]=d+p*a,t[5]=o*u,t[9]=m-f*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=p*c-d,t[8]=f*c+m,t[1]=l*h,t[5]=m*c+f,t[9]=d*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=m-f*h,t[8]=p*h+d,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=d*h+p,t[10]=f-m*h}else if(e.order==="XZY"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=f*h+m,t[5]=o*u,t[9]=d*h-p,t[2]=p*h-d,t[6]=a*u,t[10]=m*h+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(xdt,e,Sdt)}lookAt(e,t,r){const s=this.elements;return hl.subVectors(e,t),hl.lengthSq()===0&&(hl.z=1),hl.normalize(),md.crossVectors(r,hl),md.lengthSq()===0&&(Math.abs(r.z)===1?hl.x+=1e-4:hl.z+=1e-4,hl.normalize(),md.crossVectors(r,hl)),md.normalize(),FT.crossVectors(hl,md),s[0]=md.x,s[4]=FT.x,s[8]=hl.x,s[1]=md.y,s[5]=FT.y,s[9]=hl.y,s[2]=md.z,s[6]=FT.z,s[10]=hl.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],p=r[2],m=r[6],g=r[10],y=r[14],b=r[3],x=r[7],w=r[11],_=r[15],C=s[0],k=s[4],A=s[8],M=s[12],I=s[1],N=s[5],O=s[9],R=s[13],D=s[2],z=s[6],B=s[10],X=s[14],G=s[3],ee=s[7],pe=s[11],oe=s[15];return i[0]=o*C+a*I+l*D+c*G,i[4]=o*k+a*N+l*z+c*ee,i[8]=o*A+a*O+l*B+c*pe,i[12]=o*M+a*R+l*X+c*oe,i[1]=u*C+h*I+f*D+d*G,i[5]=u*k+h*N+f*z+d*ee,i[9]=u*A+h*O+f*B+d*pe,i[13]=u*M+h*R+f*X+d*oe,i[2]=p*C+m*I+g*D+y*G,i[6]=p*k+m*N+g*z+y*ee,i[10]=p*A+m*O+g*B+y*pe,i[14]=p*M+m*R+g*X+y*oe,i[3]=b*C+x*I+w*D+_*G,i[7]=b*k+x*N+w*z+_*ee,i[11]=b*A+x*O+w*B+_*pe,i[15]=b*M+x*R+w*X+_*oe,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],s=e[8],i=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],f=e[10],d=e[14],p=e[3],m=e[7],g=e[11],y=e[15];return p*(+i*l*h-s*c*h-i*a*f+r*c*f+s*a*d-r*l*d)+m*(+t*l*d-t*c*f+i*o*f-s*o*d+s*c*u-i*l*u)+g*(+t*c*h-t*a*d-i*o*h+r*o*d+i*a*u-r*c*u)+y*(-s*a*u-t*l*h+t*a*f+s*o*h-r*o*f+r*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],f=e[10],d=e[11],p=e[12],m=e[13],g=e[14],y=e[15],b=h*g*c-m*f*c+m*l*d-a*g*d-h*l*y+a*f*y,x=p*f*c-u*g*c-p*l*d+o*g*d+u*l*y-o*f*y,w=u*m*c-p*h*c+p*a*d-o*m*d-u*a*y+o*h*y,_=p*h*l-u*m*l-p*a*f+o*m*f+u*a*g-o*h*g,C=t*b+r*x+s*w+i*_;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/C;return e[0]=b*k,e[1]=(m*f*i-h*g*i-m*s*d+r*g*d+h*s*y-r*f*y)*k,e[2]=(a*g*i-m*l*i+m*s*c-r*g*c-a*s*y+r*l*y)*k,e[3]=(h*l*i-a*f*i-h*s*c+r*f*c+a*s*d-r*l*d)*k,e[4]=x*k,e[5]=(u*g*i-p*f*i+p*s*d-t*g*d-u*s*y+t*f*y)*k,e[6]=(p*l*i-o*g*i-p*s*c+t*g*c+o*s*y-t*l*y)*k,e[7]=(o*f*i-u*l*i+u*s*c-t*f*c-o*s*d+t*l*d)*k,e[8]=w*k,e[9]=(p*h*i-u*m*i-p*r*d+t*m*d+u*r*y-t*h*y)*k,e[10]=(o*m*i-p*a*i+p*r*c-t*m*c-o*r*y+t*a*y)*k,e[11]=(u*a*i-o*h*i-u*r*c+t*h*c+o*r*d-t*a*d)*k,e[12]=_*k,e[13]=(u*m*s-p*h*s+p*r*f-t*m*f-u*r*g+t*h*g)*k,e[14]=(p*a*s-o*m*s-p*r*l+t*m*l+o*r*g-t*a*g)*k,e[15]=(o*h*s-u*a*s+u*r*l-t*h*l-o*r*f+t*a*f)*k,this}scale(e){const t=this.elements,r=e.x,s=e.y,i=e.z;return t[0]*=r,t[4]*=s,t[8]*=i,t[1]*=r,t[5]*=s,t[9]*=i,t[2]*=r,t[6]*=s,t[10]*=i,t[3]*=r,t[7]*=s,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,s))}makeTranslation(e,t,r){return this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),s=Math.sin(t),i=1-r,o=e.x,a=e.y,l=e.z,c=i*o,u=i*a;return this.set(c*o+r,c*a-s*l,c*l+s*a,0,c*a+s*l,u*a+r,u*l-s*o,0,c*l-s*a,u*l+s*o,i*l*l+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r){return this.set(1,t,r,0,e,1,r,0,e,t,1,0,0,0,0,1),this}compose(e,t,r){const s=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,c=i+i,u=o+o,h=a+a,f=i*c,d=i*u,p=i*h,m=o*u,g=o*h,y=a*h,b=l*c,x=l*u,w=l*h,_=r.x,C=r.y,k=r.z;return s[0]=(1-(m+y))*_,s[1]=(d+w)*_,s[2]=(p-x)*_,s[3]=0,s[4]=(d-w)*C,s[5]=(1-(f+y))*C,s[6]=(g+b)*C,s[7]=0,s[8]=(p+x)*k,s[9]=(g-b)*k,s[10]=(1-(f+m))*k,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,r){const s=this.elements;let i=W0.set(s[0],s[1],s[2]).length();const o=W0.set(s[4],s[5],s[6]).length(),a=W0.set(s[8],s[9],s[10]).length();this.determinant()<0&&(i=-i),e.x=s[12],e.y=s[13],e.z=s[14],Qc.copy(this);const c=1/i,u=1/o,h=1/a;return Qc.elements[0]*=c,Qc.elements[1]*=c,Qc.elements[2]*=c,Qc.elements[4]*=u,Qc.elements[5]*=u,Qc.elements[6]*=u,Qc.elements[8]*=h,Qc.elements[9]*=h,Qc.elements[10]*=h,t.setFromRotationMatrix(Qc),r.x=i,r.y=o,r.z=a,this}makePerspective(e,t,r,s,i,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*i/(t-e),c=2*i/(r-s),u=(t+e)/(t-e),h=(r+s)/(r-s),f=-(o+i)/(o-i),d=-2*o*i/(o-i);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,r,s,i,o){const a=this.elements,l=1/(t-e),c=1/(r-s),u=1/(o-i),h=(t+e)*l,f=(r+s)*c,d=(o+i)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<16;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const W0=new J,Qc=new Zn,xdt=new J(0,0,0),Sdt=new J(1,1,1),md=new J,FT=new J,hl=new J;class sx{constructor(e=0,t=0,r=0,s=sx.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=r,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._order=s||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,r){const s=kn.clamp,i=e.elements,o=i[0],a=i[4],l=i[8],c=i[1],u=i[5],h=i[9],f=i[2],d=i[6],p=i[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(s(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-s(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,u)):(this._y=Math.atan2(-f,o),this._z=0);break;case"ZXY":this._x=Math.asin(s(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,p),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-s(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(s(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,u),this._y=Math.atan2(-f,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-s(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-h,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return n8.makeRotationFromQuaternion(e),this.setFromRotationMatrix(n8,t,r)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return r8.setFromEuler(this),this.setFromQuaternion(r8,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new J(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}sx.DefaultOrder="XYZ";sx.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const n8=new Zn,r8=new lo;class sV{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let _dt=0;const s8=new J,G0=new lo,af=new Zn,LT=new J,e1=new J,Cdt=new J,kdt=new lo,i8=new J(1,0,0),o8=new J(0,1,0),a8=new J(0,0,1),Tdt={type:"added"},l8={type:"removed"};function rn(){Object.defineProperty(this,"id",{value:_dt++}),this.uuid=kn.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rn.DefaultUp.clone();const n=new J,e=new sx,t=new lo,r=new J(1,1,1);function s(){t.setFromEuler(e,!1)}function i(){e.setFromQuaternion(t,void 0,!1)}e._onChange(s),t._onChange(i),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Zn},normalMatrix:{value:new kl}}),this.matrix=new Zn,this.matrixWorld=new Zn,this.matrixAutoUpdate=rn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new sV,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}rn.DefaultUp=new J(0,1,0);rn.DefaultMatrixAutoUpdate=!0;rn.prototype=Object.assign(Object.create(Uu.prototype),{constructor:rn,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(n){return this.quaternion.premultiply(n),this},setRotationFromAxisAngle:function(n,e){this.quaternion.setFromAxisAngle(n,e)},setRotationFromEuler:function(n){this.quaternion.setFromEuler(n,!0)},setRotationFromMatrix:function(n){this.quaternion.setFromRotationMatrix(n)},setRotationFromQuaternion:function(n){this.quaternion.copy(n)},rotateOnAxis:function(n,e){return G0.setFromAxisAngle(n,e),this.quaternion.multiply(G0),this},rotateOnWorldAxis:function(n,e){return G0.setFromAxisAngle(n,e),this.quaternion.premultiply(G0),this},rotateX:function(n){return this.rotateOnAxis(i8,n)},rotateY:function(n){return this.rotateOnAxis(o8,n)},rotateZ:function(n){return this.rotateOnAxis(a8,n)},translateOnAxis:function(n,e){return s8.copy(n).applyQuaternion(this.quaternion),this.position.add(s8.multiplyScalar(e)),this},translateX:function(n){return this.translateOnAxis(i8,n)},translateY:function(n){return this.translateOnAxis(o8,n)},translateZ:function(n){return this.translateOnAxis(a8,n)},localToWorld:function(n){return n.applyMatrix4(this.matrixWorld)},worldToLocal:function(n){return n.applyMatrix4(af.copy(this.matrixWorld).invert())},lookAt:function(n,e,t){n.isVector3?LT.copy(n):LT.set(n,e,t);const r=this.parent;this.updateWorldMatrix(!0,!1),e1.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?af.lookAt(e1,LT,this.up):af.lookAt(LT,e1,this.up),this.quaternion.setFromRotationMatrix(af),r&&(af.extractRotation(r.matrixWorld),G0.setFromRotationMatrix(af),this.quaternion.premultiply(G0.invert()))},add:function(n){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(n.parent!==null&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(Tdt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)},remove:function(n){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(n);return e!==-1&&(n.parent=null,this.children.splice(e,1),n.dispatchEvent(l8)),this},clear:function(){for(let n=0;n<this.children.length;n++){const e=this.children[n];e.parent=null,e.dispatchEvent(l8)}return this.children.length=0,this},attach:function(n){return this.updateWorldMatrix(!0,!1),af.copy(this.matrixWorld).invert(),n.parent!==null&&(n.parent.updateWorldMatrix(!0,!1),af.multiply(n.parent.matrixWorld)),n.applyMatrix4(af),n.updateWorldMatrix(!1,!1),this.add(n),this},getObjectById:function(n){return this.getObjectByProperty("id",n)},getObjectByName:function(n){return this.getObjectByProperty("name",n)},getObjectByProperty:function(n,e){if(this[n]===e)return this;for(let t=0,r=this.children.length;t<r;t++){const i=this.children[t].getObjectByProperty(n,e);if(i!==void 0)return i}},getWorldPosition:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),n=new J),this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),n=new lo),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(e1,n,Cdt),n},getWorldScale:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),n=new J),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(e1,kdt,n),n},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),n=new J),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(n){n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverse(n)},traverseVisible:function(n){if(this.visible===!1)return;n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverseVisible(n)},traverseAncestors:function(n){const e=this.parent;e!==null&&(n(e),e.traverseAncestors(n))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].updateMatrixWorld(n)},updateWorldMatrix:function(n,e){const t=this.parent;if(n===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let s=0,i=r.length;s<i;s++)r[s].updateWorldMatrix(!1,!0)}},toJSON:function(n){const e=n===void 0||typeof n=="string",t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON());function s(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(n)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(n.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const u=a[l];s(n.shapes,u)}else s(n.shapes,a)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(n.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(s(n.materials,this.material[a]));r.material=o}else r.material=s(n.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(n).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];r.animations.push(s(n.animations,a))}}if(e){const o=i(n.geometries),a=i(n.materials),l=i(n.textures),c=i(n.images),u=i(n.shapes),h=i(n.skeletons),f=i(n.animations);o.length>0&&(t.geometries=o),a.length>0&&(t.materials=a),l.length>0&&(t.textures=l),c.length>0&&(t.images=c),u.length>0&&(t.shapes=u),h.length>0&&(t.skeletons=h),f.length>0&&(t.animations=f)}return t.object=r,t;function i(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(n){return new this.constructor().copy(this,n)},copy:function(n,e=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),e===!0)for(let t=0;t<n.children.length;t++){const r=n.children[t];this.add(r.clone())}return this}});const uP=new J,Edt=new J,Idt=new kl;class ch{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=e!==void 0?e:new J(1,0,0),this.constant=t!==void 0?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,s){return this.normal.set(e,t,r),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const s=uP.subVectors(r,t).cross(Edt.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}clone(){return new this.constructor().copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new J),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new J);const r=e.delta(uP),s=this.normal.dot(r);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):void 0;const i=-(e.start.dot(this.normal)+this.constant)/s;if(!(i<0||i>1))return t.copy(r).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new J),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||Idt.getNormalMatrix(e),s=this.coplanarPoint(uP).applyMatrix4(e),i=this.normal.applyMatrix3(r).normalize();return this.constant=-s.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const eu=new J,lf=new J,hP=new J,cf=new J,H0=new J,j0=new J,c8=new J,fP=new J,dP=new J,pP=new J;class Go{constructor(e,t,r){this.a=e!==void 0?e:new J,this.b=t!==void 0?t:new J,this.c=r!==void 0?r:new J}static getNormal(e,t,r,s){s===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),s=new J),s.subVectors(r,t),eu.subVectors(e,t),s.cross(eu);const i=s.lengthSq();return i>0?s.multiplyScalar(1/Math.sqrt(i)):s.set(0,0,0)}static getBarycoord(e,t,r,s,i){eu.subVectors(s,t),lf.subVectors(r,t),hP.subVectors(e,t);const o=eu.dot(eu),a=eu.dot(lf),l=eu.dot(hP),c=lf.dot(lf),u=lf.dot(hP),h=o*c-a*a;if(i===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),i=new J),h===0)return i.set(-2,-1,-1);const f=1/h,d=(c*l-a*u)*f,p=(o*u-a*l)*f;return i.set(1-d-p,p,d)}static containsPoint(e,t,r,s){return this.getBarycoord(e,t,r,s,cf),cf.x>=0&&cf.y>=0&&cf.x+cf.y<=1}static getUV(e,t,r,s,i,o,a,l){return this.getBarycoord(e,t,r,s,cf),l.set(0,0),l.addScaledVector(i,cf.x),l.addScaledVector(o,cf.y),l.addScaledVector(a,cf.z),l}static isFrontFacing(e,t,r,s){return eu.subVectors(r,t),lf.subVectors(e,t),eu.cross(lf).dot(s)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,s){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[s]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return eu.subVectors(this.c,this.b),lf.subVectors(this.a,this.b),eu.cross(lf).length()*.5}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new J),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Go.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new ch),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Go.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,s,i){return Go.getUV(e,this.a,this.b,this.c,t,r,s,i)}containsPoint(e){return Go.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Go.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new J);const r=this.a,s=this.b,i=this.c;let o,a;H0.subVectors(s,r),j0.subVectors(i,r),fP.subVectors(e,r);const l=H0.dot(fP),c=j0.dot(fP);if(l<=0&&c<=0)return t.copy(r);dP.subVectors(e,s);const u=H0.dot(dP),h=j0.dot(dP);if(u>=0&&h<=u)return t.copy(s);const f=l*h-u*c;if(f<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(r).addScaledVector(H0,o);pP.subVectors(e,i);const d=H0.dot(pP),p=j0.dot(pP);if(p>=0&&d<=p)return t.copy(i);const m=d*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(r).addScaledVector(j0,a);const g=u*p-d*h;if(g<=0&&h-u>=0&&d-p>=0)return c8.subVectors(i,s),a=(h-u)/(h-u+(d-p)),t.copy(s).addScaledVector(c8,a);const y=1/(g+m+f);return o=m*y,a=f*y,t.copy(r).addScaledVector(H0,o).addScaledVector(j0,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const Xae={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tu={h:0,s:0,l:0},zT={h:0,s:0,l:0};function mP(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function gP(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function yP(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class jt{constructor(e,t,r){return Object.defineProperty(this,"isColor",{value:!0}),t===void 0&&r===void 0?this.set(e):this.setRGB(e,t,r)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,r){return this.r=e,this.g=t,this.b=r,this}setHSL(e,t,r){if(e=kn.euclideanModulo(e,1),t=kn.clamp(t,0,1),r=kn.clamp(r,0,1),t===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+t):r+t-r*t,i=2*r-s;this.r=mP(i,s,e+1/3),this.g=mP(i,s,e),this.b=mP(i,s,e-1/3)}return this}setStyle(e){function t(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const i=r[1],o=r[2];switch(i){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,t(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,t(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(s[1])/360,l=parseInt(s[2],10)/100,c=parseInt(s[3],10)/100;return t(s[4]),this.setHSL(a,l,c)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],i=s.length;if(i===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,this;if(i===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Xae[e];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const r=t>0?1/t:1;return this.r=Math.pow(e.r,r),this.g=Math.pow(e.g,r),this.b=Math.pow(e.b,r),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=gP(e.r),this.g=gP(e.g),this.b=gP(e.b),this}copyLinearToSRGB(e){return this.r=yP(e.r),this.g=yP(e.g),this.b=yP(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,r=this.g,s=this.b,i=Math.max(t,r,s),o=Math.min(t,r,s);let a,l;const c=(o+i)/2;if(o===i)a=0,l=0;else{const u=i-o;switch(l=c<=.5?u/(i+o):u/(2-i-o),i){case t:a=(r-s)/u+(r<s?6:0);break;case r:a=(s-t)/u+2;break;case s:a=(t-r)/u+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,r){return this.getHSL(tu),tu.h+=e,tu.s+=t,tu.l+=r,this.setHSL(tu.h,tu.s,tu.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(tu),e.getHSL(zT);const r=kn.lerp(tu.h,zT.h,t),s=kn.lerp(tu.s,zT.s,t),i=kn.lerp(tu.l,zT.l,t);return this.setHSL(r,s,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}jt.NAMES=Xae;jt.prototype.r=1;jt.prototype.g=1;jt.prototype.b=1;class iV{constructor(e,t,r,s,i,o=0){this.a=e,this.b=t,this.c=r,this.normal=s&&s.isVector3?s:new J,this.vertexNormals=Array.isArray(s)?s:[],this.color=i&&i.isColor?i:new jt,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,r=e.vertexNormals.length;t<r;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,r=e.vertexColors.length;t<r;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let Adt=0;function Sn(){Object.defineProperty(this,"id",{value:Adt++}),this.uuid=kn.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=$b,this.side=Qw,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Z4,this.blendDst=J4,this.blendEquation=Rm,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=vA,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=qae,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=eI,this.stencilZFail=eI,this.stencilZPass=eI,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Sn.prototype=Object.assign(Object.create(Uu.prototype),{constructor:Sn,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(n){if(n!==void 0)for(const e in n){const t=n[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===Y4;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(t):r&&r.isVector3&&t&&t.isVector3?r.copy(t):this[e]=t}},toJSON:function(n){const e=n===void 0||typeof n=="string";e&&(n={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,t.reflectivity=this.reflectivity,t.refractionRatio=this.refractionRatio,this.combine!==void 0&&(t.combine=this.combine),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),this.size!==void 0&&(t.size=this.size),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==$b&&(t.blending=this.blending),this.flatShading===!0&&(t.flatShading=this.flatShading),this.side!==Qw&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function r(s){const i=[];for(const o in s){const a=s[o];delete a.metadata,i.push(a)}return i}if(e){const s=r(n.textures),i=r(n.images);s.length>0&&(t.textures=s),i.length>0&&(t.images=i)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(n){this.name=n.name,this.fog=n.fog,this.blending=n.blending,this.side=n.side,this.flatShading=n.flatShading,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;const e=n.clippingPlanes;let t=null;if(e!==null){const r=e.length;t=new Array(r);for(let s=0;s!==r;++s)t[s]=e[s].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(Sn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function Ol(n){Sn.call(this),this.type="MeshBasicMaterial",this.color=new jt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(n)}Ol.prototype=Object.create(Sn.prototype);Ol.prototype.constructor=Ol;Ol.prototype.isMeshBasicMaterial=!0;Ol.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this};const is=new J,BT=new rt;function xn(n,e,t){if(Array.isArray(n))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=n,this.itemSize=e,this.count=n!==void 0?n.length/e:0,this.normalized=t===!0,this.usage=VC,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(xn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(xn.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[n+r]=e.array[t+r];return this},copyArray:function(n){return this.array.set(n),this},copyColorsArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new jt),e[t++]=i.r,e[t++]=i.g,e[t++]=i.b}return this},copyVector2sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new rt),e[t++]=i.x,e[t++]=i.y}return this},copyVector3sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new J),e[t++]=i.x,e[t++]=i.y,e[t++]=i.z}return this},copyVector4sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new Hr),e[t++]=i.x,e[t++]=i.y,e[t++]=i.z,e[t++]=i.w}return this},applyMatrix3:function(n){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)BT.fromBufferAttribute(this,e),BT.applyMatrix3(n),this.setXY(e,BT.x,BT.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)is.fromBufferAttribute(this,e),is.applyMatrix3(n),this.setXYZ(e,is.x,is.y,is.z);return this},applyMatrix4:function(n){for(let e=0,t=this.count;e<t;e++)is.x=this.getX(e),is.y=this.getY(e),is.z=this.getZ(e),is.applyMatrix4(n),this.setXYZ(e,is.x,is.y,is.z);return this},applyNormalMatrix:function(n){for(let e=0,t=this.count;e<t;e++)is.x=this.getX(e),is.y=this.getY(e),is.z=this.getZ(e),is.applyNormalMatrix(n),this.setXYZ(e,is.x,is.y,is.z);return this},transformDirection:function(n){for(let e=0,t=this.count;e<t;e++)is.x=this.getX(e),is.y=this.getY(e),is.z=this.getZ(e),is.transformDirection(n),this.setXYZ(e,is.x,is.y,is.z);return this},set:function(n,e=0){return this.array.set(n,e),this},getX:function(n){return this.array[n*this.itemSize]},setX:function(n,e){return this.array[n*this.itemSize]=e,this},getY:function(n){return this.array[n*this.itemSize+1]},setY:function(n,e){return this.array[n*this.itemSize+1]=e,this},getZ:function(n){return this.array[n*this.itemSize+2]},setZ:function(n,e){return this.array[n*this.itemSize+2]=e,this},getW:function(n){return this.array[n*this.itemSize+3]},setW:function(n,e){return this.array[n*this.itemSize+3]=e,this},setXY:function(n,e,t){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this},setXYZW:function(n,e,t,r,s){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this.array[n+3]=s,this},onUpload:function(n){return this.onUploadCallback=n,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function a_(n,e,t){xn.call(this,new Int8Array(n),e,t)}a_.prototype=Object.create(xn.prototype);a_.prototype.constructor=a_;function l_(n,e,t){xn.call(this,new Uint8Array(n),e,t)}l_.prototype=Object.create(xn.prototype);l_.prototype.constructor=l_;function c_(n,e,t){xn.call(this,new Uint8ClampedArray(n),e,t)}c_.prototype=Object.create(xn.prototype);c_.prototype.constructor=c_;function u_(n,e,t){xn.call(this,new Int16Array(n),e,t)}u_.prototype=Object.create(xn.prototype);u_.prototype.constructor=u_;function bg(n,e,t){xn.call(this,new Uint16Array(n),e,t)}bg.prototype=Object.create(xn.prototype);bg.prototype.constructor=bg;function h_(n,e,t){xn.call(this,new Int32Array(n),e,t)}h_.prototype=Object.create(xn.prototype);h_.prototype.constructor=h_;function vg(n,e,t){xn.call(this,new Uint32Array(n),e,t)}vg.prototype=Object.create(xn.prototype);vg.prototype.constructor=vg;function f_(n,e,t){xn.call(this,new Uint16Array(n),e,t)}f_.prototype=Object.create(xn.prototype);f_.prototype.constructor=f_;f_.prototype.isFloat16BufferAttribute=!0;function Xt(n,e,t){xn.call(this,new Float32Array(n),e,t)}Xt.prototype=Object.create(xn.prototype);Xt.prototype.constructor=Xt;function d_(n,e,t){xn.call(this,new Float64Array(n),e,t)}d_.prototype=Object.create(xn.prototype);d_.prototype.constructor=d_;function Kae(n){if(n.length===0)return-1/0;let e=n[0];for(let t=1,r=n.length;t<r;++t)n[t]>e&&(e=n[t]);return e}const Mdt={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function N1(n,e){return new Mdt[n](e)}let Ndt=0;const Ju=new Zn,bP=new rn,q0=new J,fl=new Kf,t1=new Kf,to=new J;function cn(){Object.defineProperty(this,"id",{value:Ndt++}),this.uuid=kn.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}cn.prototype=Object.assign(Object.create(Uu.prototype),{constructor:cn,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(n){return Array.isArray(n)?this.index=new(Kae(n)>65535?vg:bg)(n,1):this.index=n,this},getAttribute:function(n){return this.attributes[n]},setAttribute:function(n,e){return this.attributes[n]=e,this},deleteAttribute:function(n){return delete this.attributes[n],this},hasAttribute:function(n){return this.attributes[n]!==void 0},addGroup:function(n,e,t=0){this.groups.push({start:n,count:e,materialIndex:t})},clearGroups:function(){this.groups=[]},setDrawRange:function(n,e){this.drawRange.start=n,this.drawRange.count=e},applyMatrix4:function(n){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(n),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const s=new kl().getNormalMatrix(n);t.applyNormalMatrix(s),t.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(n),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(n){return Ju.makeRotationX(n),this.applyMatrix4(Ju),this},rotateY:function(n){return Ju.makeRotationY(n),this.applyMatrix4(Ju),this},rotateZ:function(n){return Ju.makeRotationZ(n),this.applyMatrix4(Ju),this},translate:function(n,e,t){return Ju.makeTranslation(n,e,t),this.applyMatrix4(Ju),this},scale:function(n,e,t){return Ju.makeScale(n,e,t),this.applyMatrix4(Ju),this},lookAt:function(n){return bP.lookAt(n),bP.updateMatrix(),this.applyMatrix4(bP.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(q0).negate(),this.translate(q0.x,q0.y,q0.z),this},setFromPoints:function(n){const e=[];for(let t=0,r=n.length;t<r;t++){const s=n[t];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Xt(e,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Kf);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new J(-1/0,-1/0,-1/0),new J(1/0,1/0,1/0));return}if(n!==void 0){if(this.boundingBox.setFromBufferAttribute(n),e)for(let t=0,r=e.length;t<r;t++){const s=e[t];fl.setFromBufferAttribute(s),this.morphTargetsRelative?(to.addVectors(this.boundingBox.min,fl.min),this.boundingBox.expandByPoint(to),to.addVectors(this.boundingBox.max,fl.max),this.boundingBox.expandByPoint(to)):(this.boundingBox.expandByPoint(fl.min),this.boundingBox.expandByPoint(fl.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Op);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new J,1/0);return}if(n){const t=this.boundingSphere.center;if(fl.setFromBufferAttribute(n),e)for(let s=0,i=e.length;s<i;s++){const o=e[s];t1.setFromBufferAttribute(o),this.morphTargetsRelative?(to.addVectors(fl.min,t1.min),fl.expandByPoint(to),to.addVectors(fl.max,t1.max),fl.expandByPoint(to)):(fl.expandByPoint(t1.min),fl.expandByPoint(t1.max))}fl.getCenter(t);let r=0;for(let s=0,i=n.count;s<i;s++)to.fromBufferAttribute(n,s),r=Math.max(r,t.distanceToSquared(to));if(e)for(let s=0,i=e.length;s<i;s++){const o=e[s],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)to.fromBufferAttribute(o,l),a&&(q0.fromBufferAttribute(n,l),to.add(q0)),r=Math.max(r,t.distanceToSquared(to))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const n=this.index,e=this.attributes;if(n===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=n.array,r=e.position.array,s=e.normal.array,i=e.uv.array,o=r.length/3;e.tangent===void 0&&this.setAttribute("tangent",new xn(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let M=0;M<o;M++)l[M]=new J,c[M]=new J;const u=new J,h=new J,f=new J,d=new rt,p=new rt,m=new rt,g=new J,y=new J;function b(M,I,N){u.fromArray(r,M*3),h.fromArray(r,I*3),f.fromArray(r,N*3),d.fromArray(i,M*2),p.fromArray(i,I*2),m.fromArray(i,N*2),h.sub(u),f.sub(u),p.sub(d),m.sub(d);const O=1/(p.x*m.y-m.x*p.y);isFinite(O)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(f,-p.y).multiplyScalar(O),y.copy(f).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar(O),l[M].add(g),l[I].add(g),l[N].add(g),c[M].add(y),c[I].add(y),c[N].add(y))}let x=this.groups;x.length===0&&(x=[{start:0,count:t.length}]);for(let M=0,I=x.length;M<I;++M){const N=x[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)b(t[D+0],t[D+1],t[D+2])}const w=new J,_=new J,C=new J,k=new J;function A(M){C.fromArray(s,M*3),k.copy(C);const I=l[M];w.copy(I),w.sub(C.multiplyScalar(C.dot(I))).normalize(),_.crossVectors(k,I);const O=_.dot(c[M])<0?-1:1;a[M*4]=w.x,a[M*4+1]=w.y,a[M*4+2]=w.z,a[M*4+3]=O}for(let M=0,I=x.length;M<I;++M){const N=x[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)A(t[D+0]),A(t[D+1]),A(t[D+2])}},computeVertexNormals:function(){const n=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new xn(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let h=0,f=t.count;h<f;h++)t.setXYZ(h,0,0,0);const r=new J,s=new J,i=new J,o=new J,a=new J,l=new J,c=new J,u=new J;if(n)for(let h=0,f=n.count;h<f;h+=3){const d=n.getX(h+0),p=n.getX(h+1),m=n.getX(h+2);r.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),i.fromBufferAttribute(e,m),c.subVectors(i,s),u.subVectors(r,s),c.cross(u),o.fromBufferAttribute(t,d),a.fromBufferAttribute(t,p),l.fromBufferAttribute(t,m),o.add(c),a.add(c),l.add(c),t.setXYZ(d,o.x,o.y,o.z),t.setXYZ(p,a.x,a.y,a.z),t.setXYZ(m,l.x,l.y,l.z)}else for(let h=0,f=e.count;h<f;h+=3)r.fromBufferAttribute(e,h+0),s.fromBufferAttribute(e,h+1),i.fromBufferAttribute(e,h+2),c.subVectors(i,s),u.subVectors(r,s),c.cross(u),t.setXYZ(h+0,c.x,c.y,c.z),t.setXYZ(h+1,c.x,c.y,c.z),t.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),t.needsUpdate=!0}},merge:function(n,e){if(!(n&&n.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const t=this.attributes;for(const r in t){if(n.attributes[r]===void 0)continue;const i=t[r].array,o=n.attributes[r],a=o.array,l=o.itemSize*e,c=Math.min(a.length,i.length-l);for(let u=0,h=l;u<c;u++,h++)i[h]=a[u]}return this},normalizeNormals:function(){const n=this.attributes.normal;for(let e=0,t=n.count;e<t;e++)to.fromBufferAttribute(n,e),to.normalize(),n.setXYZ(e,to.x,to.y,to.z)},toNonIndexed:function(){function n(o,a){const l=o.array,c=o.itemSize,u=o.normalized,h=new l.constructor(a.length*c);let f=0,d=0;for(let p=0,m=a.length;p<m;p++){f=a[p]*c;for(let g=0;g<c;g++)h[d++]=l[f++]}return new xn(h,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new cn,t=this.index.array,r=this.attributes;for(const o in r){const a=r[o],l=n(a,t);e.setAttribute(o,l)}const s=this.morphAttributes;for(const o in s){const a=[],l=s[o];for(let c=0,u=l.length;c<u;c++){const h=l[c],f=n(h,t);a.push(f)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let o=0,a=i.length;o<a;o++){const l=i[o];e.addGroup(l.start,l.count,l.materialIndex)}return e},toJSON:function(){const n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(n[l]=a[l]);return n}n.data={attributes:{}};const e=this.index;e!==null&&(n.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const l=t[a],c=l.toJSON(n.data);l.name!==""&&(c.name=l.name),n.data.attributes[a]=c}const r={};let s=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let u=0,h=l.length;u<h;u++){const f=l[u],d=f.toJSON(n.data);f.name!==""&&(d.name=f.name),c.push(d)}c.length>0&&(r[a]=c,s=!0)}s&&(n.data.morphAttributes=r,n.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(n.data.groups=JSON.parse(JSON.stringify(i)));const o=this.boundingSphere;return o!==null&&(n.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),n},clone:function(){return new cn().copy(this)},copy:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=n.name;const t=n.index;t!==null&&this.setIndex(t.clone(e));const r=n.attributes;for(const l in r){const c=r[l];this.setAttribute(l,c.clone(e))}const s=n.morphAttributes;for(const l in s){const c=[],u=s[l];for(let h=0,f=u.length;h<f;h++)c.push(u[h].clone(e));this.morphAttributes[l]=c}this.morphTargetsRelative=n.morphTargetsRelative;const i=n.groups;for(let l=0,c=i.length;l<c;l++){const u=i[l];this.addGroup(u.start,u.count,u.materialIndex)}const o=n.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=n.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const u8=new Zn,X0=new rx,vP=new Op,gd=new J,yd=new J,bd=new J,wP=new J,xP=new J,SP=new J,VT=new J,UT=new J,WT=new J,GT=new rt,HT=new rt,jT=new rt,_P=new J,qT=new J;function hs(n=new cn,e=new Ol){rn.call(this),this.type="Mesh",this.geometry=n,this.material=e,this.updateMorphTargets()}hs.prototype=Object.assign(Object.create(rn.prototype),{constructor:hs,isMesh:!0,copy:function(n){return rn.prototype.copy.call(this,n),n.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),n.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(n,e){const t=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(t.boundingSphere===null&&t.computeBoundingSphere(),vP.copy(t.boundingSphere),vP.applyMatrix4(s),n.ray.intersectsSphere(vP)===!1)||(u8.copy(s).invert(),X0.copy(n.ray).applyMatrix4(u8),t.boundingBox!==null&&X0.intersectsBox(t.boundingBox)===!1))return;let i;if(t.isBufferGeometry){const o=t.index,a=t.attributes.position,l=t.morphAttributes.position,c=t.morphTargetsRelative,u=t.attributes.uv,h=t.attributes.uv2,f=t.groups,d=t.drawRange;if(o!==null)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),x=Math.min(g.start+g.count,d.start+d.count);for(let w=b,_=x;w<_;w+=3){const C=o.getX(w),k=o.getX(w+1),A=o.getX(w+2);i=XT(this,y,n,X0,a,l,c,u,h,C,k,A),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=g.materialIndex,e.push(i))}}else{const p=Math.max(0,d.start),m=Math.min(o.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=o.getX(g),x=o.getX(g+1),w=o.getX(g+2);i=XT(this,r,n,X0,a,l,c,u,h,b,x,w),i&&(i.faceIndex=Math.floor(g/3),e.push(i))}}else if(a!==void 0)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),x=Math.min(g.start+g.count,d.start+d.count);for(let w=b,_=x;w<_;w+=3){const C=w,k=w+1,A=w+2;i=XT(this,y,n,X0,a,l,c,u,h,C,k,A),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=g.materialIndex,e.push(i))}}else{const p=Math.max(0,d.start),m=Math.min(a.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=g,x=g+1,w=g+2;i=XT(this,r,n,X0,a,l,c,u,h,b,x,w),i&&(i.faceIndex=Math.floor(g/3),e.push(i))}}}else t.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function $dt(n,e,t,r,s,i,o,a){let l;if(e.side===pi?l=r.intersectTriangle(o,i,s,!0,a):l=r.intersectTriangle(s,i,o,e.side!==DC,a),l===null)return null;qT.copy(a),qT.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(qT);return c<t.near||c>t.far?null:{distance:c,point:qT.clone(),object:n}}function XT(n,e,t,r,s,i,o,a,l,c,u,h){gd.fromBufferAttribute(s,c),yd.fromBufferAttribute(s,u),bd.fromBufferAttribute(s,h);const f=n.morphTargetInfluences;if(e.morphTargets&&i&&f){VT.set(0,0,0),UT.set(0,0,0),WT.set(0,0,0);for(let p=0,m=i.length;p<m;p++){const g=f[p],y=i[p];g!==0&&(wP.fromBufferAttribute(y,c),xP.fromBufferAttribute(y,u),SP.fromBufferAttribute(y,h),o?(VT.addScaledVector(wP,g),UT.addScaledVector(xP,g),WT.addScaledVector(SP,g)):(VT.addScaledVector(wP.sub(gd),g),UT.addScaledVector(xP.sub(yd),g),WT.addScaledVector(SP.sub(bd),g)))}gd.add(VT),yd.add(UT),bd.add(WT)}n.isSkinnedMesh&&(n.boneTransform(c,gd),n.boneTransform(u,yd),n.boneTransform(h,bd));const d=$dt(n,e,t,r,gd,yd,bd,_P);if(d){a&&(GT.fromBufferAttribute(a,c),HT.fromBufferAttribute(a,u),jT.fromBufferAttribute(a,h),d.uv=Go.getUV(_P,gd,yd,bd,GT,HT,jT,new rt)),l&&(GT.fromBufferAttribute(l,c),HT.fromBufferAttribute(l,u),jT.fromBufferAttribute(l,h),d.uv2=Go.getUV(_P,gd,yd,bd,GT,HT,jT,new rt));const p=new iV(c,u,h);Go.getNormal(gd,yd,bd,p.normal),d.face=p}return d}class wg extends cn{constructor(e=1,t=1,r=1,s=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:s,heightSegments:i,depthSegments:o};const a=this;s=Math.floor(s),i=Math.floor(i),o=Math.floor(o);const l=[],c=[],u=[],h=[];let f=0,d=0;p("z","y","x",-1,-1,r,t,e,o,i,0),p("z","y","x",1,-1,r,t,-e,o,i,1),p("x","z","y",1,1,e,r,t,s,o,2),p("x","z","y",1,-1,e,r,-t,s,o,3),p("x","y","z",1,-1,e,t,r,s,i,4),p("x","y","z",-1,-1,e,t,-r,s,i,5),this.setIndex(l),this.setAttribute("position",new Xt(c,3)),this.setAttribute("normal",new Xt(u,3)),this.setAttribute("uv",new Xt(h,2));function p(m,g,y,b,x,w,_,C,k,A,M){const I=w/k,N=_/A,O=w/2,R=_/2,D=C/2,z=k+1,B=A+1;let X=0,G=0;const ee=new J;for(let pe=0;pe<B;pe++){const oe=pe*N-R;for(let Ne=0;Ne<z;Ne++){const ke=Ne*I-O;ee[m]=ke*b,ee[g]=oe*x,ee[y]=D,c.push(ee.x,ee.y,ee.z),ee[m]=0,ee[g]=0,ee[y]=C>0?1:-1,u.push(ee.x,ee.y,ee.z),h.push(Ne/k),h.push(1-pe/A),X+=1}}for(let pe=0;pe<A;pe++)for(let oe=0;oe<k;oe++){const Ne=f+oe+z*pe,ke=f+oe+z*(pe+1),De=f+(oe+1)+z*(pe+1),ge=f+(oe+1)+z*pe;l.push(Ne,ke,ge),l.push(ke,De,ge),G+=6}a.addGroup(d,G,M),d+=G,f+=X}}}function cv(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const s=n[t][r];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture)?e[t][r]=s.clone():Array.isArray(s)?e[t][r]=s.slice():e[t][r]=s}}return e}function Do(n){const e={};for(let t=0;t<n.length;t++){const r=cv(n[t]);for(const s in r)e[s]=r[s]}return e}const Yae={clone:cv,merge:Do};var Rdt=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Pdt=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function _a(n){Sn.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=Rdt,this.fragmentShader=Pdt,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,n!==void 0&&(n.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(n))}_a.prototype=Object.create(Sn.prototype);_a.prototype.constructor=_a;_a.prototype.isShaderMaterial=!0;_a.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=cv(n.uniforms),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.lights=n.lights,this.clipping=n.clipping,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this};_a.prototype.toJSON=function(n){const e=Sn.prototype.toJSON.call(this,n);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const i=this.uniforms[r].value;i&&i.isTexture?e.uniforms[r]={type:"t",value:i.toJSON(n).uuid}:i&&i.isColor?e.uniforms[r]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[r]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[r]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[r]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[r]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[r]={type:"m4",value:i.toArray()}:e.uniforms[r]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const t={};for(const r in this.extensions)this.extensions[r]===!0&&(t[r]=!0);return Object.keys(t).length>0&&(e.extensions=t),e};function Eh(){rn.call(this),this.type="Camera",this.matrixWorldInverse=new Zn,this.projectionMatrix=new Zn,this.projectionMatrixInverse=new Zn}Eh.prototype=Object.assign(Object.create(rn.prototype),{constructor:Eh,isCamera:!0,copy:function(n,e){return rn.prototype.copy.call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),n=new J),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(n){rn.prototype.updateMatrixWorld.call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(n,e){rn.prototype.updateWorldMatrix.call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function xi(n=50,e=1,t=.1,r=2e3){Eh.call(this),this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=t,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}xi.prototype=Object.assign(Object.create(Eh.prototype),{constructor:xi,isPerspectiveCamera:!0,copy:function(n,e){return Eh.prototype.copy.call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=n.view===null?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this},setFocalLength:function(n){const e=.5*this.getFilmHeight()/n;this.fov=kn.RAD2DEG*2*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const n=Math.tan(kn.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/n},getEffectiveFOV:function(){return kn.RAD2DEG*2*Math.atan(Math.tan(kn.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(n,e,t,r,s,i){this.aspect=n/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=this.near;let e=n*Math.tan(kn.DEG2RAD*.5*this.fov)/this.zoom,t=2*e,r=this.aspect*t,s=-.5*r;const i=this.view;if(this.view!==null&&this.view.enabled){const a=i.fullWidth,l=i.fullHeight;s+=i.offsetX*r/a,e-=i.offsetY*t/l,r*=i.width/a,t*=i.height/l}const o=this.filmOffset;o!==0&&(s+=n*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const K0=90,Y0=1;function xg(n,e,t){if(rn.call(this),this.type="CubeCamera",t.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=t;const r=new xi(K0,Y0,n,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new J(1,0,0)),this.add(r);const s=new xi(K0,Y0,n,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new J(-1,0,0)),this.add(s);const i=new xi(K0,Y0,n,e);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new J(0,1,0)),this.add(i);const o=new xi(K0,Y0,n,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new J(0,-1,0)),this.add(o);const a=new xi(K0,Y0,n,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new J(0,0,1)),this.add(a);const l=new xi(K0,Y0,n,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new J(0,0,-1)),this.add(l),this.update=function(c,u){this.parent===null&&this.updateMatrixWorld();const h=c.xr.enabled,f=c.getRenderTarget();c.xr.enabled=!1;const d=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,c.setRenderTarget(t,0),c.render(u,r),c.setRenderTarget(t,1),c.render(u,s),c.setRenderTarget(t,2),c.render(u,i),c.setRenderTarget(t,3),c.render(u,o),c.setRenderTarget(t,4),c.render(u,a),t.texture.generateMipmaps=d,c.setRenderTarget(t,5),c.render(u,l),c.setRenderTarget(f),c.xr.enabled=h}}xg.prototype=Object.create(rn.prototype);xg.prototype.constructor=xg;function Ih(n,e,t,r,s,i,o,a,l,c){n=n!==void 0?n:[],e=e!==void 0?e:FC,o=o!==void 0?o:jd,Kr.call(this,n,e,t,r,s,i,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}Ih.prototype=Object.create(Kr.prototype);Ih.prototype.constructor=Ih;Ih.prototype.isCubeTexture=!0;Object.defineProperty(Ih.prototype,"images",{get:function(){return this.image},set:function(n){this.image=n}});class oV extends qd{constructor(e,t,r){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=r),super(e,e,t),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),t=t||{},this.texture=new Ih(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Ml,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new wg(5,5,5),i=new _a({name:"CubemapFromEquirect",uniforms:cv(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:pi,blending:Nf});i.uniforms.tEquirect.value=t;const o=new hs(s,i),a=t.minFilter;return t.minFilter===tx&&(t.minFilter=ao),new xg(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,r,s){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,r,s);e.setRenderTarget(i)}}function Ff(n,e,t,r,s,i,o,a,l,c,u,h){Kr.call(this,null,i,o,a,l,c,r,s,u,h),this.image={data:n||null,width:e||1,height:t||1},this.magFilter=l!==void 0?l:Bi,this.minFilter=c!==void 0?c:Bi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Ff.prototype=Object.create(Kr.prototype);Ff.prototype.constructor=Ff;Ff.prototype.isDataTexture=!0;const Z0=new Op,KT=new J;class UC{constructor(e,t,r,s,i,o){this.planes=[e!==void 0?e:new ch,t!==void 0?t:new ch,r!==void 0?r:new ch,s!==void 0?s:new ch,i!==void 0?i:new ch,o!==void 0?o:new ch]}set(e,t,r,s,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(r),a[3].copy(s),a[4].copy(i),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e){const t=this.planes,r=e.elements,s=r[0],i=r[1],o=r[2],a=r[3],l=r[4],c=r[5],u=r[6],h=r[7],f=r[8],d=r[9],p=r[10],m=r[11],g=r[12],y=r[13],b=r[14],x=r[15];return t[0].setComponents(a-s,h-l,m-f,x-g).normalize(),t[1].setComponents(a+s,h+l,m+f,x+g).normalize(),t[2].setComponents(a+i,h+c,m+d,x+y).normalize(),t[3].setComponents(a-i,h-c,m-d,x-y).normalize(),t[4].setComponents(a-o,h-u,m-p,x-b).normalize(),t[5].setComponents(a+o,h+u,m+p,x+b).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),Z0.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Z0)}intersectsSprite(e){return Z0.center.set(0,0,0),Z0.radius=.7071067811865476,Z0.applyMatrix4(e.matrixWorld),this.intersectsSphere(Z0)}intersectsSphere(e){const t=this.planes,r=e.center,s=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(r)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const s=t[r];if(KT.x=s.normal.x>0?e.max.x:e.min.x,KT.y=s.normal.y>0?e.max.y:e.min.y,KT.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(KT)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}}function Zae(){let n=null,e=!1,t=null,r=null;function s(i,o){t(i,o),r=n.requestAnimationFrame(s)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(s),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function Ddt(n,e){const t=e.isWebGL2,r=new WeakMap;function s(c,u){const h=c.array,f=c.usage,d=n.createBuffer();n.bindBuffer(u,d),n.bufferData(u,h,f),c.onUploadCallback();let p=5126;return h instanceof Float32Array?p=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?c.isFloat16BufferAttribute?t?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:h instanceof Int16Array?p=5122:h instanceof Uint32Array?p=5125:h instanceof Int32Array?p=5124:h instanceof Int8Array?p=5120:h instanceof Uint8Array&&(p=5121),{buffer:d,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function i(c,u,h){const f=u.array,d=u.updateRange;n.bindBuffer(h,c),d.count===-1?n.bufferSubData(h,0,f):(t?n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),r.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=r.get(c);u&&(n.deleteBuffer(u.buffer),r.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const f=r.get(c);(!f||f.version<c.version)&&r.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=r.get(c);h===void 0?r.set(c,s(c,u)):h.version<c.version&&(i(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class p_ extends cn{constructor(e=1,t=1,r=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:s};const i=e/2,o=t/2,a=Math.floor(r),l=Math.floor(s),c=a+1,u=l+1,h=e/a,f=t/l,d=[],p=[],m=[],g=[];for(let y=0;y<u;y++){const b=y*f-o;for(let x=0;x<c;x++){const w=x*h-i;p.push(w,-b,0),m.push(0,0,1),g.push(x/a),g.push(1-y/l)}}for(let y=0;y<l;y++)for(let b=0;b<a;b++){const x=b+c*y,w=b+c*(y+1),_=b+1+c*(y+1),C=b+1+c*y;d.push(x,w,C),d.push(w,_,C)}this.setIndex(d),this.setAttribute("position",new Xt(p,3)),this.setAttribute("normal",new Xt(m,3)),this.setAttribute("uv",new Xt(g,2))}}var Odt=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Fdt=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Ldt=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,zdt=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,Bdt=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Vdt="vec3 transformed = vec3( position );",Udt=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Wdt=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,Gdt=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Hdt=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,jdt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,qdt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Xdt=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Kdt=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,Ydt=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,Zdt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Jdt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Qdt=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,ept=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,tpt=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,npt=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,rpt=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,spt=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,ipt=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,opt="gl_FragColor = linearToOutputTexel( gl_FragColor );",apt=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,lpt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,cpt=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,upt=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,hpt=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,fpt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,dpt=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,ppt=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,mpt=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,gpt=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,ypt=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,bpt=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,vpt=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,wpt=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,xpt=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,Spt=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,_pt=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Cpt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,kpt=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Tpt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,Ept=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,Ipt=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Apt=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Mpt=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,Npt=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,$pt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Rpt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Ppt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Dpt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Opt=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,Fpt=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Lpt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,zpt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Bpt=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Vpt=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Upt=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Wpt=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Gpt=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Hpt=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,jpt=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,qpt=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,Xpt=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Kpt=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,Ypt=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Zpt=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Jpt=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Qpt=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,emt=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,tmt=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,nmt=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,rmt=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,smt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,imt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,omt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,amt=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,lmt=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,cmt=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,umt=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,hmt=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,fmt=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,dmt=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,pmt=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,mmt=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,gmt=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,ymt=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,bmt=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,vmt=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,wmt=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,xmt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Smt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,_mt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,Cmt=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,kmt=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Tmt=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Emt=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Imt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Amt=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Mmt=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Nmt=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,$mt=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Rmt=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Pmt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Dmt=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Omt=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Fmt=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Lmt=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,zmt=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Bmt=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Vmt=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Umt=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Wmt=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Gmt=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Hmt=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,jmt=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,qmt=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Xmt=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Kmt=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,Ymt=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Zmt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Jmt=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Qmt=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,egt=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,tgt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ngt=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Jn={alphamap_fragment:Odt,alphamap_pars_fragment:Fdt,alphatest_fragment:Ldt,aomap_fragment:zdt,aomap_pars_fragment:Bdt,begin_vertex:Vdt,beginnormal_vertex:Udt,bsdfs:Wdt,bumpmap_pars_fragment:Gdt,clipping_planes_fragment:Hdt,clipping_planes_pars_fragment:jdt,clipping_planes_pars_vertex:qdt,clipping_planes_vertex:Xdt,color_fragment:Kdt,color_pars_fragment:Ydt,color_pars_vertex:Zdt,color_vertex:Jdt,common:Qdt,cube_uv_reflection_fragment:ept,defaultnormal_vertex:tpt,displacementmap_pars_vertex:npt,displacementmap_vertex:rpt,emissivemap_fragment:spt,emissivemap_pars_fragment:ipt,encodings_fragment:opt,encodings_pars_fragment:apt,envmap_fragment:lpt,envmap_common_pars_fragment:cpt,envmap_pars_fragment:upt,envmap_pars_vertex:hpt,envmap_physical_pars_fragment:Spt,envmap_vertex:fpt,fog_vertex:dpt,fog_pars_vertex:ppt,fog_fragment:mpt,fog_pars_fragment:gpt,gradientmap_pars_fragment:ypt,lightmap_fragment:bpt,lightmap_pars_fragment:vpt,lights_lambert_vertex:wpt,lights_pars_begin:xpt,lights_toon_fragment:_pt,lights_toon_pars_fragment:Cpt,lights_phong_fragment:kpt,lights_phong_pars_fragment:Tpt,lights_physical_fragment:Ept,lights_physical_pars_fragment:Ipt,lights_fragment_begin:Apt,lights_fragment_maps:Mpt,lights_fragment_end:Npt,logdepthbuf_fragment:$pt,logdepthbuf_pars_fragment:Rpt,logdepthbuf_pars_vertex:Ppt,logdepthbuf_vertex:Dpt,map_fragment:Opt,map_pars_fragment:Fpt,map_particle_fragment:Lpt,map_particle_pars_fragment:zpt,metalnessmap_fragment:Bpt,metalnessmap_pars_fragment:Vpt,morphnormal_vertex:Upt,morphtarget_pars_vertex:Wpt,morphtarget_vertex:Gpt,normal_fragment_begin:Hpt,normal_fragment_maps:jpt,normalmap_pars_fragment:qpt,clearcoat_normal_fragment_begin:Xpt,clearcoat_normal_fragment_maps:Kpt,clearcoat_pars_fragment:Ypt,packing:Zpt,premultiplied_alpha_fragment:Jpt,project_vertex:Qpt,dithering_fragment:emt,dithering_pars_fragment:tmt,roughnessmap_fragment:nmt,roughnessmap_pars_fragment:rmt,shadowmap_pars_fragment:smt,shadowmap_pars_vertex:imt,shadowmap_vertex:omt,shadowmask_pars_fragment:amt,skinbase_vertex:lmt,skinning_pars_vertex:cmt,skinning_vertex:umt,skinnormal_vertex:hmt,specularmap_fragment:fmt,specularmap_pars_fragment:dmt,tonemapping_fragment:pmt,tonemapping_pars_fragment:mmt,transmissionmap_fragment:gmt,transmissionmap_pars_fragment:ymt,uv_pars_fragment:bmt,uv_pars_vertex:vmt,uv_vertex:wmt,uv2_pars_fragment:xmt,uv2_pars_vertex:Smt,uv2_vertex:_mt,worldpos_vertex:Cmt,background_frag:kmt,background_vert:Tmt,cube_frag:Emt,cube_vert:Imt,depth_frag:Amt,depth_vert:Mmt,distanceRGBA_frag:Nmt,distanceRGBA_vert:$mt,equirect_frag:Rmt,equirect_vert:Pmt,linedashed_frag:Dmt,linedashed_vert:Omt,meshbasic_frag:Fmt,meshbasic_vert:Lmt,meshlambert_frag:zmt,meshlambert_vert:Bmt,meshmatcap_frag:Vmt,meshmatcap_vert:Umt,meshtoon_frag:Wmt,meshtoon_vert:Gmt,meshphong_frag:Hmt,meshphong_vert:jmt,meshphysical_frag:qmt,meshphysical_vert:Xmt,normal_frag:Kmt,normal_vert:Ymt,points_frag:Zmt,points_vert:Jmt,shadow_frag:Qmt,shadow_vert:egt,sprite_frag:tgt,sprite_vert:ngt},$t={common:{diffuse:{value:new jt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new kl},uv2Transform:{value:new kl},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new rt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new jt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new jt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new kl}},sprite:{diffuse:{value:new jt(15658734)},opacity:{value:1},center:{value:new rt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new kl}}},au={basic:{uniforms:Do([$t.common,$t.specularmap,$t.envmap,$t.aomap,$t.lightmap,$t.fog]),vertexShader:Jn.meshbasic_vert,fragmentShader:Jn.meshbasic_frag},lambert:{uniforms:Do([$t.common,$t.specularmap,$t.envmap,$t.aomap,$t.lightmap,$t.emissivemap,$t.fog,$t.lights,{emissive:{value:new jt(0)}}]),vertexShader:Jn.meshlambert_vert,fragmentShader:Jn.meshlambert_frag},phong:{uniforms:Do([$t.common,$t.specularmap,$t.envmap,$t.aomap,$t.lightmap,$t.emissivemap,$t.bumpmap,$t.normalmap,$t.displacementmap,$t.fog,$t.lights,{emissive:{value:new jt(0)},specular:{value:new jt(1118481)},shininess:{value:30}}]),vertexShader:Jn.meshphong_vert,fragmentShader:Jn.meshphong_frag},standard:{uniforms:Do([$t.common,$t.envmap,$t.aomap,$t.lightmap,$t.emissivemap,$t.bumpmap,$t.normalmap,$t.displacementmap,$t.roughnessmap,$t.metalnessmap,$t.fog,$t.lights,{emissive:{value:new jt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag},toon:{uniforms:Do([$t.common,$t.aomap,$t.lightmap,$t.emissivemap,$t.bumpmap,$t.normalmap,$t.displacementmap,$t.gradientmap,$t.fog,$t.lights,{emissive:{value:new jt(0)}}]),vertexShader:Jn.meshtoon_vert,fragmentShader:Jn.meshtoon_frag},matcap:{uniforms:Do([$t.common,$t.bumpmap,$t.normalmap,$t.displacementmap,$t.fog,{matcap:{value:null}}]),vertexShader:Jn.meshmatcap_vert,fragmentShader:Jn.meshmatcap_frag},points:{uniforms:Do([$t.points,$t.fog]),vertexShader:Jn.points_vert,fragmentShader:Jn.points_frag},dashed:{uniforms:Do([$t.common,$t.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Jn.linedashed_vert,fragmentShader:Jn.linedashed_frag},depth:{uniforms:Do([$t.common,$t.displacementmap]),vertexShader:Jn.depth_vert,fragmentShader:Jn.depth_frag},normal:{uniforms:Do([$t.common,$t.bumpmap,$t.normalmap,$t.displacementmap,{opacity:{value:1}}]),vertexShader:Jn.normal_vert,fragmentShader:Jn.normal_frag},sprite:{uniforms:Do([$t.sprite,$t.fog]),vertexShader:Jn.sprite_vert,fragmentShader:Jn.sprite_frag},background:{uniforms:{uvTransform:{value:new kl},t2D:{value:null}},vertexShader:Jn.background_vert,fragmentShader:Jn.background_frag},cube:{uniforms:Do([$t.envmap,{opacity:{value:1}}]),vertexShader:Jn.cube_vert,fragmentShader:Jn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Jn.equirect_vert,fragmentShader:Jn.equirect_frag},distanceRGBA:{uniforms:Do([$t.common,$t.displacementmap,{referencePosition:{value:new J},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Jn.distanceRGBA_vert,fragmentShader:Jn.distanceRGBA_frag},shadow:{uniforms:Do([$t.lights,$t.fog,{color:{value:new jt(0)},opacity:{value:1}}]),vertexShader:Jn.shadow_vert,fragmentShader:Jn.shadow_frag}};au.physical={uniforms:Do([au.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new rt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new jt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag};function rgt(n,e,t,r,s){const i=new jt(0);let o=0,a,l,c=null,u=0,h=null;function f(p,m,g,y){let b=m.isScene===!0?m.background:null;b&&b.isTexture&&(b=e.get(b));const x=n.xr,w=x.getSession&&x.getSession();w&&w.environmentBlendMode==="additive"&&(b=null),b===null?d(i,o):b&&b.isColor&&(d(b,1),y=!0),(n.autoClear||y)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),b&&(b.isCubeTexture||b.isWebGLCubeRenderTarget||b.mapping===ex)?(l===void 0&&(l=new hs(new wg(1,1,1),new _a({name:"BackgroundCubeMaterial",uniforms:cv(au.cube.uniforms),vertexShader:au.cube.vertexShader,fragmentShader:au.cube.fragmentShader,side:pi,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(_,C,k){this.matrixWorld.copyPosition(k.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),b.isWebGLCubeRenderTarget&&(b=b.texture),l.material.uniforms.envMap.value=b,l.material.uniforms.flipEnvMap.value=b.isCubeTexture&&b._needsFlipEnvMap?-1:1,(c!==b||u!==b.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):b&&b.isTexture&&(a===void 0&&(a=new hs(new p_(2,2),new _a({name:"BackgroundMaterial",uniforms:cv(au.background.uniforms),vertexShader:au.background.vertexShader,fragmentShader:au.background.fragmentShader,side:Qw,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=b,b.matrixAutoUpdate===!0&&b.updateMatrix(),a.material.uniforms.uvTransform.value.copy(b.matrix),(c!==b||u!==b.version||h!==n.toneMapping)&&(a.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function d(p,m){t.buffers.color.setClear(p.r,p.g,p.b,m,s)}return{getClearColor:function(){return i},setClearColor:function(p,m=1){i.set(p),o=m,d(i,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,d(i,o)},render:f}}function sgt(n,e,t,r){const s=n.getParameter(34921),i=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||i!==null,a={},l=m(null);let c=l;function u(R,D,z,B,X){let G=!1;if(o){const ee=p(B,z,D);c!==ee&&(c=ee,f(c.object)),G=g(B,X),G&&y(B,X)}else{const ee=D.wireframe===!0;(c.geometry!==B.id||c.program!==z.id||c.wireframe!==ee)&&(c.geometry=B.id,c.program=z.id,c.wireframe=ee,G=!0)}R.isInstancedMesh===!0&&(G=!0),X!==null&&t.update(X,34963),G&&(k(R,D,z,B),X!==null&&n.bindBuffer(34963,t.get(X).buffer))}function h(){return r.isWebGL2?n.createVertexArray():i.createVertexArrayOES()}function f(R){return r.isWebGL2?n.bindVertexArray(R):i.bindVertexArrayOES(R)}function d(R){return r.isWebGL2?n.deleteVertexArray(R):i.deleteVertexArrayOES(R)}function p(R,D,z){const B=z.wireframe===!0;let X=a[R.id];X===void 0&&(X={},a[R.id]=X);let G=X[D.id];G===void 0&&(G={},X[D.id]=G);let ee=G[B];return ee===void 0&&(ee=m(h()),G[B]=ee),ee}function m(R){const D=[],z=[],B=[];for(let X=0;X<s;X++)D[X]=0,z[X]=0,B[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:D,enabledAttributes:z,attributeDivisors:B,object:R,attributes:{},index:null}}function g(R,D){const z=c.attributes,B=R.attributes;let X=0;for(const G in B){const ee=z[G],pe=B[G];if(ee===void 0||ee.attribute!==pe||ee.data!==pe.data)return!0;X++}return c.attributesNum!==X||c.index!==D}function y(R,D){const z={},B=R.attributes;let X=0;for(const G in B){const ee=B[G],pe={};pe.attribute=ee,ee.data&&(pe.data=ee.data),z[G]=pe,X++}c.attributes=z,c.attributesNum=X,c.index=D}function b(){const R=c.newAttributes;for(let D=0,z=R.length;D<z;D++)R[D]=0}function x(R){w(R,0)}function w(R,D){const z=c.newAttributes,B=c.enabledAttributes,X=c.attributeDivisors;z[R]=1,B[R]===0&&(n.enableVertexAttribArray(R),B[R]=1),X[R]!==D&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R,D),X[R]=D)}function _(){const R=c.newAttributes,D=c.enabledAttributes;for(let z=0,B=D.length;z<B;z++)D[z]!==R[z]&&(n.disableVertexAttribArray(z),D[z]=0)}function C(R,D,z,B,X,G){r.isWebGL2===!0&&(z===5124||z===5125)?n.vertexAttribIPointer(R,D,z,X,G):n.vertexAttribPointer(R,D,z,B,X,G)}function k(R,D,z,B){if(r.isWebGL2===!1&&(R.isInstancedMesh||B.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;b();const X=B.attributes,G=z.getAttributes(),ee=D.defaultAttributeValues;for(const pe in G){const oe=G[pe];if(oe>=0){const Ne=X[pe];if(Ne!==void 0){const ke=Ne.normalized,De=Ne.itemSize,ge=t.get(Ne);if(ge===void 0)continue;const Xe=ge.buffer,Oe=ge.type,it=ge.bytesPerElement;if(Ne.isInterleavedBufferAttribute){const Ge=Ne.data,pt=Ge.stride,ut=Ne.offset;Ge&&Ge.isInstancedInterleavedBuffer?(w(oe,Ge.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Ge.meshPerAttribute*Ge.count)):x(oe),n.bindBuffer(34962,Xe),C(oe,De,Oe,ke,pt*it,ut*it)}else Ne.isInstancedBufferAttribute?(w(oe,Ne.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Ne.meshPerAttribute*Ne.count)):x(oe),n.bindBuffer(34962,Xe),C(oe,De,Oe,ke,0,0)}else if(pe==="instanceMatrix"){const ke=t.get(R.instanceMatrix);if(ke===void 0)continue;const De=ke.buffer,ge=ke.type;w(oe+0,1),w(oe+1,1),w(oe+2,1),w(oe+3,1),n.bindBuffer(34962,De),n.vertexAttribPointer(oe+0,4,ge,!1,64,0),n.vertexAttribPointer(oe+1,4,ge,!1,64,16),n.vertexAttribPointer(oe+2,4,ge,!1,64,32),n.vertexAttribPointer(oe+3,4,ge,!1,64,48)}else if(pe==="instanceColor"){const ke=t.get(R.instanceColor);if(ke===void 0)continue;const De=ke.buffer,ge=ke.type;w(oe,1),n.bindBuffer(34962,De),n.vertexAttribPointer(oe,3,ge,!1,12,0)}else if(ee!==void 0){const ke=ee[pe];if(ke!==void 0)switch(ke.length){case 2:n.vertexAttrib2fv(oe,ke);break;case 3:n.vertexAttrib3fv(oe,ke);break;case 4:n.vertexAttrib4fv(oe,ke);break;default:n.vertexAttrib1fv(oe,ke)}}}}_()}function A(){N();for(const R in a){const D=a[R];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R]}}function M(R){if(a[R.id]===void 0)return;const D=a[R.id];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R.id]}function I(R){for(const D in a){const z=a[D];if(z[R.id]===void 0)continue;const B=z[R.id];for(const X in B)d(B[X].object),delete B[X];delete z[R.id]}}function N(){O(),c!==l&&(c=l,f(c.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:N,resetDefaultState:O,dispose:A,releaseStatesOfGeometry:M,releaseStatesOfProgram:I,initAttributes:b,enableAttribute:x,disableUnusedAttributes:_}}function igt(n,e,t,r){const s=r.isWebGL2;let i;function o(c){i=c}function a(c,u){n.drawArrays(i,c,u),t.update(u,i,1)}function l(c,u,h){if(h===0)return;let f,d;if(s)f=n,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](i,c,u,h),t.update(u,i,h)}this.setMode=o,this.render=a,this.renderInstances=l}function ogt(n,e,t){let r;function s(){if(r!==void 0)return r;const C=e.get("EXT_texture_filter_anisotropic");return C!==null?r=n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT):r=0,r}function i(C){if(C==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=t.logarithmicDepthBuffer===!0,u=n.getParameter(34930),h=n.getParameter(35660),f=n.getParameter(3379),d=n.getParameter(34076),p=n.getParameter(34921),m=n.getParameter(36347),g=n.getParameter(36348),y=n.getParameter(36349),b=h>0,x=o||!!e.get("OES_texture_float"),w=b&&x,_=o?n.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:s,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:f,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:b,floatFragmentTextures:x,floatVertexTextures:w,maxSamples:_}}function agt(n){const e=this;let t=null,r=0,s=!1,i=!1;const o=new ch,a=new kl,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,f,d){const p=h.length!==0||f||r!==0||s;return s=f,t=u(h,d,0),r=h.length,p},this.beginShadows=function(){i=!0,u(null)},this.endShadows=function(){i=!1,c()},this.setState=function(h,f,d){const p=h.clippingPlanes,m=h.clipIntersection,g=h.clipShadows,y=n.get(h);if(!s||p===null||p.length===0||i&&!g)i?u(null):c();else{const b=i?0:r,x=b*4;let w=y.clippingState||null;l.value=w,w=u(p,f,x,d);for(let _=0;_!==x;++_)w[_]=t[_];y.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(h,f,d,p){const m=h!==null?h.length:0;let g=null;if(m!==0){if(g=l.value,p!==!0||g===null){const y=d+m*4,b=f.matrixWorldInverse;a.getNormalMatrix(b),(g===null||g.length<y)&&(g=new Float32Array(y));for(let x=0,w=d;x!==m;++x,w+=4)o.copy(h[x]).applyMatrix4(b,a),o.normal.toArray(g,w),g[w+3]=o.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,g}}function lgt(n){let e=new WeakMap;function t(o,a){return a===wA?o.mapping=FC:a===xA&&(o.mapping=LC),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===wA||a===xA)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderList(),u=n.getRenderTarget(),h=new oV(l.height/2);return h.fromEquirectangularTexture(n,o),e.set(o,h),n.setRenderTarget(u),n.setRenderList(c),o.addEventListener("dispose",s),t(h.texture,o.mapping)}else return null}}return o}function s(o){const a=o.target;a.removeEventListener("dispose",s);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:r,dispose:i}}function cgt(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let s;switch(r){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(r)}return e[r]=s,s}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(r){const s=t(r);return s===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),s}}}function ugt(n,e,t,r){const s={},i=new WeakMap;function o(h){const f=h.target;f.index!==null&&e.remove(f.index);for(const p in f.attributes)e.remove(f.attributes[p]);f.removeEventListener("dispose",o),delete s[f.id];const d=i.get(f);d&&(e.remove(d),i.delete(f)),r.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(h,f){return s[f.id]===!0||(f.addEventListener("dispose",o),s[f.id]=!0,t.memory.geometries++),f}function l(h){const f=h.attributes;for(const p in f)e.update(f[p],34962);const d=h.morphAttributes;for(const p in d){const m=d[p];for(let g=0,y=m.length;g<y;g++)e.update(m[g],34962)}}function c(h){const f=[],d=h.index,p=h.attributes.position;let m=0;if(d!==null){const b=d.array;m=d.version;for(let x=0,w=b.length;x<w;x+=3){const _=b[x+0],C=b[x+1],k=b[x+2];f.push(_,C,C,k,k,_)}}else{const b=p.array;m=p.version;for(let x=0,w=b.length/3-1;x<w;x+=3){const _=x+0,C=x+1,k=x+2;f.push(_,C,C,k,k,_)}}const g=new(Kae(f)>65535?vg:bg)(f,1);g.version=m;const y=i.get(h);y&&e.remove(y),i.set(h,g)}function u(h){const f=i.get(h);if(f){const d=h.index;d!==null&&f.version<d.version&&c(h)}else c(h);return i.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function hgt(n,e,t,r){const s=r.isWebGL2;let i;function o(f){i=f}let a,l;function c(f){a=f.type,l=f.bytesPerElement}function u(f,d){n.drawElements(i,d,a,f*l),t.update(d,i,1)}function h(f,d,p){if(p===0)return;let m,g;if(s)m=n,g="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[g](i,d,a,f*l,p),t.update(d,i,p)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function fgt(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(i,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(i/3);break;case 1:t.lines+=a*(i/2);break;case 3:t.lines+=a*(i-1);break;case 2:t.lines+=a*i;break;case 0:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function s(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:r}}function dgt(n,e){return n[0]-e[0]}function pgt(n,e){return Math.abs(e[1])-Math.abs(n[1])}function mgt(n){const e={},t=new Float32Array(8),r=[];for(let i=0;i<8;i++)r[i]=[i,0];function s(i,o,a,l){const c=i.morphTargetInfluences,u=c===void 0?0:c.length;let h=e[o.id];if(h===void 0){h=[];for(let g=0;g<u;g++)h[g]=[g,0];e[o.id]=h}for(let g=0;g<u;g++){const y=h[g];y[0]=g,y[1]=c[g]}h.sort(pgt);for(let g=0;g<8;g++)g<u&&h[g][1]?(r[g][0]=h[g][0],r[g][1]=h[g][1]):(r[g][0]=Number.MAX_SAFE_INTEGER,r[g][1]=0);r.sort(dgt);const f=a.morphTargets&&o.morphAttributes.position,d=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let g=0;g<8;g++){const y=r[g],b=y[0],x=y[1];b!==Number.MAX_SAFE_INTEGER&&x?(f&&o.getAttribute("morphTarget"+g)!==f[b]&&o.setAttribute("morphTarget"+g,f[b]),d&&o.getAttribute("morphNormal"+g)!==d[b]&&o.setAttribute("morphNormal"+g,d[b]),t[g]=x,p+=x):(f&&o.hasAttribute("morphTarget"+g)===!0&&o.deleteAttribute("morphTarget"+g),d&&o.hasAttribute("morphNormal"+g)===!0&&o.deleteAttribute("morphNormal"+g),t[g]=0)}const m=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",m),l.getUniforms().setValue(n,"morphTargetInfluences",t)}return{update:s}}function ggt(n,e,t,r){let s=new WeakMap;function i(l){const c=r.render.frame,u=l.geometry,h=e.get(l,u);return s.get(h)!==c&&(e.update(h),s.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){s=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:i,dispose:o}}function uv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Bi,this.minFilter=Bi,this.wrapR=fa,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}uv.prototype=Object.create(Kr.prototype);uv.prototype.constructor=uv;uv.prototype.isDataTexture2DArray=!0;function hv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Bi,this.minFilter=Bi,this.wrapR=fa,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}hv.prototype=Object.create(Kr.prototype);hv.prototype.constructor=hv;hv.prototype.isDataTexture3D=!0;const Jae=new Kr,ygt=new uv,bgt=new hv,Qae=new Ih,h8=[],f8=[],d8=new Float32Array(16),p8=new Float32Array(9),m8=new Float32Array(4);function ix(n,e,t){const r=n[0];if(r<=0||r>0)return n;const s=e*t;let i=h8[s];if(i===void 0&&(i=new Float32Array(s),h8[s]=i),e!==0){r.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function Nc(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function Fl(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function ele(n,e){let t=f8[e];t===void 0&&(t=new Int32Array(e),f8[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function vgt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function wgt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Nc(t,e))return;n.uniform2fv(this.addr,e),Fl(t,e)}}function xgt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Nc(t,e))return;n.uniform3fv(this.addr,e),Fl(t,e)}}function Sgt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Nc(t,e))return;n.uniform4fv(this.addr,e),Fl(t,e)}}function _gt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Nc(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Fl(t,e)}else{if(Nc(t,r))return;m8.set(r),n.uniformMatrix2fv(this.addr,!1,m8),Fl(t,r)}}function Cgt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Nc(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Fl(t,e)}else{if(Nc(t,r))return;p8.set(r),n.uniformMatrix3fv(this.addr,!1,p8),Fl(t,r)}}function kgt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Nc(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Fl(t,e)}else{if(Nc(t,r))return;d8.set(r),n.uniformMatrix4fv(this.addr,!1,d8),Fl(t,r)}}function Tgt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.safeSetTexture2D(e||Jae,s)}function Egt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture2DArray(e||ygt,s)}function Igt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture3D(e||bgt,s)}function Agt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.safeSetTextureCube(e||Qae,s)}function Mgt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function Ngt(n,e){const t=this.cache;Nc(t,e)||(n.uniform2iv(this.addr,e),Fl(t,e))}function $gt(n,e){const t=this.cache;Nc(t,e)||(n.uniform3iv(this.addr,e),Fl(t,e))}function Rgt(n,e){const t=this.cache;Nc(t,e)||(n.uniform4iv(this.addr,e),Fl(t,e))}function Pgt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function Dgt(n){switch(n){case 5126:return vgt;case 35664:return wgt;case 35665:return xgt;case 35666:return Sgt;case 35674:return _gt;case 35675:return Cgt;case 35676:return kgt;case 5124:case 35670:return Mgt;case 35667:case 35671:return Ngt;case 35668:case 35672:return $gt;case 35669:case 35673:return Rgt;case 5125:return Pgt;case 35678:case 36198:case 36298:case 36306:case 35682:return Tgt;case 35679:case 36299:case 36307:return Igt;case 35680:case 36300:case 36308:case 36293:return Agt;case 36289:case 36303:case 36311:case 36292:return Egt}}function Ogt(n,e){n.uniform1fv(this.addr,e)}function Fgt(n,e){n.uniform1iv(this.addr,e)}function Lgt(n,e){n.uniform2iv(this.addr,e)}function zgt(n,e){n.uniform3iv(this.addr,e)}function Bgt(n,e){n.uniform4iv(this.addr,e)}function Vgt(n,e){const t=ix(e,this.size,2);n.uniform2fv(this.addr,t)}function Ugt(n,e){const t=ix(e,this.size,3);n.uniform3fv(this.addr,t)}function Wgt(n,e){const t=ix(e,this.size,4);n.uniform4fv(this.addr,t)}function Ggt(n,e){const t=ix(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Hgt(n,e){const t=ix(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function jgt(n,e){const t=ix(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function qgt(n,e,t){const r=e.length,s=ele(t,r);n.uniform1iv(this.addr,s);for(let i=0;i!==r;++i)t.safeSetTexture2D(e[i]||Jae,s[i])}function Xgt(n,e,t){const r=e.length,s=ele(t,r);n.uniform1iv(this.addr,s);for(let i=0;i!==r;++i)t.safeSetTextureCube(e[i]||Qae,s[i])}function Kgt(n){switch(n){case 5126:return Ogt;case 35664:return Vgt;case 35665:return Ugt;case 35666:return Wgt;case 35674:return Ggt;case 35675:return Hgt;case 35676:return jgt;case 5124:case 35670:return Fgt;case 35667:case 35671:return Lgt;case 35668:case 35672:return zgt;case 35669:case 35673:return Bgt;case 35678:case 36198:case 36298:case 36306:case 35682:return qgt;case 35680:case 36300:case 36308:case 36293:return Xgt}}function Ygt(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=Dgt(e.type)}function tle(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Kgt(e.type)}tle.prototype.updateCache=function(n){const e=this.cache;n instanceof Float32Array&&e.length!==n.length&&(this.cache=new Float32Array(n.length)),Fl(e,n)};function nle(n){this.id=n,this.seq=[],this.map={}}nle.prototype.setValue=function(n,e,t){const r=this.seq;for(let s=0,i=r.length;s!==i;++s){const o=r[s];o.setValue(n,e[o.id],t)}};const CP=/(\w+)(\])?(\[|\.)?/g;function g8(n,e){n.seq.push(e),n.map[e.id]=e}function Zgt(n,e,t){const r=n.name,s=r.length;for(CP.lastIndex=0;;){const i=CP.exec(r),o=CP.lastIndex;let a=i[1];const l=i[2]==="]",c=i[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===s){g8(t,c===void 0?new Ygt(a,n,e):new tle(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new nle(a),g8(t,h)),t=h}}}function Xd(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let r=0;r<t;++r){const s=n.getActiveUniform(e,r),i=n.getUniformLocation(e,s.name);Zgt(s,i,this)}}Xd.prototype.setValue=function(n,e,t,r){const s=this.map[e];s!==void 0&&s.setValue(n,t,r)};Xd.prototype.setOptional=function(n,e,t){const r=e[t];r!==void 0&&this.setValue(n,t,r)};Xd.upload=function(n,e,t,r){for(let s=0,i=e.length;s!==i;++s){const o=e[s],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,r)}};Xd.seqWithValue=function(n,e){const t=[];for(let r=0,s=n.length;r!==s;++r){const i=n[r];i.id in e&&t.push(i)}return t};function y8(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}let Jgt=0;function Qgt(n){const e=n.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function rle(n){switch(n){case Sa:return["Linear","( value )"];case BC:return["sRGB","( value )"];case A$:return["RGBE","( value )"];case tV:return["RGBM","( value, 7.0 )"];case nV:return["RGBM","( value, 16.0 )"];case rV:return["RGBD","( value, 256.0 )"];case I$:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Wae:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function b8(n,e,t){const r=n.getShaderParameter(e,35713),s=n.getShaderInfoLog(e).trim();if(r&&s==="")return"";const i=n.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+s+Qgt(i)}function n1(n,e){const t=rle(e);return"vec4 "+n+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function eyt(n,e){const t=rle(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function tyt(n,e){let t;switch(e){case Uoe:t="Linear";break;case Woe:t="Reinhard";break;case Goe:t="OptimizedCineon";break;case Hoe:t="ACESFilmic";break;case joe:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function nyt(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter($1).join(`
`)}function ryt(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function syt(n,e){const t={},r=n.getProgramParameter(e,35721);for(let s=0;s<r;s++){const o=n.getActiveAttrib(e,s).name;t[o]=n.getAttribLocation(e,o)}return t}function $1(n){return n!==""}function v8(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function w8(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const iyt=/^[ \t]*#include +<([\w\d./]+)>/gm;function DF(n){return n.replace(iyt,oyt)}function oyt(n,e){const t=Jn[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return DF(t)}const ayt=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,lyt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function x8(n){return n.replace(lyt,sle).replace(ayt,cyt)}function cyt(n,e,t,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),sle(n,e,t,r)}function sle(n,e,t,r){let s="";for(let i=parseInt(e);i<parseInt(t);i++)s+=r.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return s}function S8(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function uyt(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===K4?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===woe?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===wb&&(e="SHADOWMAP_TYPE_VSM"),e}function hyt(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case FC:case LC:e="ENVMAP_TYPE_CUBE";break;case ex:case zC:e="ENVMAP_TYPE_CUBE_UV";break}return e}function fyt(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case LC:case zC:e="ENVMAP_MODE_REFRACTION";break}return e}function dyt(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case OC:e="ENVMAP_BLENDING_MULTIPLY";break;case Boe:e="ENVMAP_BLENDING_MIX";break;case Voe:e="ENVMAP_BLENDING_ADD";break}return e}function pyt(n,e,t,r){const s=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=uyt(t),c=hyt(t),u=fyt(t),h=dyt(t),f=n.gammaFactor>0?n.gammaFactor:1,d=t.isWebGL2?"":nyt(t),p=ryt(i),m=s.createProgram();let g,y,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(g=[p].filter($1).join(`
`),g.length>0&&(g+=`
`),y=[d,p].filter($1).join(`
`),y.length>0&&(y+=`
`)):(g=[S8(t),"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter($1).join(`
`),y=[d,S8(t),"#define SHADER_NAME "+t.shaderName,p,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ym?"#define TONE_MAPPING":"",t.toneMapping!==Ym?Jn.tonemapping_pars_fragment:"",t.toneMapping!==Ym?tyt("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",Jn.encodings_pars_fragment,t.map?n1("mapTexelToLinear",t.mapEncoding):"",t.matcap?n1("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?n1("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?n1("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?n1("lightMapTexelToLinear",t.lightMapEncoding):"",eyt("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter($1).join(`
`)),o=DF(o),o=v8(o,t),o=w8(o,t),a=DF(a),a=v8(a,t),a=w8(a,t),o=x8(o),a=x8(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,g=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+g,y=["#define varying in",t.glslVersion===PF?"":"out highp vec4 pc_fragColor;",t.glslVersion===PF?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const x=b+g+o,w=b+y+a,_=y8(s,35633,x),C=y8(s,35632,w);if(s.attachShader(m,_),s.attachShader(m,C),t.index0AttributeName!==void 0?s.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(m,0,"position"),s.linkProgram(m),n.debug.checkShaderErrors){const M=s.getProgramInfoLog(m).trim(),I=s.getShaderInfoLog(_).trim(),N=s.getShaderInfoLog(C).trim();let O=!0,R=!0;if(s.getProgramParameter(m,35714)===!1){O=!1;const D=b8(s,_,"vertex"),z=b8(s,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",s.getError(),"35715",s.getProgramParameter(m,35715),"gl.getProgramInfoLog",M,D,z)}else M!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",M):(I===""||N==="")&&(R=!1);R&&(this.diagnostics={runnable:O,programLog:M,vertexShader:{log:I,prefix:g},fragmentShader:{log:N,prefix:y}})}s.deleteShader(_),s.deleteShader(C);let k;this.getUniforms=function(){return k===void 0&&(k=new Xd(s,m)),k};let A;return this.getAttributes=function(){return A===void 0&&(A=syt(s,m)),A},this.destroy=function(){r.releaseStatesOfProgram(this),s.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=Jgt++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=_,this.fragmentShader=C,this}function myt(n,e,t,r,s,i){const o=[],a=r.isWebGL2,l=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,h=r.vertexTextures;let f=r.precision;const d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(C){const A=C.skeleton.bones;if(c)return 1024;{const I=Math.floor((u-20)/4),N=Math.min(I,A.length);return N<A.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+A.length+" bones. This GPU supports "+N+"."),0):N}}function g(C){let k;return C&&C.isTexture?k=C.encoding:C&&C.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),k=C.texture.encoding):k=Sa,k}function y(C,k,A,M,I){const N=M.fog,O=C.isMeshStandardMaterial?M.environment:null,R=e.get(C.envMap||O),D=d[C.type],z=I.isSkinnedMesh?m(I):0;C.precision!==null&&(f=r.getMaxPrecision(C.precision),f!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",f,"instead."));let B,X;if(D){const pe=au[D];B=pe.vertexShader,X=pe.fragmentShader}else B=C.vertexShader,X=C.fragmentShader;const G=n.getRenderTarget();return{isWebGL2:a,shaderID:D,shaderName:C.type,vertexShader:B,fragmentShader:X,defines:C.defines,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:f,instancing:I.isInstancedMesh===!0,instancingColor:I.isInstancedMesh===!0&&I.instanceColor!==null,supportsVertexTextures:h,outputEncoding:G!==null?g(G.texture):n.outputEncoding,map:!!C.map,mapEncoding:g(C.map),matcap:!!C.matcap,matcapEncoding:g(C.matcap),envMap:!!R,envMapMode:R&&R.mapping,envMapEncoding:g(R),envMapCubeUV:!!R&&(R.mapping===ex||R.mapping===zC),lightMap:!!C.lightMap,lightMapEncoding:g(C.lightMap),aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,emissiveMapEncoding:g(C.emissiveMap),bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===jae,tangentSpaceNormalMap:C.normalMapType===Yy,clearcoatMap:!!C.clearcoatMap,clearcoatRoughnessMap:!!C.clearcoatRoughnessMap,clearcoatNormalMap:!!C.clearcoatNormalMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,alphaMap:!!C.alphaMap,gradientMap:!!C.gradientMap,sheen:!!C.sheen,transmissionMap:!!C.transmissionMap,combine:C.combine,vertexTangents:C.normalMap&&C.vertexTangents,vertexColors:C.vertexColors,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.displacementMap||!!C.transmissionMap,uvsVertexOnly:!(C.map||C.bumpMap||C.normalMap||C.specularMap||C.alphaMap||C.emissiveMap||C.roughnessMap||C.metalnessMap||C.clearcoatNormalMap||C.transmissionMap)&&!!C.displacementMap,fog:!!N,useFog:C.fog,fogExp2:N&&N.isFogExp2,flatShading:C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:l,skinning:C.skinning&&z>0,maxBones:z,useVertexTexture:c,morphTargets:C.morphTargets,morphNormals:C.morphNormals,maxMorphTargets:n.maxMorphTargets,maxMorphNormals:n.maxMorphNormals,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:C.dithering,shadowMapEnabled:n.shadowMap.enabled&&A.length>0,shadowMapType:n.shadowMap.type,toneMapping:C.toneMapped?n.toneMapping:Ym,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,alphaTest:C.alphaTest,doubleSided:C.side===DC,flipSided:C.side===pi,depthPacking:C.depthPacking!==void 0?C.depthPacking:!1,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||t.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function b(C){const k=[];if(C.shaderID?k.push(C.shaderID):(k.push(C.fragmentShader),k.push(C.vertexShader)),C.defines!==void 0)for(const A in C.defines)k.push(A),k.push(C.defines[A]);if(C.isRawShaderMaterial===!1){for(let A=0;A<p.length;A++)k.push(C[p[A]]);k.push(n.outputEncoding),k.push(n.gammaFactor)}return k.push(C.customProgramCacheKey),k.join()}function x(C){const k=d[C.type];let A;if(k){const M=au[k];A=Yae.clone(M.uniforms)}else A=C.uniforms;return A}function w(C,k){let A;for(let M=0,I=o.length;M<I;M++){const N=o[M];if(N.cacheKey===k){A=N,++A.usedTimes;break}}return A===void 0&&(A=new pyt(n,k,C,s),o.push(A)),A}function _(C){if(--C.usedTimes===0){const k=o.indexOf(C);o[k]=o[o.length-1],o.pop(),C.destroy()}}return{getParameters:y,getProgramCacheKey:b,getUniforms:x,acquireProgram:w,releaseProgram:_,programs:o}}function gyt(){let n=new WeakMap;function e(i){let o=n.get(i);return o===void 0&&(o={},n.set(i,o)),o}function t(i){n.delete(i)}function r(i,o,a){n.get(i)[o]=a}function s(){n=new WeakMap}return{get:e,remove:t,update:r,dispose:s}}function yyt(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.program!==e.program?n.program.id-e.program.id:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function byt(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function _8(n){const e=[];let t=0;const r=[],s=[],i={id:-1};function o(){t=0,r.length=0,s.length=0}function a(f,d,p,m,g,y){let b=e[t];const x=n.get(p);return b===void 0?(b={id:f.id,object:f,geometry:d,material:p,program:x.program||i,groupOrder:m,renderOrder:f.renderOrder,z:g,group:y},e[t]=b):(b.id=f.id,b.object=f,b.geometry=d,b.material=p,b.program=x.program||i,b.groupOrder=m,b.renderOrder=f.renderOrder,b.z=g,b.group=y),t++,b}function l(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?s:r).push(b)}function c(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?s:r).unshift(b)}function u(f,d){r.length>1&&r.sort(f||yyt),s.length>1&&s.sort(d||byt)}function h(){for(let f=t,d=e.length;f<d;f++){const p=e[f];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:r,transparent:s,init:o,push:l,unshift:c,finish:h,sort:u}}function vyt(n){let e=new WeakMap;function t(s,i){const o=e.get(s);let a;return o===void 0?(a=new _8(n),e.set(s,new WeakMap),e.get(s).set(i,a)):(a=o.get(i),a===void 0&&(a=new _8(n),o.set(i,a))),a}function r(){e=new WeakMap}return{get:t,dispose:r}}function wyt(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new J,color:new jt};break;case"SpotLight":t={position:new J,direction:new J,color:new jt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new J,color:new jt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new J,skyColor:new jt,groundColor:new jt};break;case"RectAreaLight":t={color:new jt,position:new J,halfWidth:new J,halfHeight:new J};break}return n[e.id]=t,t}}}function xyt(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let Syt=0;function _yt(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function Cyt(n,e){const t=new wyt,r=xyt(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)s.probe.push(new J);const i=new J,o=new Zn,a=new Zn;function l(u){let h=0,f=0,d=0;for(let k=0;k<9;k++)s.probe[k].set(0,0,0);let p=0,m=0,g=0,y=0,b=0,x=0,w=0,_=0;u.sort(_yt);for(let k=0,A=u.length;k<A;k++){const M=u[k],I=M.color,N=M.intensity,O=M.distance,R=M.shadow&&M.shadow.map?M.shadow.map.texture:null;if(M.isAmbientLight)h+=I.r*N,f+=I.g*N,d+=I.b*N;else if(M.isLightProbe)for(let D=0;D<9;D++)s.probe[D].addScaledVector(M.sh.coefficients[D],N);else if(M.isDirectionalLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,s.directionalShadow[p]=B,s.directionalShadowMap[p]=R,s.directionalShadowMatrix[p]=M.shadow.matrix,x++}s.directional[p]=D,p++}else if(M.isSpotLight){const D=t.get(M);if(D.position.setFromMatrixPosition(M.matrixWorld),D.color.copy(I).multiplyScalar(N),D.distance=O,D.coneCos=Math.cos(M.angle),D.penumbraCos=Math.cos(M.angle*(1-M.penumbra)),D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,s.spotShadow[g]=B,s.spotShadowMap[g]=R,s.spotShadowMatrix[g]=M.shadow.matrix,_++}s.spot[g]=D,g++}else if(M.isRectAreaLight){const D=t.get(M);D.color.copy(I).multiplyScalar(N),D.halfWidth.set(M.width*.5,0,0),D.halfHeight.set(0,M.height*.5,0),s.rectArea[y]=D,y++}else if(M.isPointLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),D.distance=M.distance,D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,B.shadowCameraNear=z.camera.near,B.shadowCameraFar=z.camera.far,s.pointShadow[m]=B,s.pointShadowMap[m]=R,s.pointShadowMatrix[m]=M.shadow.matrix,w++}s.point[m]=D,m++}else if(M.isHemisphereLight){const D=t.get(M);D.skyColor.copy(M.color).multiplyScalar(N),D.groundColor.copy(M.groundColor).multiplyScalar(N),s.hemi[b]=D,b++}}y>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=$t.LTC_FLOAT_1,s.rectAreaLTC2=$t.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=$t.LTC_HALF_1,s.rectAreaLTC2=$t.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=h,s.ambient[1]=f,s.ambient[2]=d;const C=s.hash;(C.directionalLength!==p||C.pointLength!==m||C.spotLength!==g||C.rectAreaLength!==y||C.hemiLength!==b||C.numDirectionalShadows!==x||C.numPointShadows!==w||C.numSpotShadows!==_)&&(s.directional.length=p,s.spot.length=g,s.rectArea.length=y,s.point.length=m,s.hemi.length=b,s.directionalShadow.length=x,s.directionalShadowMap.length=x,s.pointShadow.length=w,s.pointShadowMap.length=w,s.spotShadow.length=_,s.spotShadowMap.length=_,s.directionalShadowMatrix.length=x,s.pointShadowMatrix.length=w,s.spotShadowMatrix.length=_,C.directionalLength=p,C.pointLength=m,C.spotLength=g,C.rectAreaLength=y,C.hemiLength=b,C.numDirectionalShadows=x,C.numPointShadows=w,C.numSpotShadows=_,s.version=Syt++)}function c(u,h){let f=0,d=0,p=0,m=0,g=0;const y=h.matrixWorldInverse;for(let b=0,x=u.length;b<x;b++){const w=u[b];if(w.isDirectionalLight){const _=s.directional[f];_.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),_.direction.sub(i),_.direction.transformDirection(y),f++}else if(w.isSpotLight){const _=s.spot[p];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),_.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),_.direction.sub(i),_.direction.transformDirection(y),p++}else if(w.isRectAreaLight){const _=s.rectArea[m];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),a.identity(),o.copy(w.matrixWorld),o.premultiply(y),a.extractRotation(o),_.halfWidth.set(w.width*.5,0,0),_.halfHeight.set(0,w.height*.5,0),_.halfWidth.applyMatrix4(a),_.halfHeight.applyMatrix4(a),m++}else if(w.isPointLight){const _=s.point[d];_.position.setFromMatrixPosition(w.matrixWorld),_.position.applyMatrix4(y),d++}else if(w.isHemisphereLight){const _=s.hemi[g];_.direction.setFromMatrixPosition(w.matrixWorld),_.direction.transformDirection(y),_.direction.normalize(),g++}}}return{setup:l,setupView:c,state:s}}function C8(n,e){const t=new Cyt(n,e),r=[],s=[];function i(){r.length=0,s.length=0}function o(h){r.push(h)}function a(h){s.push(h)}function l(){t.setup(r)}function c(h){t.setupView(r,h)}return{init:i,state:{lightsArray:r,shadowsArray:s,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function kyt(n,e){let t=new WeakMap;function r(i,o=0){let a;return t.has(i)===!1?(a=new C8(n,e),t.set(i,[]),t.get(i).push(a)):o>=t.get(i).length?(a=new C8(n,e),t.get(i).push(a)):a=t.get(i)[o],a}function s(){t=new WeakMap}return{get:r,dispose:s}}function fp(n){Sn.call(this),this.type="MeshDepthMaterial",this.depthPacking=Gae,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(n)}fp.prototype=Object.create(Sn.prototype);fp.prototype.constructor=fp;fp.prototype.isMeshDepthMaterial=!0;fp.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.depthPacking=n.depthPacking,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this};function dp(n){Sn.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new J,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(n)}dp.prototype=Object.create(Sn.prototype);dp.prototype.constructor=dp;dp.prototype.isMeshDistanceMaterial=!0;dp.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this};var Tyt=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,Eyt=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function ile(n,e,t){let r=new UC;const s=new rt,i=new rt,o=new Hr,a=[],l=[],c={},u={0:pi,1:Qw,2:DC},h=new _a({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new rt},radius:{value:4}},vertexShader:Eyt,fragmentShader:Tyt}),f=h.clone();f.defines.HORIZONTAL_PASS=1;const d=new cn;d.setAttribute("position",new xn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new hs(d,h),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=K4,this.render=function(_,C,k){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||_.length===0)return;const A=n.getRenderTarget(),M=n.getActiveCubeFace(),I=n.getActiveMipmapLevel(),N=n.state;N.setBlending(Nf),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let O=0,R=_.length;O<R;O++){const D=_[O],z=D.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",D,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;s.copy(z.mapSize);const B=z.getFrameExtents();if(s.multiply(B),i.copy(z.mapSize),(s.x>t||s.y>t)&&(s.x>t&&(i.x=Math.floor(t/B.x),s.x=i.x*B.x,z.mapSize.x=i.x),s.y>t&&(i.y=Math.floor(t/B.y),s.y=i.y*B.y,z.mapSize.y=i.y)),z.map===null&&!z.isPointLightShadow&&this.type===wb){const G={minFilter:ao,magFilter:ao,format:Ml};z.map=new qd(s.x,s.y,G),z.map.texture.name=D.name+".shadowMap",z.mapPass=new qd(s.x,s.y,G),z.camera.updateProjectionMatrix()}if(z.map===null){const G={minFilter:Bi,magFilter:Bi,format:Ml};z.map=new qd(s.x,s.y,G),z.map.texture.name=D.name+".shadowMap",z.camera.updateProjectionMatrix()}n.setRenderTarget(z.map),n.clear();const X=z.getViewportCount();for(let G=0;G<X;G++){const ee=z.getViewport(G);o.set(i.x*ee.x,i.y*ee.y,i.x*ee.z,i.y*ee.w),N.viewport(o),z.updateMatrices(D,G),r=z.getFrustum(),w(C,k,z.camera,D,this.type)}!z.isPointLightShadow&&this.type===wb&&g(z,k),z.needsUpdate=!1}m.needsUpdate=!1,n.setRenderTarget(A,M,I)};function g(_,C){const k=e.update(p);h.uniforms.shadow_pass.value=_.map.texture,h.uniforms.resolution.value=_.mapSize,h.uniforms.radius.value=_.radius,n.setRenderTarget(_.mapPass),n.clear(),n.renderBufferDirect(C,null,k,h,p,null),f.uniforms.shadow_pass.value=_.mapPass.texture,f.uniforms.resolution.value=_.mapSize,f.uniforms.radius.value=_.radius,n.setRenderTarget(_.map),n.clear(),n.renderBufferDirect(C,null,k,f,p,null)}function y(_,C,k){const A=_<<0|C<<1|k<<2;let M=a[A];return M===void 0&&(M=new fp({depthPacking:Hae,morphTargets:_,skinning:C}),a[A]=M),M}function b(_,C,k){const A=_<<0|C<<1|k<<2;let M=l[A];return M===void 0&&(M=new dp({morphTargets:_,skinning:C}),l[A]=M),M}function x(_,C,k,A,M,I,N){let O=null,R=y,D=_.customDepthMaterial;if(A.isPointLight===!0&&(R=b,D=_.customDistanceMaterial),D===void 0){let z=!1;k.morphTargets===!0&&(z=C.morphAttributes&&C.morphAttributes.position&&C.morphAttributes.position.length>0);let B=!1;_.isSkinnedMesh===!0&&(k.skinning===!0?B=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",_));const X=_.isInstancedMesh===!0;O=R(z,B,X)}else O=D;if(n.localClippingEnabled&&k.clipShadows===!0&&k.clippingPlanes.length!==0){const z=O.uuid,B=k.uuid;let X=c[z];X===void 0&&(X={},c[z]=X);let G=X[B];G===void 0&&(G=O.clone(),X[B]=G),O=G}return O.visible=k.visible,O.wireframe=k.wireframe,N===wb?O.side=k.shadowSide!==null?k.shadowSide:k.side:O.side=k.shadowSide!==null?k.shadowSide:u[k.side],O.clipShadows=k.clipShadows,O.clippingPlanes=k.clippingPlanes,O.clipIntersection=k.clipIntersection,O.wireframeLinewidth=k.wireframeLinewidth,O.linewidth=k.linewidth,A.isPointLight===!0&&O.isMeshDistanceMaterial===!0&&(O.referencePosition.setFromMatrixPosition(A.matrixWorld),O.nearDistance=M,O.farDistance=I),O}function w(_,C,k,A,M){if(_.visible===!1)return;if(_.layers.test(C.layers)&&(_.isMesh||_.isLine||_.isPoints)&&(_.castShadow||_.receiveShadow&&M===wb)&&(!_.frustumCulled||r.intersectsObject(_))){_.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,_.matrixWorld);const O=e.update(_),R=_.material;if(Array.isArray(R)){const D=O.groups;for(let z=0,B=D.length;z<B;z++){const X=D[z],G=R[X.materialIndex];if(G&&G.visible){const ee=x(_,O,G,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,ee,_,X)}}}else if(R.visible){const D=x(_,O,R,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,D,_,null)}}const N=_.children;for(let O=0,R=N.length;O<R;O++)w(N[O],C,k,A,M)}}function Iyt(n,e,t){const r=t.isWebGL2;function s(){let me=!1;const Ye=new Hr;let bt=null;const kt=new Hr(0,0,0,0);return{setMask:function(dt){bt!==dt&&!me&&(n.colorMask(dt,dt,dt,dt),bt=dt)},setLocked:function(dt){me=dt},setClear:function(dt,le,tt,Ct,yt){yt===!0&&(dt*=Ct,le*=Ct,tt*=Ct),Ye.set(dt,le,tt,Ct),kt.equals(Ye)===!1&&(n.clearColor(dt,le,tt,Ct),kt.copy(Ye))},reset:function(){me=!1,bt=null,kt.set(-1,0,0,0)}}}function i(){let me=!1,Ye=null,bt=null,kt=null;return{setTest:function(dt){dt?pe(2929):oe(2929)},setMask:function(dt){Ye!==dt&&!me&&(n.depthMask(dt),Ye=dt)},setFunc:function(dt){if(bt!==dt){if(dt)switch(dt){case Roe:n.depthFunc(512);break;case Poe:n.depthFunc(519);break;case Doe:n.depthFunc(513);break;case vA:n.depthFunc(515);break;case Ooe:n.depthFunc(514);break;case Foe:n.depthFunc(518);break;case Loe:n.depthFunc(516);break;case zoe:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);bt=dt}},setLocked:function(dt){me=dt},setClear:function(dt){kt!==dt&&(n.clearDepth(dt),kt=dt)},reset:function(){me=!1,Ye=null,bt=null,kt=null}}}function o(){let me=!1,Ye=null,bt=null,kt=null,dt=null,le=null,tt=null,Ct=null,yt=null;return{setTest:function(Ht){me||(Ht?pe(2960):oe(2960))},setMask:function(Ht){Ye!==Ht&&!me&&(n.stencilMask(Ht),Ye=Ht)},setFunc:function(Ht,En,_r){(bt!==Ht||kt!==En||dt!==_r)&&(n.stencilFunc(Ht,En,_r),bt=Ht,kt=En,dt=_r)},setOp:function(Ht,En,_r){(le!==Ht||tt!==En||Ct!==_r)&&(n.stencilOp(Ht,En,_r),le=Ht,tt=En,Ct=_r)},setLocked:function(Ht){me=Ht},setClear:function(Ht){yt!==Ht&&(n.clearStencil(Ht),yt=Ht)},reset:function(){me=!1,Ye=null,bt=null,kt=null,dt=null,le=null,tt=null,Ct=null,yt=null}}}const a=new s,l=new i,c=new o;let u={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,x=null,w=!1,_=null,C=null,k=null,A=null,M=null;const I=n.getParameter(35661);let N=!1,O=0;const R=n.getParameter(7938);R.indexOf("WebGL")!==-1?(O=parseFloat(/^WebGL (\d)/.exec(R)[1]),N=O>=1):R.indexOf("OpenGL ES")!==-1&&(O=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),N=O>=2);let D=null,z={};const B=new Hr,X=new Hr;function G(me,Ye,bt){const kt=new Uint8Array(4),dt=n.createTexture();n.bindTexture(me,dt),n.texParameteri(me,10241,9728),n.texParameteri(me,10240,9728);for(let le=0;le<bt;le++)n.texImage2D(Ye+le,0,6408,1,1,0,6408,5121,kt);return dt}const ee={};ee[3553]=G(3553,3553,1),ee[34067]=G(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),pe(2929),l.setFunc(vA),Oe(!1),it(bF),pe(2884),ge(Nf);function pe(me){u[me]!==!0&&(n.enable(me),u[me]=!0)}function oe(me){u[me]!==!1&&(n.disable(me),u[me]=!1)}function Ne(me){return h!==me?(n.useProgram(me),h=me,!0):!1}const ke={[Rm]:32774,[Soe]:32778,[_oe]:32779};if(r)ke[SF]=32775,ke[_F]=32776;else{const me=e.get("EXT_blend_minmax");me!==null&&(ke[SF]=me.MIN_EXT,ke[_F]=me.MAX_EXT)}const De={[Coe]:0,[koe]:1,[Toe]:768,[Z4]:770,[$oe]:776,[Moe]:774,[Ioe]:772,[Eoe]:769,[J4]:771,[Noe]:775,[Aoe]:773};function ge(me,Ye,bt,kt,dt,le,tt,Ct){if(me===Nf){f&&(oe(3042),f=!1);return}if(f||(pe(3042),f=!0),me!==xoe){if(me!==d||Ct!==w){if((p!==Rm||y!==Rm)&&(n.blendEquation(32774),p=Rm,y=Rm),Ct)switch(me){case $b:n.blendFuncSeparate(1,771,1,771);break;case vF:n.blendFunc(1,1);break;case wF:n.blendFuncSeparate(0,0,769,771);break;case xF:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",me);break}else switch(me){case $b:n.blendFuncSeparate(770,771,1,771);break;case vF:n.blendFunc(770,1);break;case wF:n.blendFunc(0,769);break;case xF:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",me);break}m=null,g=null,b=null,x=null,d=me,w=Ct}return}dt=dt||Ye,le=le||bt,tt=tt||kt,(Ye!==p||dt!==y)&&(n.blendEquationSeparate(ke[Ye],ke[dt]),p=Ye,y=dt),(bt!==m||kt!==g||le!==b||tt!==x)&&(n.blendFuncSeparate(De[bt],De[kt],De[le],De[tt]),m=bt,g=kt,b=le,x=tt),d=me,w=null}function Xe(me,Ye){me.side===DC?oe(2884):pe(2884);let bt=me.side===pi;Ye&&(bt=!bt),Oe(bt),me.blending===$b&&me.transparent===!1?ge(Nf):ge(me.blending,me.blendEquation,me.blendSrc,me.blendDst,me.blendEquationAlpha,me.blendSrcAlpha,me.blendDstAlpha,me.premultipliedAlpha),l.setFunc(me.depthFunc),l.setTest(me.depthTest),l.setMask(me.depthWrite),a.setMask(me.colorWrite);const kt=me.stencilWrite;c.setTest(kt),kt&&(c.setMask(me.stencilWriteMask),c.setFunc(me.stencilFunc,me.stencilRef,me.stencilFuncMask),c.setOp(me.stencilFail,me.stencilZFail,me.stencilZPass)),pt(me.polygonOffset,me.polygonOffsetFactor,me.polygonOffsetUnits)}function Oe(me){_!==me&&(me?n.frontFace(2304):n.frontFace(2305),_=me)}function it(me){me!==boe?(pe(2884),me!==C&&(me===bF?n.cullFace(1029):me===voe?n.cullFace(1028):n.cullFace(1032))):oe(2884),C=me}function Ge(me){me!==k&&(N&&n.lineWidth(me),k=me)}function pt(me,Ye,bt){me?(pe(32823),(A!==Ye||M!==bt)&&(n.polygonOffset(Ye,bt),A=Ye,M=bt)):oe(32823)}function ut(me){me?pe(3089):oe(3089)}function Ve(me){me===void 0&&(me=33984+I-1),D!==me&&(n.activeTexture(me),D=me)}function ze(me,Ye){D===null&&Ve();let bt=z[D];bt===void 0&&(bt={type:void 0,texture:void 0},z[D]=bt),(bt.type!==me||bt.texture!==Ye)&&(n.bindTexture(me,Ye||ee[me]),bt.type=me,bt.texture=Ye)}function Be(){const me=z[D];me!==void 0&&me.type!==void 0&&(n.bindTexture(me.type,null),me.type=void 0,me.texture=void 0)}function ht(){try{n.compressedTexImage2D.apply(n,arguments)}catch(me){console.error("THREE.WebGLState:",me)}}function Ke(){try{n.texImage2D.apply(n,arguments)}catch(me){console.error("THREE.WebGLState:",me)}}function Q(){try{n.texImage3D.apply(n,arguments)}catch(me){console.error("THREE.WebGLState:",me)}}function Z(me){B.equals(me)===!1&&(n.scissor(me.x,me.y,me.z,me.w),B.copy(me))}function nt(me){X.equals(me)===!1&&(n.viewport(me.x,me.y,me.z,me.w),X.copy(me))}function He(){u={},D=null,z={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,x=null,w=!1,_=null,C=null,k=null,A=null,M=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:pe,disable:oe,useProgram:Ne,setBlending:ge,setMaterial:Xe,setFlipSided:Oe,setCullFace:it,setLineWidth:Ge,setPolygonOffset:pt,setScissorTest:ut,activeTexture:Ve,bindTexture:ze,unbindTexture:Be,compressedTexImage2D:ht,texImage2D:Ke,texImage3D:Q,scissor:Z,viewport:nt,reset:He}}function Ayt(n,e,t,r,s,i,o){const a=s.isWebGL2,l=s.maxTextures,c=s.maxCubemapSize,u=s.maxTextureSize,h=s.maxSamples,f=new WeakMap;let d,p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(Q,Z){return p?new OffscreenCanvas(Q,Z):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(Q,Z,nt,He){let me=1;if((Q.width>He||Q.height>He)&&(me=He/Math.max(Q.width,Q.height)),me<1||Z===!0)if(typeof HTMLImageElement<"u"&&Q instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Q instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Q instanceof ImageBitmap){const Ye=Z?kn.floorPowerOfTwo:Math.floor,bt=Ye(me*Q.width),kt=Ye(me*Q.height);d===void 0&&(d=m(bt,kt));const dt=nt?m(bt,kt):d;return dt.width=bt,dt.height=kt,dt.getContext("2d").drawImage(Q,0,0,bt,kt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Q.width+"x"+Q.height+") to ("+bt+"x"+kt+")."),dt}else return"data"in Q&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Q.width+"x"+Q.height+")."),Q;return Q}function y(Q){return kn.isPowerOfTwo(Q.width)&&kn.isPowerOfTwo(Q.height)}function b(Q){return a?!1:Q.wrapS!==fa||Q.wrapT!==fa||Q.minFilter!==Bi&&Q.minFilter!==ao}function x(Q,Z){return Q.generateMipmaps&&Z&&Q.minFilter!==Bi&&Q.minFilter!==ao}function w(Q,Z,nt,He){n.generateMipmap(Q);const me=r.get(Z);me.__maxMipLevel=Math.log(Math.max(nt,He))*Math.LOG2E}function _(Q,Z,nt){if(a===!1)return Z;if(Q!==null){if(n[Q]!==void 0)return n[Q];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Q+"'")}let He=Z;return Z===6403&&(nt===5126&&(He=33326),nt===5131&&(He=33325),nt===5121&&(He=33321)),Z===6407&&(nt===5126&&(He=34837),nt===5131&&(He=34843),nt===5121&&(He=32849)),Z===6408&&(nt===5126&&(He=34836),nt===5131&&(He=34842),nt===5121&&(He=32856)),(He===33325||He===33326||He===34842||He===34836)&&e.get("EXT_color_buffer_float"),He}function C(Q){return Q===Bi||Q===SA||Q===_A?9728:9729}function k(Q){const Z=Q.target;Z.removeEventListener("dispose",k),M(Z),Z.isVideoTexture&&f.delete(Z),o.memory.textures--}function A(Q){const Z=Q.target;Z.removeEventListener("dispose",A),I(Z),o.memory.textures--}function M(Q){const Z=r.get(Q);Z.__webglInit!==void 0&&(n.deleteTexture(Z.__webglTexture),r.remove(Q))}function I(Q){const Z=r.get(Q),nt=r.get(Q.texture);if(Q){if(nt.__webglTexture!==void 0&&n.deleteTexture(nt.__webglTexture),Q.depthTexture&&Q.depthTexture.dispose(),Q.isWebGLCubeRenderTarget)for(let He=0;He<6;He++)n.deleteFramebuffer(Z.__webglFramebuffer[He]),Z.__webglDepthbuffer&&n.deleteRenderbuffer(Z.__webglDepthbuffer[He]);else n.deleteFramebuffer(Z.__webglFramebuffer),Z.__webglDepthbuffer&&n.deleteRenderbuffer(Z.__webglDepthbuffer),Z.__webglMultisampledFramebuffer&&n.deleteFramebuffer(Z.__webglMultisampledFramebuffer),Z.__webglColorRenderbuffer&&n.deleteRenderbuffer(Z.__webglColorRenderbuffer),Z.__webglDepthRenderbuffer&&n.deleteRenderbuffer(Z.__webglDepthRenderbuffer);r.remove(Q.texture),r.remove(Q)}}let N=0;function O(){N=0}function R(){const Q=N;return Q>=l&&console.warn("THREE.WebGLTextures: Trying to use "+Q+" texture units while this GPU supports only "+l),N+=1,Q}function D(Q,Z){const nt=r.get(Q);if(Q.isVideoTexture&&Ve(Q),Q.version>0&&nt.__version!==Q.version){const He=Q.image;if(He===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(He.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ne(nt,Q,Z);return}}t.activeTexture(33984+Z),t.bindTexture(3553,nt.__webglTexture)}function z(Q,Z){const nt=r.get(Q);if(Q.version>0&&nt.__version!==Q.version){Ne(nt,Q,Z);return}t.activeTexture(33984+Z),t.bindTexture(35866,nt.__webglTexture)}function B(Q,Z){const nt=r.get(Q);if(Q.version>0&&nt.__version!==Q.version){Ne(nt,Q,Z);return}t.activeTexture(33984+Z),t.bindTexture(32879,nt.__webglTexture)}function X(Q,Z){const nt=r.get(Q);if(Q.version>0&&nt.__version!==Q.version){ke(nt,Q,Z);return}t.activeTexture(33984+Z),t.bindTexture(34067,nt.__webglTexture)}const G={[t_]:10497,[fa]:33071,[n_]:33648},ee={[Bi]:9728,[SA]:9984,[_A]:9986,[ao]:9729,[Q4]:9985,[tx]:9987};function pe(Q,Z,nt){nt?(n.texParameteri(Q,10242,G[Z.wrapS]),n.texParameteri(Q,10243,G[Z.wrapT]),(Q===32879||Q===35866)&&n.texParameteri(Q,32882,G[Z.wrapR]),n.texParameteri(Q,10240,ee[Z.magFilter]),n.texParameteri(Q,10241,ee[Z.minFilter])):(n.texParameteri(Q,10242,33071),n.texParameteri(Q,10243,33071),(Q===32879||Q===35866)&&n.texParameteri(Q,32882,33071),(Z.wrapS!==fa||Z.wrapT!==fa)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(Q,10240,C(Z.magFilter)),n.texParameteri(Q,10241,C(Z.minFilter)),Z.minFilter!==Bi&&Z.minFilter!==ao&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const He=e.get("EXT_texture_filter_anisotropic");if(He){if(Z.type===Tf&&e.get("OES_texture_float_linear")===null||Z.type===s_&&(a||e.get("OES_texture_half_float_linear"))===null)return;(Z.anisotropy>1||r.get(Z).__currentAnisotropy)&&(n.texParameterf(Q,He.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(Z.anisotropy,s.getMaxAnisotropy())),r.get(Z).__currentAnisotropy=Z.anisotropy)}}function oe(Q,Z){Q.__webglInit===void 0&&(Q.__webglInit=!0,Z.addEventListener("dispose",k),Q.__webglTexture=n.createTexture(),o.memory.textures++)}function Ne(Q,Z,nt){let He=3553;Z.isDataTexture2DArray&&(He=35866),Z.isDataTexture3D&&(He=32879),oe(Q,Z),t.activeTexture(33984+nt),t.bindTexture(He,Q.__webglTexture),n.pixelStorei(37440,Z.flipY),n.pixelStorei(37441,Z.premultiplyAlpha),n.pixelStorei(3317,Z.unpackAlignment);const me=b(Z)&&y(Z.image)===!1,Ye=g(Z.image,me,!1,u),bt=y(Ye)||a,kt=i.convert(Z.format);let dt=i.convert(Z.type),le=_(Z.internalFormat,kt,dt);pe(He,Z,bt);let tt;const Ct=Z.mipmaps;if(Z.isDepthTexture)le=6402,a?Z.type===Tf?le=36012:Z.type===tS?le=33190:Z.type===Rb?le=35056:le=33189:Z.type===Tf&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),Z.format===Zm&&le===6402&&Z.type!==r_&&Z.type!==tS&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),Z.type=r_,dt=i.convert(Z.type)),Z.format===lv&&le===6402&&(le=34041,Z.type!==Rb&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),Z.type=Rb,dt=i.convert(Z.type))),t.texImage2D(3553,0,le,Ye.width,Ye.height,0,kt,dt,null);else if(Z.isDataTexture)if(Ct.length>0&&bt){for(let yt=0,Ht=Ct.length;yt<Ht;yt++)tt=Ct[yt],t.texImage2D(3553,yt,le,tt.width,tt.height,0,kt,dt,tt.data);Z.generateMipmaps=!1,Q.__maxMipLevel=Ct.length-1}else t.texImage2D(3553,0,le,Ye.width,Ye.height,0,kt,dt,Ye.data),Q.__maxMipLevel=0;else if(Z.isCompressedTexture){for(let yt=0,Ht=Ct.length;yt<Ht;yt++)tt=Ct[yt],Z.format!==Ml&&Z.format!==jd?kt!==null?t.compressedTexImage2D(3553,yt,le,tt.width,tt.height,0,tt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,yt,le,tt.width,tt.height,0,kt,dt,tt.data);Q.__maxMipLevel=Ct.length-1}else if(Z.isDataTexture2DArray)t.texImage3D(35866,0,le,Ye.width,Ye.height,Ye.depth,0,kt,dt,Ye.data),Q.__maxMipLevel=0;else if(Z.isDataTexture3D)t.texImage3D(32879,0,le,Ye.width,Ye.height,Ye.depth,0,kt,dt,Ye.data),Q.__maxMipLevel=0;else if(Ct.length>0&&bt){for(let yt=0,Ht=Ct.length;yt<Ht;yt++)tt=Ct[yt],t.texImage2D(3553,yt,le,kt,dt,tt);Z.generateMipmaps=!1,Q.__maxMipLevel=Ct.length-1}else t.texImage2D(3553,0,le,kt,dt,Ye),Q.__maxMipLevel=0;x(Z,bt)&&w(He,Z,Ye.width,Ye.height),Q.__version=Z.version,Z.onUpdate&&Z.onUpdate(Z)}function ke(Q,Z,nt){if(Z.image.length!==6)return;oe(Q,Z),t.activeTexture(33984+nt),t.bindTexture(34067,Q.__webglTexture),n.pixelStorei(37440,Z.flipY),n.pixelStorei(37441,Z.premultiplyAlpha),n.pixelStorei(3317,Z.unpackAlignment);const He=Z&&(Z.isCompressedTexture||Z.image[0].isCompressedTexture),me=Z.image[0]&&Z.image[0].isDataTexture,Ye=[];for(let yt=0;yt<6;yt++)!He&&!me?Ye[yt]=g(Z.image[yt],!1,!0,c):Ye[yt]=me?Z.image[yt].image:Z.image[yt];const bt=Ye[0],kt=y(bt)||a,dt=i.convert(Z.format),le=i.convert(Z.type),tt=_(Z.internalFormat,dt,le);pe(34067,Z,kt);let Ct;if(He){for(let yt=0;yt<6;yt++){Ct=Ye[yt].mipmaps;for(let Ht=0;Ht<Ct.length;Ht++){const En=Ct[Ht];Z.format!==Ml&&Z.format!==jd?dt!==null?t.compressedTexImage2D(34069+yt,Ht,tt,En.width,En.height,0,En.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+yt,Ht,tt,En.width,En.height,0,dt,le,En.data)}}Q.__maxMipLevel=Ct.length-1}else{Ct=Z.mipmaps;for(let yt=0;yt<6;yt++)if(me){t.texImage2D(34069+yt,0,tt,Ye[yt].width,Ye[yt].height,0,dt,le,Ye[yt].data);for(let Ht=0;Ht<Ct.length;Ht++){const _r=Ct[Ht].image[yt].image;t.texImage2D(34069+yt,Ht+1,tt,_r.width,_r.height,0,dt,le,_r.data)}}else{t.texImage2D(34069+yt,0,tt,dt,le,Ye[yt]);for(let Ht=0;Ht<Ct.length;Ht++){const En=Ct[Ht];t.texImage2D(34069+yt,Ht+1,tt,dt,le,En.image[yt])}}Q.__maxMipLevel=Ct.length}x(Z,kt)&&w(34067,Z,bt.width,bt.height),Q.__version=Z.version,Z.onUpdate&&Z.onUpdate(Z)}function De(Q,Z,nt,He){const me=i.convert(Z.texture.format),Ye=i.convert(Z.texture.type),bt=_(Z.texture.internalFormat,me,Ye);t.texImage2D(He,0,bt,Z.width,Z.height,0,me,Ye,null),n.bindFramebuffer(36160,Q),n.framebufferTexture2D(36160,nt,He,r.get(Z.texture).__webglTexture,0),n.bindFramebuffer(36160,null)}function ge(Q,Z,nt){if(n.bindRenderbuffer(36161,Q),Z.depthBuffer&&!Z.stencilBuffer){let He=33189;if(nt){const me=Z.depthTexture;me&&me.isDepthTexture&&(me.type===Tf?He=36012:me.type===tS&&(He=33190));const Ye=ut(Z);n.renderbufferStorageMultisample(36161,Ye,He,Z.width,Z.height)}else n.renderbufferStorage(36161,He,Z.width,Z.height);n.framebufferRenderbuffer(36160,36096,36161,Q)}else if(Z.depthBuffer&&Z.stencilBuffer){if(nt){const He=ut(Z);n.renderbufferStorageMultisample(36161,He,35056,Z.width,Z.height)}else n.renderbufferStorage(36161,34041,Z.width,Z.height);n.framebufferRenderbuffer(36160,33306,36161,Q)}else{const He=i.convert(Z.texture.format),me=i.convert(Z.texture.type),Ye=_(Z.texture.internalFormat,He,me);if(nt){const bt=ut(Z);n.renderbufferStorageMultisample(36161,bt,Ye,Z.width,Z.height)}else n.renderbufferStorage(36161,Ye,Z.width,Z.height)}n.bindRenderbuffer(36161,null)}function Xe(Q,Z){if(Z&&Z.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,Q),!(Z.depthTexture&&Z.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(Z.depthTexture).__webglTexture||Z.depthTexture.image.width!==Z.width||Z.depthTexture.image.height!==Z.height)&&(Z.depthTexture.image.width=Z.width,Z.depthTexture.image.height=Z.height,Z.depthTexture.needsUpdate=!0),D(Z.depthTexture,0);const He=r.get(Z.depthTexture).__webglTexture;if(Z.depthTexture.format===Zm)n.framebufferTexture2D(36160,36096,3553,He,0);else if(Z.depthTexture.format===lv)n.framebufferTexture2D(36160,33306,3553,He,0);else throw new Error("Unknown depthTexture format")}function Oe(Q){const Z=r.get(Q),nt=Q.isWebGLCubeRenderTarget===!0;if(Q.depthTexture){if(nt)throw new Error("target.depthTexture not supported in Cube render targets");Xe(Z.__webglFramebuffer,Q)}else if(nt){Z.__webglDepthbuffer=[];for(let He=0;He<6;He++)n.bindFramebuffer(36160,Z.__webglFramebuffer[He]),Z.__webglDepthbuffer[He]=n.createRenderbuffer(),ge(Z.__webglDepthbuffer[He],Q,!1)}else n.bindFramebuffer(36160,Z.__webglFramebuffer),Z.__webglDepthbuffer=n.createRenderbuffer(),ge(Z.__webglDepthbuffer,Q,!1);n.bindFramebuffer(36160,null)}function it(Q){const Z=r.get(Q),nt=r.get(Q.texture);Q.addEventListener("dispose",A),nt.__webglTexture=n.createTexture(),o.memory.textures++;const He=Q.isWebGLCubeRenderTarget===!0,me=Q.isWebGLMultisampleRenderTarget===!0,Ye=y(Q)||a;if(a&&Q.texture.format===jd&&(Q.texture.type===Tf||Q.texture.type===s_)&&(Q.texture.format=Ml,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),He){Z.__webglFramebuffer=[];for(let bt=0;bt<6;bt++)Z.__webglFramebuffer[bt]=n.createFramebuffer()}else if(Z.__webglFramebuffer=n.createFramebuffer(),me)if(a){Z.__webglMultisampledFramebuffer=n.createFramebuffer(),Z.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,Z.__webglColorRenderbuffer);const bt=i.convert(Q.texture.format),kt=i.convert(Q.texture.type),dt=_(Q.texture.internalFormat,bt,kt),le=ut(Q);n.renderbufferStorageMultisample(36161,le,dt,Q.width,Q.height),n.bindFramebuffer(36160,Z.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,Z.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),Q.depthBuffer&&(Z.__webglDepthRenderbuffer=n.createRenderbuffer(),ge(Z.__webglDepthRenderbuffer,Q,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(He){t.bindTexture(34067,nt.__webglTexture),pe(34067,Q.texture,Ye);for(let bt=0;bt<6;bt++)De(Z.__webglFramebuffer[bt],Q,36064,34069+bt);x(Q.texture,Ye)&&w(34067,Q.texture,Q.width,Q.height),t.bindTexture(34067,null)}else t.bindTexture(3553,nt.__webglTexture),pe(3553,Q.texture,Ye),De(Z.__webglFramebuffer,Q,36064,3553),x(Q.texture,Ye)&&w(3553,Q.texture,Q.width,Q.height),t.bindTexture(3553,null);Q.depthBuffer&&Oe(Q)}function Ge(Q){const Z=Q.texture,nt=y(Q)||a;if(x(Z,nt)){const He=Q.isWebGLCubeRenderTarget?34067:3553,me=r.get(Z).__webglTexture;t.bindTexture(He,me),w(He,Z,Q.width,Q.height),t.bindTexture(He,null)}}function pt(Q){if(Q.isWebGLMultisampleRenderTarget)if(a){const Z=r.get(Q);n.bindFramebuffer(36008,Z.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,Z.__webglFramebuffer);const nt=Q.width,He=Q.height;let me=16384;Q.depthBuffer&&(me|=256),Q.stencilBuffer&&(me|=1024),n.blitFramebuffer(0,0,nt,He,0,0,nt,He,me,9728),n.bindFramebuffer(36160,Z.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function ut(Q){return a&&Q.isWebGLMultisampleRenderTarget?Math.min(h,Q.samples):0}function Ve(Q){const Z=o.render.frame;f.get(Q)!==Z&&(f.set(Q,Z),Q.update())}let ze=!1,Be=!1;function ht(Q,Z){Q&&Q.isWebGLRenderTarget&&(ze===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),ze=!0),Q=Q.texture),D(Q,Z)}function Ke(Q,Z){Q&&Q.isWebGLCubeRenderTarget&&(Be===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Be=!0),Q=Q.texture),X(Q,Z)}this.allocateTextureUnit=R,this.resetTextureUnits=O,this.setTexture2D=D,this.setTexture2DArray=z,this.setTexture3D=B,this.setTextureCube=X,this.setupRenderTarget=it,this.updateRenderTargetMipmap=Ge,this.updateMultisampleRenderTarget=pt,this.safeSetTexture2D=ht,this.safeSetTextureCube=Ke}function ole(n,e,t){const r=t.isWebGL2;function s(i){let o;if(i===nx)return 5121;if(i===Yoe)return 32819;if(i===Zoe)return 32820;if(i===Joe)return 33635;if(i===qoe)return 5120;if(i===Xoe)return 5122;if(i===r_)return 5123;if(i===Koe)return 5124;if(i===tS)return 5125;if(i===Tf)return 5126;if(i===s_)return r?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(i===Qoe)return 6406;if(i===jd)return 6407;if(i===Ml)return 6408;if(i===eae)return 6409;if(i===tae)return 6410;if(i===Zm)return 6402;if(i===lv)return 34041;if(i===rae)return 6403;if(i===sae)return 36244;if(i===iae)return 33319;if(i===oae)return 33320;if(i===aae)return 36248;if(i===lae)return 36249;if(i===CF||i===kF||i===TF||i===EF)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(i===CF)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===kF)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===TF)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===EF)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===IF||i===AF||i===MF||i===NF)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(i===IF)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===AF)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===MF)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===NF)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===cae)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===$F||i===RF)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(i===$F)return o.COMPRESSED_RGB8_ETC2;if(i===RF)return o.COMPRESSED_RGBA8_ETC2_EAC}if(i===uae||i===hae||i===fae||i===dae||i===pae||i===mae||i===gae||i===yae||i===bae||i===vae||i===wae||i===xae||i===Sae||i===_ae||i===kae||i===Tae||i===Eae||i===Iae||i===Aae||i===Mae||i===Nae||i===$ae||i===Rae||i===Pae||i===Dae||i===Oae||i===Fae||i===Lae)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?i:null;if(i===Cae)return o=e.get("EXT_texture_compression_bptc"),o!==null?i:null;if(i===Rb)return r?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:s}}function CA(n=[]){xi.call(this),this.cameras=n}CA.prototype=Object.assign(Object.create(xi.prototype),{constructor:CA,isArrayCamera:!0});function Ld(){rn.call(this),this.type="Group"}Ld.prototype=Object.assign(Object.create(rn.prototype),{constructor:Ld,isGroup:!0});function rS(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(rS.prototype,{constructor:rS,getHandSpace:function(){return this._hand===null&&(this._hand=new Ld,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Ld,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Ld,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(n){return this._targetRay!==null&&this._targetRay.dispatchEvent(n),this._grip!==null&&this._grip.dispatchEvent(n),this._hand!==null&&this._hand.dispatchEvent(n),this},disconnect:function(n){return this.dispatchEvent({type:"disconnected",data:n}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(n,e,t){let r=null,s=null,i=null;const o=this._targetRay,a=this._grip,l=this._hand;if(n&&e.session.visibilityState!=="visible-blurred")if(l&&n.hand){i=!0;for(const p of n.hand.values()){const m=e.getJointPose(p,t);if(l.joints[p.jointName]===void 0){const y=new Ld;y.matrixAutoUpdate=!1,y.visible=!1,l.joints[p.jointName]=y,l.add(y)}const g=l.joints[p.jointName];m!==null&&(g.matrix.fromArray(m.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=m.radius),g.visible=m!==null}const c=l.joints["index-finger-tip"],u=l.joints["thumb-tip"],h=c.position.distanceTo(u.position),f=.02,d=.005;l.inputState.pinching&&h>f+d?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!l.inputState.pinching&&h<=f-d&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else o!==null&&(r=e.getPose(n.targetRaySpace,t),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&n.gripSpace&&(s=e.getPose(n.gripSpace,t),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=r!==null),a!==null&&(a.visible=s!==null),l!==null&&(l.visible=i!==null),this}});function ale(n,e){const t=this;let r=null,s=1,i=null,o="local-floor",a=null;const l=[],c=new Map,u=new xi;u.layers.enable(1),u.viewport=new Hr;const h=new xi;h.layers.enable(2),h.viewport=new Hr;const f=[u,h],d=new CA;d.layers.enable(1),d.layers.enable(2);let p=null,m=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(I){let N=l[I];return N===void 0&&(N=new rS,l[I]=N),N.getTargetRaySpace()},this.getControllerGrip=function(I){let N=l[I];return N===void 0&&(N=new rS,l[I]=N),N.getGripSpace()},this.getHand=function(I){let N=l[I];return N===void 0&&(N=new rS,l[I]=N),N.getHandSpace()};function g(I){const N=c.get(I.inputSource);N&&N.dispatchEvent({type:I.type,data:I.inputSource})}function y(){c.forEach(function(I,N){I.disconnect(N)}),c.clear(),p=null,m=null,n.setFramebuffer(null),n.setRenderTarget(n.getRenderTarget()),M.stop(),t.isPresenting=!1,t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(I){s=I,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(I){o=I,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i},this.getSession=function(){return r},this.setSession=async function(I){if(r=I,r!==null){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",y),r.addEventListener("inputsourceschange",b);const N=e.getContextAttributes();N.xrCompatible!==!0&&await e.makeXRCompatible();const O={antialias:N.antialias,alpha:N.alpha,depth:N.depth,stencil:N.stencil,framebufferScaleFactor:s},R=new XRWebGLLayer(r,e,O);r.updateRenderState({baseLayer:R}),i=await r.requestReferenceSpace(o),M.setContext(r),M.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}};function b(I){const N=r.inputSources;for(let O=0;O<l.length;O++)c.set(N[O],l[O]);for(let O=0;O<I.removed.length;O++){const R=I.removed[O],D=c.get(R);D&&(D.dispatchEvent({type:"disconnected",data:R}),c.delete(R))}for(let O=0;O<I.added.length;O++){const R=I.added[O],D=c.get(R);D&&D.dispatchEvent({type:"connected",data:R})}}const x=new J,w=new J;function _(I,N,O){x.setFromMatrixPosition(N.matrixWorld),w.setFromMatrixPosition(O.matrixWorld);const R=x.distanceTo(w),D=N.projectionMatrix.elements,z=O.projectionMatrix.elements,B=D[14]/(D[10]-1),X=D[14]/(D[10]+1),G=(D[9]+1)/D[5],ee=(D[9]-1)/D[5],pe=(D[8]-1)/D[0],oe=(z[8]+1)/z[0],Ne=B*pe,ke=B*oe,De=R/(-pe+oe),ge=De*-pe;N.matrixWorld.decompose(I.position,I.quaternion,I.scale),I.translateX(ge),I.translateZ(De),I.matrixWorld.compose(I.position,I.quaternion,I.scale),I.matrixWorldInverse.copy(I.matrixWorld).invert();const Xe=B+De,Oe=X+De,it=Ne-ge,Ge=ke+(R-ge),pt=G*X/Oe*Xe,ut=ee*X/Oe*Xe;I.projectionMatrix.makePerspective(it,Ge,pt,ut,Xe,Oe)}function C(I,N){N===null?I.matrixWorld.copy(I.matrix):I.matrixWorld.multiplyMatrices(N.matrixWorld,I.matrix),I.matrixWorldInverse.copy(I.matrixWorld).invert()}this.getCamera=function(I){d.near=h.near=u.near=I.near,d.far=h.far=u.far=I.far,(p!==d.near||m!==d.far)&&(r.updateRenderState({depthNear:d.near,depthFar:d.far}),p=d.near,m=d.far);const N=I.parent,O=d.cameras;C(d,N);for(let D=0;D<O.length;D++)C(O[D],N);I.matrixWorld.copy(d.matrixWorld),I.matrix.copy(d.matrix),I.matrix.decompose(I.position,I.quaternion,I.scale);const R=I.children;for(let D=0,z=R.length;D<z;D++)R[D].updateMatrixWorld(!0);return O.length===2?_(d,u,h):d.projectionMatrix.copy(u.projectionMatrix),d};let k=null;function A(I,N){if(a=N.getViewerPose(i),a!==null){const R=a.views,D=r.renderState.baseLayer;n.setFramebuffer(D.framebuffer);let z=!1;R.length!==d.cameras.length&&(d.cameras.length=0,z=!0);for(let B=0;B<R.length;B++){const X=R[B],G=D.getViewport(X),ee=f[B];ee.matrix.fromArray(X.transform.matrix),ee.projectionMatrix.fromArray(X.projectionMatrix),ee.viewport.set(G.x,G.y,G.width,G.height),B===0&&d.matrix.copy(ee.matrix),z===!0&&d.cameras.push(ee)}}const O=r.inputSources;for(let R=0;R<l.length;R++){const D=l[R],z=O[R];D.update(z,N,i)}k&&k(I,N)}const M=new Zae;M.setAnimationLoop(A),this.setAnimationLoop=function(I){k=I},this.dispose=function(){}}Object.assign(ale.prototype,Uu.prototype);function Myt(n){function e(y,b){y.fogColor.value.copy(b.color),b.isFog?(y.fogNear.value=b.near,y.fogFar.value=b.far):b.isFogExp2&&(y.fogDensity.value=b.density)}function t(y,b,x,w){b.isMeshBasicMaterial?r(y,b):b.isMeshLambertMaterial?(r(y,b),l(y,b)):b.isMeshToonMaterial?(r(y,b),u(y,b)):b.isMeshPhongMaterial?(r(y,b),c(y,b)):b.isMeshStandardMaterial?(r(y,b),b.isMeshPhysicalMaterial?f(y,b):h(y,b)):b.isMeshMatcapMaterial?(r(y,b),d(y,b)):b.isMeshDepthMaterial?(r(y,b),p(y,b)):b.isMeshDistanceMaterial?(r(y,b),m(y,b)):b.isMeshNormalMaterial?(r(y,b),g(y,b)):b.isLineBasicMaterial?(s(y,b),b.isLineDashedMaterial&&i(y,b)):b.isPointsMaterial?o(y,b,x,w):b.isSpriteMaterial?a(y,b):b.isShadowMaterial?(y.color.value.copy(b.color),y.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function r(y,b){y.opacity.value=b.opacity,b.color&&y.diffuse.value.copy(b.color),b.emissive&&y.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap),b.specularMap&&(y.specularMap.value=b.specularMap);const x=n.get(b).envMap;if(x){y.envMap.value=x,y.flipEnvMap.value=x.isCubeTexture&&x._needsFlipEnvMap?-1:1,y.reflectivity.value=b.reflectivity,y.refractionRatio.value=b.refractionRatio;const C=n.get(x).__maxMipLevel;C!==void 0&&(y.maxMipLevel.value=C)}b.lightMap&&(y.lightMap.value=b.lightMap,y.lightMapIntensity.value=b.lightMapIntensity),b.aoMap&&(y.aoMap.value=b.aoMap,y.aoMapIntensity.value=b.aoMapIntensity);let w;b.map?w=b.map:b.specularMap?w=b.specularMap:b.displacementMap?w=b.displacementMap:b.normalMap?w=b.normalMap:b.bumpMap?w=b.bumpMap:b.roughnessMap?w=b.roughnessMap:b.metalnessMap?w=b.metalnessMap:b.alphaMap?w=b.alphaMap:b.emissiveMap?w=b.emissiveMap:b.clearcoatMap?w=b.clearcoatMap:b.clearcoatNormalMap?w=b.clearcoatNormalMap:b.clearcoatRoughnessMap&&(w=b.clearcoatRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),y.uvTransform.value.copy(w.matrix));let _;b.aoMap?_=b.aoMap:b.lightMap&&(_=b.lightMap),_!==void 0&&(_.isWebGLRenderTarget&&(_=_.texture),_.matrixAutoUpdate===!0&&_.updateMatrix(),y.uv2Transform.value.copy(_.matrix))}function s(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity}function i(y,b){y.dashSize.value=b.dashSize,y.totalSize.value=b.dashSize+b.gapSize,y.scale.value=b.scale}function o(y,b,x,w){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.size.value=b.size*x,y.scale.value=w*.5,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let _;b.map?_=b.map:b.alphaMap&&(_=b.alphaMap),_!==void 0&&(_.matrixAutoUpdate===!0&&_.updateMatrix(),y.uvTransform.value.copy(_.matrix))}function a(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.rotation.value=b.rotation,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let x;b.map?x=b.map:b.alphaMap&&(x=b.alphaMap),x!==void 0&&(x.matrixAutoUpdate===!0&&x.updateMatrix(),y.uvTransform.value.copy(x.matrix))}function l(y,b){b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap)}function c(y,b){y.specular.value.copy(b.specular),y.shininess.value=Math.max(b.shininess,1e-4),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===pi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===pi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function u(y,b){b.gradientMap&&(y.gradientMap.value=b.gradientMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===pi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===pi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function h(y,b){y.roughness.value=b.roughness,y.metalness.value=b.metalness,b.roughnessMap&&(y.roughnessMap.value=b.roughnessMap),b.metalnessMap&&(y.metalnessMap.value=b.metalnessMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===pi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===pi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),n.get(b).envMap&&(y.envMapIntensity.value=b.envMapIntensity)}function f(y,b){h(y,b),y.reflectivity.value=b.reflectivity,y.clearcoat.value=b.clearcoat,y.clearcoatRoughness.value=b.clearcoatRoughness,b.sheen&&y.sheen.value.copy(b.sheen),b.clearcoatMap&&(y.clearcoatMap.value=b.clearcoatMap),b.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap),b.clearcoatNormalMap&&(y.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),y.clearcoatNormalMap.value=b.clearcoatNormalMap,b.side===pi&&y.clearcoatNormalScale.value.negate()),y.transmission.value=b.transmission,b.transmissionMap&&(y.transmissionMap.value=b.transmissionMap)}function d(y,b){b.matcap&&(y.matcap.value=b.matcap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===pi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===pi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function p(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function m(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),y.referencePosition.value.copy(b.referencePosition),y.nearDistance.value=b.nearDistance,y.farDistance.value=b.farDistance}function g(y,b){b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===pi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===pi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function Nyt(){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.style.display="block",n}function WC(n){n=n||{};const e=n.canvas!==void 0?n.canvas:Nyt(),t=n.context!==void 0?n.context:null,r=n.alpha!==void 0?n.alpha:!1,s=n.depth!==void 0?n.depth:!0,i=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",u=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h=null,f=null;const d=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Sa,this.physicallyCorrectLights=!1,this.toneMapping=Ym,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let m=!1,g=null,y=0,b=0,x=null,w=null,_=-1,C=null;const k=new Hr,A=new Hr;let M=null,I=e.width,N=e.height,O=1,R=null,D=null;const z=new Hr(0,0,I,N),B=new Hr(0,0,I,N);let X=!1;const G=new UC;let ee=!1,pe=!1;const oe=new Zn,Ne=new J,ke={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function De(){return x===null?O:1}let ge=t;function Xe(re,We){for(let Fe=0;Fe<re.length;Fe++){const Ze=re[Fe],wt=e.getContext(Ze,We);if(wt!==null)return wt}return null}try{const re={alpha:r,depth:s,stencil:i,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",En,!1),e.addEventListener("webglcontextrestored",_r,!1),ge===null){const We=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&We.shift(),ge=Xe(We,re),ge===null)throw Xe(We)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}ge.getShaderPrecisionFormat===void 0&&(ge.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(re){throw console.error("THREE.WebGLRenderer: "+re.message),re}let Oe,it,Ge,pt,ut,Ve,ze,Be,ht,Ke,Q,Z,nt,He,me,Ye,bt,kt,dt,le,tt;function Ct(){Oe=new cgt(ge),it=new ogt(ge,Oe,n),Oe.init(it),le=new ole(ge,Oe,it),Ge=new Iyt(ge,Oe,it),Ge.scissor(A.copy(B).multiplyScalar(O).floor()),Ge.viewport(k.copy(z).multiplyScalar(O).floor()),pt=new fgt,ut=new gyt,Ve=new Ayt(ge,Oe,Ge,ut,it,le,pt),ze=new lgt(p),Be=new Ddt(ge,it),tt=new sgt(ge,Oe,Be,it),ht=new ugt(ge,Be,pt,tt),Ke=new ggt(ge,ht,Be,pt),bt=new mgt(ge),me=new agt(ut),Q=new myt(p,ze,Oe,it,tt,me),Z=new Myt(ut),nt=new vyt(ut),He=new kyt(Oe,it),Ye=new rgt(p,ze,Ge,Ke,a),kt=new igt(ge,Oe,pt,it),dt=new hgt(ge,Oe,pt,it),pt.programs=Q.programs,p.capabilities=it,p.extensions=Oe,p.properties=ut,p.renderLists=nt,p.state=Ge,p.info=pt}Ct();const yt=new ale(p,ge);this.xr=yt;const Ht=new ile(p,Ke,it.maxTextureSize);this.shadowMap=Ht,this.getContext=function(){return ge},this.getContextAttributes=function(){return ge.getContextAttributes()},this.forceContextLoss=function(){const re=Oe.get("WEBGL_lose_context");re&&re.loseContext()},this.forceContextRestore=function(){const re=Oe.get("WEBGL_lose_context");re&&re.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(re){re!==void 0&&(O=re,this.setSize(I,N,!1))},this.getSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),re=new rt),re.set(I,N)},this.setSize=function(re,We,Fe){if(yt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}I=re,N=We,e.width=Math.floor(re*O),e.height=Math.floor(We*O),Fe!==!1&&(e.style.width=re+"px",e.style.height=We+"px"),this.setViewport(0,0,re,We)},this.getDrawingBufferSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),re=new rt),re.set(I*O,N*O).floor()},this.setDrawingBufferSize=function(re,We,Fe){I=re,N=We,O=Fe,e.width=Math.floor(re*Fe),e.height=Math.floor(We*Fe),this.setViewport(0,0,re,We)},this.getCurrentViewport=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),re=new Hr),re.copy(k)},this.getViewport=function(re){return re.copy(z)},this.setViewport=function(re,We,Fe,Ze){re.isVector4?z.set(re.x,re.y,re.z,re.w):z.set(re,We,Fe,Ze),Ge.viewport(k.copy(z).multiplyScalar(O).floor())},this.getScissor=function(re){return re.copy(B)},this.setScissor=function(re,We,Fe,Ze){re.isVector4?B.set(re.x,re.y,re.z,re.w):B.set(re,We,Fe,Ze),Ge.scissor(A.copy(B).multiplyScalar(O).floor())},this.getScissorTest=function(){return X},this.setScissorTest=function(re){Ge.setScissorTest(X=re)},this.setOpaqueSort=function(re){R=re},this.setTransparentSort=function(re){D=re},this.getClearColor=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),re=new jt),re.copy(Ye.getClearColor())},this.setClearColor=function(){Ye.setClearColor.apply(Ye,arguments)},this.getClearAlpha=function(){return Ye.getClearAlpha()},this.setClearAlpha=function(){Ye.setClearAlpha.apply(Ye,arguments)},this.clear=function(re,We,Fe){let Ze=0;(re===void 0||re)&&(Ze|=16384),(We===void 0||We)&&(Ze|=256),(Fe===void 0||Fe)&&(Ze|=1024),ge.clear(Ze)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",En,!1),e.removeEventListener("webglcontextrestored",_r,!1),nt.dispose(),He.dispose(),ut.dispose(),ze.dispose(),Ke.dispose(),tt.dispose(),yt.dispose(),fo.stop()};function En(re){re.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function _r(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,Ct()}function Bs(re){const We=re.target;We.removeEventListener("dispose",Bs),Ms(We)}function Ms(re){Ns(re),ut.remove(re)}function Ns(re){const We=ut.get(re).program;We!==void 0&&Q.releaseProgram(We)}function Lh(re,We){re.render(function(Fe){p.renderBufferImmediate(Fe,We)})}this.renderBufferImmediate=function(re,We){tt.initAttributes();const Fe=ut.get(re);re.hasPositions&&!Fe.position&&(Fe.position=ge.createBuffer()),re.hasNormals&&!Fe.normal&&(Fe.normal=ge.createBuffer()),re.hasUvs&&!Fe.uv&&(Fe.uv=ge.createBuffer()),re.hasColors&&!Fe.color&&(Fe.color=ge.createBuffer());const Ze=We.getAttributes();re.hasPositions&&(ge.bindBuffer(34962,Fe.position),ge.bufferData(34962,re.positionArray,35048),tt.enableAttribute(Ze.position),ge.vertexAttribPointer(Ze.position,3,5126,!1,0,0)),re.hasNormals&&(ge.bindBuffer(34962,Fe.normal),ge.bufferData(34962,re.normalArray,35048),tt.enableAttribute(Ze.normal),ge.vertexAttribPointer(Ze.normal,3,5126,!1,0,0)),re.hasUvs&&(ge.bindBuffer(34962,Fe.uv),ge.bufferData(34962,re.uvArray,35048),tt.enableAttribute(Ze.uv),ge.vertexAttribPointer(Ze.uv,2,5126,!1,0,0)),re.hasColors&&(ge.bindBuffer(34962,Fe.color),ge.bufferData(34962,re.colorArray,35048),tt.enableAttribute(Ze.color),ge.vertexAttribPointer(Ze.color,3,5126,!1,0,0)),tt.disableUnusedAttributes(),ge.drawArrays(4,0,re.count),re.count=0},this.renderBufferDirect=function(re,We,Fe,Ze,wt,zn){We===null&&(We=ke);const sn=wt.isMesh&&wt.matrixWorld.determinant()<0,_n=zh(re,We,Ze,wt);Ge.setMaterial(Ze,sn);let Cn=Fe.index;const In=Fe.attributes.position;if(Cn===null){if(In===void 0||In.count===0)return}else if(Cn.count===0)return;let er=1;Ze.wireframe===!0&&(Cn=ht.getWireframeAttribute(Fe),er=2),(Ze.morphTargets||Ze.morphNormals)&&bt.update(wt,Fe,Ze,_n),tt.setup(wt,Ze,_n,Fe,Cn);let vn,cr=kt;Cn!==null&&(vn=Be.get(Cn),cr=dt,cr.setIndex(vn));const Pi=Cn!==null?Cn.count:In.count,wr=Fe.drawRange.start*er,Yi=Fe.drawRange.count*er,Ar=zn!==null?zn.start*er:0,To=zn!==null?zn.count*er:1/0,ss=Math.max(wr,Ar),po=Math.min(Pi,wr+Yi,Ar+To)-1,Eo=Math.max(0,po-ss+1);if(Eo!==0){if(wt.isMesh)Ze.wireframe===!0?(Ge.setLineWidth(Ze.wireframeLinewidth*De()),cr.setMode(1)):cr.setMode(4);else if(wt.isLine){let $s=Ze.linewidth;$s===void 0&&($s=1),Ge.setLineWidth($s*De()),wt.isLineSegments?cr.setMode(1):wt.isLineLoop?cr.setMode(2):cr.setMode(3)}else wt.isPoints?cr.setMode(0):wt.isSprite&&cr.setMode(4);if(wt.isInstancedMesh)cr.renderInstances(ss,Eo,wt.count);else if(Fe.isInstancedBufferGeometry){const $s=Math.min(Fe.instanceCount,Fe._maxInstanceCount);cr.renderInstances(ss,Eo,$s)}else cr.render(ss,Eo)}},this.compile=function(re,We){f=He.get(re),f.init(),re.traverseVisible(function(Ze){Ze.isLight&&Ze.layers.test(We.layers)&&(f.pushLight(Ze),Ze.castShadow&&f.pushShadow(Ze))}),f.setupLights();const Fe=new WeakMap;re.traverse(function(Ze){const wt=Ze.material;if(wt)if(Array.isArray(wt))for(let zn=0;zn<wt.length;zn++){const sn=wt[zn];Fe.has(sn)===!1&&(Ri(sn,re,Ze),Fe.set(sn))}else Fe.has(wt)===!1&&(Ri(wt,re,Ze),Fe.set(wt))})};let Wl=null;function Gl(re){yt.isPresenting||Wl&&Wl(re)}const fo=new Zae;fo.setAnimationLoop(Gl),typeof window<"u"&&fo.setContext(window),this.setAnimationLoop=function(re){Wl=re,yt.setAnimationLoop(re),re===null?fo.stop():fo.start()},this.render=function(re,We){let Fe,Ze;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),Fe=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),Ze=arguments[3]),We!==void 0&&We.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;tt.resetDefaultState(),_=-1,C=null,re.autoUpdate===!0&&re.updateMatrixWorld(),We.parent===null&&We.updateMatrixWorld(),yt.enabled===!0&&yt.isPresenting===!0&&(We=yt.getCamera(We)),re.isScene===!0&&re.onBeforeRender(p,re,We,Fe||x),f=He.get(re,d.length),f.init(),d.push(f),oe.multiplyMatrices(We.projectionMatrix,We.matrixWorldInverse),G.setFromProjectionMatrix(oe),pe=this.localClippingEnabled,ee=me.init(this.clippingPlanes,pe,We),h=nt.get(re,We),h.init(),Hl(re,We,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(R,D),ee===!0&&me.beginShadows();const wt=f.state.shadowsArray;Ht.render(wt,re,We),f.setupLights(),f.setupLightsView(We),ee===!0&&me.endShadows(),this.info.autoReset===!0&&this.info.reset(),Fe!==void 0&&this.setRenderTarget(Fe),Ye.render(h,re,We,Ze);const zn=h.opaque,sn=h.transparent;zn.length>0&&Bc(zn,re,We),sn.length>0&&Bc(sn,re,We),re.isScene===!0&&re.onAfterRender(p,re,We),x!==null&&(Ve.updateRenderTargetMipmap(x),Ve.updateMultisampleRenderTarget(x)),Ge.buffers.depth.setTest(!0),Ge.buffers.depth.setMask(!0),Ge.buffers.color.setMask(!0),Ge.setPolygonOffset(!1),d.pop(),d.length>0?f=d[d.length-1]:f=null,h=null};function Hl(re,We,Fe,Ze){if(re.visible===!1)return;if(re.layers.test(We.layers)){if(re.isGroup)Fe=re.renderOrder;else if(re.isLOD)re.autoUpdate===!0&&re.update(We);else if(re.isLight)f.pushLight(re),re.castShadow&&f.pushShadow(re);else if(re.isSprite){if(!re.frustumCulled||G.intersectsSprite(re)){Ze&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(oe);const sn=Ke.update(re),_n=re.material;_n.visible&&h.push(re,sn,_n,Fe,Ne.z,null)}}else if(re.isImmediateRenderObject)Ze&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(oe),h.push(re,null,re.material,Fe,Ne.z,null);else if((re.isMesh||re.isLine||re.isPoints)&&(re.isSkinnedMesh&&re.skeleton.frame!==pt.render.frame&&(re.skeleton.update(),re.skeleton.frame=pt.render.frame),!re.frustumCulled||G.intersectsObject(re))){Ze&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(oe);const sn=Ke.update(re),_n=re.material;if(Array.isArray(_n)){const Cn=sn.groups;for(let In=0,er=Cn.length;In<er;In++){const vn=Cn[In],cr=_n[vn.materialIndex];cr&&cr.visible&&h.push(re,sn,cr,Fe,Ne.z,vn)}}else _n.visible&&h.push(re,sn,_n,Fe,Ne.z,null)}}const zn=re.children;for(let sn=0,_n=zn.length;sn<_n;sn++)Hl(zn[sn],We,Fe,Ze)}function Bc(re,We,Fe){const Ze=We.isScene===!0?We.overrideMaterial:null;for(let wt=0,zn=re.length;wt<zn;wt++){const sn=re[wt],_n=sn.object,Cn=sn.geometry,In=Ze===null?sn.material:Ze,er=sn.group;if(Fe.isArrayCamera){const vn=Fe.cameras;for(let cr=0,Pi=vn.length;cr<Pi;cr++){const wr=vn[cr];_n.layers.test(wr.layers)&&(Ge.viewport(k.copy(wr.viewport)),f.setupLightsView(wr),Vc(_n,We,wr,Cn,In,er))}}else Vc(_n,We,Fe,Cn,In,er)}}function Vc(re,We,Fe,Ze,wt,zn){if(re.onBeforeRender(p,We,Fe,Ze,wt,zn),re.modelViewMatrix.multiplyMatrices(Fe.matrixWorldInverse,re.matrixWorld),re.normalMatrix.getNormalMatrix(re.modelViewMatrix),re.isImmediateRenderObject){const sn=zh(Fe,We,wt,re);Ge.setMaterial(wt),tt.reset(),Lh(re,sn)}else p.renderBufferDirect(Fe,We,Ze,wt,re,zn);re.onAfterRender(p,We,Fe,Ze,wt,zn)}function Ri(re,We,Fe){We.isScene!==!0&&(We=ke);const Ze=ut.get(re),wt=f.state.lights,zn=f.state.shadowsArray,sn=wt.state.version,_n=Q.getParameters(re,wt.state,zn,We,Fe),Cn=Q.getProgramCacheKey(_n);let In=Ze.program,er=!0;if(Ze.environment=re.isMeshStandardMaterial?We.environment:null,Ze.fog=We.fog,Ze.envMap=ze.get(re.envMap||Ze.environment),In===void 0)re.addEventListener("dispose",Bs);else if(In.cacheKey!==Cn)Ns(re);else if(Ze.lightsStateVersion!==sn)er=!1;else{if(_n.shaderID!==void 0)return;er=!1}er&&(_n.uniforms=Q.getUniforms(re),re.onBeforeCompile(_n,p),In=Q.acquireProgram(_n,Cn),Ze.program=In,Ze.uniforms=_n.uniforms,Ze.outputEncoding=_n.outputEncoding);const vn=Ze.uniforms;(!re.isShaderMaterial&&!re.isRawShaderMaterial||re.clipping===!0)&&(Ze.numClippingPlanes=me.numPlanes,Ze.numIntersection=me.numIntersection,vn.clippingPlanes=me.uniform),Ze.needsLights=Bh(re),Ze.lightsStateVersion=sn,Ze.needsLights&&(vn.ambientLightColor.value=wt.state.ambient,vn.lightProbe.value=wt.state.probe,vn.directionalLights.value=wt.state.directional,vn.directionalLightShadows.value=wt.state.directionalShadow,vn.spotLights.value=wt.state.spot,vn.spotLightShadows.value=wt.state.spotShadow,vn.rectAreaLights.value=wt.state.rectArea,vn.ltc_1.value=wt.state.rectAreaLTC1,vn.ltc_2.value=wt.state.rectAreaLTC2,vn.pointLights.value=wt.state.point,vn.pointLightShadows.value=wt.state.pointShadow,vn.hemisphereLights.value=wt.state.hemi,vn.directionalShadowMap.value=wt.state.directionalShadowMap,vn.directionalShadowMatrix.value=wt.state.directionalShadowMatrix,vn.spotShadowMap.value=wt.state.spotShadowMap,vn.spotShadowMatrix.value=wt.state.spotShadowMatrix,vn.pointShadowMap.value=wt.state.pointShadowMap,vn.pointShadowMatrix.value=wt.state.pointShadowMatrix);const cr=Ze.program.getUniforms(),Pi=Xd.seqWithValue(cr.seq,vn);Ze.uniformsList=Pi}function zh(re,We,Fe,Ze){We.isScene!==!0&&(We=ke),Ve.resetTextureUnits();const wt=We.fog,zn=Fe.isMeshStandardMaterial?We.environment:null,sn=x===null?p.outputEncoding:x.texture.encoding,_n=ze.get(Fe.envMap||zn),Cn=ut.get(Fe),In=f.state.lights;if(ee===!0&&(pe===!0||re!==C)){const Ar=re===C&&Fe.id===_;me.setState(Fe,re,Ar)}Fe.version===Cn.__version?(Fe.fog&&Cn.fog!==wt||Cn.environment!==zn||Cn.needsLights&&Cn.lightsStateVersion!==In.state.version||Cn.numClippingPlanes!==void 0&&(Cn.numClippingPlanes!==me.numPlanes||Cn.numIntersection!==me.numIntersection)||Cn.outputEncoding!==sn||Cn.envMap!==_n)&&Ri(Fe,We,Ze):(Ri(Fe,We,Ze),Cn.__version=Fe.version);let er=!1,vn=!1,cr=!1;const Pi=Cn.program,wr=Pi.getUniforms(),Yi=Cn.uniforms;if(Ge.useProgram(Pi.program)&&(er=!0,vn=!0,cr=!0),Fe.id!==_&&(_=Fe.id,vn=!0),er||C!==re){if(wr.setValue(ge,"projectionMatrix",re.projectionMatrix),it.logarithmicDepthBuffer&&wr.setValue(ge,"logDepthBufFC",2/(Math.log(re.far+1)/Math.LN2)),C!==re&&(C=re,vn=!0,cr=!0),Fe.isShaderMaterial||Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshStandardMaterial||Fe.envMap){const Ar=wr.map.cameraPosition;Ar!==void 0&&Ar.setValue(ge,Ne.setFromMatrixPosition(re.matrixWorld))}(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial)&&wr.setValue(ge,"isOrthographic",re.isOrthographicCamera===!0),(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial||Fe.isShadowMaterial||Fe.skinning)&&wr.setValue(ge,"viewMatrix",re.matrixWorldInverse)}if(Fe.skinning){wr.setOptional(ge,Ze,"bindMatrix"),wr.setOptional(ge,Ze,"bindMatrixInverse");const Ar=Ze.skeleton;if(Ar){const To=Ar.bones;if(it.floatVertexTextures){if(Ar.boneTexture===null){let ss=Math.sqrt(To.length*4);ss=kn.ceilPowerOfTwo(ss),ss=Math.max(ss,4);const po=new Float32Array(ss*ss*4);po.set(Ar.boneMatrices);const Eo=new Ff(po,ss,ss,Ml,Tf);Ar.boneMatrices=po,Ar.boneTexture=Eo,Ar.boneTextureSize=ss}wr.setValue(ge,"boneTexture",Ar.boneTexture,Ve),wr.setValue(ge,"boneTextureSize",Ar.boneTextureSize)}else wr.setOptional(ge,Ar,"boneMatrices")}}return(vn||Cn.receiveShadow!==Ze.receiveShadow)&&(Cn.receiveShadow=Ze.receiveShadow,wr.setValue(ge,"receiveShadow",Ze.receiveShadow)),vn&&(wr.setValue(ge,"toneMappingExposure",p.toneMappingExposure),Cn.needsLights&&sl(Yi,cr),wt&&Fe.fog&&Z.refreshFogUniforms(Yi,wt),Z.refreshMaterialUniforms(Yi,Fe,O,N),Xd.upload(ge,Cn.uniformsList,Yi,Ve)),Fe.isShaderMaterial&&Fe.uniformsNeedUpdate===!0&&(Xd.upload(ge,Cn.uniformsList,Yi,Ve),Fe.uniformsNeedUpdate=!1),Fe.isSpriteMaterial&&wr.setValue(ge,"center",Ze.center),wr.setValue(ge,"modelViewMatrix",Ze.modelViewMatrix),wr.setValue(ge,"normalMatrix",Ze.normalMatrix),wr.setValue(ge,"modelMatrix",Ze.matrixWorld),Pi}function sl(re,We){re.ambientLightColor.needsUpdate=We,re.lightProbe.needsUpdate=We,re.directionalLights.needsUpdate=We,re.directionalLightShadows.needsUpdate=We,re.pointLights.needsUpdate=We,re.pointLightShadows.needsUpdate=We,re.spotLights.needsUpdate=We,re.spotLightShadows.needsUpdate=We,re.rectAreaLights.needsUpdate=We,re.hemisphereLights.needsUpdate=We}function Bh(re){return re.isMeshLambertMaterial||re.isMeshToonMaterial||re.isMeshPhongMaterial||re.isMeshStandardMaterial||re.isShadowMaterial||re.isShaderMaterial&&re.lights===!0}this.setFramebuffer=function(re){g!==re&&x===null&&ge.bindFramebuffer(36160,re),g=re},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderList=function(){return h},this.setRenderList=function(re){h=re},this.getRenderTarget=function(){return x},this.setRenderTarget=function(re,We=0,Fe=0){x=re,y=We,b=Fe,re&&ut.get(re).__webglFramebuffer===void 0&&Ve.setupRenderTarget(re);let Ze=g,wt=!1;if(re){const zn=ut.get(re).__webglFramebuffer;re.isWebGLCubeRenderTarget?(Ze=zn[We],wt=!0):re.isWebGLMultisampleRenderTarget?Ze=ut.get(re).__webglMultisampledFramebuffer:Ze=zn,k.copy(re.viewport),A.copy(re.scissor),M=re.scissorTest}else k.copy(z).multiplyScalar(O).floor(),A.copy(B).multiplyScalar(O).floor(),M=X;if(w!==Ze&&(ge.bindFramebuffer(36160,Ze),w=Ze),Ge.viewport(k),Ge.scissor(A),Ge.setScissorTest(M),wt){const zn=ut.get(re.texture);ge.framebufferTexture2D(36160,36064,34069+We,zn.__webglTexture,Fe)}},this.readRenderTargetPixels=function(re,We,Fe,Ze,wt,zn,sn){if(!(re&&re.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let _n=ut.get(re).__webglFramebuffer;if(re.isWebGLCubeRenderTarget&&sn!==void 0&&(_n=_n[sn]),_n){let Cn=!1;_n!==w&&(ge.bindFramebuffer(36160,_n),Cn=!0);try{const In=re.texture,er=In.format,vn=In.type;if(er!==Ml&&le.convert(er)!==ge.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const cr=vn===s_&&(Oe.has("EXT_color_buffer_half_float")||it.isWebGL2&&Oe.has("EXT_color_buffer_float"));if(vn!==nx&&le.convert(vn)!==ge.getParameter(35738)&&!(vn===Tf&&(it.isWebGL2||Oe.has("OES_texture_float")||Oe.has("WEBGL_color_buffer_float")))&&!cr){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ge.checkFramebufferStatus(36160)===36053?We>=0&&We<=re.width-Ze&&Fe>=0&&Fe<=re.height-wt&&ge.readPixels(We,Fe,Ze,wt,le.convert(er),le.convert(vn),zn):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{Cn&&ge.bindFramebuffer(36160,w)}}},this.copyFramebufferToTexture=function(re,We,Fe=0){const Ze=Math.pow(2,-Fe),wt=Math.floor(We.image.width*Ze),zn=Math.floor(We.image.height*Ze),sn=le.convert(We.format);Ve.setTexture2D(We,0),ge.copyTexImage2D(3553,Fe,sn,re.x,re.y,wt,zn,0),Ge.unbindTexture()},this.copyTextureToTexture=function(re,We,Fe,Ze=0){const wt=We.image.width,zn=We.image.height,sn=le.convert(Fe.format),_n=le.convert(Fe.type);Ve.setTexture2D(Fe,0),ge.pixelStorei(37440,Fe.flipY),ge.pixelStorei(37441,Fe.premultiplyAlpha),ge.pixelStorei(3317,Fe.unpackAlignment),We.isDataTexture?ge.texSubImage2D(3553,Ze,re.x,re.y,wt,zn,sn,_n,We.image.data):We.isCompressedTexture?ge.compressedTexSubImage2D(3553,Ze,re.x,re.y,We.mipmaps[0].width,We.mipmaps[0].height,sn,We.mipmaps[0].data):ge.texSubImage2D(3553,Ze,re.x,re.y,sn,_n,We.image),Ze===0&&Fe.generateMipmaps&&ge.generateMipmap(3553),Ge.unbindTexture()},this.initTexture=function(re){Ve.setTexture2D(re,0),Ge.unbindTexture()},this.resetState=function(){Ge.reset(),tt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function OF(n){WC.call(this,n)}OF.prototype=Object.assign(Object.create(WC.prototype),{constructor:OF,isWebGL1Renderer:!0});class M${constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new jt(e),this.density=t!==void 0?t:25e-5}clone(){return new M$(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class N${constructor(e,t,r){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new jt(e),this.near=t!==void 0?t:1,this.far=r!==void 0?r:1e3}clone(){return new N$(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class aV extends rn{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}function Tl(n,e){this.array=n,this.stride=e,this.count=n!==void 0?n.length/e:0,this.usage=VC,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=kn.generateUUID()}Object.defineProperty(Tl.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Tl.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.stride,t*=e.stride;for(let r=0,s=this.stride;r<s;r++)this.array[n+r]=e.array[t+r];return this},set:function(n,e=0){return this.array.set(n,e),this},clone:function(n){n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=kn.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new Tl(e,this.stride);return t.setUsage(this.usage),t},onUpload:function(n){return this.onUploadCallback=n,this},toJSON:function(n){return n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=kn.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const um=new J;function pp(n,e,t,r){this.name="",this.data=n,this.itemSize=e,this.offset=t,this.normalized=r===!0}Object.defineProperties(pp.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(n){this.data.needsUpdate=n}}});Object.assign(pp.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(n){for(let e=0,t=this.data.count;e<t;e++)um.x=this.getX(e),um.y=this.getY(e),um.z=this.getZ(e),um.applyMatrix4(n),this.setXYZ(e,um.x,um.y,um.z);return this},setX:function(n,e){return this.data.array[n*this.data.stride+this.offset]=e,this},setY:function(n,e){return this.data.array[n*this.data.stride+this.offset+1]=e,this},setZ:function(n,e){return this.data.array[n*this.data.stride+this.offset+2]=e,this},setW:function(n,e){return this.data.array[n*this.data.stride+this.offset+3]=e,this},getX:function(n){return this.data.array[n*this.data.stride+this.offset]},getY:function(n){return this.data.array[n*this.data.stride+this.offset+1]},getZ:function(n){return this.data.array[n*this.data.stride+this.offset+2]},getW:function(n){return this.data.array[n*this.data.stride+this.offset+3]},setXY:function(n,e,t){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this},setXYZW:function(n,e,t,r,s){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this.data.array[n+3]=s,this},clone:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return new xn(new this.array.constructor(e),this.itemSize,this.normalized)}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new pp(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function mp(n){Sn.call(this),this.type="SpriteMaterial",this.color=new jt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(n)}mp.prototype=Object.create(Sn.prototype);mp.prototype.constructor=mp;mp.prototype.isSpriteMaterial=!0;mp.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this};let J0;const r1=new J,Q0=new J,eb=new J,tb=new rt,s1=new rt,lle=new Zn,YT=new J,i1=new J,ZT=new J,k8=new rt,kP=new rt,T8=new rt;function m_(n){if(rn.call(this),this.type="Sprite",J0===void 0){J0=new cn;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new Tl(e,5);J0.setIndex([0,1,2,0,2,3]),J0.setAttribute("position",new pp(t,3,0,!1)),J0.setAttribute("uv",new pp(t,2,3,!1))}this.geometry=J0,this.material=n!==void 0?n:new mp,this.center=new rt(.5,.5)}m_.prototype=Object.assign(Object.create(rn.prototype),{constructor:m_,isSprite:!0,raycast:function(n,e){n.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Q0.setFromMatrixScale(this.matrixWorld),lle.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),eb.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Q0.multiplyScalar(-eb.z);const t=this.material.rotation;let r,s;t!==0&&(s=Math.cos(t),r=Math.sin(t));const i=this.center;JT(YT.set(-.5,-.5,0),eb,i,Q0,r,s),JT(i1.set(.5,-.5,0),eb,i,Q0,r,s),JT(ZT.set(.5,.5,0),eb,i,Q0,r,s),k8.set(0,0),kP.set(1,0),T8.set(1,1);let o=n.ray.intersectTriangle(YT,i1,ZT,!1,r1);if(o===null&&(JT(i1.set(-.5,.5,0),eb,i,Q0,r,s),kP.set(0,1),o=n.ray.intersectTriangle(YT,ZT,i1,!1,r1),o===null))return;const a=n.ray.origin.distanceTo(r1);a<n.near||a>n.far||e.push({distance:a,point:r1.clone(),uv:Go.getUV(r1,YT,i1,ZT,k8,kP,T8,new rt),face:null,object:this})},copy:function(n){return rn.prototype.copy.call(this,n),n.center!==void 0&&this.center.copy(n.center),this.material=n.material,this}});function JT(n,e,t,r,s,i){tb.subVectors(n,t).addScalar(.5).multiply(r),s!==void 0?(s1.x=i*tb.x-s*tb.y,s1.y=s*tb.x+i*tb.y):s1.copy(tb),n.copy(e),n.x+=s1.x,n.y+=s1.y,n.applyMatrix4(lle)}const QT=new J,E8=new J;function g_(){rn.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}g_.prototype=Object.assign(Object.create(rn.prototype),{constructor:g_,isLOD:!0,copy:function(n){rn.prototype.copy.call(this,n,!1);const e=n.levels;for(let t=0,r=e.length;t<r;t++){const s=e[t];this.addLevel(s.object.clone(),s.distance)}return this.autoUpdate=n.autoUpdate,this},addLevel:function(n,e=0){e=Math.abs(e);const t=this.levels;let r;for(r=0;r<t.length&&!(e<t[r].distance);r++);return t.splice(r,0,{distance:e,object:n}),this.add(n),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(n){const e=this.levels;if(e.length>0){let t,r;for(t=1,r=e.length;t<r&&!(n<e[t].distance);t++);return e[t-1].object}return null},raycast:function(n,e){if(this.levels.length>0){QT.setFromMatrixPosition(this.matrixWorld);const r=n.ray.origin.distanceTo(QT);this.getObjectForDistance(r).raycast(n,e)}},update:function(n){const e=this.levels;if(e.length>1){QT.setFromMatrixPosition(n.matrixWorld),E8.setFromMatrixPosition(this.matrixWorld);const t=QT.distanceTo(E8)/n.zoom;e[0].object.visible=!0;let r,s;for(r=1,s=e.length;r<s&&t>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<s;r++)e[r].object.visible=!1}},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const t=this.levels;for(let r=0,s=t.length;r<s;r++){const i=t[r];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}});const I8=new J,A8=new Hr,M8=new Hr,$yt=new J,N8=new Zn;function y_(n,e){n&&n.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),hs.call(this,n,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Zn,this.bindMatrixInverse=new Zn}y_.prototype=Object.assign(Object.create(hs.prototype),{constructor:y_,isSkinnedMesh:!0,copy:function(n){return hs.prototype.copy.call(this,n),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this},bind:function(n,e){this.skeleton=n,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const n=new Hr,e=this.geometry.attributes.skinWeight;for(let t=0,r=e.count;t<r;t++){n.x=e.getX(t),n.y=e.getY(t),n.z=e.getZ(t),n.w=e.getW(t);const s=1/n.manhattanLength();s!==1/0?n.multiplyScalar(s):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(n){hs.prototype.updateMatrixWorld.call(this,n),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(n,e){const t=this.skeleton,r=this.geometry;A8.fromBufferAttribute(r.attributes.skinIndex,n),M8.fromBufferAttribute(r.attributes.skinWeight,n),I8.fromBufferAttribute(r.attributes.position,n).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const i=M8.getComponent(s);if(i!==0){const o=A8.getComponent(s);N8.multiplyMatrices(t.bones[o].matrixWorld,t.boneInverses[o]),e.addScaledVector($yt.copy(I8).applyMatrix4(N8),i)}}return e.applyMatrix4(this.bindMatrixInverse)}});function b_(){rn.call(this),this.type="Bone"}b_.prototype=Object.assign(Object.create(rn.prototype),{constructor:b_,isBone:!0});const $8=new Zn,Ryt=new Zn;function v_(n=[],e=[]){this.uuid=kn.generateUUID(),this.bones=n.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(v_.prototype,{init:function(){const n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(n.length*16),e.length===0)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,r=this.bones.length;t<r;t++)this.boneInverses.push(new Zn)}},calculateInverses:function(){this.boneInverses.length=0;for(let n=0,e=this.bones.length;n<e;n++){const t=new Zn;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}},pose:function(){for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const n=this.bones,e=this.boneInverses,t=this.boneMatrices,r=this.boneTexture;for(let s=0,i=n.length;s<i;s++){const o=n[s]?n[s].matrixWorld:Ryt;$8.multiplyMatrices(o,e[s]),$8.toArray(t,s*16)}r!==null&&(r.needsUpdate=!0)},clone:function(){return new v_(this.bones,this.boneInverses)},getBoneByName:function(n){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];if(r.name===n)return r}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(n,e){this.uuid=n.uuid;for(let t=0,r=n.bones.length;t<r;t++){const s=n.bones[t];let i=e[s];i===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),i=new b_),this.bones.push(i),this.boneInverses.push(new Zn().fromArray(n.boneInverses[t]))}return this.init(),this},toJSON:function(){const n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let r=0,s=e.length;r<s;r++){const i=e[r];n.bones.push(i.uuid);const o=t[r];n.boneInverses.push(o.toArray())}return n}});const R8=new Zn,P8=new Zn,eE=[],o1=new hs;function kA(n,e,t){hs.call(this,n,e),this.instanceMatrix=new xn(new Float32Array(t*16),16),this.instanceColor=null,this.count=t,this.frustumCulled=!1}kA.prototype=Object.assign(Object.create(hs.prototype),{constructor:kA,isInstancedMesh:!0,copy:function(n){return hs.prototype.copy.call(this,n),this.instanceMatrix.copy(n.instanceMatrix),n.instanceColor!==null&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this},getColorAt:function(n,e){e.fromArray(this.instanceColor.array,n*3)},getMatrixAt:function(n,e){e.fromArray(this.instanceMatrix.array,n*16)},raycast:function(n,e){const t=this.matrixWorld,r=this.count;if(o1.geometry=this.geometry,o1.material=this.material,o1.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,R8),P8.multiplyMatrices(t,R8),o1.matrixWorld=P8,o1.raycast(n,eE);for(let i=0,o=eE.length;i<o;i++){const a=eE[i];a.instanceId=s,a.object=this,e.push(a)}eE.length=0}},setColorAt:function(n,e){this.instanceColor===null&&(this.instanceColor=new xn(new Float32Array(this.count*3),3)),e.toArray(this.instanceColor.array,n*3)},setMatrixAt:function(n,e){e.toArray(this.instanceMatrix.array,n*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});function Is(n){Sn.call(this),this.type="LineBasicMaterial",this.color=new jt(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(n)}Is.prototype=Object.create(Sn.prototype);Is.prototype.constructor=Is;Is.prototype.isLineBasicMaterial=!0;Is.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.morphTargets=n.morphTargets,this};const D8=new J,O8=new J,F8=new Zn,TP=new rx,tE=new Op;function $c(n=new cn,e=new Is){rn.call(this),this.type="Line",this.geometry=n,this.material=e,this.updateMorphTargets()}$c.prototype=Object.assign(Object.create(rn.prototype),{constructor:$c,isLine:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[0];for(let r=1,s=e.count;r<s;r++)D8.fromBufferAttribute(e,r-1),O8.fromBufferAttribute(e,r),t[r]=t[r-1],t[r]+=D8.distanceTo(O8);n.setAttribute("lineDistance",new Xt(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,s=n.params.Line.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),tE.copy(t.boundingSphere),tE.applyMatrix4(r),tE.radius+=s,n.ray.intersectsSphere(tE)===!1)return;F8.copy(r).invert(),TP.copy(n.ray).applyMatrix4(F8);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=i*i,a=new J,l=new J,c=new J,u=new J,h=this.isLineSegments?2:1;if(t.isBufferGeometry){const f=t.index,p=t.attributes.position;if(f!==null){const m=f.array;for(let g=0,y=m.length-1;g<y;g+=h){const b=m[g],x=m[g+1];if(a.fromBufferAttribute(p,b),l.fromBufferAttribute(p,x),TP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const _=n.ray.origin.distanceTo(u);_<n.near||_>n.far||e.push({distance:_,point:c.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this})}}else for(let m=0,g=p.count-1;m<g;m+=h){if(a.fromBufferAttribute(p,m),l.fromBufferAttribute(p,m+1),TP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const b=n.ray.origin.distanceTo(u);b<n.near||b>n.far||e.push({distance:b,point:c.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else t.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const L8=new J,z8=new J;function Ca(n,e){$c.call(this,n,e),this.type="LineSegments"}Ca.prototype=Object.assign(Object.create($c.prototype),{constructor:Ca,isLineSegments:!0,computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[];for(let r=0,s=e.count;r<s;r+=2)L8.fromBufferAttribute(e,r),z8.fromBufferAttribute(e,r+1),t[r]=r===0?0:t[r-1],t[r+1]=t[r]+L8.distanceTo(z8);n.setAttribute("lineDistance",new Xt(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});function TA(n,e){$c.call(this,n,e),this.type="LineLoop"}TA.prototype=Object.assign(Object.create($c.prototype),{constructor:TA,isLineLoop:!0});function Iu(n){Sn.call(this),this.type="PointsMaterial",this.color=new jt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(n)}Iu.prototype=Object.create(Sn.prototype);Iu.prototype.constructor=Iu;Iu.prototype.isPointsMaterial=!0;Iu.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.morphTargets=n.morphTargets,this};const B8=new Zn,FF=new rx,nE=new Op,rE=new J;function fv(n=new cn,e=new Iu){rn.call(this),this.type="Points",this.geometry=n,this.material=e,this.updateMorphTargets()}fv.prototype=Object.assign(Object.create(rn.prototype),{constructor:fv,isPoints:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,s=n.params.Points.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),nE.copy(t.boundingSphere),nE.applyMatrix4(r),nE.radius+=s,n.ray.intersectsSphere(nE)===!1)return;B8.copy(r).invert(),FF.copy(n.ray).applyMatrix4(B8);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=i*i;if(t.isBufferGeometry){const a=t.index,c=t.attributes.position;if(a!==null){const u=a.array;for(let h=0,f=u.length;h<f;h++){const d=u[h];rE.fromBufferAttribute(c,d),V8(rE,d,o,r,n,e,this)}}else for(let u=0,h=c.count;u<h;u++)rE.fromBufferAttribute(c,u),V8(rE,u,o,r,n,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function V8(n,e,t,r,s,i,o){const a=FF.distanceSqToPoint(n);if(a<t){const l=new J;FF.closestPointToPoint(n,l),l.applyMatrix4(r);const c=s.ray.origin.distanceTo(l);if(c<s.near||c>s.far)return;i.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}function LF(n,e,t,r,s,i,o,a,l){Kr.call(this,n,e,t,r,s,i,o,a,l),this.format=o!==void 0?o:jd,this.minFilter=i!==void 0?i:ao,this.magFilter=s!==void 0?s:ao,this.generateMipmaps=!1;const c=this;function u(){c.needsUpdate=!0,n.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(u)}LF.prototype=Object.assign(Object.create(Kr.prototype),{constructor:LF,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const n=this.image;"requestVideoFrameCallback"in n===!1&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function dv(n,e,t,r,s,i,o,a,l,c,u,h){Kr.call(this,null,i,o,a,l,c,r,s,u,h),this.image={width:e,height:t},this.mipmaps=n,this.flipY=!1,this.generateMipmaps=!1}dv.prototype=Object.create(Kr.prototype);dv.prototype.constructor=dv;dv.prototype.isCompressedTexture=!0;function w_(n,e,t,r,s,i,o,a,l){Kr.call(this,n,e,t,r,s,i,o,a,l),this.needsUpdate=!0}w_.prototype=Object.create(Kr.prototype);w_.prototype.constructor=w_;w_.prototype.isCanvasTexture=!0;function x_(n,e,t,r,s,i,o,a,l,c){if(c=c!==void 0?c:Zm,c!==Zm&&c!==lv)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&c===Zm&&(t=r_),t===void 0&&c===lv&&(t=Rb),Kr.call(this,null,r,s,i,o,a,c,t,l),this.image={width:n,height:e},this.magFilter=o!==void 0?o:Bi,this.minFilter=a!==void 0?a:Bi,this.flipY=!1,this.generateMipmaps=!1}x_.prototype=Object.create(Kr.prototype);x_.prototype.constructor=x_;x_.prototype.isDepthTexture=!0;class EA extends cn{constructor(e=1,t=8,r=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:s},t=Math.max(3,t);const i=[],o=[],a=[],l=[],c=new J,u=new rt;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,f=3;h<=t;h++,f+=3){const d=r+h/t*s;c.x=e*Math.cos(d),c.y=e*Math.sin(d),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[f]/e+1)/2,u.y=(o[f+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)i.push(h,h+1,0);this.setIndex(i),this.setAttribute("position",new Xt(o,3)),this.setAttribute("normal",new Xt(a,3)),this.setAttribute("uv",new Xt(l,2))}}class pv extends cn{constructor(e=1,t=1,r=1,s=8,i=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:s,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l};const c=this;s=Math.floor(s),i=Math.floor(i);const u=[],h=[],f=[],d=[];let p=0;const m=[],g=r/2;let y=0;b(),o===!1&&(e>0&&x(!0),t>0&&x(!1)),this.setIndex(u),this.setAttribute("position",new Xt(h,3)),this.setAttribute("normal",new Xt(f,3)),this.setAttribute("uv",new Xt(d,2));function b(){const w=new J,_=new J;let C=0;const k=(t-e)/r;for(let A=0;A<=i;A++){const M=[],I=A/i,N=I*(t-e)+e;for(let O=0;O<=s;O++){const R=O/s,D=R*l+a,z=Math.sin(D),B=Math.cos(D);_.x=N*z,_.y=-I*r+g,_.z=N*B,h.push(_.x,_.y,_.z),w.set(z,k,B).normalize(),f.push(w.x,w.y,w.z),d.push(R,1-I),M.push(p++)}m.push(M)}for(let A=0;A<s;A++)for(let M=0;M<i;M++){const I=m[M][A],N=m[M+1][A],O=m[M+1][A+1],R=m[M][A+1];u.push(I,N,R),u.push(N,O,R),C+=6}c.addGroup(y,C,0),y+=C}function x(w){const _=p,C=new rt,k=new J;let A=0;const M=w===!0?e:t,I=w===!0?1:-1;for(let O=1;O<=s;O++)h.push(0,g*I,0),f.push(0,I,0),d.push(.5,.5),p++;const N=p;for(let O=0;O<=s;O++){const D=O/s*l+a,z=Math.cos(D),B=Math.sin(D);k.x=M*B,k.y=g*I,k.z=M*z,h.push(k.x,k.y,k.z),f.push(0,I,0),C.x=z*.5+.5,C.y=B*.5*I+.5,d.push(C.x,C.y),p++}for(let O=0;O<s;O++){const R=_+O,D=N+O;w===!0?u.push(D,D+1,R):u.push(D+1,D,R),A+=3}c.addGroup(y,A,w===!0?1:2),y+=A}}}class IA extends pv{constructor(e=1,t=1,r=8,s=1,i=!1,o=0,a=Math.PI*2){super(0,e,t,r,s,i,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:s,openEnded:i,thetaStart:o,thetaLength:a}}}class gp extends cn{constructor(e,t,r=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:s};const i=[],o=[];a(s),c(r),u(),this.setAttribute("position",new Xt(i,3)),this.setAttribute("normal",new Xt(i.slice(),3)),this.setAttribute("uv",new Xt(o,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function a(b){const x=new J,w=new J,_=new J;for(let C=0;C<t.length;C+=3)d(t[C+0],x),d(t[C+1],w),d(t[C+2],_),l(x,w,_,b)}function l(b,x,w,_){const C=_+1,k=[];for(let A=0;A<=C;A++){k[A]=[];const M=b.clone().lerp(w,A/C),I=x.clone().lerp(w,A/C),N=C-A;for(let O=0;O<=N;O++)O===0&&A===C?k[A][O]=M:k[A][O]=M.clone().lerp(I,O/N)}for(let A=0;A<C;A++)for(let M=0;M<2*(C-A)-1;M++){const I=Math.floor(M/2);M%2===0?(f(k[A][I+1]),f(k[A+1][I]),f(k[A][I])):(f(k[A][I+1]),f(k[A+1][I+1]),f(k[A+1][I]))}}function c(b){const x=new J;for(let w=0;w<i.length;w+=3)x.x=i[w+0],x.y=i[w+1],x.z=i[w+2],x.normalize().multiplyScalar(b),i[w+0]=x.x,i[w+1]=x.y,i[w+2]=x.z}function u(){const b=new J;for(let x=0;x<i.length;x+=3){b.x=i[x+0],b.y=i[x+1],b.z=i[x+2];const w=g(b)/2/Math.PI+.5,_=y(b)/Math.PI+.5;o.push(w,1-_)}p(),h()}function h(){for(let b=0;b<o.length;b+=6){const x=o[b+0],w=o[b+2],_=o[b+4],C=Math.max(x,w,_),k=Math.min(x,w,_);C>.9&&k<.1&&(x<.2&&(o[b+0]+=1),w<.2&&(o[b+2]+=1),_<.2&&(o[b+4]+=1))}}function f(b){i.push(b.x,b.y,b.z)}function d(b,x){const w=b*3;x.x=e[w+0],x.y=e[w+1],x.z=e[w+2]}function p(){const b=new J,x=new J,w=new J,_=new J,C=new rt,k=new rt,A=new rt;for(let M=0,I=0;M<i.length;M+=9,I+=6){b.set(i[M+0],i[M+1],i[M+2]),x.set(i[M+3],i[M+4],i[M+5]),w.set(i[M+6],i[M+7],i[M+8]),C.set(o[I+0],o[I+1]),k.set(o[I+2],o[I+3]),A.set(o[I+4],o[I+5]),_.copy(b).add(x).add(w).divideScalar(3);const N=g(_);m(C,I+0,b,N),m(k,I+2,x,N),m(A,I+4,w,N)}}function m(b,x,w,_){_<0&&b.x===1&&(o[x]=b.x-1),w.x===0&&w.z===0&&(o[x]=_/2/Math.PI+.5)}function g(b){return Math.atan2(b.z,-b.x)}function y(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}}}class AA extends gp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=1/r,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-r,0,-s,r,0,s,-r,0,s,r,-s,-r,0,-s,r,0,s,-r,0,s,r,0,-r,0,-s,r,0,-s,-r,0,s,r,0,s],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const sE=new J,iE=new J,EP=new J,oE=new Go;class lV extends cn{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0){console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const s=Math.pow(10,4),i=Math.cos(kn.DEG2RAD*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),f={},d=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:g,c:y}=oE;if(m.fromBufferAttribute(a,c[0]),g.fromBufferAttribute(a,c[1]),y.fromBufferAttribute(a,c[2]),oE.getNormal(EP),h[0]=`${Math.round(m.x*s)},${Math.round(m.y*s)},${Math.round(m.z*s)}`,h[1]=`${Math.round(g.x*s)},${Math.round(g.y*s)},${Math.round(g.z*s)}`,h[2]=`${Math.round(y.x*s)},${Math.round(y.y*s)},${Math.round(y.z*s)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let b=0;b<3;b++){const x=(b+1)%3,w=h[b],_=h[x],C=oE[u[b]],k=oE[u[x]],A=`${w}_${_}`,M=`${_}_${w}`;M in f&&f[M]?(EP.dot(f[M].normal)<=i&&(d.push(C.x,C.y,C.z),d.push(k.x,k.y,k.z)),f[M]=null):A in f||(f[A]={index0:c[b],index1:c[x],normal:EP.clone()})}}for(const p in f)if(f[p]){const{index0:m,index1:g}=f[p];sE.fromBufferAttribute(a,m),iE.fromBufferAttribute(a,g),d.push(sE.x,sE.y,sE.z),d.push(iE.x,iE.y,iE.z)}this.setAttribute("position",new Xt(d,3))}}const Pyt={triangulate:function(n,e,t){t=t||2;const r=e&&e.length,s=r?e[0]*t:n.length;let i=cle(n,0,s,t,!0);const o=[];if(!i||i.next===i.prev)return o;let a,l,c,u,h,f,d;if(r&&(i=zyt(n,e,i,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let p=t;p<s;p+=t)h=n[p],f=n[p+1],h<a&&(a=h),f<l&&(l=f),h>c&&(c=h),f>u&&(u=f);d=Math.max(c-a,u-l),d=d!==0?1/d:0}return S_(i,o,t,a,l,d),o}};function cle(n,e,t,r,s){let i,o;if(s===Yyt(n,e,t,r)>0)for(i=e;i<t;i+=r)o=U8(i,n[i],n[i+1],o);else for(i=t-r;i>=e;i-=r)o=U8(i,n[i],n[i+1],o);return o&&$$(o,o.next)&&(C_(o),o=o.next),o}function yp(n,e){if(!n)return n;e||(e=n);let t=n,r;do if(r=!1,!t.steiner&&($$(t,t.next)||Fs(t.prev,t,t.next)===0)){if(C_(t),t=e=t.prev,t===t.next)break;r=!0}else t=t.next;while(r||t!==e);return e}function S_(n,e,t,r,s,i,o){if(!n)return;!o&&i&&Gyt(n,r,s,i);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,i?Oyt(n,r,s,i):Dyt(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),C_(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=Fyt(yp(n),e,t),S_(n,e,t,r,s,i,2)):o===2&&Lyt(n,e,t,r,s,i):S_(yp(n),e,t,r,s,i,1);break}}}function Dyt(n){const e=n.prev,t=n,r=n.next;if(Fs(e,t,r)>=0)return!1;let s=n.next.next;for(;s!==n.prev;){if(xb(e.x,e.y,t.x,t.y,r.x,r.y,s.x,s.y)&&Fs(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function Oyt(n,e,t,r){const s=n.prev,i=n,o=n.next;if(Fs(s,i,o)>=0)return!1;const a=s.x<i.x?s.x<o.x?s.x:o.x:i.x<o.x?i.x:o.x,l=s.y<i.y?s.y<o.y?s.y:o.y:i.y<o.y?i.y:o.y,c=s.x>i.x?s.x>o.x?s.x:o.x:i.x>o.x?i.x:o.x,u=s.y>i.y?s.y>o.y?s.y:o.y:i.y>o.y?i.y:o.y,h=zF(a,l,e,t,r),f=zF(c,u,e,t,r);let d=n.prevZ,p=n.nextZ;for(;d&&d.z>=h&&p&&p.z<=f;){if(d!==n.prev&&d!==n.next&&xb(s.x,s.y,i.x,i.y,o.x,o.y,d.x,d.y)&&Fs(d.prev,d,d.next)>=0||(d=d.prevZ,p!==n.prev&&p!==n.next&&xb(s.x,s.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Fs(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;d&&d.z>=h;){if(d!==n.prev&&d!==n.next&&xb(s.x,s.y,i.x,i.y,o.x,o.y,d.x,d.y)&&Fs(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;p&&p.z<=f;){if(p!==n.prev&&p!==n.next&&xb(s.x,s.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Fs(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function Fyt(n,e,t){let r=n;do{const s=r.prev,i=r.next.next;!$$(s,i)&&ule(s,r,r.next,i)&&__(s,i)&&__(i,s)&&(e.push(s.i/t),e.push(r.i/t),e.push(i.i/t),C_(r),C_(r.next),r=n=i),r=r.next}while(r!==n);return yp(r)}function Lyt(n,e,t,r,s,i){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&qyt(o,a)){let l=hle(o,a);o=yp(o,o.next),l=yp(l,l.next),S_(o,e,t,r,s,i),S_(l,e,t,r,s,i);return}a=a.next}o=o.next}while(o!==n)}function zyt(n,e,t,r){const s=[];let i,o,a,l,c;for(i=0,o=e.length;i<o;i++)a=e[i]*r,l=i<o-1?e[i+1]*r:n.length,c=cle(n,a,l,r,!1),c===c.next&&(c.steiner=!0),s.push(jyt(c));for(s.sort(Byt),i=0;i<s.length;i++)Vyt(s[i],t),t=yp(t,t.next);return t}function Byt(n,e){return n.x-e.x}function Vyt(n,e){if(e=Uyt(n,e),e){const t=hle(e,n);yp(e,e.next),yp(t,t.next)}}function Uyt(n,e){let t=e;const r=n.x,s=n.y;let i=-1/0,o;do{if(s<=t.y&&s>=t.next.y&&t.next.y!==t.y){const f=t.x+(s-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=r&&f>i){if(i=f,f===r){if(s===t.y)return t;if(s===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(r===i)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do r>=t.x&&t.x>=l&&r!==t.x&&xb(s<c?r:i,s,l,c,s<c?i:r,s,t.x,t.y)&&(h=Math.abs(s-t.y)/(r-t.x),__(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&Wyt(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function Wyt(n,e){return Fs(n.prev,n,e.prev)<0&&Fs(e.next,n,n.next)<0}function Gyt(n,e,t,r){let s=n;do s.z===null&&(s.z=zF(s.x,s.y,e,t,r)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,Hyt(s)}function Hyt(n){let e,t,r,s,i,o,a,l,c=1;do{for(t=n,n=null,i=null,o=0;t;){for(o++,r=t,a=0,e=0;e<c&&(a++,r=r.nextZ,!!r);e++);for(l=c;a>0||l>0&&r;)a!==0&&(l===0||!r||t.z<=r.z)?(s=t,t=t.nextZ,a--):(s=r,r=r.nextZ,l--),i?i.nextZ=s:n=s,s.prevZ=i,i=s;t=r}i.nextZ=null,c*=2}while(o>1);return n}function zF(n,e,t,r,s){return n=32767*(n-t)*s,e=32767*(e-r)*s,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function jyt(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function xb(n,e,t,r,s,i,o,a){return(s-o)*(e-a)-(n-o)*(i-a)>=0&&(n-o)*(r-a)-(t-o)*(e-a)>=0&&(t-o)*(i-a)-(s-o)*(r-a)>=0}function qyt(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!Xyt(n,e)&&(__(n,e)&&__(e,n)&&Kyt(n,e)&&(Fs(n.prev,n,e.prev)||Fs(n,e.prev,e))||$$(n,e)&&Fs(n.prev,n,n.next)>0&&Fs(e.prev,e,e.next)>0)}function Fs(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function $$(n,e){return n.x===e.x&&n.y===e.y}function ule(n,e,t,r){const s=lE(Fs(n,e,t)),i=lE(Fs(n,e,r)),o=lE(Fs(t,r,n)),a=lE(Fs(t,r,e));return!!(s!==i&&o!==a||s===0&&aE(n,t,e)||i===0&&aE(n,r,e)||o===0&&aE(t,n,r)||a===0&&aE(t,e,r))}function aE(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function lE(n){return n>0?1:n<0?-1:0}function Xyt(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&ule(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function __(n,e){return Fs(n.prev,n,n.next)<0?Fs(n,e,n.next)>=0&&Fs(n,n.prev,e)>=0:Fs(n,e,n.prev)<0||Fs(n,n.next,e)<0}function Kyt(n,e){let t=n,r=!1;const s=(n.x+e.x)/2,i=(n.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&s<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==n);return r}function hle(n,e){const t=new BF(n.i,n.x,n.y),r=new BF(e.i,e.x,e.y),s=n.next,i=e.prev;return n.next=e,e.prev=n,t.next=s,s.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function U8(n,e,t,r){const s=new BF(n,e,t);return r?(s.next=r.next,s.prev=r,r.next.prev=s,r.next=s):(s.prev=s,s.next=s),s}function C_(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function BF(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Yyt(n,e,t,r){let s=0;for(let i=e,o=t-r;i<t;i+=r)s+=(n[o]-n[i])*(n[i+1]+n[o+1]),o=i;return s}const $f={area:function(n){const e=n.length;let t=0;for(let r=e-1,s=0;s<e;r=s++)t+=n[r].x*n[s].y-n[s].x*n[r].y;return t*.5},isClockWise:function(n){return $f.area(n)<0},triangulateShape:function(n,e){const t=[],r=[],s=[];W8(n),G8(t,n);let i=n.length;e.forEach(W8);for(let a=0;a<e.length;a++)r.push(i),i+=e[a].length,G8(t,e[a]);const o=Pyt.triangulate(t,r);for(let a=0;a<o.length;a+=3)s.push(o.slice(a,a+3));return s}};function W8(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function G8(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class Sg extends cn{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const r=this,s=[],i=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new Xt(s,3)),this.setAttribute("uv",new Xt(i,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:100,f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,d=t.bevelThickness!==void 0?t.bevelThickness:6,p=t.bevelSize!==void 0?t.bevelSize:d-2,m=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const y=t.extrudePath,b=t.UVGenerator!==void 0?t.UVGenerator:Zyt;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let x,w=!1,_,C,k,A;y&&(x=y.getSpacedPoints(u),w=!0,f=!1,_=y.computeFrenetFrames(u,!1),C=new J,k=new J,A=new J),f||(g=0,d=0,p=0,m=0);const M=a.extractPoints(c);let I=M.shape;const N=M.holes;if(!$f.isClockWise(I)){I=I.reverse();for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];$f.isClockWise(Be)&&(N[Ve]=Be.reverse())}}const R=$f.triangulateShape(I,N),D=I;for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];I=I.concat(Be)}function z(Ve,ze,Be){return ze||console.error("THREE.ExtrudeGeometry: vec does not exist"),ze.clone().multiplyScalar(Be).add(Ve)}const B=I.length,X=R.length;function G(Ve,ze,Be){let ht,Ke,Q;const Z=Ve.x-ze.x,nt=Ve.y-ze.y,He=Be.x-Ve.x,me=Be.y-Ve.y,Ye=Z*Z+nt*nt,bt=Z*me-nt*He;if(Math.abs(bt)>Number.EPSILON){const kt=Math.sqrt(Ye),dt=Math.sqrt(He*He+me*me),le=ze.x-nt/kt,tt=ze.y+Z/kt,Ct=Be.x-me/dt,yt=Be.y+He/dt,Ht=((Ct-le)*me-(yt-tt)*He)/(Z*me-nt*He);ht=le+Z*Ht-Ve.x,Ke=tt+nt*Ht-Ve.y;const En=ht*ht+Ke*Ke;if(En<=2)return new rt(ht,Ke);Q=Math.sqrt(En/2)}else{let kt=!1;Z>Number.EPSILON?He>Number.EPSILON&&(kt=!0):Z<-Number.EPSILON?He<-Number.EPSILON&&(kt=!0):Math.sign(nt)===Math.sign(me)&&(kt=!0),kt?(ht=-nt,Ke=Z,Q=Math.sqrt(Ye)):(ht=Z,Ke=nt,Q=Math.sqrt(Ye/2))}return new rt(ht/Q,Ke/Q)}const ee=[];for(let Ve=0,ze=D.length,Be=ze-1,ht=Ve+1;Ve<ze;Ve++,Be++,ht++)Be===ze&&(Be=0),ht===ze&&(ht=0),ee[Ve]=G(D[Ve],D[Be],D[ht]);const pe=[];let oe,Ne=ee.concat();for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];oe=[];for(let ht=0,Ke=Be.length,Q=Ke-1,Z=ht+1;ht<Ke;ht++,Q++,Z++)Q===Ke&&(Q=0),Z===Ke&&(Z=0),oe[ht]=G(Be[ht],Be[Q],Be[Z]);pe.push(oe),Ne=Ne.concat(oe)}for(let Ve=0;Ve<g;Ve++){const ze=Ve/g,Be=d*Math.cos(ze*Math.PI/2),ht=p*Math.sin(ze*Math.PI/2)+m;for(let Ke=0,Q=D.length;Ke<Q;Ke++){const Z=z(D[Ke],ee[Ke],ht);Oe(Z.x,Z.y,-Be)}for(let Ke=0,Q=N.length;Ke<Q;Ke++){const Z=N[Ke];oe=pe[Ke];for(let nt=0,He=Z.length;nt<He;nt++){const me=z(Z[nt],oe[nt],ht);Oe(me.x,me.y,-Be)}}}const ke=p+m;for(let Ve=0;Ve<B;Ve++){const ze=f?z(I[Ve],Ne[Ve],ke):I[Ve];w?(k.copy(_.normals[0]).multiplyScalar(ze.x),C.copy(_.binormals[0]).multiplyScalar(ze.y),A.copy(x[0]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(ze.x,ze.y,0)}for(let Ve=1;Ve<=u;Ve++)for(let ze=0;ze<B;ze++){const Be=f?z(I[ze],Ne[ze],ke):I[ze];w?(k.copy(_.normals[Ve]).multiplyScalar(Be.x),C.copy(_.binormals[Ve]).multiplyScalar(Be.y),A.copy(x[Ve]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(Be.x,Be.y,h/u*Ve)}for(let Ve=g-1;Ve>=0;Ve--){const ze=Ve/g,Be=d*Math.cos(ze*Math.PI/2),ht=p*Math.sin(ze*Math.PI/2)+m;for(let Ke=0,Q=D.length;Ke<Q;Ke++){const Z=z(D[Ke],ee[Ke],ht);Oe(Z.x,Z.y,h+Be)}for(let Ke=0,Q=N.length;Ke<Q;Ke++){const Z=N[Ke];oe=pe[Ke];for(let nt=0,He=Z.length;nt<He;nt++){const me=z(Z[nt],oe[nt],ht);w?Oe(me.x,me.y+x[u-1].y,x[u-1].x+Be):Oe(me.x,me.y,h+Be)}}}De(),ge();function De(){const Ve=s.length/3;if(f){let ze=0,Be=B*ze;for(let ht=0;ht<X;ht++){const Ke=R[ht];it(Ke[2]+Be,Ke[1]+Be,Ke[0]+Be)}ze=u+g*2,Be=B*ze;for(let ht=0;ht<X;ht++){const Ke=R[ht];it(Ke[0]+Be,Ke[1]+Be,Ke[2]+Be)}}else{for(let ze=0;ze<X;ze++){const Be=R[ze];it(Be[2],Be[1],Be[0])}for(let ze=0;ze<X;ze++){const Be=R[ze];it(Be[0]+B*u,Be[1]+B*u,Be[2]+B*u)}}r.addGroup(Ve,s.length/3-Ve,0)}function ge(){const Ve=s.length/3;let ze=0;Xe(D,ze),ze+=D.length;for(let Be=0,ht=N.length;Be<ht;Be++){const Ke=N[Be];Xe(Ke,ze),ze+=Ke.length}r.addGroup(Ve,s.length/3-Ve,1)}function Xe(Ve,ze){let Be=Ve.length;for(;--Be>=0;){const ht=Be;let Ke=Be-1;Ke<0&&(Ke=Ve.length-1);for(let Q=0,Z=u+g*2;Q<Z;Q++){const nt=B*Q,He=B*(Q+1),me=ze+ht+nt,Ye=ze+Ke+nt,bt=ze+Ke+He,kt=ze+ht+He;Ge(me,Ye,bt,kt)}}}function Oe(Ve,ze,Be){l.push(Ve),l.push(ze),l.push(Be)}function it(Ve,ze,Be){pt(Ve),pt(ze),pt(Be);const ht=s.length/3,Ke=b.generateTopUV(r,s,ht-3,ht-2,ht-1);ut(Ke[0]),ut(Ke[1]),ut(Ke[2])}function Ge(Ve,ze,Be,ht){pt(Ve),pt(ze),pt(ht),pt(ze),pt(Be),pt(ht);const Ke=s.length/3,Q=b.generateSideWallUV(r,s,Ke-6,Ke-3,Ke-2,Ke-1);ut(Q[0]),ut(Q[1]),ut(Q[3]),ut(Q[1]),ut(Q[2]),ut(Q[3])}function pt(Ve){s.push(l[Ve*3+0]),s.push(l[Ve*3+1]),s.push(l[Ve*3+2])}function ut(Ve){i.push(Ve.x),i.push(Ve.y)}}}toJSON(){const e=cn.prototype.toJSON.call(this),t=this.parameters.shapes,r=this.parameters.options;return Jyt(t,r,e)}}const Zyt={generateTopUV:function(n,e,t,r,s){const i=e[t*3],o=e[t*3+1],a=e[r*3],l=e[r*3+1],c=e[s*3],u=e[s*3+1];return[new rt(i,o),new rt(a,l),new rt(c,u)]},generateSideWallUV:function(n,e,t,r,s,i){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[r*3],u=e[r*3+1],h=e[r*3+2],f=e[s*3],d=e[s*3+1],p=e[s*3+2],m=e[i*3],g=e[i*3+1],y=e[i*3+2];return Math.abs(a-u)<.01?[new rt(o,1-l),new rt(c,1-h),new rt(f,1-p),new rt(m,1-y)]:[new rt(a,1-l),new rt(u,1-h),new rt(d,1-p),new rt(g,1-y)]}};function Jyt(n,e,t){if(t.shapes=[],Array.isArray(n))for(let r=0,s=n.length;r<s;r++){const i=n[r];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class MA extends gp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,i,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class NA extends cn{constructor(e,t=12,r=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:s},t=Math.floor(t),s=kn.clamp(s,0,Math.PI*2);const i=[],o=[],a=[],l=1/t,c=new J,u=new rt;for(let h=0;h<=t;h++){const f=r+h*l*s,d=Math.sin(f),p=Math.cos(f);for(let m=0;m<=e.length-1;m++)c.x=e[m].x*d,c.y=e[m].y,c.z=e[m].x*p,o.push(c.x,c.y,c.z),u.x=h/t,u.y=m/(e.length-1),a.push(u.x,u.y)}for(let h=0;h<t;h++)for(let f=0;f<e.length-1;f++){const d=f+h*e.length,p=d,m=d+e.length,g=d+e.length+1,y=d+1;i.push(p,m,y),i.push(m,g,y)}if(this.setIndex(i),this.setAttribute("position",new Xt(o,3)),this.setAttribute("uv",new Xt(a,2)),this.computeVertexNormals(),s===Math.PI*2){const h=this.attributes.normal.array,f=new J,d=new J,p=new J,m=t*e.length*3;for(let g=0,y=0;g<e.length;g++,y+=3)f.x=h[y+0],f.y=h[y+1],f.z=h[y+2],d.x=h[m+y+0],d.y=h[m+y+1],d.z=h[m+y+2],p.addVectors(f,d).normalize(),h[y+0]=h[m+y+0]=p.x,h[y+1]=h[m+y+1]=p.y,h[y+2]=h[m+y+2]=p.z}}}class k_ extends gp{constructor(e=1,t=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,s,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}function _g(n,e,t){cn.call(this),this.type="ParametricGeometry",this.parameters={func:n,slices:e,stacks:t};const r=[],s=[],i=[],o=[],a=1e-5,l=new J,c=new J,u=new J,h=new J,f=new J;n.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const d=e+1;for(let p=0;p<=t;p++){const m=p/t;for(let g=0;g<=e;g++){const y=g/e;n(y,m,c),s.push(c.x,c.y,c.z),y-a>=0?(n(y-a,m,u),h.subVectors(c,u)):(n(y+a,m,u),h.subVectors(u,c)),m-a>=0?(n(y,m-a,u),f.subVectors(c,u)):(n(y,m+a,u),f.subVectors(u,c)),l.crossVectors(h,f).normalize(),i.push(l.x,l.y,l.z),o.push(y,m)}}for(let p=0;p<t;p++)for(let m=0;m<e;m++){const g=p*d+m,y=p*d+m+1,b=(p+1)*d+m+1,x=(p+1)*d+m;r.push(g,y,x),r.push(y,b,x)}this.setIndex(r),this.setAttribute("position",new Xt(s,3)),this.setAttribute("normal",new Xt(i,3)),this.setAttribute("uv",new Xt(o,2))}_g.prototype=Object.create(cn.prototype);_g.prototype.constructor=_g;class $A extends cn{constructor(e=.5,t=1,r=8,s=1,i=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:s,thetaStart:i,thetaLength:o},r=Math.max(3,r),s=Math.max(1,s);const a=[],l=[],c=[],u=[];let h=e;const f=(t-e)/s,d=new J,p=new rt;for(let m=0;m<=s;m++){for(let g=0;g<=r;g++){const y=i+g/r*o;d.x=h*Math.cos(y),d.y=h*Math.sin(y),l.push(d.x,d.y,d.z),c.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,u.push(p.x,p.y)}h+=f}for(let m=0;m<s;m++){const g=m*(r+1);for(let y=0;y<r;y++){const b=y+g,x=b,w=b+r+1,_=b+r+2,C=b+1;a.push(x,w,C),a.push(w,_,C)}}this.setIndex(a),this.setAttribute("position",new Xt(l,3)),this.setAttribute("normal",new Xt(c,3)),this.setAttribute("uv",new Xt(u,2))}}class T_ extends cn{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],s=[],i=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(r),this.setAttribute("position",new Xt(s,3)),this.setAttribute("normal",new Xt(i,3)),this.setAttribute("uv",new Xt(o,2));function c(u){const h=s.length/3,f=u.extractPoints(t);let d=f.shape;const p=f.holes;$f.isClockWise(d)===!1&&(d=d.reverse());for(let g=0,y=p.length;g<y;g++){const b=p[g];$f.isClockWise(b)===!0&&(p[g]=b.reverse())}const m=$f.triangulateShape(d,p);for(let g=0,y=p.length;g<y;g++){const b=p[g];d=d.concat(b)}for(let g=0,y=d.length;g<y;g++){const b=d[g];s.push(b.x,b.y,0),i.push(0,0,1),o.push(b.x,b.y)}for(let g=0,y=m.length;g<y;g++){const b=m[g],x=b[0]+h,w=b[1]+h,_=b[2]+h;r.push(x,w,_),l+=3}}}toJSON(){const e=cn.prototype.toJSON.call(this),t=this.parameters.shapes;return Qyt(t,e)}}function Qyt(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const s=n[t];e.shapes.push(s.uuid)}else e.shapes.push(n.uuid);return e}class E_ extends cn{constructor(e=1,t=8,r=6,s=0,i=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:s,phiLength:i,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),r=Math.max(2,Math.floor(r));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new J,f=new J,d=[],p=[],m=[],g=[];for(let y=0;y<=r;y++){const b=[],x=y/r;let w=0;y==0&&o==0?w=.5/t:y==r&&l==Math.PI&&(w=-.5/t);for(let _=0;_<=t;_++){const C=_/t;h.x=-e*Math.cos(s+C*i)*Math.sin(o+x*a),h.y=e*Math.cos(o+x*a),h.z=e*Math.sin(s+C*i)*Math.sin(o+x*a),p.push(h.x,h.y,h.z),f.copy(h).normalize(),m.push(f.x,f.y,f.z),g.push(C+w,1-x),b.push(c++)}u.push(b)}for(let y=0;y<r;y++)for(let b=0;b<t;b++){const x=u[y][b+1],w=u[y][b],_=u[y+1][b],C=u[y+1][b+1];(y!==0||o>0)&&d.push(x,w,C),(y!==r-1||l<Math.PI)&&d.push(w,_,C)}this.setIndex(d),this.setAttribute("position",new Xt(p,3)),this.setAttribute("normal",new Xt(m,3)),this.setAttribute("uv",new Xt(g,2))}}class RA extends gp{constructor(e=1,t=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],s=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,s,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class PA extends Sg{constructor(e,t={}){const r=t.font;if(!(r&&r.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new cn;const s=r.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(s,t),this.type="TextGeometry"}}class DA extends cn{constructor(e=1,t=.4,r=8,s=6,i=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:s,arc:i},r=Math.floor(r),s=Math.floor(s);const o=[],a=[],l=[],c=[],u=new J,h=new J,f=new J;for(let d=0;d<=r;d++)for(let p=0;p<=s;p++){const m=p/s*i,g=d/r*Math.PI*2;h.x=(e+t*Math.cos(g))*Math.cos(m),h.y=(e+t*Math.cos(g))*Math.sin(m),h.z=t*Math.sin(g),a.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),f.subVectors(h,u).normalize(),l.push(f.x,f.y,f.z),c.push(p/s),c.push(d/r)}for(let d=1;d<=r;d++)for(let p=1;p<=s;p++){const m=(s+1)*d+p-1,g=(s+1)*(d-1)+p-1,y=(s+1)*(d-1)+p,b=(s+1)*d+p;o.push(m,g,b),o.push(g,y,b)}this.setIndex(o),this.setAttribute("position",new Xt(a,3)),this.setAttribute("normal",new Xt(l,3)),this.setAttribute("uv",new Xt(c,2))}}class OA extends cn{constructor(e=1,t=.4,r=64,s=8,i=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:s,p:i,q:o},r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],u=[],h=new J,f=new J,d=new J,p=new J,m=new J,g=new J,y=new J;for(let x=0;x<=r;++x){const w=x/r*i*Math.PI*2;b(w,i,o,e,d),b(w+.01,i,o,e,p),g.subVectors(p,d),y.addVectors(p,d),m.crossVectors(g,y),y.crossVectors(m,g),m.normalize(),y.normalize();for(let _=0;_<=s;++_){const C=_/s*Math.PI*2,k=-t*Math.cos(C),A=t*Math.sin(C);h.x=d.x+(k*y.x+A*m.x),h.y=d.y+(k*y.y+A*m.y),h.z=d.z+(k*y.z+A*m.z),l.push(h.x,h.y,h.z),f.subVectors(h,d).normalize(),c.push(f.x,f.y,f.z),u.push(x/r),u.push(_/s)}}for(let x=1;x<=r;x++)for(let w=1;w<=s;w++){const _=(s+1)*(x-1)+(w-1),C=(s+1)*x+(w-1),k=(s+1)*x+w,A=(s+1)*(x-1)+w;a.push(_,C,A),a.push(C,k,A)}this.setIndex(a),this.setAttribute("position",new Xt(l,3)),this.setAttribute("normal",new Xt(c,3)),this.setAttribute("uv",new Xt(u,2));function b(x,w,_,C,k){const A=Math.cos(x),M=Math.sin(x),I=_/w*x,N=Math.cos(I);k.x=C*(2+N)*.5*A,k.y=C*(2+N)*M*.5,k.z=C*Math.sin(I)*.5}}}class FA extends cn{constructor(e,t=64,r=1,s=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:s,closed:i};const o=e.computeFrenetFrames(t,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new J,l=new J,c=new rt;let u=new J;const h=[],f=[],d=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new Xt(h,3)),this.setAttribute("normal",new Xt(f,3)),this.setAttribute("uv",new Xt(d,2));function m(){for(let x=0;x<t;x++)g(x);g(i===!1?t:0),b(),y()}function g(x){u=e.getPointAt(x/t,u);const w=o.normals[x],_=o.binormals[x];for(let C=0;C<=s;C++){const k=C/s*Math.PI*2,A=Math.sin(k),M=-Math.cos(k);l.x=M*w.x+A*_.x,l.y=M*w.y+A*_.y,l.z=M*w.z+A*_.z,l.normalize(),f.push(l.x,l.y,l.z),a.x=u.x+r*l.x,a.y=u.y+r*l.y,a.z=u.z+r*l.z,h.push(a.x,a.y,a.z)}}function y(){for(let x=1;x<=t;x++)for(let w=1;w<=s;w++){const _=(s+1)*(x-1)+(w-1),C=(s+1)*x+(w-1),k=(s+1)*x+w,A=(s+1)*(x-1)+w;p.push(_,C,A),p.push(C,k,A)}}function b(){for(let x=0;x<=t;x++)for(let w=0;w<=s;w++)c.x=x/t,c.y=w/s,d.push(c.x,c.y)}}toJSON(){const e=cn.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class cV extends cn{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const t=[],r=[0,0],s={},i=new J;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],f=h.start,d=h.count;for(let p=f,m=f+d;p<m;p+=3)for(let g=0;g<3;g++){const y=a.getX(p+g),b=a.getX(p+(g+1)%3);r[0]=Math.min(y,b),r[1]=Math.max(y,b);const x=r[0]+","+r[1];s[x]===void 0&&(s[x]={index1:r[0],index2:r[1]})}}for(const c in s){const u=s[c];i.fromBufferAttribute(o,u.index1),t.push(i.x,i.y,i.z),i.fromBufferAttribute(o,u.index2),t.push(i.x,i.y,i.z)}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c;i.fromBufferAttribute(o,u),t.push(i.x,i.y,i.z);const h=3*a+(c+1)%3;i.fromBufferAttribute(o,h),t.push(i.x,i.y,i.z)}}this.setAttribute("position",new Xt(t,3))}}var oa=Object.freeze({__proto__:null,BoxGeometry:wg,BoxBufferGeometry:wg,CircleGeometry:EA,CircleBufferGeometry:EA,ConeGeometry:IA,ConeBufferGeometry:IA,CylinderGeometry:pv,CylinderBufferGeometry:pv,DodecahedronGeometry:AA,DodecahedronBufferGeometry:AA,EdgesGeometry:lV,ExtrudeGeometry:Sg,ExtrudeBufferGeometry:Sg,IcosahedronGeometry:MA,IcosahedronBufferGeometry:MA,LatheGeometry:NA,LatheBufferGeometry:NA,OctahedronGeometry:k_,OctahedronBufferGeometry:k_,ParametricGeometry:_g,ParametricBufferGeometry:_g,PlaneGeometry:p_,PlaneBufferGeometry:p_,PolyhedronGeometry:gp,PolyhedronBufferGeometry:gp,RingGeometry:$A,RingBufferGeometry:$A,ShapeGeometry:T_,ShapeBufferGeometry:T_,SphereGeometry:E_,SphereBufferGeometry:E_,TetrahedronGeometry:RA,TetrahedronBufferGeometry:RA,TextGeometry:PA,TextBufferGeometry:PA,TorusGeometry:DA,TorusBufferGeometry:DA,TorusKnotGeometry:OA,TorusKnotBufferGeometry:OA,TubeGeometry:FA,TubeBufferGeometry:FA,WireframeGeometry:cV});function Cg(n){Sn.call(this),this.type="ShadowMaterial",this.color=new jt(0),this.transparent=!0,this.setValues(n)}Cg.prototype=Object.create(Sn.prototype);Cg.prototype.constructor=Cg;Cg.prototype.isShadowMaterial=!0;Cg.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this};function Lf(n){_a.call(this,n),this.type="RawShaderMaterial"}Lf.prototype=Object.create(_a.prototype);Lf.prototype.constructor=Lf;Lf.prototype.isRawShaderMaterial=!0;function Ah(n){Sn.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new jt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Yy,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(n)}Ah.prototype=Object.create(Sn.prototype);Ah.prototype.constructor=Ah;Ah.prototype.isMeshStandardMaterial=!0;Ah.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.vertexTangents=n.vertexTangents,this};function bp(n){Ah.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new rt(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=kn.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(n)}bp.prototype=Object.create(Ah.prototype);bp.prototype.constructor=bp;bp.prototype.isMeshPhysicalMaterial=!0;bp.prototype.copy=function(n){return Ah.prototype.copy.call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.reflectivity=n.reflectivity,n.sheen?this.sheen=(this.sheen||new jt).copy(n.sheen):this.sheen=null,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this};function vp(n){Sn.call(this),this.type="MeshPhongMaterial",this.color=new jt(16777215),this.specular=new jt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Yy,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}vp.prototype=Object.create(Sn.prototype);vp.prototype.constructor=vp;vp.prototype.isMeshPhongMaterial=!0;vp.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function kg(n){Sn.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new jt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Yy,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}kg.prototype=Object.create(Sn.prototype);kg.prototype.constructor=kg;kg.prototype.isMeshToonMaterial=!0;kg.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Tg(n){Sn.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Yy,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Tg.prototype=Object.create(Sn.prototype);Tg.prototype.constructor=Tg;Tg.prototype.isMeshNormalMaterial=!0;Tg.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Eg(n){Sn.call(this),this.type="MeshLambertMaterial",this.color=new jt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new jt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Eg.prototype=Object.create(Sn.prototype);Eg.prototype.constructor=Eg;Eg.prototype.isMeshLambertMaterial=!0;Eg.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ig(n){Sn.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new jt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Yy,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Ig.prototype=Object.create(Sn.prototype);Ig.prototype.constructor=Ig;Ig.prototype.isMeshMatcapMaterial=!0;Ig.prototype.copy=function(n){return Sn.prototype.copy.call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ag(n){Is.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(n)}Ag.prototype=Object.create(Is.prototype);Ag.prototype.constructor=Ag;Ag.prototype.isLineDashedMaterial=!0;Ag.prototype.copy=function(n){return Is.prototype.copy.call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this};var e0t=Object.freeze({__proto__:null,ShadowMaterial:Cg,SpriteMaterial:mp,RawShaderMaterial:Lf,ShaderMaterial:_a,PointsMaterial:Iu,MeshPhysicalMaterial:bp,MeshStandardMaterial:Ah,MeshPhongMaterial:vp,MeshToonMaterial:kg,MeshNormalMaterial:Tg,MeshLambertMaterial:Eg,MeshDepthMaterial:fp,MeshDistanceMaterial:dp,MeshBasicMaterial:Ol,MeshMatcapMaterial:Ig,LineDashedMaterial:Ag,LineBasicMaterial:Is,Material:Sn});const ps={arraySlice:function(n,e,t){return ps.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(s,i){return n[s]-n[i]}const t=n.length,r=new Array(t);for(let s=0;s!==t;++s)r[s]=s;return r.sort(e),r},sortedArray:function(n,e,t){const r=n.length,s=new n.constructor(r);for(let i=0,o=0;o!==r;++i){const a=t[i]*e;for(let l=0;l!==e;++l)s[o++]=n[a+l]}return s},flattenJSON:function(n,e,t,r){let s=1,i=n[0];for(;i!==void 0&&i[r]===void 0;)i=n[s++];if(i===void 0)return;let o=i[r];if(o!==void 0)if(Array.isArray(o))do o=i[r],o!==void 0&&(e.push(i.time),t.push.apply(t,o)),i=n[s++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[r],o!==void 0&&(e.push(i.time),o.toArray(t,t.length)),i=n[s++];while(i!==void 0);else do o=i[r],o!==void 0&&(e.push(i.time),t.push(o)),i=n[s++];while(i!==void 0)},subclip:function(n,e,t,r,s=30){const i=n.clone();i.name=e;const o=[];for(let l=0;l<i.tracks.length;++l){const c=i.tracks[l],u=c.getValueSize(),h=[],f=[];for(let d=0;d<c.times.length;++d){const p=c.times[d]*s;if(!(p<t||p>=r)){h.push(c.times[d]);for(let m=0;m<u;++m)f.push(c.values[d*u+m])}}h.length!==0&&(c.times=ps.convertArray(h,c.times.constructor),c.values=ps.convertArray(f,c.values.constructor),o.push(c))}i.tracks=o;let a=1/0;for(let l=0;l<i.tracks.length;++l)a>i.tracks[l].times[0]&&(a=i.tracks[l].times[0]);for(let l=0;l<i.tracks.length;++l)i.tracks[l].shift(-1*a);return i.resetDuration(),i},makeClipAdditive:function(n,e=0,t=n,r=30){r<=0&&(r=30);const s=t.tracks.length,i=e/r;for(let o=0;o<s;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(y){return y.name===a.name&&y.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let f=0;const d=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=d/3);const p=a.times.length-1;let m;if(i<=a.times[0]){const y=u,b=h-u;m=ps.arraySlice(a.values,y,b)}else if(i>=a.times[p]){const y=p*h+u,b=y+h-u;m=ps.arraySlice(a.values,y,b)}else{const y=a.createInterpolant(),b=u,x=h-u;y.evaluate(i),m=ps.arraySlice(y.resultBuffer,b,x)}l==="quaternion"&&new lo().fromArray(m).normalize().conjugate().toArray(m);const g=c.times.length;for(let y=0;y<g;++y){const b=y*d+f;if(l==="quaternion")lo.multiplyQuaternionsFlat(c.values,b,m,0,c.values,b);else{const x=d-f*2;for(let w=0;w<x;++w)c.values[b+w]-=m[w]}}}return n.blendMode=eV,n}};function Nl(n,e,t,r){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new e.constructor(t),this.sampleValues=e,this.valueSize=t}Object.assign(Nl.prototype,{evaluate:function(n){const e=this.parameterPositions;let t=this._cachedIndex,r=e[t],s=e[t-1];e:{t:{let i;n:{r:if(!(n<r)){for(let o=t+2;;){if(r===void 0){if(n<s)break r;return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,n,s)}if(t===o)break;if(s=r,r=e[++t],n<r)break t}i=e.length;break n}if(!(n>=s)){const o=e[1];n<o&&(t=2,s=o);for(let a=t-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(t===a)break;if(r=s,s=e[--t-1],n>=s)break t}i=t,t=0;break n}break e}for(;t<i;){const o=t+i>>>1;n<e[o]?i=o:t=o+1}if(r=e[t],s=e[t-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(r===void 0)return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,s,n)}this._cachedIndex=t,this.intervalChanged_(t,s,r)}return this.interpolate_(t,s,n,r)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(n){const e=this.resultBuffer,t=this.sampleValues,r=this.valueSize,s=n*r;for(let i=0;i!==r;++i)e[i]=t[s+i];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Nl.prototype,{beforeStart_:Nl.prototype.copySampleValue_,afterEnd_:Nl.prototype.copySampleValue_});function LA(n,e,t,r){Nl.call(this,n,e,t,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}LA.prototype=Object.assign(Object.create(Nl.prototype),{constructor:LA,DefaultSettings_:{endingStart:Bm,endingEnd:Bm},intervalChanged_:function(n,e,t){const r=this.parameterPositions;let s=n-2,i=n+1,o=r[s],a=r[i];if(o===void 0)switch(this.getSettings_().endingStart){case Vm:s=n,o=2*e-t;break;case o_:s=r.length-2,o=e+r[s]-r[s+1];break;default:s=n,o=t}if(a===void 0)switch(this.getSettings_().endingEnd){case Vm:i=n,a=2*t-e;break;case o_:i=1,a=t+r[1]-r[0];break;default:i=n-1,a=e}const l=(t-e)*.5,c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-t),this._offsetPrev=s*c,this._offsetNext=i*c},interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,f=this._weightNext,d=(t-e)/(r-e),p=d*d,m=p*d,g=-h*m+2*h*p-h*d,y=(1+h)*m+(-1.5-2*h)*p+(-.5+h)*d+1,b=(-1-f)*m+(1.5+f)*p+.5*d,x=f*m-f*p;for(let w=0;w!==o;++w)s[w]=g*i[c+w]+y*i[l+w]+b*i[a+w]+x*i[u+w];return s}});function I_(n,e,t,r){Nl.call(this,n,e,t,r)}I_.prototype=Object.assign(Object.create(Nl.prototype),{constructor:I_,interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=(t-e)/(r-e),u=1-c;for(let h=0;h!==o;++h)s[h]=i[l+h]*u+i[a+h]*c;return s}});function zA(n,e,t,r){Nl.call(this,n,e,t,r)}zA.prototype=Object.assign(Object.create(Nl.prototype),{constructor:zA,interpolate_:function(n){return this.copySampleValue_(n-1)}});function xo(n,e,t,r){if(n===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+n);this.name=n,this.times=ps.convertArray(e,this.TimeBufferType),this.values=ps.convertArray(t,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}Object.assign(xo,{toJSON:function(n){const e=n.constructor;let t;if(e.toJSON!==void 0)t=e.toJSON(n);else{t={name:n.name,times:ps.convertArray(n.times,Array),values:ps.convertArray(n.values,Array)};const r=n.getInterpolation();r!==n.DefaultInterpolation&&(t.interpolation=r)}return t.type=n.ValueTypeName,t}});Object.assign(xo.prototype,{constructor:xo,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:nS,InterpolantFactoryMethodDiscrete:function(n){return new zA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodLinear:function(n){return new I_(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:function(n){return new LA(this.times,this.values,this.getValueSize(),n)},setInterpolation:function(n){let e;switch(n){case i_:e=this.InterpolantFactoryMethodDiscrete;break;case nS:e=this.InterpolantFactoryMethodLinear;break;case QE:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(n!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return i_;case this.InterpolantFactoryMethodLinear:return nS;case this.InterpolantFactoryMethodSmooth:return QE}},getValueSize:function(){return this.values.length/this.times.length},shift:function(n){if(n!==0){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]+=n}return this},scale:function(n){if(n!==1){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]*=n}return this},trim:function(n,e){const t=this.times,r=t.length;let s=0,i=r-1;for(;s!==r&&t[s]<n;)++s;for(;i!==-1&&t[i]>e;)--i;if(++i,s!==0||i!==r){s>=i&&(i=Math.max(i,1),s=i-1);const o=this.getValueSize();this.times=ps.arraySlice(t,s,i),this.values=ps.arraySlice(this.values,s*o,i*o)}return this},validate:function(){let n=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);const t=this.times,r=this.values,s=t.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);let i=null;for(let o=0;o!==s;o++){const a=t[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),n=!1;break}if(i!==null&&i>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,i),n=!1;break}i=a}if(r!==void 0&&ps.isTypedArray(r))for(let o=0,a=r.length;o!==a;++o){const l=r[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),n=!1;break}}return n},optimize:function(){const n=ps.arraySlice(this.times),e=ps.arraySlice(this.values),t=this.getValueSize(),r=this.getInterpolation()===QE,s=n.length-1;let i=1;for(let o=1;o<s;++o){let a=!1;const l=n[o],c=n[o+1];if(l!==c&&(o!==1||l!==n[0]))if(r)a=!0;else{const u=o*t,h=u-t,f=u+t;for(let d=0;d!==t;++d){const p=e[u+d];if(p!==e[h+d]||p!==e[f+d]){a=!0;break}}}if(a){if(o!==i){n[i]=n[o];const u=o*t,h=i*t;for(let f=0;f!==t;++f)e[h+f]=e[u+f]}++i}}if(s>0){n[i]=n[s];for(let o=s*t,a=i*t,l=0;l!==t;++l)e[a+l]=e[o+l];++i}return i!==n.length?(this.times=ps.arraySlice(n,0,i),this.values=ps.arraySlice(e,0,i*t)):(this.times=n,this.values=e),this},clone:function(){const n=ps.arraySlice(this.times,0),e=ps.arraySlice(this.values,0),t=this.constructor,r=new t(this.name,n,e);return r.createInterpolant=this.createInterpolant,r}});function BA(n,e,t){xo.call(this,n,e,t)}BA.prototype=Object.assign(Object.create(xo.prototype),{constructor:BA,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:i_,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function VA(n,e,t,r){xo.call(this,n,e,t,r)}VA.prototype=Object.assign(Object.create(xo.prototype),{constructor:VA,ValueTypeName:"color"});function mv(n,e,t,r){xo.call(this,n,e,t,r)}mv.prototype=Object.assign(Object.create(xo.prototype),{constructor:mv,ValueTypeName:"number"});function UA(n,e,t,r){Nl.call(this,n,e,t,r)}UA.prototype=Object.assign(Object.create(Nl.prototype),{constructor:UA,interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=(t-e)/(r-e);let l=n*o;for(let c=l+o;l!==c;l+=4)lo.slerpFlat(s,0,i,l-o,i,l,a);return s}});function A_(n,e,t,r){xo.call(this,n,e,t,r)}A_.prototype=Object.assign(Object.create(xo.prototype),{constructor:A_,ValueTypeName:"quaternion",DefaultInterpolation:nS,InterpolantFactoryMethodLinear:function(n){return new UA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:void 0});function WA(n,e,t,r){xo.call(this,n,e,t,r)}WA.prototype=Object.assign(Object.create(xo.prototype),{constructor:WA,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:i_,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function gv(n,e,t,r){xo.call(this,n,e,t,r)}gv.prototype=Object.assign(Object.create(xo.prototype),{constructor:gv,ValueTypeName:"vector"});function _l(n,e=-1,t,r=E$){this.name=n,this.tracks=t,this.duration=e,this.blendMode=r,this.uuid=kn.generateUUID(),this.duration<0&&this.resetDuration()}function t0t(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return mv;case"vector":case"vector2":case"vector3":case"vector4":return gv;case"color":return VA;case"quaternion":return A_;case"bool":case"boolean":return BA;case"string":return WA}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function n0t(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=t0t(n.type);if(n.times===void 0){const t=[],r=[];ps.flattenJSON(n.keys,t,r,"value"),n.times=t,n.values=r}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}Object.assign(_l,{parse:function(n){const e=[],t=n.tracks,r=1/(n.fps||1);for(let i=0,o=t.length;i!==o;++i)e.push(n0t(t[i]).scale(r));const s=new _l(n.name,n.duration,e,n.blendMode);return s.uuid=n.uuid,s},toJSON:function(n){const e=[],t=n.tracks,r={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode};for(let s=0,i=t.length;s!==i;++s)e.push(xo.toJSON(t[s]));return r},CreateFromMorphTargetSequence:function(n,e,t,r){const s=e.length,i=[];for(let o=0;o<s;o++){let a=[],l=[];a.push((o+s-1)%s,o,(o+1)%s),l.push(0,1,0);const c=ps.getKeyframeOrder(a);a=ps.sortedArray(a,1,c),l=ps.sortedArray(l,1,c),!r&&a[0]===0&&(a.push(s),l.push(l[0])),i.push(new mv(".morphTargetInfluences["+e[o].name+"]",a,l).scale(1/t))}return new _l(n,-1,i)},findByName:function(n,e){let t=n;if(!Array.isArray(n)){const r=n;t=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<t.length;r++)if(t[r].name===e)return t[r];return null},CreateClipsFromMorphTargetSequences:function(n,e,t){const r={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,a=n.length;o<a;o++){const l=n[o],c=l.name.match(s);if(c&&c.length>1){const u=c[1];let h=r[u];h||(r[u]=h=[]),h.push(l)}}const i=[];for(const o in r)i.push(_l.CreateFromMorphTargetSequence(o,r[o],e,t));return i},parseAnimation:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(u,h,f,d,p){if(f.length!==0){const m=[],g=[];ps.flattenJSON(f,m,g,d),m.length!==0&&p.push(new u(h,m,g))}},r=[],s=n.name||"default",i=n.fps||30,o=n.blendMode;let a=n.length||-1;const l=n.hierarchy||[];for(let u=0;u<l.length;u++){const h=l[u].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const f={};let d;for(d=0;d<h.length;d++)if(h[d].morphTargets)for(let p=0;p<h[d].morphTargets.length;p++)f[h[d].morphTargets[p]]=-1;for(const p in f){const m=[],g=[];for(let y=0;y!==h[d].morphTargets.length;++y){const b=h[d];m.push(b.time),g.push(b.morphTarget===p?1:0)}r.push(new mv(".morphTargetInfluence["+p+"]",m,g))}a=f.length*(i||1)}else{const f=".bones["+e[u].name+"]";t(gv,f+".position",h,"pos",r),t(A_,f+".quaternion",h,"rot",r),t(gv,f+".scale",h,"scl",r)}}return r.length===0?null:new _l(s,a,r,o)}});Object.assign(_l.prototype,{resetDuration:function(){const n=this.tracks;let e=0;for(let t=0,r=n.length;t!==r;++t){const s=this.tracks[t];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this},trim:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this},validate:function(){let n=!0;for(let e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n},optimize:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this},clone:function(){const n=[];for(let e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new _l(this.name,this.duration,n,this.blendMode)},toJSON:function(){return _l.toJSON(this)}});const Mg={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};function uV(n,e,t){const r=this;let s=!1,i=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=n,this.onProgress=e,this.onError=t,this.itemStart=function(c){o++,s===!1&&r.onStart!==void 0&&r.onStart(c,i,o),s=!0},this.itemEnd=function(c){i++,r.onProgress!==void 0&&r.onProgress(c,i,o),i===o&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,u){return l.push(c,u),this},this.removeHandler=function(c){const u=l.indexOf(c);return u!==-1&&l.splice(u,2),this},this.getHandler=function(c){for(let u=0,h=l.length;u<h;u+=2){const f=l[u],d=l[u+1];if(f.global&&(f.lastIndex=0),f.test(c))return d}return null}}const fle=new uV;function zr(n){this.manager=n!==void 0?n:fle,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(zr.prototype,{load:function(){},loadAsync:function(n,e){const t=this;return new Promise(function(r,s){t.load(n,r,e,s)})},parse:function(){},setCrossOrigin:function(n){return this.crossOrigin=n,this},setWithCredentials:function(n){return this.withCredentials=n,this},setPath:function(n){return this.path=n,this},setResourcePath:function(n){return this.resourcePath=n,this},setRequestHeader:function(n){return this.requestHeader=n,this}});const nu={};function Rc(n){zr.call(this,n)}Rc.prototype=Object.assign(Object.create(zr.prototype),{constructor:Rc,load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Mg.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;if(nu[n]!==void 0){nu[n].push({onLoad:e,onProgress:t,onError:r});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=n.match(o);let l;if(a){const c=a[1],u=!!a[2];let h=a[3];h=decodeURIComponent(h),u&&(h=atob(h));try{let f;const d=(this.responseType||"").toLowerCase();switch(d){case"arraybuffer":case"blob":const p=new Uint8Array(h.length);for(let g=0;g<h.length;g++)p[g]=h.charCodeAt(g);d==="blob"?f=new Blob([p.buffer],{type:c}):f=p.buffer;break;case"document":f=new DOMParser().parseFromString(h,c);break;case"json":f=JSON.parse(h);break;default:f=h;break}setTimeout(function(){e&&e(f),s.manager.itemEnd(n)},0)}catch(f){setTimeout(function(){r&&r(f),s.manager.itemError(n),s.manager.itemEnd(n)},0)}}else{nu[n]=[],nu[n].push({onLoad:e,onProgress:t,onError:r}),l=new XMLHttpRequest,l.open("GET",n,!0),l.addEventListener("load",function(c){const u=this.response,h=nu[n];if(delete nu[n],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Mg.add(n,u);for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onLoad&&p.onLoad(u)}s.manager.itemEnd(n)}else{for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onError&&p.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)}},!1),l.addEventListener("progress",function(c){const u=nu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onProgress&&d.onProgress(c)}},!1),l.addEventListener("error",function(c){const u=nu[n];delete nu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)},!1),l.addEventListener("abort",function(c){const u=nu[n];delete nu[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return s.manager.itemStart(n),l},setResponseType:function(n){return this.responseType=n,this},setMimeType:function(n){return this.mimeType=n,this}});function VF(n){zr.call(this,n)}VF.prototype=Object.assign(Object.create(zr.prototype),{constructor:VF,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e=[];for(let t=0;t<n.length;t++){const r=_l.parse(n[t]);e.push(r)}return e}});function UF(n){zr.call(this,n)}UF.prototype=Object.assign(Object.create(zr.prototype),{constructor:UF,load:function(n,e,t,r){const s=this,i=[],o=new dv,a=new Rc(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(s.withCredentials);let l=0;function c(u){a.load(n[u],function(h){const f=s.parse(h,!0);i[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},l+=1,l===6&&(f.mipmapCount===1&&(o.minFilter=ao),o.image=i,o.format=f.format,o.needsUpdate=!0,e&&e(o))},t,r)}if(Array.isArray(n))for(let u=0,h=n.length;u<h;++u)c(u);else a.load(n,function(u){const h=s.parse(u,!0);if(h.isCubemap){const f=h.mipmaps.length/h.mipmapCount;for(let d=0;d<f;d++){i[d]={mipmaps:[]};for(let p=0;p<h.mipmapCount;p++)i[d].mipmaps.push(h.mipmaps[d*h.mipmapCount+p]),i[d].format=h.format,i[d].width=h.width,i[d].height=h.height}o.image=i}else o.image.width=h.width,o.image.height=h.height,o.mipmaps=h.mipmaps;h.mipmapCount===1&&(o.minFilter=ao),o.format=h.format,o.needsUpdate=!0,e&&e(o)},t,r);return o}});function yv(n){zr.call(this,n)}yv.prototype=Object.assign(Object.create(zr.prototype),{constructor:yv,load:function(n,e,t,r){this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Mg.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),Mg.add(n,this),e&&e(this),s.manager.itemEnd(n)}function l(c){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),r&&r(c),s.manager.itemError(n),s.manager.itemEnd(n)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),n.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(n),o.src=n,o}});function GA(n){zr.call(this,n)}GA.prototype=Object.assign(Object.create(zr.prototype),{constructor:GA,load:function(n,e,t,r){const s=new Ih,i=new yv(this.manager);i.setCrossOrigin(this.crossOrigin),i.setPath(this.path);let o=0;function a(l){i.load(n[l],function(c){s.images[l]=c,o++,o===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let l=0;l<n.length;++l)a(l);return s}});function HA(n){zr.call(this,n)}HA.prototype=Object.assign(Object.create(zr.prototype),{constructor:HA,load:function(n,e,t,r){const s=this,i=new Ff,o=new Rc(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(s.withCredentials),o.load(n,function(a){const l=s.parse(a);l&&(l.image!==void 0?i.image=l.image:l.data!==void 0&&(i.image.width=l.width,i.image.height=l.height,i.image.data=l.data),i.wrapS=l.wrapS!==void 0?l.wrapS:fa,i.wrapT=l.wrapT!==void 0?l.wrapT:fa,i.magFilter=l.magFilter!==void 0?l.magFilter:ao,i.minFilter=l.minFilter!==void 0?l.minFilter:ao,i.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(i.encoding=l.encoding),l.flipY!==void 0&&(i.flipY=l.flipY),l.format!==void 0&&(i.format=l.format),l.type!==void 0&&(i.type=l.type),l.mipmaps!==void 0&&(i.mipmaps=l.mipmaps,i.minFilter=tx),l.mipmapCount===1&&(i.minFilter=ao),i.needsUpdate=!0,e&&e(i,l))},t,r),i}});function jA(n){zr.call(this,n)}jA.prototype=Object.assign(Object.create(zr.prototype),{constructor:jA,load:function(n,e,t,r){const s=new Kr,i=new yv(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(n,function(o){s.image=o;const a=n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0;s.format=a?jd:Ml,s.needsUpdate=!0,e!==void 0&&e(s)},t,r),s}});function on(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(on.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(n,e){const t=this.getUtoTmapping(n);return this.getPoint(t,e)},getPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return e},getSpacedPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e},getLength:function(){const n=this.getLengths();return n[n.length-1]},getLengths:function(n){if(n===void 0&&(n=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let t,r=this.getPoint(0),s=0;e.push(0);for(let i=1;i<=n;i++)t=this.getPoint(i/n),s+=t.distanceTo(r),e.push(s),r=t;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(n,e){const t=this.getLengths();let r=0;const s=t.length;let i;e?i=e:i=n*t[s-1];let o=0,a=s-1,l;for(;o<=a;)if(r=Math.floor(o+(a-o)/2),l=t[r]-i,l<0)o=r+1;else if(l>0)a=r-1;else{a=r;break}if(r=a,t[r]===i)return r/(s-1);const c=t[r],h=t[r+1]-c,f=(i-c)/h;return(r+f)/(s-1)},getTangent:function(n,e){let r=n-1e-4,s=n+1e-4;r<0&&(r=0),s>1&&(s=1);const i=this.getPoint(r),o=this.getPoint(s),a=e||(i.isVector2?new rt:new J);return a.copy(o).sub(i).normalize(),a},getTangentAt:function(n,e){const t=this.getUtoTmapping(n);return this.getTangent(t,e)},computeFrenetFrames:function(n,e){const t=new J,r=[],s=[],i=[],o=new J,a=new Zn;for(let f=0;f<=n;f++){const d=f/n;r[f]=this.getTangentAt(d,new J),r[f].normalize()}s[0]=new J,i[0]=new J;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),u=Math.abs(r[0].y),h=Math.abs(r[0].z);c<=l&&(l=c,t.set(1,0,0)),u<=l&&(l=u,t.set(0,1,0)),h<=l&&t.set(0,0,1),o.crossVectors(r[0],t).normalize(),s[0].crossVectors(r[0],o),i[0].crossVectors(r[0],s[0]);for(let f=1;f<=n;f++){if(s[f]=s[f-1].clone(),i[f]=i[f-1].clone(),o.crossVectors(r[f-1],r[f]),o.length()>Number.EPSILON){o.normalize();const d=Math.acos(kn.clamp(r[f-1].dot(r[f]),-1,1));s[f].applyMatrix4(a.makeRotationAxis(o,d))}i[f].crossVectors(r[f],s[f])}if(e===!0){let f=Math.acos(kn.clamp(s[0].dot(s[n]),-1,1));f/=n,r[0].dot(o.crossVectors(s[0],s[n]))>0&&(f=-f);for(let d=1;d<=n;d++)s[d].applyMatrix4(a.makeRotationAxis(r[d],f*d)),i[d].crossVectors(r[d],s[d])}return{tangents:r,normals:s,binormals:i}},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this},toJSON:function(){const n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n},fromJSON:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}});function Ll(n,e,t,r,s,i,o,a){on.call(this),this.type="EllipseCurve",this.aX=n||0,this.aY=e||0,this.xRadius=t||1,this.yRadius=r||1,this.aStartAngle=s||0,this.aEndAngle=i||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}Ll.prototype=Object.create(on.prototype);Ll.prototype.constructor=Ll;Ll.prototype.isEllipseCurve=!0;Ll.prototype.getPoint=function(n,e){const t=e||new rt,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const i=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(i?s=0:s=r),this.aClockwise===!0&&!i&&(s===r?s=-r:s=s-r);const o=this.aStartAngle+n*s;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=a-this.aX,f=l-this.aY;a=h*c-f*u+this.aX,l=h*u+f*c+this.aY}return t.set(a,l)};Ll.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};Ll.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n};Ll.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};function bv(n,e,t,r,s,i){Ll.call(this,n,e,t,t,r,s,i),this.type="ArcCurve"}bv.prototype=Object.create(Ll.prototype);bv.prototype.constructor=bv;bv.prototype.isArcCurve=!0;function hV(){let n=0,e=0,t=0,r=0;function s(i,o,a,l){n=i,e=a,t=-3*i+3*o-2*a-l,r=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,c){s(o,a,c*(a-i),c*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,c,u,h){let f=(o-i)/c-(a-i)/(c+u)+(a-o)/u,d=(a-o)/u-(l-o)/(u+h)+(l-a)/h;f*=u,d*=u,s(o,a,f,d)},calc:function(i){const o=i*i,a=o*i;return n+e*i+t*o+r*a}}}const cE=new J,IP=new hV,AP=new hV,MP=new hV;function Zo(n=[],e=!1,t="centripetal",r=.5){on.call(this),this.type="CatmullRomCurve3",this.points=n,this.closed=e,this.curveType=t,this.tension=r}Zo.prototype=Object.create(on.prototype);Zo.prototype.constructor=Zo;Zo.prototype.isCatmullRomCurve3=!0;Zo.prototype.getPoint=function(n,e=new J){const t=e,r=this.points,s=r.length,i=(s-(this.closed?0:1))*n;let o=Math.floor(i),a=i-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:a===0&&o===s-1&&(o=s-2,a=1);let l,c;this.closed||o>0?l=r[(o-1)%s]:(cE.subVectors(r[0],r[1]).add(r[0]),l=cE);const u=r[o%s],h=r[(o+1)%s];if(this.closed||o+2<s?c=r[(o+2)%s]:(cE.subVectors(r[s-1],r[s-2]).add(r[s-1]),c=cE),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let d=Math.pow(l.distanceToSquared(u),f),p=Math.pow(u.distanceToSquared(h),f),m=Math.pow(h.distanceToSquared(c),f);p<1e-4&&(p=1),d<1e-4&&(d=p),m<1e-4&&(m=p),IP.initNonuniformCatmullRom(l.x,u.x,h.x,c.x,d,p,m),AP.initNonuniformCatmullRom(l.y,u.y,h.y,c.y,d,p,m),MP.initNonuniformCatmullRom(l.z,u.z,h.z,c.z,d,p,m)}else this.curveType==="catmullrom"&&(IP.initCatmullRom(l.x,u.x,h.x,c.x,this.tension),AP.initCatmullRom(l.y,u.y,h.y,c.y,this.tension),MP.initCatmullRom(l.z,u.z,h.z,c.z,this.tension));return t.set(IP.calc(a),AP.calc(a),MP.calc(a)),t};Zo.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};Zo.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n};Zo.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new J().fromArray(r))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};function H8(n,e,t,r,s){const i=(r-e)*.5,o=(s-t)*.5,a=n*n,l=n*a;return(2*t-2*r+i+o)*l+(-3*t+3*r-2*i-o)*a+i*n+t}function r0t(n,e){const t=1-n;return t*t*e}function s0t(n,e){return 2*(1-n)*n*e}function i0t(n,e){return n*n*e}function sS(n,e,t,r){return r0t(n,e)+s0t(n,t)+i0t(n,r)}function o0t(n,e){const t=1-n;return t*t*t*e}function a0t(n,e){const t=1-n;return 3*t*t*n*e}function l0t(n,e){return 3*(1-n)*n*n*e}function c0t(n,e){return n*n*n*e}function iS(n,e,t,r,s){return o0t(n,e)+a0t(n,t)+l0t(n,r)+c0t(n,s)}function Au(n=new rt,e=new rt,t=new rt,r=new rt){on.call(this),this.type="CubicBezierCurve",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Au.prototype=Object.create(on.prototype);Au.prototype.constructor=Au;Au.prototype.isCubicBezierCurve=!0;Au.prototype.getPoint=function(n,e=new rt){const t=e,r=this.v0,s=this.v1,i=this.v2,o=this.v3;return t.set(iS(n,r.x,s.x,i.x,o.x),iS(n,r.y,s.y,i.y,o.y)),t};Au.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Au.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Au.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Mh(n=new J,e=new J,t=new J,r=new J){on.call(this),this.type="CubicBezierCurve3",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Mh.prototype=Object.create(on.prototype);Mh.prototype.constructor=Mh;Mh.prototype.isCubicBezierCurve3=!0;Mh.prototype.getPoint=function(n,e=new J){const t=e,r=this.v0,s=this.v1,i=this.v2,o=this.v3;return t.set(iS(n,r.x,s.x,i.x,o.x),iS(n,r.y,s.y,i.y,o.y),iS(n,r.z,s.z,i.z,o.z)),t};Mh.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Mh.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Mh.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Xa(n=new rt,e=new rt){on.call(this),this.type="LineCurve",this.v1=n,this.v2=e}Xa.prototype=Object.create(on.prototype);Xa.prototype.constructor=Xa;Xa.prototype.isLineCurve=!0;Xa.prototype.getPoint=function(n,e=new rt){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Xa.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Xa.prototype.getTangent=function(n,e){const t=e||new rt;return t.copy(this.v2).sub(this.v1).normalize(),t};Xa.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Xa.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Xa.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Mu(n=new J,e=new J){on.call(this),this.type="LineCurve3",this.v1=n,this.v2=e}Mu.prototype=Object.create(on.prototype);Mu.prototype.constructor=Mu;Mu.prototype.isLineCurve3=!0;Mu.prototype.getPoint=function(n,e=new J){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Mu.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Mu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Mu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Mu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Nu(n=new rt,e=new rt,t=new rt){on.call(this),this.type="QuadraticBezierCurve",this.v0=n,this.v1=e,this.v2=t}Nu.prototype=Object.create(on.prototype);Nu.prototype.constructor=Nu;Nu.prototype.isQuadraticBezierCurve=!0;Nu.prototype.getPoint=function(n,e=new rt){const t=e,r=this.v0,s=this.v1,i=this.v2;return t.set(sS(n,r.x,s.x,i.x),sS(n,r.y,s.y,i.y)),t};Nu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Nu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Nu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Nh(n=new J,e=new J,t=new J){on.call(this),this.type="QuadraticBezierCurve3",this.v0=n,this.v1=e,this.v2=t}Nh.prototype=Object.create(on.prototype);Nh.prototype.constructor=Nh;Nh.prototype.isQuadraticBezierCurve3=!0;Nh.prototype.getPoint=function(n,e=new J){const t=e,r=this.v0,s=this.v1,i=this.v2;return t.set(sS(n,r.x,s.x,i.x),sS(n,r.y,s.y,i.y),sS(n,r.z,s.z,i.z)),t};Nh.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Nh.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Nh.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function $u(n=[]){on.call(this),this.type="SplineCurve",this.points=n}$u.prototype=Object.create(on.prototype);$u.prototype.constructor=$u;$u.prototype.isSplineCurve=!0;$u.prototype.getPoint=function(n,e=new rt){const t=e,r=this.points,s=(r.length-1)*n,i=Math.floor(s),o=s-i,a=r[i===0?i:i-1],l=r[i],c=r[i>r.length-2?r.length-1:i+1],u=r[i>r.length-3?r.length-1:i+2];return t.set(H8(o,a.x,l.x,c.x,u.x),H8(o,a.y,l.y,c.y,u.y)),t};$u.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this};$u.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n};$u.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new rt().fromArray(r))}return this};var WF=Object.freeze({__proto__:null,ArcCurve:bv,CatmullRomCurve3:Zo,CubicBezierCurve:Au,CubicBezierCurve3:Mh,EllipseCurve:Ll,LineCurve:Xa,LineCurve3:Mu,QuadraticBezierCurve:Nu,QuadraticBezierCurve3:Nh,SplineCurve:$u});function zd(){on.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}zd.prototype=Object.assign(Object.create(on.prototype),{constructor:zd,add:function(n){this.curves.push(n)},closePath:function(){const n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new Xa(e,n))},getPoint:function(n){const e=n*this.getLength(),t=this.getCurveLengths();let r=0;for(;r<t.length;){if(t[r]>=e){const s=t[r]-e,i=this.curves[r],o=i.getLength(),a=o===0?0:1-s/o;return i.getPointAt(a)}r++}return null},getLength:function(){const n=this.getCurveLengths();return n[n.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const n=[];let e=0;for(let t=0,r=this.curves.length;t<r;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n},getSpacedPoints:function(n=40){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e},getPoints:function(n=12){const e=[];let t;for(let r=0,s=this.curves;r<s.length;r++){const i=s[r],o=i&&i.isEllipseCurve?n*2:i&&(i.isLineCurve||i.isLineCurve3)?1:i&&i.isSplineCurve?n*i.points.length:n,a=i.getPoints(o);for(let l=0;l<a.length;l++){const c=a[l];t&&t.equals(c)||(e.push(c),t=c)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(n){on.prototype.copy.call(this,n),this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(r.clone())}return this.autoClose=n.autoClose,this},toJSON:function(){const n=on.prototype.toJSON.call(this);n.autoClose=this.autoClose,n.curves=[];for(let e=0,t=this.curves.length;e<t;e++){const r=this.curves[e];n.curves.push(r.toJSON())}return n},fromJSON:function(n){on.prototype.fromJSON.call(this,n),this.autoClose=n.autoClose,this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(new WF[r.type]().fromJSON(r))}return this}});function cu(n){zd.call(this),this.type="Path",this.currentPoint=new rt,n&&this.setFromPoints(n)}cu.prototype=Object.assign(Object.create(zd.prototype),{constructor:cu,setFromPoints:function(n){this.moveTo(n[0].x,n[0].y);for(let e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this},moveTo:function(n,e){return this.currentPoint.set(n,e),this},lineTo:function(n,e){const t=new Xa(this.currentPoint.clone(),new rt(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this},quadraticCurveTo:function(n,e,t,r){const s=new Nu(this.currentPoint.clone(),new rt(n,e),new rt(t,r));return this.curves.push(s),this.currentPoint.set(t,r),this},bezierCurveTo:function(n,e,t,r,s,i){const o=new Au(this.currentPoint.clone(),new rt(n,e),new rt(t,r),new rt(s,i));return this.curves.push(o),this.currentPoint.set(s,i),this},splineThru:function(n){const e=[this.currentPoint.clone()].concat(n),t=new $u(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this},arc:function(n,e,t,r,s,i){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(n+o,e+a,t,r,s,i),this},absarc:function(n,e,t,r,s,i){return this.absellipse(n,e,t,t,r,s,i),this},ellipse:function(n,e,t,r,s,i,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(n+l,e+c,t,r,s,i,o,a),this},absellipse:function(n,e,t,r,s,i,o,a){const l=new Ll(n,e,t,r,s,i,o,a);if(this.curves.length>0){const u=l.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(n){return zd.prototype.copy.call(this,n),this.currentPoint.copy(n.currentPoint),this},toJSON:function(){const n=zd.prototype.toJSON.call(this);return n.currentPoint=this.currentPoint.toArray(),n},fromJSON:function(n){return zd.prototype.fromJSON.call(this,n),this.currentPoint.fromArray(n.currentPoint),this}});function Kd(n){cu.call(this,n),this.uuid=kn.generateUUID(),this.type="Shape",this.holes=[]}Kd.prototype=Object.assign(Object.create(cu.prototype),{constructor:Kd,getPointsHoles:function(n){const e=[];for(let t=0,r=this.holes.length;t<r;t++)e[t]=this.holes[t].getPoints(n);return e},extractPoints:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}},copy:function(n){cu.prototype.copy.call(this,n),this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(r.clone())}return this},toJSON:function(){const n=cu.prototype.toJSON.call(this);n.uuid=this.uuid,n.holes=[];for(let e=0,t=this.holes.length;e<t;e++){const r=this.holes[e];n.holes.push(r.toJSON())}return n},fromJSON:function(n){cu.prototype.fromJSON.call(this,n),this.uuid=n.uuid,this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(new cu().fromJSON(r))}return this}});function fs(n,e=1){rn.call(this),this.type="Light",this.color=new jt(n),this.intensity=e}fs.prototype=Object.assign(Object.create(rn.prototype),{constructor:fs,isLight:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.color.copy(n.color),this.intensity=n.intensity,this},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}});function qA(n,e,t){fs.call(this,n,t),this.type="HemisphereLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.groundColor=new jt(e)}qA.prototype=Object.assign(Object.create(fs.prototype),{constructor:qA,isHemisphereLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.groundColor.copy(n.groundColor),this}});function zf(n){this.camera=n,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new rt(512,512),this.map=null,this.mapPass=null,this.matrix=new Zn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new UC,this._frameExtents=new rt(1,1),this._viewportCount=1,this._viewports=[new Hr(0,0,1,1)]}Object.assign(zf.prototype,{_projScreenMatrix:new Zn,_lightPositionWorld:new J,_lookTarget:new J,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(n){const e=this.camera,t=this.matrix,r=this._projScreenMatrix,s=this._lookTarget,i=this._lightPositionWorld;i.setFromMatrixPosition(n.matrixWorld),e.position.copy(i),s.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(s),e.updateMatrixWorld(),r.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(r),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(e.projectionMatrix),t.multiply(e.matrixWorldInverse)},getViewport:function(n){return this._viewports[n]},getFrameExtents:function(){return this._frameExtents},copy:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n={};return this.bias!==0&&(n.bias=this.bias),this.normalBias!==0&&(n.normalBias=this.normalBias),this.radius!==1&&(n.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}});function GF(){zf.call(this,new xi(50,1,.5,500)),this.focus=1}GF.prototype=Object.assign(Object.create(zf.prototype),{constructor:GF,isSpotLightShadow:!0,updateMatrices:function(n){const e=this.camera,t=kn.RAD2DEG*2*n.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=n.distance||e.far;(t!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=t,e.aspect=r,e.far=s,e.updateProjectionMatrix()),zf.prototype.updateMatrices.call(this,n)}});function XA(n,e,t,r,s,i){fs.call(this,n,e),this.type="SpotLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(o){this.intensity=o/Math.PI}}),this.distance=t!==void 0?t:0,this.angle=r!==void 0?r:Math.PI/3,this.penumbra=s!==void 0?s:0,this.decay=i!==void 0?i:1,this.shadow=new GF}XA.prototype=Object.assign(Object.create(fs.prototype),{constructor:XA,isSpotLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function HF(){zf.call(this,new xi(90,1,.5,500)),this._frameExtents=new rt(4,2),this._viewportCount=6,this._viewports=[new Hr(2,1,1,1),new Hr(0,1,1,1),new Hr(3,1,1,1),new Hr(1,1,1,1),new Hr(3,0,1,1),new Hr(1,0,1,1)],this._cubeDirections=[new J(1,0,0),new J(-1,0,0),new J(0,0,1),new J(0,0,-1),new J(0,1,0),new J(0,-1,0)],this._cubeUps=[new J(0,1,0),new J(0,1,0),new J(0,1,0),new J(0,1,0),new J(0,0,1),new J(0,0,-1)]}HF.prototype=Object.assign(Object.create(zf.prototype),{constructor:HF,isPointLightShadow:!0,updateMatrices:function(n,e=0){const t=this.camera,r=this.matrix,s=this._lightPositionWorld,i=this._lookTarget,o=this._projScreenMatrix;s.setFromMatrixPosition(n.matrixWorld),t.position.copy(s),i.copy(t.position),i.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(i),t.updateMatrixWorld(),r.makeTranslation(-s.x,-s.y,-s.z),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}});function KA(n,e,t,r){fs.call(this,n,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(s){this.intensity=s/(4*Math.PI)}}),this.distance=t!==void 0?t:0,this.decay=r!==void 0?r:1,this.shadow=new HF}KA.prototype=Object.assign(Object.create(fs.prototype),{constructor:KA,isPointLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}});function vv(n=-1,e=1,t=1,r=-1,s=.1,i=2e3){Eh.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=n,this.right=e,this.top=t,this.bottom=r,this.near=s,this.far=i,this.updateProjectionMatrix()}vv.prototype=Object.assign(Object.create(Eh.prototype),{constructor:vv,isOrthographicCamera:!0,copy:function(n,e){return Eh.prototype.copy.call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=n.view===null?null:Object.assign({},n.view),this},setViewOffset:function(n,e,t,r,s,i){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=t-n,i=t+n,o=r+e,a=r-e;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=l*this.view.offsetX,i=s+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(s,i,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}});function jF(){zf.call(this,new vv(-5,5,5,-5,.5,500))}jF.prototype=Object.assign(Object.create(zf.prototype),{constructor:jF,isDirectionalLightShadow:!0,updateMatrices:function(n){zf.prototype.updateMatrices.call(this,n)}});function YA(n,e){fs.call(this,n,e),this.type="DirectionalLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,this.shadow=new jF}YA.prototype=Object.assign(Object.create(fs.prototype),{constructor:YA,isDirectionalLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function ZA(n,e){fs.call(this,n,e),this.type="AmbientLight"}ZA.prototype=Object.assign(Object.create(fs.prototype),{constructor:ZA,isAmbientLight:!0});function JA(n,e,t,r){fs.call(this,n,e),this.type="RectAreaLight",this.width=t!==void 0?t:10,this.height=r!==void 0?r:10}JA.prototype=Object.assign(Object.create(fs.prototype),{constructor:JA,isRectAreaLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.width=n.width,this.height=n.height,this},toJSON:function(n){const e=fs.prototype.toJSON.call(this,n);return e.object.width=this.width,e.object.height=this.height,e}});class dle{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new J)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*s),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*r),t.addScaledVector(o[4],1.092548*(r*s)),t.addScaledVector(o[5],1.092548*(s*i)),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],1.092548*(r*i)),t.addScaledVector(o[8],.546274*(r*r-s*s)),t}getIrradianceAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*s),t.addScaledVector(o[2],2*.511664*i),t.addScaledVector(o[3],2*.511664*r),t.addScaledVector(o[4],2*.429043*r*s),t.addScaledVector(o[5],2*.429043*s*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],2*.429043*r*i),t.addScaledVector(o[8],.429043*(r*r-s*s)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].fromArray(e,t+s*3);return this}toArray(e=[],t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].toArray(e,t+s*3);return e}static getBasisAt(e,t){const r=e.x,s=e.y,i=e.z;t[0]=.282095,t[1]=.488603*s,t[2]=.488603*i,t[3]=.488603*r,t[4]=1.092548*r*s,t[5]=1.092548*s*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*r*i,t[8]=.546274*(r*r-s*s)}}function Cc(n,e){fs.call(this,void 0,e),this.type="LightProbe",this.sh=n!==void 0?n:new dle}Cc.prototype=Object.assign(Object.create(fs.prototype),{constructor:Cc,isLightProbe:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.sh.copy(n.sh),this},fromJSON:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this},toJSON:function(n){const e=fs.prototype.toJSON.call(this,n);return e.object.sh=this.sh.toArray(),e}});function QA(n){zr.call(this,n),this.textures={}}QA.prototype=Object.assign(Object.create(zr.prototype),{constructor:QA,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e=this.textures;function t(s){return e[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),e[s]}const r=new e0t[n.type];if(n.uuid!==void 0&&(r.uuid=n.uuid),n.name!==void 0&&(r.name=n.name),n.color!==void 0&&r.color!==void 0&&r.color.setHex(n.color),n.roughness!==void 0&&(r.roughness=n.roughness),n.metalness!==void 0&&(r.metalness=n.metalness),n.sheen!==void 0&&(r.sheen=new jt().setHex(n.sheen)),n.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(n.emissive),n.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(n.specular),n.shininess!==void 0&&(r.shininess=n.shininess),n.clearcoat!==void 0&&(r.clearcoat=n.clearcoat),n.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=n.clearcoatRoughness),n.fog!==void 0&&(r.fog=n.fog),n.flatShading!==void 0&&(r.flatShading=n.flatShading),n.blending!==void 0&&(r.blending=n.blending),n.combine!==void 0&&(r.combine=n.combine),n.side!==void 0&&(r.side=n.side),n.opacity!==void 0&&(r.opacity=n.opacity),n.transparent!==void 0&&(r.transparent=n.transparent),n.alphaTest!==void 0&&(r.alphaTest=n.alphaTest),n.depthTest!==void 0&&(r.depthTest=n.depthTest),n.depthWrite!==void 0&&(r.depthWrite=n.depthWrite),n.colorWrite!==void 0&&(r.colorWrite=n.colorWrite),n.stencilWrite!==void 0&&(r.stencilWrite=n.stencilWrite),n.stencilWriteMask!==void 0&&(r.stencilWriteMask=n.stencilWriteMask),n.stencilFunc!==void 0&&(r.stencilFunc=n.stencilFunc),n.stencilRef!==void 0&&(r.stencilRef=n.stencilRef),n.stencilFuncMask!==void 0&&(r.stencilFuncMask=n.stencilFuncMask),n.stencilFail!==void 0&&(r.stencilFail=n.stencilFail),n.stencilZFail!==void 0&&(r.stencilZFail=n.stencilZFail),n.stencilZPass!==void 0&&(r.stencilZPass=n.stencilZPass),n.wireframe!==void 0&&(r.wireframe=n.wireframe),n.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=n.wireframeLinewidth),n.wireframeLinecap!==void 0&&(r.wireframeLinecap=n.wireframeLinecap),n.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=n.wireframeLinejoin),n.rotation!==void 0&&(r.rotation=n.rotation),n.linewidth!==1&&(r.linewidth=n.linewidth),n.dashSize!==void 0&&(r.dashSize=n.dashSize),n.gapSize!==void 0&&(r.gapSize=n.gapSize),n.scale!==void 0&&(r.scale=n.scale),n.polygonOffset!==void 0&&(r.polygonOffset=n.polygonOffset),n.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=n.polygonOffsetFactor),n.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=n.polygonOffsetUnits),n.skinning!==void 0&&(r.skinning=n.skinning),n.morphTargets!==void 0&&(r.morphTargets=n.morphTargets),n.morphNormals!==void 0&&(r.morphNormals=n.morphNormals),n.dithering!==void 0&&(r.dithering=n.dithering),n.vertexTangents!==void 0&&(r.vertexTangents=n.vertexTangents),n.visible!==void 0&&(r.visible=n.visible),n.toneMapped!==void 0&&(r.toneMapped=n.toneMapped),n.userData!==void 0&&(r.userData=n.userData),n.vertexColors!==void 0&&(typeof n.vertexColors=="number"?r.vertexColors=n.vertexColors>0:r.vertexColors=n.vertexColors),n.uniforms!==void 0)for(const s in n.uniforms){const i=n.uniforms[s];switch(r.uniforms[s]={},i.type){case"t":r.uniforms[s].value=t(i.value);break;case"c":r.uniforms[s].value=new jt().setHex(i.value);break;case"v2":r.uniforms[s].value=new rt().fromArray(i.value);break;case"v3":r.uniforms[s].value=new J().fromArray(i.value);break;case"v4":r.uniforms[s].value=new Hr().fromArray(i.value);break;case"m3":r.uniforms[s].value=new kl().fromArray(i.value);break;case"m4":r.uniforms[s].value=new Zn().fromArray(i.value);break;default:r.uniforms[s].value=i.value}}if(n.defines!==void 0&&(r.defines=n.defines),n.vertexShader!==void 0&&(r.vertexShader=n.vertexShader),n.fragmentShader!==void 0&&(r.fragmentShader=n.fragmentShader),n.extensions!==void 0)for(const s in n.extensions)r.extensions[s]=n.extensions[s];if(n.shading!==void 0&&(r.flatShading=n.shading===1),n.size!==void 0&&(r.size=n.size),n.sizeAttenuation!==void 0&&(r.sizeAttenuation=n.sizeAttenuation),n.map!==void 0&&(r.map=t(n.map)),n.matcap!==void 0&&(r.matcap=t(n.matcap)),n.alphaMap!==void 0&&(r.alphaMap=t(n.alphaMap)),n.bumpMap!==void 0&&(r.bumpMap=t(n.bumpMap)),n.bumpScale!==void 0&&(r.bumpScale=n.bumpScale),n.normalMap!==void 0&&(r.normalMap=t(n.normalMap)),n.normalMapType!==void 0&&(r.normalMapType=n.normalMapType),n.normalScale!==void 0){let s=n.normalScale;Array.isArray(s)===!1&&(s=[s,s]),r.normalScale=new rt().fromArray(s)}return n.displacementMap!==void 0&&(r.displacementMap=t(n.displacementMap)),n.displacementScale!==void 0&&(r.displacementScale=n.displacementScale),n.displacementBias!==void 0&&(r.displacementBias=n.displacementBias),n.roughnessMap!==void 0&&(r.roughnessMap=t(n.roughnessMap)),n.metalnessMap!==void 0&&(r.metalnessMap=t(n.metalnessMap)),n.emissiveMap!==void 0&&(r.emissiveMap=t(n.emissiveMap)),n.emissiveIntensity!==void 0&&(r.emissiveIntensity=n.emissiveIntensity),n.specularMap!==void 0&&(r.specularMap=t(n.specularMap)),n.envMap!==void 0&&(r.envMap=t(n.envMap)),n.envMapIntensity!==void 0&&(r.envMapIntensity=n.envMapIntensity),n.reflectivity!==void 0&&(r.reflectivity=n.reflectivity),n.refractionRatio!==void 0&&(r.refractionRatio=n.refractionRatio),n.lightMap!==void 0&&(r.lightMap=t(n.lightMap)),n.lightMapIntensity!==void 0&&(r.lightMapIntensity=n.lightMapIntensity),n.aoMap!==void 0&&(r.aoMap=t(n.aoMap)),n.aoMapIntensity!==void 0&&(r.aoMapIntensity=n.aoMapIntensity),n.gradientMap!==void 0&&(r.gradientMap=t(n.gradientMap)),n.clearcoatMap!==void 0&&(r.clearcoatMap=t(n.clearcoatMap)),n.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=t(n.clearcoatRoughnessMap)),n.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=t(n.clearcoatNormalMap)),n.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new rt().fromArray(n.clearcoatNormalScale)),n.transmission!==void 0&&(r.transmission=n.transmission),n.transmissionMap!==void 0&&(r.transmissionMap=t(n.transmissionMap)),r},setTextures:function(n){return this.textures=n,this}});const fV={decodeText:function(n){if(typeof TextDecoder<"u")return new TextDecoder().decode(n);let e="";for(let t=0,r=n.length;t<r;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}},extractUrlBase:function(n){const e=n.lastIndexOf("/");return e===-1?"./":n.substr(0,e+1)}};function M_(){cn.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}M_.prototype=Object.assign(Object.create(cn.prototype),{constructor:M_,isInstancedBufferGeometry:!0,copy:function(n){return cn.prototype.copy.call(this,n),this.instanceCount=n.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n=cn.prototype.toJSON.call(this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}});function eM(n,e,t,r){typeof t=="number"&&(r=t,t=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),xn.call(this,n,e,t),this.meshPerAttribute=r||1}eM.prototype=Object.assign(Object.create(xn.prototype),{constructor:eM,isInstancedBufferAttribute:!0,copy:function(n){return xn.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},toJSON:function(){const n=xn.prototype.toJSON.call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}});function tM(n){zr.call(this,n)}tM.prototype=Object.assign(Object.create(zr.prototype),{constructor:tM,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e={},t={};function r(f,d){if(e[d]!==void 0)return e[d];const m=f.interleavedBuffers[d],g=s(f,m.buffer),y=N1(m.type,g),b=new Tl(y,m.stride);return b.uuid=m.uuid,e[d]=b,b}function s(f,d){if(t[d]!==void 0)return t[d];const m=f.arrayBuffers[d],g=new Uint32Array(m).buffer;return t[d]=g,g}const i=n.isInstancedBufferGeometry?new M_:new cn,o=n.data.index;if(o!==void 0){const f=N1(o.type,o.array);i.setIndex(new xn(f,1))}const a=n.data.attributes;for(const f in a){const d=a[f];let p;if(d.isInterleavedBufferAttribute){const m=r(n.data,d.data);p=new pp(m,d.itemSize,d.offset,d.normalized)}else{const m=N1(d.type,d.array),g=d.isInstancedBufferAttribute?eM:xn;p=new g(m,d.itemSize,d.normalized)}d.name!==void 0&&(p.name=d.name),i.setAttribute(f,p)}const l=n.data.morphAttributes;if(l)for(const f in l){const d=l[f],p=[];for(let m=0,g=d.length;m<g;m++){const y=d[m];let b;if(y.isInterleavedBufferAttribute){const x=r(n.data,y.data);b=new pp(x,y.itemSize,y.offset,y.normalized)}else{const x=N1(y.type,y.array);b=new xn(x,y.itemSize,y.normalized)}y.name!==void 0&&(b.name=y.name),p.push(b)}i.morphAttributes[f]=p}n.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const u=n.data.groups||n.data.drawcalls||n.data.offsets;if(u!==void 0)for(let f=0,d=u.length;f!==d;++f){const p=u[f];i.addGroup(p.start,p.count,p.materialIndex)}const h=n.data.boundingSphere;if(h!==void 0){const f=new J;h.center!==void 0&&f.fromArray(h.center),i.boundingSphere=new Op(f,h.radius)}return n.name&&(i.name=n.name),n.userData&&(i.userData=n.userData),i}});class u0t extends zr{constructor(e){super(e)}load(e,t,r,s){const i=this,o=this.path===""?fV.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Rc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){s!==void 0&&s(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}i.parse(c,t)},r,s)}parse(e,t){const r=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,i,l,r),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const f in o)if(o[f]instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}parseShapes(e){const t={};if(e!==void 0)for(let r=0,s=e.length;r<s;r++){const i=new Kd().fromJSON(e[r]);t[i.uuid]=i}return t}parseSkeletons(e,t){const r={},s={};if(t.traverse(function(i){i.isBone&&(s[i.uuid]=i)}),e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=new v_().fromJSON(e[i],s);r[a.uuid]=a}return r}parseGeometries(e,t){const r={};let s;if(e!==void 0){const i=new tM;for(let o=0,a=e.length;o<a;o++){let l;const c=e[o];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":l=new oa[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":l=new oa[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":l=new oa[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":l=new oa[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":l=new oa[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":l=new oa[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":l=new oa[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":l=new oa[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":l=new oa[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":l=new oa[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":l=new oa[c.type](new WF[c.path.type]().fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":l=new oa[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":l=new oa[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":s=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];s.push(d)}l=new oa[c.type](s,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":s=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];s.push(d)}const u=c.options.extrudePath;u!==void 0&&(c.options.extrudePath=new WF[u.type]().fromJSON(u)),l=new oa[c.type](s,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":l=i.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),l.isBufferGeometry===!0&&c.userData!==void 0&&(l.userData=c.userData),r[c.uuid]=l}}return r}parseMaterials(e,t){const r={},s={};if(e!==void 0){const i=new QA;i.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];if(l.type==="MultiMaterial"){const c=[];for(let u=0;u<l.materials.length;u++){const h=l.materials[u];r[h.uuid]===void 0&&(r[h.uuid]=i.parse(h)),c.push(r[h.uuid])}s[l.uuid]=c}else r[l.uuid]===void 0&&(r[l.uuid]=i.parse(l)),s[l.uuid]=r[l.uuid]}}return s}parseAnimations(e){const t={};if(e!==void 0)for(let r=0;r<e.length;r++){const s=e[r],i=_l.parse(s);t[i.uuid]=i}return t}parseImages(e,t){const r=this,s={};let i;function o(l){return r.manager.itemStart(l),i.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:r.resourcePath+c;return o(u)}else return l.data?{data:N1(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new uV(t);i=new yv(l),i.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],f=h.url;if(Array.isArray(f)){s[h.uuid]=[];for(let d=0,p=f.length;d<p;d++){const m=f[d],g=a(m);g!==null&&(g instanceof HTMLImageElement?s[h.uuid].push(g):s[h.uuid].push(new Ff(g.data,g.width,g.height)))}}else{const d=a(h.url);d!==null&&(s[h.uuid]=d)}}}return s}parseTextures(e,t){function r(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const s={};if(e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=e[i];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let l;const c=t[a.image];Array.isArray(c)?(l=new Ih(c),c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new Ff(c.data,c.width,c.height):l=new Kr(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=r(a.mapping,h0t)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=r(a.wrap[0],j8),l.wrapT=r(a.wrap[1],j8)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=r(a.minFilter,q8)),a.magFilter!==void 0&&(l.magFilter=r(a.magFilter,q8)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),s[a.uuid]=l}return s}parseObject(e,t,r,s){let i;function o(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function a(u){if(u!==void 0){if(Array.isArray(u)){const h=[];for(let f=0,d=u.length;f<d;f++){const p=u[f];r[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),h.push(r[p])}return h}return r[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),r[u]}}let l,c;switch(e.type){case"Scene":i=new aV,e.background!==void 0&&Number.isInteger(e.background)&&(i.background=new jt(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?i.fog=new N$(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(i.fog=new M$(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":i=new xi(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(i.focus=e.focus),e.zoom!==void 0&&(i.zoom=e.zoom),e.filmGauge!==void 0&&(i.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(i.filmOffset=e.filmOffset),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"OrthographicCamera":i=new vv(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(i.zoom=e.zoom),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"AmbientLight":i=new ZA(e.color,e.intensity);break;case"DirectionalLight":i=new YA(e.color,e.intensity);break;case"PointLight":i=new KA(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":i=new JA(e.color,e.intensity,e.width,e.height);break;case"SpotLight":i=new XA(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":i=new qA(e.color,e.groundColor,e.intensity);break;case"LightProbe":i=new Cc().fromJSON(e);break;case"SkinnedMesh":l=o(e.geometry),c=a(e.material),i=new y_(l,c),e.bindMode!==void 0&&(i.bindMode=e.bindMode),e.bindMatrix!==void 0&&i.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(i.skeleton=e.skeleton);break;case"Mesh":l=o(e.geometry),c=a(e.material),i=new hs(l,c);break;case"InstancedMesh":l=o(e.geometry),c=a(e.material);const u=e.count,h=e.instanceMatrix;i=new kA(l,c,u),i.instanceMatrix=new xn(new Float32Array(h.array),16);break;case"LOD":i=new g_;break;case"Line":i=new $c(o(e.geometry),a(e.material));break;case"LineLoop":i=new TA(o(e.geometry),a(e.material));break;case"LineSegments":i=new Ca(o(e.geometry),a(e.material));break;case"PointCloud":case"Points":i=new fv(o(e.geometry),a(e.material));break;case"Sprite":i=new m_(a(e.material));break;case"Group":i=new Ld;break;case"Bone":i=new b_;break;default:i=new rn}if(i.uuid=e.uuid,e.name!==void 0&&(i.name=e.name),e.matrix!==void 0?(i.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(i.matrixAutoUpdate=e.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(e.position!==void 0&&i.position.fromArray(e.position),e.rotation!==void 0&&i.rotation.fromArray(e.rotation),e.quaternion!==void 0&&i.quaternion.fromArray(e.quaternion),e.scale!==void 0&&i.scale.fromArray(e.scale)),e.castShadow!==void 0&&(i.castShadow=e.castShadow),e.receiveShadow!==void 0&&(i.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(i.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(i.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(i.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&i.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(i.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(i.visible=e.visible),e.frustumCulled!==void 0&&(i.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(i.renderOrder=e.renderOrder),e.userData!==void 0&&(i.userData=e.userData),e.layers!==void 0&&(i.layers.mask=e.layers),e.children!==void 0){const u=e.children;for(let h=0;h<u.length;h++)i.add(this.parseObject(u[h],t,r,s))}if(e.animations!==void 0){const u=e.animations;for(let h=0;h<u.length;h++){const f=u[h];i.animations.push(s[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(i.autoUpdate=e.autoUpdate);const u=e.levels;for(let h=0;h<u.length;h++){const f=u[h],d=i.getObjectByProperty("uuid",f.object);d!==void 0&&i.addLevel(d,f.distance)}}return i}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const s=t[r.skeleton];s===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(s,r.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const h0t={UVMapping:T$,CubeReflectionMapping:FC,CubeRefractionMapping:LC,EquirectangularReflectionMapping:wA,EquirectangularRefractionMapping:xA,CubeUVReflectionMapping:ex,CubeUVRefractionMapping:zC},j8={RepeatWrapping:t_,ClampToEdgeWrapping:fa,MirroredRepeatWrapping:n_},q8={NearestFilter:Bi,NearestMipmapNearestFilter:SA,NearestMipmapLinearFilter:_A,LinearFilter:ao,LinearMipmapNearestFilter:Q4,LinearMipmapLinearFilter:tx};function qF(n){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),zr.call(this,n),this.options={premultiplyAlpha:"none"}}qF.prototype=Object.assign(Object.create(zr.prototype),{constructor:qF,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Mg.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(n,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,s.options)}).then(function(a){Mg.add(n,a),e&&e(a),s.manager.itemEnd(n)}).catch(function(a){r&&r(a),s.manager.itemError(n),s.manager.itemEnd(n)}),s.manager.itemStart(n)}});function dV(){this.type="ShapePath",this.color=new jt,this.subPaths=[],this.currentPath=null}Object.assign(dV.prototype,{moveTo:function(n,e){return this.currentPath=new cu,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this},lineTo:function(n,e){return this.currentPath.lineTo(n,e),this},quadraticCurveTo:function(n,e,t,r){return this.currentPath.quadraticCurveTo(n,e,t,r),this},bezierCurveTo:function(n,e,t,r,s,i){return this.currentPath.bezierCurveTo(n,e,t,r,s,i),this},splineThru:function(n){return this.currentPath.splineThru(n),this},toShapes:function(n,e){function t(y){const b=[];for(let x=0,w=y.length;x<w;x++){const _=y[x],C=new Kd;C.curves=_.curves,b.push(C)}return b}function r(y,b){const x=b.length;let w=!1;for(let _=x-1,C=0;C<x;_=C++){let k=b[_],A=b[C],M=A.x-k.x,I=A.y-k.y;if(Math.abs(I)>Number.EPSILON){if(I<0&&(k=b[C],M=-M,A=b[_],I=-I),y.y<k.y||y.y>A.y)continue;if(y.y===k.y){if(y.x===k.x)return!0}else{const N=I*(y.x-k.x)-M*(y.y-k.y);if(N===0)return!0;if(N<0)continue;w=!w}}else{if(y.y!==k.y)continue;if(A.x<=y.x&&y.x<=k.x||k.x<=y.x&&y.x<=A.x)return!0}}return w}const s=$f.isClockWise,i=this.subPaths;if(i.length===0)return[];if(e===!0)return t(i);let o,a,l;const c=[];if(i.length===1)return a=i[0],l=new Kd,l.curves=a.curves,c.push(l),c;let u=!s(i[0].getPoints());u=n?!u:u;const h=[],f=[];let d=[],p=0,m;f[p]=void 0,d[p]=[];for(let y=0,b=i.length;y<b;y++)a=i[y],m=a.getPoints(),o=s(m),o=n?!o:o,o?(!u&&f[p]&&p++,f[p]={s:new Kd,p:m},f[p].s.curves=a.curves,u&&p++,d[p]=[]):d[p].push({h:a,p:m[0]});if(!f[0])return t(i);if(f.length>1){let y=!1;const b=[];for(let x=0,w=f.length;x<w;x++)h[x]=[];for(let x=0,w=f.length;x<w;x++){const _=d[x];for(let C=0;C<_.length;C++){const k=_[C];let A=!0;for(let M=0;M<f.length;M++)r(k.p,f[M].p)&&(x!==M&&b.push({froms:x,tos:M,hole:C}),A?(A=!1,h[M].push(k)):y=!0);A&&h[x].push(k)}}b.length>0&&(y||(d=h))}let g;for(let y=0,b=f.length;y<b;y++){l=f[y].s,c.push(l),g=d[y];for(let x=0,w=g.length;x<w;x++)l.holes.push(g[x].h)}return c}});class ple{constructor(e){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=e}generateShapes(e,t=100){const r=[],s=f0t(e,t,this.data);for(let i=0,o=s.length;i<o;i++)Array.prototype.push.apply(r,s[i].toShapes());return r}}function f0t(n,e,t){const r=Array.from?Array.from(n):String(n).split(""),s=e/t.resolution,i=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*s,o=[];let a=0,l=0;for(let c=0;c<r.length;c++){const u=r[c];if(u===`
`)a=0,l-=i;else{const h=d0t(u,s,a,l,t);a+=h.offsetX,o.push(h.path)}}return o}function d0t(n,e,t,r,s){const i=s.glyphs[n]||s.glyphs["?"];if(!i){console.error('THREE.Font: character "'+n+'" does not exists in font family '+s.familyName+".");return}const o=new dV;let a,l,c,u,h,f,d,p;if(i.o){const m=i._cachedOutline||(i._cachedOutline=i.o.split(" "));for(let g=0,y=m.length;g<y;)switch(m[g++]){case"m":a=m[g++]*e+t,l=m[g++]*e+r,o.moveTo(a,l);break;case"l":a=m[g++]*e+t,l=m[g++]*e+r,o.lineTo(a,l);break;case"q":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,o.quadraticCurveTo(h,f,c,u);break;case"b":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,d=m[g++]*e+t,p=m[g++]*e+r,o.bezierCurveTo(h,f,d,p,c,u);break}}return{offsetX:i.ha*e,path:o}}function XF(n){zr.call(this,n)}XF.prototype=Object.assign(Object.create(zr.prototype),{constructor:XF,load:function(n,e,t,r){const s=this,i=new Rc(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){let a;try{a=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(o.substring(65,o.length-2))}const l=s.parse(a);e&&e(l)},t,r)},parse:function(n){return new ple(n)}});let uE;const pV={getContext:function(){return uE===void 0&&(uE=new(window.AudioContext||window.webkitAudioContext)),uE},setContext:function(n){uE=n}};function nM(n){zr.call(this,n)}nM.prototype=Object.assign(Object.create(zr.prototype),{constructor:nM,load:function(n,e,t,r){const s=this,i=new Rc(s.manager);i.setResponseType("arraybuffer"),i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{const a=o.slice(0);pV.getContext().decodeAudioData(a,function(c){e(c)})}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)}});function KF(n,e,t){Cc.call(this,void 0,t);const r=new jt().set(n),s=new jt().set(e),i=new J(r.r,r.g,r.b),o=new J(s.r,s.g,s.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(i).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(i).sub(o).multiplyScalar(l)}KF.prototype=Object.assign(Object.create(Cc.prototype),{constructor:KF,isHemisphereLightProbe:!0,copy:function(n){return Cc.prototype.copy.call(this,n),this},toJSON:function(n){return Cc.prototype.toJSON.call(this,n)}});function YF(n,e){Cc.call(this,void 0,e);const t=new jt().set(n);this.sh.coefficients[0].set(t.r,t.g,t.b).multiplyScalar(2*Math.sqrt(Math.PI))}YF.prototype=Object.assign(Object.create(Cc.prototype),{constructor:YF,isAmbientLightProbe:!0,copy:function(n){return Cc.prototype.copy.call(this,n),this},toJSON:function(n){return Cc.prototype.toJSON.call(this,n)}});const X8=new Zn,K8=new Zn;function mle(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new xi,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new xi,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(mle.prototype,{update:function(n){const e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep;const r=n.projectionMatrix.clone(),s=e.eyeSep/2,i=s*e.near/e.focus,o=e.near*Math.tan(kn.DEG2RAD*e.fov*.5)/e.zoom;let a,l;K8.elements[12]=-s,X8.elements[12]=s,a=-o*e.aspect+i,l=o*e.aspect+i,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(r),a=-o*e.aspect-i,l=o*e.aspect-i,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(r)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(K8),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(X8)}});class gle{constructor(e){this.autoStart=e!==void 0?e:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Y8(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Y8();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Y8(){return(typeof performance>"u"?Date:performance).now()}const hm=new J,Z8=new lo,p0t=new J,fm=new J;class m0t extends rn{constructor(){super(),this.type="AudioListener",this.context=pV.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new gle}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(hm,Z8,p0t),fm.set(0,0,-1).applyQuaternion(Z8),t.positionX){const s=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(hm.x,s),t.positionY.linearRampToValueAtTime(hm.y,s),t.positionZ.linearRampToValueAtTime(hm.z,s),t.forwardX.linearRampToValueAtTime(fm.x,s),t.forwardY.linearRampToValueAtTime(fm.y,s),t.forwardZ.linearRampToValueAtTime(fm.z,s),t.upX.linearRampToValueAtTime(r.x,s),t.upY.linearRampToValueAtTime(r.y,s),t.upZ.linearRampToValueAtTime(r.z,s)}else t.setPosition(hm.x,hm.y,hm.z),t.setOrientation(fm.x,fm.y,fm.z,r.x,r.y,r.z)}}class mV extends rn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const dm=new J,J8=new lo,g0t=new J,pm=new J;class y0t extends mV{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(dm,J8,g0t),pm.set(0,0,1).applyQuaternion(J8);const t=this.panner;if(t.positionX){const r=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(dm.x,r),t.positionY.linearRampToValueAtTime(dm.y,r),t.positionZ.linearRampToValueAtTime(dm.z,r),t.orientationX.linearRampToValueAtTime(pm.x,r),t.orientationY.linearRampToValueAtTime(pm.y,r),t.orientationZ.linearRampToValueAtTime(pm.z,r)}else t.setPosition(dm.x,dm.y,dm.z),t.setOrientation(pm.x,pm.y,pm.z)}}class yle{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let r=0;r<t.length;r++)e+=t[r];return e/t.length}}function gV(n,e,t){this.binding=n,this.valueSize=t;let r,s,i;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:r=this._lerp,s=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(gV.prototype,{accumulate:function(n,e){const t=this.buffer,r=this.valueSize,s=n*r+r;let i=this.cumulativeWeight;if(i===0){for(let o=0;o!==r;++o)t[s+o]=t[o];i=e}else{i+=e;const o=e/i;this._mixBufferRegion(t,s,0,o,r)}this.cumulativeWeight=i},accumulateAdditive:function(n){const e=this.buffer,t=this.valueSize,r=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,n,t),this.cumulativeWeightAdditive+=n},apply:function(n){const e=this.valueSize,t=this.buffer,r=n*e+e,s=this.cumulativeWeight,i=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const a=e*this._origIndex;this._mixBufferRegion(t,r,a,1-s,e)}i>0&&this._mixBufferRegionAdditive(t,r,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(t[a]!==t[a+e]){o.setValue(t,r);break}},saveOriginalState:function(){const n=this.binding,e=this.buffer,t=this.valueSize,r=t*this._origIndex;n.getValue(e,r);for(let s=t,i=r;s!==i;++s)e[s]=e[r+s%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const n=this.valueSize*3;this.binding.setValue(this.buffer,n)},_setAdditiveIdentityNumeric:function(){const n=this._addIndex*this.valueSize,e=n+this.valueSize;for(let t=n;t<e;t++)this.buffer[t]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]},_select:function(n,e,t,r,s){if(r>=.5)for(let i=0;i!==s;++i)n[e+i]=n[t+i]},_slerp:function(n,e,t,r){lo.slerpFlat(n,e,n,e,n,t,r)},_slerpAdditive:function(n,e,t,r,s){const i=this._workIndex*s;lo.multiplyQuaternionsFlat(n,i,n,e,n,t),lo.slerpFlat(n,e,n,e,n,i,r)},_lerp:function(n,e,t,r,s){const i=1-r;for(let o=0;o!==s;++o){const a=e+o;n[a]=n[a]*i+n[t+o]*r}},_lerpAdditive:function(n,e,t,r,s){for(let i=0;i!==s;++i){const o=e+i;n[o]=n[o]+n[t+i]*r}}});const yV="\\[\\]\\.:\\/",b0t=new RegExp("["+yV+"]","g"),bV="[^"+yV+"]",v0t="[^"+yV.replace("\\.","")+"]",w0t=/((?:WC+[\/:])*)/.source.replace("WC",bV),x0t=/(WCOD+)?/.source.replace("WCOD",v0t),S0t=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",bV),_0t=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",bV),C0t=new RegExp("^"+w0t+x0t+S0t+_0t+"$"),k0t=["material","materials","bones"];function ble(n,e,t){const r=t||qo.parseTrackName(e);this._targetGroup=n,this._bindings=n.subscribe_(e,r)}Object.assign(ble.prototype,{getValue:function(n,e){this.bind();const t=this._targetGroup.nCachedObjects_,r=this._bindings[t];r!==void 0&&r.getValue(n,e)},setValue:function(n,e){const t=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=t.length;r!==s;++r)t[r].setValue(n,e)},bind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()},unbind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}});function qo(n,e,t){this.path=e,this.parsedPath=t||qo.parseTrackName(e),this.node=qo.findNode(n,this.parsedPath.nodeName)||n,this.rootNode=n}Object.assign(qo,{Composite:ble,create:function(n,e,t){return n&&n.isAnimationObjectGroup?new qo.Composite(n,e,t):new qo(n,e,t)},sanitizeNodeName:function(n){return n.replace(/\s/g,"_").replace(b0t,"")},parseTrackName:function(n){const e=C0t.exec(n);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=t.nodeName&&t.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=t.nodeName.substring(r+1);k0t.indexOf(s)!==-1&&(t.nodeName=t.nodeName.substring(0,r),t.objectName=s)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t},findNode:function(n,e){if(!e||e===""||e==="."||e===-1||e===n.name||e===n.uuid)return n;if(n.skeleton){const t=n.skeleton.getBoneByName(e);if(t!==void 0)return t}if(n.children){const t=function(s){for(let i=0;i<s.length;i++){const o=s[i];if(o.name===e||o.uuid===e)return o;const a=t(o.children);if(a)return a}return null},r=t(n.children);if(r)return r}return null}});Object.assign(qo.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)e[t++]=r[s]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++]},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let n=this.node;const e=this.parsedPath,t=e.objectName,r=e.propertyName;let s=e.propertyIndex;if(n||(n=qo.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=n),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(t){let l=e.objectIndex;switch(t){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}n=n.skeleton.bones;for(let c=0;c<n.length;c++)if(n[c].name===l){l=c;break}break;default:if(n[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[t]}if(l!==void 0){if(n[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[l]}}const i=n[r];if(i===void 0){const l=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+r+" but it wasn't found.",n);return}let o=this.Versioning.None;this.targetObject=n,n.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:n.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(n.geometry.isBufferGeometry){if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}n.morphTargetDictionary[s]!==void 0&&(s=n.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=s}else i.fromArray!==void 0&&i.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(a=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=r;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(qo.prototype,{_getValue_unbound:qo.prototype.getValue,_setValue_unbound:qo.prototype.setValue});function vle(){this.uuid=kn.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const n={};this._indicesByUUID=n;for(let t=0,r=arguments.length;t!==r;++t)n[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}Object.assign(vle.prototype,{isAnimationObjectGroup:!0,add:function(){const n=this._objects,e=this._indicesByUUID,t=this._paths,r=this._parsedPaths,s=this._bindings,i=s.length;let o,a=n.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const h=arguments[c],f=h.uuid;let d=e[f];if(d===void 0){d=a++,e[f]=d,n.push(h);for(let p=0,m=i;p!==m;++p)s[p].push(new qo(h,t[p],r[p]))}else if(d<l){o=n[d];const p=--l,m=n[p];e[m.uuid]=d,n[d]=m,e[f]=p,n[p]=h;for(let g=0,y=i;g!==y;++g){const b=s[g],x=b[p];let w=b[d];b[d]=x,w===void 0&&(w=new qo(h,t[g],r[g])),b[p]=w}}else n[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let s=this.nCachedObjects_;for(let i=0,o=arguments.length;i!==o;++i){const a=arguments[i],l=a.uuid,c=e[l];if(c!==void 0&&c>=s){const u=s++,h=n[u];e[h.uuid]=c,n[c]=h,e[l]=u,n[u]=a;for(let f=0,d=r;f!==d;++f){const p=t[f],m=p[u],g=p[c];p[c]=m,p[u]=g}}}this.nCachedObjects_=s},uncache:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let s=this.nCachedObjects_,i=n.length;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=e[c];if(u!==void 0)if(delete e[c],u<s){const h=--s,f=n[h],d=--i,p=n[d];e[f.uuid]=u,n[u]=f,e[p.uuid]=h,n[h]=p,n.pop();for(let m=0,g=r;m!==g;++m){const y=t[m],b=y[h],x=y[d];y[u]=b,y[h]=x,y.pop()}}else{const h=--i,f=n[h];h>0&&(e[f.uuid]=u),n[u]=f,n.pop();for(let d=0,p=r;d!==p;++d){const m=t[d];m[u]=m[h],m.pop()}}}this.nCachedObjects_=s},subscribe_:function(n,e){const t=this._bindingsIndicesByPath;let r=t[n];const s=this._bindings;if(r!==void 0)return s[r];const i=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,u=new Array(l);r=s.length,t[n]=r,i.push(n),o.push(e),s.push(u);for(let h=c,f=a.length;h!==f;++h){const d=a[h];u[h]=new qo(d,n,e)}return u},unsubscribe_:function(n){const e=this._bindingsIndicesByPath,t=e[n];if(t!==void 0){const r=this._paths,s=this._parsedPaths,i=this._bindings,o=i.length-1,a=i[o],l=n[o];e[l]=t,i[t]=a,i.pop(),s[t]=s[o],s.pop(),r[t]=r[o],r.pop()}}});class T0t{constructor(e,t,r=null,s=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=s;const i=t.tracks,o=i.length,a=new Array(o),l={endingStart:Bm,endingEnd:Bm};for(let c=0;c!==o;++c){const u=i[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Bae,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){const s=this._clip.duration,i=e._clip.duration,o=i/s,a=s/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,r){return e.crossFadeFrom(this,t,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,r){const s=this._mixer,i=s.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=s._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=i,l[1]=i+r,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,r,s){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const l=(e-i)*r;if(l<0||r===0)return;this._startTime=null,t=r*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case eV:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case E$:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(s,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const r=this._weightInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,r=this.loop;let s=this.time+e,i=this._loopCount;const o=r===Vae;if(e===0)return i===-1?s:o&&(i&1)===1?t-s:s;if(r===zae){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(s>=t)s=t;else if(s<0)s=0;else{this.time=s;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),s>=t||s<0){const a=Math.floor(s/t);s-=t*a,i+=Math.abs(a);const l=this.repetitions-i;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=e>0?t:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=s;if(o&&(i&1)===1)return t-s}return s}_setEndings(e,t,r){const s=this._interpolantSettings;r?(s.endingStart=Vm,s.endingEnd=Vm):(e?s.endingStart=this.zeroSlopeAtStart?Vm:Bm:s.endingStart=o_,t?s.endingEnd=this.zeroSlopeAtEnd?Vm:Bm:s.endingEnd=o_)}_scheduleFading(e,t,r){const s=this._mixer,i=s.time;let o=this._weightInterpolant;o===null&&(o=s._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,l[0]=t,a[1]=i+e,l[1]=r,this}}function ZF(n){this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}ZF.prototype=Object.assign(Object.create(Uu.prototype),{constructor:ZF,_bindAction:function(n,e){const t=n._localRoot||this._root,r=n._clip.tracks,s=r.length,i=n._propertyBindings,o=n._interpolants,a=t.uuid,l=this._bindingsByRootAndName;let c=l[a];c===void 0&&(c={},l[a]=c);for(let u=0;u!==s;++u){const h=r[u],f=h.name;let d=c[f];if(d!==void 0)i[u]=d;else{if(d=i[u],d!==void 0){d._cacheIndex===null&&(++d.referenceCount,this._addInactiveBinding(d,a,f));continue}const p=e&&e._propertyBindings[u].binding.parsedPath;d=new gV(qo.create(t,f,p),h.ValueTypeName,h.getValueSize()),++d.referenceCount,this._addInactiveBinding(d,a,f),i[u]=d}o[u].resultBuffer=d.buffer}},_activateAction:function(n){if(!this._isActiveAction(n)){if(n._cacheIndex===null){const t=(n._localRoot||this._root).uuid,r=n._clip.uuid,s=this._actionsByClip[r];this._bindAction(n,s&&s.knownActions[0]),this._addInactiveAction(n,r,t)}const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(n)}},_deactivateAction:function(n){if(this._isActiveAction(n)){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(n)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}},_isActiveAction:function(n){const e=n._cacheIndex;return e!==null&&e<this._nActiveActions},_addInactiveAction:function(n,e,t){const r=this._actions,s=this._actionsByClip;let i=s[e];if(i===void 0)i={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,s[e]=i;else{const o=i.knownActions;n._byClipCacheIndex=o.length,o.push(n)}n._cacheIndex=r.length,r.push(n),i.actionByRoot[t]=n},_removeInactiveAction:function(n){const e=this._actions,t=e[e.length-1],r=n._cacheIndex;t._cacheIndex=r,e[r]=t,e.pop(),n._cacheIndex=null;const s=n._clip.uuid,i=this._actionsByClip,o=i[s],a=o.knownActions,l=a[a.length-1],c=n._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),n._byClipCacheIndex=null;const u=o.actionByRoot,h=(n._localRoot||this._root).uuid;delete u[h],a.length===0&&delete i[s],this._removeInactiveBindingsForAction(n)},_removeInactiveBindingsForAction:function(n){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];--s.referenceCount===0&&this._removeInactiveBinding(s)}},_lendAction:function(n){const e=this._actions,t=n._cacheIndex,r=this._nActiveActions++,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_takeBackAction:function(n){const e=this._actions,t=n._cacheIndex,r=--this._nActiveActions,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_addInactiveBinding:function(n,e,t){const r=this._bindingsByRootAndName,s=this._bindings;let i=r[e];i===void 0&&(i={},r[e]=i),i[t]=n,n._cacheIndex=s.length,s.push(n)},_removeInactiveBinding:function(n){const e=this._bindings,t=n.binding,r=t.rootNode.uuid,s=t.path,i=this._bindingsByRootAndName,o=i[r],a=e[e.length-1],l=n._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[s],Object.keys(o).length===0&&delete i[r]},_lendBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=this._nActiveBindings++,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_takeBackBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=--this._nActiveBindings,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_lendControlInterpolant:function(){const n=this._controlInterpolants,e=this._nActiveControlInterpolants++;let t=n[e];return t===void 0&&(t=new I_(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),t.__cacheIndex=e,n[e]=t),t},_takeBackControlInterpolant:function(n){const e=this._controlInterpolants,t=n.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];n.__cacheIndex=r,e[r]=n,s.__cacheIndex=t,e[t]=s},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(n,e,t){const r=e||this._root,s=r.uuid;let i=typeof n=="string"?_l.findByName(r,n):n;const o=i!==null?i.uuid:n,a=this._actionsByClip[o];let l=null;if(t===void 0&&(i!==null?t=i.blendMode:t=E$),a!==void 0){const u=a.actionByRoot[s];if(u!==void 0&&u.blendMode===t)return u;l=a.knownActions[0],i===null&&(i=l._clip)}if(i===null)return null;const c=new T0t(this,i,e,t);return this._bindAction(c,l),this._addInactiveAction(c,o,s),c},existingAction:function(n,e){const t=e||this._root,r=t.uuid,s=typeof n=="string"?_l.findByName(t,n):n,i=s?s.uuid:n,o=this._actionsByClip[i];return o!==void 0&&o.actionByRoot[r]||null},stopAllAction:function(){const n=this._actions,e=this._nActiveActions;for(let t=e-1;t>=0;--t)n[t].stop();return this},update:function(n){n*=this.timeScale;const e=this._actions,t=this._nActiveActions,r=this.time+=n,s=Math.sign(n),i=this._accuIndex^=1;for(let l=0;l!==t;++l)e[l]._update(r,n,s,i);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(i);return this},setTime:function(n){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)},getRoot:function(){return this._root},uncacheClip:function(n){const e=this._actions,t=n.uuid,r=this._actionsByClip,s=r[t];if(s!==void 0){const i=s.knownActions;for(let o=0,a=i.length;o!==a;++o){const l=i[o];this._deactivateAction(l);const c=l._cacheIndex,u=e[e.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,u._cacheIndex=c,e[c]=u,e.pop(),this._removeInactiveBindingsForAction(l)}delete r[t]}},uncacheRoot:function(n){const e=n.uuid,t=this._actionsByClip;for(const i in t){const o=t[i].actionByRoot,a=o[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const i in s){const o=s[i];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(n,e){const t=this.existingAction(n,e);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}});class R${constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new R$(this.value.clone===void 0?this.value:this.value.clone())}}function JF(n,e,t){Tl.call(this,n,e),this.meshPerAttribute=t||1}JF.prototype=Object.assign(Object.create(Tl.prototype),{constructor:JF,isInstancedInterleavedBuffer:!0,copy:function(n){return Tl.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},clone:function(n){const e=Tl.prototype.clone.call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(n){const e=Tl.prototype.toJSON.call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}});function vV(n,e,t,r,s){this.buffer=n,this.type=e,this.itemSize=t,this.elementSize=r,this.count=s,this.version=0}Object.defineProperty(vV.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(vV.prototype,{isGLBufferAttribute:!0,setBuffer:function(n){return this.buffer=n,this},setType:function(n,e){return this.type=n,this.elementSize=e,this},setItemSize:function(n){return this.itemSize=n,this},setCount:function(n){return this.count=n,this}});function wV(n,e,t,r){this.ray=new rx(n,e),this.near=t||0,this.far=r||1/0,this.camera=null,this.layers=new sV,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function Q8(n,e){return n.distance-e.distance}function QF(n,e,t,r){if(n.layers.test(e.layers)&&n.raycast(e,t),r===!0){const s=n.children;for(let i=0,o=s.length;i<o;i++)QF(s[i],e,t,!0)}}Object.assign(wV.prototype,{set:function(n,e){this.ray.set(n,e)},setFromCamera:function(n,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(n,e,t){const r=t||[];return QF(n,this,r,e),r.sort(Q8),r},intersectObjects:function(n,e,t){const r=t||[];if(Array.isArray(n)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),r;for(let s=0,i=n.length;s<i;s++)QF(n[s],this,r,e);return r.sort(Q8),r}});class eL{constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(kn.clamp(t/this.radius,-1,1))),this}}class E0t{constructor(e,t,r){return this.radius=e!==void 0?e:1,this.theta=t!==void 0?t:0,this.y=r!==void 0?r:0,this}set(e,t,r){return this.radius=e,this.theta=t,this.y=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=t,this}}const eq=new rt;class wle{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=e!==void 0?e:new rt(1/0,1/0),this.max=t!==void 0?t:new rt(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=eq.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new rt),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new rt),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new rt),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new rt),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return eq.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const tq=new J,hE=new J;class xle{constructor(e,t){this.start=e!==void 0?e:new J,this.end=t!==void 0?t:new J}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new J),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new J),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new J),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){tq.subVectors(e,this.start),hE.subVectors(this.end,this.start);const r=hE.dot(hE);let i=hE.dot(tq)/r;return t&&(i=kn.clamp(i,0,1)),i}closestPointToPoint(e,t,r){const s=this.closestPointToPointParameter(e,t);return r===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),r=new J),this.delta(r).multiplyScalar(s).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function N_(n){rn.call(this),this.material=n,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}N_.prototype=Object.create(rn.prototype);N_.prototype.constructor=N_;N_.prototype.isImmediateRenderObject=!0;const nq=new J;class I0t extends rn{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const r=new cn,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;s.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}r.setAttribute("position",new Xt(s,3));const i=new Is({fog:!1,toneMapped:!1});this.cone=new Ca(r,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),nq.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(nq),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const vd=new J,fE=new Zn,NP=new Zn;class Sle extends Ca{constructor(e){const t=_le(e),r=new cn,s=[],i=[],o=new jt(0,0,1),a=new jt(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}r.setAttribute("position",new Xt(s,3)),r.setAttribute("color",new Xt(i,3));const l=new Is({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,r=this.geometry,s=r.getAttribute("position");NP.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(fE.multiplyMatrices(NP,a.matrixWorld),vd.setFromMatrixPosition(fE),s.setXYZ(o,vd.x,vd.y,vd.z),fE.multiplyMatrices(NP,a.parent.matrixWorld),vd.setFromMatrixPosition(fE),s.setXYZ(o+1,vd.x,vd.y,vd.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function _le(n){const e=[];n&&n.isBone&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,_le(n.children[t]));return e}class A0t extends hs{constructor(e,t,r){const s=new E_(t,4,2),i=new Ol({wireframe:!0,fog:!1,toneMapped:!1});super(s,i),this.light=e,this.light.updateMatrixWorld(),this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const M0t=new J,rq=new jt,sq=new jt;class N0t extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r;const s=new k_(t);s.rotateY(Math.PI*.5),this.material=new Ol({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=s.getAttribute("position"),o=new Float32Array(i.count*3);s.setAttribute("color",new xn(o,3)),this.add(new hs(s,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");rq.copy(this.light.color),sq.copy(this.light.groundColor);for(let r=0,s=t.count;r<s;r++){const i=r<s/2?rq:sq;t.setXYZ(r,i.r,i.g,i.b)}t.needsUpdate=!0}e.lookAt(M0t.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Cle extends Ca{constructor(e=10,t=10,r=4473924,s=8947848){r=new jt(r),s=new jt(s);const i=t/2,o=e/t,a=e/2,l=[],c=[];for(let f=0,d=0,p=-a;f<=t;f++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const m=f===i?r:s;m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3}const u=new cn;u.setAttribute("position",new Xt(l,3)),u.setAttribute("color",new Xt(c,3));const h=new Is({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}class $0t extends Ca{constructor(e=10,t=16,r=8,s=64,i=4473924,o=8947848){i=new jt(i),o=new jt(o);const a=[],l=[];for(let h=0;h<=t;h++){const f=h/t*(Math.PI*2),d=Math.sin(f)*e,p=Math.cos(f)*e;a.push(0,0,0),a.push(d,0,p);const m=h&1?i:o;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=r;h++){const f=h&1?i:o,d=e-e/r*h;for(let p=0;p<s;p++){let m=p/s*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d;a.push(g,0,y),l.push(f.r,f.g,f.b),m=(p+1)/s*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d,a.push(g,0,y),l.push(f.r,f.g,f.b)}}const c=new cn;c.setAttribute("position",new Xt(a,3)),c.setAttribute("color",new Xt(l,3));const u=new Is({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}}const iq=new J,dE=new J,oq=new J;class R0t extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,t===void 0&&(t=1);let s=new cn;s.setAttribute("position",new Xt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new Is({fog:!1,toneMapped:!1});this.lightPlane=new $c(s,i),this.add(this.lightPlane),s=new cn,s.setAttribute("position",new Xt([0,0,0,0,0,1],3)),this.targetLine=new $c(s,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){iq.setFromMatrixPosition(this.light.matrixWorld),dE.setFromMatrixPosition(this.light.target.matrixWorld),oq.subVectors(dE,iq),this.lightPlane.lookAt(dE),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(dE),this.targetLine.scale.z=oq.length()}}const pE=new J,Gs=new Eh;class P0t extends Ca{constructor(e){const t=new cn,r=new Is({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],i=[],o={},a=new jt(16755200),l=new jt(16711680),c=new jt(43775),u=new jt(16777215),h=new jt(3355443);f("n1","n2",a),f("n2","n4",a),f("n4","n3",a),f("n3","n1",a),f("f1","f2",a),f("f2","f4",a),f("f4","f3",a),f("f3","f1",a),f("n1","f1",a),f("n2","f2",a),f("n3","f3",a),f("n4","f4",a),f("p","n1",l),f("p","n2",l),f("p","n3",l),f("p","n4",l),f("u1","u2",c),f("u2","u3",c),f("u3","u1",c),f("c","t",u),f("p","c",h),f("cn1","cn2",h),f("cn3","cn4",h),f("cf1","cf2",h),f("cf3","cf4",h);function f(p,m,g){d(p,g),d(m,g)}function d(p,m){s.push(0,0,0),i.push(m.r,m.g,m.b),o[p]===void 0&&(o[p]=[]),o[p].push(s.length/3-1)}t.setAttribute("position",new Xt(s,3)),t.setAttribute("color",new Xt(i,3)),super(t,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const e=this.geometry,t=this.pointMap,r=1,s=1;Gs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),ri("c",t,e,Gs,0,0,-1),ri("t",t,e,Gs,0,0,1),ri("n1",t,e,Gs,-r,-s,-1),ri("n2",t,e,Gs,r,-s,-1),ri("n3",t,e,Gs,-r,s,-1),ri("n4",t,e,Gs,r,s,-1),ri("f1",t,e,Gs,-r,-s,1),ri("f2",t,e,Gs,r,-s,1),ri("f3",t,e,Gs,-r,s,1),ri("f4",t,e,Gs,r,s,1),ri("u1",t,e,Gs,r*.7,s*1.1,-1),ri("u2",t,e,Gs,-r*.7,s*1.1,-1),ri("u3",t,e,Gs,0,s*2,-1),ri("cf1",t,e,Gs,-r,0,1),ri("cf2",t,e,Gs,r,0,1),ri("cf3",t,e,Gs,0,-s,1),ri("cf4",t,e,Gs,0,s,1),ri("cn1",t,e,Gs,-r,0,-1),ri("cn2",t,e,Gs,r,0,-1),ri("cn3",t,e,Gs,0,-s,-1),ri("cn4",t,e,Gs,0,s,-1),e.getAttribute("position").needsUpdate=!0}}function ri(n,e,t,r,s,i,o){pE.set(s,i,o).unproject(r);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],pE.x,pE.y,pE.z)}}const mE=new Kf;class kle extends Ca{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(8*3),i=new cn;i.setIndex(new xn(r,1)),i.setAttribute("position",new xn(s,3)),super(i,new Is({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&mE.setFromObject(this.object),mE.isEmpty())return;const t=mE.min,r=mE.max,s=this.geometry.attributes.position,i=s.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=t.x,i[4]=r.y,i[5]=r.z,i[6]=t.x,i[7]=t.y,i[8]=r.z,i[9]=r.x,i[10]=t.y,i[11]=r.z,i[12]=r.x,i[13]=r.y,i[14]=t.z,i[15]=t.x,i[16]=r.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=r.x,i[22]=t.y,i[23]=t.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return Ca.prototype.copy.call(this,e),this.object=e.object,this}}class D0t extends Ca{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],i=new cn;i.setIndex(new xn(r,1)),i.setAttribute("position",new Xt(s,3)),super(i,new Is({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class O0t extends $c{constructor(e,t=1,r=16776960){const s=r,i=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],o=new cn;o.setAttribute("position",new Xt(i,3)),o.computeBoundingSphere(),super(o,new Is({color:s,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new cn;l.setAttribute("position",new Xt(a,3)),l.computeBoundingSphere(),this.add(new hs(l,new Ol({color:s,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?pi:Qw,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const aq=new J;let gE,$P;class F0t extends rn{constructor(e,t,r,s,i,o){super(),this.type="ArrowHelper",e===void 0&&(e=new J(0,0,1)),t===void 0&&(t=new J(0,0,0)),r===void 0&&(r=1),s===void 0&&(s=16776960),i===void 0&&(i=.2*r),o===void 0&&(o=.2*i),gE===void 0&&(gE=new cn,gE.setAttribute("position",new Xt([0,0,0,0,1,0],3)),$P=new pv(0,.5,1,5,1),$P.translate(0,-.5,0)),this.position.copy(t),this.line=new $c(gE,new Is({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new hs($P,new Ol({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,i,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{aq.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(aq,t)}}setLength(e,t,r){t===void 0&&(t=.2*e),r===void 0&&(r=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(r,t,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class Tle extends Ca{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new cn;s.setAttribute("position",new Xt(t,3)),s.setAttribute("color",new Xt(r,3));const i=new Is({vertexColors:!0,toneMapped:!1});super(s,i),this.type="AxesHelper"}}const Ele=new Float32Array(1),L0t=new Int32Array(Ele.buffer),z0t={toHalfFloat:function(n){Ele[0]=n;const e=L0t[0];let t=e>>16&32768,r=e>>12&2047;const s=e>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?0:1)&&e&8388607,t):s<113?(r|=2048,t|=(r>>114-s)+(r>>113-s&1),t):(t|=s-112<<10|r>>1,t+=r&1,t)}},Pb=4,Yd=8,ih=Math.pow(2,Yd),Ile=[.125,.215,.35,.446,.526,.582],Ale=Yd-Pb+1+Ile.length,nb=20,dh={[Sa]:0,[BC]:1,[A$]:2,[tV]:3,[nV]:4,[rV]:5,[I$]:6},xm=new Ol({side:pi,depthWrite:!1,depthTest:!1}),B0t=new hs(new wg,xm),RP=new vv,{_lodPlanes:a1,_sizeLods:lq,_sigmas:yE}=W0t(),cq=new jt;let PP=null;const Sm=(1+Math.sqrt(5))/2,rb=1/Sm,uq=[new J(1,1,1),new J(-1,1,1),new J(1,1,-1),new J(-1,1,-1),new J(0,Sm,rb),new J(0,Sm,-rb),new J(rb,0,Sm),new J(-rb,0,Sm),new J(Sm,rb,0),new J(-Sm,rb,0)];function hq(n){const e=Math.max(n.r,n.g,n.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return n.multiplyScalar(Math.pow(2,-t)),(t+128)/255}class V0t{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=G0t(nb),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,s=100){PP=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(e,r,s,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=pq(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=dq(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<a1.length;e++)a1[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(PP),e.scissorTest=!1,bE(e,0,0,e.width,e.height)}_fromTexture(e){PP=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Bi,minFilter:Bi,generateMipmaps:!1,type:nx,format:nae,encoding:U0t(e)?e.encoding:A$,depthBuffer:!1},r=fq(t);return r.depthBuffer=!e,this._pingPongRenderTarget=fq(t),r}_compileMaterial(e){const t=new hs(a1[0],e);this._renderer.compile(t,RP)}_sceneToCubeUV(e,t,r,s){const a=new xi(90,1,t,r),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,f=u.outputEncoding,d=u.toneMapping;u.getClearColor(cq),u.toneMapping=Ym,u.outputEncoding=Sa,u.autoClear=!1;let p=!1;const m=e.background;if(m){if(m.isColor){xm.color.copy(m).convertSRGBToLinear(),e.background=null;const g=hq(xm.color);xm.opacity=g,p=!0}}else{xm.color.copy(cq).convertSRGBToLinear();const g=hq(xm.color);xm.opacity=g,p=!0}for(let g=0;g<6;g++){const y=g%3;y==0?(a.up.set(0,l[g],0),a.lookAt(c[g],0,0)):y==1?(a.up.set(0,0,l[g]),a.lookAt(0,c[g],0)):(a.up.set(0,l[g],0),a.lookAt(0,0,c[g])),bE(s,y*ih,g>2?ih:0,ih,ih),u.setRenderTarget(s),p&&u.render(B0t,a),u.render(e,a)}u.toneMapping=d,u.outputEncoding=f,u.autoClear=h}_textureToCubeUV(e,t){const r=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=pq()):this._equirectShader==null&&(this._equirectShader=dq());const s=e.isCubeTexture?this._cubemapShader:this._equirectShader,i=new hs(a1[0],s),o=s.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=dh[e.encoding],o.outputEncoding.value=dh[t.texture.encoding],bE(t,0,0,3*ih,2*ih),r.setRenderTarget(t),r.render(i,RP)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;for(let s=1;s<Ale;s++){const i=Math.sqrt(yE[s]*yE[s]-yE[s-1]*yE[s-1]),o=uq[(s-1)%uq.length];this._blur(e,s-1,s,i,o)}t.autoClear=r}_blur(e,t,r,s,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,s,"latitudinal",i),this._halfBlur(o,e,r,r,s,"longitudinal",i)}_halfBlur(e,t,r,s,i,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new hs(a1[s],c),f=c.uniforms,d=lq[r]-1,p=isFinite(i)?Math.PI/(2*d):2*Math.PI/(2*nb-1),m=i/p,g=isFinite(i)?1+Math.floor(u*m):nb;g>nb&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${nb}`);const y=[];let b=0;for(let C=0;C<nb;++C){const k=C/m,A=Math.exp(-k*k/2);y.push(A),C==0?b+=A:C<g&&(b+=2*A)}for(let C=0;C<y.length;C++)y[C]=y[C]/b;f.envMap.value=e.texture,f.samples.value=g,f.weights.value=y,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a),f.dTheta.value=p,f.mipInt.value=Yd-r,f.inputEncoding.value=dh[e.texture.encoding],f.outputEncoding.value=dh[e.texture.encoding];const x=lq[s],w=3*Math.max(0,ih-2*x),_=(s===0?0:2*ih)+2*x*(s>Yd-Pb?s-Yd+Pb:0);bE(t,w,_,3*x,2*x),l.setRenderTarget(t),l.render(h,RP)}}function U0t(n){return n===void 0||n.type!==nx?!1:n.encoding===Sa||n.encoding===BC||n.encoding===I$}function W0t(){const n=[],e=[],t=[];let r=Yd;for(let s=0;s<Ale;s++){const i=Math.pow(2,r);e.push(i);let o=1/i;s>Yd-Pb?o=Ile[s-Yd+Pb-1]:s==0&&(o=0),t.push(o);const a=1/(i-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,f=6,d=3,p=2,m=1,g=new Float32Array(d*f*h),y=new Float32Array(p*f*h),b=new Float32Array(m*f*h);for(let w=0;w<h;w++){const _=w%3*2/3-1,C=w>2?0:-1,k=[_,C,0,_+2/3,C,0,_+2/3,C+1,0,_,C,0,_+2/3,C+1,0,_,C+1,0];g.set(k,d*f*w),y.set(u,p*f*w);const A=[w,w,w,w,w,w];b.set(A,m*f*w)}const x=new cn;x.setAttribute("position",new xn(g,d)),x.setAttribute("uv",new xn(y,p)),x.setAttribute("faceIndex",new xn(b,m)),n.push(x),r>Pb&&r--}return{_lodPlanes:n,_sizeLods:e,_sigmas:t}}function fq(n){const e=new qd(3*ih,3*ih,n);return e.texture.mapping=ex,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function bE(n,e,t,r,s){n.viewport.set(e,t,r,s),n.scissor.set(e,t,r,s)}function G0t(n){const e=new Float32Array(n),t=new J(0,1,0);return new Lf({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:dh[Sa]},outputEncoding:{value:dh[Sa]}},vertexShader:xV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${SV()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Nf,depthTest:!1,depthWrite:!1})}function dq(){const n=new rt(1,1);return new Lf({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:dh[Sa]},outputEncoding:{value:dh[Sa]}},vertexShader:xV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${SV()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Nf,depthTest:!1,depthWrite:!1})}function pq(){return new Lf({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:dh[Sa]},outputEncoding:{value:dh[Sa]}},vertexShader:xV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${SV()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Nf,depthTest:!1,depthWrite:!1})}function xV(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function SV(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function H0t(n,e,t,r,s,i,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new iV(n,e,t,s,i,o)}const j0t=0,q0t=1,X0t=0,K0t=1,Y0t=2;function Z0t(n){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),n}function J0t(n=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),n.isMultiMaterial=!0,n.materials=n,n.clone=function(){return n.slice()},n}function Q0t(n,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new fv(n,e)}function ebt(n){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new m_(n)}function tbt(n,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new fv(n,e)}function nbt(n){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Iu(n)}function rbt(n){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Iu(n)}function sbt(n){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Iu(n)}function ibt(n,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new J(n,e,t)}function obt(n,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new xn(n,e).setUsage(yg)}function abt(n,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new a_(n,e)}function lbt(n,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new l_(n,e)}function cbt(n,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new c_(n,e)}function ubt(n,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new u_(n,e)}function hbt(n,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new bg(n,e)}function fbt(n,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new h_(n,e)}function dbt(n,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new vg(n,e)}function pbt(n,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Xt(n,e)}function mbt(n,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new d_(n,e)}on.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(on.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};Object.assign(cu.prototype,{fromPoints:function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)}});function Mle(n){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Zo.call(this,n),this.type="catmullrom",this.closed=!0}Mle.prototype=Object.create(Zo.prototype);function Nle(n){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Zo.call(this,n),this.type="catmullrom"}Nle.prototype=Object.create(Zo.prototype);function _V(n){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),Zo.call(this,n),this.type="catmullrom"}_V.prototype=Object.create(Zo.prototype);Object.assign(_V.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});function gbt(n){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Tle(n)}function ybt(n,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new kle(n,e)}function bbt(n,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Ca(new lV(n.geometry),new Is({color:e!==void 0?e:16777215}))}Cle.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Sle.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function vbt(n,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Ca(new cV(n.geometry),new Is({color:e!==void 0?e:16777215}))}Object.assign(zr.prototype,{extractUrlBase:function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),fV.extractUrlBase(n)}});zr.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function wbt(n){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Rc(n)}function xbt(n){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new HA(n)}Object.assign(wle.prototype,{center:function(n){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},size:function(n){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(Kf.prototype,{center:function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionSphere:function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)},size:function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(Op.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}});UC.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};xle.prototype.center=function(n){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Object.assign(kn,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(n){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),kn.floorPowerOfTwo(n)},nextPowerOfTwo:function(n){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),kn.ceilPowerOfTwo(n)}});Object.assign(kl.prototype,{flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},multiplyVector3:function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});Object.assign(Zn.prototype,{extractPosition:function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)},flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new J().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector4:function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)},crossVector:function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(n,e,t,r,s,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,r,t,s,i)},getInverse:function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});ch.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Object.assign(lo.prototype,{multiplyVector3:function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}});Object.assign(rx.prototype,{isIntersectionBox:function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionPlane:function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)},isIntersectionSphere:function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)}});Object.assign(Go.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)},midpoint:function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)},normal:function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)},plane:function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)}});Object.assign(Go,{barycoordFromPoint:function(n,e,t,r,s){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Go.getBarycoord(n,e,t,r,s)},normal:function(n,e,t,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Go.getNormal(n,e,t,r)}});Object.assign(Kd.prototype,{extractAllPoints:function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)},extrude:function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Sg(this,n)},makeGeometry:function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new T_(this,n)}});Object.assign(rt.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(J.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)},getScaleFromMatrix:function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)},getColumnFromMatrix:function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)},applyProjection:function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)},fromAttribute:function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Hr.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(rn.prototype,{getChildByName:function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(rn.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.assign(hs.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}});Object.defineProperties(hs.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),Uae},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Object.defineProperties(g_.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}});Object.defineProperty(v_.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});y_.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(on.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(n){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=n}});xi.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(fs.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(xn.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===yg},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(yg)}}});Object.assign(xn.prototype,{setDynamic:function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?yg:VC),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(cn.prototype,{addIndex:function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)},addAttribute:function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new xn(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)},addDrawCall:function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)},applyMatrix:function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(cn.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(M_.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(n){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=n}}});Object.defineProperties(wV.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(n){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=n}}});Object.defineProperties(Tl.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===yg},set:function(n){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(n)}}});Object.assign(Tl.prototype,{setDynamic:function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?yg:VC),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(Sg.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}});Object.assign(aV.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}});Object.defineProperties(R$.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}});Object.defineProperties(Sn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new jt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Y4}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}}});Object.defineProperties(vp.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(bp.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(n){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=n}}});Object.defineProperties(_a.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Object.assign(WC.prototype,{clearTarget:function(n,e,t,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,r)},animate:function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}});Object.defineProperties(WC.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?BC:Sa}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(ile.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function Sbt(n,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new oV(n,t)}Object.defineProperties(qd.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});Object.defineProperties(mV.prototype,{load:{value:function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new nM().load(n,function(r){e.setBuffer(r)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}});yle.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};xg.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};xg.prototype.clear=function(n,e,t,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,r)};const _bt={merge:function(n,e,t){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");let r;e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),r=e.matrix,e=e.geometry),n.merge(e,r,t)},center:function(n){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),n.center()}};Zy.crossOrigin=void 0;Zy.loadTexture=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const s=new jA;s.setCrossOrigin(this.crossOrigin);const i=s.load(n,t,void 0,r);return e&&(i.mapping=e),i};Zy.loadTextureCube=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const s=new GA;s.setCrossOrigin(this.crossOrigin);const i=s.load(n,t,void 0,r);return e&&(i.mapping=e),i};Zy.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Zy.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function Cbt(){console.error("THREE.CanvasRenderer has been removed")}function kbt(){console.error("THREE.JSONLoader has been removed.")}const Tbt={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function Ebt(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:X4}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=X4);const Ibt=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:Hoe,AddEquation:Rm,AddOperation:Voe,AdditiveAnimationBlendMode:eV,AdditiveBlending:vF,AlphaFormat:Qoe,AlwaysDepth:Poe,AlwaysStencilFunc:qae,AmbientLight:ZA,AmbientLightProbe:YF,AnimationClip:_l,AnimationLoader:VF,AnimationMixer:ZF,AnimationObjectGroup:vle,AnimationUtils:ps,ArcCurve:bv,ArrayCamera:CA,ArrowHelper:F0t,Audio:mV,AudioAnalyser:yle,AudioContext:pV,AudioListener:m0t,AudioLoader:nM,AxesHelper:Tle,AxisHelper:gbt,BackSide:pi,BasicDepthPacking:Gae,BasicShadowMap:Uft,BinaryTextureLoader:xbt,Bone:b_,BooleanKeyframeTrack:BA,BoundingBoxHelper:ybt,Box2:wle,Box3:Kf,Box3Helper:D0t,BoxBufferGeometry:wg,BoxGeometry:wg,BoxHelper:kle,BufferAttribute:xn,BufferGeometry:cn,BufferGeometryLoader:tM,ByteType:qoe,Cache:Mg,Camera:Eh,CameraHelper:P0t,CanvasRenderer:Cbt,CanvasTexture:w_,CatmullRomCurve3:Zo,CineonToneMapping:Goe,CircleBufferGeometry:EA,CircleGeometry:EA,ClampToEdgeWrapping:fa,Clock:gle,ClosedSplineCurve3:Mle,Color:jt,ColorKeyframeTrack:VA,CompressedTexture:dv,CompressedTextureLoader:UF,ConeBufferGeometry:IA,ConeGeometry:IA,CubeCamera:xg,CubeReflectionMapping:FC,CubeRefractionMapping:LC,CubeTexture:Ih,CubeTextureLoader:GA,CubeUVReflectionMapping:ex,CubeUVRefractionMapping:zC,CubicBezierCurve:Au,CubicBezierCurve3:Mh,CubicInterpolant:LA,CullFaceBack:bF,CullFaceFront:voe,CullFaceFrontBack:Vft,CullFaceNone:boe,Curve:on,CurvePath:zd,CustomBlending:xoe,CustomToneMapping:joe,CylinderBufferGeometry:pv,CylinderGeometry:pv,Cylindrical:E0t,DataTexture:Ff,DataTexture2DArray:uv,DataTexture3D:hv,DataTextureLoader:HA,DataUtils:z0t,DecrementStencilOp:Qft,DecrementWrapStencilOp:tdt,DefaultLoadingManager:fle,DepthFormat:Zm,DepthStencilFormat:lv,DepthTexture:x_,DirectionalLight:YA,DirectionalLightHelper:R0t,DiscreteInterpolant:zA,DodecahedronBufferGeometry:AA,DodecahedronGeometry:AA,DoubleSide:DC,DstAlphaFactor:Ioe,DstColorFactor:Moe,DynamicBufferAttribute:obt,DynamicCopyUsage:mdt,DynamicDrawUsage:yg,DynamicReadUsage:fdt,EdgesGeometry:lV,EdgesHelper:bbt,EllipseCurve:Ll,EqualDepth:Ooe,EqualStencilFunc:idt,EquirectangularReflectionMapping:wA,EquirectangularRefractionMapping:xA,Euler:sx,EventDispatcher:Uu,ExtrudeBufferGeometry:Sg,ExtrudeGeometry:Sg,Face3:iV,Face4:H0t,FaceColors:K0t,FileLoader:Rc,FlatShading:Y4,Float16BufferAttribute:f_,Float32Attribute:pbt,Float32BufferAttribute:Xt,Float64Attribute:mbt,Float64BufferAttribute:d_,FloatType:Tf,Fog:N$,FogExp2:M$,Font:ple,FontLoader:XF,FrontSide:Qw,Frustum:UC,GLBufferAttribute:vV,GLSL1:ydt,GLSL3:PF,GammaEncoding:I$,GeometryUtils:_bt,GreaterDepth:Loe,GreaterEqualDepth:Foe,GreaterEqualStencilFunc:cdt,GreaterStencilFunc:adt,GridHelper:Cle,Group:Ld,HalfFloatType:s_,HemisphereLight:qA,HemisphereLightHelper:N0t,HemisphereLightProbe:KF,IcosahedronBufferGeometry:MA,IcosahedronGeometry:MA,ImageBitmapLoader:qF,ImageLoader:yv,ImageUtils:Zy,ImmediateRenderObject:N_,IncrementStencilOp:Jft,IncrementWrapStencilOp:edt,InstancedBufferAttribute:eM,InstancedBufferGeometry:M_,InstancedInterleavedBuffer:JF,InstancedMesh:kA,Int16Attribute:ubt,Int16BufferAttribute:u_,Int32Attribute:fbt,Int32BufferAttribute:h_,Int8Attribute:abt,Int8BufferAttribute:a_,IntType:Koe,InterleavedBuffer:Tl,InterleavedBufferAttribute:pp,Interpolant:Nl,InterpolateDiscrete:i_,InterpolateLinear:nS,InterpolateSmooth:QE,InvertStencilOp:ndt,JSONLoader:kbt,KeepStencilOp:eI,KeyframeTrack:xo,LOD:g_,LatheBufferGeometry:NA,LatheGeometry:NA,Layers:sV,LensFlare:Ebt,LessDepth:Doe,LessEqualDepth:vA,LessEqualStencilFunc:odt,LessStencilFunc:sdt,Light:fs,LightProbe:Cc,Line:$c,Line3:xle,LineBasicMaterial:Is,LineCurve:Xa,LineCurve3:Mu,LineDashedMaterial:Ag,LineLoop:TA,LinePieces:q0t,LineSegments:Ca,LineStrip:j0t,LinearEncoding:Sa,LinearFilter:ao,LinearInterpolant:I_,LinearMipMapLinearFilter:qft,LinearMipMapNearestFilter:jft,LinearMipmapLinearFilter:tx,LinearMipmapNearestFilter:Q4,LinearToneMapping:Uoe,Loader:zr,LoaderUtils:fV,LoadingManager:uV,LogLuvEncoding:Wae,LoopOnce:zae,LoopPingPong:Vae,LoopRepeat:Bae,LuminanceAlphaFormat:tae,LuminanceFormat:eae,MOUSE:Sf,Material:Sn,MaterialLoader:QA,Math:kn,MathUtils:kn,Matrix3:kl,Matrix4:Zn,MaxEquation:_F,Mesh:hs,MeshBasicMaterial:Ol,MeshDepthMaterial:fp,MeshDistanceMaterial:dp,MeshFaceMaterial:Z0t,MeshLambertMaterial:Eg,MeshMatcapMaterial:Ig,MeshNormalMaterial:Tg,MeshPhongMaterial:vp,MeshPhysicalMaterial:bp,MeshStandardMaterial:Ah,MeshToonMaterial:kg,MinEquation:SF,MirroredRepeatWrapping:n_,MixOperation:Boe,MultiMaterial:J0t,MultiplyBlending:xF,MultiplyOperation:OC,NearestFilter:Bi,NearestMipMapLinearFilter:Hft,NearestMipMapNearestFilter:Gft,NearestMipmapLinearFilter:_A,NearestMipmapNearestFilter:SA,NeverDepth:Roe,NeverStencilFunc:rdt,NoBlending:Nf,NoColors:X0t,NoToneMapping:Ym,NormalAnimationBlendMode:E$,NormalBlending:$b,NotEqualDepth:zoe,NotEqualStencilFunc:ldt,NumberKeyframeTrack:mv,Object3D:rn,ObjectLoader:u0t,ObjectSpaceNormalMap:jae,OctahedronBufferGeometry:k_,OctahedronGeometry:k_,OneFactor:koe,OneMinusDstAlphaFactor:Aoe,OneMinusDstColorFactor:Noe,OneMinusSrcAlphaFactor:J4,OneMinusSrcColorFactor:Eoe,OrthographicCamera:vv,PCFShadowMap:K4,PCFSoftShadowMap:woe,PMREMGenerator:V0t,ParametricBufferGeometry:_g,ParametricGeometry:_g,Particle:ebt,ParticleBasicMaterial:rbt,ParticleSystem:tbt,ParticleSystemMaterial:sbt,Path:cu,PerspectiveCamera:xi,Plane:ch,PlaneBufferGeometry:p_,PlaneGeometry:p_,PlaneHelper:O0t,PointCloud:Q0t,PointCloudMaterial:nbt,PointLight:KA,PointLightHelper:A0t,Points:fv,PointsMaterial:Iu,PolarGridHelper:$0t,PolyhedronBufferGeometry:gp,PolyhedronGeometry:gp,PositionalAudio:y0t,PropertyBinding:qo,PropertyMixer:gV,QuadraticBezierCurve:Nu,QuadraticBezierCurve3:Nh,Quaternion:lo,QuaternionKeyframeTrack:A_,QuaternionLinearInterpolant:UA,REVISION:X4,RGBADepthPacking:Hae,RGBAFormat:Ml,RGBAIntegerFormat:lae,RGBA_ASTC_10x10_Format:xae,RGBA_ASTC_10x5_Format:bae,RGBA_ASTC_10x6_Format:vae,RGBA_ASTC_10x8_Format:wae,RGBA_ASTC_12x10_Format:Sae,RGBA_ASTC_12x12_Format:_ae,RGBA_ASTC_4x4_Format:uae,RGBA_ASTC_5x4_Format:hae,RGBA_ASTC_5x5_Format:fae,RGBA_ASTC_6x5_Format:dae,RGBA_ASTC_6x6_Format:pae,RGBA_ASTC_8x5_Format:mae,RGBA_ASTC_8x6_Format:gae,RGBA_ASTC_8x8_Format:yae,RGBA_BPTC_Format:Cae,RGBA_ETC2_EAC_Format:RF,RGBA_PVRTC_2BPPV1_Format:NF,RGBA_PVRTC_4BPPV1_Format:MF,RGBA_S3TC_DXT1_Format:kF,RGBA_S3TC_DXT3_Format:TF,RGBA_S3TC_DXT5_Format:EF,RGBDEncoding:rV,RGBEEncoding:A$,RGBEFormat:nae,RGBFormat:jd,RGBIntegerFormat:aae,RGBM16Encoding:nV,RGBM7Encoding:tV,RGB_ETC1_Format:cae,RGB_ETC2_Format:$F,RGB_PVRTC_2BPPV1_Format:AF,RGB_PVRTC_4BPPV1_Format:IF,RGB_S3TC_DXT1_Format:CF,RGFormat:iae,RGIntegerFormat:oae,RawShaderMaterial:Lf,Ray:rx,Raycaster:wV,RectAreaLight:JA,RedFormat:rae,RedIntegerFormat:sae,ReinhardToneMapping:Woe,RepeatWrapping:t_,ReplaceStencilOp:Zft,ReverseSubtractEquation:_oe,RingBufferGeometry:$A,RingGeometry:$A,SRGB8_ALPHA8_ASTC_10x10_Format:Oae,SRGB8_ALPHA8_ASTC_10x5_Format:Rae,SRGB8_ALPHA8_ASTC_10x6_Format:Pae,SRGB8_ALPHA8_ASTC_10x8_Format:Dae,SRGB8_ALPHA8_ASTC_12x10_Format:Fae,SRGB8_ALPHA8_ASTC_12x12_Format:Lae,SRGB8_ALPHA8_ASTC_4x4_Format:kae,SRGB8_ALPHA8_ASTC_5x4_Format:Tae,SRGB8_ALPHA8_ASTC_5x5_Format:Eae,SRGB8_ALPHA8_ASTC_6x5_Format:Iae,SRGB8_ALPHA8_ASTC_6x6_Format:Aae,SRGB8_ALPHA8_ASTC_8x5_Format:Mae,SRGB8_ALPHA8_ASTC_8x6_Format:Nae,SRGB8_ALPHA8_ASTC_8x8_Format:$ae,Scene:aV,SceneUtils:Tbt,ShaderChunk:Jn,ShaderLib:au,ShaderMaterial:_a,ShadowMaterial:Cg,Shape:Kd,ShapeBufferGeometry:T_,ShapeGeometry:T_,ShapePath:dV,ShapeUtils:$f,ShortType:Xoe,Skeleton:v_,SkeletonHelper:Sle,SkinnedMesh:y_,SmoothShading:Wft,Sphere:Op,SphereBufferGeometry:E_,SphereGeometry:E_,Spherical:eL,SphericalHarmonics3:dle,Spline:_V,SplineCurve:$u,SplineCurve3:Nle,SpotLight:XA,SpotLightHelper:I0t,Sprite:m_,SpriteMaterial:mp,SrcAlphaFactor:Z4,SrcAlphaSaturateFactor:$oe,SrcColorFactor:Toe,StaticCopyUsage:pdt,StaticDrawUsage:VC,StaticReadUsage:hdt,StereoCamera:mle,StreamCopyUsage:gdt,StreamDrawUsage:udt,StreamReadUsage:ddt,StringKeyframeTrack:WA,SubtractEquation:Soe,SubtractiveBlending:wF,TOUCH:_f,TangentSpaceNormalMap:Yy,TetrahedronBufferGeometry:RA,TetrahedronGeometry:RA,TextBufferGeometry:PA,TextGeometry:PA,Texture:Kr,TextureLoader:jA,TorusBufferGeometry:DA,TorusGeometry:DA,TorusKnotBufferGeometry:OA,TorusKnotGeometry:OA,Triangle:Go,TriangleFanDrawMode:Kft,TriangleStripDrawMode:Xft,TrianglesDrawMode:Uae,TubeBufferGeometry:FA,TubeGeometry:FA,UVMapping:T$,Uint16Attribute:hbt,Uint16BufferAttribute:bg,Uint32Attribute:dbt,Uint32BufferAttribute:vg,Uint8Attribute:lbt,Uint8BufferAttribute:l_,Uint8ClampedAttribute:cbt,Uint8ClampedBufferAttribute:c_,Uniform:R$,UniformsLib:$t,UniformsUtils:Yae,UnsignedByteType:nx,UnsignedInt248Type:Rb,UnsignedIntType:tS,UnsignedShort4444Type:Yoe,UnsignedShort5551Type:Zoe,UnsignedShort565Type:Joe,UnsignedShortType:r_,VSMShadowMap:wb,Vector2:rt,Vector3:J,Vector4:Hr,VectorKeyframeTrack:gv,Vertex:ibt,VertexColors:Y0t,VideoTexture:LF,WebGL1Renderer:OF,WebGLCubeRenderTarget:oV,WebGLMultisampleRenderTarget:vdt,WebGLRenderTarget:qd,WebGLRenderTargetCube:Sbt,WebGLRenderer:WC,WebGLUtils:ole,WireframeGeometry:cV,WireframeHelper:vbt,WrapAroundEnding:o_,XHRLoader:wbt,ZeroCurvatureEnding:Bm,ZeroFactor:Coe,ZeroSlopeEnding:Vm,ZeroStencilOp:Yft,sRGBEncoding:BC},Symbol.toStringTag,{value:"Module"})),Jy=Vf(Ibt);var $_=function(n,e){e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=n,this.domElement=e,this.enabled=!0,this.target=new J,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:Sf.ROTATE,MIDDLE:Sf.DOLLY,RIGHT:Sf.PAN},this.touches={ONE:_f.ROTATE,TWO:_f.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(le){le.addEventListener("keydown",me),this._domElementKeyEvents=le},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,t.object.updateProjectionMatrix(),t.dispatchEvent(r),t.update(),a=o.NONE},this.update=function(){var le=new J,tt=new lo().setFromUnitVectors(n.up,new J(0,1,0)),Ct=tt.clone().invert(),yt=new J,Ht=new lo,En=2*Math.PI;return function(){var Bs=t.object.position;le.copy(Bs).sub(t.target),le.applyQuaternion(tt),c.setFromVector3(le),t.autoRotate&&a===o.NONE&&M(k()),t.enableDamping?(c.theta+=u.theta*t.dampingFactor,c.phi+=u.phi*t.dampingFactor):(c.theta+=u.theta,c.phi+=u.phi);var Ms=t.minAzimuthAngle,Ns=t.maxAzimuthAngle;return isFinite(Ms)&&isFinite(Ns)&&(Ms<-Math.PI?Ms+=En:Ms>Math.PI&&(Ms-=En),Ns<-Math.PI?Ns+=En:Ns>Math.PI&&(Ns-=En),Ms<=Ns?c.theta=Math.max(Ms,Math.min(Ns,c.theta)):c.theta=c.theta>(Ms+Ns)/2?Math.max(Ms,c.theta):Math.min(Ns,c.theta)),c.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=h,c.radius=Math.max(t.minDistance,Math.min(t.maxDistance,c.radius)),t.enableDamping===!0?t.target.addScaledVector(f,t.dampingFactor):t.target.add(f),le.setFromSpherical(c),le.applyQuaternion(Ct),Bs.copy(t.target).add(le),t.object.lookAt(t.target),t.enableDamping===!0?(u.theta*=1-t.dampingFactor,u.phi*=1-t.dampingFactor,f.multiplyScalar(1-t.dampingFactor)):(u.set(0,0,0),f.set(0,0,0)),h=1,d||yt.distanceToSquared(t.object.position)>l||8*(1-Ht.dot(t.object.quaternion))>l?(t.dispatchEvent(r),yt.copy(t.object.position),Ht.copy(t.object.quaternion),d=!1,!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",dt),t.domElement.removeEventListener("pointerdown",Be),t.domElement.removeEventListener("wheel",He),t.domElement.removeEventListener("touchstart",Ye),t.domElement.removeEventListener("touchend",kt),t.domElement.removeEventListener("touchmove",bt),t.domElement.ownerDocument.removeEventListener("pointermove",ht),t.domElement.ownerDocument.removeEventListener("pointerup",Ke),t._domElementKeyEvents!==null&&t._domElementKeyEvents.removeEventListener("keydown",me)};var t=this,r={type:"change"},s={type:"start"},i={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},a=o.NONE,l=1e-6,c=new eL,u=new eL,h=1,f=new J,d=!1,p=new rt,m=new rt,g=new rt,y=new rt,b=new rt,x=new rt,w=new rt,_=new rt,C=new rt;function k(){return 2*Math.PI/60/60*t.autoRotateSpeed}function A(){return Math.pow(.95,t.zoomSpeed)}function M(le){u.theta-=le}function I(le){u.phi-=le}var N=function(){var le=new J;return function(Ct,yt){le.setFromMatrixColumn(yt,0),le.multiplyScalar(-Ct),f.add(le)}}(),O=function(){var le=new J;return function(Ct,yt){t.screenSpacePanning===!0?le.setFromMatrixColumn(yt,1):(le.setFromMatrixColumn(yt,0),le.crossVectors(t.object.up,le)),le.multiplyScalar(Ct),f.add(le)}}(),R=function(){var le=new J;return function(Ct,yt){var Ht=t.domElement;if(t.object.isPerspectiveCamera){var En=t.object.position;le.copy(En).sub(t.target);var _r=le.length();_r*=Math.tan(t.object.fov/2*Math.PI/180),N(2*Ct*_r/Ht.clientHeight,t.object.matrix),O(2*yt*_r/Ht.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(N(Ct*(t.object.right-t.object.left)/t.object.zoom/Ht.clientWidth,t.object.matrix),O(yt*(t.object.top-t.object.bottom)/t.object.zoom/Ht.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function D(le){t.object.isPerspectiveCamera?h/=le:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom*le)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function z(le){t.object.isPerspectiveCamera?h*=le:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/le)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function B(le){p.set(le.clientX,le.clientY)}function X(le){w.set(le.clientX,le.clientY)}function G(le){y.set(le.clientX,le.clientY)}function ee(le){m.set(le.clientX,le.clientY),g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var tt=t.domElement;M(2*Math.PI*g.x/tt.clientHeight),I(2*Math.PI*g.y/tt.clientHeight),p.copy(m),t.update()}function pe(le){_.set(le.clientX,le.clientY),C.subVectors(_,w),C.y>0?D(A()):C.y<0&&z(A()),w.copy(_),t.update()}function oe(le){b.set(le.clientX,le.clientY),x.subVectors(b,y).multiplyScalar(t.panSpeed),R(x.x,x.y),y.copy(b),t.update()}function Ne(le){le.deltaY<0?z(A()):le.deltaY>0&&D(A()),t.update()}function ke(le){var tt=!1;switch(le.keyCode){case t.keys.UP:R(0,t.keyPanSpeed),tt=!0;break;case t.keys.BOTTOM:R(0,-t.keyPanSpeed),tt=!0;break;case t.keys.LEFT:R(t.keyPanSpeed,0),tt=!0;break;case t.keys.RIGHT:R(-t.keyPanSpeed,0),tt=!0;break}tt&&(le.preventDefault(),t.update())}function De(le){if(le.touches.length==1)p.set(le.touches[0].pageX,le.touches[0].pageY);else{var tt=.5*(le.touches[0].pageX+le.touches[1].pageX),Ct=.5*(le.touches[0].pageY+le.touches[1].pageY);p.set(tt,Ct)}}function ge(le){if(le.touches.length==1)y.set(le.touches[0].pageX,le.touches[0].pageY);else{var tt=.5*(le.touches[0].pageX+le.touches[1].pageX),Ct=.5*(le.touches[0].pageY+le.touches[1].pageY);y.set(tt,Ct)}}function Xe(le){var tt=le.touches[0].pageX-le.touches[1].pageX,Ct=le.touches[0].pageY-le.touches[1].pageY,yt=Math.sqrt(tt*tt+Ct*Ct);w.set(0,yt)}function Oe(le){t.enableZoom&&Xe(le),t.enablePan&&ge(le)}function it(le){t.enableZoom&&Xe(le),t.enableRotate&&De(le)}function Ge(le){if(le.touches.length==1)m.set(le.touches[0].pageX,le.touches[0].pageY);else{var tt=.5*(le.touches[0].pageX+le.touches[1].pageX),Ct=.5*(le.touches[0].pageY+le.touches[1].pageY);m.set(tt,Ct)}g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var yt=t.domElement;M(2*Math.PI*g.x/yt.clientHeight),I(2*Math.PI*g.y/yt.clientHeight),p.copy(m)}function pt(le){if(le.touches.length==1)b.set(le.touches[0].pageX,le.touches[0].pageY);else{var tt=.5*(le.touches[0].pageX+le.touches[1].pageX),Ct=.5*(le.touches[0].pageY+le.touches[1].pageY);b.set(tt,Ct)}x.subVectors(b,y).multiplyScalar(t.panSpeed),R(x.x,x.y),y.copy(b)}function ut(le){var tt=le.touches[0].pageX-le.touches[1].pageX,Ct=le.touches[0].pageY-le.touches[1].pageY,yt=Math.sqrt(tt*tt+Ct*Ct);_.set(0,yt),C.set(0,Math.pow(_.y/w.y,t.zoomSpeed)),D(C.y),w.copy(_)}function Ve(le){t.enableZoom&&ut(le),t.enablePan&&pt(le)}function ze(le){t.enableZoom&&ut(le),t.enableRotate&&Ge(le)}function Be(le){if(t.enabled!==!1)switch(le.pointerType){case"mouse":case"pen":Q(le);break}}function ht(le){if(t.enabled!==!1)switch(le.pointerType){case"mouse":case"pen":Z(le);break}}function Ke(le){switch(le.pointerType){case"mouse":case"pen":nt();break}}function Q(le){le.preventDefault(),t.domElement.focus?t.domElement.focus():window.focus();var tt;switch(le.button){case 0:tt=t.mouseButtons.LEFT;break;case 1:tt=t.mouseButtons.MIDDLE;break;case 2:tt=t.mouseButtons.RIGHT;break;default:tt=-1}switch(tt){case Sf.DOLLY:if(t.enableZoom===!1)return;X(le),a=o.DOLLY;break;case Sf.ROTATE:if(le.ctrlKey||le.metaKey||le.shiftKey){if(t.enablePan===!1)return;G(le),a=o.PAN}else{if(t.enableRotate===!1)return;B(le),a=o.ROTATE}break;case Sf.PAN:if(le.ctrlKey||le.metaKey||le.shiftKey){if(t.enableRotate===!1)return;B(le),a=o.ROTATE}else{if(t.enablePan===!1)return;G(le),a=o.PAN}break;default:a=o.NONE}a!==o.NONE&&(t.domElement.ownerDocument.addEventListener("pointermove",ht),t.domElement.ownerDocument.addEventListener("pointerup",Ke),t.dispatchEvent(s))}function Z(le){if(t.enabled!==!1)switch(le.preventDefault(),a){case o.ROTATE:if(t.enableRotate===!1)return;ee(le);break;case o.DOLLY:if(t.enableZoom===!1)return;pe(le);break;case o.PAN:if(t.enablePan===!1)return;oe(le);break}}function nt(le){t.domElement.ownerDocument.removeEventListener("pointermove",ht),t.domElement.ownerDocument.removeEventListener("pointerup",Ke),t.enabled!==!1&&(t.dispatchEvent(i),a=o.NONE)}function He(le){t.enabled===!1||t.enableZoom===!1||a!==o.NONE&&a!==o.ROTATE||(le.preventDefault(),le.stopPropagation(),t.dispatchEvent(s),Ne(le),t.dispatchEvent(i))}function me(le){t.enabled===!1||t.enablePan===!1||ke(le)}function Ye(le){if(t.enabled!==!1){switch(le.preventDefault(),le.touches.length){case 1:switch(t.touches.ONE){case _f.ROTATE:if(t.enableRotate===!1)return;De(le),a=o.TOUCH_ROTATE;break;case _f.PAN:if(t.enablePan===!1)return;ge(le),a=o.TOUCH_PAN;break;default:a=o.NONE}break;case 2:switch(t.touches.TWO){case _f.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Oe(le),a=o.TOUCH_DOLLY_PAN;break;case _f.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;it(le),a=o.TOUCH_DOLLY_ROTATE;break;default:a=o.NONE}break;default:a=o.NONE}a!==o.NONE&&t.dispatchEvent(s)}}function bt(le){if(t.enabled!==!1)switch(le.preventDefault(),le.stopPropagation(),a){case o.TOUCH_ROTATE:if(t.enableRotate===!1)return;Ge(le),t.update();break;case o.TOUCH_PAN:if(t.enablePan===!1)return;pt(le),t.update();break;case o.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Ve(le),t.update();break;case o.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;ze(le),t.update();break;default:a=o.NONE}}function kt(le){t.enabled!==!1&&(t.dispatchEvent(i),a=o.NONE)}function dt(le){t.enabled!==!1&&le.preventDefault()}t.domElement.addEventListener("contextmenu",dt),t.domElement.addEventListener("pointerdown",Be),t.domElement.addEventListener("wheel",He),t.domElement.addEventListener("touchstart",Ye),t.domElement.addEventListener("touchend",kt),t.domElement.addEventListener("touchmove",bt),this.update()};$_.prototype=Object.create(Uu.prototype);$_.prototype.constructor=$_;var rM=function(n,e){$_.call(this,n,e),this.screenSpacePanning=!1,this.mouseButtons.LEFT=Sf.PAN,this.mouseButtons.RIGHT=Sf.ROTATE,this.touches.ONE=_f.PAN,this.touches.TWO=_f.DOLLY_ROTATE};rM.prototype=Object.create(Uu.prototype);rM.prototype.constructor=rM;const Abt=Object.freeze(Object.defineProperty({__proto__:null,MapControls:rM,OrbitControls:$_},Symbol.toStringTag,{value:"Module"})),Mbt=Vf(Abt);var GC={};(function(n){Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function r(s,i,o,a,l,c,u){this.pointIndices=s,this.labelStrings=i,this.scaleFactors=o,this.useSceneOpacityFlags=a,this.defaultFontSize=l,this.fillColors=c,this.strokeColors=u}return r}();n.LabelRenderParams=e,function(r){r[r.Perspective=0]="Perspective",r[r.Orthographic=1]="Orthographic"}(n.CameraType||(n.CameraType={}));var t=function(){function r(s,i,o,a,l,c,u,h,f,d,p,m,g,y){this.camera=s,this.cameraType=i,this.cameraTarget=o,this.screenWidth=a,this.screenHeight=l,this.nearestCameraSpacePointZ=c,this.farthestCameraSpacePointZ=u,this.backgroundColor=h,this.pointColors=f,this.pointScaleFactors=d,this.labels=p,this.polylineColors=m,this.polylineOpacities=g,this.polylineWidths=y}return r}();n.RenderContext=t})(GC);var Ki={};Object.defineProperty(Ki,"__esModule",{value:!0});var pu=Jy;function Nbt(n,e,t,r){var s=window.devicePixelRatio,i=new pu.Vector3().copy(r).project(n),o=[(i.x+1)/2*e*s,-((i.y-1)/2*t)*s];return o}Ki.vector3DToScreenCoords=Nbt;function $bt(n,e){var t=e*3;return new pu.Vector3(n[t],n[t+1],n[t+2])}Ki.vector3FromPackedArray=$bt;function Rbt(n,e,t){for(var r=1/0,s=0,i=new pu.Vector3().copy(t).sub(e),o=new pu.Vector3().copy(i).normalize(),a=n.length/3,l=0,c=new pu.Vector3,u=new pu.Vector3,h=0;h<a;h++){c.x=n[l],c.y=n[l+1],c.z=n[l+2],l+=3,u.copy(c).sub(e);var f=o.dot(u);f<0||(s=f>s?f:s,r=f<r?f:r)}return[r,s]}Ki.getNearFarPoints=Rbt;function $le(n,e){return e===void 0&&(e=!0),n.needsUpdate=e,n.minFilter=pu.LinearFilter,n.generateMipmaps=!1,n.flipY=!1,n}function Pbt(n){var e=new pu.Texture(n);return $le(e)}Ki.createTextureFromCanvas=Pbt;function Dbt(n,e){var t=new pu.Texture(n);return n.complete?(t.needsUpdate=!0,e()):n.onload=function(){t.needsUpdate=!0,e()},$le(t,!1)}Ki.createTextureFromImage=Dbt;function Obt(){try{var n=document.createElement("canvas"),e=n.getContext("webgl")||n.getContext("experimental-webgl");return e!=null}catch{return!1}}Ki.hasWebGLSupport=Obt;function Fbt(n){for(var e=1/0,t=-1/0,r=0;r<n.length;r++){var s=n[r];s<e&&(e=s),s>t&&(t=s)}return[e,t]}Ki.extent=Fbt;function Lbt(n,e,t){var r=e[1]-e[0],s=t[1]-t[0],i=(n-e[0])/r;return i*s+t[0]}Ki.scaleLinear=Lbt;function zbt(n,e,t){var r=Math.pow(e[1],Math.E)-Math.pow(e[0],Math.E),s=t[1]-t[0],i=(Math.pow(n,Math.E)-e[0])/r;return i*s+t[0]}Ki.scaleExponential=zbt;function Bbt(n,e,t,r,s){n[e*3]=t,n[e*3+1]=r,n[e*3+2]=s}Ki.packRgbIntoUint8Array=Bbt;function Vbt(n){var e=new pu.Color(n);return[e.r*255|0,e.g*255|0,e.b*255|0]}Ki.styleRgbFromHexColor=Vbt;var mq=function(n){return 100*n+"%"};function Ubt(n,e,t,r,s,i){var o=t+(r-t)*n/e,a="hsl("+o+", "+mq(s)+", "+mq(i)+")";return new pu.Color(a)}Ki.getDefaultPointInPolylineColor=Ubt;var CV={};Object.defineProperty(CV,"__esModule",{value:!0});var Wbt=function(){function n(e,t,r){this.startCoordinates=[0,0],this.svgElement=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgElement.style.display="none",this.svgElement.style.height="100%",this.svgElement.style.width="100%",this.svgElement.style.position="absolute",e.insertAdjacentElement("afterbegin",this.svgElement),this.rectElement=document.createElementNS("http://www.w3.org/2000/svg","rect"),this.rectElement.style.stroke=r.select.stroke,this.rectElement.style.strokeDasharray=r.select.strokeDashArray,this.rectElement.style.strokeWidth=""+r.select.strokeWidth,this.rectElement.style.fill=r.select.fill,this.rectElement.style.fillOpacity=""+r.select.fillOpacity,this.svgElement.appendChild(this.rectElement),this.selectionCallback=t,this.isMouseDown=!1}return n.prototype.onMouseDown=function(e,t){this.isMouseDown=!0,this.rectElement.style.display="block",this.svgElement.style.display="block",this.startCoordinates=[e,t],this.lastBoundingBox={x:this.startCoordinates[0],y:this.startCoordinates[1],width:1,height:1}},n.prototype.onMouseMove=function(e,t){this.isMouseDown&&(this.lastBoundingBox.x=Math.min(e,this.startCoordinates[0]),this.lastBoundingBox.y=Math.max(t,this.startCoordinates[1]),this.lastBoundingBox.width=Math.max(e,this.startCoordinates[0])-this.lastBoundingBox.x,this.lastBoundingBox.height=this.lastBoundingBox.y-Math.min(t,this.startCoordinates[1]),this.rectElement.setAttribute("x",""+this.lastBoundingBox.x),this.rectElement.setAttribute("y",""+(this.lastBoundingBox.y-this.lastBoundingBox.height)),this.rectElement.setAttribute("width",""+this.lastBoundingBox.width),this.rectElement.setAttribute("height",""+this.lastBoundingBox.height))},n.prototype.onMouseUp=function(){this.isMouseDown=!1,this.svgElement.style.display="none",this.rectElement.style.display="none",this.rectElement.setAttribute("width","0"),this.rectElement.setAttribute("height","0"),this.selectionCallback(this.lastBoundingBox)},n}();CV.ScatterPlotRectangleSelector=Wbt;var sM=mt&&mt.__assign||function(){return sM=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++){e=arguments[t];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s])}return n},sM.apply(this,arguments)},DP=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},gq=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(q4,"__esModule",{value:!0});var xr=Jy,Gbt=Mbt,OP=GC,Hbt=Ki,jbt=CV,Rle=2,qbt=5*Rle,Xbt=.025*Rle,Kbt=70,Ybt=.01,Zbt=100,vE=1.2,yq="Shift",bq="Control",Jbt=new xr.Vector3(.45,.9,1.6),Qbt=new xr.Vector3(0,0,0),evt=new xr.Vector3(0,0,4),tvt=new xr.Vector3(0,0,0),nvt={mouseRotateSpeed:1,autoRotateSpeed:2,zoomSpeed:.125},rvt=function(){function n(e,t){var r=this;this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.selectEnabled=!0,this.visualizers=new Map,this.onCameraMoveListeners=[],this.height=0,this.width=0,this.dimensions=3,this.interactionMode="PAN",this.pickingTexture=new xr.WebGLRenderTarget(0,0),this.orbitAnimationOnNextCameraCreation=!1,this.orbitAnimationId=null,this.worldSpacePointPositions=new Float32Array(0),this.pointColors=new Float32Array(0),this.pointScaleFactors=new Float32Array(0),this.polylineColors={},this.polylineOpacities=new Float32Array(0),this.polylineWidths=new Float32Array(0),this.selecting=!1,this.nearestPoint=null,this.mouseIsDown=!1,this.isDragSequence=!1,this.lastHovered=null,this.container=e,this.styles=t.styles,this.setParameters(t),this.computeLayoutValues(),this.scene=new xr.Scene,this.renderer=new xr.WebGLRenderer({alpha:!0,premultipliedAlpha:!1,antialias:!1}),this.renderer.setClearColor(this.styles.backgroundColor,1),this.container.appendChild(this.renderer.domElement),this.light=new xr.PointLight(16772287,1,0),this.scene.add(this.light),this.orbitControlParams=sM(sM({},nvt),t.orbitControlParams),this.rectangleSelector=new jbt.ScatterPlotRectangleSelector(this.container,function(s){r.selectBoundingBox(s)},this.styles),this.addInteractionListeners(),this.setDimensions(3),this.makeCamera(t.camera),this.resize()}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled)},n.prototype.addInteractionListeners=function(){this.container.addEventListener("pointermove",this.onMouseMove.bind(this)),this.container.addEventListener("pointerdown",this.onMouseDown.bind(this)),this.container.addEventListener("pointerup",this.onMouseUp.bind(this)),this.container.addEventListener("click",this.onClick.bind(this)),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1)},n.prototype.addCameraControlsEventListeners=function(e){var t=this;e.addEventListener("start",function(){t.stopOrbitAnimation(),t.onCameraMoveListeners.forEach(function(r){return r(t.camera.position,e.target)})}),e.addEventListener("change",function(){t.render()}),e.addEventListener("end",function(){})},n.prototype.makeOrbitControls=function(e,t){this.orbitCameraControls!=null&&this.orbitCameraControls.dispose();var r=new Gbt.OrbitControls(e,this.renderer.domElement);r.zoomSpeed=this.orbitControlParams.zoomSpeed,r.enableRotate=t,r.autoRotate=!1,r.enableKeys=!1,r.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,t?(r.mouseButtons.LEFT=xr.MOUSE.LEFT,r.mouseButtons.RIGHT=xr.MOUSE.RIGHT):(r.mouseButtons.LEFT=xr.MOUSE.RIGHT,r.mouseButtons.RIGHT=xr.MOUSE.LEFT),r.reset(),this.camera=e,this.orbitCameraControls=r,this.addCameraControlsEventListeners(this.orbitCameraControls)},n.prototype.makeCamera=function(e){e===void 0&&(e={});var t=this.makeDefaultCameraDef(this.dimensions,e);this.recreateCamera(t),this.dimensions===3&&this.styles.axesVisible?this.add3dAxes():this.remove3dAxesFromScene()},n.prototype.makeCamera3D=function(e,t,r){var s;{var i=t/r;s=new xr.PerspectiveCamera(Kbt,i,Ybt,Zbt),s.position.set(e.position[0],e.position[1],e.position[2]);var o=new xr.Vector3(e.target[0],e.target[1],e.target[2]);s.lookAt(o),s.zoom=e.zoom,s.updateProjectionMatrix()}this.camera=s,this.makeOrbitControls(s,!0)},n.prototype.makeCamera2D=function(e,t,r){var s,i=new xr.Vector3(e.target[0],e.target[1],e.target[2]);{var o=t/r,a=-vE,l=vE,c=-vE,u=vE;o>1?(a*=o,l*=o):(u/=o,c/=o),s=new xr.OrthographicCamera(a,l,u,c,-1e3,1e3),s.position.set(e.position[0],e.position[1],e.position[2]),s.up=new xr.Vector3(0,0,1),s.lookAt(i),s.zoom=e.zoom,s.updateProjectionMatrix()}this.camera=s,this.makeOrbitControls(s,!1)},n.prototype.makeDefaultCameraDef=function(e,t){t===void 0&&(t={});var r=e===2,s=r?evt:Jbt,i=r?tvt:Qbt,o={orthographic:r,zoom:1,position:[s.x,s.y,s.z],target:[i.x,i.y,i.z]};return t.zoom&&(o.zoom=t.zoom),t.position&&(o.position=t.position),t.target&&(o.target=t.target),o},n.prototype.recreateCamera=function(e){e.orthographic?this.makeCamera2D(e,this.width,this.height):this.makeCamera3D(e,this.width,this.height),this.orbitCameraControls.minDistance=Xbt,this.orbitCameraControls.maxDistance=qbt,this.orbitCameraControls.update(),this.orbitAnimationOnNextCameraCreation&&this.startOrbitAnimation()},n.prototype.setInteractionMode=function(e){this.interactionMode=e,e==="SELECT"?(this.selecting=!0,this.container.style.cursor="crosshair",this.orbitCameraControls.enabled=!1):(this.selecting=!1,this.container.style.cursor="default",this.orbitCameraControls.enabled=!0)},n.prototype.onClick=function(e,t){if(t===void 0&&(t=!0),!(e&&this.selecting)){if(!this.isDragSequence&&t){if(this.selectEnabled){var r=this.nearestPoint!=null?[this.nearestPoint]:[];this.selectCallback(r)}this.clickCallback(this.nearestPoint)}this.isDragSequence=!1,this.render()}},n.prototype.onMouseDown=function(e){this.isDragSequence=!1,this.mouseIsDown=!0,this.selecting?(this.rectangleSelector.onMouseDown(e.offsetX,e.offsetY),this.setNearestPointToMouse(e)):!e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===xr.MOUSE.RIGHT?(this.orbitCameraControls.mouseButtons.ORBIT=xr.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=xr.MOUSE.RIGHT):e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===xr.MOUSE.LEFT&&(this.orbitCameraControls.mouseButtons.ORBIT=xr.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=xr.MOUSE.LEFT)},n.prototype.onMouseUp=function(e){this.selecting&&(this.rectangleSelector.onMouseUp(),this.render()),this.mouseIsDown=!1},n.prototype.onMouseMove=function(e){this.isDragSequence=this.mouseIsDown,this.selecting&&this.mouseIsDown?(this.rectangleSelector.onMouseMove(e.offsetX,e.offsetY),this.render()):this.mouseIsDown||(this.setNearestPointToMouse(e),this.nearestPoint!=this.lastHovered&&(this.lastHovered=this.nearestPoint,this.hoverCallback(this.nearestPoint)))},n.prototype.onKeyDown=function(e){e.key===bq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=xr.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=xr.MOUSE.LEFT),e.key===yq&&this.selectEnabled&&(this.selecting=!0,this.orbitCameraControls.enabled=!1,this.container.style.cursor="crosshair")},n.prototype.onKeyUp=function(e){e.key===bq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=xr.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=xr.MOUSE.RIGHT),e.key===yq&&this.selectEnabled&&(this.selecting=!1,this.orbitCameraControls.enabled=!0,this.container.style.cursor="default",this.render())},n.prototype.getPointIndicesFromBoundingBox=function(e){if(this.worldSpacePointPositions==null)return[];this.camera.updateMatrixWorld();var t=window.devicePixelRatio||1,r=Math.floor(e.x*t),s=Math.floor(e.y*t),i=Math.max(Math.floor(e.width*t),1),o=Math.max(Math.floor(e.height*t),1);if(i<=2&&o<=2)return this.getPointIndicesFromBoundingBoxPickingTexture(e);for(var a=this.renderer.domElement,l=a.width,c=a.height,u=[],h=new xr.Vector3,f=0;f<this.worldSpacePointPositions.length;f++){var d=f*3,p=DP(this.worldSpacePointPositions.slice(d,d+3),3),m=p[0],g=p[1],y=p[2];h.x=m,h.y=g,h.z=y;var b=h.project(this.camera),x=(b.x+1)*l/2,w=-(b.y-1)*c/2;x>=r&&x<=r+i&&w<=s&&w>=s-o&&u.push(f)}return u},n.prototype.getPointIndicesFromBoundingBoxPickingTexture=function(e){if(this.worldSpacePointPositions==null)return[];var t=this.worldSpacePointPositions.length/3,r=window.devicePixelRatio||1,s=Math.floor(e.x*r),i=Math.floor(e.y*r),o=Math.max(Math.floor(e.width*r),1),a=Math.max(Math.floor(e.height*r),1),l=new Uint8Array(o*a*4);this.renderer.readRenderTargetPixels(this.pickingTexture,s,this.pickingTexture.height-i,o,a,l);for(var c=new Uint8Array(this.worldSpacePointPositions.length),u=0;u<o*a;u++){var h=l[u*4]<<16|l[u*4+1]<<8|l[u*4+2];h!==16777215&&h<t&&(c[h]=1)}for(var f=[],u=0;u<c.length;u++)c[u]===1&&f.push(u);return f},n.prototype.selectBoundingBox=function(e){var t=this.getPointIndicesFromBoundingBox(e);this.selectCallback(t)},n.prototype.setNearestPointToMouse=function(e){if(this.pickingTexture==null){this.nearestPoint=null;return}var t={x:e.offsetX,y:e.offsetY,width:1,height:1},r=this.getPointIndicesFromBoundingBoxPickingTexture(t);this.nearestPoint=r.length?r[0]:null},n.prototype.computeLayoutValues=function(){return this.width=this.container.offsetWidth,this.height=Math.max(1,this.container.offsetHeight),[this.width,this.height]},n.prototype.sceneIs3D=function(){return this.dimensions===3},n.prototype.remove3dAxesFromScene=function(){var e=this.scene.getObjectByName("axes");return e!=null&&this.scene.remove(e),e},n.prototype.add3dAxes=function(){var e=new xr.AxesHelper;e.name="axes",this.scene.add(e)},n.prototype.setDimensions=function(e){if(e!==2&&e!==3)throw new RangeError("dimensions must be 2 or 3");this.dimensions!==e&&(this.dimensions=e,this.makeCamera())},n.prototype.getCameraPosition=function(){var e=this.camera.position;return[e.x,e.y,e.z]},n.prototype.getCameraTarget=function(){var e=this.orbitCameraControls.target;return[e.x,e.y,e.z]},n.prototype.setCameraPositionAndTarget=function(e,t){this.stopOrbitAnimation(),this.camera.position.set(e[0],e[1],e[2]),this.orbitCameraControls.target.set(t[0],t[1],t[2]),this.orbitCameraControls.update(),this.render()},n.prototype.startOrbitAnimation=function(){this.sceneIs3D()&&(this.orbitAnimationId!=null&&this.stopOrbitAnimation(),this.orbitCameraControls.autoRotate=!0,this.orbitCameraControls.autoRotateSpeed=this.orbitControlParams.autoRotateSpeed,this.updateOrbitAnimation())},n.prototype.orbitIsAnimating=function(){return this.orbitAnimationId!=null},n.prototype.updateOrbitAnimation=function(){var e=this;this.orbitCameraControls.update(),this.orbitAnimationId=requestAnimationFrame(function(){return e.updateOrbitAnimation()})},n.prototype.stopOrbitAnimation=function(){this.orbitCameraControls.autoRotate=!1,this.orbitCameraControls.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,this.orbitAnimationId!=null&&(cancelAnimationFrame(this.orbitAnimationId),this.orbitAnimationId=null)},n.prototype.setActiveVisualizers=function(e){var t,r,s,i,o=new Set(e.map(function(f){return f.id}));try{for(var a=gq(this.visualizers.values()),l=a.next();!l.done;l=a.next()){var c=l.value;o.has(c.id)||(c.dispose(),this.visualizers.delete(c.id))}}catch(f){t={error:f}}finally{try{l&&!l.done&&(r=a.return)&&r.call(a)}finally{if(t)throw t.error}}try{for(var u=gq(e),h=u.next();!h.done;h=u.next()){var c=h.value;this.visualizers.set(c.id,c),c.setScene(this.scene),c.onResize(this.width,this.height),this.worldSpacePointPositions&&c.onPointPositionsChanged(this.worldSpacePointPositions)}}catch(f){s={error:f}}finally{try{h&&!h.done&&(i=u.return)&&i.call(u)}finally{if(s)throw s.error}}},n.prototype.disposeAllVisualizers=function(){this.visualizers.forEach(function(e){return e.dispose()}),this.visualizers.clear()},n.prototype.setPointPositions=function(e){this.worldSpacePointPositions=e,this.visualizers.forEach(function(t){return t.onPointPositionsChanged(e)})},n.prototype.render=function(){{var e=this.camera.position.clone();e.x+=1,e.y+=1,this.light.position.set(e.x,e.y,e.z)}var t=this.camera instanceof xr.PerspectiveCamera?OP.CameraType.Perspective:OP.CameraType.Orthographic,r=[0,0];this.worldSpacePointPositions!=null&&(r=Hbt.getNearFarPoints(this.worldSpacePointPositions,this.camera.position,this.orbitCameraControls.target));var s=new OP.RenderContext(this.camera,t,this.orbitCameraControls.target,this.width,this.height,r[0],r[1],this.styles.backgroundColor,this.pointColors,this.pointScaleFactors,this.labels,this.polylineColors,this.polylineOpacities,this.polylineWidths);this.visualizers.forEach(function(o){return o.onPickingRender(s)});{var i=this.remove3dAxesFromScene();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.render(this.scene,this.camera),i!=null&&this.scene.add(i)}this.visualizers.forEach(function(o){return o.onRender(s)}),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)},n.prototype.setPointColors=function(e){this.pointColors=e},n.prototype.setPointScaleFactors=function(e){this.pointScaleFactors=e},n.prototype.setLabels=function(e){this.labels=e},n.prototype.setPolylineColors=function(e){this.polylineColors=e},n.prototype.setPolylineOpacities=function(e){this.polylineOpacities=e},n.prototype.setPolylineWidths=function(e){this.polylineWidths=e},n.prototype.resetZoom=function(){this.recreateCamera(this.makeDefaultCameraDef(this.dimensions)),this.render()},n.prototype.setDayNightMode=function(e){for(var t=this.container.querySelectorAll("canvas"),r=e?"invert(100%)":"",s=0;s<t.length;s++)t[s].style.filter=r},n.prototype.resize=function(e){e===void 0&&(e=!0);var t=DP([this.width,this.height],2),r=t[0],s=t[1],i=DP(this.computeLayoutValues(),2),o=i[0],a=i[1];if(this.dimensions===3){var l=this.camera;l.aspect=o/a,l.updateProjectionMatrix()}else{var l=this.camera,c=o/r,u=a/s,h=(l.right-l.left)*c/2,f=(l.top-l.bottom)*u/2;l.top=f,l.bottom=-f,l.left=-h,l.right=h,l.updateProjectionMatrix()}var d=window.devicePixelRatio||1;this.renderer.setPixelRatio(d),this.renderer.setSize(o,a);{var p=new xr.Vector2;this.renderer.getSize(p);var m=this.renderer.getPixelRatio();this.pickingTexture=new xr.WebGLRenderTarget(p.width*m,p.height*m),this.pickingTexture.texture.minFilter=xr.LinearFilter}this.visualizers.forEach(function(g){return g.onResize(o,a)}),e&&this.render()},n.prototype.onCameraMove=function(e){this.onCameraMoveListeners.push(e)},n.prototype.clickOnPoint=function(e){this.nearestPoint=e,this.onClick(null,!1)},n}();q4.ScatterPlot=rvt;var kV={},svt=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i};Object.defineProperty(kV,"__esModule",{value:!0});var ivt=Jy,FP=new Map,ovt=/^(rgba|hsla)\((\d+),\s*(\d+%?),\s*(\d+%?)(?:,\s*(\d+(?:\.\d+)?))?\)$/;function avt(n){var e=ovt.exec(n);if(e){var t=svt(e,6);t[0];var r=t[1],s=t[2],i=t[3],o=t[4],a=t[5],l=r.replace("a","")+"("+s+","+i+","+o+")";return{colorString:l,opacity:parseFloat(a)}}return{colorString:n,opacity:1}}function lvt(n){if(FP.has(n))return FP.get(n);var e=avt(n),t=e.colorString,r=e.opacity,s=new ivt.Color(t),i=s.r,o=s.g,a=s.b,l={r:i,g:o,b:a,opacity:r};return FP.set(n,l),l}kV.parseColor=lvt;var P$={},cvt=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(P$,"__esModule",{value:!0});var vq="Points must be an array of either 2 or 3 dimensional number arrays",uvt=function(){function n(e,t){var r,s;t===void 0&&(t=[]),this.points=e,this.metadata=t;var i=e[0].length;if(!(i===2||i===3))throw new Error(vq);try{for(var o=cvt(e),a=o.next();!a.done;a=o.next()){var l=a.value;if(i!==l.length)throw new Error(vq)}}catch(c){r={error:c}}finally{try{a&&!a.done&&(s=o.return)&&s.call(o)}finally{if(r)throw r.error}}this.dimensions=i}return n.prototype.setSpriteMetadata=function(e){this.spriteMetadata=e},n}();P$.Dataset=uvt;var TV={};Object.defineProperty(TV,"__esModule",{value:!0});var hvt=function(){var n={backgroundColor:"#ffffff",axesVisible:!0,fog:{color:"#ffffff",enabled:!0,threshold:5e3},label:{fontSize:10,scaleDefault:1,scaleLarge:2,fillColorSelected:"#000000",fillColorHover:"#000000",strokeColorSelected:"#ffffff",strokeColorHover:"#ffffff",strokeWidth:3,fillWidth:6},label3D:{fontSize:80,scale:2.2,color:"black",backgroundColor:"#ffffff",colorUnselected:"#ffffff",colorNoSelection:"#ffffff"},point:{colorUnselected:"rgba(227, 227, 227, 0.7)",colorNoSelection:"rgba(117, 117, 217, 0.7)",colorSelected:"rgba(250, 102, 102, 0.7)",colorHover:"rgba(118, 11, 79, 0.7)",scaleDefault:1,scaleSelected:1.2,scaleHover:1.2},polyline:{startHue:60,endHue:360,saturation:1,lightness:.3,defaultOpacity:.2,defaultLineWidth:2,selectedOpacity:.9,selectedLineWidth:3,deselectedOpacity:.05},select:{fill:"#dddddd",fillOpacity:.2,stroke:"#aaaaaa",strokeWidth:2,strokeDashArray:"10 5"},sprites:{minPointSize:5,imageSize:30,colorUnselected:"#ffffff",colorNoSelection:"#ffffff"}};return n};function fvt(n){var e=hvt();if(n===void 0)return e;for(var t in e){var r=t;typeof e[r]=="object"&&typeof n[r]=="object"?e[r]=Object.assign(e[r],n[r]):n[r]!==void 0&&(e[r]=n[r])}return e}TV.makeStyles=fvt;var Wu={};Object.defineProperty(Wu,"__esModule",{value:!0});Wu.RGB_NUM_ELEMENTS=3;Wu.RGBA_NUM_ELEMENTS=4;Wu.XYZ_NUM_ELEMENTS=3;Wu.UV_NUM_ELEMENTS=2;Wu.INDEX_NUM_ELEMENTS=1;Wu.SCATTER_PLOT_CUBE_LENGTH=2;var EV={};Object.defineProperty(EV,"__esModule",{value:!0});var uf=Jy,wq=Ki,no=Wu,LP=8192,zP=256,aa=2*3,dvt=function(n,e){return`
      attribute vec2 posObj;
      attribute vec4 color;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        vUv = uv;
        vColor = color;

        // Rotate label to face camera.

        vec4 vRight = vec4(
          modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);

        vec4 vUp = vec4(
          modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);

        vec4 vAt = -vec4(
          modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);

        mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));

        vec2 scaledPos = posObj * `+1/n+" * "+e+`;

        vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);
        vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);
        gl_Position = projectionMatrix * mvPosition;
      }`},pvt=`
      uniform sampler2D glyphTexture;
      uniform bool picking;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        if (picking) {
          gl_FragColor = vColor;
        } else {
          vec4 fromTexture = texture(glyphTexture, vUv);
          gl_FragColor = vColor * fromTexture;
        }
      }`,mvt=function(){function n(e){this.styles=e,this.id="3D_LABELS",this.labelStrings=[],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.uniforms={},this.totalVertexCount=0,this.labelVertexMap=[]}return n.prototype.createGlyphTexture=function(){var e=this.styles.label3D,t=e.fontSize,r=e.backgroundColor,s=e.color,i=document.createElement("canvas");i.width=LP,i.height=t;var o=i.getContext("2d");o.font="bold "+t+"px roboto",o.textBaseline="top",o.fillStyle=r,o.rect(0,0,i.width,i.height),o.fill(),o.fillStyle=s;for(var a=o.measureText(" ").width,l=new Float32Array(zP),c=new Float32Array(zP),u=0,h=0;h<zP;h++){var f=" "+String.fromCharCode(h),d=o.measureText(f).width;l[h]=d-a,c[h]=u,o.fillText(f,u-a,0),u+=d}var p=wq.createTextureFromCanvas(i);return{texture:p,lengths:l,offsets:c}},n.prototype.processLabelVerts=function(e){var t=0;this.labelVertexMap=[];for(var r=0;r<e;r++){for(var s=this.labelStrings[r],i=[],o=0;o<s.length;o++){for(var a=0;a<aa;a++)i.push(t*aa+a);t++}this.labelVertexMap.push(i)}this.totalVertexCount=t*aa},n.prototype.createColorBuffers=function(e){var t=this;this.pickingColors=new Float32Array(this.totalVertexCount*no.RGB_NUM_ELEMENTS),this.renderColors=new Float32Array(this.totalVertexCount*no.RGB_NUM_ELEMENTS);for(var r=function(o){var a=new uf.Color(o);s.labelVertexMap[o].forEach(function(l){t.pickingColors[no.RGB_NUM_ELEMENTS*l]=a.r,t.pickingColors[no.RGB_NUM_ELEMENTS*l+1]=a.g,t.pickingColors[no.RGB_NUM_ELEMENTS*l+2]=a.b,t.renderColors[no.RGB_NUM_ELEMENTS*l]=1,t.renderColors[no.RGB_NUM_ELEMENTS*l+1]=1,t.renderColors[no.RGB_NUM_ELEMENTS*l+2]=1})},s=this,i=0;i<e;i++)r(i)},n.prototype.createLabels=function(){var e=this,t=this.styles.label3D,r=t.fontSize,s=t.scale;if(!(this.labelStrings==null||this.worldSpacePointPositions==null)){var i=this.worldSpacePointPositions.length/no.XYZ_NUM_ELEMENTS;if(i===this.labelStrings.length){this.glyphTexture=this.createGlyphTexture(),this.uniforms={glyphTexture:{value:null},picking:{value:!1}},this.material=new uf.ShaderMaterial({uniforms:this.uniforms,transparent:!0,vertexShader:dvt(r,s),fragmentShader:pvt}),this.processLabelVerts(i),this.createColorBuffers(i);var o=new Float32Array(this.totalVertexCount*no.XYZ_NUM_ELEMENTS);this.positions=new uf.BufferAttribute(o,no.XYZ_NUM_ELEMENTS);var a=new Float32Array(this.totalVertexCount*no.XYZ_NUM_ELEMENTS),l=new Float32Array(this.totalVertexCount*no.UV_NUM_ELEMENTS),c=new Float32Array(this.totalVertexCount*no.RGB_NUM_ELEMENTS),u=new uf.BufferAttribute(a,2),h=new uf.BufferAttribute(l,no.UV_NUM_ELEMENTS),f=new uf.BufferAttribute(c,no.RGB_NUM_ELEMENTS);this.geometry=new uf.BufferGeometry,this.geometry.setAttribute("posObj",u),this.geometry.setAttribute("position",this.positions),this.geometry.setAttribute("uv",h),this.geometry.setAttribute("color",f);for(var d=0,p=0;p<i;p++){for(var m=this.labelStrings[p],g=0,y=0;y<m.length;y++){var b=m.charCodeAt(y);g+=this.glyphTexture.lengths[b]}g/=-2;for(var y=0;y<m.length;y++){var b=m.charCodeAt(y),x=this.glyphTexture.lengths[b],w=r,_=(g+x)/w,C=g/w,k=r/w;u.setXY(d*aa+0,C,0),u.setXY(d*aa+1,_,0),u.setXY(d*aa+2,C,k),u.setXY(d*aa+3,C,k),u.setXY(d*aa+4,_,0),u.setXY(d*aa+5,_,k);var A=this.glyphTexture.offsets[b],M=this.glyphTexture.offsets[b]+x;A/=LP,M/=LP;var I=1,N=0;h.setXY(d*aa+0,A,I),h.setXY(d*aa+1,M,I),h.setXY(d*aa+2,A,N),h.setXY(d*aa+3,A,N),h.setXY(d*aa+4,M,I),h.setXY(d*aa+5,M,N),d++,g+=x}}for(var O=function(D){var z=wq.vector3FromPackedArray(R.worldSpacePointPositions,D);R.labelVertexMap[D].forEach(function(B){e.positions.setXYZ(B,z.x,z.y,z.z)})},R=this,p=0;p<i;p++)O(p);this.labelsMesh=new uf.Mesh(this.geometry,this.material),this.labelsMesh.frustumCulled=!1,this.scene.add(this.labelsMesh)}}},n.prototype.colorLabels=function(e){if(!(this.labelStrings==null||this.geometry==null||e==null)){var t=this.geometry.getAttribute("color");t.array=this.renderColors;for(var r=e.length/no.RGBA_NUM_ELEMENTS,s=0,i=0;i<r;++i){for(var o=new uf.Color(e[s],e[s+1],e[s+2]),a=this.labelVertexMap[i].length,l=0;l<a;++l)t.setXYZ(this.labelVertexMap[i][l],o.r,o.g,o.b);s+=no.RGBA_NUM_ELEMENTS}t.needsUpdate=!0}},n.prototype.setScene=function(e){this.scene=e},n.prototype.dispose=function(){this.labelsMesh&&(this.scene&&this.scene.remove(this.labelsMesh),this.labelsMesh=null),this.geometry&&(this.geometry.dispose(),this.geometry=null),this.glyphTexture!=null&&this.glyphTexture.texture!=null&&(this.glyphTexture.texture.dispose(),this.glyphTexture.texture=null)},n.prototype.onPickingRender=function(e){if(this.geometry==null){this.createLabels();return}this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!0;var t=this.geometry.getAttribute("color");t.array=this.pickingColors,t.needsUpdate=!0},n.prototype.onRender=function(e){if(this.geometry==null){this.createLabels();return}this.colorLabels(e.pointColors),this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!1;var t=this.geometry.getAttribute("color");t.array=this.renderColors,t.needsUpdate=!0},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.dispose()},n.prototype.setLabelStrings=function(e){this.labelStrings=e,this.dispose()},n.prototype.onResize=function(e,t){},n}();EV.ScatterPlotVisualizer3DLabels=mvt;var IV={};Object.defineProperty(IV,"__esModule",{value:!0});var Po=Jy,gvt=GC,xq=Ki,rc=Wu,Sq=function(n){return`
    // Index of the specific vertex (passed in as bufferAttribute), and the
    // variable that will be used to pass it to the fragment shader.
    attribute float spriteIndex;
    attribute vec4 color;
    attribute float scaleFactor;

    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform bool sizeAttenuation;
    uniform float pointSize;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;

    varying float fogDepth;

    void main() {
      // Pass index and color values to fragment shader.
      vColor = color;
      xyIndex = vec2(mod(spriteIndex, spritesPerRow),
                floor(spriteIndex / spritesPerColumn));

      // Transform current vertex by modelViewMatrix (model world position and
      // camera world position matrix).
      vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);

      // Project vertex in camera-space to screen coordinates using the camera's
      // projection matrix.
      gl_Position = projectionMatrix * cameraSpacePos;

      // Create size attenuation (if we're in 3D mode) by making the size of
      // each point inversly proportional to its distance to the camera.
      float outputPointSize = pointSize;
      if (sizeAttenuation) {
        outputPointSize = -pointSize / cameraSpacePos.z;
        fogDepth = pointSize / outputPointSize * 1.2;
      } else {  // Create size attenuation (if we're in 2D mode)
        const float PI = 3.1415926535897932384626433832795;
        const float minScale = 0.1;  // minimum scaling factor
        const float outSpeed = 2.0;  // shrink speed when zooming out
        const float outNorm = (1. - minScale) / atan(outSpeed);
        const float maxScale = 15.0;  // maximum scaling factor
        const float inSpeed = 0.02;  // enlarge speed when zooming in
        const float zoomOffset = 0.3;  // offset zoom pivot
        float zoom = projectionMatrix[0][0] + zoomOffset;  // zoom pivot
        float scale = zoom < 1. ? 1. + outNorm * atan(outSpeed * (zoom - 1.)) :
                      1. + 2. / PI * (maxScale - 1.) * atan(inSpeed * (zoom - 1.));
        outputPointSize = pointSize * scale;
      }

      gl_PointSize =
        max(outputPointSize * scaleFactor, `+n.toFixed(1)+`);
    }`},Ple=`
    bool point_in_unit_circle(vec2 spriteCoord) {
      vec2 centerToP = spriteCoord - vec2(0.5, 0.5);
      return dot(centerToP, centerToP) < (0.5 * 0.5);
    }

    bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {
      vec3 v0 = vec3(0, 1, 0);
      vec3 v1 = vec3(0.5, 0, 0);
      vec3 v2 = vec3(1, 1, 0);
      vec3 p = vec3(spriteCoord, 0);
      float p_in_v0_v1 = cross(v1 - v0, p - v0).z;
      float p_in_v1_v2 = cross(v2 - v1, p - v1).z;
      return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);
    }

    bool point_in_unit_square(vec2 spriteCoord) {
      return true;
    }
  `,yvt=`
    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform sampler2D spriteTexture;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;
    uniform bool isImage;

    `+Po.ShaderChunk.common+`
    `+Ple+`
    uniform vec3 fogColor;
    varying float fogDepth;
		uniform float fogNear;
    uniform float fogFar;

    void main() {
      if (isImage) {
        // Coordinates of the vertex within the entire sprite image.
        vec2 coords =
          (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);
        gl_FragColor = vColor * texture(spriteTexture, coords);
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
      float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    }`,bvt=`
    varying vec2 xyIndex;
    varying vec4 vColor;
    uniform bool isImage;

    `+Ple+`

    varying float fogDepth;

    void main() {
      xyIndex; // Silence 'unused variable' warning.
      fogDepth; // Silence 'unused variable' warning.
      if (isImage) {
        gl_FragColor = vColor;
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
    }`,vvt=function(){function n(e,t){this.styles=e,this.id="SPRITES",this.isSpriteSheetMode=!1,this.spritesPerRow=0,this.spritesPerColumn=0,this.spriteDimensions=[0,0],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.standinTextureForPoints=xq.createTextureFromCanvas(document.createElement("canvas")),t&&(this.spriteSheetParams=t,this.setSpriteSheet(t),this.isSpriteSheetMode=!0),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial()}return n.prototype.createUniforms=function(){return{spriteTexture:{type:"t"},spritesPerRow:{type:"f"},spritesPerColumn:{type:"f"},fogColor:{type:"c"},fogNear:{type:"f"},fogFar:{type:"f"},isImage:{type:"bool"},sizeAttenuation:{type:"bool"},pointSize:{type:"f"}}},n.prototype.createRenderMaterial=function(){this.isSpriteSheetMode;var e=this.createUniforms();return new Po.ShaderMaterial({uniforms:e,vertexShader:Sq(this.styles.sprites.minPointSize),fragmentShader:yvt,transparent:!0,depthFunc:Po.LessDepth,fog:this.styles.fog.enabled,blending:Po.NormalBlending})},n.prototype.createPickingMaterial=function(){var e=this.createUniforms();return new Po.ShaderMaterial({uniforms:e,vertexShader:Sq(this.styles.sprites.minPointSize),fragmentShader:bvt,transparent:!0,depthTest:!0,depthWrite:!0,fog:!1,blending:Po.NormalBlending})},n.prototype.createPointSprites=function(e,t){var r=t!=null?t.length/rc.XYZ_NUM_ELEMENTS:0,s=this.createGeometry(r);this.fog=new Po.Fog(16777215),this.points=new Po.Points(s,this.renderMaterial),this.points.frustumCulled=!1,this.spriteIndexBufferAttribute!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute),e.add(this.points)},n.prototype.calculatePointSize=function(e){var t=this.styles.sprites.imageSize;if(this.texture)return e?t:this.spriteDimensions[0];var r=this.worldSpacePointPositions!=null?this.worldSpacePointPositions.length/rc.XYZ_NUM_ELEMENTS:1,s=200,i=8,o=1.5,a=s/Math.log(r)/Math.log(i);return e?a:a/o},n.prototype.createGeometry=function(e){var t=e;this.pickingColors=new Float32Array(t*rc.RGBA_NUM_ELEMENTS);for(var r=0,s=0;s<t;s++){var i=new Po.Color(s);this.pickingColors[r++]=i.r,this.pickingColors[r++]=i.g,this.pickingColors[r++]=i.b,this.pickingColors[r++]=1}var o=new Po.BufferGeometry;return o.setAttribute("position",new Po.BufferAttribute(new Float32Array([]),rc.XYZ_NUM_ELEMENTS)),o.setAttribute("color",new Po.BufferAttribute(new Float32Array([]),rc.RGBA_NUM_ELEMENTS)),o.setAttribute("scaleFactor",new Po.BufferAttribute(new Float32Array([]),rc.INDEX_NUM_ELEMENTS)),o.computeVertexNormals(),o},n.prototype.setFogDistances=function(e,t,r){var s=this.styles.fog,i=s.threshold,o=s.enabled;if(e&&o){this.fog.near=t;var a=t-r;this.fog.far=t-i*a}else this.fog.near=1/0,this.fog.far=1/0},n.prototype.dispose=function(){this.disposeGeometry(),this.disposeSpriteSheet()},n.prototype.disposeGeometry=function(){this.points!=null&&(this.scene.remove(this.points),this.points.geometry.dispose(),this.points=null,this.worldSpacePointPositions=null)},n.prototype.disposeSpriteSheet=function(){this.texture&&this.texture.dispose(),this.texture=null,this.renderMaterial=null,this.pickingMaterial=null,this.spriteSheetImage=null},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSpriteSheet=function(e){var t=this,r=e.spriteDimensions,s=e.onImageLoad,i=e.spritesheetImage;if(typeof i=="string"){var o=i;i=new Image,i.src=o}this.spriteSheetImage=i,this.texture=xq.createTextureFromImage(this.spriteSheetImage,function(){t.spritesPerRow=t.spriteSheetImage.width/r[0],t.spritesPerColumn=t.spriteSheetImage.height/r[1],s()}),this.spriteDimensions=r,this.setSpriteIndexBuffer()},n.prototype.setSpriteIndexBuffer=function(){var e=this.spriteSheetParams.spriteIndices;this.spriteIndexBufferAttribute=new Po.BufferAttribute(e,rc.INDEX_NUM_ELEMENTS),this.points!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute)},n.prototype.onPointPositionsChanged=function(e){this.points!=null&&this.worldSpacePointPositions.length!==e.length&&this.disposeGeometry(),this.worldSpacePointPositions=e,this.points==null&&this.createPointSprites(this.scene,e),this.spriteSheetParams&&this.setSpriteIndexBuffer(),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial();var t=this.points.geometry.getAttribute("position");t.array=e,t.count=e.length/rc.XYZ_NUM_ELEMENTS,t.needsUpdate=!0},n.prototype.onPickingRender=function(e){var t=e.cameraType===gvt.CameraType.Perspective;this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerColumn,this.pickingMaterial.uniforms.sizeAttenuation.value=t,this.pickingMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.pickingMaterial;var r=this.points.geometry.getAttribute("color");r.array=this.pickingColors,r.count=this.pickingColors.length/rc.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var s=this.points.geometry.getAttribute("scaleFactor");s.array=e.pointScaleFactors,s.count=e.pointScaleFactors.length,s.count=e.pointScaleFactors.length/rc.INDEX_NUM_ELEMENTS,s.needsUpdate=!0},n.prototype.onRender=function(e){var t=e.camera instanceof Po.PerspectiveCamera;this.setFogDistances(t,e.nearestCameraSpacePointZ,e.farthestCameraSpacePointZ),this.scene.fog=this.fog,this.scene.fog.color=new Po.Color(e.backgroundColor),this.renderMaterial.uniforms.fogColor.value=this.scene.fog.color,this.renderMaterial.uniforms.fogNear.value=this.fog.near,this.renderMaterial.uniforms.fogFar.value=this.fog.far,this.renderMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.renderMaterial.uniforms.spritesPerColumn.value=this.spritesPerColumn,this.renderMaterial.uniforms.isImage.value=this.texture!=null,this.renderMaterial.uniforms.spriteTexture.value=this.texture!=null?this.texture:this.standinTextureForPoints,this.renderMaterial.uniforms.sizeAttenuation.value=t,this.renderMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.renderMaterial;var r=this.points.geometry.getAttribute("color");this.renderColors=e.pointColors,r.array=this.renderColors,r.count=this.renderColors.length/rc.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var s=this.points.geometry.getAttribute("scaleFactor");s.array=e.pointScaleFactors,s.count=e.pointScaleFactors.length/rc.INDEX_NUM_ELEMENTS,s.needsUpdate=!0},n.prototype.onResize=function(e,t){},n}();IV.ScatterPlotVisualizerSprites=vvt;var AV={},MV={};Object.defineProperty(MV,"__esModule",{value:!0});var wvt=function(){function n(e,t,r){this.bound=e,this.cellWidth=t,this.cellHeight=r,this.numHorizCells=Math.ceil(this.boundWidth(e)/t),this.numVertCells=Math.ceil(this.boundHeight(e)/r),this.grid=new Array(this.numHorizCells*this.numVertCells)}return n.prototype.boundWidth=function(e){return e.hiX-e.loX},n.prototype.boundHeight=function(e){return e.hiY-e.loY},n.prototype.boundsIntersect=function(e,t){return!(e.loX>t.hiX||e.loY>t.hiY||e.hiX<t.loX||e.hiY<t.loY)},n.prototype.insert=function(e,t){if(t===void 0&&(t=!1),e.hiX<this.bound.loX||e.loX>this.bound.hiX||e.hiY<this.bound.loY||e.loY>this.bound.hiY)return!1;for(var r=this.getCellX(e.loX),s=this.getCellX(e.hiX),i=this.getCellY(e.loY),o=this.getCellY(e.hiY),a=i*this.numHorizCells+r,l=a,c=i;c<=o;c++){for(var u=r;u<=s;u++){var h=this.grid[l++];if(h){for(var f=0;f<h.length;f++)if(this.boundsIntersect(e,h[f]))return!1}}l+=this.numHorizCells-(s-r+1)}if(t)return!0;l=a;for(var c=i;c<=o;c++){for(var u=r;u<=s;u++)this.grid[l]?this.grid[l].push(e):this.grid[l]=[e],l++;l+=this.numHorizCells-(s-r+1)}return!0},n.prototype.getCellX=function(e){return Math.floor((e-this.bound.loX)/this.cellWidth)},n.prototype.getCellY=function(e){return Math.floor((e-this.bound.loY)/this.cellHeight)},n}();MV.CollisionGrid=wvt;var xvt=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i};Object.defineProperty(AV,"__esModule",{value:!0});var Svt=Jy,_vt=GC,Cvt=MV,BP=Ki,kvt=1e4,Tvt=function(){function n(e,t){this.styles=t,this.id="CANVAS_LABELS",this.worldSpacePointPositions=new Float32Array(0),this.labelsActive=!0,this.canvas=document.createElement("canvas"),e.appendChild(this.canvas),this.gc=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0",this.canvas.style.pointerEvents="none"}return n.prototype.removeAllLabels=function(){var e=this.canvas.width*window.devicePixelRatio,t=this.canvas.height*window.devicePixelRatio;this.gc.clearRect(0,0,e,t)},n.prototype.makeLabels=function(e){if(!(e.labels==null||e.labels.pointIndices.length===0)&&this.worldSpacePointPositions!=null){var t=e.labels,r=e.cameraType===_vt.CameraType.Perspective,s=parseInt(this.gc.font,10),i=window.devicePixelRatio,o;{var a=this.canvas.width*i,l=this.canvas.height*i,c={loX:0,hiX:a,loY:0,hiY:l};o=new Cvt.CollisionGrid(c,a/25,l/50)}var u=[e.farthestCameraSpacePointZ,e.nearestCameraSpacePointZ],h=function(O){return BP.scaleExponential(O,u,[.1,1])},f=e.camera.position,d=f.clone().sub(e.cameraTarget),p=new Svt.Vector3;this.gc.textBaseline="middle",this.gc.miterLimit=2;for(var m=2,g=4,y=Math.min(kvt,t.pointIndices.length),b=0;b<y;++b){var x=void 0;{var w=t.pointIndices[b];x=BP.vector3FromPackedArray(this.worldSpacePointPositions,w)}if(p.copy(f).sub(x),!(d.dot(p)<0)){var _=xvt(BP.vector3DToScreenCoords(e.camera,e.screenWidth,e.screenHeight,x),2),C=_[0],k=_[1];C+=g;var A={loX:C-m,hiX:C+1+m,loY:k-s/2-m,hiY:k+s/2+m};if(o.insert(A,!0)){var M=t.labelStrings[b],I=t.defaultFontSize*t.scaleFactors[b]*i;if(this.gc.font=I+"px roboto",A.hiX+=this.gc.measureText(M).width-1,o.insert(A)){var N=1;r&&t.useSceneOpacityFlags[b]===1&&(N=h(p.length())),this.gc.fillStyle=this.styleStringFromPackedRgba(t.fillColors,b,N),this.gc.strokeStyle=this.styleStringFromPackedRgba(t.strokeColors,b,N),this.gc.lineWidth=this.styles.label.strokeWidth,this.gc.strokeText(M,C,k),this.gc.lineWidth=this.styles.label.fillWidth,this.gc.fillText(M,C,k)}}}}}},n.prototype.styleStringFromPackedRgba=function(e,t,r){var s=t*3,i=e[s],o=e[s+1],a=e[s+2];return"rgba("+i+","+o+","+a+","+r+")"},n.prototype.onResize=function(e,t){var r=window.devicePixelRatio;this.canvas.width=e*r,this.canvas.height=t*r,this.canvas.style.width=e+"px",this.canvas.style.height=t+"px"},n.prototype.dispose=function(){this.removeAllLabels()},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.removeAllLabels()},n.prototype.onRender=function(e){this.labelsActive&&(this.removeAllLabels(),this.makeLabels(e))},n.prototype.setScene=function(e){},n.prototype.onPickingRender=function(e){},n}();AV.ScatterPlotVisualizerCanvasLabels=Tvt;var NV={},_q=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(NV,"__esModule",{value:!0});var l1=Jy,Cq=Ki,wE=Wu,Evt=function(){function n(){this.id="POLYLINES",this.sequences=[],this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={},this.pointSequenceIndices=new Map}return n.prototype.getPointSequenceIndex=function(e){return this.pointSequenceIndices.get(e)},n.prototype.updateSequenceIndices=function(){for(var e=0;e<this.sequences.length;e++)for(var t=this.sequences[e],r=0;r<t.indices.length-1;r++){var s=t.indices[r];this.pointSequenceIndices.set(s,e),this.pointSequenceIndices.set(s+1,e)}},n.prototype.createPolylines=function(){var e,t;this.updateSequenceIndices();try{for(var r=_q(this.polylines),s=r.next();!s.done;s=r.next()){var i=s.value;this.scene.remove(i),i.geometry.dispose()}}catch(c){e={error:c}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[];for(var o=0;o<this.sequences.length;o++){var a=new l1.BufferGeometry;a.addAttribute("position",this.polylinePositionBuffer[o]),a.addAttribute("color",this.polylineColorBuffer[o]);var l=new l1.LineBasicMaterial({linewidth:1,opacity:1,transparent:!0,vertexColors:!0}),i=new l1.LineSegments(a,l);i.frustumCulled=!1,this.polylines.push(i),this.scene.add(i)}},n.prototype.dispose=function(){var e,t;try{for(var r=_q(this.polylines),s=r.next();!s.done;s=r.next()){var i=s.value;this.scene.remove(i),i.geometry.dispose()}}catch(o){e={error:o}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={}},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSequences=function(e){this.sequences=e},n.prototype.onPointPositionsChanged=function(e){if(e==null&&this.dispose(),!(e==null||this.sequences.length===0)){for(var t=0;t<this.sequences.length;t++){var r=this.sequences[t],s=2*(r.indices.length-1),i=new Float32Array(s*wE.XYZ_NUM_ELEMENTS);this.polylinePositionBuffer[t]=new l1.BufferAttribute(i,wE.XYZ_NUM_ELEMENTS);var o=new Float32Array(s*wE.RGBA_NUM_ELEMENTS);this.polylineColorBuffer[t]=new l1.BufferAttribute(o,wE.RGBA_NUM_ELEMENTS)}for(var t=0;t<this.sequences.length;t++){for(var r=this.sequences[t],a=0,l=0;l<r.indices.length-1;l++){var c=r.indices[l],u=r.indices[l+1],h=Cq.vector3FromPackedArray(e,c),f=Cq.vector3FromPackedArray(e,u);this.polylinePositionBuffer[t].setXYZ(a,h.x,h.y,h.z),this.polylinePositionBuffer[t].setXYZ(a+1,f.x,f.y,f.z),a+=2}this.polylinePositionBuffer[t].needsUpdate=!0}this.createPolylines()}},n.prototype.onRender=function(e){for(var t=0;t<this.polylines.length;t++){var r=this.polylines[t].material;r.opacity=e.polylineOpacities[t],r.linewidth=e.polylineWidths[t],this.polylineColorBuffer[t].array=e.polylineColors[t],this.polylineColorBuffer[t].needsUpdate=!0}},n.prototype.onPickingRender=function(e){},n.prototype.onResize=function(e,t){},n}();NV.ScatterPlotVisualizerPolylines=Evt;var Ivt=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},VP=mt&&mt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(Ivt(arguments[e]));return n},kq=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(j4,"__esModule",{value:!0});var Avt=q4,mm=kV,Mvt=P$,Nvt=GC,$vt=TV,Ro=Ki,xE=Wu,Rvt=EV,Tq=IV,Pvt=AV,Dvt=NV,Ovt=function(){function n(e,t){var r=this;t===void 0&&(t={}),this.pointColorer=null,this.sequences=[],this.renderMode="POINT",this.rotateOnStart=!0,this.selectEnabled=!0,this.showLabelsOnHover=!0,this.hoverPointIndex=null,this.selectedPointIndices=new Set,this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.cameraMoveCallback=function(){},this.onHover=function(s){r.hoverCallback(s),r.hoverPointIndex=s,r.updateScatterPlotAttributes(),r.renderScatterPlot()},this.onClick=function(s){r.clickCallback(s)},this.select=function(s){r.selectEnabled&&(r.selectedPointIndices=new Set(s),r.updateScatterPlotAttributes(),r.renderScatterPlot())},this.onSelect=function(s){r.selectEnabled&&(r.selectCallback(s),r.select(s))},this.containerElement=e,this.styles=$vt.makeStyles(t.styles),this.setParameters(t),this.scatterPlot=new Avt.ScatterPlot(e,{camera:t.camera,onClick:this.onClick,onHover:this.onHover,onSelect:this.onSelect,selectEnabled:this.selectEnabled,styles:this.styles,orbitControlParams:t.orbitControls}),this.scatterPlot.onCameraMove(this.cameraMoveCallback)}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.onCameraMove!==void 0&&(this.cameraMoveCallback=e.onCameraMove),e.pointColorer!==void 0&&(this.pointColorer=e.pointColorer),e.renderMode!==void 0&&(this.renderMode=e.renderMode),e.rotateOnStart!==void 0&&(this.rotateOnStart=e.rotateOnStart),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled),e.showLabelsOnHover!==void 0&&(this.showLabelsOnHover=e.showLabelsOnHover)},n.prototype.render=function(e){this.updateDataset(e),this.clearVisualizers(),this.setVisualizers(),this.rotateOnStart&&this.scatterPlot.startOrbitAnimation()},n.prototype.clearVisualizers=function(){this.canvasLabelsVisualizer=void 0,this.labels3DVisualizer=void 0,this.pointVisualizer=void 0,this.polylineVisualizer=void 0,this.spritesheetVisualizer=void 0,this.scatterPlot.disposeAllVisualizers()},n.prototype.renderScatterPlot=function(){this.dataset&&this.scatterPlot.render()},n.prototype.resetZoom=function(){this.scatterPlot.resetZoom()},n.prototype.setRenderMode=function(e){this.renderMode=e,this.setVisualizers(),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions()},n.prototype.setTextRenderMode=function(){this.setRenderMode("TEXT"),this.renderScatterPlot()},n.prototype.setPointRenderMode=function(){this.setRenderMode("POINT"),this.renderScatterPlot()},n.prototype.setSpriteRenderMode=function(){this.dataset&&this.dataset.spriteMetadata&&(this.setRenderMode("SPRITE"),this.renderScatterPlot())},n.prototype.setSequences=function(e){this.sequences=e,this.updatePolylineAttributes(),this.setVisualizers(),this.renderScatterPlot()},n.prototype.setPanMode=function(){this.scatterPlot.setInteractionMode("PAN")},n.prototype.setSelectMode=function(){this.scatterPlot.setInteractionMode("SELECT")},n.prototype.setDimensions=function(e){var t=e<2||e>3,r=this.dataset&&e>this.dataset.dimensions;if(t||r)throw new RangeError("Setting invalid dimensionality");this.scatterPlot.setDimensions(e),this.renderScatterPlot()},n.prototype.setPointColorer=function(e){this.pointColorer=e,this.updateScatterPlotAttributes(),this.renderScatterPlot()},n.prototype.callPointColorer=function(e,t){return e(t,this.selectedPointIndices,this.hoverPointIndex)},n.prototype.setHoverPointIndex=function(e){this.hoverPointIndex=e,this.updateScatterPlotAttributes(),!this.scatterPlot.orbitIsAnimating()&&this.renderScatterPlot()},n.prototype.resize=function(){this.scatterPlot.resize()},n.prototype.updateDataset=function(e){this.setDataset(e),this.scatterPlot.setDimensions(e.dimensions),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions(),this.renderScatterPlot()},n.prototype.isOrbiting=function(){return this.scatterPlot.orbitIsAnimating()},n.prototype.startOrbitAnimation=function(){this.scatterPlot.startOrbitAnimation()},n.prototype.stopOrbitAnimation=function(){this.scatterPlot.stopOrbitAnimation()},n.prototype.setDataset=function(e){this.dataset=e,this.labels3DVisualizer&&this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray())},n.prototype.updateScatterPlotPositions=function(){var e=this.dataset;if(e){var t=this.generatePointPositionArray(e);this.scatterPlot.setPointPositions(t)}},n.prototype.updateScatterPlotAttributes=function(){var e=this.dataset;if(e){var t=this.generatePointColorArray(e),r=this.generatePointScaleFactorArray(e),s=this.generateVisibleLabelRenderParams();this.scatterPlot.setPointColors(t),this.scatterPlot.setPointScaleFactors(r),this.scatterPlot.setLabels(s)}},n.prototype.updatePolylineAttributes=function(){var e=this.dataset;if(e){var t=this.generateLineSegmentColorMap(e),r=this.generateLineSegmentOpacityArray(e),s=this.generateLineSegmentWidthArray(e);this.scatterPlot.setPolylineColors(t),this.scatterPlot.setPolylineOpacities(r),this.scatterPlot.setPolylineWidths(s)}},n.prototype.generatePointPositionArray=function(e){var t=[0,0],r=[0,0],s=[0,0];t=Ro.extent(e.points.map(function(y){return y[0]})),r=Ro.extent(e.points.map(function(y){return y[1]})),e.dimensions===3&&(s=Ro.extent(e.points.map(function(y){return y[2]})));var i=function(y){return Math.abs(y[1]-y[0])},o=i(t),a=i(r),l=i(s),c=Math.max(o,a,l),u=xE.SCATTER_PLOT_CUBE_LENGTH/2,h=function(y,b){return[-b*(y/c),b*(y/c)]},f=h(o,u),d=h(a,u),p=h(l,u),m=new Float32Array(e.points.length*3),g=0;return e.points.forEach(function(y,b){var x=e.points[b];m[g++]=Ro.scaleLinear(x[0],t,f),m[g++]=Ro.scaleLinear(x[1],r,d),e.dimensions===3?m[g++]=Ro.scaleLinear(x[2],s,p):m[g++]=0}),m},n.prototype.generateVisibleLabelRenderParams=function(){var e=this,t=e.hoverPointIndex,r=e.selectedPointIndices,s=e.styles,i=t!==null?1:0,o=new Uint32Array(i),a=new Float32Array(i),l=new Int8Array(i),c=new Uint8Array(i*3),u=new Uint8Array(i*3),h=[];a.fill(s.label.scaleDefault),l.fill(1);var f=0;if(t!==null){h.push(this.getLabelText(t)),o[f]=t,a[f]=s.label.scaleLarge,l[f]=0;var d=Ro.styleRgbFromHexColor(s.label.fillColorHover);Ro.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]);var p=Ro.styleRgbFromHexColor(s.label.strokeColorHover);Ro.packRgbIntoUint8Array(u,f,p[0],p[1],p[1]),++f}{var d=Ro.styleRgbFromHexColor(s.label.fillColorSelected),p=Ro.styleRgbFromHexColor(s.label.strokeColorSelected);if(r.size===1){var m=VP(r)[0];h.push(this.getLabelText(m)),o[f]=m,a[f]=s.label.scaleLarge,l[f]=0,Ro.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]),Ro.packRgbIntoUint8Array(u,f,p[0],p[1],p[2])}}return new Nvt.LabelRenderParams(new Float32Array(o),h,a,l,s.label.fontSize,c,u)},n.prototype.generatePointScaleFactorArray=function(e){var t,r,s=this,i=s.hoverPointIndex,o=s.selectedPointIndices,a=s.styles,l=a.point,c=l.scaleDefault,u=l.scaleSelected,h=l.scaleHover,f=new Float32Array(e.points.length);f.fill(c),o.size;try{for(var d=kq(o.values()),p=d.next();!p.done;p=d.next()){var m=p.value;f[m]=u}}catch(g){t={error:g}}finally{try{p&&!p.done&&(r=d.return)&&r.call(d)}finally{if(t)throw t.error}}return i!=null&&(f[i]=h),f},n.prototype.generatePointColorArray=function(e){var t,r,s=this,i=s.hoverPointIndex,o=s.pointColorer,a=s.selectedPointIndices,l=s.styles,c=l.point,u=c.colorHover,h=c.colorNoSelection,f=c.colorSelected,d=c.colorUnselected,p=new Float32Array(e.points.length*xE.RGBA_NUM_ELEMENTS),m=d,g=h;this.renderMode==="TEXT"&&(m=this.styles.label3D.colorUnselected,g=this.styles.label3D.colorNoSelection),this.renderMode==="SPRITE"&&(m=this.styles.sprites.colorUnselected,g=this.styles.sprites.colorNoSelection);var y=e.points.length,b=this.selectedPointIndices.size;if(o)for(var x=0,w=0;w<y;++w){var _=mm.parseColor(this.callPointColorer(o,w)||g);p[x++]=_.r,p[x++]=_.g,p[x++]=_.b,p[x++]=_.opacity}else{for(var x=0,_=b>0?mm.parseColor(m):mm.parseColor(g),w=0;w<y;++w)p[x++]=_.r,p[x++]=_.g,p[x++]=_.b,p[x++]=_.opacity;_=mm.parseColor(f);try{for(var C=kq(a.values()),k=C.next();!k.done;k=C.next()){var A=k.value,M=A*xE.RGBA_NUM_ELEMENTS;p[M++]=_.r,p[M++]=_.g,p[M++]=_.b,p[M++]=_.opacity}}catch(D){t={error:D}}finally{try{k&&!k.done&&(r=C.return)&&r.call(C)}finally{if(t)throw t.error}}if(i!=null){var I=mm.parseColor(u),N=i*xE.RGBA_NUM_ELEMENTS;p[N++]=I.r,p[N++]=I.g,p[N++]=I.b,p[N++]=I.opacity}}return p},n.prototype.generate3DLabelsArray=function(){var e=this.dataset;if(!e)return[];for(var t=[],r=e.points.length,s=0;s<r;++s)t.push(this.getLabelText(s));return t},n.prototype.generateLineSegmentColorMap=function(e){for(var t=this,r=t.pointColorer,s=t.styles,i={},o=0;o<this.sequences.length;o++){var a=this.sequences[o],l=new Float32Array(2*(a.indices.length-1)*3),c=0;if(r)for(var u=0;u<a.indices.length-1;u++){var h=mm.parseColor(this.callPointColorer(r,a.indices[u])),f=mm.parseColor(this.callPointColorer(r,a.indices[u+1]));l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}else for(var u=0;u<a.indices.length-1;u++){var h=Ro.getDefaultPointInPolylineColor(u,a.indices.length,s.polyline.startHue,s.polyline.endHue,s.polyline.saturation,s.polyline.lightness),f=Ro.getDefaultPointInPolylineColor(u+1,a.indices.length,s.polyline.startHue,s.polyline.endHue,s.polyline.saturation,s.polyline.lightness);l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}i[o]=l}return i},n.prototype.generateLineSegmentOpacityArray=function(e){var t=this,r=t.selectedPointIndices,s=t.styles,i=new Float32Array(this.sequences.length),o=r.size;if(o>0){i.fill(s.polyline.deselectedOpacity);var a=this.polylineVisualizer.getPointSequenceIndex(VP(r)[0]);a!==void 0&&(i[a]=s.polyline.selectedOpacity)}else i.fill(s.polyline.defaultOpacity);return i},n.prototype.generateLineSegmentWidthArray=function(e){var t=this,r=t.selectedPointIndices,s=t.styles,i=new Float32Array(this.sequences.length);i.fill(s.polyline.defaultLineWidth);var o=r.size;if(o>0){var a=this.polylineVisualizer.getPointSequenceIndex(VP(r)[0]);a!==void 0&&(i[a]=s.polyline.selectedLineWidth)}return i},n.prototype.getLabelText=function(e){var t=this.dataset;if(!t)return"";var r=t.metadata[e];return r&&r.label!=null?""+r.label:""},n.prototype.initializeCanvasLabelsVisualizer=function(){return this.canvasLabelsVisualizer||(this.canvasLabelsVisualizer=new Pvt.ScatterPlotVisualizerCanvasLabels(this.containerElement,this.styles)),this.canvasLabelsVisualizer},n.prototype.initialize3DLabelsVisualizer=function(){return this.labels3DVisualizer||(this.labels3DVisualizer=new Rvt.ScatterPlotVisualizer3DLabels(this.styles)),this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray()),this.labels3DVisualizer},n.prototype.initializePointVisualizer=function(){return this.pointVisualizer||(this.pointVisualizer=new Tq.ScatterPlotVisualizerSprites(this.styles)),this.pointVisualizer},n.prototype.initializeSpritesheetVisualizer=function(){var e=this,t=this.styles,r=this.dataset,s=r.spriteMetadata;if(!this.spritesheetVisualizer&&s){if(!s.spriteImage||!s.singleSpriteSize)return;var i=r.points.length,o=void 0;if(s.spriteIndices)o=new Float32Array(s.spriteIndices);else{o=new Float32Array(i);for(var a=0;a<i;++a)o[a]=a}var l=function(){return e.renderScatterPlot()},c=new Tq.ScatterPlotVisualizerSprites(t,{spritesheetImage:s.spriteImage,spriteDimensions:s.singleSpriteSize,spriteIndices:o,onImageLoad:l});c.id="SPRITE_SHEET_VISUALIZER",this.spritesheetVisualizer=c}return this.spritesheetVisualizer},n.prototype.initializePolylineVisualizer=function(){return this.polylineVisualizer||(this.polylineVisualizer=new Dvt.ScatterPlotVisualizerPolylines),this.polylineVisualizer.setSequences(this.sequences),this.polylineVisualizer},n.prototype.setVisualizers=function(){var e=this,t=e.dataset,r=e.renderMode,s=[];if(r==="TEXT"){var i=this.initialize3DLabelsVisualizer();s.push(i)}else if(r==="POINT"){var i=this.initializePointVisualizer();s.push(i)}else if(r==="SPRITE"&&t.spriteMetadata){var i=this.initializeSpritesheetVisualizer();i&&s.push(i)}if(this.sequences.length>0){var i=this.initializePolylineVisualizer();s.push(i)}var o=r==="POINT"||r==="SPRITE";if(o&&this.showLabelsOnHover){var i=this.initializeCanvasLabelsVisualizer();s.push(i)}this.scatterPlot.setActiveVisualizers(s)},n.Dataset=Mvt.Dataset,n}();j4.ScatterGL=Ovt;Object.defineProperty(H4,"__esModule",{value:!0});var Fvt=j4;H4.ScatterGL=Fvt.ScatterGL;var Lvt=P$;H4.Dataset=Lvt.Dataset;var Dle={},Yf={},Fh={},hi={},zvt=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}};Object.defineProperty(hi,"__esModule",{value:!0});function Ole(n,e){return Math.floor(e()*n)}hi.tauRandInt=Ole;function Bvt(n){return n()}hi.tauRand=Bvt;function Vvt(n){var e,t,r=0;try{for(var s=zvt(n),i=s.next();!i.done;i=s.next()){var o=i.value;r+=Math.pow(o,2)}}catch(a){e={error:a}}finally{try{i&&!i.done&&(t=s.return)&&t.call(s)}finally{if(e)throw e.error}}return Math.sqrt(r)}hi.norm=Vvt;function D$(n){for(var e=[],t=0;t<n;t++)e.push(void 0);return e}hi.empty=D$;function Uvt(n){return D$(n).map(function(e,t){return t})}hi.range=Uvt;function $V(n,e){return D$(n).map(function(){return e})}hi.filled=$V;function Fle(n){return $V(n,0)}hi.zeros=Fle;function Wvt(n){return $V(n,1)}hi.ones=Wvt;function Gvt(n,e,t){return D$(t).map(function(r,s){return n+s*((e-n)/(t-1))})}hi.linear=Gvt;function Lle(n){return n.reduce(function(e,t){return e+t})}hi.sum=Lle;function Hvt(n){return Lle(n)/n.length}hi.mean=Hvt;function jvt(n){for(var e=0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return e}hi.max=jvt;function qvt(n){for(var e=0,t=0;t<n.length;t++)for(var r=0;r<n[t].length;r++)e=n[t][r]>e?n[t][r]:e;return e}hi.max2d=qvt;function Xvt(n,e,t){for(var r=Fle(n),s=0;s<n;s++)for(var i=!0;i;){for(var o=Ole(e,t),a=!1,l=0;l<s;l++)if(o===r[l]){a=!0;break}a||(i=!1),r[s]=o}return r}hi.rejectionSample=Xvt;function Kvt(n,e,t){var r=[],s=0;if(n.length!==e*t)throw new Error("Array dimensions must match input length.");for(var i=0;i<e;i++){for(var o=[],a=0;a<t;a++)o.push(n[s]),s+=1;r.push(o)}return r}hi.reshape2d=Kvt;var Yvt=mt&&mt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(Fh,"__esModule",{value:!0});var R_=Yvt(hi);function zle(n,e){var t=function(s){return R_.empty(n).map(function(){return R_.filled(e,s)})},r=[];return r.push(t(-1)),r.push(t(1/0)),r.push(t(0)),r}Fh.makeHeap=zle;function Zvt(n,e,t){for(var r=R_.zeros(n),s=0;s<n;s++){for(var i=!0,o=0;i;){o=R_.tauRandInt(e,t);for(var a=!1,l=0;l<s;l++)if(o===r[l]){a=!0;break}a||(i=!1)}r[s]=o}return r}Fh.rejectionSample=Zvt;function tL(n,e,t,r,s){e=Math.floor(e);var i=n[0][e],o=n[1][e];if(n[2][e],t>=o[0])return 0;for(var a=0;a<i.length;a++)if(r===i[a])return 0;return Ble(n,e,t,r,s)}Fh.heapPush=tL;function Ble(n,e,t,r,s){var i=n[0][e],o=n[1][e],a=n[2][e];if(t>=o[0])return 0;o[0]=t,i[0]=r,a[0]=s;for(var l=0,c=0;;){var u=2*l+1,h=u+1,f=n[0][0].length;if(u>=f)break;if(h>=f)if(o[u]>t)c=u;else break;else if(o[u]>=o[h])if(t<o[u])c=u;else break;else if(t<o[h])c=h;else break;o[l]=o[c],i[l]=i[c],a[l]=a[c],l=c}return o[l]=t,i[l]=r,a[l]=s,1}Fh.uncheckedHeapPush=Ble;function Jvt(n,e,t,r,s){for(var i=zle(e,r),o=0;o<e;o++)for(var a=0;a<t;a++)if(!(n[0][o][a]<0)){var l=n[0][o][a],c=n[2][o][a],u=R_.tauRand(s);tL(i,o,u,l,c),tL(i,l,u,o,c),n[2][o][a]=0}return i}Fh.buildCandidates=Jvt;function Qvt(n){for(var e=n[0],t=n[1],r=0;r<e.length;r++)for(var s=e[r],i=t[r],o=0;o<s.length-1;o++){var a=s.length-o-1,l=i.length-o-1,c=s[0];s[0]=s[a],s[a]=c;var u=i[0];i[0]=i[l],i[l]=u,ewt(i,s,l,0)}return{indices:e,weights:t}}Fh.deheapSort=Qvt;function ewt(n,e,t,r){for(;r*2+1<t;){var s=r*2+1,i=s+1,o=r;if(n[o]<n[s]&&(o=s),i<t&&n[o]<n[i]&&(o=i),o===r)break;var a=n[r];n[r]=n[o],n[o]=a;var l=e[r];e[r]=e[o],e[o]=l,r=o}}function twt(n,e){for(var t=n[0][e],r=n[1][e],s=n[2][e],i=1/0,o=-1,a=0;a>t.length;a++)s[a]===1&&r[a]<i&&(i=r[a],o=a);return o>=0?(s[o]=0,Math.floor(t[o])):-1}Fh.smallestFlagged=twt;var tl={},tI=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},nwt=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},rwt=mt&&mt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(tl,"__esModule",{value:!0});var c1,Eq=rwt(hi),ox=function(){function n(e,t,r,s){if(this.entries=new Map,this.nRows=0,this.nCols=0,e.length!==t.length||e.length!==r.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=s[0],this.nCols=s[1];for(var i=0;i<r.length;i++){var o=e[i],a=t[i];this.checkDims(o,a);var l=this.makeKey(o,a);this.entries.set(l,{value:r[i],row:o,col:a})}}return n.prototype.makeKey=function(e,t){return e+":"+t},n.prototype.checkDims=function(e,t){var r=e<this.nRows&&t<this.nCols;if(!r)throw new Error("row and/or col specified outside of matrix dimensions")},n.prototype.set=function(e,t,r){this.checkDims(e,t);var s=this.makeKey(e,t);this.entries.has(s)?this.entries.get(s).value=r:this.entries.set(s,{value:r,row:e,col:t})},n.prototype.get=function(e,t,r){r===void 0&&(r=0),this.checkDims(e,t);var s=this.makeKey(e,t);return this.entries.has(s)?this.entries.get(s).value:r},n.prototype.getAll=function(e){e===void 0&&(e=!0);var t=[];return this.entries.forEach(function(r){t.push(r)}),e&&t.sort(function(r,s){return r.row===s.row?r.col-s.col:r.row-s.row}),t},n.prototype.getDims=function(){return[this.nRows,this.nCols]},n.prototype.getRows=function(){return Array.from(this.entries,function(e){var t=tI(e,2);t[0];var r=t[1];return r.row})},n.prototype.getCols=function(){return Array.from(this.entries,function(e){var t=tI(e,2);t[0];var r=t[1];return r.col})},n.prototype.getValues=function(){return Array.from(this.entries,function(e){var t=tI(e,2);t[0];var r=t[1];return r.value})},n.prototype.forEach=function(e){this.entries.forEach(function(t){return e(t.value,t.row,t.col)})},n.prototype.map=function(e){var t=[];this.entries.forEach(function(s){t.push(e(s.value,s.row,s.col))});var r=[this.nRows,this.nCols];return new n(this.getRows(),this.getCols(),t,r)},n.prototype.toArray=function(){var e=this,t=Eq.empty(this.nRows),r=t.map(function(){return Eq.zeros(e.nCols)});return this.entries.forEach(function(s){r[s.row][s.col]=s.value}),r},n}();tl.SparseMatrix=ox;function swt(n){var e=[],t=[],r=[];n.forEach(function(i,o,a){e.push(o),t.push(a),r.push(i)});var s=[n.nCols,n.nRows];return new ox(t,e,r,s)}tl.transpose=swt;function iwt(n){for(var e=tI(n,1),t=e[0],r=new ox([],[],[],n),s=0;s<t;s++)r.set(s,s,1);return r}tl.identity=iwt;function owt(n,e){return O$(n,e,function(t,r){return t*r})}tl.pairwiseMultiply=owt;function awt(n,e){return O$(n,e,function(t,r){return t+r})}tl.add=awt;function lwt(n,e){return O$(n,e,function(t,r){return t-r})}tl.subtract=lwt;function cwt(n,e){return O$(n,e,function(t,r){return t>r?t:r})}tl.maximum=cwt;function uwt(n,e){return n.map(function(t){return t*e})}tl.multiplyScalar=uwt;function hwt(n){for(var e=new Set,t=n.getValues(),r=n.getRows(),s=n.getCols(),i=0;i<t.length;i++)t[i]===0&&e.add(i);var o=function(u,h){return!e.has(h)},a=t.filter(o),l=r.filter(o),c=s.filter(o);return new ox(l,c,a,n.getDims())}tl.eliminateZeros=hwt;function fwt(n,e){e===void 0&&(e="l2");var t,r,s=dwt[e],i=new Map;n.forEach(function(h,f,d){var p=i.get(f)||[];p.push(d),i.set(f,p)});var o=new ox([],[],[],n.getDims()),a=function(h){for(var f=i.get(h).sort(),d=f.map(function(g){return n.get(h,g)}),p=s(d),m=0;m<p.length;m++)o.set(h,f[m],p[m])};try{for(var l=nwt(i.keys()),c=l.next();!c.done;c=l.next()){var u=c.value;a(u)}}catch(h){t={error:h}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(t)throw t.error}}return o}tl.normalize=fwt;var dwt=(c1={},c1.max=function(n){for(var e=-1/0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return n.map(function(r){return r/e})},c1.l1=function(n){for(var e=0,t=0;t<n.length;t++)e+=n[t];return n.map(function(r){return r/e})},c1.l2=function(n){for(var e=0,t=0;t<n.length;t++)e+=Math.pow(n[t],2);return n.map(function(r){return Math.sqrt(Math.pow(r,2)/e)})},c1);function O$(n,e,t){for(var r=new Set,s=[],i=[],o=[],a=function(x,w){s.push(x),i.push(w);var _=t(n.get(x,w),e.get(x,w));o.push(_)},l=n.getValues(),c=n.getRows(),u=n.getCols(),h=0;h<l.length;h++){var f=c[h],d=u[h],p=f+":"+d;r.add(p),a(f,d)}for(var m=e.getValues(),g=e.getRows(),y=e.getCols(),h=0;h<m.length;h++){var f=g[h],d=y[h],p=f+":"+d;r.has(p)||a(f,d)}var b=[n.nRows,n.nCols];return new ox(s,i,o,b)}function pwt(n){var e=[];n.forEach(function(h,f,d){e.push({value:h,row:f,col:d})}),e.sort(function(h,f){return h.row===f.row?h.col-f.col:h.row-f.row});for(var t=[],r=[],s=[],i=-1,o=0;o<e.length;o++){var a=e[o],l=a.row,c=a.col,u=a.value;l!==i&&(i=l,s.push(o)),t.push(c),r.push(u)}return{indices:t,values:r,indptr:s}}tl.getCSR=pwt;var ax={},Qy={},mwt=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Vle=mt&&mt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(mwt(arguments[e]));return n},gwt=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},ywt=mt&&mt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(Qy,"__esModule",{value:!0});var Lo=ywt(hi),Ule=function(){function n(e,t,r,s){this.hyperplanes=e,this.offsets=t,this.children=r,this.indices=s}return n}();Qy.FlatTree=Ule;function bwt(n,e,t,r){var s=Math.max(10,e),i=Lo.range(t).map(function(a,l){return vwt(n,s,l,r)}),o=i.map(function(a){return xwt(a,s)});return o}Qy.makeForest=bwt;function vwt(n,e,t,r){e===void 0&&(e=30);var s=Lo.range(n.length),i=nL(n,s,e,t,r);return i}function nL(n,e,t,r,s){if(t===void 0&&(t=30),e.length>t){var i=wwt(n,e,s),o=i.indicesLeft,a=i.indicesRight,l=i.hyperplane,c=i.offset,u=nL(n,o,t,r+1,s),h=nL(n,a,t,r+1,s),f={leftChild:u,rightChild:h,isLeaf:!1,hyperplane:l,offset:c};return f}else{var f={indices:e,isLeaf:!0};return f}}function wwt(n,e,t){var r=n[0].length,s=Lo.tauRandInt(e.length,t),i=Lo.tauRandInt(e.length,t);i+=s===i?1:0,i=i%e.length;for(var o=e[s],a=e[i],l=0,c=Lo.zeros(r),u=0;u<c.length;u++)c[u]=n[o][u]-n[a][u],l-=c[u]*(n[o][u]+n[a][u])/2;for(var h=0,f=0,d=Lo.zeros(e.length),u=0;u<e.length;u++){for(var p=l,m=0;m<r;m++)p+=c[m]*n[e[u]][m];p===0?(d[u]=Lo.tauRandInt(2,t),d[u]===0?h+=1:f+=1):p>0?(d[u]=0,h+=1):(d[u]=1,f+=1)}var g=Lo.zeros(h),y=Lo.zeros(f);h=0,f=0;for(var u=0;u<d.length;u++)d[u]===0?(g[h]=e[u],h+=1):(y[f]=e[u],f+=1);return{indicesLeft:g,indicesRight:y,hyperplane:c,offset:l}}function xwt(n,e){var t=sL(n),r=iL(n),s=Lo.range(t).map(function(){return Lo.zeros(n.hyperplane?n.hyperplane.length:0)}),i=Lo.zeros(t),o=Lo.range(t).map(function(){return[-1,-1]}),a=Lo.range(r).map(function(){return Lo.range(e).map(function(){return-1})});return rL(n,s,i,o,a,0,0),new Ule(s,i,o,a)}function rL(n,e,t,r,s,i,o){var a;if(n.isLeaf)return r[i][0]=-o,(a=s[o]).splice.apply(a,Vle([0,n.indices.length],n.indices)),o+=1,{nodeNum:i,leafNum:o};e[i]=n.hyperplane,t[i]=n.offset,r[i][0]=i+1;var l=i,c=rL(n.leftChild,e,t,r,s,i+1,o);return i=c.nodeNum,o=c.leafNum,r[l][1]=i+1,c=rL(n.rightChild,e,t,r,s,i+1,o),{nodeNum:c.nodeNum,leafNum:c.leafNum}}function sL(n){return n.isLeaf?1:1+sL(n.leftChild)+sL(n.rightChild)}function iL(n){return n.isLeaf?1:iL(n.leftChild)+iL(n.rightChild)}function Swt(n){var e,t;if(n.length>0){var r=[];try{for(var s=gwt(n),i=s.next();!i.done;i=s.next()){var o=i.value;r.push.apply(r,Vle(o.indices))}}catch(a){e={error:a}}finally{try{i&&!i.done&&(t=s.return)&&t.call(s)}finally{if(e)throw e.error}}return r}else return[[-1]]}Qy.makeLeafArray=Swt;function _wt(n,e,t,r){for(var s=e,i=0;i<t.length;i++)s+=n[i]*t[i];if(s===0){var o=Lo.tauRandInt(2,r);return o}else return s>0?0:1}function Cwt(n,e,t){for(var r=0;e.children[r][0]>0;){var s=_wt(e.hyperplanes[r],e.offsets[r],n,t);s===0?r=e.children[r][0]:r=e.children[r][1]}var i=-1*e.children[r][0];return e.indices[i]}Qy.searchFlatTree=Cwt;var Wle=mt&&mt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},F$=mt&&mt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(ax,"__esModule",{value:!0});var ca=F$(Fh),kwt=F$(tl),Twt=F$(Qy),Gle=F$(hi);function Ewt(n,e){return function(r,s,i,o,a,l,c,u){o===void 0&&(o=10),a===void 0&&(a=50),l===void 0&&(l=.001),c===void 0&&(c=.5),u===void 0&&(u=!0);for(var h=r.length,f=ca.makeHeap(r.length,i),d=0;d<r.length;d++)for(var p=ca.rejectionSample(i,r.length,e),m=0;m<p.length;m++){var g=n(r[d],r[p[m]]);ca.heapPush(f,d,g,p[m],1),ca.heapPush(f,p[m],g,d,1)}if(u)for(var y=0;y<s.length;y++)for(var d=0;d<s[y].length&&!(s[y][d]<0);d++)for(var m=d+1;m<s[y].length&&!(s[y][m]<0);m++){var g=n(r[s[y][d]],r[s[y][m]]);ca.heapPush(f,s[y][d],g,s[y][m],1),ca.heapPush(f,s[y][m],g,s[y][d],1)}for(var y=0;y<o;y++){for(var b=ca.buildCandidates(f,h,i,a,e),x=0,d=0;d<h;d++)for(var m=0;m<a;m++){var w=Math.floor(b[0][d][m]);if(!(w<0||Gle.tauRand(e)<c))for(var _=0;_<a;_++){var C=Math.floor(b[0][d][_]),k=b[2][d][m],A=b[2][d][_];if(!(C<0||!k&&!A)){var g=n(r[w],r[C]);x+=ca.heapPush(f,w,g,C,1),x+=ca.heapPush(f,C,g,w,1)}}}if(x<=l*i*r.length)break}var M=ca.deheapSort(f);return M}}ax.makeNNDescent=Ewt;function Iwt(n){function e(r,s,i,o,a){for(var l=0;l<i.length;l++)for(var c=Gle.rejectionSample(r,s.length,a),u=0;u<c.length;u++)if(!(c[u]<0)){var h=n(s[c[u]],i[l]);ca.heapPush(o,l,h,c[u],1)}}function t(r,s,i,o,a){for(var l=0;l<i.length;l++)for(var c=Twt.searchFlatTree(i[l],r,a),u=0;u<c.length;u++){if(c[u]<0)return;var h=n(s[c[u]],i[l]);ca.heapPush(o,l,h,c[u],1)}}return{initFromRandom:e,initFromTree:t}}ax.makeInitializations=Iwt;function Awt(n){return function(t,r,s,i){for(var o,a,l=kwt.getCSR(r),c=l.indices,u=l.indptr,h=0;h<i.length;h++)for(var f=new Set(s[0][h]);;){var d=ca.smallestFlagged(s,h);if(d===-1)break;var p=c.slice(u[d],u[d+1]);try{for(var m=Wle(p),g=m.next();!g.done;g=m.next()){var y=g.value;if(!(y===d||y===-1||f.has(y))){var b=n(t[y],i[h]);ca.uncheckedHeapPush(s,h,b,y,1),f.add(y)}}}catch(x){o={error:x}}finally{try{g&&!g.done&&(a=m.return)&&a.call(m)}finally{if(o)throw o.error}}}return s}}ax.makeInitializedNNSearch=Awt;function Mwt(n,e,t,r,s,i,o){var a,l,c=ca.makeHeap(t.length,r);if(s(r,e,t,c,o),n)try{for(var u=Wle(n),h=u.next();!h.done;h=u.next()){var f=h.value;i(f,e,t,c,o)}}catch(d){a={error:d}}finally{try{h&&!h.done&&(l=u.return)&&l.call(u)}finally{if(a)throw a.error}}return c}ax.initializeSearch=Mwt;const Nwt=Object.prototype.toString;function UP(n){return Nwt.call(n).endsWith("Array]")}function Iq(n,e,t){let r=0;const s=t(e);for(let i=0;i<n.x.length;i++)r+=Math.abs(n.y[i]-s(n.x[i]));return r}function $wt(n,e,t,r,s){const i=t.length,o=n.x.length;let a=new Array(i);for(let l=0;l<i;l++){a[l]=new Array(o);let c=t.slice();c[l]+=r;let u=s(c);for(let h=0;h<o;h++)a[l][h]=e[h]-u(n.x[h])}return new hh(a)}function Rwt(n,e){const t=n.x.length;let r=new Array(t);for(let s=0;s<t;s++)r[s]=[n.y[s]-e[s]];return new hh(r)}function Pwt(n,e,t,r,s){let i=t*r*r,o=hh.eye(e.length,e.length,i);const a=s(e);let l=new Float64Array(n.x.length);for(let f=0;f<n.x.length;f++)l[f]=a(n.x[f]);let c=$wt(n,l,e,r,s),u=Rwt(n,l),h=pht(o.add(c.mmul(c.transpose())));return e=new hh([e]),e=e.sub(h.mmul(c).mmul(u).mul(r).transpose()),e.to1DArray()}function Dwt(n,e,t={}){let{maxIterations:r=100,gradientDifference:s=.1,damping:i=0,errorTolerance:o=.01,minValues:a,maxValues:l,initialValues:c}=t;if(i<=0)throw new Error("The damping option must be a positive number");if(!n.x||!n.y)throw new Error("The data parameter must have x and y elements");if(!UP(n.x)||n.x.length<2||!UP(n.y)||n.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(n.x.length!==n.y.length)throw new Error("The data parameter elements must have the same size");let u=c||new Array(e.length).fill(1),h=u.length;if(l=l||new Array(h).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(h).fill(Number.MIN_SAFE_INTEGER),l.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!UP(u))throw new Error("initialValues must be an array");let f=Iq(n,u,e),d=f<=o,p;for(p=0;p<r&&!d;p++){u=Pwt(n,u,i,s,e);for(let m=0;m<h;m++)u[m]=Math.min(Math.max(a[m],u[m]),l[m]);if(f=Iq(n,u,e),isNaN(f))break;d=f<=o}return{parameterValues:u,parameterError:f,iterations:p}}const Owt=Object.freeze(Object.defineProperty({__proto__:null,default:Dwt},Symbol.toStringTag,{value:"Module"})),Fwt=Vf(Owt);var Aq=mt&&mt.__awaiter||function(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){c.done?s(c.value):new t(function(u){u(c.value)}).then(o,a)}l((r=r.apply(n,e||[])).next())})},Mq=mt&&mt.__generator||function(n,e){var t={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},r,s,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(i=c[0]&2?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,s=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(i=t.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){t.label=c[1];break}if(c[0]===6&&t.label<i[1]){t.label=i[1],i=c;break}if(i&&t.label<i[2]){t.label=i[2],t.ops.push(c);break}i[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],s=0}finally{r=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},oL=mt&&mt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Nq=mt&&mt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(oL(arguments[e]));return n},HC=mt&&mt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e},Lwt=mt&&mt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Yf,"__esModule",{value:!0});var zwt=HC(Fh),js=HC(tl),SE=HC(ax),$q=HC(Qy),si=HC(hi),Bwt=Lwt(Fwt),Rq=1e-5,_E=.001,Vwt=function(){function n(e){e===void 0&&(e={});var t=this;this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=Hle,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new Wwt;var r=function(s){e[s]!==void 0&&(t[s]=e[s])};r("distanceFn"),r("learningRate"),r("localConnectivity"),r("minDist"),r("nComponents"),r("nEpochs"),r("nNeighbors"),r("negativeSampleRate"),r("random"),r("repulsionStrength"),r("setOpMixRatio"),r("spread"),r("transformQueueSize")}return n.prototype.fit=function(e){return this.initializeFit(e),this.optimizeLayout(),this.embedding},n.prototype.fitAsync=function(e,t){return t===void 0&&(t=function(){return!0}),Aq(this,void 0,void 0,function(){return Mq(this,function(r){switch(r.label){case 0:return this.initializeFit(e),[4,this.optimizeLayoutAsync(t)];case 1:return r.sent(),[2,this.embedding]}})})},n.prototype.setSupervisedProjection=function(e,t){t===void 0&&(t={}),this.Y=e,this.targetMetric=t.targetMetric||this.targetMetric,this.targetWeight=t.targetWeight||this.targetWeight,this.targetNNeighbors=t.targetNNeighbors||this.targetNNeighbors},n.prototype.setPrecomputedKNN=function(e,t){this.knnIndices=e,this.knnDistances=t},n.prototype.initializeFit=function(e){if(e.length<=this.nNeighbors)throw new Error("Not enough data points ("+e.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===e&&this.isInitialized)return this.getNEpochs();if(this.X=e,!this.knnIndices&&!this.knnDistances){var t=this.nearestNeighbors(e);this.knnIndices=t.knnIndices,this.knnDistances=t.knnDistances}this.graph=this.fuzzySimplicialSet(e,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(e),this.processGraphForSupervisedProjection();var r=this.initializeSimplicialSetEmbedding(),s=r.head,i=r.tail,o=r.epochsPerSample;return this.optimizationState.head=s,this.optimizationState.tail=i,this.optimizationState.epochsPerSample=o,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},n.prototype.makeSearchFns=function(){var e=SE.makeInitializations(this.distanceFn),t=e.initFromTree,r=e.initFromRandom;this.initFromTree=t,this.initFromRandom=r,this.search=SE.makeInitializedNNSearch(this.distanceFn)},n.prototype.makeSearchGraph=function(e){for(var t=this.knnIndices,r=this.knnDistances,s=[e.length,e.length],i=new js.SparseMatrix([],[],[],s),o=0;o<t.length;o++)for(var a=t[o],l=r[o],c=0;c<a.length;c++){var u=a[c],h=l[c];h>0&&i.set(o,u,h)}var f=js.transpose(i);return js.maximum(i,f)},n.prototype.transform=function(e){var t=this,r=this.X;if(r===void 0||r.length===0)throw new Error("No data has been fit.");var s=Math.floor(this.nNeighbors*this.transformQueueSize);s=Math.min(r.length,s);var i=SE.initializeSearch(this.rpForest,r,e,s,this.initFromRandom,this.initFromTree,this.random),o=this.search(r,this.searchGraph,i,e),a=zwt.deheapSort(o),l=a.indices,c=a.weights;l=l.map(function(z){return z.slice(0,t.nNeighbors)}),c=c.map(function(z){return z.slice(0,t.nNeighbors)});var u=Math.max(0,this.localConnectivity-1),h=this.smoothKNNDistance(c,this.nNeighbors,u),f=h.sigmas,d=h.rhos,p=this.computeMembershipStrengths(l,c,f,d),m=p.rows,g=p.cols,y=p.vals,b=[e.length,r.length],x=new js.SparseMatrix(m,g,y,b),w=js.normalize(x,"l1"),_=js.getCSR(w),C=e.length,k=si.reshape2d(_.indices,C,this.nNeighbors),A=si.reshape2d(_.values,C,this.nNeighbors),M=Kle(k,A,this.embedding),I=this.nEpochs?this.nEpochs/3:x.nRows<=1e4?100:30,N=x.getValues().reduce(function(z,B){return B>z?B:z},0);x=x.map(function(z){return z<N/I?0:z}),x=js.eliminateZeros(x);var O=this.makeEpochsPerSample(x.getValues(),I),R=x.getRows(),D=x.getCols();return this.assignOptimizationStateParameters({headEmbedding:M,tailEmbedding:this.embedding,head:R,tail:D,currentEpoch:0,nEpochs:I,nVertices:x.getDims()[1],epochsPerSample:O}),this.prepareForOptimizationLoop(),this.optimizeLayout()},n.prototype.processGraphForSupervisedProjection=function(){var e=this,t=e.Y,r=e.X;if(t){if(t.length!==r.length)throw new Error("Length of X and y must be equal");if(this.targetMetric==="categorical"){var s=this.targetWeight<1,i=s?2.5*(1/(1-this.targetWeight)):1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,t,i)}}},n.prototype.step=function(){var e=this.optimizationState.currentEpoch;return e<this.getNEpochs()&&this.optimizeLayoutStep(e),this.optimizationState.currentEpoch},n.prototype.getEmbedding=function(){return this.embedding},n.prototype.nearestNeighbors=function(e){var t=this,r=t.distanceFn,s=t.nNeighbors,i=function(p){return Math.log(p)/Math.log(2)},o=SE.makeNNDescent(r,this.random),a=function(p){return p===.5?0:Math.round(p)},l=5+Math.floor(a(Math.pow(e.length,.5)/20)),c=Math.max(5,Math.floor(Math.round(i(e.length))));this.rpForest=$q.makeForest(e,s,l,this.random);var u=$q.makeLeafArray(this.rpForest),h=o(e,u,s,c),f=h.indices,d=h.weights;return{knnIndices:f,knnDistances:d}},n.prototype.fuzzySimplicialSet=function(e,t,r){r===void 0&&(r=1);var s=this,i=s.knnIndices,o=i===void 0?[]:i,a=s.knnDistances,l=a===void 0?[]:a,c=s.localConnectivity,u=this.smoothKNNDistance(l,t,c),h=u.sigmas,f=u.rhos,d=this.computeMembershipStrengths(o,l,h,f),p=d.rows,m=d.cols,g=d.vals,y=[e.length,e.length],b=new js.SparseMatrix(p,m,g,y),x=js.transpose(b),w=js.pairwiseMultiply(b,x),_=js.subtract(js.add(b,x),w),C=js.multiplyScalar(_,r),k=js.multiplyScalar(w,1-r),A=js.add(C,k);return A},n.prototype.categoricalSimplicialSetIntersection=function(e,t,r,s){s===void 0&&(s=1);var i=qle(e,t,s,r);return i=js.eliminateZeros(i),Xle(i)},n.prototype.smoothKNNDistance=function(e,t,r,s,i){r===void 0&&(r=1),s===void 0&&(s=64),i===void 0&&(i=1);for(var o=Math.log(t)/Math.log(2)*i,a=si.zeros(e.length),l=si.zeros(e.length),c=0;c<e.length;c++){var u=0,h=1/0,f=1,d=e[c],p=d.filter(function(k){return k>0});if(p.length>=r){var m=Math.floor(r),g=r-m;m>0?(a[c]=p[m-1],g>Rq&&(a[c]+=g*(p[m]-p[m-1]))):a[c]=g*p[0]}else p.length>0&&(a[c]=si.max(p));for(var y=0;y<s;y++){for(var b=0,x=1;x<e[c].length;x++){var w=e[c][x]-a[c];w>0?b+=Math.exp(-(w/f)):b+=1}if(Math.abs(b-o)<Rq)break;b>o?(h=f,f=(u+h)/2):(u=f,h===1/0?f*=2:f=(u+h)/2)}if(l[c]=f,a[c]>0){var _=si.mean(d);l[c]<_E*_&&(l[c]=_E*_)}else{var C=si.mean(e.map(si.mean));l[c]<_E*C&&(l[c]=_E*C)}}return{sigmas:l,rhos:a}},n.prototype.computeMembershipStrengths=function(e,t,r,s){for(var i=e.length,o=e[0].length,a=si.zeros(i*o),l=si.zeros(i*o),c=si.zeros(i*o),u=0;u<i;u++)for(var h=0;h<o;h++){var f=0;e[u][h]!==-1&&(e[u][h]===u?f=0:t[u][h]-s[u]<=0?f=1:f=Math.exp(-((t[u][h]-s[u])/r[u])),a[u*o+h]=u,l[u*o+h]=e[u][h],c[u*o+h]=f)}return{rows:a,cols:l,vals:c}},n.prototype.initializeSimplicialSetEmbedding=function(){for(var e=this,t=this.getNEpochs(),r=this.nComponents,s=this.graph.getValues(),i=0,o=0;o<s.length;o++){var a=s[o];i<s[o]&&(i=a)}var l=this.graph.map(function(m){return m<i/t?0:m});this.embedding=si.zeros(l.nRows).map(function(){return si.zeros(r).map(function(){return si.tauRand(e.random)*20+-10})});for(var c=[],u=[],h=[],f=l.getAll(),o=0;o<f.length;o++){var d=f[o];d.value&&(c.push(d.value),h.push(d.row),u.push(d.col))}var p=this.makeEpochsPerSample(c,t);return{head:u,tail:h,epochsPerSample:p}},n.prototype.makeEpochsPerSample=function(e,t){var r=si.filled(e.length,-1),s=si.max(e),i=e.map(function(o){return o/s*t});return i.forEach(function(o,a){o>0&&(r[a]=t/i[a])}),r},n.prototype.assignOptimizationStateParameters=function(e){Object.assign(this.optimizationState,e)},n.prototype.prepareForOptimizationLoop=function(){var e=this,t=e.repulsionStrength,r=e.learningRate,s=e.negativeSampleRate,i=this.optimizationState,o=i.epochsPerSample,a=i.headEmbedding,l=i.tailEmbedding,c=a[0].length,u=a.length===l.length,h=o.map(function(p){return p/s}),f=Nq(h),d=Nq(o);this.assignOptimizationStateParameters({epochOfNextSample:d,epochOfNextNegativeSample:f,epochsPerNegativeSample:h,moveOther:u,initialAlpha:r,alpha:r,gamma:t,dim:c})},n.prototype.initializeOptimization=function(){var e=this.embedding,t=this.embedding,r=this.optimizationState,s=r.head,i=r.tail,o=r.epochsPerSample,a=this.getNEpochs(),l=this.graph.nCols,c=jle(this.spread,this.minDist),u=c.a,h=c.b;this.assignOptimizationStateParameters({headEmbedding:e,tailEmbedding:t,head:s,tail:i,epochsPerSample:o,a:u,b:h,nEpochs:a,nVertices:l})},n.prototype.optimizeLayoutStep=function(e){for(var t=this.optimizationState,r=t.head,s=t.tail,i=t.headEmbedding,o=t.tailEmbedding,a=t.epochsPerSample,l=t.epochOfNextSample,c=t.epochOfNextNegativeSample,u=t.epochsPerNegativeSample,h=t.moveOther,f=t.initialAlpha,d=t.alpha,p=t.gamma,m=t.a,g=t.b,y=t.dim,b=t.nEpochs,x=t.nVertices,w=4,_=0;_<a.length;_++)if(!(l[_]>e)){var C=r[_],k=s[_],A=i[C],M=o[k],I=Dq(A,M),N=0;I>0&&(N=-2*m*g*Math.pow(I,g-1),N/=m*Math.pow(I,g)+1);for(var O=0;O<y;O++){var R=Pq(N*(A[O]-M[O]),w);A[O]+=R*d,h&&(M[O]+=-R*d)}l[_]+=a[_];for(var D=Math.floor((e-c[_])/u[_]),z=0;z<D;z++){var B=si.tauRandInt(x,this.random),X=o[B],G=Dq(A,X),ee=0;if(G>0)ee=2*p*g,ee/=(.001+G)*(m*Math.pow(G,g)+1);else if(C===B)continue;for(var O=0;O<y;O++){var R=4;ee>0&&(R=Pq(ee*(A[O]-X[O]),w)),A[O]+=R*d}}c[_]+=D*u[_]}return t.alpha=f*(1-e/b),t.currentEpoch+=1,i},n.prototype.optimizeLayoutAsync=function(e){var t=this;return e===void 0&&(e=function(){return!0}),new Promise(function(r,s){var i=function(){return Aq(t,void 0,void 0,function(){var o,a,l,c,u,h;return Mq(this,function(f){try{if(o=this.optimizationState,a=o.nEpochs,l=o.currentEpoch,this.embedding=this.optimizeLayoutStep(l),c=this.optimizationState.currentEpoch,u=e(c)===!1,h=c===a,!u&&!h)setTimeout(function(){return i()},0);else return[2,r(h)]}catch(d){s(d)}return[2]})})};setTimeout(function(){return i()},0)})},n.prototype.optimizeLayout=function(e){e===void 0&&(e=function(){return!0});for(var t=!1,r=[];!t;){var s=this.optimizationState,i=s.nEpochs,o=s.currentEpoch;r=this.optimizeLayoutStep(o);var a=this.optimizationState.currentEpoch,l=e(a)===!1;t=a===i||l}return r},n.prototype.getNEpochs=function(){var e=this.graph;if(this.nEpochs>0)return this.nEpochs;var t=e.nRows;return t<=2500?500:t<=5e3?400:t<=7500?300:200},n}();Yf.UMAP=Vwt;function Hle(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return Math.sqrt(t)}Yf.euclidean=Hle;function Uwt(n,e){for(var t=0,r=0,s=0,i=0;i<n.length;i++)t+=n[i]*e[i],r+=Math.pow(n[i],2),s+=Math.pow(e[i],2);return r===0&&s===0?0:r===0||s===0?1:1-t/Math.sqrt(r*s)}Yf.cosine=Uwt;var Wwt=function(){function n(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0}return n}();function Pq(n,e){return n>e?e:n<-e?-e:n}function Dq(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return t}function jle(n,e){var t=function(f){var d=oL(f,2),p=d[0],m=d[1];return function(g){return 1/(1+p*Math.pow(g,2*m))}},r=si.linear(0,n*3,300).map(function(f){return f<e?1:f}),s=si.zeros(r.length).map(function(f,d){var p=r[d]>=e;return p?Math.exp(-(r[d]-e)/n):f}),i=[.5,.5],o={x:r,y:s},a={damping:1.5,initialValues:i,gradientDifference:.1,maxIterations:100,errorTolerance:.01},l=Bwt.default(o,t,a).parameterValues,c=oL(l,2),u=c[0],h=c[1];return{a:u,b:h}}Yf.findABParams=jle;function qle(n,e,t,r){return t===void 0&&(t=1),r===void 0&&(r=5),n.map(function(s,i,o){return e[i]===-1||e[o]===-1?s*Math.exp(-t):e[i]!==e[o]?s*Math.exp(-r):s})}Yf.fastIntersection=qle;function Xle(n){n=js.normalize(n,"max");var e=js.transpose(n),t=js.pairwiseMultiply(e,n);return n=js.add(n,js.subtract(e,t)),js.eliminateZeros(n)}Yf.resetLocalConnectivity=Xle;function Kle(n,e,t){for(var r=si.zeros(n.length).map(function(l){return si.zeros(t[0].length)}),s=0;s<n.length;s++)for(var i=0;i<n[0].length;i++)for(var o=0;o<t[0].length;o++){var a=n[s][i];r[s][o]+=e[s][i]*t[a][o]}return r}Yf.initTransform=Kle;Object.defineProperty(Dle,"__esModule",{value:!0});var Gwt=Yf;Dle.UMAP=Gwt.UMAP;function ot(){}const L$=n=>n;function Hwt(n,e){for(const t in e)n[t]=e[t];return n}function jwt(n){return!!n&&(typeof n=="object"||typeof n=="function")&&typeof n.then=="function"}function Yle(n){return n()}function Oq(){return Object.create(null)}function nl(n){n.forEach(Yle)}function lx(n){return typeof n=="function"}function Nn(n,e){return n!=n?e==e:n!==e||n&&typeof n=="object"||typeof n=="function"}let CE;function iM(n,e){return CE||(CE=document.createElement("a")),CE.href=e,n===CE.href}function qwt(n){return Object.keys(n).length===0}function es(n,...e){if(n==null)return ot;const t=n.subscribe(...e);return t.unsubscribe?()=>t.unsubscribe():t}function oS(n){let e;return es(n,t=>e=t)(),e}function RV(n,e,t){n.$$.on_destroy.push(es(e,t))}function Fp(n,e,t,r){if(n){const s=Zle(n,e,t,r);return n[0](s)}}function Zle(n,e,t,r){return n[1]&&r?Hwt(t.ctx.slice(),n[1](r(e))):t.ctx}function Lp(n,e,t,r){if(n[2]&&r){const s=n[2](r(t));if(e.dirty===void 0)return s;if(typeof s=="object"){const i=[],o=Math.max(e.dirty.length,s.length);for(let a=0;a<o;a+=1)i[a]=e.dirty[a]|s[a];return i}return e.dirty|s}return e.dirty}function zp(n,e,t,r,s,i){if(s){const o=Zle(e,t,r,i);n.p(o,s)}}function Bp(n){if(n.ctx.length>32){const e=[],t=n.ctx.length/32;for(let r=0;r<t;r++)e[r]=-1;return e}return-1}function Xwt(n){const e=typeof n=="string"&&n.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);return e?[parseFloat(e[1]),e[2]||"px"]:[n,"px"]}const Jle=typeof window<"u";let z$=Jle?()=>window.performance.now():()=>Date.now(),PV=Jle?n=>requestAnimationFrame(n):ot;const Db=new Set;function Qle(n){Db.forEach(e=>{e.c(n)||(Db.delete(e),e.f())}),Db.size!==0&&PV(Qle)}function B$(n){let e;return Db.size===0&&PV(Qle),{promise:new Promise(t=>{Db.add(e={c:n,f:t})}),abort(){Db.delete(e)}}}const Kwt=typeof window<"u"?window:typeof globalThis<"u"?globalThis:global;function ue(n,e){n.appendChild(e)}function ece(n){if(!n)return document;const e=n.getRootNode?n.getRootNode():n.ownerDocument;return e&&e.host?e:n.ownerDocument}function Ywt(n){const e=Ce("style");return Zwt(ece(n),e),e.sheet}function Zwt(n,e){return ue(n.head||n,e),e.sheet}function be(n,e,t){n.insertBefore(e,t||null)}function ye(n){n.parentNode&&n.parentNode.removeChild(n)}function Vi(n,e){for(let t=0;t<n.length;t+=1)n[t]&&n[t].d(e)}function Ce(n){return document.createElement(n)}function vs(n){return document.createElementNS("http://www.w3.org/2000/svg",n)}function Qe(n){return document.createTextNode(n)}function st(){return Qe(" ")}function ea(){return Qe("")}function Ir(n,e,t,r){return n.addEventListener(e,t,r),()=>n.removeEventListener(e,t,r)}function jC(n){return function(e){return e.preventDefault(),n.call(this,e)}}function Jwt(n){return function(e){return e.stopPropagation(),n.call(this,e)}}function te(n,e,t){t==null?n.removeAttribute(e):n.getAttribute(e)!==t&&n.setAttribute(e,t)}function Sb(n,e,t){e in n?n[e]=typeof n[e]=="boolean"&&t===""?!0:t:te(n,e,t)}function Qwt(n){return Array.from(n.childNodes)}function dn(n,e){e=""+e,n.data!==e&&(n.data=e)}function ua(n,e,t,r){t==null?n.style.removeProperty(e):n.style.setProperty(e,t,r?"important":"")}function Fq(n,e,t){for(let r=0;r<n.options.length;r+=1){const s=n.options[r];if(s.__value===e){s.selected=!0;return}}(!t||e!==void 0)&&(n.selectedIndex=-1)}function ext(n){const e=n.querySelector(":checked");return e&&e.__value}let kE;function txt(){if(kE===void 0){kE=!1;try{typeof window<"u"&&window.parent&&window.parent.document}catch{kE=!0}}return kE}function nxt(n,e){getComputedStyle(n).position==="static"&&(n.style.position="relative");const r=Ce("iframe");r.setAttribute("style","display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"),r.setAttribute("aria-hidden","true"),r.tabIndex=-1;const s=txt();let i;return s?(r.src="data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>",i=Ir(window,"message",o=>{o.source===r.contentWindow&&e()})):(r.src="about:blank",r.onload=()=>{i=Ir(r.contentWindow,"resize",e),e()}),ue(n,r),()=>{(s||i&&r.contentWindow)&&i(),ye(r)}}function Gt(n,e,t){n.classList[t?"add":"remove"](e)}function tce(n,e,{bubbles:t=!1,cancelable:r=!1}={}){const s=document.createEvent("CustomEvent");return s.initCustomEvent(n,t,r,e),s}class rxt{constructor(e=!1){this.is_svg=!1,this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,r=null){this.e||(this.is_svg?this.e=vs(t.nodeName):this.e=Ce(t.nodeType===11?"TEMPLATE":t.nodeName),this.t=t.tagName!=="TEMPLATE"?t:t.content,this.c(e)),this.i(r)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.nodeName==="TEMPLATE"?this.e.content.childNodes:this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)be(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(ye)}}const oM=new Map;let aM=0;function sxt(n){let e=5381,t=n.length;for(;t--;)e=(e<<5)-e^n.charCodeAt(t);return e>>>0}function ixt(n,e){const t={stylesheet:Ywt(e),rules:{}};return oM.set(n,t),t}function P_(n,e,t,r,s,i,o,a=0){const l=16.666/r;let c=`{
`;for(let g=0;g<=1;g+=l){const y=e+(t-e)*i(g);c+=g*100+`%{${o(y,1-y)}}
`}const u=c+`100% {${o(t,1-t)}}
}`,h=`__svelte_${sxt(u)}_${a}`,f=ece(n),{stylesheet:d,rules:p}=oM.get(f)||ixt(f,n);p[h]||(p[h]=!0,d.insertRule(`@keyframes ${h} ${u}`,d.cssRules.length));const m=n.style.animation||"";return n.style.animation=`${m?`${m}, `:""}${h} ${r}ms linear ${s}ms 1 both`,aM+=1,h}function D_(n,e){const t=(n.style.animation||"").split(", "),r=t.filter(e?i=>i.indexOf(e)<0:i=>i.indexOf("__svelte")===-1),s=t.length-r.length;s&&(n.style.animation=r.join(", "),aM-=s,aM||oxt())}function oxt(){PV(()=>{aM||(oM.forEach(n=>{const{ownerNode:e}=n.stylesheet;e&&ye(e)}),oM.clear())})}function axt(n,e,t,r){if(!e)return ot;const s=n.getBoundingClientRect();if(e.left===s.left&&e.right===s.right&&e.top===s.top&&e.bottom===s.bottom)return ot;const{delay:i=0,duration:o=300,easing:a=L$,start:l=z$()+i,end:c=l+o,tick:u=ot,css:h}=t(n,{from:e,to:s},r);let f=!0,d=!1,p;function m(){h&&(p=P_(n,0,1,o,i,a,h)),i||(d=!0)}function g(){h&&D_(n,p),f=!1}return B$(y=>{if(!d&&y>=l&&(d=!0),d&&y>=c&&(u(1,0),g()),!f)return!1;if(d){const b=y-l,x=0+1*a(b/o);u(x,1-x)}return!0}),m(),u(0,1),g}function lxt(n){const e=getComputedStyle(n);if(e.position!=="absolute"&&e.position!=="fixed"){const{width:t,height:r}=e,s=n.getBoundingClientRect();n.style.position="absolute",n.style.width=t,n.style.height=r,nce(n,s)}}function nce(n,e){const t=n.getBoundingClientRect();if(e.left!==t.left||e.top!==t.top){const r=getComputedStyle(n),s=r.transform==="none"?"":r.transform;n.style.transform=`${s} translate(${e.left-t.left}px, ${e.top-t.top}px)`}}let O_;function Af(n){O_=n}function e0(){if(!O_)throw new Error("Function called outside component initialization");return O_}function $h(n){e0().$$.on_mount.push(n)}function rce(n){e0().$$.after_update.push(n)}function wv(n){e0().$$.on_destroy.push(n)}function Fc(){const n=e0();return(e,t,{cancelable:r=!1}={})=>{const s=n.$$.callbacks[e];if(s){const i=tce(e,t,{cancelable:r});return s.slice().forEach(o=>{o.call(n,i)}),!i.defaultPrevented}return!0}}function cxt(n,e){return e0().$$.context.set(n,e),e}function sce(n){return e0().$$.context.get(n)}function lM(n,e){const t=n.$$.callbacks[e.type];t&&t.slice().forEach(r=>r.call(this,e))}const pb=[],So=[];let Ob=[];const aL=[],ice=Promise.resolve();let lL=!1;function oce(){lL||(lL=!0,ice.then(F_))}function Ka(){return oce(),ice}function Pc(n){Ob.push(n)}function cx(n){aL.push(n)}const WP=new Set;let sb=0;function F_(){if(sb!==0)return;const n=O_;do{try{for(;sb<pb.length;){const e=pb[sb];sb++,Af(e),uxt(e.$$)}}catch(e){throw pb.length=0,sb=0,e}for(Af(null),pb.length=0,sb=0;So.length;)So.pop()();for(let e=0;e<Ob.length;e+=1){const t=Ob[e];WP.has(t)||(WP.add(t),t())}Ob.length=0}while(pb.length);for(;aL.length;)aL.pop()();lL=!1,WP.clear(),Af(n)}function uxt(n){if(n.fragment!==null){n.update(),nl(n.before_update);const e=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,e),n.after_update.forEach(Pc)}}function hxt(n){const e=[],t=[];Ob.forEach(r=>n.indexOf(r)===-1?e.push(r):t.push(r)),t.forEach(r=>r()),Ob=e}let u1;function DV(){return u1||(u1=Promise.resolve(),u1.then(()=>{u1=null})),u1}function Jm(n,e,t){n.dispatchEvent(tce(`${e?"intro":"outro"}${t}`))}const nI=new Set;let ph;function yr(){ph={r:0,c:[],p:ph}}function br(){ph.r||nl(ph.c),ph=ph.p}function Ae(n,e){n&&n.i&&(nI.delete(n),n.i(e))}function Re(n,e,t,r){if(n&&n.o){if(nI.has(n))return;nI.add(n),ph.c.push(()=>{nI.delete(n),r&&(t&&n.d(1),r())}),n.o(e)}else r&&r()}const OV={duration:0};function fxt(n,e,t){const r={direction:"in"};let s=e(n,t,r),i=!1,o,a,l=0;function c(){o&&D_(n,o)}function u(){const{delay:f=0,duration:d=300,easing:p=L$,tick:m=ot,css:g}=s||OV;g&&(o=P_(n,0,1,d,f,p,g,l++)),m(0,1);const y=z$()+f,b=y+d;a&&a.abort(),i=!0,Pc(()=>Jm(n,!0,"start")),a=B$(x=>{if(i){if(x>=b)return m(1,0),Jm(n,!0,"end"),c(),i=!1;if(x>=y){const w=p((x-y)/d);m(w,1-w)}}return i})}let h=!1;return{start(){h||(h=!0,D_(n),lx(s)?(s=s(r),DV().then(u)):u())},invalidate(){h=!1},end(){i&&(c(),i=!1)}}}function dxt(n,e,t){const r={direction:"out"};let s=e(n,t,r),i=!0,o;const a=ph;a.r+=1;function l(){const{delay:c=0,duration:u=300,easing:h=L$,tick:f=ot,css:d}=s||OV;d&&(o=P_(n,1,0,u,c,h,d));const p=z$()+c,m=p+u;Pc(()=>Jm(n,!1,"start")),B$(g=>{if(i){if(g>=m)return f(0,1),Jm(n,!1,"end"),--a.r||nl(a.c),!1;if(g>=p){const y=h((g-p)/u);f(1-y,y)}}return i})}return lx(s)?DV().then(()=>{s=s(r),l()}):l(),{end(c){c&&s.tick&&s.tick(1,0),i&&(o&&D_(n,o),i=!1)}}}function xv(n,e,t,r){const s={direction:"both"};let i=e(n,t,s),o=r?0:1,a=null,l=null,c=null;function u(){c&&D_(n,c)}function h(d,p){const m=d.b-o;return p*=Math.abs(m),{a:o,b:d.b,d:m,duration:p,start:d.start,end:d.start+p,group:d.group}}function f(d){const{delay:p=0,duration:m=300,easing:g=L$,tick:y=ot,css:b}=i||OV,x={start:z$()+p,b:d};d||(x.group=ph,ph.r+=1),a||l?l=x:(b&&(u(),c=P_(n,o,d,m,p,g,b)),d&&y(0,1),a=h(x,m),Pc(()=>Jm(n,d,"start")),B$(w=>{if(l&&w>l.start&&(a=h(l,m),l=null,Jm(n,a.b,"start"),b&&(u(),c=P_(n,o,a.b,a.duration,0,g,i.css))),a){if(w>=a.end)y(o=a.b,1-o),Jm(n,a.b,"end"),l||(a.b?u():--a.group.r||nl(a.group.c)),a=null;else if(w>=a.start){const _=w-a.start;o=a.a+a.d*g(_/a.duration),y(o,1-o)}}return!!(a||l)}))}return{run(d){lx(i)?DV().then(()=>{i=i(s),f(d)}):f(d)},end(){u(),a=l=null}}}function Lq(n,e){const t=e.token={};function r(s,i,o,a){if(e.token!==t)return;e.resolved=a;let l=e.ctx;o!==void 0&&(l=l.slice(),l[o]=a);const c=s&&(e.current=s)(l);let u=!1;e.block&&(e.blocks?e.blocks.forEach((h,f)=>{f!==i&&h&&(yr(),Re(h,1,1,()=>{e.blocks[f]===h&&(e.blocks[f]=null)}),br())}):e.block.d(1),c.c(),Ae(c,1),c.m(e.mount(),e.anchor),u=!0),e.block=c,e.blocks&&(e.blocks[i]=c),u&&F_()}if(jwt(n)){const s=e0();if(n.then(i=>{Af(s),r(e.then,1,e.value,i),Af(null)},i=>{if(Af(s),r(e.catch,2,e.error,i),Af(null),!e.hasCatch)throw i}),e.current!==e.pending)return r(e.pending,0),!0}else{if(e.current!==e.then)return r(e.then,1,e.value,n),!0;e.resolved=n}}function pxt(n,e,t){const r=e.slice(),{resolved:s}=n;n.current===n.then&&(r[n.value]=s),n.current===n.catch&&(r[n.error]=s),n.block.p(r,t)}function ace(n,e){Re(n,1,1,()=>{e.delete(n.key)})}function mxt(n,e){n.f(),ace(n,e)}function lce(n,e,t,r,s,i,o,a,l,c,u,h){let f=n.length,d=i.length,p=f;const m={};for(;p--;)m[n[p].key]=p;const g=[],y=new Map,b=new Map,x=[];for(p=d;p--;){const k=h(s,i,p),A=t(k);let M=o.get(A);M?r&&x.push(()=>M.p(k,e)):(M=c(A,k),M.c()),y.set(A,g[p]=M),A in m&&b.set(A,Math.abs(p-m[A]))}const w=new Set,_=new Set;function C(k){Ae(k,1),k.m(a,u),o.set(k.key,k),u=k.first,d--}for(;f&&d;){const k=g[d-1],A=n[f-1],M=k.key,I=A.key;k===A?(u=k.first,f--,d--):y.has(I)?!o.has(M)||w.has(M)?C(k):_.has(I)?f--:b.get(M)>b.get(I)?(_.add(M),C(k)):(w.add(I),f--):(l(A,o),f--)}for(;f--;){const k=n[f];y.has(k.key)||l(k,o)}for(;d;)C(g[d-1]);return nl(x),g}function ux(n,e,t){const r=n.$$.props[e];r!==void 0&&(n.$$.bound[r]=t,t(n.$$.ctx[r]))}function Pt(n){n&&n.c()}function At(n,e,t,r){const{fragment:s,after_update:i}=n.$$;s&&s.m(e,t),r||Pc(()=>{const o=n.$$.on_mount.map(Yle).filter(lx);n.$$.on_destroy?n.$$.on_destroy.push(...o):nl(o),n.$$.on_mount=[]}),i.forEach(Pc)}function Mt(n,e){const t=n.$$;t.fragment!==null&&(hxt(t.after_update),nl(t.on_destroy),t.fragment&&t.fragment.d(e),t.on_destroy=t.fragment=null,t.ctx=[])}function gxt(n,e){n.$$.dirty[0]===-1&&(pb.push(n),oce(),n.$$.dirty.fill(0)),n.$$.dirty[e/31|0]|=1<<e%31}function $n(n,e,t,r,s,i,o,a=[-1]){const l=O_;Af(n);const c=n.$$={fragment:null,ctx:[],props:i,update:ot,not_equal:s,bound:Oq(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(l?l.$$.context:[])),callbacks:Oq(),dirty:a,skip_bound:!1,root:e.target||l.$$.root};o&&o(c.root);let u=!1;if(c.ctx=t?t(n,e.props||{},(h,f,...d)=>{const p=d.length?d[0]:f;return c.ctx&&s(c.ctx[h],c.ctx[h]=p)&&(!c.skip_bound&&c.bound[h]&&c.bound[h](p),u&&gxt(n,h)),f}):[],c.update(),u=!0,nl(c.before_update),c.fragment=r?r(c.ctx):!1,e.target){if(e.hydrate){const h=Qwt(e.target);c.fragment&&c.fragment.l(h),h.forEach(ye)}else c.fragment&&c.fragment.c();e.intro&&Ae(n.$$.fragment),At(n,e.target,e.anchor,e.customElement),F_()}Af(l)}class Rn{$destroy(){Mt(this,1),this.$destroy=ot}$on(e,t){if(!lx(t))return ot;const r=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return r.push(t),()=>{const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}$set(e){this.$$set&&!qwt(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}function yxt(n){let e,t,r,s,i;const o=n[10].default,a=Fp(o,n,n[9],null);return{c(){e=st(),t=Ce("button"),a&&a.c(),te(t,"class","marcelle svelte-2j0fl0"),t.disabled=n[1],Gt(t,"outline",n[0]==="outline"),Gt(t,"filled",n[0]==="filled"),Gt(t,"light",n[0]==="light"),Gt(t,"success",n[2]==="success"),Gt(t,"warning",n[2]==="warning"),Gt(t,"danger",n[2]==="danger"),Gt(t,"size-small",n[3]==="small"),Gt(t,"size-large",n[3]==="large"),Gt(t,"round",n[4])},m(l,c){be(l,e,c),be(l,t,c),a&&a.m(t,null),r=!0,s||(i=[Ir(document.body,"mouseup",n[6]),Ir(document.body,"touchend",n[6]),Ir(t,"click",n[11]),Ir(t,"mousedown",n[5]),Ir(t,"touchstart",jC(n[5])),Ir(t,"touchend",n[7])],s=!0)},p(l,[c]){a&&a.p&&(!r||c&512)&&zp(a,o,l,l[9],r?Lp(o,l[9],c,null):Bp(l[9]),null),(!r||c&2)&&(t.disabled=l[1]),(!r||c&1)&&Gt(t,"outline",l[0]==="outline"),(!r||c&1)&&Gt(t,"filled",l[0]==="filled"),(!r||c&1)&&Gt(t,"light",l[0]==="light"),(!r||c&4)&&Gt(t,"success",l[2]==="success"),(!r||c&4)&&Gt(t,"warning",l[2]==="warning"),(!r||c&4)&&Gt(t,"danger",l[2]==="danger"),(!r||c&8)&&Gt(t,"size-small",l[3]==="small"),(!r||c&8)&&Gt(t,"size-large",l[3]==="large"),(!r||c&16)&&Gt(t,"round",l[4])},i(l){r||(Ae(a,l),r=!0)},o(l){Re(a,l),r=!1},d(l){l&&ye(e),l&&ye(t),a&&a.d(l),s=!1,nl(i)}}}function bxt(n,e,t){let{$$slots:r={},$$scope:s}=e,{variant:i="outline"}=e,{disabled:o=!1}=e,{type:a="default"}=e,{size:l="medium"}=e,{round:c=!1}=e,{pressed:u=!1}=e;const h=Fc();function f(){t(8,u=!0),h("pressed",u)}function d(){u&&(t(8,u=!1),h("pressed",u))}function p(g){h("click",g)}function m(g){lM.call(this,n,g)}return n.$$set=g=>{"variant"in g&&t(0,i=g.variant),"disabled"in g&&t(1,o=g.disabled),"type"in g&&t(2,a=g.type),"size"in g&&t(3,l=g.size),"round"in g&&t(4,c=g.round),"pressed"in g&&t(8,u=g.pressed),"$$scope"in g&&t(9,s=g.$$scope)},[i,o,a,l,c,f,d,p,u,s,r,m]}let zs=class extends Rn{constructor(e){super(),$n(this,e,bxt,yxt,Nn,{variant:0,disabled:1,type:2,size:3,round:4,pressed:8})}};function vxt(n){let e,t,r;return{c(){e=Ce("input"),te(e,"class","marcelle svelte-1mutsa0"),e.disabled=n[2],te(e,"type",n[3]),te(e,"placeholder",n[1]),e.value=n[0]},m(s,i){be(s,e,i),t||(r=Ir(e,"input",n[4]),t=!0)},p(s,[i]){i&4&&(e.disabled=s[2]),i&8&&te(e,"type",s[3]),i&2&&te(e,"placeholder",s[1]),i&1&&e.value!==s[0]&&(e.value=s[0])},i:ot,o:ot,d(s){s&&ye(e),t=!1,r()}}}function wxt(n,e,t){let{placeholder:r=""}=e,{disabled:s=!1}=e,{type:i="text"}=e,{value:o=null}=e;function a(l){t(0,o=l.currentTarget.value)}return n.$$set=l=>{"placeholder"in l&&t(1,r=l.placeholder),"disabled"in l&&t(2,s=l.disabled),"type"in l&&t(3,i=l.type),"value"in l&&t(0,o=l.value)},[o,r,s,i,a]}class xxt extends Rn{constructor(e){super(),$n(this,e,wxt,vxt,Nn,{placeholder:1,disabled:2,type:3,value:0})}}function Sxt(n){let e,t,r,s,i,o,a,l;const c=n[2].default,u=Fp(c,n,n[1],null);return{c(){e=Ce("div"),t=Ce("div"),r=Ce("div"),s=st(),i=Ce("div"),u&&u.c(),te(r,"class","absolute inset-0 bg-gray-500 opacity-50"),te(t,"class","overlay svelte-1sg0y6b"),te(i,"class","modal svelte-1sg0y6b"),te(e,"class","modal-container svelte-1sg0y6b")},m(h,f){be(h,e,f),ue(e,t),ue(t,r),ue(e,s),ue(e,i),u&&u.m(i,null),o=!0,a||(l=[Ir(r,"click",n[0]),Ir(r,"keypress",jC(n[3]))],a=!0)},p(h,[f]){u&&u.p&&(!o||f&2)&&zp(u,c,h,h[1],o?Lp(c,h[1],f,null):Bp(h[1]),null)},i(h){o||(Ae(u,h),o=!0)},o(h){Re(u,h),o=!1},d(h){h&&ye(e),u&&u.d(h),a=!1,nl(l)}}}function _xt(n,e,t){let{$$slots:r={},$$scope:s}=e;const i=Fc();function o(){i("quit")}const a=l=>l.key==="Escape"&&o();return n.$$set=l=>{"$$scope"in l&&t(1,s=l.$$scope)},[o,s,r,a]}class cce extends Rn{constructor(e){super(),$n(this,e,_xt,Sxt,Nn,{quit:0})}get quit(){return this.$$.ctx[0]}}function Cxt(n){return n<.5?4*n*n*n:.5*Math.pow(2*n-2,3)+1}function FV(n){const e=n-1;return e*e*e+1}function cM(n,{delay:e=0,duration:t=400,easing:r=Cxt,amount:s=5,opacity:i=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.filter==="none"?"":o.filter,c=a*(1-i),[u,h]=Xwt(s);return{delay:e,duration:t,easing:r,css:(f,d)=>`opacity: ${a-c*d}; filter: ${l} blur(${d*u}${h});`}}function zq(n,{delay:e=0,duration:t=400,easing:r=FV,axis:s="y"}={}){const i=getComputedStyle(n),o=+i.opacity,a=s==="y"?"height":"width",l=parseFloat(i[a]),c=s==="y"?["top","bottom"]:["left","right"],u=c.map(y=>`${y[0].toUpperCase()}${y.slice(1)}`),h=parseFloat(i[`padding${u[0]}`]),f=parseFloat(i[`padding${u[1]}`]),d=parseFloat(i[`margin${u[0]}`]),p=parseFloat(i[`margin${u[1]}`]),m=parseFloat(i[`border${u[0]}Width`]),g=parseFloat(i[`border${u[1]}Width`]);return{delay:e,duration:t,easing:r,css:y=>`overflow: hidden;opacity: ${Math.min(y*20,1)*o};${a}: ${y*l}px;padding-${c[0]}: ${y*h}px;padding-${c[1]}: ${y*f}px;margin-${c[0]}: ${y*d}px;margin-${c[1]}: ${y*p}px;border-${c[0]}-width: ${y*m}px;border-${c[1]}-width: ${y*g}px;`}}function Bq(n,{delay:e=0,duration:t=400,easing:r=FV,start:s=0,opacity:i=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.transform==="none"?"":o.transform,c=1-s,u=a*(1-i);return{delay:e,duration:t,easing:r,css:(h,f)=>`
			transform: ${l} scale(${1-c*f});
			opacity: ${a-u*f}
		`}}function kxt(n,{from:e,to:t},r={}){const s=getComputedStyle(n),i=s.transform==="none"?"":s.transform,[o,a]=s.transformOrigin.split(" ").map(parseFloat),l=e.left+e.width*o/t.width-(t.left+o),c=e.top+e.height*a/t.height-(t.top+a),{delay:u=0,duration:h=d=>Math.sqrt(d)*120,easing:f=FV}=r;return{delay:u,duration:lx(h)?h(Math.sqrt(l*l+c*c)):h,easing:f,css:(d,p)=>{const m=p*l,g=p*c,y=d+p*e.width/t.width,b=d+p*e.height/t.height;return`transform: ${i} translate(${m}px, ${g}px) scale(${y}, ${b});`}}}function Vq(n,e,t){const r=n.slice();return r[6]=e[t].title,r[7]=e[t].message,r[8]=e[t].type,r[9]=e[t].id,r}function Txt(n){let e;return{c(){e=vs("path"),te(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z`)},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function Ext(n){let e;return{c(){e=vs("path"),te(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z`)},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function Uq(n,e){let t,r,s,i,o,a,l,c=e[6]+"",u,h,f,d=e[7]+"",p,m,g,y,b,x,w,_,C,k,A=ot,M,I,N;function O(X,G){if(X[8]==="default")return Ext;if(X[8]==="danger")return Txt}let R=O(e),D=R&&R(e);function z(){return e[3](e[9])}function B(...X){return e[4](e[9],...X)}return{key:n,first:null,c(){t=Ce("div"),r=Ce("div"),s=Ce("div"),i=vs("svg"),D&&D.c(),o=st(),a=Ce("div"),l=Ce("p"),u=Qe(c),h=st(),f=Ce("p"),p=Qe(d),m=st(),g=Ce("div"),y=vs("svg"),b=vs("title"),x=Qe("Close"),w=vs("path"),_=st(),te(i,"class","notification-svg mr-4 svelte-c58nio"),te(i,"xmlns","http://www.w3.org/2000/svg"),te(i,"viewBox","0 0 20 20"),Gt(i,"default",e[8]==="default"),Gt(i,"danger",e[8]==="danger"),te(s,"class","py-1"),te(l,"class","my-1 font-bold"),te(f,"class","my-1 text-sm"),te(w,"d",`M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1
              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10
              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0
              1.698z`),te(y,"class","notification-svg ml-4 cursor-pointer svelte-c58nio"),te(y,"role","button"),te(y,"xmlns","http://www.w3.org/2000/svg"),te(y,"viewBox","0 0 20 20"),Gt(y,"default",e[8]==="default"),Gt(y,"danger",e[8]==="danger"),te(r,"class","flex items-start"),te(t,"class","notification-card svelte-c58nio"),te(t,"role","alert"),Gt(t,"default",e[8]==="default"),Gt(t,"danger",e[8]==="danger"),this.first=t},m(X,G){be(X,t,G),ue(t,r),ue(r,s),ue(s,i),D&&D.m(i,null),ue(r,o),ue(r,a),ue(a,l),ue(l,u),ue(a,h),ue(a,f),ue(f,p),ue(r,m),ue(r,g),ue(g,y),ue(y,b),ue(b,x),ue(y,w),ue(t,_),M=!0,I||(N=[Ir(y,"click",z),Ir(y,"keypress",jC(B))],I=!0)},p(X,G){e=X,R!==(R=O(e))&&(D&&D.d(1),D=R&&R(e),D&&(D.c(),D.m(i,null))),(!M||G&1)&&Gt(i,"default",e[8]==="default"),(!M||G&1)&&Gt(i,"danger",e[8]==="danger"),(!M||G&1)&&c!==(c=e[6]+"")&&dn(u,c),(!M||G&1)&&d!==(d=e[7]+"")&&dn(p,d),(!M||G&1)&&Gt(y,"default",e[8]==="default"),(!M||G&1)&&Gt(y,"danger",e[8]==="danger"),(!M||G&1)&&Gt(t,"default",e[8]==="default"),(!M||G&1)&&Gt(t,"danger",e[8]==="danger")},r(){k=t.getBoundingClientRect()},f(){lxt(t),A(),nce(t,k)},a(){A(),A=axt(t,k,kxt,{})},i(X){M||(Pc(()=>{M&&(C||(C=xv(t,cM,{amount:10},!0)),C.run(1))}),M=!0)},o(X){C||(C=xv(t,cM,{amount:10},!1)),C.run(0),M=!1},d(X){X&&ye(t),D&&D.d(),X&&C&&C.end(),I=!1,nl(N)}}}function Ixt(n){let e,t=[],r=new Map,s,i=n[0].slice(0,10);const o=a=>a[9];for(let a=0;a<i.length;a+=1){let l=Vq(n,i,a),c=o(l);r.set(c,t[a]=Uq(c,l))}return{c(){e=Ce("div");for(let a=0;a<t.length;a+=1)t[a].c();te(e,"class","marcelle notification-container svelte-c58nio")},m(a,l){be(a,e,l);for(let c=0;c<t.length;c+=1)t[c]&&t[c].m(e,null);s=!0},p(a,[l]){if(l&3){i=a[0].slice(0,10),yr();for(let c=0;c<t.length;c+=1)t[c].r();t=lce(t,l,o,1,a,i,r,e,mxt,Uq,null,Vq);for(let c=0;c<t.length;c+=1)t[c].a();br()}},i(a){if(!s){for(let l=0;l<i.length;l+=1)Ae(t[l]);s=!0}},o(a){for(let l=0;l<t.length;l+=1)Re(t[l]);s=!1},d(a){a&&ye(e);for(let l=0;l<t.length;l+=1)t[l].d()}}}function Axt(n,e,t){let{notifications:r=[]}=e;function s(c){t(0,r=r.filter(u=>u.id!==c))}let i=1;function o({title:c,message:u,type:h="default",duration:f=3e3}){const d={id:i,title:c,message:u,type:h};i+=1,t(0,r=[...r,d]),f>0&&setTimeout(()=>{s(d.id)},f)}const a=c=>s(c),l=(c,u)=>u.key==="Escape"&&s(c);return n.$$set=c=>{"notifications"in c&&t(0,r=c.notifications)},[r,s,o,a,l]}class Mxt extends Rn{constructor(e){super(),$n(this,e,Axt,Ixt,Nn,{notifications:0,add:2})}get add(){return this.$$.ctx[2]}}function Wq(n,e,t){const r=n.slice();return r[7]=e[t],r}function Nxt(n){let e,t;return{c(){e=vs("svg"),t=vs("path"),te(t,"d","M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"),te(e,"class","fill-current inline-block h-5 w-5"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"viewBox","0 0 20 20")},m(r,s){be(r,e,s),ue(e,t)},p:ot,d(r){r&&ye(e)}}}function Gq(n){let e,t,r,s,i,o=n[0],a=[];for(let l=0;l<o.length;l+=1)a[l]=Hq(Wq(n,o,l));return{c(){e=Ce("div"),t=Ce("div"),r=Ce("div");for(let l=0;l<a.length;l+=1)a[l].c();te(r,"class","py-1"),te(r,"role","menu"),te(r,"aria-orientation","vertical"),te(r,"aria-labelledby","options-menu"),te(t,"class","origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"),te(e,"class","origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50"),Gt(e,"hidden",!1)},m(l,c){be(l,e,c),ue(e,t),ue(t,r);for(let u=0;u<a.length;u+=1)a[u]&&a[u].m(r,null);i=!0},p(l,c){if(c&9){o=l[0];let u;for(u=0;u<o.length;u+=1){const h=Wq(l,o,u);a[u]?a[u].p(h,c):(a[u]=Hq(h),a[u].c(),a[u].m(r,null))}for(;u<a.length;u+=1)a[u].d(1);a.length=o.length}},i(l){i||(Pc(()=>{i&&(s||(s=xv(e,zq,{duration:100},!0)),s.run(1))}),i=!0)},o(l){s||(s=xv(e,zq,{duration:100},!1)),s.run(0),i=!1},d(l){l&&ye(e),Vi(a,l),l&&s&&s.end()}}}function Hq(n){let e,t=n[7].text+"",r,s,i,o;function a(){return n[5](n[7])}return{c(){e=Ce("button"),r=Qe(t),s=st(),te(e,"class","text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer")},m(l,c){be(l,e,c),ue(e,r),ue(e,s),i||(o=Ir(e,"click",a),i=!0)},p(l,c){n=l,c&1&&t!==(t=n[7].text+"")&&dn(r,t)},d(l){l&&ye(e),i=!1,o()}}}function $xt(n){let e,t,r,s,i,o,a;r=new zs({props:{size:"small",round:!0,$$slots:{default:[Nxt]},$$scope:{ctx:n}}}),r.$on("click",n[2]);let l=n[1]&&Gq(n);return{c(){e=st(),t=Ce("div"),Pt(r.$$.fragment),s=st(),l&&l.c(),te(t,"class","relative")},m(c,u){be(c,e,u),be(c,t,u),At(r,t,null),ue(t,s),l&&l.m(t,null),i=!0,o||(a=Ir(document.body,"click",n[4]),o=!0)},p(c,[u]){const h={};u&1024&&(h.$$scope={dirty:u,ctx:c}),r.$set(h),c[1]?l?(l.p(c,u),u&2&&Ae(l,1)):(l=Gq(c),l.c(),Ae(l,1),l.m(t,null)):l&&(yr(),Re(l,1,1,()=>{l=null}),br())},i(c){i||(Ae(r.$$.fragment,c),Ae(l),i=!0)},o(c){Re(r.$$.fragment,c),Re(l),i=!1},d(c){c&&ye(e),c&&ye(t),Mt(r),l&&l.d(),o=!1,a()}}}function Rxt(n,e,t){let{actions:r=[]}=e;const s=Fc();let i=!1;function o(u){u.stopPropagation(),i?t(1,i=!1):t(1,i=!0)}function a(u){s("select",u)}const l=()=>{t(1,i=!1)},c=u=>a(u.code);return n.$$set=u=>{"actions"in u&&t(0,r=u.actions)},[r,i,o,a,l,c]}class Pxt extends Rn{constructor(e){super(),$n(this,e,Rxt,$xt,Nn,{actions:0})}}function Dxt(n){let e,t;return{c(){e=Ce("div"),te(e,"class","progress-line svelte-dee3y"),te(e,"style",t=n[0]>=0?`--bar-mr: ${100-Math.floor(n[0]*100)}%;`:"--bar-mr: 0px"),Gt(e,"thin",n[2]),Gt(e,"indeterminate",n[0]===void 0||n[0]===null||n[0]<0),Gt(e,"gray",n[1]==="idle"),Gt(e,"green",n[1]==="success"),Gt(e,"red",n[1]==="danger")},m(r,s){be(r,e,s)},p(r,[s]){s&1&&t!==(t=r[0]>=0?`--bar-mr: ${100-Math.floor(r[0]*100)}%;`:"--bar-mr: 0px")&&te(e,"style",t),s&4&&Gt(e,"thin",r[2]),s&1&&Gt(e,"indeterminate",r[0]===void 0||r[0]===null||r[0]<0),s&2&&Gt(e,"gray",r[1]==="idle"),s&2&&Gt(e,"green",r[1]==="success"),s&2&&Gt(e,"red",r[1]==="danger")},i:ot,o:ot,d(r){r&&ye(e)}}}function Oxt(n,e,t){let{progress:r}=e,{type:s="default"}=e,{thin:i=!1}=e;return n.$$set=o=>{"progress"in o&&t(0,r=o.progress),"type"in o&&t(1,s=o.type),"thin"in o&&t(2,i=o.thin)},[r,s,i]}class uce extends Rn{constructor(e){super(),$n(this,e,Oxt,Dxt,Nn,{progress:0,type:1,thin:2})}}function jq(n,e,t){const r=n.slice();return r[7]=e[t],r}function qq(n){let e,t;return{c(){e=Ce("option"),t=Qe(n[2]),e.__value="",e.value=e.__value,e.disabled=!0,te(e,"class","svelte-g3sqa4")},m(r,s){be(r,e,s),ue(e,t)},p(r,s){s&4&&dn(t,r[2])},d(r){r&&ye(e)}}}function Xq(n){let e,t=n[7]+"",r,s;return{c(){e=Ce("option"),r=Qe(t),e.__value=s=n[7],e.value=e.__value,te(e,"class","svelte-g3sqa4")},m(i,o){be(i,e,o),ue(e,r)},p(i,o){o&2&&t!==(t=i[7]+"")&&dn(r,t),o&2&&s!==(s=i[7])&&(e.__value=s,e.value=e.__value)},d(i){i&&ye(e)}}}function Fxt(n){let e,t,r,s,i,o,a,l=n[2]&&qq(n),c=n[1],u=[];for(let h=0;h<c.length;h+=1)u[h]=Xq(jq(n,c,h));return{c(){e=Ce("div"),t=Ce("select"),l&&l.c(),r=ea();for(let h=0;h<u.length;h+=1)u[h].c();s=st(),i=Ce("div"),i.innerHTML='<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"></path></svg>',te(t,"class","svelte-g3sqa4"),n[0]===void 0&&Pc(()=>n[5].call(t)),Gt(t,"small",n[3]==="small"),te(i,"class","pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700"),te(e,"class","select-container svelte-g3sqa4")},m(h,f){be(h,e,f),ue(e,t),l&&l.m(t,null),ue(t,r);for(let d=0;d<u.length;d+=1)u[d]&&u[d].m(t,null);Fq(t,n[0],!0),ue(e,s),ue(e,i),o||(a=[Ir(t,"change",n[5]),Ir(t,"change",n[6])],o=!0)},p(h,[f]){if(h[2]?l?l.p(h,f):(l=qq(h),l.c(),l.m(t,r)):l&&(l.d(1),l=null),f&2){c=h[1];let d;for(d=0;d<c.length;d+=1){const p=jq(h,c,d);u[d]?u[d].p(p,f):(u[d]=Xq(p),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}f&3&&Fq(t,h[0]),f&8&&Gt(t,"small",h[3]==="small")},i:ot,o:ot,d(h){h&&ye(e),l&&l.d(),Vi(u,h),o=!1,nl(a)}}}function Lxt(n,e,t){let{options:r}=e,{value:s=""}=e,{placeholder:i="Select an Option"}=e,{size:o="normal"}=e;const a=Fc();function l(){s=ext(this),t(0,s),t(1,r)}const c=u=>a("change",u.currentTarget.value);return n.$$set=u=>{"options"in u&&t(1,r=u.options),"value"in u&&t(0,s=u.value),"placeholder"in u&&t(2,i=u.placeholder),"size"in u&&t(3,o=u.size)},[s,r,i,o,a,l,c]}let zxt=class extends Rn{constructor(e){super(),$n(this,e,Lxt,Fxt,Nn,{options:1,value:0,placeholder:2,size:3})}};function Bxt(n){let e;return{c(){e=Ce("span"),e.innerHTML='<span class="spinner svelte-zvuq20"><span class="dot1 svelte-zvuq20"></span>  <span class="dot2 svelte-zvuq20"></span></span>',te(e,"class","spinner-container svelte-zvuq20")},m(t,r){be(t,e,r)},p:ot,i:ot,o:ot,d(t){t&&ye(e)}}}class LV extends Rn{constructor(e){super(),$n(this,e,null,Bxt,Nn,{})}}function Vxt(n){let e,t,r,s,i,o,a,l,c;return{c(){e=Ce("label"),t=Ce("input"),r=st(),s=Ce("span"),s.innerHTML=`<span class="track svelte-smv03c"></span> 
    <span class="thumb svelte-smv03c"></span>`,i=st(),o=Ce("span"),a=Qe(n[1]),te(t,"type","checkbox"),t.disabled=n[2],te(t,"class","svelte-smv03c"),te(s,"class","switch svelte-smv03c"),te(o,"class","ml-2 cursor-pointer"),te(e,"class","marcelle")},m(u,h){be(u,e,h),ue(e,t),t.checked=n[0],ue(e,r),ue(e,s),ue(e,i),ue(e,o),ue(o,a),l||(c=Ir(t,"change",n[3]),l=!0)},p(u,[h]){h&4&&(t.disabled=u[2]),h&1&&(t.checked=u[0]),h&2&&dn(a,u[1])},i:ot,o:ot,d(u){u&&ye(e),l=!1,c()}}}function Uxt(n,e,t){let{text:r=""}=e,{checked:s=!1}=e,{disabled:i=!1}=e;function o(){s=this.checked,t(0,s)}return n.$$set=a=>{"text"in a&&t(1,r=a.text),"checked"in a&&t(0,s=a.checked),"disabled"in a&&t(2,i=a.disabled)},[s,r,i,o]}class Wxt extends Rn{constructor(e){super(),$n(this,e,Uxt,Vxt,Nn,{text:1,checked:0,disabled:2})}}const ib=[];function aS(n,e=ot){let t;const r=new Set;function s(a){if(Nn(n,a)&&(n=a,t)){const l=!ib.length;for(const c of r)c[1](),ib.push(c,n);if(l){for(let c=0;c<ib.length;c+=2)ib[c][0](ib[c+1]);ib.length=0}}}function i(a){s(a(n))}function o(a,l=ot){const c=[a,l];return r.add(c),r.size===1&&(t=e(s)||ot),a(n),()=>{r.delete(c),r.size===0&&t&&(t(),t=null)}}return{set:s,update:i,subscribe:o}}function Gxt(n){let e,t;const r=n[1].default,s=Fp(r,n,n[0],null);return{c(){e=Ce("div"),s&&s.c(),te(e,"class","tabs")},m(i,o){be(i,e,o),s&&s.m(e,null),t=!0},p(i,[o]){s&&s.p&&(!t||o&1)&&zp(s,r,i,i[0],t?Lp(r,i[0],o,null):Bp(i[0]),null)},i(i){t||(Ae(s,i),t=!0)},o(i){Re(s,i),t=!1},d(i){i&&ye(e),s&&s.d(i)}}}const zV={};function Hxt(n,e,t){let{$$slots:r={},$$scope:s}=e;const i=[],o=[],a=aS(null),l=aS(null);return cxt(zV,{registerTab:c=>{i.push(c),a.update(u=>u||c),wv(()=>{const u=i.indexOf(c);i.splice(u,1),a.update(h=>h===c?i[u]||i[i.length-1]:h)})},registerPanel:c=>{o.push(c),l.update(u=>u||c),wv(()=>{const u=o.indexOf(c);o.splice(u,1),l.update(h=>h===c?o[u]||o[o.length-1]:h)})},selectTab:c=>{const u=i.indexOf(c);a.set(c),l.set(o[u])},selectedTab:a,selectedPanel:l}),n.$$set=c=>{"$$scope"in c&&t(0,s=c.$$scope)},[s,r]}class jxt extends Rn{constructor(e){super(),$n(this,e,Hxt,Gxt,Nn,{})}}function qxt(n){let e,t,r,s;const i=n[5].default,o=Fp(i,n,n[4],null);return{c(){e=Ce("div"),o&&o.c(),te(e,"class","text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-d0yt2a"),te(e,"role","tab"),Gt(e,"selected",n[0]===n[1])},m(a,l){be(a,e,l),o&&o.m(e,null),t=!0,r||(s=Ir(e,"click",n[6]),r=!0)},p(a,[l]){o&&o.p&&(!t||l&16)&&zp(o,i,a,a[4],t?Lp(i,a[4],l,null):Bp(a[4]),null),(!t||l&3)&&Gt(e,"selected",a[0]===a[1])},i(a){t||(Ae(o,a),t=!0)},o(a){Re(o,a),t=!1},d(a){a&&ye(e),o&&o.d(a),r=!1,s()}}}function Xxt(n,e,t){let r,{$$slots:s={},$$scope:i}=e;const o={},{registerTab:a,selectTab:l,selectedTab:c}=sce(zV);RV(n,c,h=>t(0,r=h)),a(o);const u=()=>l(o);return n.$$set=h=>{"$$scope"in h&&t(4,i=h.$$scope)},[r,o,l,c,i,s,u]}class TE extends Rn{constructor(e){super(),$n(this,e,Xxt,qxt,Nn,{})}}function Kq(n){let e;const t=n[4].default,r=Fp(t,n,n[3],null);return{c(){r&&r.c()},m(s,i){r&&r.m(s,i),e=!0},p(s,i){r&&r.p&&(!e||i&8)&&zp(r,t,s,s[3],e?Lp(t,s[3],i,null):Bp(s[3]),null)},i(s){e||(Ae(r,s),e=!0)},o(s){Re(r,s),e=!1},d(s){r&&r.d(s)}}}function Kxt(n){let e,t,r=n[0]===n[1]&&Kq(n);return{c(){r&&r.c(),e=ea()},m(s,i){r&&r.m(s,i),be(s,e,i),t=!0},p(s,[i]){s[0]===s[1]?r?(r.p(s,i),i&1&&Ae(r,1)):(r=Kq(s),r.c(),Ae(r,1),r.m(e.parentNode,e)):r&&(yr(),Re(r,1,1,()=>{r=null}),br())},i(s){t||(Ae(r),t=!0)},o(s){Re(r),t=!1},d(s){r&&r.d(s),s&&ye(e)}}}function Yxt(n,e,t){let r,{$$slots:s={},$$scope:i}=e;const o={},{registerPanel:a,selectedPanel:l}=sce(zV);return RV(n,l,c=>t(0,r=c)),a(o),n.$$set=c=>{"$$scope"in c&&t(3,i=c.$$scope)},[r,o,l,i,s]}class EE extends Rn{constructor(e){super(),$n(this,e,Yxt,Kxt,Nn,{})}}function Zxt(n){let e;return{c(){e=Qe(n[1])},m(t,r){be(t,e,r)},p(t,r){r&2&&dn(e,t[1])},i:ot,o:ot,d(t){t&&ye(e)}}}function Jxt(n){let e=n[1].toPrecision(2)+"",t;return{c(){t=Qe(e)},m(r,s){be(r,t,s)},p(r,s){s&2&&e!==(e=r[1].toPrecision(2)+"")&&dn(t,e)},i:ot,o:ot,d(r){r&&ye(t)}}}function Qxt(n){let e,t=cL(n[1]).join(", ")+"",r,s;return{c(){e=Qe("Array("),r=Qe(t),s=Qe(")")},m(i,o){be(i,e,o),be(i,r,o),be(i,s,o)},p(i,o){o&2&&t!==(t=cL(i[1]).join(", ")+"")&&dn(r,t)},i:ot,o:ot,d(i){i&&ye(e),i&&ye(r),i&&ye(s)}}}function e1t(n){let e=n[3](n[1])+"",t;return{c(){t=Qe(e)},m(r,s){be(r,t,s)},p(r,s){s&2&&e!==(e=r[3](r[1])+"")&&dn(t,e)},i:ot,o:ot,d(r){r&&ye(t)}}}function t1t(n){let e;const t=n[4].default,r=Fp(t,n,n[7],null);return{c(){r&&r.c()},m(s,i){r&&r.m(s,i),e=!0},p(s,i){r&&r.p&&(!e||i&128)&&zp(r,t,s,s[7],e?Lp(t,s[7],i,null):Bp(s[7]),null)},i(s){e||(Ae(r,s),e=!0)},o(s){Re(r,s),e=!1},d(s){r&&r.d(s)}}}function n1t(n){let e,t;return e=new zs({props:{size:"small",$$slots:{default:[i1t]},$$scope:{ctx:n}}}),e.$on("click",n[6]),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&130&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function r1t(n){let e,t=n[1].text+"",r,s,i;return{c(){e=Ce("sl-button"),r=Qe(t),Sb(e,"type","text"),Sb(e,"size","small")},m(o,a){be(o,e,a),ue(e,r),s||(i=Ir(e,"click",n[5]),s=!0)},p(o,a){a&2&&t!==(t=o[1].text+"")&&dn(r,t)},i:ot,o:ot,d(o){o&&ye(e),s=!1,i()}}}function s1t(n){let e,t;return{c(){e=Ce("img"),te(e,"alt","thumbnail"),iM(e.src,t=n[1])||te(e,"src",t),te(e,"width","30"),te(e,"height","30"),te(e,"class","rounded-md")},m(r,s){be(r,e,s)},p(r,s){s&2&&!iM(e.src,t=r[1])&&te(e,"src",t)},i:ot,o:ot,d(r){r&&ye(e)}}}function i1t(n){let e;return{c(){e=Qe(n[1])},m(t,r){be(t,e,r)},p(t,r){r&2&&dn(e,t[1])},d(t){t&&ye(e)}}}function o1t(n){let e,t,r,s;const i=[s1t,r1t,n1t,t1t,e1t,Qxt,Jxt,Zxt],o=[];function a(l,c){return l[0]==="image"?0:l[0]==="link"?1:l[0]==="action"?2:l[0]==="slot"?3:l[0]==="date"?4:l[0]==="array"?5:typeof l[1]=="number"?6:7}return t=a(n),r=o[t]=i[t](n),{c(){e=Ce("td"),r.c(),te(e,"class","svelte-fe0rg4")},m(l,c){be(l,e,c),o[t].m(e,null),s=!0},p(l,[c]){let u=t;t=a(l),t===u?o[t].p(l,c):(yr(),Re(o[u],1,1,()=>{o[u]=null}),br(),r=o[t],r?r.p(l,c):(r=o[t]=i[t](l),r.c()),Ae(r,1),r.m(e,null))},i(l){s||(Ae(r),s=!0)},o(l){Re(r),s=!1},d(l){l&&ye(e),o[t].d()}}}function cL(n){return Array.isArray(n)?n.length>0&&Array.isArray(n[0])?[n.length,...cL(n[0])]:[n.length]:[]}function a1t(n,e,t){let{$$slots:r={},$$scope:s}=e,{type:i="generic"}=e,{value:o=null}=e;const a=Fc();function l(h){try{return xje(Date.parse(h),{includeSeconds:!0,addSuffix:!0})}catch(f){return console.log("Date Parsing Error",h,f),h}}const c=()=>{console.log("GOTO:",o.href)},u=()=>a("action",o);return n.$$set=h=>{"type"in h&&t(0,i=h.type),"value"in h&&t(1,o=h.value),"$$scope"in h&&t(7,s=h.$$scope)},[i,o,a,l,r,c,u,s]}class hce extends Rn{constructor(e){super(),$n(this,e,a1t,o1t,Nn,{type:0,value:1})}}function Yq(n){let e,t,r,s;const i=[c1t,l1t],o=[];function a(l,c){return l[2]?0:1}return e=a(n),t=o[e]=i[e](n),{c(){t.c(),r=ea()},m(l,c){o[e].m(l,c),be(l,r,c),s=!0},p(l,c){let u=e;e=a(l),e===u?o[e].p(l,c):(yr(),Re(o[u],1,1,()=>{o[u]=null}),br(),t=o[e],t?t.p(l,c):(t=o[e]=i[e](l),t.c()),Ae(t,1),t.m(r.parentNode,r))},i(l){s||(Ae(t),s=!0)},o(l){Re(t),s=!1},d(l){o[e].d(l),l&&ye(r)}}}function l1t(n){let e,t;return e=new zs({props:{round:!0,size:"small",$$slots:{default:[u1t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&64&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function c1t(n){let e,t;return e=new zs({props:{round:!0,size:"small",$$slots:{default:[h1t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&64&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function u1t(n){let e,t;return{c(){e=vs("svg"),t=vs("path"),te(t,"stroke-linecap","round"),te(t,"stroke-linejoin","round"),te(t,"stroke-width","2"),te(t,"d","M16 17l-4 4m0 0l-4-4m4 4V3"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"class","h-6 w-6"),te(e,"fill","none"),te(e,"viewBox","0 0 24 24"),te(e,"stroke","currentColor")},m(r,s){be(r,e,s),ue(e,t)},p:ot,d(r){r&&ye(e)}}}function h1t(n){let e,t;return{c(){e=vs("svg"),t=vs("path"),te(t,"stroke-linecap","round"),te(t,"stroke-linejoin","round"),te(t,"stroke-width","2"),te(t,"d","M8 7l4-4m0 0l4 4m-4-4v18"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"class","h-6 w-6"),te(e,"fill","none"),te(e,"viewBox","0 0 24 24"),te(e,"stroke","currentColor")},m(r,s){be(r,e,s),ue(e,t)},p:ot,d(r){r&&ye(e)}}}function f1t(n){let e,t,r,s,i,o,a=n[1]&&Yq(n);return{c(){e=Ce("th"),t=Ce("span"),r=Ce("span"),s=Qe(n[0]),i=st(),a&&a.c(),ua(r,"margin-top","0.5rem"),ua(r,"margin-bottom","0.5rem"),ua(t,"display","flex"),ua(t,"justify-content","space-between"),ua(t,"align-items","center"),te(e,"class","svelte-1310j1m")},m(l,c){be(l,e,c),ue(e,t),ue(t,r),ue(r,s),ue(t,i),a&&a.m(t,null),o=!0},p(l,[c]){(!o||c&1)&&dn(s,l[0]),l[1]?a?(a.p(l,c),c&2&&Ae(a,1)):(a=Yq(l),a.c(),Ae(a,1),a.m(t,null)):a&&(yr(),Re(a,1,1,()=>{a=null}),br())},i(l){o||(Ae(a),o=!0)},o(l){Re(a),o=!1},d(l){l&&ye(e),a&&a.d()}}}function d1t(n,e,t){let{name:r="name"}=e,{sortable:s=!1}=e,{sorting:i={col:"",ascending:!0}}=e;const o=Fc();let a=!0;function l(){t(2,a=!a),o("sort",{col:r,ascending:a})}return n.$$set=c=>{"name"in c&&t(0,r=c.name),"sortable"in c&&t(1,s=c.sortable),"sorting"in c&&t(4,i=c.sorting)},n.$$.update=()=>{n.$$.dirty&17&&i.col===r&&t(2,a=i.ascending)},[r,s,a,l,i]}class p1t extends Rn{constructor(e){super(),$n(this,e,d1t,f1t,Nn,{name:0,sortable:1,sorting:4})}}function Zq(n,e,t){const r=n.slice();return r[10]=e[t].name,r[11]=e[t].multiple,r[12]=e[t].confirm,r}function m1t(n){let e=n[10]+"",t;return{c(){t=Qe(e)},m(r,s){be(r,t,s)},p(r,s){s&2&&e!==(e=r[10]+"")&&dn(t,e)},d(r){r&&ye(t)}}}function Jq(n){let e,t;function r(){return n[7](n[10],n[12])}return e=new zs({props:{size:"small",disabled:n[11]===!1&&n[0].length>1,type:n[10]==="delete"?"danger":"default",$$slots:{default:[m1t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){Pt(e.$$.fragment)},m(s,i){At(e,s,i),t=!0},p(s,i){n=s;const o={};i&3&&(o.disabled=n[11]===!1&&n[0].length>1),i&2&&(o.type=n[10]==="delete"?"danger":"default"),i&32770&&(o.$$scope={dirty:i,ctx:n}),e.$set(o)},i(s){t||(Ae(e.$$.fragment,s),t=!0)},o(s){Re(e.$$.fragment,s),t=!1},d(s){Mt(e,s)}}}function Qq(n){let e,t;return e=new cce({props:{$$slots:{default:[b1t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&32780&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function g1t(n){let e;return{c(){e=Qe("Cancel")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function y1t(n){let e;return{c(){e=Qe("Confirm")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function b1t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d;return l=new zs({props:{type:"danger",$$slots:{default:[g1t]},$$scope:{ctx:n}}}),l.$on("click",n[8]),f=new zs({props:{variant:"filled",$$slots:{default:[y1t]},$$scope:{ctx:n}}}),f.$on("click",n[4]),{c(){e=Ce("div"),t=Ce("p"),r=Qe("Do you want to "),s=Qe(n[2]),i=Qe(" the selected items?"),o=st(),a=Ce("div"),Pt(l.$$.fragment),c=st(),u=Ce("span"),h=st(),Pt(f.$$.fragment),te(u,"class","w-2"),te(a,"class","w-full flex justify-end"),te(e,"class","p-8")},m(p,m){be(p,e,m),ue(e,t),ue(t,r),ue(t,s),ue(t,i),ue(e,o),ue(e,a),At(l,a,null),ue(a,c),ue(a,u),ue(a,h),At(f,a,null),d=!0},p(p,m){(!d||m&4)&&dn(s,p[2]);const g={};m&32768&&(g.$$scope={dirty:m,ctx:p}),l.$set(g);const y={};m&32768&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(Ae(l.$$.fragment,p),Ae(f.$$.fragment,p),d=!0)},o(p){Re(l.$$.fragment,p),Re(f.$$.fragment,p),d=!1},d(p){p&&ye(e),Mt(l),Mt(f)}}}function v1t(n){let e,t,r,s,i=n[1],o=[];for(let c=0;c<i.length;c+=1)o[c]=Jq(Zq(n,i,c));const a=c=>Re(o[c],1,1,()=>{o[c]=null});let l=n[3]&&Qq(n);return{c(){e=Ce("div");for(let c=0;c<o.length;c+=1)o[c].c();t=st(),l&&l.c(),r=ea(),te(e,"class","actions")},m(c,u){be(c,e,u);for(let h=0;h<o.length;h+=1)o[h]&&o[h].m(e,null);be(c,t,u),l&&l.m(c,u),be(c,r,u),s=!0},p(c,[u]){if(u&35){i=c[1];let h;for(h=0;h<i.length;h+=1){const f=Zq(c,i,h);o[h]?(o[h].p(f,u),Ae(o[h],1)):(o[h]=Jq(f),o[h].c(),Ae(o[h],1),o[h].m(e,null))}for(yr(),h=i.length;h<o.length;h+=1)a(h);br()}c[3]?l?(l.p(c,u),u&8&&Ae(l,1)):(l=Qq(c),l.c(),Ae(l,1),l.m(r.parentNode,r)):l&&(yr(),Re(l,1,1,()=>{l=null}),br())},i(c){if(!s){for(let u=0;u<i.length;u+=1)Ae(o[u]);Ae(l),s=!0}},o(c){o=o.filter(Boolean);for(let u=0;u<o.length;u+=1)Re(o[u]);Re(l),s=!1},d(c){c&&ye(e),Vi(o,c),c&&ye(t),l&&l.d(c),c&&ye(r)}}}function w1t(n,e,t){let{provider:r}=e,{actions:s}=e,{selected:i}=e;const o=Fc();let a="",l=!1;async function c(){if(a==="delete")for(const d of i)await r.delete(d);else o("action",[a,i]);t(3,l=!1),t(0,i=[]),o("selected",i)}function u(d,p){t(2,a=d),!(!a||i.length===0)&&(p?t(3,l=!0):c())}const h=(d,p)=>u(d,p),f=()=>{t(3,l=!1)};return n.$$set=d=>{"provider"in d&&t(6,r=d.provider),"actions"in d&&t(1,s=d.actions),"selected"in d&&t(0,i=d.selected)},[i,s,a,l,c,u,r,h,f]}class x1t extends Rn{constructor(e){super(),$n(this,e,w1t,v1t,Nn,{provider:6,actions:1,selected:0})}}function e9(n){let e,t,r;function s(o){n[11](o)}let i={provider:n[1],actions:n[2]};return n[0]!==void 0&&(i.selected=n[0]),e=new x1t({props:i}),So.push(()=>ux(e,"selected",s)),e.$on("selected",n[12]),e.$on("action",n[13]),{c(){Pt(e.$$.fragment)},m(o,a){At(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.provider=o[1]),a&4&&(l.actions=o[2]),!t&&a&1&&(t=!0,l.selected=o[0],cx(()=>t=!1)),e.$set(l)},i(o){r||(Ae(e.$$.fragment,o),r=!0)},o(o){Re(e.$$.fragment,o),r=!1},d(o){Mt(e,o)}}}function S1t(n){let e,t;return{c(){e=vs("svg"),t=vs("path"),te(t,"stroke-linecap","round"),te(t,"stroke-linejoin","round"),te(t,"stroke-width","2"),te(t,"d","M15 19l-7-7 7-7"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"class","h-3 w-3"),te(e,"fill","none"),te(e,"viewBox","0 0 24 24"),te(e,"stroke","currentColor")},m(r,s){be(r,e,s),ue(e,t)},p:ot,d(r){r&&ye(e)}}}function _1t(n){let e,t;return{c(){e=vs("svg"),t=vs("path"),te(t,"stroke-linecap","round"),te(t,"stroke-linejoin","round"),te(t,"stroke-width","2"),te(t,"d","M9 5l7 7-7 7"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"class","h-3 w-3"),te(e,"fill","none"),te(e,"viewBox","0 0 24 24"),te(e,"stroke","currentColor")},m(r,s){be(r,e,s),ue(e,t)},p:ot,d(r){r&&ye(e)}}}function C1t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,_,C,k,A,M,I=n[2].length>0&&n[0].length>0&&e9(n);return l=new zxt({props:{size:"small",options:["10","20","50","all"],value:n[5].toString()}}),l.$on("change",n[14]),y=new zs({props:{round:!0,disabled:n[3]===1,$$slots:{default:[S1t]},$$scope:{ctx:n}}}),y.$on("click",n[15]),C=new zs({props:{round:!0,disabled:n[3]===n[6],$$slots:{default:[_1t]},$$scope:{ctx:n}}}),C.$on("click",n[17]),{c(){e=Ce("div"),t=Ce("div"),I&&I.c(),r=st(),s=Ce("div"),i=Ce("div"),o=Qe(`Items per page:
			`),a=Ce("div"),Pt(l.$$.fragment),c=st(),u=Ce("div"),h=Qe(n[7]),f=Qe("-"),d=Qe(n[8]),p=Qe(" of "),m=Qe(n[4]),g=st(),Pt(y.$$.fragment),b=st(),x=Ce("input"),_=st(),Pt(C.$$.fragment),te(t,"class","actions"),te(a,"class","w-12 ml-2"),te(i,"class","flex items-center mx-4"),te(u,"class","mx-3"),te(x,"class","marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50"),x.value=w=n[3].toString(),te(s,"class","flex items-center"),te(e,"class","table-footer svelte-13k2ee6")},m(N,O){be(N,e,O),ue(e,t),I&&I.m(t,null),ue(e,r),ue(e,s),ue(s,i),ue(i,o),ue(i,a),At(l,a,null),ue(s,c),ue(s,u),ue(u,h),ue(u,f),ue(u,d),ue(u,p),ue(u,m),ue(s,g),At(y,s,null),ue(s,b),ue(s,x),ue(s,_),At(C,s,null),k=!0,A||(M=Ir(x,"blur",n[16]),A=!0)},p(N,[O]){N[2].length>0&&N[0].length>0?I?(I.p(N,O),O&5&&Ae(I,1)):(I=e9(N),I.c(),Ae(I,1),I.m(t,null)):I&&(yr(),Re(I,1,1,()=>{I=null}),br());const R={};O&32&&(R.value=N[5].toString()),l.$set(R),(!k||O&128)&&dn(h,N[7]),(!k||O&256)&&dn(d,N[8]),(!k||O&16)&&dn(m,N[4]);const D={};O&8&&(D.disabled=N[3]===1),O&262144&&(D.$$scope={dirty:O,ctx:N}),y.$set(D),(!k||O&8&&w!==(w=N[3].toString())&&x.value!==w)&&(x.value=w);const z={};O&72&&(z.disabled=N[3]===N[6]),O&262144&&(z.$$scope={dirty:O,ctx:N}),C.$set(z)},i(N){k||(Ae(I),Ae(l.$$.fragment,N),Ae(y.$$.fragment,N),Ae(C.$$.fragment,N),k=!0)},o(N){Re(I),Re(l.$$.fragment,N),Re(y.$$.fragment,N),Re(C.$$.fragment,N),k=!1},d(N){N&&ye(e),I&&I.d(),Mt(l),Mt(y),Mt(C),A=!1,M()}}}function k1t(n,e,t){let r,{provider:s}=e,{actions:i}=e,{selected:o}=e,a=1,l=1,c=0,u=0,h=0,f=()=>{};function d(_){t(3,a=_),s.page(_)}function p(_){o=_,t(0,o)}function m(_){lM.call(this,n,_)}function g(_){lM.call(this,n,_)}const y=({detail:_})=>{const C=_==="all"?h:parseInt(_);s.paginate(C),t(5,r=C)},b=()=>{d(a-1)},x=_=>{let C=parseInt(_.currentTarget.value);isNaN(C)||d(Math.max(1,Math.min(l,C)))},w=()=>{d(a+1)};return n.$$set=_=>{"provider"in _&&t(1,s=_.provider),"actions"in _&&t(2,i=_.actions),"selected"in _&&t(0,o=_.selected)},n.$$.update=()=>{n.$$.dirty&2&&t(5,r=s.options.itemsPerPage),n.$$.dirty&1082&&(f(),t(10,f=s.total.subscribe(_=>{_===void 0||_===0?(t(6,l=1),t(7,c=0),t(8,u=0),t(4,h=0)):(t(6,l=Math.ceil(h/r)),t(7,c=(a-1)*r+1),t(8,u=Math.min(h||0,a*r)),t(4,h=_))})))},[o,s,i,a,h,r,l,c,u,d,f,p,m,g,y,b,x,w]}class T1t extends Rn{constructor(e){super(),$n(this,e,k1t,C1t,Nn,{provider:1,actions:2,selected:0})}}function t9(n,e,t){const r=n.slice();return r[22]=e[t],r[24]=t,r}function n9(n,e,t){const r=n.slice();return r[25]=e[t].type,r[26]=e[t].name,r}function r9(n,e,t){const r=n.slice();return r[26]=e[t].name,r[29]=e[t].sortable,r}function s9(n){let e,t,r,s,i,o,a,l;return{c(){e=Ce("div"),t=Ce("sl-alert"),r=Ce("sl-icon"),s=st(),i=Ce("strong"),i.textContent="Table Data Error",o=Ce("br"),a=st(),l=Qe(n[9]),Sb(r,"slot","icon"),Sb(r,"name","check2-circle"),Sb(t,"type","danger"),Sb(t,"open",""),te(e,"class","service-error")},m(c,u){be(c,e,u),ue(e,t),ue(t,r),ue(t,s),ue(t,i),ue(t,o),ue(t,a),ue(t,l)},p(c,u){u[0]&512&&dn(l,c[9])},d(c){c&&ye(e)}}}function i9(n){let e,t=!n[4]&&o9(n);return{c(){e=Ce("th"),t&&t.c(),te(e,"class","svelte-12gp9na")},m(r,s){be(r,e,s),t&&t.m(e,null)},p(r,s){r[4]?t&&(t.d(1),t=null):t?t.p(r,s):(t=o9(r),t.c(),t.m(e,null))},d(r){r&&ye(e),t&&t.d()}}}function o9(n){let e,t,r,s;return{c(){e=Ce("input"),te(e,"type","checkbox"),e.checked=t=n[6].length>0&&n[6].length===n[10].length},m(i,o){be(i,e,o),r||(s=Ir(e,"click",n[12]),r=!0)},p(i,o){o[0]&1088&&t!==(t=i[6].length>0&&i[6].length===i[10].length)&&(e.checked=t)},d(i){i&&ye(e),r=!1,s()}}}function a9(n){let e,t;return e=new p1t({props:{name:n[26],sortable:n[29],sorting:n[7]}}),e.$on("sort",n[11]),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s[0]&1&&(i.name=r[26]),s[0]&1&&(i.sortable=r[29]),s[0]&128&&(i.sorting=r[7]),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function l9(n){let e,t;return e=new hce({props:{type:"slot",$$slots:{default:[E1t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s[0]&64|s[1]&2&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function E1t(n){let e,t,r,s;function i(...o){return n[16](n[24],...o)}return{c(){e=Ce("input"),te(e,"type","checkbox"),e.checked=t=n[6].includes(n[24])},m(o,a){be(o,e,a),r||(s=Ir(e,"click",i),r=!0)},p(o,a){n=o,a[0]&64&&t!==(t=n[6].includes(n[24]))&&(e.checked=t)},d(o){o&&ye(e),r=!1,s()}}}function c9(n){let e,t;function r(...s){return n[17](n[24],...s)}return e=new hce({props:{type:n[25],value:n[22][n[26]]}}),e.$on("action",r),{c(){Pt(e.$$.fragment)},m(s,i){At(e,s,i),t=!0},p(s,i){n=s;const o={};i[0]&1&&(o.type=n[25]),i[0]&1025&&(o.value=n[22][n[26]]),e.$set(o)},i(s){t||(Ae(e.$$.fragment,s),t=!0)},o(s){Re(e.$$.fragment,s),t=!1},d(s){Mt(e,s)}}}function u9(n){let e,t,r,s,i=n[3]&&l9(n),o=n[0],a=[];for(let c=0;c<o.length;c+=1)a[c]=c9(n9(n,o,c));const l=c=>Re(a[c],1,1,()=>{a[c]=null});return{c(){e=Ce("tr"),i&&i.c(),t=st();for(let c=0;c<a.length;c+=1)a[c].c();r=st(),te(e,"class","svelte-12gp9na")},m(c,u){be(c,e,u),i&&i.m(e,null),ue(e,t);for(let h=0;h<a.length;h+=1)a[h]&&a[h].m(e,null);ue(e,r),s=!0},p(c,u){if(c[3]?i?(i.p(c,u),u[0]&8&&Ae(i,1)):(i=l9(c),i.c(),Ae(i,1),i.m(e,t)):i&&(yr(),Re(i,1,1,()=>{i=null}),br()),u[0]&17409){o=c[0];let h;for(h=0;h<o.length;h+=1){const f=n9(c,o,h);a[h]?(a[h].p(f,u),Ae(a[h],1)):(a[h]=c9(f),a[h].c(),Ae(a[h],1),a[h].m(e,r))}for(yr(),h=o.length;h<a.length;h+=1)l(h);br()}},i(c){if(!s){Ae(i);for(let u=0;u<o.length;u+=1)Ae(a[u]);s=!0}},o(c){Re(i),a=a.filter(Boolean);for(let u=0;u<a.length;u+=1)Re(a[u]);s=!1},d(c){c&&ye(e),i&&i.d(),Vi(a,c)}}}function I1t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d=n[9]&&s9(n),p=n[3]&&i9(n),m=n[0],g=[];for(let k=0;k<m.length;k+=1)g[k]=a9(r9(n,m,k));const y=k=>Re(g[k],1,1,()=>{g[k]=null});let b=n[10],x=[];for(let k=0;k<b.length;k+=1)x[k]=u9(t9(n,b,k));const w=k=>Re(x[k],1,1,()=>{x[k]=null});function _(k){n[18](k)}let C={provider:n[1],actions:n[2]};return n[6]!==void 0&&(C.selected=n[6]),u=new T1t({props:C}),So.push(()=>ux(u,"selected",_)),u.$on("action",n[19]),{c(){d&&d.c(),e=st(),t=Ce("div"),r=Ce("table"),s=Ce("thead"),i=Ce("tr"),p&&p.c(),o=st();for(let k=0;k<g.length;k+=1)g[k].c();a=st(),l=Ce("tbody");for(let k=0;k<x.length;k+=1)x[k].c();c=st(),Pt(u.$$.fragment),te(i,"class","svelte-12gp9na"),te(s,"class","svelte-12gp9na"),te(l,"class","svelte-12gp9na"),te(r,"class","svelte-12gp9na"),te(t,"class","marcelle table-container svelte-12gp9na")},m(k,A){d&&d.m(k,A),be(k,e,A),be(k,t,A),ue(t,r),ue(r,s),ue(s,i),p&&p.m(i,null),ue(i,o);for(let M=0;M<g.length;M+=1)g[M]&&g[M].m(i,null);ue(r,a),ue(r,l);for(let M=0;M<x.length;M+=1)x[M]&&x[M].m(l,null);ue(t,c),At(u,t,null),f=!0},p(k,A){if(k[9]?d?d.p(k,A):(d=s9(k),d.c(),d.m(e.parentNode,e)):d&&(d.d(1),d=null),k[3]?p?p.p(k,A):(p=i9(k),p.c(),p.m(i,o)):p&&(p.d(1),p=null),A[0]&2177){m=k[0];let I;for(I=0;I<m.length;I+=1){const N=r9(k,m,I);g[I]?(g[I].p(N,A),Ae(g[I],1)):(g[I]=a9(N),g[I].c(),Ae(g[I],1),g[I].m(i,null))}for(yr(),I=m.length;I<g.length;I+=1)y(I);br()}if(A[0]&25673){b=k[10];let I;for(I=0;I<b.length;I+=1){const N=t9(k,b,I);x[I]?(x[I].p(N,A),Ae(x[I],1)):(x[I]=u9(N),x[I].c(),Ae(x[I],1),x[I].m(l,null))}for(yr(),I=b.length;I<x.length;I+=1)w(I);br()}const M={};A[0]&2&&(M.provider=k[1]),A[0]&4&&(M.actions=k[2]),!h&&A[0]&64&&(h=!0,M.selected=k[6],cx(()=>h=!1)),u.$set(M)},i(k){if(!f){for(let A=0;A<m.length;A+=1)Ae(g[A]);for(let A=0;A<b.length;A+=1)Ae(x[A]);Ae(u.$$.fragment,k),f=!0}},o(k){g=g.filter(Boolean);for(let A=0;A<g.length;A+=1)Re(g[A]);x=x.filter(Boolean);for(let A=0;A<x.length;A+=1)Re(x[A]);Re(u.$$.fragment,k),f=!1},d(k){d&&d.d(k),k&&ye(e),k&&ye(t),p&&p.d(),Vi(g,k),Vi(x,k),Mt(u)}}}function A1t(n,e,t){let r,s,i,o=ot,a=()=>(o(),o=es(s,R=>t(9,i=R)),s),l,c=ot,u=()=>(c(),c=es(r,R=>t(10,l=R)),r);n.$$.on_destroy.push(()=>o()),n.$$.on_destroy.push(()=>c());let{columns:h}=e,{provider:f}=e,{actions:d=[]}=e,{selectable:p=!0}=e,{singleSelection:m=!1}=e,{selection:g=[]}=e,y=[];const b=Fc();let x={col:"",ascending:!0};function w({detail:R}){t(7,x=R),f.sort(R)}async function _(){t(15,g=await Promise.all(y.map(f.get.bind(f)))),b("selection",g)}function C(){y.length===oS(r).length?t(6,y=[]):t(6,y=oS(r).map((R,D)=>D)),_()}function k(R,D){m?(t(6,y=D.currentTarget.checked?[R]:[]),_()):D.currentTarget.checked?y.includes(R)||(t(6,y=y.concat([R])),_()):(t(6,y=y.filter(z=>z!==R)),_())}async function A([R,D]){const z=Array.isArray(D)?await Promise.all(D.map(f.get.bind(f))):await f.get(D);b(R,z)}const M=(R,D)=>k(R,D),I=(R,{detail:D})=>{A([D,R])};function N(R){y=R,t(6,y),t(15,g),t(5,r),t(1,f)}const O=({detail:R})=>A(R);return n.$$set=R=>{"columns"in R&&t(0,h=R.columns),"provider"in R&&t(1,f=R.provider),"actions"in R&&t(2,d=R.actions),"selectable"in R&&t(3,p=R.selectable),"singleSelection"in R&&t(4,m=R.singleSelection),"selection"in R&&t(15,g=R.selection)},n.$$.update=()=>{n.$$.dirty[0]&2&&u(t(5,r=f.data)),n.$$.dirty[0]&2&&a(t(8,s=f.error)),n.$$.dirty[0]&32800&&t(6,y=g.map(R=>oS(r).indexOf(R)))},[h,f,d,p,m,r,y,x,s,i,l,w,C,k,A,g,M,I,N,O]}class fce extends Rn{constructor(e){super(),$n(this,e,A1t,I1t,Nn,{columns:0,provider:1,actions:2,selectable:3,singleSelection:4,selection:15},null,[-1,-1])}}function M1t(n){let e,t;const r=n[1].default,s=Fp(r,n,n[0],null);return{c(){e=Ce("div"),s&&s.c(),te(e,"class","flex border-solid border-0 border-b border-gray-200 mb-2")},m(i,o){be(i,e,o),s&&s.m(e,null),t=!0},p(i,[o]){s&&s.p&&(!t||o&1)&&zp(s,r,i,i[0],t?Lp(r,i[0],o,null):Bp(i[0]),null)},i(i){t||(Ae(s,i),t=!0)},o(i){Re(s,i),t=!1},d(i){i&&ye(e),s&&s.d(i)}}}function N1t(n,e,t){let{$$slots:r={},$$scope:s}=e;return n.$$set=i=>{"$$scope"in i&&t(0,s=i.$$scope)},[s,r]}class $1t extends Rn{constructor(e){super(),$n(this,e,N1t,M1t,Nn,{})}}const h9={itemsPerPage:10};class dce{constructor(e=h9){zt(this,"options");zt(this,"data",aS([]));zt(this,"total",aS(0));zt(this,"error",aS(null));this.options={...h9,...e}}paginate(e){this.options.itemsPerPage=e,this.update()}async get(e){const t=oS(this.data);return e>=0&&e<t.length?t[e]:null}}class R1t extends dce{constructor({data:t,...r}){super(r);zt(this,"rawData");zt(this,"currentPage",1);this.rawData=t,this.total.set(t.length),this.data.set(this.rawData.slice(0,this.options.itemsPerPage))}async update(){this.page(this.currentPage)}async page(t){this.data.set(this.rawData.slice((t-1)*this.options.itemsPerPage,Math.min(t*this.options.itemsPerPage,this.rawData.length))),this.currentPage=t}async sort(t){this.rawData.sort((r,s)=>r[t.col]>s[t.col]?t.ascending?1:-1:r[t.col]<s[t.col]?t.ascending?-1:1:0),this.page(this.currentPage)}async delete(t){return this.rawData.splice(t,1),this.page(this.currentPage),null}}class P1t extends dce{constructor({service:t,columns:r,transform:s,...i}){super(i);zt(this,"service");zt(this,"query");zt(this,"transform");this.service=t,this.transform=s||{},this.query={$sort:{updatedAt:-1},$limit:this.options.itemsPerPage},r&&(this.query.$select=r.map(o=>o.name).concat(["id"])),this.update(),this.service.on("created",this.update.bind(this)),this.service.on("patched",this.update.bind(this)),this.service.on("updated",this.update.bind(this)),this.service.on("removed",this.update.bind(this))}paginate(t){super.paginate(t),this.query.$limit=this.options.itemsPerPage,this.update()}async update(){try{const t=await this.service.find({query:this.query}),r=t.data.map((s,i)=>{const o=Object.entries(this.transform).map(([a,l])=>{try{return{[a]:l(s,i)}}catch{return{[a]:"transform error"}}}).reduce((a,l)=>({...a,...l}),{});return{...s,...o}});this.data.set(r),this.total.set(t.total),this.error.set(null)}catch(t){this.data.set([]),this.total.set(0),this.error.set(t)}}async page(t){this.query.$skip=(t-1)*this.query.$limit,this.update()}async sort(t){const{col:r,ascending:s}=t;r?this.query.$sort={[r]:s?1:-1}:delete this.query.$sort,this.update()}async delete(t){const r=oS(this.data)[t];return await this.service.remove(r.id),this.update(),r}}function f9(n){let e,t,r;return t=new uce({props:{progress:n[2],thin:!0}}),{c(){e=Ce("div"),Pt(t.$$.fragment),te(e,"class","absolute top-0 left-0 right-0")},m(s,i){be(s,e,i),At(t,e,null),r=!0},p(s,i){const o={};i&4&&(o.progress=s[2]),t.$set(o)},i(s){r||(Ae(t.$$.fragment,s),r=!0)},o(s){Re(t.$$.fragment,s),r=!1},d(s){s&&ye(e),Mt(t)}}}function d9(n){let e,t;return e=new LV({}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function D1t(n){let e,t,r,s,i,o,a,l=n[2]!==!1&&f9(n),c=n[1]&&d9();const u=n[4].default,h=Fp(u,n,n[3],null);return{c(){e=Ce("div"),l&&l.c(),t=st(),r=Ce("span"),s=Qe(n[0]),i=st(),c&&c.c(),o=st(),h&&h.c(),te(r,"class","card-title"),te(e,"class","card-container svelte-xnhseh")},m(f,d){be(f,e,d),l&&l.m(e,null),ue(e,t),ue(e,r),ue(r,s),ue(e,i),c&&c.m(e,null),ue(e,o),h&&h.m(e,null),a=!0},p(f,[d]){f[2]!==!1?l?(l.p(f,d),d&4&&Ae(l,1)):(l=f9(f),l.c(),Ae(l,1),l.m(e,t)):l&&(yr(),Re(l,1,1,()=>{l=null}),br()),(!a||d&1)&&dn(s,f[0]),f[1]?c?d&2&&Ae(c,1):(c=d9(),c.c(),Ae(c,1),c.m(e,o)):c&&(yr(),Re(c,1,1,()=>{c=null}),br()),h&&h.p&&(!a||d&8)&&zp(h,u,f,f[3],a?Lp(u,f[3],d,null):Bp(f[3]),null)},i(f){a||(Ae(l),Ae(c),Ae(h,f),a=!0)},o(f){Re(l),Re(c),Re(h,f),a=!1},d(f){f&&ye(e),l&&l.d(),c&&c.d(),h&&h.d(f)}}}function O1t(n,e,t){let{$$slots:r={},$$scope:s}=e,{title:i}=e,{loading:o=!1}=e,{progress:a=!1}=e;return n.$$set=l=>{"title"in l&&t(0,i=l.title),"loading"in l&&t(1,o=l.loading),"progress"in l&&t(2,a=l.progress),"$$scope"in l&&t(3,s=l.$$scope)},[i,o,a,s,r]}class rl extends Rn{constructor(e){super(),$n(this,e,O1t,D1t,Nn,{title:0,loading:1,progress:2})}}let h1,IE;function uM({title:n,message:e,duration:t=3e3,type:r="default"}){h1||(h1=document.createElement("div"),h1.id="notification-container",document.body.appendChild(h1),IE=new Mxt({target:h1})),IE==null||IE.add({title:n,message:e,duration:t,type:r})}function Dn(n,e,t,r){var s=arguments.length,i=s<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(i=(s<3?o(i):s>3?o(e,t,i):o(e,t))||i);return s>3&&i&&Object.defineProperty(e,t,i),i}function Ue(n,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?n!==e||!r:!e.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(n):r?r.value:e.get(n)}function Vn(n,e,t,r,s){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?n!==e||!s:!e.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?s.call(n,t):s?s.value=t:e.set(n,t),t}function Qm(){}var _m,Cm,rI;function F1t(n){}const p9=Kje();function L1t(n){return n&&typeof n=="object"&&n.run!==void 0}function BV(n){return n&&typeof n=="object"&&n.run!==void 0&&n.id!==void 0}class gt{constructor(e,t=void 0){this.id=gt.nextId++,this.subscribers=[],this.value=void 0,this.ready=!1,_m.set(this,void 0),Cm.set(this,!1),rI.set(this,void 0),Vn(this,_m,!!t,"f");const[r,s]=uH(),[i,o]=uH();this.stopStream=r,this.set=l=>{this.value=l,i(l)};let a;BV(e)?(a=e,t===void 0&&Vn(this,_m,e.holding,"f"),e.holding&&(this.value=e.value)):L1t(e)?a=e:(a=iH(()=>this.value,FD(e)),this.value=e),this.stream=C9e(oH(this.runListeners.bind(this),cH(s,aH(a,o))))}get(){return this.value}get holding(){return Ue(this,_m,"f")}run(e,t){return this.stream.run(e,t)}runListeners(e){this.value=e;for(const t of this.subscribers)t(e)}subscribe(e=F1t,t=Qm){Ue(this,_m,"f")&&Ue(this,Cm,"f")&&e(this.value);const r=s=>{t(),e(s)};return this.subscribers.push(r),Ue(this,Cm,"f")||this.start(),()=>{const s=this.subscribers.indexOf(r);s!==-1&&this.subscribers.splice(s,1)}}async start(){return Ue(this,Cm,"f")||(gt.numActive++,v8e(this.stream,p9).then(()=>{gt.numActive--}),Vn(this,Cm,!0,"f"),Vn(this,rI,new Promise((e,t)=>{ON({run:()=>{this.ready=!0,e()},error(r){t(r)},dispose(){}},p9)}),"f")),Ue(this,rI,"f")}stop(){this.stopStream(void 0),Vn(this,Cm,!1,"f")}hold(e=!0){return Vn(this,_m,e,"f"),this}thru(e){return new gt(e(this))}startWith(e){const t=new gt(M9e(e,this));return this.holding&&(t.value=e),t}continueWith(e){const t=new gt(P9e(e,this));return this.holding&&(t.value=this.value),t}map(e){const t=new gt(iH(e,this));return this.holding&&(t.value=e(this.value)),t}constant(e){const t=new gt(N9e(e,this));return this.holding&&(t.value=e),t}tap(e){const t=new gt(oH(e,this));return this.holding&&(t.value=this.value),t}ap(e){const t=new gt($9e(e,this));return this.holding&&e.holding&&(t.value=e.get()(this.value)),t}scan(e,t){const r=new gt(A9e(e,t,this));return this.holding&&(r.value=t),r}loop(e,t){return new gt(I9e(e,t,this))}withItems(e){return new gt(V9e(e,this))}zipItems(e,t){return new gt(B9e(e,t,this))}switchLatest(){return new gt(Gqe(this))}join(){return new gt(KQ(this))}chain(e){return new gt(R9e(e,this))}concatMap(e){return new gt(D9e(e,this))}mergeConcurrently(e){return new gt(O9e(e,this))}mergeMapConcurrently(e,t){return new gt(F9e(e,t,this))}merge(e){const t=new gt(aH(e,this));return this.holding&&(t.value=this.value),t}combine(e,t){const r=new gt(L9e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}zip(e,t){const r=new gt(U9e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}resample(e){return new gt(lH(this,e))}sample(e){return new gt(lH(e,this))}snapshot(e,t){return new gt(z9e(e,t,this))}filter(e){const t=new gt(W9e(e,this));return this.holding&&e(this.value)&&(t.value=this.value),t}skipRepeats(){const e=new gt(Kqe(this));return this.holding&&(e.value=this.value),e}skipRepeatsWith(e){return new gt(G9e(e,this))}slice(e,t){return new gt(q9e(e,t,this))}take(e){return new gt(H9e(e,this))}skip(e){return new gt(j9e(e,this))}takeWhile(e){return new gt(X9e(e,this))}skipWhile(e){return new gt(K9e(e,this))}skipAfter(e){return new gt(Y9e(e,this))}until(e){return new gt(cH(e,this))}since(e){return new gt(Z9e(e,this))}during(e){return new gt(J9e(e,this))}delay(e){return new gt(Q9e(e,this))}withLocalTime(e){return new gt(E9e(e,this))}throttle(e){return new gt(e7e(e,this))}debounce(e){return new gt(t7e(e,this))}awaitPromises(){return new gt(m9e(this))}recoverWith(e){return new gt(n7e(e,this))}static empty(){return new gt(Xi())}static never(){return new gt(AS())}static now(e){return new gt(FD(e))}static at(e,t){return new gt(UQ(e,t))}static periodic(e){return new gt(y8e(e))}static throwError(e){return new gt(w9e(e))}}_m=new WeakMap,Cm=new WeakMap,rI=new WeakMap;gt.nextId=0;gt.numActive=0;var xc;(function(n){n[n.Debug=0]="Debug",n[n.Info=1]="Info",n[n.Warning=2]="Warning",n[n.Error=3]="Error"})(xc||(xc={}));const R1=new gt(AS()),ma={log(...n){console.log(...n),R1.set([xc.Info,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},debug(...n){R1.set([xc.Debug,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},info(...n){this.log(...n)},warning(...n){R1.set([xc.Warning,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},error(...n){console.error(...n),R1.set([xc.Error,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])}};function z1t(){return R1}function Ln(n,e,t){const r=t.value;return t.value=function(...i){try{return r.apply(this,i)}catch(o){return ma.error(o),uM({title:o.name,message:o.message,type:"danger"}),o}},t}class wp extends Error{constructor(e){super(e),this.name="Training Error"}}function Ya(n,{duration:e=3e3}={}){ma.error(`${n.name}: ${n.message}`,n),uM({title:n.name,message:n.message,type:"danger",duration:e})}function pce(n,e){return async function*(){let t=0;for await(const r of n())e(r,t++)&&(yield await r)}}function GP(n,e){return async function*(){let t=0;for await(const r of n())yield await e(r,t++)}}function B1t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){yield*pce(n,(t,r)=>r>=e)()}}function V1t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){let t=e;for await(const r of n()){if(t--===0)return;yield await r}}}function HP(n,e){return async function*(){yield*await n(),yield*await e}}async function U1t(n,e){let t=0;for await(const r of n())e(r,t++)}async function W1t(n){const e=[];for await(const t of n())e.push(t);return e}function G1t(n,e){return async function*(){const t=e()[Symbol.asyncIterator]();for await(const r of n()){const s=await t.next();if(s.done)return;yield[r,s.value]}}}async function H1t(n,e,t){let[r,s]=[-1,t];for await(const i of n())s=++r===0&&t===void 0?i:e(s,i,r);if(t===void 0&&r===-1)throw new Error("Sequence contains no elements.");return s}function j1t(n){return typeof n[Symbol.iterator]=="function"}function q1t(n){return typeof n[Symbol.asyncIterator]=="function"}class gl{constructor(e){this.source=e}[Symbol.asyncIterator](){return this.source()[Symbol.asyncIterator]()}entries(){return new gl(GP(this.source,(e,t)=>[t,e]))}keys(){return new gl(GP(this.source,(e,t)=>t))}values(){return new gl(this.source)}forEach(e){return U1t(this.source,e)}concat(e){return j1t(e)?new gl(HP(this.source,async function*(t){yield*t}(e))):q1t(e)?new gl(HP(this.source,e)):new gl(HP(this.source,async function*(t){yield t}(e)))}reduce(e,t){return H1t(this.source,e,t)}filter(e){return new gl(pce(this.source,e))}take(e){return new gl(V1t(this.source,e))}skip(e){return new gl(B1t(this.source,e))}map(e){return new gl(GP(this.source,e))}zip(e){return new gl(G1t(this.source,e))}toArray(){return W1t(this.source)}}function jP(n){return n&&typeof n=="object"&&!Array.isArray(n)}function wl(n,...e){if(!e.length)return n;const t=e.shift(),r={...n};if(jP(n)&&jP(t))for(const s in t)jP(t[s])?(r[s]||Object.assign(r,{[s]:{}}),r[s]=wl(r[s],t[s])):Object.assign(r,{[s]:t[s]});return wl(r,...e)}window&&(window.onerror=n=>{typeof n=="string"&&uM({title:"An error occurred",message:n,type:"danger"})},window.addEventListener("unhandledrejection",n=>{uM({title:"An error occurred",message:n.reason,type:"danger"})}));let X1t=0;class Lc{constructor(){this.id=`component-${String(X1t++).padStart(3,"0")}`,this.$$={streams:[],app:void 0},l7e(this)}destroy(){var e;(e=this.$$.app)===null||e===void 0||e.$destroy(),this.$$.app=void 0}start(){this.$$.streams=Object.entries(this).filter(([e,t])=>e[0]==="$"&&BV(t)).map(([,e])=>(e.start(),e))}stop(){for(const e of this.$$.streams)e.stop()}dispose(){this.destroy(),this.stop()}}let qP=~~(Math.random()*16777215);const XP=parseInt((Math.random()*16777215).toString(),10);function K1t(){const n=~~(Date.now()/1e3),e=Math.floor(Math.random()*1e5);qP=(qP+1)%16777215;const t=qP,r=new Uint8Array(12);return r[3]=n&255,r[2]=n>>8&255,r[1]=n>>16&255,r[0]=n>>24&255,r[6]=XP&255,r[5]=XP>>8&255,r[4]=XP>>16&255,r[8]=e&255,r[7]=e>>8&255,r[11]=t&255,r[10]=t>>8&255,r[9]=t>>16&255,r.reduce((s,i)=>s+`0${i.toString(16)}`.slice(-2),"")}const km=document.createElement("canvas"),ob=km.getContext("2d"),f1=new Image;function m9(n){return new Promise((e,t)=>{n?(f1.addEventListener("load",()=>{km.width=f1.width,km.height=f1.height,ob==null||ob.drawImage(f1,0,0,km.width,km.height),e(ob==null?void 0:ob.getImageData(0,0,km.width,km.height))},!1),f1.src=n):t()})}function Y1t(n){const{data:e,service:t}=n;return n.data={[t.id]:K1t(),...e},n}function gm(n){const{result:e,params:t}=n;if(e){if(e._id)e.id=e._id,delete e._id;else if(e.total&&Array.isArray(e.data))for(const[r,s]of e.data.entries())s._id&&(e.data[r].id=e.data[r]._id,delete e.data[r]._id)}else t&&t.query&&(t.query.id&&(n.params.query._id=n.params.query.id,delete n.params.query.id),t.query.$select&&t.query.$select.includes("id")&&!t.query.$select.includes("_id")&&n.params.query.$select.push("_id"));return n}function Z1t(n){return n.data||(n.data={}),n.data.createdAt=new Date,n.data.updatedAt=n.data.createdAt,n}function g9(n){return!n.data||!n.data.createdAt||(n.data.updatedAt=new Date),n}function J1t(n,e){return t=>{const{data:r}=t;return t.data={[n]:e,...r},t}}function d1(n,e){return t=>(t.params=t.params||{},t.params.query=t.params.query||{},t.params.query[n]=e,t)}const sI=document.createElement("canvas"),Q1t=sI.getContext("2d");async function eSt(n){const{data:e}=n;for(const[t,r]of Object.entries(e))if(r instanceof ImageData){const s=r.width,i=r.height;sI.width=s,sI.height=i,Q1t.putImageData(r,0,0),n.data[t]=sI.toDataURL("image/jpeg")}return n}async function y9(n){if(!n.result)return n;const{result:e}=n,t=r=>r&&typeof r=="string"&&r.slice(0,22)==="data:image/jpeg;base64";if(e._id)for(const[r,s]of Object.entries(e).filter(([i])=>i!=="thumbnail"))t(s)&&(e[r]=await m9(s));else if(e.total&&Array.isArray(e.data))for(const[r,s]of e.data.entries())for(const[i,o]of Object.entries(s).filter(([a])=>a!=="thumbnail"))t(o)&&(e.data[r][i]=await m9(o));return n}async function tSt(n){var e,t;if(!(!((t=(e=n.params)===null||e===void 0?void 0:e.query)===null||t===void 0)&&t.$distinct)||n.type!=="before"||n.method!=="find")return n;const{$distinct:r,...s}=n.params.query;s.$select=[r],s.$skip=0;let i=1;const o=new Set;for(;s.$skip<i;){const a=await n.service.find({query:s});for(const l of a.data)o.add(l[r]);s.$skip+=a.limit,i=a.total}return n.result=Array.from(o),n}function nSt(n){let e;return{c(){e=Qe("Register")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function rSt(n){let e;return{c(){e=Qe("Log In")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function b9(n){let e,t,r,s,i,o,a,l,c;return{c(){e=Ce("div"),t=Ce("span"),t.innerHTML='<i class="fas fa-bell"></i>',r=st(),s=Ce("span"),i=Ce("b"),i.textContent="Login Error",o=st(),a=Qe(n[1]),l=st(),c=Ce("button"),c.innerHTML="<span></span>",te(t,"class","text-xl inline-block mr-5 align-middle"),te(i,"class","capitalize"),te(s,"class","inline-block align-middle mr-8"),te(c,"class","absolute bg-transparent text-2xl font-semibold leading-none right-0 top-0 mt-4 mr-6 outline-none focus:outline-none"),te(e,"class","text-white px-6 py-4 border-0 rounded relative mb-4 bg-red-500")},m(u,h){be(u,e,h),ue(e,t),ue(e,r),ue(e,s),ue(s,i),ue(s,o),ue(s,a),ue(e,l),ue(e,c)},p(u,h){h&2&&dn(a,u[1])},d(u){u&&ye(e)}}}function sSt(n){let e;return{c(){e=Qe("Register")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function iSt(n){let e;return{c(){e=Qe("Log In")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function oSt(n){let e,t,r,s;return{c(){e=Qe(`Already have an account?
        `),t=Ce("button"),t.textContent="Log In",te(t,"class","text-blue-500")},m(i,o){be(i,e,o),be(i,t,o),r||(s=Ir(t,"click",n[2]),r=!0)},p:ot,d(i){i&&ye(e),i&&ye(t),r=!1,s()}}}function aSt(n){let e,t,r,s;return{c(){e=Qe(`Don't have an account?
        `),t=Ce("button"),t.textContent="Register Here",te(t,"class","text-blue-500")},m(i,o){be(i,e,o),be(i,t,o),r||(s=Ir(t,"click",n[2]),r=!0)},p:ot,d(i){i&&ye(e),i&&ye(t),r=!1,s()}}}function lSt(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b;function x(R,D){return R[0]==="login"?rSt:nSt}let w=x(n),_=w(n),C=n[1]&&b9(n);function k(R,D){return R[0]==="login"?iSt:sSt}let A=k(n),M=A(n);function I(R,D){return R[0]==="login"?aSt:oSt}let N=I(n),O=N(n);return{c(){e=Ce("div"),t=Ce("div"),r=Ce("h2"),_.c(),s=st(),i=Ce("p"),i.textContent="This Marcelle application requires authentication.",o=st(),C&&C.c(),a=st(),l=Ce("form"),c=Ce("div"),c.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Email</label> 
        <input type="email" name="email" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Email" style="transition: all 0.15s ease 0s;"/>`,u=st(),h=Ce("div"),h.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Password</label> 
        <input type="password" name="password" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Password" style="transition: all 0.15s ease 0s;"/>`,f=st(),d=Ce("div"),p=Ce("button"),M.c(),m=st(),g=Ce("p"),O.c(),te(r,"class","text-xl"),te(i,"class","text-gray-600"),te(t,"class","p-4 text-center"),te(c,"class","relative w-full mb-3"),te(h,"class","relative w-full mb-3"),te(p,"class","bg-gray-900 text-white active:bg-gray-700 text-sm font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg outline-none focus:outline-none mr-1 mb-1 w-full"),te(p,"type","submit"),ua(p,"transition","all 0.15s ease 0s"),te(d,"class","text-center mt-6"),te(g,"class","my-4"),te(e,"class","marcelle p-12")},m(R,D){be(R,e,D),ue(e,t),ue(t,r),_.m(r,null),ue(t,s),ue(t,i),ue(e,o),C&&C.m(e,null),ue(e,a),ue(e,l),ue(l,c),ue(l,u),ue(l,h),ue(l,f),ue(l,d),ue(d,p),M.m(p,null),ue(e,m),ue(e,g),O.m(g,null),y||(b=Ir(l,"submit",jC(n[7])),y=!0)},p(R,D){w!==(w=x(R))&&(_.d(1),_=w(R),_&&(_.c(),_.m(r,null))),R[1]?C?C.p(R,D):(C=b9(R),C.c(),C.m(e,a)):C&&(C.d(1),C=null),A!==(A=k(R))&&(M.d(1),M=A(R),M&&(M.c(),M.m(p,null))),N===(N=I(R))&&O?O.p(R,D):(O.d(1),O=N(R),O&&(O.c(),O.m(g,null)))},d(R){R&&ye(e),_.d(),C&&C.d(),M.d(),O.d(),y=!1,b()}}}function cSt(n){let e,t;return e=new cce({props:{$$slots:{default:[lSt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&515&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function uSt(n,e,t){const r=Fc();let{dataStore:s}=e,{mode:i="login"}=e,o;function a(){t(0,i=i==="login"?"register":"login")}function l(f){r("terminate",f)}async function c(f){const d=new FormData(f.target);try{const p=await s.login(d.get("email"),d.get("password"));l(p)}catch(p){t(1,o=p)}}async function u(f){const d=new FormData(f.target);try{const p=await s.signup(d.get("email"),d.get("password"));l(p)}catch{l(null)}}const h=f=>i==="login"?c(f):u(f);return n.$$set=f=>{"dataStore"in f&&t(5,s=f.dataStore),"mode"in f&&t(0,i=f.mode)},[i,o,a,c,u,s,l,h]}class hSt extends Rn{constructor(e){super(),$n(this,e,uSt,cSt,Nn,{dataStore:5,mode:0,terminate:6})}get terminate(){return this.$$.ctx[6]}}class _b extends gl{constructor(e,t={}){super(async function*(){const r={query:{},skip:0,take:-1,...t},s=r.take;let i=0,o=[];const a={...r.query,$skip:r.skip,$limit:10};for(;;)try{if(s>0&&i>=s)return;if(i++,o.length>0)yield o.shift();else{const l=await e.find({query:a});if(a.$skip=l.skip+l.limit,o=l.data,o.length>0)yield o.shift();else return}}catch(l){throw l.message=`Error thrown while iterating through a service: ${l.message}`,l}}),this.service=e,this.params={query:{},skip:0,take:-1,...t}}skip(e){return new _b(this.service,{...this.params,skip:e})}take(e){return new _b(this.service,{...this.params,take:e})}select(e){const t=vYe.cloneDeep(this.params);return t.query.$select=e,new _b(this.service,t)}query(e){return new _b(this.service,wl(this.params,{query:e}))}}function fSt(n){return new _b(n)}var iI,P1,D1,mb,O1;function dSt(n){try{new URL(n)}catch{return!1}return!0}var vl;(function(n){n[n.Memory=0]="Memory",n[n.LocalStorage=1]="LocalStorage",n[n.Remote=2]="Remote"})(vl||(vl={}));class pSt{constructor(e="memory"){if(this.requiresAuth=!1,this.apiPrefix="",this.$services=new gt([],!0),iI.set(this,void 0),P1.set(this,void 0),D1.set(this,Promise.resolve()),mb.set(this,!1),O1.set(this,Qm),this.feathers=BKe(),this.location=e,dSt(e)){this.backend=vl.Remote;const t=new URL(e),r=t.host;this.apiPrefix=t.pathname.replace(/\/$/,"");const s=KXe(r,{transports:["websocket"],reconnectionAttempts:5,path:this.apiPrefix+"/socket.io"});this.feathers.configure(KKe(s,{timeout:15e3})),Vn(this,iI,new Promise(i=>{this.feathers.io.on("init",({auth:o})=>{this.requiresAuth=o,o&&this.feathers.configure(pKe({path:`${this.apiPrefix}/authentication`})),i()})}),"f")}else if(e==="localStorage"){this.backend=vl.LocalStorage;const t=r=>bYe({storage:window.localStorage,name:r,id:"_id",multi:!0,paginate:{default:100,max:200}});Vn(this,O1,r=>{this.feathers.use(`/${r}`,t(r))},"f")}else if(e==="memory")this.backend=vl.Memory,Vn(this,O1,t=>{this.feathers.use(`/${t}`,mYe({id:"_id",paginate:{default:100,max:200}}))},"f");else throw new Error(`Cannot process backend location '${e}'`);this.setupAppHooks()}async connect(){return this.backend!==vl.Remote?{email:null}:(Ue(this,P1,"f")||(ma.log(`Connecting to backend ${this.location}...`),Vn(this,P1,new Promise((e,t)=>{this.feathers.io.on("connect",()=>{ma.log(`Connected to backend ${this.location}!`),e()}),this.feathers.io.on("reconnect_failed",()=>{const r=new Error(`Cannot reach backend at location ${this.location}. Is the server running?
          If using locally, run 'npm run backend'`);r.name="DataStore connection error",t(),Ya(r,{duration:0})})}),"f")),await Ue(this,iI,"f"),await Ue(this,P1,"f"),this.authenticate())}async authenticate(){if(!this.requiresAuth)return this.user={email:null},this.user;if(this.user)return this.user;const e=()=>(Vn(this,mb,!0,"f"),new Promise((t,r)=>{this.feathers.reAuthenticate().then(({user:s})=>{Vn(this,mb,!1,"f"),this.user=s,ma.log(`Authenticated as ${s.email}`),t()}).catch(s=>{Vn(this,mb,!1,"f"),r(s)})}));return Vn(this,D1,Ue(this,D1,"f").then(()=>Ue(this,mb,"f")?null:e()),"f"),Ue(this,D1,"f").then(()=>this.user)}async login(e,t){const r=await this.feathers.authenticate({strategy:"local",email:e,password:t});return this.user=r.user,this.user}async loginWithUI(){const e=new hSt({target:document.body,props:{dataStore:this}});return new Promise((t,r)=>{e.$on("terminate",s=>{e.$destroy(),s?t(s):r()})})}async signup(e,t){try{return await this.service("users").create({email:e,password:t}),await this.login(e,t),this.user}catch(r){return ma.error("An error occurred during signup",r),{email:null}}}async logout(){await this.feathers.logout(),document.location.reload()}service(e){const t=Object.keys(this.feathers.services).includes(e);t||(Ue(this,O1,"f").call(this,e),this.$services.set(Object.keys(this.feathers.services)));const r=this.backend===vl.Remote?this.feathers.service(`${this.apiPrefix}/${e}`):this.feathers.service(e);return t||(r.items=()=>fSt(r)),r}setupAppHooks(){const e=this.backend!==vl.Remote?[Y1t]:[],t=this.backend!==vl.Remote?[tSt]:[];this.feathers.hooks({before:{find:[...t,gm],create:[...e,Z1t],update:[g9],patch:[g9]},after:{find:[gm],get:[gm],create:[gm],update:[gm],patch:[gm],remove:[gm]}})}}iI=new WeakMap,P1=new WeakMap,D1=new WeakMap,mb=new WeakMap,O1=new WeakMap;function mce(n){return new pSt(n)}async function L_(n,e,t){const r=document.createElement("a");r.style.display="none",document.body.appendChild(r);const s=new Blob([n],{type:t});r.href=URL.createObjectURL(s),r.download=e,r.click()}async function gce(n){return new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const s=JSON.parse(r.result);e(s)},r.onerror=s=>{t(s)},r.readAsText(n)})}function V$(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[\s_]+/g,"-").toLowerCase()}var F1,L1;class mSt extends Lc{constructor(e,t=mce()){super(),this.title="dataset",this.isDataset=!0,F1.set(this,void 0),this.query={},L1.set(this,new Set),this.$count=new gt(0,!0),this.$changes=new gt([]),this.name=e,this.title=`dataset (${e})`,Vn(this,F1,t,"f"),this.start(),this.ready=new Promise((r,s)=>{Ue(this,F1,"f").connect().then(()=>this.setup()).then(r).catch(i=>{const o=new Error(i==null?void 0:i.message);o.name=`Dataset Error (${e}): datastore connection failed`,Ya(o,{duration:0}),s(o)})})}async setup(){const e=V$(`instances-${this.name}`);this.instanceService=Ue(this,F1,"f").service(e),this.instanceService.__hooks.before.find===void 0&&this.instanceService.hooks({before:{all:[],create:[J1t("datasetName",this.name),eSt],find:[d1("datasetName",this.name)],get:[d1("datasetName",this.name)],update:[d1("datasetName",this.name)],patch:[d1("datasetName",this.name)],remove:[d1("datasetName",this.name)]},after:{find:[y9],get:[y9]}}),this.instanceService.hooks({before:{update:[this.checkUpdates],patch:[this.checkUpdates]}}),await this.reset(),this.watchChanges()}async reset(){const{total:e}=await this.find({query:{$limit:0}});this.$count.set(e),this.$changes.set([{level:"dataset",type:"created"}])}async checkUpdates(e){if(Object.keys(this.query).length===0)return;const t=BH(this.query),r=t(e.data);try{const s=await this.get(e.id);t(s)&&!r&&(this.$count.set(this.$count.get()-1),this.$changes.set([{level:"instance",type:"removed",data:s}]))}catch{Ue(this,L1,"f").add(e.id)}}watchChanges(){const e=BH(this.query);this.instanceService.on("created",r=>{if(!e(r))return;const s={...r,id:r.id||r._id};this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:s}])});const t=r=>{if(!e(r))return;const s={...r,id:r.id||r._id};Ue(this,L1,"f").has(s.id)?(this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:s}]),Ue(this,L1,"f").delete(s.id)):this.$changes.set([{level:"instance",type:"updated",data:s}])};this.instanceService.on("updated",t),this.instanceService.on("patched",t),this.instanceService.on("removed",r=>{if(!e(r))return;this.$count.set(this.$count.get()-1);const s={...r,id:r.id||r._id};this.$changes.set([{level:"instance",type:"removed",data:s}])})}async sift(e={}){return this.query=e,this.ready.then(()=>this.reset())}items(){return this.instanceService.items().query(this.query)}async find(e){const t=wl(e||{},{query:this.query});return this.instanceService.find(t)}async get(e,t){const r=wl(t||{},{query:this.query});return this.instanceService.get(e,r)}async create(e,t){const r=wl(t||{},{query:this.query});return this.instanceService.create(e,r)}async update(e,t,r){const s=wl(r||{},{query:this.query});return this.instanceService.update(e,t,s)}async patch(e,t,r){const s=wl(r||{},{query:this.query});return this.instanceService.patch(e,t,s)}async remove(e,t){const r=wl(t||{},{query:this.query});return this.instanceService.remove(e,r)}async clear(){await this.remove(null,{query:{}})}async distinct(e){const t={$distinct:e,...this.query};return this.instanceService.find({query:t})}async download(){const e=await this.find(),t={marcelleMeta:{type:"dataset"},instances:e.data},r=new Date(Date.now()),s=`${this.title}-${r.toISOString()}.json`;await L_(JSON.stringify(t),s,"text/plain")}async upload(e){const t=e.filter(i=>i.type==="application/json").map(i=>gce(i)),s=(await Promise.all(t)).map(i=>i.instances.map(o=>{const{id:a,...l}=o;return this.create(l).catch(c=>{Ya(c)})}));await Promise.all(s)}mount(){}}F1=new WeakMap,L1=new WeakMap;function gSt(n,e){return new mSt(n,e)}function Ng(n){return typeof n=="object"&&n!==null&&n.isDataset}class t0 extends Lc{constructor(){super(),this.ready=!1,this.$training=new gt({status:"idle"},!0),this.$training.start(),this.$training.subscribe(({status:e})=>{(e==="success"||e==="loaded")&&(this.ready=!0)})}sync(e,t){return this.syncData={name:t,store:e},this.syncData.store.connect().then(()=>{this.syncData.service=this.syncData.store.service(this.serviceName),this.setupSync()}).catch(r=>{const s=new Error(r==null?void 0:r.message);s.name=`Model Sync Error (${t}): datastore connection failed`,Ya(s,{duration:0})}),this}async setupSync(){if(!this.syncData.service)return;const{data:e}=await this.syncData.service.find({query:{name:this.syncData.name,$select:["id"],$limit:1,$sort:{updatedAt:-1}}});let t=null;e.length===1&&(t=e[0].id,this.load(this.syncData.store,t));let r=!1;this.$training.subscribe(({status:i,data:o})=>{(i==="success"||i==="loaded"&&(o==null?void 0:o.source)!=="datastore")&&(r=!0,this.save(this.syncData.store,this.syncData.name,{},t).then(a=>{t=a}))});const s=i=>{(i._id===t||!t&&i.name===this.syncData.name)&&(t=i._id,r||this.load(this.syncData.store,t),r=!1)};this.syncData.service.on("created",s),this.syncData.service.on("updated",s),this.syncData.service.on("patched",s)}async saveToDatastore(e,t,r=null){await e.connect();const s=e.service(this.serviceName);if(!s||!t)return null;let i=r;return r?await s.update(r,t):i=(await s.create(t)).id,ma.info(`Model was saved to data store at location ${e.location}`),i}async loadFromDatastore(e,t){await e.connect();const r=e.service(this.serviceName);if(!r||!t)return null;let s;try{s=await r.get(t)}catch{const{data:o}=await r.find({query:{name:t,$limit:1,$sort:{updatedAt:-1}}});o.length===1&&(s=o[0])}if(s){const i=s.name;ma.info(`Model ${i} was loaded from data store at location ${e.location}`)}return s}mount(){}}function yce(n){if(!n.modelTopology.model_config||!n.modelTopology.model_config.config||!n.modelTopology.model_config.config.layers||n.modelTopology.model_config.config.layers.length>0&&!n.modelTopology.model_config.config.layers[0].class_name)return n;try{let e=!1;for(const[t,r]of n.modelTopology.model_config.config.layers.entries())if(r.class_name==="SeparableConv2D"){const s=["kernel_constraint","kernel_initializer","kernel_regularizer"];for(const i of s)Object.keys(n.modelTopology.model_config.config.layers[t].config).includes(i)&&(e=!0),delete n.modelTopology.model_config.config.layers[t].config[i]}e&&ma.warning("TFJS Model loading: experimentally removing Kernel attributes from SeparableConv2D layers")}catch(e){ma.warning("TFJS Model loading: An error occurred whil experimentally removing Kernel attributes from SeparableConv2D layers",e)}return n}function uL(...n){const e=nN(...n),t=e.load.bind(e);return e.load=async function(){const s=await t();return yce(s)},e}function bce(...n){const e=oY(...n),t=e.load.bind(e);return e.load=async function(){const s=await t();return yce(s)},e}class U$ extends t0{constructor(){super(...arguments),this.serviceName="tfjs-models"}async warmup(){const e=this.model.inputs[0].shape.map(r=>r&&r>0?r:1),t=this.model.predict(Se(()=>ms(e)));await t.data(),t.dispose()}async save(e,t,r,s=null){if(!this.model)return null;let i;if(e.backend===vl.LocalStorage)await this.model.save(`indexeddb://${t}`),i=[["main",`indexeddb://${t}`]];else if(e.backend===vl.Remote){const a={};if(e.requiresAuth){const l=await e.feathers.authentication.getAccessToken(),c=new Headers({Authorization:`Bearer ${l}`});a.requestInit={headers:c}}i=await this.model.save(uL(`${e.location}/tfjs-models/upload`,a)).then(l=>l.responses[0].json())}const o={name:t,files:i,format:"tfjs",metadata:{tfjsModelFormat:this.model instanceof Gd?"layers-model":"graph-model",...this.labels&&{labels:this.labels},...r}};return this.saveToDatastore(e,o,s)}async load(e,t){if(!t)return null;this.$training.set({status:"loading"}),this.ready=!1,await G2();try{const r=await this.loadFromDatastore(e,t);this.loadFn=r.metadata.tfjsModelFormat==="graph-model"?Pl:GS;let s;if(e.backend===vl.LocalStorage)s=await this.loadFn(r.files[0][1]);else if(e.backend===vl.Remote){const i={};if(e.requiresAuth){const o=await e.feathers.authentication.getAccessToken(),a=new Headers({Authorization:`Bearer ${o}`});i.requestInit={headers:a}}s=await this.loadFn(uL(`${e.location}/tfjs-models/${r.id}/model.json`,i))}return s&&(this.model=s,await this.warmup()),r.metadata&&r.metadata.labels?this.labels=r.metadata.labels:this.labels=void 0,this.$training.set({status:"loaded",data:{source:"datastore",url:e.location}}),r}catch(r){throw console.log("[tfjs-model] Loading error",r),this.$training.set({status:"error"}),r}}async download(e){const t=V$(this.title),r={type:"tfjs-model",tfjsModelFormat:this.model instanceof Gd?"layers-model":"graph-model",name:t,...this.labels&&{labels:this.labels},...e},s=new Date(Date.now());await this.model.save(fY(async i=>{const o={modelTopology:i.modelTopology,weightsManifest:[{paths:[`./${t}.weights.bin`],weights:i.weightSpecs}],marcelle:r};return await L_(i.weightData,`${t}.weights.bin`,"application/octet-stream"),await L_(JSON.stringify(o),`${t}.json`,"text/plain"),{modelArtifactsInfo:{dateSaved:s,modelTopologyType:"JSON"}}}))}async upload(...e){this.$training.set({status:"loading"});try{const t=e.filter(o=>o.name.includes(".json")),r=e.filter(o=>o.name.includes(".bin")),{marcelle:s}=await new Promise((o,a)=>{const l=new FileReader;l.onload=()=>{const c=JSON.parse(l.result);o(c)},l.onerror=c=>a(new Error(`The provided files are not a valid marcelle model ${c}`)),l.readAsText(t[0])});if(this.loadFn=s.tfjsModelFormat==="graph-model"?Pl:GS,t.length===1&&e.length){const o=await this.loadFn(bce([t[0],...r]));return o&&(this.model=o,await this.warmup()),s&&s.labels?this.labels=s.labels:this.labels=null,this.$training.set({status:"loaded",data:{source:"file"}}),{name:s.name,format:"tfjs",files:[],metadata:s}}const i=new Error("The provided files are not compatible with this model");throw i.name="File upload error",i}catch(t){throw this.$training.set({status:"error"}),t}}}Dn([Ln],U$.prototype,"warmup",null);Dn([Ln],U$.prototype,"upload",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ySt=1e-7,bSt=1e-4;class vSt{refCount(e){return Oa("refCount")}incRef(e){return Oa("incRef")}timerAvailable(){return!0}time(e){return Oa("time")}read(e){return Oa("read")}readSync(e){return Oa("readSync")}readToGPU(e,t){return Oa("readToGPU")}numDataIds(){return Oa("numDataIds")}disposeData(e,t){return Oa("disposeData")}write(e,t,r){return Oa("write")}move(e,t,r,s,i){return Oa("move")}createTensorFromGPUData(e,t,r){return Oa("createTensorFromGPUData")}memory(){return Oa("memory")}floatPrecision(){return Oa("floatPrecision")}epsilon(){return this.floatPrecision()===32?ySt:bSt}dispose(){return Oa("dispose")}}function Oa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Li(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Fb(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function vce(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function wSt(n){return n%1===0}function oI(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function wce(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),Li(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),Li(n.every(r=>wSt(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function xSt(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:wce(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function SSt(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function _St(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function hL(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function CSt(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function VV(n){return typeof n=="string"||n instanceof String}function kSt(n){return typeof n=="boolean"}function TSt(n){return typeof n=="number"}function UV(n){return Array.isArray(n)?UV(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":TSt(n)?"float32":VV(n)?"string":kSt(n)?"bool":"float32"}function v9(n){return!!(n&&n.constructor&&n.call&&n.apply)}function xce(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function Sce(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=Sce(n+l*a,o,t,r)}return s}function w9(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Sce(0,n,e,t)}function ESt(n,e){const t=_ce(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function _ce(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function ISt(n){n.forEach(e=>{Li(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function WV(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x9="tfjsflags";class ASt{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=MSt,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ua().getBool("IS_TEST")||Ua().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Ua().getBool("IS_TEST")||Ua().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(WV(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);x9 in e&&e[x9].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=$St(s,i)})}}function MSt(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(NSt(e,r[0],r[1]),r.join("="))),e}function NSt(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function $St(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ua(){return Cce}let Cce=null;function RSt(n){Cce=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KP;function kce(){if(KP==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");KP=n}return KP}function PSt(){const n=kce();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function GV(n,e){const t=PSt();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const DSt="Abs",OSt="Add",FSt="ArgMax",LSt="BatchMatMul",Tce="Cast",zSt="ComplexAbs",BSt="ExpandDims",VSt="GatherV2",USt="Identity",WSt="Max",GSt="Min",HSt="Multiply",jSt="Pow",qSt="Reshape",XSt="Sqrt",KSt="Sum";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(...n){Ua().getBool("IS_TEST")||Ua().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ece=GV("kernelRegistry",()=>new Map),YSt=GV("gradRegistry",()=>new Map);function S9(n,e){const t=ZSt(n,e);return Ece.get(t)}function _9(n){return YSt.get(n)}function C9(n){const e=Ece.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function ZSt(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JSt(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QSt(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Ice(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=z_(n)),Ua().getBool("DEBUG")&&SSt(n,e),QSt(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function hM(){return Ua().platform.now()}function e_t(n,e="utf-8"){return e=e||"utf-8",Ua().platform.encode(n,e)}function k9(n,e="utf-8"){return e=e||"utf-8",Ua().platform.decode(n,e)}function Ru(n){return Ua().platform.isTypedArray!=null?Ua().platform.isTypedArray(n):JSt(n)}function z_(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||WV(n)||n==null||Ru(n)&&t)e.push(n);else if(Array.isArray(n)||Ru(n))for(let r=0;r<n.length;++r)z_(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)z_(n[s],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t_t{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new r_t)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=hM();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:hM()-a})}if(Ua().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(h=>{n_t(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function n_t(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class r_t{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?oI(`${s}ms`,9):s.error,l=oI(e,25),c=t.rank,u=t.size,h=oI(t.shape.toString(),14);let f="";for(const d in i){const p=i[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_t(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const f in u)i[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function i_t(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!vce(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T9=20,m1=3,YP=7;function o_t(n,e,t,r){const s=xce(e),i=a_t(n,e,t,s),o=e.length,a=aI(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function a_t(n,e,t,r){const s=Fb(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?B1(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],z1(l[u+h],0,t).length)}return o}function z1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(YP))} + ${parseFloat(n[1].toFixed(YP))}j`:VV(n)?r=`'${n}'`:t==="bool"?r=Ace(n):r=parseFloat(n.toFixed(YP)).toString(),oI(r,e)}function Ace(n){return n===0?"false":"true"}function aI(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=B1(n);return[z1(m[0],0,t)]}return t==="bool"?[Ace(n[0])]:[n[0].toString()]}if(l===1){if(a>T9){const g=m1*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-m1)*o,a*o));return t==="complex64"&&(y=B1(y),b=B1(b)),["["+y.map((x,w)=>z1(x,s[w],t)).join(", ")+", ..., "+b.map((x,w)=>z1(x,s[a-m1+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?B1(n):Array.from(n)).map((g,y)=>z1(g,s[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>T9){for(let m=0;m<m1;m++){const g=m*h,y=g+h;f.push(...aI(n.slice(g,y),c,t,u,s,!1))}f.push("...");for(let m=a-m1;m<a;m++){const g=m*h,y=g+h;f.push(...aI(n.slice(g,y),c,t,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...aI(n.slice(g,y),c,t,u,s,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":p),f}function B1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uh=null,g1=null;function l_t(n){uh=n}class fc{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Fb(e),this.strides=xce(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return g1.buffer(this.shape,this.dtype,e)}bufferSync(){return g1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return w9(this.shape,e,this.dtype==="complex64")}arraySync(){return w9(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=uh().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>k9(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),uh().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=uh().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>k9(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await uh().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),uh().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return g1.print(this,e)}clone(){return this.throwIfDisposed(),g1.clone(this)}toString(e=!1){const t=this.dataSync();return o_t(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),g1.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),uh().makeVariable(this,e,t,r)}}Object.defineProperty(fc,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function zc(){return GV("Tensor",()=>fc)}zc();class fL extends fc{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!vce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);uh().disposeTensor(this),this.dataId=e.dataId,uh().incRef(this,null)}dispose(){uh().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(fL,Symbol.hasInstance,{value:n=>n instanceof fc&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var E9;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(E9||(E9={}));var dL;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(dL||(dL={}));var pL;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(pL||(pL={}));var mL;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(mL||(mL={}));var gL;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(gL||(gL={}));const c_t={float32:mL,int32:dL,bool:pL,complex64:gL};function u_t(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return c_t[n][e]}function Mce(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Nce(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HV(n,e){if(n.dtype===e.dtype)return[n,e];const t=u_t(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function h_t(n){const e=[];return $ce(n,e,new Set),e}function $ce(n,e,t){if(n==null)return;if(n instanceof fc){e.push(n);return}if(!f_t(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),$ce(i,e,t))}}function f_t(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZP(n){return n.kernelName!=null}class I9{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Sv{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new I9}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(p1(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new t_t(this.backendInstance),!0}setupRegisteredKernels(){C9(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){C9(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof vSt)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,p1(`Initialization of backend ${e} failed`),p1(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return p1(`Initialization of backend ${e} failed`),p1(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Sv.nextTensorId++}nextVariableId(){return Sv.nextVariableId++}clone(e){const t=xs.runKernel(USt,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return xs.runKernel(Tce,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(S9(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=ZP(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ZP(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=S9(p,this.backendName);Li(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,x);const w=x.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(s){const _=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(_)}return w}}else{const{forwardFunc:p}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=ZP(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=_9(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(Li(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&VV(e[0])&&(i=e.map(l=>e_t(l)));const o=s.write(i,t,r),a=new fc(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),c=CSt(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new fc(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new fL(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*hL(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof fL||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*hL(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=_9(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=_ce(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=h_t(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(Li(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Li(i instanceof fc,()=>"The result y returned by f() must be a tensor.");const o=s_t(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??d_t(i.shape),i_t(a,o,c=>this.tidy(c),m_t);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return Li(v9(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{Li(t.every(a=>a instanceof fc),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),Li(r.value instanceof fc,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Li(v9(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];Li(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Li(u.every(f=>f instanceof fc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=hM(),r=await this.backend.time(e);return r.wallMs=hM()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new I9;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Sv.nextTensorId=0;Sv.nextVariableId=0;function d_t(n){const e=ESt(Fb(n),"float32");return xs.makeTensor(e,n,"float32")}function p_t(){const n=kce();if(n._tfengine==null){const e=new ASt(n);n._tfengine=new Sv(e)}return RSt(n._tfengine.ENV),l_t(()=>n._tfengine),n._tfengine}const xs=p_t();function m_t(n,e){const t={a:n,b:e};return xs.runKernel(OSt,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_t(n,e){let t=n;if(Ru(n))return e==="string"?[]:[n.length];if(Mce(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(Nce(n))return[n.buffer.size/(e==null?4:hL(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Ru(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ua().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Rce(n,r,[]),r}function Rce(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ru(n)){Li(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}Li(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),Li(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)Rce(n[s],r,t.concat(s))}function A9(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function Mi(n,e,t,r="numeric"){if(n instanceof fc)return A9(r,n.dtype,e,t),n;let s=UV(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),A9(r,s,e,t),n==null||!Ru(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=g_t(n,s);!Ru(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?Ice(n,s):z_(n,[],!0);return xs.makeTensor(a,i,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y_t="__op";function ta(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+y_t;const s=(...i)=>{xs.startScope(t);try{const o=r(...i);return WV(o)&&console.error("Cannot return a Promise inside of tidy."),xs.endScope(o),o}catch(o){throw xs.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_t(n,e,t=0,r=0){const s=Mi(n,"x","gather"),i=Mi(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return xs.runKernel(VSt,o,a)}const v_t=ta({gather_:b_t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.gather=function(n,e,t){return this.throwIfDisposed(),v_t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_t(n,e=0){const r={x:Mi(n,"x","argMax")},s={axis:e};return xs.runKernel(FSt,r,s)}const x_t=ta({argMax_:w_t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.argMax=function(n){return this.throwIfDisposed(),x_t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_t(n,e){const r={x:Mi(n,"x","reshape","string_or_numeric")},s={shape:e};return xs.runKernel(qSt,r,s)}const hx=ta({reshape_:S_t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __t(n,e){const t=Mi(n,"x","squeeze","string_or_numeric");return hx(t,xSt(t.shape,e).newShape)}const C_t=ta({squeeze_:__t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.squeeze=function(n){return this.throwIfDisposed(),C_t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_t(n,e=0){const t=Mi(n,"x","expandDims","string_or_numeric");Li(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return xs.runKernel(BSt,r,s)}const T_t=ta({expandDims_:k_t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.expandDims=function(n){return this.throwIfDisposed(),T_t(this,n)};function M9(n,e=null,t=!1){const r=e?{$select:e}:{},s=Ng(n)?n.items().query(r):n,i=t?s.toArray():Promise.resolve(s);async function*o(){const a=await i;for await(const l of a)yield l}return hrt(o)}function N9(n){const e={};for(const[t,r]of Object.entries(n)){const s=t.startsWith("val_")?t.replace("val_","")+"Val":t;e[s]=r}return e}class Pce extends U${constructor({epochs:e=20,batchSize:t=8,validationSplit:r=.2}={}){super(),this.title="TFJSCustomModel",this.loadFn=GS,this.validationSplit=Math.max(Math.min(r,1),0),this.parameters={epochs:new gt(e,!0),batchSize:new gt(t,!0)}}transformDataset(e){return e.map(t=>({xs:ki(t.x),ys:ki(t.y)}))}async train(e,t){this.$training.set({status:"start",epochs:this.parameters.epochs.get()});const s=Ng(e)?e.$count.value:(await e.toArray()).length,i=Math.min(200,s),o=this.transformDataset(M9(e,["x","y"],s<200)).shuffle(i);let a,l;if(t)a=o,l=this.transformDataset(M9(t,["x","y"],s<200)).shuffle(i);else{const h=Math.floor(s*(1-this.validationSplit));a=o.take(h),l=this.validationSplit>0&&o.skip(h)}const[{xs:c,ys:u}]=await a.take(1).toArray();this.buildModel(c.shape,u.shape),this.fit(a,l)}_predict(e){return this.model?Se(()=>this.model.predict(ki(e).expandDims(0)).gather(0)):null}clear(){delete this.model}fit(e,t){this.model.fitDataset(e.batch(this.parameters.batchSize.get()),{...t?{validationData:t.batch(this.parameters.batchSize.get())}:{},epochs:this.parameters.epochs.get(),callbacks:{onEpochEnd:(r,s)=>{this.$training.set({status:"epoch",epoch:r+1,epochs:this.parameters.epochs.get(),data:N9(s)})}}}).then(r=>{this.$training.set({status:"success",data:N9(r.history)})}).catch(r=>{throw this.$training.set({status:"error",data:r}),new wp(r.message)})}}Dn([Ln],Pce.prototype,"train",null);class Dce extends Pce{constructor(){super(...arguments),this.title="TFJSCustomClassifier"}async train(e,t){const r=Ng(e);if(this.labels=r?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:i})=>i).toArray())),this.labels.length===0){Ya(new wp("This dataset is empty or is missing labels")),this.$training.set({status:"error"});return}if(this.labels.length===1){Ya(new wp("At least two classes are needed to train the classifier")),this.$training.set({status:"error"});return}const s=this.labels.length;this.transformDataset=i=>i.map(o=>({xs:ki(o.x),ys:Hb(this.labels.indexOf(o.y),s)})),super.train(e,t)}async predict(e){return this.model?Se(()=>{const t=this._predict(e),r=this.labels[t.argMax().arraySync()],i=t.arraySync().reduce((o,a,l)=>({...o,[this.labels[l]]:a}),{});return{label:r,confidences:i}}):{label:void 0,confidences:{}}}}Dn([Ln],Dce.prototype,"train",null);function E_t(n){var g,y,b,x;let e,t,r,s,i=((g=n[2])==null?void 0:g.message)+"",o,a,l,c,u=Math.floor(((y=n[2])==null?void 0:y.progress)*100)+"",h,f,d,p,m;return p=new uce({props:{progress:(b=n[2])==null?void 0:b.progress,type:(x=n[2])==null?void 0:x.type}}),{c(){var w,_,C,k,A,M;e=Ce("div"),t=Ce("div"),r=Ce("div"),s=Ce("span"),o=Qe(i),a=st(),l=Ce("div"),c=Ce("span"),h=Qe(u),f=Qe("%"),d=st(),Pt(p.$$.fragment),te(s,"class","text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 svelte-cymqgb"),Gt(s,"gray",((w=n[2])==null?void 0:w.type)==="idle"),Gt(s,"green",((_=n[2])==null?void 0:_.type)==="success"),Gt(s,"red",((C=n[2])==null?void 0:C.type)==="danger"),te(c,"class","text-xs font-semibold inline-block text-blue-600 svelte-cymqgb"),Gt(c,"tgray",((k=n[2])==null?void 0:k.type)==="idle"),Gt(c,"tgreen",((A=n[2])==null?void 0:A.type)==="success"),Gt(c,"tred",((M=n[2])==null?void 0:M.type)==="danger"),te(l,"class","text-right"),te(t,"class","flex mb-2 items-center justify-between"),te(e,"class","relative pt-6 w-full"),ua(e,"min-width","250px")},m(w,_){be(w,e,_),ue(e,t),ue(t,r),ue(r,s),ue(s,o),ue(t,a),ue(t,l),ue(l,c),ue(c,h),ue(c,f),ue(e,d),At(p,e,null),m=!0},p(w,_){var k,A,M,I,N,O,R,D,z,B;(!m||_&4)&&i!==(i=((k=w[2])==null?void 0:k.message)+"")&&dn(o,i),(!m||_&4)&&Gt(s,"gray",((A=w[2])==null?void 0:A.type)==="idle"),(!m||_&4)&&Gt(s,"green",((M=w[2])==null?void 0:M.type)==="success"),(!m||_&4)&&Gt(s,"red",((I=w[2])==null?void 0:I.type)==="danger"),(!m||_&4)&&u!==(u=Math.floor(((N=w[2])==null?void 0:N.progress)*100)+"")&&dn(h,u),(!m||_&4)&&Gt(c,"tgray",((O=w[2])==null?void 0:O.type)==="idle"),(!m||_&4)&&Gt(c,"tgreen",((R=w[2])==null?void 0:R.type)==="success"),(!m||_&4)&&Gt(c,"tred",((D=w[2])==null?void 0:D.type)==="danger");const C={};_&4&&(C.progress=(z=w[2])==null?void 0:z.progress),_&4&&(C.type=(B=w[2])==null?void 0:B.type),p.$set(C)},i(w){m||(Ae(p.$$.fragment,w),m=!0)},o(w){Re(p.$$.fragment,w),m=!1},d(w){w&&ye(e),Mt(p)}}}function I_t(n){let e,t;return e=new rl({props:{title:n[0],$$slots:{default:[E_t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&12&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function A_t(n,e,t){let r,s=ot,i=()=>(s(),s=es(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{progress:a}=e;return i(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"progress"in l&&i(t(1,a=l.progress))},[o,a,r]}class M_t extends Rn{constructor(e){super(),$n(this,e,A_t,I_t,Nn,{title:0,progress:1})}}class N_t extends Lc{constructor(e){super(),this.$progress=e,this.title="progress bar",this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new M_t({target:t,props:{title:this.title,progress:this.$progress}}))}}function $_t(n){if(!n.$training)throw new Error("The argument is not a valid MLP");const e=n.$training.map(({status:r,epoch:s,epochs:i})=>{let o="default",a=i>0?s/i:null;return r==="error"&&(o="danger"),r==="idle"&&(o="idle",a=0),["success","loaded"].includes(r)&&(o="success",a=1),["start","loading"].includes(r)&&(a=null),{message:`Status: ${r}`,progress:a,type:o}}).hold(),t=new N_t(e);return t.title="Training Progress",t}function R_t(n){let e;return{c(){e=Qe(n[10])},m(t,r){be(t,e,r)},p(t,r){r&1024&&dn(e,t[10])},d(t){t&&ye(e)}}}function P_t(n){let e,t,r,s;function i(a){n[11](a)}let o={disabled:n[7],type:n[8],$$slots:{default:[R_t]},$$scope:{ctx:n}};return n[9]!==void 0&&(o.pressed=n[9]),t=new zs({props:o}),So.push(()=>ux(t,"pressed",i)),t.$on("click",n[12]),{c(){e=Ce("div"),Pt(t.$$.fragment)},m(a,l){be(a,e,l),At(t,e,null),s=!0},p(a,l){const c={};l&128&&(c.disabled=a[7]),l&256&&(c.type=a[8]),l&9216&&(c.$$scope={dirty:l,ctx:a}),!r&&l&512&&(r=!0,c.pressed=a[9],cx(()=>r=!1)),t.$set(c)},i(a){s||(Ae(t.$$.fragment,a),s=!0)},o(a){Re(t.$$.fragment,a),s=!1},d(a){a&&ye(e),Mt(t)}}}function D_t(n){let e,t;return e=new rl({props:{title:n[0],loading:n[6],$$slots:{default:[P_t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&64&&(i.loading=r[6]),s&10112&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function O_t(n,e,t){let r,s=ot,i=()=>(s(),s=es(_,I=>t(6,r=I)),_),o,a=ot,l=()=>(a(),a=es(C,I=>t(7,o=I)),C),c,u=ot,h=()=>(u(),u=es(k,I=>t(8,c=I)),k),f,d=ot,p=()=>(d(),d=es(w,I=>t(9,f=I)),w),m,g=ot,y=()=>(g(),g=es(x,I=>t(10,m=I)),x);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u()),n.$$.on_destroy.push(()=>d()),n.$$.on_destroy.push(()=>g());let{title:b}=e,{text:x}=e;y();let{pressed:w}=e;p();let{loading:_}=e;i();let{disabled:C}=e;l();let{type:k}=e;h();function A(I){f=I,w.set(f)}function M(I){lM.call(this,n,I)}return n.$$set=I=>{"title"in I&&t(0,b=I.title),"text"in I&&y(t(1,x=I.text)),"pressed"in I&&p(t(2,w=I.pressed)),"loading"in I&&i(t(3,_=I.loading)),"disabled"in I&&l(t(4,C=I.disabled)),"type"in I&&h(t(5,k=I.type))},[b,x,w,_,C,k,r,o,c,f,m,A,M]}class F_t extends Rn{constructor(e){super(),$n(this,e,O_t,D_t,Nn,{title:0,text:1,pressed:2,loading:3,disabled:4,type:5})}}class L_t extends Lc{constructor(e="click me"){super(),this.title="button",this.$click=new gt(AS()),this.$pressed=new gt(!1,!0),this.$loading=new gt(!1,!0),this.$disabled=new gt(!1,!0),this.$type=new gt("default",!0),this.$text=new gt(e,!0),this.start(),this.$loading.skip(1).subscribe(t=>{this.$disabled.set(t)})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new F_t({target:t,props:{title:this.title,text:this.$text,pressed:this.$pressed,loading:this.$loading,disabled:this.$disabled,type:this.$type}}),this.$$.app.$on("click",this.$click.set))}}function Oce(...n){return new L_t(...n)}function z_t(n){let e,t;return{c(){e=Qe("COCO-SSD loaded with base "),t=Qe(n[2])},m(r,s){be(r,e,s),be(r,t,s)},p(r,s){s&4&&dn(t,r[2])},d(r){r&&ye(e),r&&ye(t)}}}function B_t(n){let e;return{c(){e=Qe("")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function V_t(n){let e;function t(i,o){return i[3]?B_t:z_t}let r=t(n),s=r(n);return{c(){e=Ce("p"),s.c(),te(e,"class","p-2 text-sm text-gray-600")},m(i,o){be(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&ye(e),s.d()}}}function U_t(n){let e,t;return e=new rl({props:{title:n[0],loading:n[3],$$slots:{default:[V_t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]),s&28&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function W_t(n,e,t){let r,s=ot,i=()=>(s(),s=es(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{base:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&i(t(1,a=c.loading)),"base"in c&&t(2,l=c.base)},[o,a,l,r]}class G_t extends Rn{constructor(e){super(),$n(this,e,W_t,U_t,Nn,{title:0,loading:1,base:2})}}var Tm,xd;class fx extends t0{constructor({base:e="lite_mobilenet_v2"}={}){super(),this.title="COCO-SSD Object Detection",this.parameters={},this.serviceName="undefined",Tm.set(this,void 0),xd.set(this,void 0),this.$loading=new gt(!0,!0),Vn(this,xd,e,"f"),this.setup()}async setup(){await G2();const e=await RL(),t=Object.keys(e).filter(r=>r.includes("cocossd"));try{Vn(this,Tm,await E6.load({base:Ue(this,xd,"f"),modelUrl:`indexeddb://cocossd-${Ue(this,xd,"f")}`}),"f")}catch{t.length>0&&await PL(t[0]),Vn(this,Tm,await E6.load({base:Ue(this,xd,"f")}),"f"),await Ue(this,Tm,"f").model.save(`indexeddb://cocossd-${Ue(this,xd,"f")}`)}ma.info("COCO-SSD loaded with base `lite_mobilenet_v2`"),this.$loading.set(!1),this.start()}train(){throw new wp("Model `CocoSsd` cannot be trained")}async predict(e){if(!Ue(this,Tm,"f"))throw new Error("Model is not loaded");return{outputs:(await Ue(this,Tm,"f").detect(e)).map(s=>({bbox:s.bbox,class:s.class,confidence:s.score}))}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new G_t({target:t,props:{title:this.title,loading:this.$loading,base:Ue(this,xd,"f")}}))}save(){throw new Error("CocoSsd does not support saving")}load(){throw new Error("CocoSsd does not support loading")}download(){throw new Error("CocoSsd does not support downloading")}upload(){throw new Error("CocoSsd does not support uploading")}}Tm=new WeakMap,xd=new WeakMap;Dn([Ln],fx.prototype,"train",null);Dn([Ln],fx.prototype,"predict",null);Dn([Ln],fx.prototype,"save",null);Dn([Ln],fx.prototype,"load",null);Dn([Ln],fx.prototype,"download",null);Dn([Ln],fx.prototype,"upload",null);function H_t(n){let e,t;return{c(){e=Ce("div"),t=Ce("canvas"),te(e,"class","w-full h-96")},m(r,s){be(r,e,s),ue(e,t),n[6](t)},p:ot,d(r){r&&ye(e),n[6](null)}}}function j_t(n){let e,t;return e=new rl({props:{title:n[0],$$slots:{default:[H_t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&32770&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function q_t(n,e,t){let{title:r}=e,{preset:s}=e,{options:i}=e,{datasets:o}=e;wf.register(jE,LE,zE,nF,vb,gat,Sat,Dd,BE,rF,sF,ZO,qE,VE,UE,I1,XE,WE,JS,oF,Cat,$at);const a=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 206, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(255, 159, 64)"],l={data:{},options:{maintainAspectRatio:!1,animation:{duration:200},borderWidth:4}};function c(b){return{borderColor:a[b%6],backgroundColor:a[b%6],fill:!1,lineTension:.2}}function u(b,x,w){const _={labels:[]};let C=0;return _.datasets=b.map(({dataStream:k,label:A,options:M},I)=>{C=Math.max(C,k.get()?k.get().length:0),I===0&&(_.labels=M.labels||[],!M.labels&&k.get()&&k.get().length>0&&(typeof k.get()[0]=="number"?_.labels=Array.from(Array(k.get().length),(O,R)=>R.toString()):_.labels=k.get().map(O=>O.x.toString())));let N={...c(I),...x,...M,label:A,data:k.get()||[]};return(["bar","bar-fast"].includes(M.type)||["bar","bar-fast"].includes(w.type)&&!M.type)&&b.length===1&&(N.borderColor=a,N.backgroundColor=a),N}),_}let h,f=[],d;function p(){let b=wl(l,s.global);b=wl(b,{data:u(o,s.datasets,b),options:i}),i.xlabel&&(b=wl(b,{options:{scales:{x:{title:{display:!0,text:i.xlabel}}}}})),i.ylabel&&(b=wl(b,{options:{scales:{y:{title:{display:!0,text:i.ylabel}}}}}));const x=o.map(({dataStream:_})=>{var C;return((C=_.get())===null||C===void 0?void 0:C.length)||0});f=o.map(({dataStream:_,options:C},k)=>_.subscribe(A=>{if(A&&h){const M=x.reduce((I,N)=>Math.max(I,N));x[k]=A.length,!C.labels&&A.length>0&&x[k]>M&&(typeof A[0]=="number"?b.data.labels=Array.from(Array(A.length),(I,N)=>N.toString()):b.data.labels=A.map(I=>I.x.toString())),b.data.datasets[k].data=A;try{h.update()}catch(I){console.log(I)}}}));const w=d.getContext("2d");h=new wf(w,b)}function m(){for(const b of f)b();h==null||h.destroy()}$h(async()=>{await Ka(),await Ka(),p()});let g=o.length;wv(m);function y(b){So[b?"unshift":"push"](()=>{d=b,t(1,d)})}return n.$$set=b=>{"title"in b&&t(0,r=b.title),"preset"in b&&t(2,s=b.preset),"options"in b&&t(3,i=b.options),"datasets"in b&&t(4,o=b.datasets)},n.$$.update=()=>{n.$$.dirty&48&&o.length!==g&&(m(),p(),t(5,g=o.length))},[r,d,s,i,o,g,y]}class X_t extends Rn{constructor(e){super(),$n(this,e,q_t,j_t,Nn,{title:0,preset:2,options:3,datasets:4})}}var lI,cI,dl;const $9={line:{global:{type:"line",options:{animation:{duration:200},scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:.2}},"line-fast":{global:{type:"line",options:{elements:{point:{radius:0}},animation:!1,tooltips:!1,spanGaps:!0,scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:0}},bar:{global:{type:"bar",options:{animation:{duration:200},scales:{y:{beginAtZero:!0}}}}},"bar-fast":{global:{type:"bar",options:{animation:!1,scales:{y:{beginAtZero:!0}}}}},scatter:{global:{type:"scatter",options:{scales:{x:{type:"linear",position:"bottom"}}}}}};class K_t extends Lc{constructor({preset:e="line",options:t={}}={}){super(),this.title="generic chart",lI.set(this,void 0),cI.set(this,void 0),dl.set(this,[]),Object.keys($9).includes(e)||Ya(new Error(`Preset ${e} is not recognized`)),Vn(this,lI,e,"f"),Vn(this,cI,$9[e],"f"),this.options=t,this.start()}addSeries(e,t,r={}){if(BV(e)){if(Ue(this,lI,"f")==="line-fast"){const s=e.debounce(10);s.value=e.get(),Ue(this,dl,"f").push({dataStream:s,label:t,options:r})}else Ue(this,dl,"f").push({dataStream:e,label:t,options:r});this.updateView()}else e.toArray().then(s=>{const i=new gt(s,!0);Ue(this,dl,"f").push({dataStream:i,label:t,options:r}),this.updateView()})}setColors(e){Ue(this,dl,"f")[0].label="clusters",Ue(this,dl,"f")[0].options.backgroundColor=e.get(),Ue(this,dl,"f")[0].options.color=e.get()}removeSeries(e){const t=Ue(this,dl,"f").map(r=>r.dataStream).indexOf(e);t>-1&&Ue(this,dl,"f").splice(t,1)}clear(){Vn(this,dl,[],"f"),this.updateView()}updateView(){this.$$.app&&this.$$.app.$set({datasets:Ue(this,dl,"f")})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new X_t({target:t,props:{title:this.title,preset:Ue(this,cI,"f"),options:this.options,datasets:Ue(this,dl,"f")}}))}}lI=new WeakMap,cI=new WeakMap,dl=new WeakMap;function Fce(...n){return new K_t(...n)}function R9(n){let e,t;return{c(){e=new rxt(!1),t=ea(),e.a=t},m(r,s){e.m(n[2],r,s),be(r,t,s)},p(r,s){s&4&&e.p(r[2])},d(r){r&&ye(t),r&&e.d()}}}function Y_t(n){let e,t=n[2]&&R9(n);return{c(){e=Ce("div"),t&&t.c(),te(e,"class","grow")},m(r,s){be(r,e,s),t&&t.m(e,null)},p(r,s){r[2]?t?t.p(r,s):(t=R9(r),t.c(),t.m(e,null)):t&&(t.d(1),t=null)},d(r){r&&ye(e),t&&t.d()}}}function Z_t(n){let e,t;return e=new rl({props:{title:n[0],$$slots:{default:[Y_t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&12&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function J_t(n,e,t){let r,s=ot,i=()=>(s(),s=es(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{text:a}=e;return i(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"text"in l&&i(t(1,a=l.text))},[o,a,r]}class Q_t extends Rn{constructor(e){super(),$n(this,e,J_t,Z_t,Nn,{title:0,text:1})}get title(){return this.$$.ctx[0]}set title(e){this.$$set({title:e}),F_()}get text(){return this.$$.ctx[1]}set text(e){this.$$set({text:e}),F_()}}class e2t extends Lc{constructor(e="click me"){super(),this.title="text",this.$value=new gt(e,!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new Q_t({target:t,props:{title:this.title,text:this.$value}}))}}function t2t(...n){return new e2t(...n)}var df,eh;class n2t extends Lc{constructor(e){super(),this.title="confidence plot",df.set(this,void 0),eh.set(this,void 0),this.$confidenceStream=e.map(({confidences:t})=>Object.entries(t).map(([r,s])=>({x:r,y:s})).sort((r,s)=>r.x<s.x?-1:r.x>s.x?1:0)),Vn(this,df,Fce({preset:"bar-fast",options:{xlabel:"Label",ylabel:"Confidence",scales:{y:{suggestedMax:1}}}}),"f"),Ue(this,df,"f").addSeries(this.$confidenceStream,"Confidences"),Ue(this,df,"f").title="",Vn(this,eh,t2t("Waiting for predictions..."),"f"),Ue(this,eh,"f").title=this.title,Ue(this,eh,"f").$value=new gt(e.map(({label:t})=>`<p>Predicted Label: <code style="font-size: 1.5rem;">${t}</code></p>`).startWith("Waiting for predictions..."),!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);if(!t)return;const r=document.createElement("div");r.id=`${t.id}-${Ue(this,eh,"f").id}`;const s=document.createElement("div");s.id=`${t.id}-${Ue(this,df,"f").id}`,t.appendChild(r),t.appendChild(s),Ue(this,eh,"f").title=this.title,Ue(this,eh,"f").mount(r),Ue(this,df,"f").mount(s),this.destroy=()=>{r.parentElement.removeChild(r),s.parentElement.removeChild(s),Ue(this,eh,"f").destroy(),Ue(this,df,"f").destroy()}}destroy(){Ue(this,eh,"f").destroy(),Ue(this,df,"f").destroy()}}df=new WeakMap,eh=new WeakMap;function r2t(...n){return new n2t(...n)}const{window:P9}=Kwt;function D9(n,e,t){const r=n.slice();return r[27]=e[t][0],r[28]=e[t][1].loaded,r[29]=e[t][1].total,r[30]=e[t][1].instances,r}function O9(n,e,t){const r=n.slice();return r[33]=e[t].id,r[34]=e[t].thumbnail,r}function F9(n){let e,t,r,s,i;function o(f,d){return f[6]>0?i2t:s2t}let a=o(n),l=a(n),c=Object.entries(n[5]),u=[];for(let f=0;f<c.length;f+=1)u[f]=B9(D9(n,c,f));const h=f=>Re(u[f],1,1,()=>{u[f]=null});return{c(){l.c(),e=st(),t=Ce("div");for(let f=0;f<u.length;f+=1)u[f].c();te(t,"class","flex flex-wrap")},m(f,d){l.m(f,d),be(f,e,d),be(f,t,d);for(let p=0;p<u.length;p+=1)u[p]&&u[p].m(t,null);r=!0,s||(i=[Ir(t,"click",n[18]),Ir(t,"keypress",jC(n[19]))],s=!0)},p(f,d){if(a===(a=o(f))&&l?l.p(f,d):(l.d(1),l=a(f),l&&(l.c(),l.m(e.parentNode,e))),d[0]&6560){c=Object.entries(f[5]);let p;for(p=0;p<c.length;p+=1){const m=D9(f,c,p);u[p]?(u[p].p(m,d),Ae(u[p],1)):(u[p]=B9(m),u[p].c(),Ae(u[p],1),u[p].m(t,null))}for(yr(),p=c.length;p<u.length;p+=1)h(p);br()}},i(f){if(!r){for(let d=0;d<c.length;d+=1)Ae(u[d]);r=!0}},o(f){u=u.filter(Boolean);for(let d=0;d<u.length;d+=1)Re(u[d]);r=!1},d(f){l.d(f),f&&ye(e),f&&ye(t),Vi(u,f),s=!1,nl(i)}}}function s2t(n){let e;return{c(){e=Ce("p"),e.textContent="This dataset is empty.",te(e,"class","ml-3 mt-2")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function i2t(n){let e,t,r,s,i=n[6]>1?"s":"",o,a;return{c(){e=Ce("p"),t=Qe("This dataset contains "),r=Qe(n[6]),s=Qe(" instance"),o=Qe(i),a=Qe("."),te(e,"class","ml-3 mt-2")},m(l,c){be(l,e,c),ue(e,t),ue(e,r),ue(e,s),ue(e,o),ue(e,a)},p(l,c){c[0]&64&&dn(r,l[6]),c[0]&64&&i!==(i=l[6]>1?"s":"")&&dn(o,i)},d(l){l&&ye(e)}}}function L9(n,e){let t,r,s,i,o,a,l;function c(){return e[16](e[33])}return{key:n,first:null,c(){t=Ce("img"),iM(t.src,r=e[34])||te(t,"src",r),te(t,"alt","thumbnail"),te(t,"class","m-1 svelte-14ms951"),Gt(t,"selected",e[7].includes(e[33])),this.first=t},m(u,h){be(u,t,h),o=!0,a||(l=Ir(t,"click",Jwt(c)),a=!0)},p(u,h){e=u,(!o||h[0]&32&&!iM(t.src,r=e[34]))&&te(t,"src",r),(!o||h[0]&160)&&Gt(t,"selected",e[7].includes(e[33]))},i(u){o||(Pc(()=>{o&&(i&&i.end(1),s=fxt(t,Bq,{}),s.start())}),o=!0)},o(u){s&&s.invalidate(),i=dxt(t,Bq,{}),o=!1},d(u){u&&ye(t),u&&i&&i.end(),a=!1,l()}}}function z9(n){let e,t;function r(){return n[17](n[27])}return e=new zs({props:{size:"small",variant:"light",$$slots:{default:[o2t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){Pt(e.$$.fragment)},m(s,i){At(e,s,i),t=!0},p(s,i){n=s;const o={};i[1]&64&&(o.$$scope={dirty:i,ctx:n}),e.$set(o)},i(s){t||(Ae(e.$$.fragment,s),t=!0)},o(s){Re(e.$$.fragment,s),t=!1},d(s){Mt(e,s)}}}function o2t(n){let e;return{c(){e=Qe("View More")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function B9(n){let e,t,r,s,i=n[27]+"",o,a,l,c,u,h=[],f=new Map,d,p,m,g;function y(..._){return n[15](n[27],..._)}l=new Pxt({props:{actions:[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])}}),l.$on("select",y);let b=n[30];const x=_=>_[33];for(let _=0;_<b.length;_+=1){let C=O9(n,b,_),k=x(C);f.set(k,h[_]=L9(k,C))}let w=n[28]<n[29]&&z9(n);return{c(){e=Ce("div"),t=Ce("div"),r=Ce("div"),s=Ce("span"),o=Qe(i),a=st(),Pt(l.$$.fragment),c=st(),u=Ce("div");for(let _=0;_<h.length;_+=1)h[_].c();d=st(),p=Ce("div"),w&&w.c(),m=st(),te(s,"class","browser-class-title svelte-14ms951"),te(r,"class","browser-class-header svelte-14ms951"),te(u,"class","browser-class-body svelte-14ms951"),te(t,"class","w-full"),te(p,"class","pb-1"),te(e,"class","browser-class svelte-14ms951")},m(_,C){be(_,e,C),ue(e,t),ue(t,r),ue(r,s),ue(s,o),ue(r,a),At(l,r,null),ue(t,c),ue(t,u);for(let k=0;k<h.length;k+=1)h[k]&&h[k].m(u,null);ue(e,d),ue(e,p),w&&w.m(p,null),ue(e,m),g=!0},p(_,C){n=_,(!g||C[0]&32)&&i!==(i=n[27]+"")&&dn(o,i);const k={};C[0]&128&&(k.actions=[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])),l.$set(k),C[0]&2208&&(b=n[30],yr(),h=lce(h,C,x,1,n,b,f,u,ace,L9,null,O9),br()),n[28]<n[29]?w?(w.p(n,C),C[0]&32&&Ae(w,1)):(w=z9(n),w.c(),Ae(w,1),w.m(p,null)):w&&(yr(),Re(w,1,1,()=>{w=null}),br())},i(_){if(!g){Ae(l.$$.fragment,_);for(let C=0;C<b.length;C+=1)Ae(h[C]);Ae(w),g=!0}},o(_){Re(l.$$.fragment,_);for(let C=0;C<h.length;C+=1)Re(h[C]);Re(w),g=!1},d(_){_&&ye(e),Mt(l);for(let C=0;C<h.length;C+=1)h[C].d();w&&w.d()}}}function V9(n){let e;return{c(){e=Ce("div"),e.innerHTML=`<svg class="inline flex-shrink-0 mr-3 w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg> 
      <div><span class="font-medium">Data Store connection Error!</span> This data store probably requires
        authentication</div>`,te(e,"class","flex p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800"),te(e,"role","alert")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function a2t(n){let e,t,r,s=n[5]&&!n[4]&&F9(n),i=n[4]&&V9();return{c(){s&&s.c(),e=st(),i&&i.c(),t=ea()},m(o,a){s&&s.m(o,a),be(o,e,a),i&&i.m(o,a),be(o,t,a),r=!0},p(o,a){o[5]&&!o[4]?s?(s.p(o,a),a[0]&48&&Ae(s,1)):(s=F9(o),s.c(),Ae(s,1),s.m(e.parentNode,e)):s&&(yr(),Re(s,1,1,()=>{s=null}),br()),o[4]?i||(i=V9(),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i(o){r||(Ae(s),r=!0)},o(o){Re(s),r=!1},d(o){s&&s.d(o),o&&ye(e),i&&i.d(o),o&&ye(t)}}}function l2t(n){let e,t,r,s;return e=new rl({props:{title:n[0],loading:n[3],$$slots:{default:[a2t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(i,o){At(e,i,o),t=!0,r||(s=[Ir(P9,"keydown",n[9]),Ir(P9,"keyup",n[10])],r=!0)},p(i,o){const a={};o[0]&1&&(a.title=i[0]),o[0]&8&&(a.loading=i[3]),o[0]&240|o[1]&64&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){t||(Ae(e.$$.fragment,i),t=!0)},o(i){Re(e.$$.fragment,i),t=!1},d(i){Mt(e,i),r=!1,nl(s)}}}function c2t(n,e,t){let r,s=ot,i=()=>(s(),s=es(h,G=>t(6,r=G)),h),o,a=ot,l=()=>(a(),a=es(d,G=>t(7,o=G)),d);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a());let{title:c}=e,{batchSize:u}=e,{count:h}=e;i();let{dataset:f}=e,{selected:d}=e;l();let p=!1,m=!1,g={};async function y(G){await f.ready;for await(const ee of f.items().query({y:G,$sort:{updatedAt:-1}}).skip(g[G].loaded).take(u).select(["id","y","thumbnail"]))t(5,g[G].instances=[...g[G].instances,ee],g),t(5,g[G].loaded+=1,g)}async function b(){if(p)return;t(3,p=!0);try{t(4,m=!1),await f.ready}catch{t(3,p=!1),t(4,m=!0);return}const G=await f.distinct("y");t(5,g=G.reduce((ee,pe)=>({...ee,[pe]:{total:0,loaded:0,instances:[]}}),{}));for(const ee of G){const{total:pe}=await f.find({query:{$limit:0,y:ee}});if(t(5,g[ee].total=pe,g),u>0)await y(ee);else for(;g[ee].loaded<g[ee].total;)await y(ee)}t(3,p=!1)}function x(G){for(const[ee,{instances:pe}]of Object.entries(g))if(pe.map(oe=>oe.id).includes(G))return ee;return null}async function w(){let G=Promise.resolve();for(const ee of d.get())G=G.then(()=>f.remove(ee));await G,d.set([])}async function _(G){let ee=Promise.resolve();for(const pe of d.get())ee=ee.then(()=>f.patch(pe,{y:G}));await ee,d.set([])}let C=!1,k=!1;function A(G){["Meta","Control"].includes(G.key)?C=!0:G.key==="Shift"?k=!0:(G.key==="Delete"||G.key==="Backspace"&&C)&&w()}function M(G){["Meta","Control"].includes(G.key)?C=!1:G.key==="Shift"&&(k=!1)}let I=null;function N(G){if(C){if(!G)return;d.get().includes(G)?d.set(d.get().filter(ee=>ee!==G)):d.set(d.get().concat([G]))}else if(k){if(!I||!G)return;const ee=x(I),pe=x(G);if(ee!==pe)return;const oe=g[ee].instances.map(De=>De.id),Ne=oe.indexOf(I),ke=oe.indexOf(G);d.set(Ne<ke?oe.slice(Ne,ke+1):oe.slice(ke,Ne+1))}else d.set(G?[G]:[]),I=G}function O(G,ee){let pe;switch(ee){case"edit":pe=window.prompt("Enter the new label",G),pe&&f.patch(null,{y:pe},{query:{y:G}});break;case"delete":f.remove(null,{query:{y:G}});break;case"deleteInstances":w();break;case"relabelInstances":pe=window.prompt("Enter the new label",G),pe&&_(pe);break;default:alert(`Class ${G}: ${ee}`);break}}$h(()=>{b(),f.$changes.subscribe(async G=>{for(const{level:ee,type:pe,data:oe}of G)if(ee==="dataset")pe==="created"&&(N(),b());else if(ee==="instance")if(pe==="created")g[oe.y]||t(5,g[oe.y]={total:0,loaded:0,instances:[]},g),t(5,g[oe.y].total+=1,g),t(5,g[oe.y].loaded+=1,g),t(5,g[oe.y].instances=[{id:oe.id,y:oe.y,thumbnail:oe.thumbnail},...g[oe.y].instances],g);else if(pe==="updated"){const Ne=x(oe.id);t(5,g[Ne].total-=1,g),t(5,g[Ne].loaded-=1,g),t(5,g[Ne].instances=g[Ne].instances.filter(({id:ke})=>ke!==oe.id),g),g[Ne].total===0&&(delete g[Ne],t(5,g)),g[oe.y]||t(5,g[oe.y]={total:0,loaded:0,instances:[]},g),t(5,g[oe.y].instances=[{id:oe.id,y:oe.y,thumbnail:oe.thumbnail},...g[oe.y].instances],g)}else pe==="removed"&&(t(5,g[oe.y].total-=1,g),t(5,g[oe.y].loaded-=1,g),t(5,g[oe.y].instances=g[oe.y].instances.filter(({id:Ne})=>Ne!==oe.id),g),g[oe.y].total===0&&(delete g[oe.y],t(5,g)))})});const R=(G,ee)=>O(G,ee.detail),D=G=>N(G),z=G=>y(G),B=()=>N(),X=G=>G.key==="Escape"&&N();return n.$$set=G=>{"title"in G&&t(0,c=G.title),"batchSize"in G&&t(13,u=G.batchSize),"count"in G&&i(t(1,h=G.count)),"dataset"in G&&t(14,f=G.dataset),"selected"in G&&l(t(2,d=G.selected))},[c,h,d,p,m,g,r,o,y,A,M,N,O,u,f,R,D,z,B,X]}class u2t extends Rn{constructor(e){super(),$n(this,e,c2t,l2t,Nn,{title:0,batchSize:13,count:1,dataset:14,selected:2},null,[-1,-1])}}var V1;class h2t extends Lc{constructor(e,{batchSize:t=6}={}){super(),this.title="dataset browser",V1.set(this,void 0),this.$selected=new gt([],!0),Vn(this,V1,e,"f"),this.batchSize=t,this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new u2t({target:t,props:{title:this.title,batchSize:this.batchSize,count:Ue(this,V1,"f").$count,dataset:Ue(this,V1,"f"),selected:this.$selected}}))}}V1=new WeakMap;function f2t(...n){return new h2t(...n)}function d2t(n,e){return n.map((t,r)=>Math.abs(t-e[r])**2).reduce((t,r)=>t+r)**(1/2)}class jV extends t0{constructor({k:e=3}={}){super(),this.title="k-means clustering",this.serviceName="kmeans-models",this.parameters={k:new gt(e,!0)},this.$centers=new gt([],!1),this.$clusters=new gt([],!1),this.dataset=[],this.start()}async train(e){this.$training.set({status:"start",epochs:1});const t=Ng(e)?e.items():e;for await(const{x:s}of t)this.dataset.push(s);const r=Sht(this.dataset,this.parameters.k.get());this.$centers.set(r.centroids.map(s=>s.centroid)),this.$clusters.set(r.clusters),this.$training.set({status:"success"})}async predict(e){let t=0,r=1e3;const s={};let i=0;for(let o=0;o<this.$centers.get().length;o++){const a=d2t(this.$centers.get()[o],e);a<r&&(r=a,t=o),s[`${o}`]=Math.exp(a),i+=Math.exp(a)}if(Object.entries(s).forEach(([o])=>{s[o]/=i}),this.$centers.get().length===0){const o=new Error("KMeans is not trained");o.name="[KMeans] Prediction Error",Ya(o)}return{cluster:t,confidences:s}}async batchPredict(e){const t=[],r=Ng(e)?e.items():e;for await(const{x:i}of r)t.push(i);const s=[];for(let i=0;i<t.length;i++)this.predict(t[i]).then(o=>s.push(o));if(this.$centers.get().length===0){const i=new Error("KMeans is not trained");i.name="[KMeans] Prediction Error",Ya(i)}return s}async save(e,t,r,s=null){const i=await this.write(r);return i.name=t,this.saveToDatastore(e,i,s)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);L_(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(s=>s.name.includes(".json")),r=await new Promise((s,i)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);s(a)},o.onerror=i,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){return{name:V$(this.title),files:[],format:"ml-kmeans",metadata:{clusters:this.$clusters.get(),centers:this.$centers.get(),...e}}}async read(e){const t=e.metadata.data;t&&(Object.entries(t).forEach(([r,s])=>{}),this.$clusters.set(e.metadata.labels),this.$training.set({status:"loaded"}))}}Dn([Ln],jV.prototype,"train",null);Dn([Ln],jV.prototype,"predict",null);Dn([Ln],jV.prototype,"batchPredict",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.flatten=function(){return this.throwIfDisposed(),hx(this,[this.size])};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p2t(n){const e=Mi(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return xs.runKernel(zSt,t)}else{const t={x:e};return xs.runKernel(DSt,t)}}const wd=ta({abs_:p2t});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2t(n,e){const t=Mi(n,"x","cast");if(!_St(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return xs.runKernel(Tce,r,s)}const Lce=ta({cast_:m2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2t(n,e,t=!1,r=!1){let s=Mi(n,"a","matMul"),i=Mi(e,"b","matMul");[s,i]=HV(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return xs.runKernel(LSt,o,a)}const y2t=ta({matMul_:g2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b2t(n,e){let t=Mi(n,"a","mul"),r=Mi(e,"b","mul");[t,r]=HV(t,r);const s={a:t,b:r};return xs.runKernel(HSt,s)}const v2t=ta({mul_:b2t});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2t(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function x2t(n,e){const t=e.map(r=>1);return w2t(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2t(n,e=null,t=!1){const s={x:Mi(n,"x","max")},i={reductionIndices:e,keepDims:t};return xs.runKernel(WSt,s,i)}const JP=ta({max_:S2t});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2t(n,e=null,t=!1){const s={x:Mi(n,"x","min")},i={axis:e,keepDims:t};return xs.runKernel(GSt,s,i)}const U9=ta({min_:_2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2t(n,e){let t=Mi(n,"base","pow"),r=Mi(e,"exp","pow");[t,r]=HV(t,r);const s={a:t,b:r};return xs.runKernel(jSt,s)}const k2t=ta({pow_:C2t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2t(n,e,t,r){if(r==null)r=UV(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Nce(n)||Mce(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return xs.backend.createTensorFromGPUData(n,e||t,r)}if(!Ru(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){ISt(e);const s=Fb(e),i=Fb(t);Li(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Fb(e.slice(o)):!0;Li(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ru(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Ice(n,r):z_(n,[],!0),xs.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2t(n,e){if((Ru(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ru(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return T2t(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2t(n){const t={x:Mi(n,"x","sqrt","float32")};return xs.runKernel(XSt,t)}const W9=ta({sqrt_:I2t});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2t(n){const e=Mi(n,"x","square"),t={};return xs.runKernel("Square",{x:e},t)}const M2t=ta({square_:A2t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2t(n,e=null,t=!1){let r=Mi(n,"x","sum");r.dtype==="bool"&&(r=Lce(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return xs.runKernel(KSt,s,i)}const ab=ta({sum_:N2t});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2t(n,e="euclidean",t=null,r=!1){n=Mi(n,"x","norm");const s=zce(n,e,t);let i=s.shape;if(r){const o=wce(t,n.shape);i=x2t(s.shape,o)}return hx(s,i)}function zce(n,e,t=null){if(n.rank===0)return wd(n);if(n.rank!==1&&t===null)return zce(hx(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ab(wd(n),t);if(e===1/0)return JP(wd(n),t);if(e===-1/0)return U9(wd(n),t);if(e==="euclidean"||e===2)return W9(ab(k2t(wd(n),E2t(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return JP(ab(wd(n),t[0]),t[1]-1);if(e===1/0)return JP(ab(wd(n),t[1]),t[0]);if(e===-1/0)return U9(ab(wd(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return W9(ab(M2t(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const R2t=ta({norm_:$2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.norm=function(n,e,t){return this.throwIfDisposed(),R2t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),y2t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.as1D=function(){return this.throwIfDisposed(),hx(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.as2D=function(n,e){return this.throwIfDisposed(),hx(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.asType=function(n){return this.throwIfDisposed(),Lce(this,n)};class Bce extends t0{constructor({k:e=3}={}){super(),this.title="KNN classifier",this.serviceName="knn-classifier-models",this.classifier=new Eht,this.parameters={k:new gt(e,!0)}}async train(e){this.labels=Ng(e)?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:r})=>r).toArray()));const t=Ng(e)?e.items():e;if(this.labels.length<1)throw this.$training.set({status:"error"}),new Error("Cannot train a kNN with no classes");this.$training.set({status:"start",epochs:1}),this.classifier.clearAllClasses();for await(const{x:r,y:s}of t)this.classifier.addExample(ki(r),s);this.$training.set({status:"success"})}async predict(e){if(!this.classifier||!this.labels||this.labels.length<1)return{label:void 0,confidences:{}};const{label:t,confidences:r}=await this.classifier.predictClass(ki(e),this.parameters.k.get());return{label:t,confidences:r}}clear(){delete this.classifier}async save(e,t,r,s=null){const i=await this.write(r);return i.name=t,this.saveToDatastore(e,i,s)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);L_(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(s=>s.name.includes(".json")),r=await new Promise((s,i)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);s(a)},o.onerror=i,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){if(!this.classifier)return null;const t=this.classifier.getClassifierDataset(),r={};for(const i of Object.keys(t)){const o=t[i].arraySync();r[i]=o}return{name:V$(this.title),files:[],format:"knn-classifier",metadata:{labels:this.labels,data:r,...e}}}async read(e){const t=e.metadata.data;if(!t)return;const r={};for(const[s,i]of Object.entries(t))r[s]=Ga(i);this.labels=e.metadata.labels,this.classifier.setClassifierDataset(r),this.$training.set({status:"loaded"})}}Dn([Ln],Bce.prototype,"train",null);Dn([Ln],Bce.prototype,"predict",null);class P2t extends Dce{constructor({layers:e=[64,32],...t}={}){super(t),this.title="MLPClassifier",this.parameters={layers:new gt(e,!0),...this.parameters}}buildModel(e,t){this.model=Cnt();for(const[s,i]of this.parameters.layers.get().entries()){const o={units:i,activation:"relu"};s===0&&(o.inputDim=e[0]),this.model.add(C6(o))}this.model.add(C6({units:t[0],activation:"softmax"}));const r=Sd.adam();this.model.compile({optimizer:r,loss:"categoricalCrossentropy",metrics:["accuracy"]})}}function D2t(...n){return new P2t(...n)}function O2t(n){let e,t,r,s,i;return{c(){e=Qe("Using Mobilenet v"),t=Qe(n[2]),r=Qe(" with alpha = "),s=Qe(n[3]),i=Qe(".")},m(o,a){be(o,e,a),be(o,t,a),be(o,r,a),be(o,s,a),be(o,i,a)},p(o,a){a&4&&dn(t,o[2]),a&8&&dn(s,o[3])},d(o){o&&ye(e),o&&ye(t),o&&ye(r),o&&ye(s),o&&ye(i)}}}function F2t(n){let e;return{c(){e=Qe("")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function L2t(n){let e;function t(i,o){return i[4]?F2t:O2t}let r=t(n),s=r(n);return{c(){e=Ce("p"),s.c(),te(e,"class","p-2 text-sm text-gray-600")},m(i,o){be(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&ye(e),s.d()}}}function z2t(n){let e,t;return e=new rl({props:{title:n[0],loading:n[4],$$slots:{default:[L2t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&16&&(i.loading=r[4]),s&60&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function B2t(n,e,t){let r,s=ot,i=()=>(s(),s=es(a,u=>t(4,r=u)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{version:l}=e,{alpha:c}=e;return n.$$set=u=>{"title"in u&&t(0,o=u.title),"loading"in u&&i(t(1,a=u.loading)),"version"in u&&t(2,l=u.version),"alpha"in u&&t(3,c=u.alpha)},[o,a,l,c,r]}class V2t extends Rn{constructor(e){super(),$n(this,e,B2t,z2t,Nn,{title:0,loading:1,version:2,alpha:3})}}var pf;class dx extends t0{constructor({version:e=1,alpha:t=1}={}){if(super(),this.title="mobileNet",this.parameters={},this.serviceName="undefined",pf.set(this,void 0),this.$loading=new gt(!0,!0),![1,2].includes(e))throw new Error("Mobilenet version must be 1 or 2");if(![.25,.5,.75,1].includes(t))throw new Error("Mobilenet alpha must be 0.25 | 0.50 | 0.75 | 1.0");this.version=e,this.alpha=t,this.setup()}async setup(){await G2();const e=await RL(),t=Object.keys(e).filter(r=>r.includes("mobileNet"));try{Vn(this,pf,await _j({modelUrl:`indexeddb://mobilenet-v${this.version}-${this.alpha}`,version:this.version,alpha:this.alpha}),"f")}catch{t.length>0&&await PL(t[0]),Vn(this,pf,await _j({version:this.version,alpha:this.alpha}),"f"),await Ue(this,pf,"f").model.save(`indexeddb://mobilenet-v${this.version}-${this.alpha}`)}return ma.info(`MobileNet v${this.version} loaded with alpha = ${this.alpha}`),this.$loading.set(!1),this.start(),this}async process(e){return Ue(this,pf,"f")?Se(()=>Ue(this,pf,"f").infer(e,!0).arraySync()[0]):[]}async predict(e){if(!Ue(this,pf,"f"))throw new Error("Mobilenet is not loaded");const t=await Ue(this,pf,"f").classify(e,5);return{label:t[0].className,confidences:t.reduce((r,s)=>({...r,[s.className]:s.probability}),{})}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new V2t({target:t,props:{title:this.title,loading:this.$loading,version:this.version,alpha:this.alpha}}))}train(){throw new wp("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}pf=new WeakMap;Dn([Ln],dx.prototype,"train",null);Dn([Ln],dx.prototype,"save",null);Dn([Ln],dx.prototype,"load",null);Dn([Ln],dx.prototype,"download",null);Dn([Ln],dx.prototype,"upload",null);function U2t(...n){return new dx(...n)}function W2t(n){let e;return{c(){e=Ce("p"),e.textContent="No model loaded"},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function G2t(n){let e,t,r,s;return{c(){e=Ce("p"),t=Qe("Model Loaded from "),r=Qe(n[2]),s=Qe(".")},m(i,o){be(i,e,o),ue(e,t),ue(e,r),ue(e,s)},p(i,o){o&4&&dn(r,i[2])},d(i){i&&ye(e)}}}function H2t(n){let e;return{c(){e=Ce("p"),e.textContent="Loading Model..."},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function j2t(n){let e;function t(i,o){return i[3]==="loading"?H2t:i[3]==="loaded"?G2t:W2t}let r=t(n),s=r(n);return{c(){e=Ce("div"),s.c(),te(e,"class","p-2 text-sm text-gray-600")},m(i,o){be(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&ye(e),s.d()}}}function q2t(n){let e,t;return e=new rl({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[j2t]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]==="loading"),s&268&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function X2t(n,e,t){let r,s,i,o=ot,a=()=>(o(),o=es(f,d=>t(7,i=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=i.status),n.$$.dirty&240&&t(2,s=!(t(4,l=i.data)===null||l===void 0)&&l.source?i.data.source==="datastore"?`datastore at ${t(5,c=i.data)===null||c===void 0?void 0:c.url}`:i.data.source==="url"?`url ${t(6,u=i.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,s,r,l,c,u,i]}class K2t extends Rn{constructor(e){super(),$n(this,e,X2t,q2t,Nn,{title:0,training:1})}}var mf;function G9(n,e){return n===e}function H9(n,e){return n===e}class Gu extends t0{constructor({inputType:e,taskType:t,inputShape:r}){super(),this.title="onnx model",this.parameters={},this.serviceName="onnx-models",this.$loading=new gt(!1,!0),this.$ready=new gt(!1,!0),this.modelName="",this.lockLoading=Promise.resolve(),mf.set(this,void 0),this.inputType=e,this.taskType=t,this.inputShape=r,this.start()}train(){throw new wp("Model `OnnxModel` cannot be trained")}async predict(e){if(!Ue(this,mf,"f")||!this.$ready.get())throw new Error("Model is not loaded");const t=this.preprocess(e),r=await Ue(this,mf,"f").run({[Ue(this,mf,"f").inputNames[0]]:t});return await this.postprocess(r)}async loadFromUrl(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{await this.loadModel(e,e),this.$training.set({status:"loaded",data:{source:"url",url:e}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}async loadFromFile(e){if(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{const t=await new Promise((r,s)=>{const i=new FileReader;i.onload=function(){const a=this.result;r(a)},i.onerror=function(){s()},i.readAsArrayBuffer(e)});await this.loadModel(t,e.name),this.$training.set({status:"loaded",data:{source:"file"}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}}async loadModel(e,t){this.ready=!1,this.lockLoading=this.lockLoading.then(()=>ort.InferenceSession.create(e)).then(r=>{Vn(this,mf,r,"f")}),await this.lockLoading,this.modelName=t;try{await this.warmup()}catch(r){console.log("ONNX Model warmup failed",r)}this.ready=!0}preprocess(e){if(G9(this.inputType,"image"))return this.preprocessImage(e);if(G9(this.inputType,"generic")){const t=e.flat().flat().flat().flat().flat();return new ort.Tensor("float32",Float32Array.from(t),this.inputShape)}throw new Error("Invalid input data type")}preprocessImage(e){throw new Error("ONNX for Images: Not yet implemented")}async postprocess(e){if(H9(this.taskType,"classification")){const t=this.labels?s=>this.labels[s]:s=>s.toString(),r=Array.from(e.probabilities.data).reduce((s,i,o)=>({...s,[t(o)]:i}),{});return{label:t(e.label.data[0]),confidences:r}}if(H9(this.taskType,"generic")){const t={};for(const r of Ue(this,mf,"f").outputNames)t[r]=Array.from(e[r].data);return t}throw new Error("Invalid output data type")}async warmup(){const e=Float32Array.from(Array(this.inputShape.reduce((r,s)=>r*s,1)),()=>Math.random()),t=new ort.Tensor("float32",e,this.inputShape);await Ue(this,mf,"f").run({[Ue(this,mf,"f").inputNames[0]]:t})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new K2t({target:t,props:{title:this.title,training:this.$training}}))}save(){throw new Error("OnnxModel does not support saving")}load(){throw new Error("OnnxModel does not support loading")}download(){throw new Error("OnnxModel does not support downloading")}upload(){throw new Error("OnnxModel does not support uploading")}}mf=new WeakMap;Dn([Ln],Gu.prototype,"train",null);Dn([Ln],Gu.prototype,"predict",null);Dn([Ln],Gu.prototype,"loadFromUrl",null);Dn([Ln],Gu.prototype,"loadFromFile",null);Dn([Ln],Gu.prototype,"loadModel",null);Dn([Ln],Gu.prototype,"preprocess",null);Dn([Ln],Gu.prototype,"postprocess",null);Dn([Ln],Gu.prototype,"save",null);Dn([Ln],Gu.prototype,"load",null);Dn([Ln],Gu.prototype,"download",null);Dn([Ln],Gu.prototype,"upload",null);const Y2t={MoveNet:.35,PoseNet:.5,BlazePose:.65},Z2t=["#ffffff","#800000","#469990","#e6194b","#42d4f4","#fabed4","#aaffc3","#9a6324","#000075","#f58231","#4363d8","#ffd8b1","#dcbeff","#808000","#ffe119","#911eb4","#bfef45","#f032e6","#3cb44b","#a9a9a9"];class j9{constructor(e,t){this.model=e,this.width=t,this.params={lineWidth:2,radius:4,scoreThreshold:Y2t[e]},this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.width,this.ctx=this.canvas.getContext("2d")}drawKeypoint(e){if((e.score!=null?e.score:1)>=this.params.scoreThreshold){const r=new Path2D;r.arc(e.x,e.y,this.params.radius,0,2*Math.PI),this.ctx.fill(r),this.ctx.stroke(r)}}drawKeypoints(e){const t=Rj.getKeypointIndexBySide(this.model);this.ctx.fillStyle="Red",this.ctx.strokeStyle="White",this.ctx.lineWidth=this.params.lineWidth;for(const r of t.middle)this.drawKeypoint(e[r]);this.ctx.fillStyle="Green";for(const r of t.left)this.drawKeypoint(e[r]);this.ctx.fillStyle="Orange";for(const r of t.right)this.drawKeypoint(e[r])}drawSkeleton(e,t){const r=t!=null?Z2t[t%20]:"White";this.ctx.fillStyle=r,this.ctx.strokeStyle=r,this.ctx.lineWidth=this.params.lineWidth,Rj.getAdjacentPairs(this.model).forEach(([s,i])=>{const o=e[s],a=e[i],l=o.score!=null?o.score:1,c=a.score!=null?a.score:1,u=this.params.scoreThreshold||0;l>=u&&c>=u&&(this.ctx.beginPath(),this.ctx.moveTo(o.x,o.y),this.ctx.lineTo(a.x,a.y),this.ctx.stroke())})}drawResult(e){if(e.keypoints!=null&&(this.drawKeypoints(e.keypoints),this.drawSkeleton(e.keypoints,e.id)),e.keypoints3D!=null)throw new Error("Keypoints 3D is not Implemented...")}drawResults(e){for(const t of e)this.drawResult(t)}drawImage(e){this.ctx.clearRect(0,0,e.width,e.width),this.canvas.height=e.height,this.canvas.width=e.width,this.ctx.putImageData(e,0,0)}render(e,t,r="ImageData"){return this.drawImage(e),this.drawResults(t),r==="ImageData"?this.ctx.getImageData(0,0,this.width,this.width):this.canvas.toDataURL("image/jpeg")}}function J2t(n){let e,t,r;return{c(){e=Qe("Using "),t=Qe(n[2]),r=Qe(" pose detector.")},m(s,i){be(s,e,i),be(s,t,i),be(s,r,i)},p(s,i){i&4&&dn(t,s[2])},d(s){s&&ye(e),s&&ye(t),s&&ye(r)}}}function Q2t(n){let e;return{c(){e=Qe("")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function eCt(n){let e;function t(i,o){return i[3]?Q2t:J2t}let r=t(n),s=r(n);return{c(){e=Ce("p"),s.c(),te(e,"class","p-2 text-sm text-gray-600")},m(i,o){be(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&ye(e),s.d()}}}function tCt(n){let e,t;return e=new rl({props:{title:n[0],loading:n[3],$$slots:{default:[eCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]),s&28&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function nCt(n,e,t){let r,s=ot,i=()=>(s(),s=es(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{model:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&i(t(1,a=c.loading)),"model"in c&&t(2,l=c.model)},[o,a,l,r]}class rCt extends Rn{constructor(e){super(),$n(this,e,nCt,tCt,Nn,{title:0,loading:1,model:2})}}var U1,uI,hI;class qC extends t0{constructor(e="MoveNet",t){super(),this.model=e,this.modelConfig=t,this.title="Pose Detection",this.parameters={},this.serviceName="undefined",U1.set(this,void 0),this.$loading=new gt(!0,!0),this.$bodyParts=new gt("Full body",!1),uI.set(this,void 0),hI.set(this,void 0),Vn(this,uI,new j9(so[e],224),"f"),Vn(this,hI,new j9(so[e],60),"f"),this.start(),this.setup(e,t)}async setup(e,t){await G2(),Vn(this,U1,await Bft(so[e],t),"f"),ma.info(`${e} loaded`),this.$loading.set(!1),this.start()}async predict(e){return Ue(this,U1,"f")?await Ue(this,U1,"f").estimatePoses(e):(ma.error("Movenet is not loaded"),[])}postprocess(e,t){const r=t&&Array.isArray(t)&&t.length>0?(s,i)=>t.includes(i):()=>!0;return e.map(s=>{const i=s.keypoints[0];return s.keypoints.filter(r).reduce((o,a)=>[...o,(a.x-i.x)/100,(a.y-i.y)/100],[])}).reduce((s,i)=>[...s,...i],[])}thumbnail(e,t){return Ue(this,hI,"f").render(e,t,"dataURL")}render(e,t){return Ue(this,uI,"f").render(e,t)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new rCt({target:t,props:{title:this.title,loading:this.$loading,model:this.model}}))}train(){throw new wp("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}U1=new WeakMap,uI=new WeakMap,hI=new WeakMap;Dn([Ln],qC.prototype,"train",null);Dn([Ln],qC.prototype,"save",null);Dn([Ln],qC.prototype,"load",null);Dn([Ln],qC.prototype,"download",null);Dn([Ln],qC.prototype,"upload",null);function sCt(n){let e,t,r,s,i;function o(l){n[5](l)}let a={type:"text",placeholder:"Enter a label..",disabled:n[4]};return n[3]!==void 0&&(a.value=n[3]),r=new xxt({props:a}),So.push(()=>ux(r,"value",o)),{c(){e=Ce("div"),t=Ce("div"),Pt(r.$$.fragment),te(t,"class","md:flex md:items-center mb-2"),te(e,"class","w-full max-w-sm")},m(l,c){be(l,e,c),ue(e,t),At(r,t,null),i=!0},p(l,c){const u={};c&16&&(u.disabled=l[4]),!s&&c&8&&(s=!0,u.value=l[3],cx(()=>s=!1)),r.$set(u)},i(l){i||(Ae(r.$$.fragment,l),i=!0)},o(l){Re(r.$$.fragment,l),i=!1},d(l){l&&ye(e),Mt(r)}}}function iCt(n){let e,t;return e=new rl({props:{title:n[0],$$slots:{default:[sCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&88&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function oCt(n,e,t){let r,s=ot,i=()=>(s(),s=es(u,d=>t(3,r=d)),u),o,a=ot,l=()=>(a(),a=es(h,d=>t(4,o=d)),h);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a());let{title:c}=e,{value:u}=e;i();let{disabled:h}=e;l();function f(d){r=d,u.set(r)}return n.$$set=d=>{"title"in d&&t(0,c=d.title),"value"in d&&i(t(1,u=d.value)),"disabled"in d&&l(t(2,h=d.disabled))},[c,u,h,r,o,f]}class aCt extends Rn{constructor(e){super(),$n(this,e,oCt,iCt,Nn,{title:0,value:1,disabled:2})}}class lCt extends Lc{constructor(e){super(),this.title="text input",this.$value=new gt("",!0),this.$disabled=new gt(!1,!0),e!==void 0&&this.$value.set(e),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new aCt({target:t,props:{title:this.title,value:this.$value,disabled:this.$disabled}}))}}function cCt(...n){return new lCt(...n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */zc().prototype.mul=function(n){return this.throwIfDisposed(),v2t(this,n)};function uCt(n){let e;return{c(){e=Ce("p"),e.textContent="No model loaded"},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function hCt(n){let e,t,r,s;return{c(){e=Ce("p"),t=Qe("Model Loaded from "),r=Qe(n[2]),s=Qe(".")},m(i,o){be(i,e,o),ue(e,t),ue(e,r),ue(e,s)},p(i,o){o&4&&dn(r,i[2])},d(i){i&&ye(e)}}}function fCt(n){let e;return{c(){e=Ce("p"),e.textContent="Loading Model..."},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function dCt(n){let e;function t(i,o){return i[3]==="loading"?fCt:i[3]==="loaded"?hCt:uCt}let r=t(n),s=r(n);return{c(){e=Ce("div"),s.c(),te(e,"class","p-2 text-sm text-gray-600")},m(i,o){be(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&ye(e),s.d()}}}function pCt(n){let e,t;return e=new rl({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[dCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]==="loading"),s&268&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function mCt(n,e,t){let r,s,i,o=ot,a=()=>(o(),o=es(f,d=>t(7,i=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=i.status),n.$$.dirty&240&&t(2,s=!(t(4,l=i.data)===null||l===void 0)&&l.source?i.data.source==="datastore"?`datastore at ${t(5,c=i.data)===null||c===void 0?void 0:c.url}`:i.data.source==="url"?`url ${t(6,u=i.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,s,r,l,c,u,i]}class gCt extends Rn{constructor(e){super(),$n(this,e,mCt,pCt,Nn,{title:0,training:1})}}function q9(n,e){return n===e}function QP(n,e){return n===e}class n0 extends U${constructor({inputType:e,taskType:t,segmentationOptions:r={applyArgmax:!1,output:"image"}}){super(),this.title="tfjs model",this.parameters={},this.segmentationOptions={applyArgmax:!1,output:"image",...r},this.inputType=e,this.taskType=t,this.$training.subscribe(({status:s})=>{s==="loaded"&&(this.inputShape=this.model.inputs[0].shape.map(i=>i&&i>0?i:1))})}train(){throw new wp("Model `TfModel` cannot be trained")}async predict(e){if(!this.model||this.$training.get().status!=="loaded")throw new Error("Model is not loaded");const t=Se(()=>{const s=this.preprocess(e);return this.model.predict(s.expandDims(0)).gather(0)}),r=await this.postprocess(t);return t.dispose(),r}preprocess(e){if(q9(this.inputType,"image"))return this.preprocessImage(e);if(q9(this.inputType,"generic"))return ki(e);throw new Error("Invalid input data type")}preprocessImage(e){return Si.resizeBilinear(sC(e),[this.inputShape[1],this.inputShape[2]])}async postprocess(e){if(QP(this.taskType,"classification")){const t=this.labels?i=>this.labels[i]:i=>i.toString(),r=Se(()=>e.argMax().dataSync()[0]),s=e.arraySync().reduce((i,o,a)=>({...i,[t(a)]:o}),{});return{label:t(r),confidences:s}}if(QP(this.taskType,"segmentation")){const[t,r]=e.shape,s=this.segmentationOptions.applyArgmax?Se(()=>e.argMax(-1).mul(.5)):e,i=this.segmentationOptions.output==="image"?new ImageData(await rC(s),t,r):await s.array();return this.segmentationOptions.applyArgmax&&s.dispose(),i}if(QP(this.taskType,"generic"))return e.array();throw new Error("Invalid output data type")}async loadFromFiles(e){this.$training.set({status:"loading"});try{const t=e.filter(s=>s.name.includes(".json")),r=e.filter(s=>s.name.includes(".bin"));if(t.length!==1){const s=new Error("The provided files are not compatible with this model");throw s.name="File upload error",s}if(this.$training.set({status:"loading"}),e.length){const s=await gce(t[0]);this.loadFn=s.format==="graph-model"?Pl:GS,this.model=await this.loadFn(bce([t[0],...r])),await this.warmup(),this.$training.set({status:"loaded",data:{source:"file"}})}}catch(t){throw this.$training.set({status:"error"}),t}}async loadFromUrl(e){this.$training.set({status:"loading"});try{const t=await fetch(e).then(r=>r.json());this.loadFn=t.format==="graph-model"?Pl:GS,this.model=await this.loadFn(uL(e)),await this.warmup(),this.$training.set({status:"loaded",data:{source:"url",url:e}})}catch(t){throw console.log("[tf-model] Loading error",t),this.$training.set({status:"error"}),t}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new gCt({target:t,props:{title:this.title,training:this.$training}}))}}Dn([Ln],n0.prototype,"train",null);Dn([Ln],n0.prototype,"predict",null);Dn([Ln],n0.prototype,"preprocess",null);Dn([Ln],n0.prototype,"preprocessImage",null);Dn([Ln],n0.prototype,"postprocess",null);Dn([Ln],n0.prototype,"loadFromFiles",null);Dn([Ln],n0.prototype,"loadFromUrl",null);const yCt=n=>function(t,r,s){const i=s.value;return s.value=function(...a){const l=this[n].then(()=>i.apply(this,a));return this[n]=l,l},s};function bCt(n){let e;return{c(){e=Ce("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,te(e,"class","empty svelte-yj1ygt")},m(t,r){be(t,e,r)},p:ot,i:ot,o:ot,d(t){t&&ye(e)}}}function vCt(n){let e,t;return e=new fce({props:{columns:[{name:"field"},...n[2]],provider:n[1],selectable:!1}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&4&&(i.columns=[{name:"field"},...r[2]]),s&2&&(i.provider=r[1]),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function wCt(n){let e,t,r,s;const i=[vCt,bCt],o=[];function a(l,c){return l[0].length>0?0:1}return e=a(n),t=o[e]=i[e](n),{c(){t.c(),r=ea()},m(l,c){o[e].m(l,c),be(l,r,c),s=!0},p(l,[c]){let u=e;e=a(l),e===u?o[e].p(l,c):(yr(),Re(o[u],1,1,()=>{o[u]=null}),br(),t=o[e],t?t.p(l,c):(t=o[e]=i[e](l),t.c()),Ae(t,1),t.m(r.parentNode,r))},i(l){s||(Ae(t),s=!0)},o(l){Re(t),s=!1},d(l){o[e].d(l),l&&ye(r)}}}function xCt(n,e,t){let r,s,i,o,{runs:a}=e;return n.$$set=l=>{"runs"in l&&t(0,a=l.runs)},n.$$.update=()=>{n.$$.dirty&1&&t(2,r=a.map((l,c)=>({name:`Run ${c+1}`}))),n.$$.dirty&1&&t(4,s=a.length>0?Object.keys(a[0]).filter(l=>l!=="logs"):[]),n.$$.dirty&17&&t(3,i=s.map(l=>a.map((c,u)=>({[`Run ${u+1}`]:c[l]})).reduce((c,u)=>({...c,...u}),{field:l}))),n.$$.dirty&8&&t(1,o=new R1t({data:i}))},[a,o,r,i,s]}class Vce extends Rn{constructor(e){super(),$n(this,e,xCt,wCt,Nn,{runs:0})}}function X9(n,e,t){const r=n.slice();return r[5]=e[t],r[6]=e,r[7]=t,r}function K9(n){let e,t=n[7];const r=()=>n[3](e,t),s=()=>n[3](null,t);return{c(){e=Ce("div"),te(e,"class","card inner-card xl:flex-1 svelte-1o4ebpu")},m(i,o){be(i,e,o),r()},p(i,o){n=i,t!==n[7]&&(s(),t=n[7],r())},d(i){i&&ye(e),s()}}}function SCt(n){let e,t=Object.values(n[0]),r=[];for(let s=0;s<t.length;s+=1)r[s]=K9(X9(n,t,s));return{c(){e=Ce("div");for(let s=0;s<r.length;s+=1)r[s].c();te(e,"class","grid grid-cols-1 gap-1")},m(s,i){be(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null);n[4](e)},p(s,[i]){if(i&5){t=Object.values(s[0]);let o;for(o=0;o<t.length;o+=1){const a=X9(s,t,o);r[o]?r[o].p(a,i):(r[o]=K9(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},i:ot,o:ot,d(s){s&&ye(e),Vi(r,s),n[4](null)}}}function _Ct(n,e,t){let{charts:r}=e,s,i=[];$h(async()=>{await Ka(),await Ka(),Object.keys(r).length>1&&s.clientWidth>700&&t(1,s.style.gridTemplateColumns="repeat(2, minmax(0, 1fr))",s);for(const[l,c]of Object.values(r).entries())c.mount(i[l])}),wv(()=>{for(const l of Object.values(r))l.destroy()});function o(l,c){So[l?"unshift":"push"](()=>{i[c]=l,t(2,i)})}function a(l){So[l?"unshift":"push"](()=>{s=l,t(1,s)})}return n.$$set=l=>{"charts"in l&&t(0,r=l.charts)},[r,s,i,o,a]}class CCt extends Rn{constructor(e){super(),$n(this,e,_Ct,SCt,Nn,{charts:0})}}class kCt extends Lc{constructor(e,t={loss:["loss","lossVal"],accuracy:["acc","accVal"]}){if(super(),this.model=e,this.title="training plot",this.charts={},!e){const o=new Error("[training plot] No model was provided");o.name="Component Compatibility Error",Ya(o)}if(!e.$training){const o=new Error("[training plot] The provided model is incompatible with the training plot component, missing `$training` stream");o.name="Component Compatibility Error",Ya(o)}let r=t;typeof t=="string"&&(r=[t]),Array.isArray(r)&&(r=r.reduce((o,a)=>({...o,[a]:a}),{}));const s={};for(const[o,a]of Object.entries(r)){const l=Array.isArray(a)?a:[a];this.charts[o]=Fce({preset:"line-fast",options:{xlabel:"Epoch",ylabel:o}});for(const c of l)Object.keys(s).includes(c)||(s[c]=new gt([],!0)),this.charts[o].addSeries(s[c],c);this.charts[o].title=o}function i(){for(const o of Object.values(s))o.set([])}e.$training.subscribe(o=>{if(o.status==="start")i();else if(o.data)for(const[a,l]of Object.entries(o.data)){if(!Object.keys(s).includes(a))return;Array.isArray(l)?s[a].set(l.map((c,u)=>({x:u+1,y:c}))):s[a].set(s[a].get().concat([{x:s[a].get().length+1,y:l}]))}}),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new CCt({target:t,props:{charts:this.charts}}))}}function TCt(...n){return new kCt(...n)}function ECt(n){let e;return{c(){e=Ce("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,te(e,"class","empty svelte-yj1ygt")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function ICt(n){let e;return{c(){e=Ce("div")},m(t,r){be(t,e,r),n[7](e)},p:ot,d(t){t&&ye(e),n[7](null)}}}function ACt(n){let e;function t(i,o){return i[0].length>0?ICt:ECt}let r=t(n),s=r(n);return{c(){s.c(),e=ea()},m(i,o){s.m(i,o),be(i,e,o)},p(i,[o]){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},i:ot,o:ot,d(i){s.d(i),i&&ye(e)}}}function MCt(n,e,t){let r,s,{names:i}=e,{logs:o}=e,a,l,c;wv(()=>{c&&c.destroy()});function u(h){So[h?"unshift":"push"](()=>{a=h,t(1,a)})}return n.$$set=h=>{"names"in h&&t(2,i=h.names),"logs"in h&&t(0,o=h.logs)},n.$$.update=()=>{n.$$.dirty&9&&(t(3,l=Array.from(new Set(o.map(Object.keys).flat()))),l.sort()),n.$$.dirty&5&&t(6,r=o.map((h,f)=>Object.entries(h).reduce((d,[p,m])=>({...d,[`${p} (${i[f]})`]:m}),{})).reduce((h,f)=>({...h,...f}),{})),n.$$.dirty&72&&t(5,s=l.reduce((h,f)=>({...h,[f]:Object.keys(r).filter(d=>d.startsWith(`${f} (`))}),{})),n.$$.dirty&114&&(c&&c.destroy(),t(4,c=TCt({$training:new gt({status:"success",data:r},!0)},s)),c.mount(a))},[o,a,i,l,c,s,r,u]}class NCt extends Rn{constructor(e){super(),$n(this,e,MCt,ACt,Nn,{names:2,logs:0})}}function Y9(n,e,t){const r=n.slice();return r[13]=e[t],r[15]=t,r}function $Ct(n){let e;return{c(){e=Qe("Graphs")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function RCt(n){let e;return{c(){e=Qe("Metadata")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function PCt(n){let e;return{c(){e=Qe("Parameters")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function DCt(n){let e;return{c(){e=Qe("Model Summary")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function OCt(n){let e,t,r,s,i,o,a,l;return e=new TE({props:{$$slots:{default:[$Ct]},$$scope:{ctx:n}}}),r=new TE({props:{$$slots:{default:[RCt]},$$scope:{ctx:n}}}),i=new TE({props:{$$slots:{default:[PCt]},$$scope:{ctx:n}}}),a=new TE({props:{$$slots:{default:[DCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment),t=st(),Pt(r.$$.fragment),s=st(),Pt(i.$$.fragment),o=st(),Pt(a.$$.fragment)},m(c,u){At(e,c,u),be(c,t,u),At(r,c,u),be(c,s,u),At(i,c,u),be(c,o,u),At(a,c,u),l=!0},p(c,u){const h={};u&65536&&(h.$$scope={dirty:u,ctx:c}),e.$set(h);const f={};u&65536&&(f.$$scope={dirty:u,ctx:c}),r.$set(f);const d={};u&65536&&(d.$$scope={dirty:u,ctx:c}),i.$set(d);const p={};u&65536&&(p.$$scope={dirty:u,ctx:c}),a.$set(p)},i(c){l||(Ae(e.$$.fragment,c),Ae(r.$$.fragment,c),Ae(i.$$.fragment,c),Ae(a.$$.fragment,c),l=!0)},o(c){Re(e.$$.fragment,c),Re(r.$$.fragment,c),Re(i.$$.fragment,c),Re(a.$$.fragment,c),l=!1},d(c){Mt(e,c),c&&ye(t),Mt(r,c),c&&ye(s),Mt(i,c),c&&ye(o),Mt(a,c)}}}function FCt(n){let e,t;return e=new NCt({props:{logs:n[4].map(Q9),names:n[4].map(e7)}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.logs=r[4].map(Q9)),s&16&&(i.names=r[4].map(e7)),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function LCt(n){let e,t;return e=new Vce({props:{runs:n[4]}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.runs=r[4]),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function zCt(n){let e,t;return e=new Vce({props:{runs:n[4].map(t7)}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.runs=r[4].map(t7)),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function Z9(n){let e,t,r,s=n[15]+1+"",i,o,a,l,c=n[13]+"",u,h,f;return{c(){e=Ce("div"),t=Ce("h2"),r=Qe("Model "),i=Qe(s),o=st(),a=Ce("div"),l=Ce("pre"),u=Qe(c),h=Ce("br"),f=st(),te(a,"class","summary svelte-y4izzs")},m(d,p){be(d,e,p),ue(e,t),ue(t,r),ue(t,i),ue(e,o),ue(e,a),ue(a,l),ue(l,u),ue(l,h),ue(e,f)},p(d,p){p&16&&c!==(c=d[13]+"")&&dn(u,c)},d(d){d&&ye(e)}}}function BCt(n){let e,t=n[4].map(n7),r=[];for(let s=0;s<t.length;s+=1)r[s]=Z9(Y9(n,t,s));return{c(){e=Ce("div");for(let s=0;s<r.length;s+=1)r[s].c();te(e,"class","summaries svelte-y4izzs")},m(s,i){be(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(s,i){if(i&16){t=s[4].map(n7);let o;for(o=0;o<t.length;o+=1){const a=Y9(s,t,o);r[o]?r[o].p(a,i):(r[o]=Z9(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(s){s&&ye(e),Vi(r,s)}}}function VCt(n){let e,t,r,s,i,o,a,l,c,u;return e=new $1t({props:{$$slots:{default:[OCt]},$$scope:{ctx:n}}}),r=new EE({props:{$$slots:{default:[FCt]},$$scope:{ctx:n}}}),i=new EE({props:{$$slots:{default:[LCt]},$$scope:{ctx:n}}}),a=new EE({props:{$$slots:{default:[zCt]},$$scope:{ctx:n}}}),c=new EE({props:{$$slots:{default:[BCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment),t=st(),Pt(r.$$.fragment),s=st(),Pt(i.$$.fragment),o=st(),Pt(a.$$.fragment),l=st(),Pt(c.$$.fragment)},m(h,f){At(e,h,f),be(h,t,f),At(r,h,f),be(h,s,f),At(i,h,f),be(h,o,f),At(a,h,f),be(h,l,f),At(c,h,f),u=!0},p(h,f){const d={};f&65536&&(d.$$scope={dirty:f,ctx:h}),e.$set(d);const p={};f&65552&&(p.$$scope={dirty:f,ctx:h}),r.$set(p);const m={};f&65552&&(m.$$scope={dirty:f,ctx:h}),i.$set(m);const g={};f&65552&&(g.$$scope={dirty:f,ctx:h}),a.$set(g);const y={};f&65552&&(y.$$scope={dirty:f,ctx:h}),c.$set(y)},i(h){u||(Ae(e.$$.fragment,h),Ae(r.$$.fragment,h),Ae(i.$$.fragment,h),Ae(a.$$.fragment,h),Ae(c.$$.fragment,h),u=!0)},o(h){Re(e.$$.fragment,h),Re(r.$$.fragment,h),Re(i.$$.fragment,h),Re(a.$$.fragment,h),Re(c.$$.fragment,h),u=!1},d(h){Mt(e,h),h&&ye(t),Mt(r,h),h&&ye(s),Mt(i,h),h&&ye(o),Mt(a,h),h&&ye(l),Mt(c,h)}}}function UCt(n){let e,t,r,s,i,o,a;function l(u){n[10](u)}let c={columns:n[7],provider:n[6],actions:[...n[1].map(J9),{name:"delete",confirm:!0}]};return n[4]!==void 0&&(c.selection=n[4]),e=new fce({props:c}),So.push(()=>ux(e,"selection",l)),n[11](e),e.$on("select",n[12]),o=new jxt({props:{$$slots:{default:[VCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment),r=st(),s=Ce("br"),i=st(),Pt(o.$$.fragment)},m(u,h){At(e,u,h),be(u,r,h),be(u,s,h),be(u,i,h),At(o,u,h),a=!0},p(u,h){const f={};h&2&&(f.actions=[...u[1].map(J9),{name:"delete",confirm:!0}]),!t&&h&16&&(t=!0,f.selection=u[4],cx(()=>t=!1)),e.$set(f);const d={};h&65552&&(d.$$scope={dirty:h,ctx:u}),o.$set(d)},i(u){a||(Ae(e.$$.fragment,u),Ae(o.$$.fragment,u),a=!0)},o(u){Re(e.$$.fragment,u),Re(o.$$.fragment,u),a=!1},d(u){n[11](null),Mt(e,u),u&&ye(r),u&&ye(s),u&&ye(i),Mt(o,u)}}}function WCt(n){let e,t;return e=new rl({props:{title:n[0],$$slots:{default:[UCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&65562&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}const J9=n=>typeof n=="string"?{name:n}:n,Q9=n=>n.logs,e7=n=>n.name,t7=n=>n.params,n7=n=>{var e;return((e=n.model)==null?void 0:e.summary)||"No summary available"};function GCt(n,e,t){let r,s=ot,i=()=>(s(),s=es(u,b=>t(4,r=b)),u);n.$$.on_destroy.push(()=>s());let{title:o}=e,{service:a}=e,{metrics:l}=e,{actions:c}=e,{selection:u}=e;i();const h=Fc(),f=new P1t({service:a,transform:{...l.reduce((b,x)=>({...b,[x]:w=>x in w.logs?w.logs[x][w.logs[x].length-1]:"metrics not found"}),{}),...c.reduce((b,x)=>({...b,[typeof x=="string"?x:x.name]:()=>typeof x=="string"?x:x.name}),{})}});f.data.subscribe(()=>{u.set([])});const d=[{name:"name",sortable:!0},{name:"start",sortable:!0,type:"date"},...l.map(b=>({name:b})),{name:"epochs"},{name:"status"},...c.map(b=>({name:typeof b=="string"?b:b.name,type:"action"}))];let p;$h(async()=>{await Ka(),await Ka();for(const b of c){const x=typeof b=="string"?b:b.name;p.$on(x,({detail:w})=>{h(x,w)})}});function m(b){r=b,u.set(r)}function g(b){So[b?"unshift":"push"](()=>{p=b,t(3,p)})}const y=({detail:b})=>h("load",b);return n.$$set=b=>{"title"in b&&t(0,o=b.title),"service"in b&&t(8,a=b.service),"metrics"in b&&t(9,l=b.metrics),"actions"in b&&t(1,c=b.actions),"selection"in b&&i(t(2,u=b.selection))},[o,c,u,p,r,h,f,d,a,l,m,g,y]}class HCt extends Rn{constructor(e){super(),$n(this,e,GCt,WCt,Nn,{title:0,service:8,metrics:9,actions:1,selection:2})}}function jCt(n,e){const t={...n};for(const[r,s]of Object.entries(e))t[r]=(t[r]||[]).concat([s]);return t}const qCt={metrics:["accuracy","accuracyVal","loss","lossVal"],actions:[]};class XCt extends Lc{constructor(e,t={}){super(),this.dataStore=e,this.title="Training History",this.$selection=new gt([],!0),this.$actions=new gt(null).skip(1),this.ready=Promise.resolve(),this.stopTracking=Qm,this.lock=Promise.resolve(),this.options={...qCt,...t},this.lock=this.lock.then(Qm),this.start(),this.ready=this.ready.then(()=>this.dataStore.connect()).then(()=>{this.runService=this.dataStore.service("runs")}).catch(()=>{ma.log("[dataset] dataStore connection failed")})}track(e,t="anonymous"){return this.ready.then(()=>(this.stopTracking(),this.model=e,this.modelName=t,this.runService.find({query:{basename:t,$sort:{createdAt:-1},$select:["name"],$limit:1}}))).then(({data:r})=>r.length>0?parseInt(r[0].name.split(`${t}-`)[1])+1:1).then(r=>{this.nextIndex=r,this.crtRun=null,this.stopTracking=this.model?this.model.$training.subscribe(this.trackTrainingStream):Qm}),this}async trackTrainingStream(e){if(e.status==="start")this.crtRun=await this.runService.create({name:`${this.modelName}-${this.nextIndex++}`,basename:this.modelName,start:new Date(Date.now()).toISOString(),source:"js",status:e.status,epochs:e.epochs,params:Object.entries(this.model.parameters).map(([t,r])=>({[t]:r.get()})).reduce((t,r)=>({...t,...r}),{}),logs:{}});else if(e.status==="epoch")this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:jCt(this.crtRun.logs,e.data)});else if(e.status==="success"){const t=await this.model.save(this.dataStore,this.modelName,{});this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:e.data,checkpoints:(this.crtRun.checkpoints||[]).concat([{id:t,name:`${this.crtRun.name}@final`,service:this.model.serviceName}])})}else e.status==="error"&&this.runService.patch(this.crtRun.id,{status:e.status})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.ready.then(()=>{this.$$.app=new HCt({target:t,props:{title:this.title,service:this.runService,metrics:this.options.metrics,actions:this.options.actions,selection:this.$selection}});for(const r of this.options.actions){const s=typeof r=="string"?r:r.name;this.$$.app.$on(s,({detail:i})=>{this.$actions.set({name:s,data:i})})}}))}}Dn([yCt("lock")],XCt.prototype,"trackTrainingStream",null);function r7(n){let e,t;return e=new LV({}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function s7(n){let e,t,r;return t=new zs({props:{round:!0,$$slots:{default:[KCt]},$$scope:{ctx:n}}}),t.$on("click",n[15]),{c(){e=Ce("div"),Pt(t.$$.fragment),te(e,"class","absolute bottom-2 right-2 text-right")},m(s,i){be(s,e,i),At(t,e,null),r=!0},p(s,i){const o={};i&262144&&(o.$$scope={dirty:i,ctx:s}),t.$set(o)},i(s){r||(Ae(t.$$.fragment,s),r=!0)},o(s){Re(t.$$.fragment,s),r=!1},d(s){s&&ye(e),Mt(t)}}}function KCt(n){let e,t;return{c(){e=vs("svg"),t=vs("path"),te(t,"stroke-linecap","round"),te(t,"stroke-linejoin","round"),te(t,"d","M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"fill","none"),te(e,"viewBox","0 0 24 24"),te(e,"stroke-width","1.5"),te(e,"stroke","currentColor"),te(e,"class","w-6 h-6")},m(r,s){be(r,e,s),ue(e,t)},p:ot,d(r){r&&ye(e)}}}function YCt(n){let e,t,r,s,i,o,a,l,c,u,h,f;function d(y){n[13](y)}let p={text:"activate video"};n[9]!==void 0&&(p.checked=n[9]),s=new Wxt({props:p}),So.push(()=>ux(s,"checked",d));let m=n[9]&&!n[10]&&r7(),g=n[8]>1&&s7(n);return{c(){e=Ce("div"),t=Ce("div"),r=Ce("div"),Pt(s.$$.fragment),o=st(),a=Ce("div"),m&&m.c(),l=st(),c=Ce("video"),u=st(),g&&g.c(),te(c,"id","webcam-video"),te(c,"class","max-w-none svelte-xql639"),ua(c,"width",n[1]>n[2]?`${n[7]}px`:"auto"),ua(c,"height",n[1]>n[2]?"auto":`${n[7]*n[2]/n[1]}px`),c.autoplay=!0,c.muted=!0,c.playsInline=!0,Gt(c,"mirror",n[11]==="user"),te(a,"class","webcam-container svelte-xql639"),ua(a,"flex-direction",n[1]>n[2]?"column":"row"),ua(a,"height",n[7]*n[2]/n[1]+"px"),Pc(()=>n[16].call(a)),te(e,"class","webcam svelte-xql639")},m(y,b){be(y,e,b),ue(e,t),ue(t,r),At(s,r,null),ue(e,o),ue(e,a),m&&m.m(a,null),ue(a,l),ue(a,c),n[14](c),ue(a,u),g&&g.m(a,null),h=nxt(a,n[16].bind(a)),f=!0},p(y,b){const x={};!i&&b&512&&(i=!0,x.checked=y[9],cx(()=>i=!1)),s.$set(x),y[9]&&!y[10]?m?b&1536&&Ae(m,1):(m=r7(),m.c(),Ae(m,1),m.m(a,l)):m&&(yr(),Re(m,1,1,()=>{m=null}),br()),(!f||b&134)&&ua(c,"width",y[1]>y[2]?`${y[7]}px`:"auto"),(!f||b&134)&&ua(c,"height",y[1]>y[2]?"auto":`${y[7]*y[2]/y[1]}px`),(!f||b&2048)&&Gt(c,"mirror",y[11]==="user"),y[8]>1?g?(g.p(y,b),b&256&&Ae(g,1)):(g=s7(y),g.c(),Ae(g,1),g.m(a,null)):g&&(yr(),Re(g,1,1,()=>{g=null}),br()),(!f||b&6)&&ua(a,"flex-direction",y[1]>y[2]?"column":"row"),(!f||b&134)&&ua(a,"height",y[7]*y[2]/y[1]+"px")},i(y){f||(Ae(s.$$.fragment,y),Ae(m),Ae(g),f=!0)},o(y){Re(s.$$.fragment,y),Re(m),Re(g),f=!1},d(y){y&&ye(e),Mt(s),m&&m.d(),n[14](null),g&&g.d(),h()}}}function ZCt(n){let e,t;return e=new rl({props:{title:n[0],$$slots:{default:[YCt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&266190&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function JCt(n,e,t){let r,s=ot,i=()=>(s(),s=es(g,N=>t(9,r=N)),g),o,a=ot,l=()=>(a(),a=es(b,N=>t(10,o=N)),b),c,u=ot,h=()=>(u(),u=es(m,N=>t(11,c=N)),m);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u());let{title:f}=e,{width:d}=e,{height:p}=e,{facingMode:m}=e;h();let{active:g}=e;i();let{mediaStream:y}=e,{ready:b}=e;l();let x,w,_=0,C=Qm;$h(async()=>{await Ka(),await Ka(),C=y.subscribe(N=>{var O;N&&t(6,x.srcObject=N,x),!((O=navigator.mediaDevices)===null||O===void 0)&&O.enumerateDevices&&navigator.mediaDevices.enumerateDevices().then(R=>R.filter(D=>D.kind==="videoinput")).then(R=>{t(8,_=R.length)}).catch(R=>{console.error(`${R.name}: ${R.message}`)})})}),wv(()=>{C()});function k(N){r=N,g.set(r)}function A(N){So[N?"unshift":"push"](()=>{x=N,t(6,x)})}const M=()=>m.set(m.get()==="user"?"environment":"user");function I(){w=this.clientWidth,t(7,w)}return n.$$set=N=>{"title"in N&&t(0,f=N.title),"width"in N&&t(1,d=N.width),"height"in N&&t(2,p=N.height),"facingMode"in N&&h(t(3,m=N.facingMode)),"active"in N&&i(t(4,g=N.active)),"mediaStream"in N&&t(12,y=N.mediaStream),"ready"in N&&l(t(5,b=N.ready))},[f,d,p,m,g,b,x,w,_,r,o,c,y,k,A,M,I]}class QCt extends Rn{constructor(e){super(),$n(this,e,JCt,ZCt,Nn,{title:0,width:1,height:2,facingMode:3,active:4,mediaStream:12,ready:5})}}var pl,sc,th,nh,la,fI,W1,ml,G1,gb,yb,dI;function ekt(n,e){let t=new Date().getTime(),r=!1,s;function i(){if(r)return;new Date().getTime()-t>=e&&(n(),t=new Date().getTime()),s=window.requestAnimationFrame(i)}return s=window.requestAnimationFrame(i),function(){window.cancelAnimationFrame(s),r=!0}}class tkt extends Lc{constructor({width:e=224,height:t=224,period:r=50,facingMode:s="user",audio:i=!1}={}){super(),this.title="webcam",this.$active=new gt(!1,!0),this.$ready=new gt(!1,!0),this.$mediastream=new gt(void 0,!0),this.$images=new gt(AS(),!0),this.$thumbnails=new gt(AS(),!0),pl.set(this,void 0),sc.set(this,void 0),th.set(this,void 0),nh.set(this,void 0),la.set(this,document.createElement("video")),fI.set(this,60),W1.set(this,Qm),ml.set(this,void 0),G1.set(this,void 0),gb.set(this,void 0),yb.set(this,void 0),dI.set(this,void 0),Vn(this,pl,e,"f"),Vn(this,sc,t,"f"),this.period=r,this.$facingMode=new gt(s,!0),Vn(this,dI,i,"f"),this.setupCapture(),Ue(this,la,"f").autoplay=!0,Ue(this,la,"f").muted=!0,Ue(this,la,"f").playsInline=!0;const o=a=>{Ue(this,W1,"f").call(this),a?(this.loadCameras(),Vn(this,W1,ekt(this.process,this.period),"f")):this.stopCamera()};this.$active.subscribe(o),this.$facingMode.subscribe(()=>this.$active.get()&&o(!0)),this.start()}getWidth(){return Ue(this,pl,"f")}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new QCt({target:t,props:{title:this.title,width:Ue(this,pl,"f"),height:Ue(this,sc,"f"),facingMode:this.$facingMode,active:this.$active,mediaStream:this.$mediastream,ready:this.$ready}}))}stop(){if(super.stop(),Ue(this,W1,"f").call(this),this.$mediastream.get())for(const e of this.$mediastream.get().getTracks())e.stop()}setupCapture(){Vn(this,ml,document.createElement("canvas"),"f"),Ue(this,ml,"f").width=Ue(this,fI,"f"),Ue(this,ml,"f").height=Ue(this,fI,"f")*Ue(this,sc,"f")/Ue(this,pl,"f"),Vn(this,G1,Ue(this,ml,"f").getContext("2d"),"f"),Vn(this,gb,document.createElement("canvas"),"f"),Ue(this,gb,"f").width=Ue(this,pl,"f"),Ue(this,gb,"f").height=Ue(this,sc,"f"),Vn(this,yb,Ue(this,gb,"f").getContext("2d"),"f")}async loadCameras(){try{const e=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:this.$facingMode.get()}},audio:Ue(this,dI,"f")});Vn(this,th,e.getVideoTracks()[0].getSettings().width,"f"),Vn(this,nh,e.getVideoTracks()[0].getSettings().height,"f"),this.loadSrcStream(e)}catch{Ya(new Error("Webcam not supported"))}}loadSrcStream(e){this.$mediastream.set(e),Ue(this,la,"f").srcObject=e,Ue(this,la,"f").play(),Ue(this,la,"f").onloadedmetadata=()=>{Vn(this,th,Ue(this,la,"f").videoWidth,"f"),Vn(this,nh,Ue(this,la,"f").videoHeight,"f"),this.$ready.set(!0)}}stopCamera(){if(this.$mediastream.get()){const e=this.$mediastream.get().getTracks();for(const t of e)t.stop(),Ue(this,la,"f").srcObject=null;this.$ready.set(!1)}}process(){this.$ready.get()&&(this.$thumbnails.set(this.captureThumbnail()),this.$images.set(this.captureImage()))}captureThumbnail(){if(!this.$ready.get())return null;const e=Ue(this,sc,"f")/Ue(this,nh,"f"),t=Ue(this,pl,"f")/Ue(this,th,"f");if(e>t){const r=Ue(this,ml,"f").height*Ue(this,th,"f")/Ue(this,nh,"f");Ue(this,G1,"f").drawImage(Ue(this,la,"f"),Ue(this,ml,"f").width/2-r/2,0,r,Ue(this,ml,"f").height)}else{const r=Ue(this,ml,"f").width*Ue(this,nh,"f")/Ue(this,th,"f");Ue(this,G1,"f").drawImage(Ue(this,la,"f"),0,Ue(this,ml,"f").height/2-r/2,Ue(this,ml,"f").width,r)}return Ue(this,ml,"f").toDataURL("image/jpeg")}captureImage(){if(!this.$ready.get())return null;const e=Ue(this,sc,"f")/Ue(this,nh,"f"),t=Ue(this,pl,"f")/Ue(this,th,"f");if(e>t){const r=Ue(this,sc,"f")*Ue(this,th,"f")/Ue(this,nh,"f");Ue(this,yb,"f").drawImage(Ue(this,la,"f"),Ue(this,pl,"f")/2-r/2,0,r,Ue(this,sc,"f"))}else{const r=Ue(this,pl,"f")*Ue(this,nh,"f")/Ue(this,th,"f");Ue(this,yb,"f").drawImage(Ue(this,la,"f"),0,Ue(this,sc,"f")/2-r/2,Ue(this,pl,"f"),r)}return Ue(this,yb,"f").getImageData(0,0,Ue(this,pl,"f"),Ue(this,sc,"f"))}}pl=new WeakMap,sc=new WeakMap,th=new WeakMap,nh=new WeakMap,la=new WeakMap,fI=new WeakMap,W1=new WeakMap,ml=new WeakMap,G1=new WeakMap,gb=new WeakMap,yb=new WeakMap,dI=new WeakMap;function nkt(...n){return new tkt(...n)}function i7(n){return typeof n=="string"}function o7(n){return Array.isArray(n)}let rkt=class{constructor(e,t=!0){this.name=e,this.showSidebar=t,this.components=[],this.componentsLeft=[]}use(...e){return this.components=this.components.concat(e),this}sidebar(...e){return this.componentsLeft=this.componentsLeft.concat(e),this}mount(){for(const e of this.components)if(o7(e))for(const t of e)t.mount();else i7(e)||e.mount();for(const e of this.componentsLeft)e.mount()}destroy(){for(const e of this.components)if(o7(e))for(const t of e)t.destroy();else i7(e)||e.destroy();for(const e of this.componentsLeft)e.destroy()}};function skt(n,e,t,r){return n instanceof RegExp?n:(n instanceof Array&&(n=`(${n.join("|")})`),n=n.concat(r?"":"/?").replace(/\/\(/g,"(?:/").replace(/\+/g,"__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g,(s,i,o,a,l,c)=>(e.push({name:a,optional:!!c}),i=i||"",`${c?"":i}(?:${c?i:""}${o||""}${l||o&&"([^/.]+?)"||"([^/]+?)"})${c||""}`)).replace(/([/.])/g,"\\$1").replace(/__plus__/g,"(.+)").replace(/\*/g,"(.*)"),new RegExp(`^${n}$`,t?"":"i"))}class ikt{constructor(e,t){this.path=e,this.name=t,this.keys=[],this.fns=[],this.params={},this.regex=skt(this.path,this.keys,!1,!1)}addHandler(e){this.fns.push(e)}removeHandler(e){this.fns=this.fns.filter(t=>e===t)}run(e){for(const t of this.fns)t.apply(this,e)}match(e,t){const r=this.regex.exec(e);if(!r)return!1;for(let s=1,i=r.length;s<i;s++){const o=this.keys[s-1],a=typeof r[s]=="string"?decodeURIComponent(r[s]):r[s];o&&(this.params[o.name]=a),t.push(a)}return!0}}function okt(n,e){const t=[];return e.match(n,t)?(e.run(t),!0):!1}class akt{constructor(){this.map={},this.routes=[],this.addListener()}route(e,t){const r=e.split(" "),s=r.length===2?r[0]:null;e=r.length===2?r[1]:r[0],Object.keys(this.map).includes(e)||(this.map[e]=new ikt(e,s),this.routes.push(this.map[e])),this.map[e].addHandler(t),this.reload()}addListener(){window.addEventListener("hashchange",this.reload.bind(this),!1)}removeListener(){window.removeEventListener("hashchange",this.reload.bind(this))}reload(){const e=window.location.hash.substring(1);for(let t=0;t<this.routes.length;t++){const r=this.routes[t];if(okt(e,r))return}}navigate(e,{silent:t=!1}={}){t&&this.removeListener(),setTimeout(()=>{window.location.hash=e,t&&setTimeout(()=>{this.addListener()},1)},1)}}function a7(n,e,t){const r=n.slice();return r[1]=e[t],r}function l7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function c7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function u7(n){let e,t,r=n[0].showSidebar&&h7(n),s=n[0].components,i=[];for(let o=0;o<s.length;o+=1)i[o]=p7(a7(n,s,o));return{c(){r&&r.c(),e=st(),t=Ce("div");for(let o=0;o<i.length;o+=1)i[o].c();te(t,"class","right svelte-15dyumc"),Gt(t,"fullw",!n[0].showSidebar)},m(o,a){r&&r.m(o,a),be(o,e,a),be(o,t,a);for(let l=0;l<i.length;l+=1)i[l]&&i[l].m(t,null)},p(o,a){if(o[0].showSidebar?r?r.p(o,a):(r=h7(o),r.c(),r.m(e.parentNode,e)):r&&(r.d(1),r=null),a&1){s=o[0].components;let l;for(l=0;l<s.length;l+=1){const c=a7(o,s,l);i[l]?i[l].p(c,a):(i[l]=p7(c),i[l].c(),i[l].m(t,null))}for(;l<i.length;l+=1)i[l].d(1);i.length=s.length}a&1&&Gt(t,"fullw",!o[0].showSidebar)},d(o){r&&r.d(o),o&&ye(e),o&&ye(t),Vi(i,o)}}}function h7(n){let e,t=n[0].componentsLeft,r=[];for(let s=0;s<t.length;s+=1)r[s]=f7(c7(n,t,s));return{c(){e=Ce("div");for(let s=0;s<r.length;s+=1)r[s].c();te(e,"class","left svelte-15dyumc")},m(s,i){be(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(s,i){if(i&1){t=s[0].componentsLeft;let o;for(o=0;o<t.length;o+=1){const a=c7(s,t,o);r[o]?r[o].p(a,i):(r[o]=f7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(s){s&&ye(e),Vi(r,s)}}}function f7(n){let e,t;return{c(){e=Ce("div"),te(e,"id",t=n[4]),te(e,"class","card")},m(r,s){be(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&te(e,"id",t)},d(r){r&&ye(e)}}}function lkt(n){let e,t;return{c(){e=Ce("div"),te(e,"id",t=n[1].id),te(e,"class","card")},m(r,s){be(r,e,s)},p(r,s){s&1&&t!==(t=r[1].id)&&te(e,"id",t)},d(r){r&&ye(e)}}}function ckt(n){let e,t=n[1]+"",r;return{c(){e=Ce("h2"),r=Qe(t),te(e,"class","svelte-15dyumc")},m(s,i){be(s,e,i),ue(e,r)},p(s,i){i&1&&t!==(t=s[1]+"")&&dn(r,t)},d(s){s&&ye(e)}}}function ukt(n){let e,t,r=n[1],s=[];for(let i=0;i<r.length;i+=1)s[i]=d7(l7(n,r,i));return{c(){e=Ce("div");for(let i=0;i<s.length;i+=1)s[i].c();t=st(),te(e,"class","flex flex-row flex-wrap items-stretch")},m(i,o){be(i,e,o);for(let a=0;a<s.length;a+=1)s[a]&&s[a].m(e,null);ue(e,t)},p(i,o){if(o&1){r=i[1];let a;for(a=0;a<r.length;a+=1){const l=l7(i,r,a);s[a]?s[a].p(l,o):(s[a]=d7(l),s[a].c(),s[a].m(e,t))}for(;a<s.length;a+=1)s[a].d(1);s.length=r.length}},d(i){i&&ye(e),Vi(s,i)}}}function d7(n){let e,t;return{c(){e=Ce("div"),te(e,"id",t=n[4]),te(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,s){be(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&te(e,"id",t)},d(r){r&&ye(e)}}}function p7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?ukt:typeof o[1]=="string"?ckt:lkt}let s=r(n,-1),i=s(n);return{c(){i.c(),t=ea()},m(o,a){i.m(o,a),be(o,t,a)},p(o,a){s===(s=r(o,a))&&i?i.p(o,a):(i.d(1),i=s(o),i&&(i.c(),i.m(t.parentNode,t)))},d(o){i.d(o),o&&ye(t)}}}function hkt(n){let e,t=n[0]&&u7(n);return{c(){t&&t.c(),e=ea()},m(r,s){t&&t.m(r,s),be(r,e,s)},p(r,[s]){r[0]?t?t.p(r,s):(t=u7(r),t.c(),t.m(e.parentNode,e)):t&&(t.d(1),t=null)},i:ot,o:ot,d(r){t&&t.d(r),r&&ye(e)}}}function fkt(n,e,t){let{dashboard:r}=e;return rce(()=>{r.mount()}),n.$$set=s=>{"dashboard"in s&&t(0,r=s.dashboard)},[r]}class dkt extends Rn{constructor(e){super(),$n(this,e,fkt,hkt,Nn,{dashboard:0})}}function pkt(n){let e;return{c(){e=Qe("This dataset is empty")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function mkt(n){let e,t,r,s=n[3]?"s":"",i,o;return{c(){e=Qe("This dataset contains "),t=Qe(n[3]),r=Qe(" instance"),i=Qe(s),o=Qe(".")},m(a,l){be(a,e,l),be(a,t,l),be(a,r,l),be(a,i,l),be(a,o,l)},p(a,l){l&8&&dn(t,a[3]),l&8&&s!==(s=a[3]?"s":"")&&dn(i,s)},d(a){a&&ye(e),a&&ye(t),a&&ye(r),a&&ye(i),a&&ye(o)}}}function m7(n){let e,t,r,s;return e=new zs({props:{$$slots:{default:[gkt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){Pt(e.$$.fragment),t=st(),r=Ce("span"),te(r,"class","w-1")},m(i,o){At(e,i,o),be(i,t,o),be(i,r,o),s=!0},p(i,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ae(e.$$.fragment,i),s=!0)},o(i){Re(e.$$.fragment,i),s=!1},d(i){Mt(e,i),i&&ye(t),i&&ye(r)}}}function gkt(n){let e;return{c(){e=Qe("Download Dataset")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function ykt(n){let e;return{c(){e=Qe("Upload Dataset")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function bkt(n){let e;return{c(){e=Qe("Clear Dataset")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function vkt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d,p,m,g;function y(_,C){return _[3]?mkt:pkt}let b=y(n),x=b(n),w=n[3]&&m7(n);return c=new zs({props:{$$slots:{default:[ykt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zs({props:{type:"danger",$$slots:{default:[bkt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=Ce("span"),r=Qe(t),s=st(),i=Ce("p"),x.c(),o=st(),a=Ce("div"),w&&w.c(),l=st(),Pt(c.$$.fragment),u=st(),h=Ce("span"),f=st(),d=Ce("input"),p=st(),Pt(m.$$.fragment),te(e,"class","card-title"),te(i,"class","pb-2"),te(h,"class","w-1"),te(d,"type","file"),d.multiple=!0,te(d,"class","hidden"),te(a,"class","flex")},m(_,C){be(_,e,C),ue(e,r),be(_,s,C),be(_,i,C),x.m(i,null),be(_,o,C),be(_,a,C),w&&w.m(a,null),ue(a,l),At(c,a,null),ue(a,u),ue(a,h),ue(a,f),ue(a,d),n[7](d),ue(a,p),At(m,a,null),g=!0},p(_,[C]){(!g||C&1)&&t!==(t=_[0].title+"")&&dn(r,t),b===(b=y(_))&&x?x.p(_,C):(x.d(1),x=b(_),x&&(x.c(),x.m(i,null))),_[3]?w?(w.p(_,C),C&8&&Ae(w,1)):(w=m7(_),w.c(),Ae(w,1),w.m(a,l)):w&&(yr(),Re(w,1,1,()=>{w=null}),br());const k={};C&256&&(k.$$scope={dirty:C,ctx:_}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:_}),m.$set(A)},i(_){g||(Ae(w),Ae(c.$$.fragment,_),Ae(m.$$.fragment,_),g=!0)},o(_){Re(w),Re(c.$$.fragment,_),Re(m.$$.fragment,_),g=!1},d(_){_&&ye(e),_&&ye(s),_&&ye(i),x.d(),_&&ye(o),_&&ye(a),w&&w.d(),Mt(c),n[7](null),Mt(m)}}}function wkt(n,e,t){let r,s,i=ot,o=()=>(i(),i=es(r,d=>t(3,s=d)),r);n.$$.on_destroy.push(()=>i());let{dataset:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}$h(async()=>{await Ka(),await Ka(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){So[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"dataset"in d&&t(0,a=d.dataset)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,s,c,u,h,f]}class xkt extends Rn{constructor(e){super(),$n(this,e,wkt,vkt,Nn,{dataset:0})}}function g7(n){let e,t,r,s={ctx:n,current:null,token:null,hasCatch:!1,pending:kkt,then:_kt,catch:Skt,value:4,blocks:[,,,]};return Lq(t=n[0].connect(),s),{c(){e=ea(),s.block.c()},m(i,o){be(i,e,o),s.block.m(i,s.anchor=o),s.mount=()=>e.parentNode,s.anchor=e,r=!0},p(i,o){n=i,s.ctx=n,o&1&&t!==(t=n[0].connect())&&Lq(t,s)||pxt(s,n,o)},i(i){r||(Ae(s.block),r=!0)},o(i){for(let o=0;o<3;o+=1){const a=s.blocks[o];Re(a)}r=!1},d(i){i&&ye(e),s.block.d(i),s.token=null,s=null}}}function Skt(n){return{c:ot,m:ot,p:ot,i:ot,o:ot,d:ot}}function _kt(n){let e,t,r=n[4].email+"",s,i,o,a,l;return a=new zs({props:{$$slots:{default:[Ckt]},$$scope:{ctx:n}}}),a.$on("click",n[3]),{c(){e=Ce("p"),t=Qe("Hello, "),s=Qe(r),i=st(),o=Ce("div"),Pt(a.$$.fragment),te(e,"class","pb-2"),te(o,"class","flex")},m(c,u){be(c,e,u),ue(e,t),ue(e,s),be(c,i,u),be(c,o,u),At(a,o,null),l=!0},p(c,u){(!l||u&1)&&r!==(r=c[4].email+"")&&dn(s,r);const h={};u&32&&(h.$$scope={dirty:u,ctx:c}),a.$set(h)},i(c){l||(Ae(a.$$.fragment,c),l=!0)},o(c){Re(a.$$.fragment,c),l=!1},d(c){c&&ye(e),c&&ye(i),c&&ye(o),Mt(a)}}}function Ckt(n){let e;return{c(){e=Qe("Log out")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function kkt(n){let e,t;return e=new LV({}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p:ot,i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function y7(n){let e,t,r=n[2].join(", ")+"",s;return{c(){e=Ce("div"),t=Qe("This data store contains the following services: "),s=Qe(r)},m(i,o){be(i,e,o),ue(e,t),ue(e,s)},p(i,o){o&4&&r!==(r=i[2].join(", ")+"")&&dn(s,r)},d(i){i&&ye(e)}}}function Tkt(n){let e,t,r,s=n[0].requiresAuth&&g7(n),i=n[2]&&y7(n);return{c(){s&&s.c(),e=st(),i&&i.c(),t=ea()},m(o,a){s&&s.m(o,a),be(o,e,a),i&&i.m(o,a),be(o,t,a),r=!0},p(o,a){o[0].requiresAuth?s?(s.p(o,a),a&1&&Ae(s,1)):(s=g7(o),s.c(),Ae(s,1),s.m(e.parentNode,e)):s&&(yr(),Re(s,1,1,()=>{s=null}),br()),o[2]?i?i.p(o,a):(i=y7(o),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i(o){r||(Ae(s),r=!0)},o(o){Re(s),r=!1},d(o){s&&s.d(o),o&&ye(e),i&&i.d(o),o&&ye(t)}}}function Ekt(n){let e,t;return e=new rl({props:{title:"data store ("+n[0].location+")",$$slots:{default:[Tkt]},$$scope:{ctx:n}}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title="data store ("+r[0].location+")"),s&37&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function Ikt(n,e,t){let r,s,i=ot,o=()=>(i(),i=es(r,c=>t(2,s=c)),r);n.$$.on_destroy.push(()=>i());let{dataStore:a}=e;function l(){a.logout()}return n.$$set=c=>{"dataStore"in c&&t(0,a=c.dataStore)},n.$$.update=()=>{n.$$.dirty&1&&o(t(1,r=a.$services))},[a,r,s,l]}class Akt extends Rn{constructor(e){super(),$n(this,e,Ikt,Ekt,Nn,{dataStore:0})}}function Mkt(n){let e;return{c(){e=Qe("Download Model")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function Nkt(n){let e;return{c(){e=Qe("Upload Model")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function $kt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d;return o=new zs({props:{$$slots:{default:[Mkt]},$$scope:{ctx:n}}}),o.$on("click",n[2]),f=new zs({props:{$$slots:{default:[Nkt]},$$scope:{ctx:n}}}),f.$on("click",n[3]),{c(){e=Ce("span"),r=Qe(t),s=st(),i=Ce("div"),Pt(o.$$.fragment),a=st(),l=Ce("span"),c=st(),u=Ce("input"),h=st(),Pt(f.$$.fragment),te(e,"class","card-title"),te(l,"class","w-1"),te(u,"type","file"),u.multiple=!0,te(u,"class","hidden"),te(i,"class","flex")},m(p,m){be(p,e,m),ue(e,r),be(p,s,m),be(p,i,m),At(o,i,null),ue(i,a),ue(i,l),ue(i,c),ue(i,u),n[4](u),ue(i,h),At(f,i,null),d=!0},p(p,[m]){(!d||m&1)&&t!==(t=p[0].title+"")&&dn(r,t);const g={};m&32&&(g.$$scope={dirty:m,ctx:p}),o.$set(g);const y={};m&32&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(Ae(o.$$.fragment,p),Ae(f.$$.fragment,p),d=!0)},o(p){Re(o.$$.fragment,p),Re(f.$$.fragment,p),d=!1},d(p){p&&ye(e),p&&ye(s),p&&ye(i),Mt(o),n[4](null),Mt(f)}}}function eD(n){return"download"in n}function Rkt(n,e,t){let{model:r}=e,s;function i(){eD(r)?r.download():Ya(new Error("This model cannot be saved"))}function o(){eD(r)?s==null||s.click():Ya(new Error("This model cannot be uploaded"))}$h(async()=>{await Ka(),await Ka(),s.addEventListener("change",l=>{const c=l.target.files,u=[];for(let h=0;h<c.length;h++)u.push(c[h]);eD(r)&&r.upload(...u)})});function a(l){So[l?"unshift":"push"](()=>{s=l,t(1,s)})}return n.$$set=l=>{"model"in l&&t(0,r=l.model)},[r,s,i,o,a]}class Pkt extends Rn{constructor(e){super(),$n(this,e,Rkt,$kt,Nn,{model:0})}}function Dkt(n){let e;return{c(){e=Qe("This batch prediction component is empty")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function Okt(n){let e,t,r,s=n[3]?"s":"",i;return{c(){e=Qe(`This batch prediction component contains
    `),t=Qe(n[3]),r=Qe(`
    prediction`),i=Qe(s)},m(o,a){be(o,e,a),be(o,t,a),be(o,r,a),be(o,i,a)},p(o,a){a&8&&dn(t,o[3]),a&8&&s!==(s=o[3]?"s":"")&&dn(i,s)},d(o){o&&ye(e),o&&ye(t),o&&ye(r),o&&ye(i)}}}function b7(n){let e,t,r,s;return e=new zs({props:{$$slots:{default:[Fkt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){Pt(e.$$.fragment),t=st(),r=Ce("span"),te(r,"class","w-1")},m(i,o){At(e,i,o),be(i,t,o),be(i,r,o),s=!0},p(i,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ae(e.$$.fragment,i),s=!0)},o(i){Re(e.$$.fragment,i),s=!1},d(i){Mt(e,i),i&&ye(t),i&&ye(r)}}}function Fkt(n){let e;return{c(){e=Qe("Download Predictions")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function Lkt(n){let e;return{c(){e=Qe("Upload Predictions")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function zkt(n){let e;return{c(){e=Qe("Clear Predictions")},m(t,r){be(t,e,r)},d(t){t&&ye(e)}}}function Bkt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d,p,m,g;function y(_,C){return _[3]?Okt:Dkt}let b=y(n),x=b(n),w=n[3]&&b7(n);return c=new zs({props:{$$slots:{default:[Lkt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zs({props:{type:"danger",$$slots:{default:[zkt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=Ce("span"),r=Qe(t),s=st(),i=Ce("p"),x.c(),o=st(),a=Ce("div"),w&&w.c(),l=st(),Pt(c.$$.fragment),u=st(),h=Ce("span"),f=st(),d=Ce("input"),p=st(),Pt(m.$$.fragment),te(e,"class","card-title"),te(i,"class","pb-2"),te(h,"class","w-1"),te(d,"type","file"),d.multiple=!0,te(d,"class","hidden"),te(a,"class","flex")},m(_,C){be(_,e,C),ue(e,r),be(_,s,C),be(_,i,C),x.m(i,null),be(_,o,C),be(_,a,C),w&&w.m(a,null),ue(a,l),At(c,a,null),ue(a,u),ue(a,h),ue(a,f),ue(a,d),n[7](d),ue(a,p),At(m,a,null),g=!0},p(_,[C]){(!g||C&1)&&t!==(t=_[0].title+"")&&dn(r,t),b===(b=y(_))&&x?x.p(_,C):(x.d(1),x=b(_),x&&(x.c(),x.m(i,null))),_[3]?w?(w.p(_,C),C&8&&Ae(w,1)):(w=b7(_),w.c(),Ae(w,1),w.m(a,l)):w&&(yr(),Re(w,1,1,()=>{w=null}),br());const k={};C&256&&(k.$$scope={dirty:C,ctx:_}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:_}),m.$set(A)},i(_){g||(Ae(w),Ae(c.$$.fragment,_),Ae(m.$$.fragment,_),g=!0)},o(_){Re(w),Re(c.$$.fragment,_),Re(m.$$.fragment,_),g=!1},d(_){_&&ye(e),_&&ye(s),_&&ye(i),x.d(),_&&ye(o),_&&ye(a),w&&w.d(),Mt(c),n[7](null),Mt(m)}}}function Vkt(n,e,t){let r,s,i=ot,o=()=>(i(),i=es(r,d=>t(3,s=d)),r);n.$$.on_destroy.push(()=>i());let{prediction:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}$h(async()=>{await Ka(),await Ka(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){So[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"prediction"in d&&t(0,a=d.prediction)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,s,c,u,h,f]}class Ukt extends Rn{constructor(e){super(),$n(this,e,Vkt,Bkt,Nn,{prediction:0})}}function v7(n,e,t){const r=n.slice();return r[1]=e[t],r}function w7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function x7(n,e,t){const r=n.slice();return r[7]=e[t],r}function S7(n,e,t){const r=n.slice();return r[10]=e[t],r}function _7(n,e,t){const r=n.slice();return r[13]=e[t],r}function C7(n,e,t){const r=n.slice();return r[16]=e[t],r}function k7(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g=n[0].xDataStores,y=[];for(let D=0;D<g.length;D+=1)y[D]=T7(C7(n,g,D));const b=D=>Re(y[D],1,1,()=>{y[D]=null});let x=n[0].xModels,w=[];for(let D=0;D<x.length;D+=1)w[D]=E7(_7(n,x,D));const _=D=>Re(w[D],1,1,()=>{w[D]=null});let C=n[0].xDatasets,k=[];for(let D=0;D<C.length;D+=1)k[D]=I7(S7(n,C,D));const A=D=>Re(k[D],1,1,()=>{k[D]=null});let M=n[0].xPredictions,I=[];for(let D=0;D<M.length;D+=1)I[D]=A7(x7(n,M,D));const N=D=>Re(I[D],1,1,()=>{I[D]=null});let O=n[0].components,R=[];for(let D=0;D<O.length;D+=1)R[D]=N7(v7(n,O,D));return{c(){e=Ce("div"),t=Ce("h2"),t.textContent="Data Stores",r=st();for(let D=0;D<y.length;D+=1)y[D].c();s=st(),i=Ce("h2"),i.textContent="Models",o=st();for(let D=0;D<w.length;D+=1)w[D].c();a=st(),l=Ce("h2"),l.textContent="Datasets",c=st();for(let D=0;D<k.length;D+=1)k[D].c();u=st(),h=Ce("h2"),h.textContent="Predictions",f=st();for(let D=0;D<I.length;D+=1)I[D].c();d=st(),p=Ce("div");for(let D=0;D<R.length;D+=1)R[D].c();te(e,"class","left svelte-inuorr"),te(p,"class","right svelte-inuorr")},m(D,z){be(D,e,z),ue(e,t),ue(e,r);for(let B=0;B<y.length;B+=1)y[B]&&y[B].m(e,null);ue(e,s),ue(e,i),ue(e,o);for(let B=0;B<w.length;B+=1)w[B]&&w[B].m(e,null);ue(e,a),ue(e,l),ue(e,c);for(let B=0;B<k.length;B+=1)k[B]&&k[B].m(e,null);ue(e,u),ue(e,h),ue(e,f);for(let B=0;B<I.length;B+=1)I[B]&&I[B].m(e,null);be(D,d,z),be(D,p,z);for(let B=0;B<R.length;B+=1)R[B]&&R[B].m(p,null);m=!0},p(D,z){if(z&1){g=D[0].xDataStores;let B;for(B=0;B<g.length;B+=1){const X=C7(D,g,B);y[B]?(y[B].p(X,z),Ae(y[B],1)):(y[B]=T7(X),y[B].c(),Ae(y[B],1),y[B].m(e,s))}for(yr(),B=g.length;B<y.length;B+=1)b(B);br()}if(z&1){x=D[0].xModels;let B;for(B=0;B<x.length;B+=1){const X=_7(D,x,B);w[B]?(w[B].p(X,z),Ae(w[B],1)):(w[B]=E7(X),w[B].c(),Ae(w[B],1),w[B].m(e,a))}for(yr(),B=x.length;B<w.length;B+=1)_(B);br()}if(z&1){C=D[0].xDatasets;let B;for(B=0;B<C.length;B+=1){const X=S7(D,C,B);k[B]?(k[B].p(X,z),Ae(k[B],1)):(k[B]=I7(X),k[B].c(),Ae(k[B],1),k[B].m(e,u))}for(yr(),B=C.length;B<k.length;B+=1)A(B);br()}if(z&1){M=D[0].xPredictions;let B;for(B=0;B<M.length;B+=1){const X=x7(D,M,B);I[B]?(I[B].p(X,z),Ae(I[B],1)):(I[B]=A7(X),I[B].c(),Ae(I[B],1),I[B].m(e,null))}for(yr(),B=M.length;B<I.length;B+=1)N(B);br()}if(z&1){O=D[0].components;let B;for(B=0;B<O.length;B+=1){const X=v7(D,O,B);R[B]?R[B].p(X,z):(R[B]=N7(X),R[B].c(),R[B].m(p,null))}for(;B<R.length;B+=1)R[B].d(1);R.length=O.length}},i(D){if(!m){for(let z=0;z<g.length;z+=1)Ae(y[z]);for(let z=0;z<x.length;z+=1)Ae(w[z]);for(let z=0;z<C.length;z+=1)Ae(k[z]);for(let z=0;z<M.length;z+=1)Ae(I[z]);m=!0}},o(D){y=y.filter(Boolean);for(let z=0;z<y.length;z+=1)Re(y[z]);w=w.filter(Boolean);for(let z=0;z<w.length;z+=1)Re(w[z]);k=k.filter(Boolean);for(let z=0;z<k.length;z+=1)Re(k[z]);I=I.filter(Boolean);for(let z=0;z<I.length;z+=1)Re(I[z]);m=!1},d(D){D&&ye(e),Vi(y,D),Vi(w,D),Vi(k,D),Vi(I,D),D&&ye(d),D&&ye(p),Vi(R,D)}}}function T7(n){let e,t,r;return t=new Akt({props:{dataStore:n[16]}}),{c(){e=Ce("div"),Pt(t.$$.fragment),te(e,"class","card")},m(s,i){be(s,e,i),At(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.dataStore=s[16]),t.$set(o)},i(s){r||(Ae(t.$$.fragment,s),r=!0)},o(s){Re(t.$$.fragment,s),r=!1},d(s){s&&ye(e),Mt(t)}}}function E7(n){let e,t,r;return t=new Pkt({props:{model:n[13]}}),{c(){e=Ce("div"),Pt(t.$$.fragment),te(e,"class","card")},m(s,i){be(s,e,i),At(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.model=s[13]),t.$set(o)},i(s){r||(Ae(t.$$.fragment,s),r=!0)},o(s){Re(t.$$.fragment,s),r=!1},d(s){s&&ye(e),Mt(t)}}}function I7(n){let e,t,r;return t=new xkt({props:{dataset:n[10]}}),{c(){e=Ce("div"),Pt(t.$$.fragment),te(e,"class","card")},m(s,i){be(s,e,i),At(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.dataset=s[10]),t.$set(o)},i(s){r||(Ae(t.$$.fragment,s),r=!0)},o(s){Re(t.$$.fragment,s),r=!1},d(s){s&&ye(e),Mt(t)}}}function A7(n){let e,t,r,s;return t=new Ukt({props:{prediction:n[7]}}),{c(){e=Ce("div"),Pt(t.$$.fragment),r=st(),te(e,"class","card")},m(i,o){be(i,e,o),At(t,e,null),ue(e,r),s=!0},p(i,o){const a={};o&1&&(a.prediction=i[7]),t.$set(a)},i(i){s||(Ae(t.$$.fragment,i),s=!0)},o(i){Re(t.$$.fragment,i),s=!1},d(i){i&&ye(e),Mt(t)}}}function Wkt(n){let e,t;return{c(){e=Ce("div"),te(e,"id",t=n[1].id),te(e,"class","card")},m(r,s){be(r,e,s)},p(r,s){s&1&&t!==(t=r[1].id)&&te(e,"id",t)},d(r){r&&ye(e)}}}function Gkt(n){let e,t=n[1]+"",r;return{c(){e=Ce("h2"),r=Qe(t)},m(s,i){be(s,e,i),ue(e,r)},p(s,i){i&1&&t!==(t=s[1]+"")&&dn(r,t)},d(s){s&&ye(e)}}}function Hkt(n){let e,t,r=n[1],s=[];for(let i=0;i<r.length;i+=1)s[i]=M7(w7(n,r,i));return{c(){e=Ce("div");for(let i=0;i<s.length;i+=1)s[i].c();t=st(),te(e,"class","flex flex-row flex-wrap items-stretch")},m(i,o){be(i,e,o);for(let a=0;a<s.length;a+=1)s[a]&&s[a].m(e,null);ue(e,t)},p(i,o){if(o&1){r=i[1];let a;for(a=0;a<r.length;a+=1){const l=w7(i,r,a);s[a]?s[a].p(l,o):(s[a]=M7(l),s[a].c(),s[a].m(e,t))}for(;a<s.length;a+=1)s[a].d(1);s.length=r.length}},d(i){i&&ye(e),Vi(s,i)}}}function M7(n){let e,t;return{c(){e=Ce("div"),te(e,"id",t=n[4]),te(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,s){be(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&te(e,"id",t)},d(r){r&&ye(e)}}}function N7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?Hkt:typeof o[1]=="string"?Gkt:Wkt}let s=r(n,-1),i=s(n);return{c(){i.c(),t=ea()},m(o,a){i.m(o,a),be(o,t,a)},p(o,a){s===(s=r(o,a))&&i?i.p(o,a):(i.d(1),i=s(o),i&&(i.c(),i.m(t.parentNode,t)))},d(o){i.d(o),o&&ye(t)}}}function jkt(n){let e,t,r=n[0]&&k7(n);return{c(){r&&r.c(),e=ea()},m(s,i){r&&r.m(s,i),be(s,e,i),t=!0},p(s,[i]){s[0]?r?(r.p(s,i),i&1&&Ae(r,1)):(r=k7(s),r.c(),Ae(r,1),r.m(e.parentNode,e)):r&&(yr(),Re(r,1,1,()=>{r=null}),br())},i(s){t||(Ae(r),t=!0)},o(s){Re(r),t=!1},d(s){r&&r.d(s),s&&ye(e)}}}function qkt(n,e,t){let{settings:r}=e;return rce(()=>{r.mount()}),n.$$set=s=>{"settings"in s&&t(0,r=s.settings)},[r]}let Xkt=class extends Rn{constructor(e){super(),$n(this,e,qkt,jkt,Nn,{settings:0})}};function $7(n,e,t){const r=n.slice();return r[8]=e[t][0],r[9]=e[t][1],r[11]=t,r}function R7(n){let e,t=n[9]+"",r,s,i;return{c(){e=Ce("a"),r=Qe(t),s=st(),te(e,"href",i=`#${n[8]}`),te(e,"class","ml-2 mr-5 flex items-center hover:text-black border-solid border-0 border-b-2 border-transparent svelte-1ut593v"),Gt(e,"active",!n[4]&&n[2]===n[9])},m(o,a){be(o,e,a),ue(e,r),ue(e,s)},p(o,a){a&2&&t!==(t=o[9]+"")&&dn(r,t),a&2&&i!==(i=`#${o[8]}`)&&te(e,"href",i),a&22&&Gt(e,"active",!o[4]&&o[2]===o[9])},d(o){o&&ye(e)}}}function Kkt(n){let e,t,r;return{c(){e=vs("svg"),t=vs("circle"),r=vs("path"),te(t,"cx","12"),te(t,"cy","12"),te(t,"r","3"),te(r,"d","M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"width","24"),te(e,"height","24"),te(e,"viewBox","0 0 24 24"),te(e,"fill","none"),te(e,"stroke","currentColor"),te(e,"stroke-width","2"),te(e,"stroke-linecap","round"),te(e,"stroke-linejoin","round"),te(e,"class","feather feather-settings")},m(s,i){be(s,e,i),ue(e,t),ue(e,r)},p:ot,d(s){s&&ye(e)}}}function P7(n){let e,t,r,s;return e=new zs({props:{round:!0,type:"danger",$$slots:{default:[Ykt]},$$scope:{ctx:n}}}),e.$on("click",n[5]),{c(){Pt(e.$$.fragment),t=st(),r=Ce("span"),te(r,"class","w-1")},m(i,o){At(e,i,o),be(i,t,o),be(i,r,o),s=!0},p(i,o){const a={};o&4096&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ae(e.$$.fragment,i),s=!0)},o(i){Re(e.$$.fragment,i),s=!1},d(i){Mt(e,i),i&&ye(t),i&&ye(r)}}}function Ykt(n){let e,t,r;return{c(){e=vs("svg"),t=vs("path"),r=vs("line"),te(t,"d","M18.36 6.64a9 9 0 1 1-12.73 0"),te(r,"x1","12"),te(r,"y1","2"),te(r,"x2","12"),te(r,"y2","12"),te(e,"xmlns","http://www.w3.org/2000/svg"),te(e,"width","24"),te(e,"height","24"),te(e,"viewBox","0 0 24 24"),te(e,"fill","none"),te(e,"stroke","currentColor"),te(e,"stroke-width","2"),te(e,"stroke-linecap","round"),te(e,"stroke-linejoin","round"),te(e,"class","feather feather-power")},m(s,i){be(s,e,i),ue(e,t),ue(e,r)},p:ot,d(s){s&&ye(e)}}}function Zkt(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m=Object.entries(n[1]),g=[];for(let b=0;b<m.length;b+=1)g[b]=R7($7(n,m,b));u=new zs({props:{round:!0,$$slots:{default:[Kkt]},$$scope:{ctx:n}}}),u.$on("click",n[6]);let y=n[3]&&P7(n);return{c(){e=Ce("header"),t=Ce("div"),r=Ce("a"),s=Ce("span"),i=Qe(n[0]),o=st(),a=Ce("nav");for(let b=0;b<g.length;b+=1)g[b].c();l=st(),c=Ce("div"),Pt(u.$$.fragment),h=st(),f=Ce("span"),d=st(),y&&y.c(),te(s,"class","mx-3 text-lg"),te(r,"href","#/"),te(r,"class","flex p-3 title-font font-medium items-center text-gray-900 mb-4 md:mb-0 border-solid border-0 border-r border-gray-200 svelte-1ut593v"),te(a,"class","flex items-stretch justify-start flex-wrap text-base grow mx-4"),te(f,"class","w-1"),te(c,"class","flex items-center"),te(t,"class","mx-auto flex flex-wrap flex-col md:flex-row items-stretch w-full"),te(e,"class","bg-white text-gray-700 body-font")},m(b,x){be(b,e,x),ue(e,t),ue(t,r),ue(r,s),ue(s,i),ue(t,o),ue(t,a);for(let w=0;w<g.length;w+=1)g[w]&&g[w].m(a,null);ue(t,l),ue(t,c),At(u,c,null),ue(c,h),ue(c,f),ue(c,d),y&&y.m(c,null),p=!0},p(b,[x]){if((!p||x&1)&&dn(i,b[0]),x&22){m=Object.entries(b[1]);let _;for(_=0;_<m.length;_+=1){const C=$7(b,m,_);g[_]?g[_].p(C,x):(g[_]=R7(C),g[_].c(),g[_].m(a,null))}for(;_<g.length;_+=1)g[_].d(1);g.length=m.length}const w={};x&4096&&(w.$$scope={dirty:x,ctx:b}),u.$set(w),b[3]?y?(y.p(b,x),x&8&&Ae(y,1)):(y=P7(b),y.c(),Ae(y,1),y.m(c,null)):y&&(yr(),Re(y,1,1,()=>{y=null}),br())},i(b){p||(Ae(u.$$.fragment,b),Ae(y),p=!0)},o(b){Re(u.$$.fragment,b),Re(y),p=!1},d(b){b&&ye(e),Vi(g,b),Mt(u),y&&y.d()}}}function Jkt(n,e,t){let{title:r}=e,{items:s}=e,{current:i}=e,{closable:o}=e,{showSettings:a=!1}=e;const l=Fc();function c(){a?window.location.href=window.location.href.split("#")[0]+"#"+Object.keys(s)[Object.values(s).indexOf(i)]:window.location.href=window.location.href.split("#")[0]+"#settings"}function u(){setTimeout(()=>{l("quit")},400)}return n.$$set=h=>{"title"in h&&t(0,r=h.title),"items"in h&&t(1,s=h.items),"current"in h&&t(2,i=h.current),"closable"in h&&t(3,o=h.closable),"showSettings"in h&&t(4,a=h.showSettings)},[r,s,i,o,a,u,c]}class Qkt extends Rn{constructor(e){super(),$n(this,e,Jkt,Zkt,Nn,{title:0,items:1,current:2,closable:3,showSettings:4,quit:5})}get quit(){return this.$$.ctx[5]}}function eTt(n){let e;return{c(){e=Qe("")},m(t,r){be(t,e,r)},p:ot,d(t){t&&ye(e)}}}function tTt(n){let e;function t(i,o){return i[1][0]===xc.Warning?sTt:i[1][0]===xc.Error?rTt:nTt}let r=t(n),s=r(n);return{c(){s.c(),e=ea()},m(i,o){s.m(i,o),be(i,e,o)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},d(i){s.d(i),i&&ye(e)}}}function nTt(n){let e=(n[1][1]||"")+"",t;return{c(){t=Qe(e)},m(r,s){be(r,t,s)},p(r,s){s&2&&e!==(e=(r[1][1]||"")+"")&&dn(t,e)},d(r){r&&ye(t)}}}function rTt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=Qe(`Err:
        `),r=Qe(t)},m(s,i){be(s,e,i),be(s,r,i)},p(s,i){i&2&&t!==(t=(s[1][1]||"")+"")&&dn(r,t)},d(s){s&&ye(e),s&&ye(r)}}}function sTt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=Qe(`Warn:
        `),r=Qe(t)},m(s,i){be(s,e,i),be(s,r,i)},p(s,i){i&2&&t!==(t=(s[1][1]||"")+"")&&dn(r,t)},d(s){s&&ye(e),s&&ye(r)}}}function iTt(n){let e,t,r,s,i,o;function a(u,h){return u[1]?tTt:eTt}let l=a(n),c=l(n);return{c(){e=Ce("footer"),t=Ce("p"),c.c(),r=st(),s=Ce("p"),i=Qe(" 2021 "),o=Qe(n[0]),te(t,"class","console svelte-i04gf3"),Gt(t,"error",n[1]&&n[1][0]===xc.Error),Gt(t,"warning",n[1]&&n[1][0]===xc.Warning),te(s,"class","text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-gray-200"),te(e,"class","bg-white text-gray-600 border-t px-5 py-1 flex items-center justify-between flex-col sm:flex-row")},m(u,h){be(u,e,h),ue(e,t),c.m(t,null),ue(e,r),ue(e,s),ue(s,i),ue(s,o)},p(u,[h]){l===(l=a(u))&&c?c.p(u,h):(c.d(1),c=l(u),c&&(c.c(),c.m(t,null))),h&2&&Gt(t,"error",u[1]&&u[1][0]===xc.Error),h&2&&Gt(t,"warning",u[1]&&u[1][0]===xc.Warning),h&1&&dn(o,u[0])},i:ot,o:ot,d(u){u&&ye(e),c.d()}}}function oTt(n,e,t){let r,{author:s}=e;const i=z1t();return RV(n,i,o=>t(1,r=o)),n.$$set=o=>{"author"in o&&t(0,s=o.author)},[s,r,i]}class aTt extends Rn{constructor(e){super(),$n(this,e,oTt,iTt,Nn,{author:0})}}function D7(n){let e,t,r,s,i,o,a,l,c,u,h;r=new Qkt({props:{title:n[0],items:n[10].reduce(n[12],{}),current:n[9],showSettings:n[8],closable:n[4]}}),r.$on("quit",n[5]);const f=[cTt,lTt],d=[];function p(m,g){return m[8]?0:m[9]?1:-1}return~(o=p(n))&&(a=d[o]=f[o](n)),c=new aTt({props:{author:n[1]}}),{c(){e=Ce("div"),t=Ce("div"),Pt(r.$$.fragment),s=st(),i=Ce("main"),a&&a.c(),l=st(),Pt(c.$$.fragment),te(i,"class","main-container svelte-1da5cws"),te(t,"class","app-container svelte-1da5cws"),te(e,"class","marcelle fixed h-screen w-full max-w-full overflow-y-scroll overflow-x-hidden top-0 left-0 z-50")},m(m,g){be(m,e,g),ue(e,t),At(r,t,null),ue(t,s),ue(t,i),~o&&d[o].m(i,null),ue(t,l),At(c,t,null),h=!0},p(m,g){n=m;const y={};g&1&&(y.title=n[0]),g&1088&&(y.items=n[10].reduce(n[12],{})),g&512&&(y.current=n[9]),g&256&&(y.showSettings=n[8]),g&16&&(y.closable=n[4]),r.$set(y);let b=o;o=p(n),o===b?~o&&d[o].p(n,g):(a&&(yr(),Re(d[b],1,1,()=>{d[b]=null}),br()),~o?(a=d[o],a?a.p(n,g):(a=d[o]=f[o](n),a.c()),Ae(a,1),a.m(i,null)):a=null);const x={};g&2&&(x.author=n[1]),c.$set(x)},i(m){h||(Ae(r.$$.fragment,m),Ae(a),Ae(c.$$.fragment,m),Pc(()=>{h&&(u||(u=xv(t,cM,{amount:10,duration:n[4]?400:0},!0)),u.run(1))}),h=!0)},o(m){Re(r.$$.fragment,m),Re(a),Re(c.$$.fragment,m),u||(u=xv(t,cM,{amount:10,duration:n[4]?400:0},!1)),u.run(0),h=!1},d(m){m&&ye(e),Mt(r),~o&&d[o].d(),Mt(c),m&&u&&u.end()}}}function lTt(n){let e,t;return e=new dkt({props:{dashboard:n[2][n[9]]}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&516&&(i.dashboard=r[2][r[9]]),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function cTt(n){let e,t;return e=new Xkt({props:{settings:n[3]}}),{c(){Pt(e.$$.fragment)},m(r,s){At(e,r,s),t=!0},p(r,s){const i={};s&8&&(i.settings=r[3]),e.$set(i)},i(r){t||(Ae(e.$$.fragment,r),t=!0)},o(r){Re(e.$$.fragment,r),t=!1},d(r){Mt(e,r)}}}function uTt(n){let e,t,r,s;document.title=e=n[0];let i=n[7]&&D7(n);return{c(){t=st(),i&&i.c(),r=ea()},m(o,a){be(o,t,a),i&&i.m(o,a),be(o,r,a),s=!0},p(o,[a]){(!s||a&1)&&e!==(e=o[0])&&(document.title=e),o[7]?i?(i.p(o,a),a&128&&Ae(i,1)):(i=D7(o),i.c(),Ae(i,1),i.m(r.parentNode,r)):i&&(yr(),Re(i,1,1,()=>{i=null}),br())},i(o){s||(Ae(i),s=!0)},o(o){Re(i),s=!1},d(o){o&&ye(t),i&&i.d(o),o&&ye(r)}}}function O7(n){let e=n.replace(/^\s+|\s+$/g,"");e=e.toLowerCase();const t="/_,:;",r="aaaaeeeeiiiioooouuuunc------";for(let s=0,i=t.length;s<i;s++)e=e.replace(new RegExp(t.charAt(s),"g"),r.charAt(s));return e=e.replace(/[^a-z0-9 -]/g,"").replace(/\s+/g,"-").replace(/-+/g,"-"),e}function hTt(n,e,t){let r,s;const i=Fc();let{title:o}=e,{author:a}=e,{dashboards:l={}}=e,{settings:c}=e,{page:u}=e,{closable:h}=e,f=!1;$h(()=>{t(7,f=!0)});function d(){t(7,f=!1),setTimeout(()=>{i("quit")},400)}let p=!1,m=Object.keys(l)[0]||void 0;$h(()=>{try{const y=new akt;y.route("settings",()=>{t(8,p=!0),m&&l[m].destroy(),u.set("settings")}),s.forEach((b,x)=>{y.route(b,()=>{t(8,p=!1),m!==r[x]&&(m&&l[m].destroy(),t(9,m=r[x]),u.set(b===""?O7(r[0]):b))})})}catch(y){console.log("Could not enable router",y)}});const g=(y,b,x)=>({...y,[b]:r[x]});return n.$$set=y=>{"title"in y&&t(0,o=y.title),"author"in y&&t(1,a=y.author),"dashboards"in y&&t(2,l=y.dashboards),"settings"in y&&t(3,c=y.settings),"page"in y&&t(11,u=y.page),"closable"in y&&t(4,h=y.closable)},n.$$.update=()=>{n.$$.dirty&4&&t(6,r=Object.keys(l)),n.$$.dirty&64&&t(10,s=[""].concat(r.slice(1).map(O7)))},[o,a,l,c,h,d,r,f,p,m,s,u,g]}let fTt=class extends Rn{constructor(e){super(),$n(this,e,hTt,uTt,Nn,{title:0,author:1,dashboards:2,settings:3,page:11,closable:4,quit:5})}get quit(){return this.$$.ctx[5]}};function F7(n){return typeof n=="string"}function L7(n){return Array.isArray(n)}class dTt{constructor(){this.name="settings",this.components=[],this.xModels=[],this.xDatasets=[],this.xPredictions=[],this.xDataStores=[]}use(...e){return this.components=this.components.concat(e),this}dataStores(...e){return this.xDataStores=e,this}models(...e){return this.xModels=e,this}datasets(...e){return this.xDatasets=e,this}predictions(...e){return this.xPredictions=e,this}mount(){for(const e of this.components)if(L7(e))for(const t of e)t.mount();else F7(e)||e.mount()}destroy(){for(const e of this.components)if(L7(e))for(const t of e)t.destroy();else F7(e)||e.destroy()}}class pTt{constructor({title:e="Hello, Marcelle!",author:t="author",closable:r=!1}){this.panels={},this.settings=new dTt,this.$active=new gt(!1,!0),this.$page=new gt("",!0),this.title=e,this.author=t,this.closable=r}page(e,t){return Object.keys(this.panels).includes(e)||(this.panels[e]=new rkt(e,t)),this.panels[e]}show(){this.app=new fTt({target:document.body,props:{title:this.title,author:this.author,dashboards:this.panels,settings:this.settings,page:this.$page,closable:this.closable}}),this.$active.set(!0),this.app.$on("quit",()=>{var e;this.$active.set(!1),(e=this.app)===null||e===void 0||e.$destroy();for(const t of Object.values(this.panels))t.destroy();this.app=void 0})}hide(){var e;(e=this.app)===null||e===void 0||e.quit()}}function mTt(n){return new pTt(n)}const B_=nkt();B_.title="Webcam";const qV=cCt("Label");qV.title="Label";const XV=Oce("Hold to collect");XV.title="Collect images with label";const Uce=U2t(),Wce=mce("localStorage"),KV=gSt("training set",Wce),Gce=f2t(KV);Gce.title="Training set";B_.$images.filter(()=>XV.$pressed.get()).map(async n=>({x:await Uce.process(n),thumbnail:B_.$thumbnails.get(),y:qV.$value.get()})).awaitPromises().subscribe(KV.create);const YV=Oce("Train");YV.title="Train the model";const fM=D2t({layers:[64,32],epochs:15,batch:8}).sync(Wce,"mlp-dashboard");YV.$click.subscribe(()=>fM.train(KV));const Hce=$_t(fM);Hce.title="Training progress";const gTt=B_.$images.filter(()=>fM.ready).map(async n=>fM.predict(await Uce.process(n))).awaitPromises(),jce=r2t(gTt);jce.title="Prediction confidence";const qce=mTt({title:"AICA project course",author:"To Sanchez"});qce.page("Train your first ML model").sidebar(B_,qV,XV).use(Gce,[YV,Hce],jce);qce.show();
