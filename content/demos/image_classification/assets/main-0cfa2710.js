var Fge=Object.defineProperty;var Lge=(n,e,t)=>e in n?Fge(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var Mt=(n,e,t)=>(Lge(n,typeof e!="symbol"?e+"":e,t),t);function zge(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const i=Object.getOwnPropertyDescriptor(r,s);i&&Object.defineProperty(n,s,i.get?i:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bge=1e-7,Vge=1e-4;class yM{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}let WS=class{refCount(e){return Fa("refCount")}incRef(e){return Fa("incRef")}timerAvailable(){return!0}time(e){return Fa("time")}read(e){return Fa("read")}readSync(e){return Fa("readSync")}readToGPU(e,t){return Fa("readToGPU")}numDataIds(){return Fa("numDataIds")}disposeData(e,t){return Fa("disposeData")}write(e,t,r){return Fa("write")}move(e,t,r,s,i){return Fa("move")}createTensorFromGPUData(e,t,r){return Fa("createTensorFromGPUData")}memory(){return Fa("memory")}floatPrecision(){return Fa("floatPrecision")}epsilon(){return this.floatPrecision()===32?Bge:Vge}dispose(){return Fa("dispose")}};function Fa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _L(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,xf(n,e,t)}function Uge(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,xf(n,t,r),xf(e,t,r)}function ep(n,e,t){return Math.max(n,Math.min(e,t))}function bM(n){return n%2===0?n:n+1}function xf(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function SL(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function Wge(n,e){const t=Math.random();return e*t+(1-t)*n}function Gge(n,e){let t=0;for(let r=0;r<n.length;r++){const s=Number(n[r])-Number(e[r]);t+=s*s}return t}function U(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function qi(n,e,t=""){U(Rn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Pg(n){U(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Te(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function sD(n){return n.length===0}function Q7(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function Rn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function tg(n){return n%1===0}function Hge(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function vI(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function jge(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return _L(e),e}function Hm(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function iD(n,e=s=>0,t,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n()){s();return}o++;const l=e(o);if(t!=null&&o>=t){i();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function vM(n,e){let t=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function An(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),U(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),U(n.every(r=>tg(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Lf(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:An(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function ci(n,e){return Ss(n,e)}function Ss(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function eX(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function tX(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function wM(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function d_(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function nX(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function cu(n){return typeof n=="string"||n instanceof String}function rX(n){return typeof n=="boolean"}function wI(n){return typeof n=="number"}function Cp(n){return Array.isArray(n)?Cp(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":wI(n)?"float32":cu(n)?"string":rX(n)?"bool":"float32"}function tp(n){return!!(n&&n.constructor&&n.call&&n.apply)}function xI(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Jt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function sX(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=sX(n+l*a,o,t,r)}return s}function Cl(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return sX(0,n,e,t)}function K1(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function xM(n,e){const t=ji(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function ji(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function CL(n,e){const t=n.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return Cl(n,new Float32Array(t));if(e==="int32")return Cl(n,new Int32Array(t));if(e==="bool")return Cl(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Ja(n){n.forEach(e=>{U(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function mu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function Dg(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function np(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YW="tfjsflags";let iX=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=qge,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(np(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);YW in e&&e[YW].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=Kge(s,i)})}};function qge(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(Xge(e,r[0],r[1]),r.join("="))),e}function Xge(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Kge(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ee(){return kL}let kL=null;function Yge(n){kL=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let n3;function oX(){if(n3==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");n3=n}return n3}function Zge(){const n=oX();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function TL(n,e){const t=Zge();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const Tv="Abs",Og="Acos",Fg="Acosh",kp="Add",Ev="AddN",GS="All",HS="Any",Iv="ArgMax",Av="ArgMin",Lg="Asin",zg="Asinh",Bg="Atan",Vg="Atanh",Ug="Atan2",Mv="AvgPool",jS="AvgPoolGrad",Nv="AvgPool3D",qS="AvgPool3DGrad",$v="BatchMatMul",Rv="BatchToSpaceND",XS="Bincount",KS="BitwiseAnd",aX="BroadcastTo",YS="BroadcastArgs",Wg="Cast",Gg="Ceil",Hg="ClipByValue",ZS="Complex",Pv="ComplexAbs",Dv="Concat",Ov="Conv2D",JS="Conv2DBackpropFilter",Fv="Conv2DBackpropInput",Lv="Conv3D",QS="Conv3DBackpropFilterV2",e2="Conv3DBackpropInputV2",jg="Cos",qg="Cosh",t2="Cumprod",zv="Cumsum",n2="CropAndResize",r2="DenseBincount",s2="DepthToSpace",Bv="DepthwiseConv2dNative",i2="DepthwiseConv2dNativeBackpropFilter",o2="DepthwiseConv2dNativeBackpropInput",a2="Diag",Vv="Dilation2D",p_="Dilation2DBackpropInput",m_="Dilation2DBackpropFilter",l2="Draw",Xg="RealDiv",c2="Einsum",Kg="Elu",u2="EluGrad",Yg="Erf",Uv="Equal",Zg="Exp",Wv="ExpandDims",Jg="Expm1",h2="FFT",f2="Fill",d2="FlipLeftRight",Qg="Floor",ey="FloorDiv",Gv="FusedBatchNorm",Hv="GatherV2",p2="GatherNd",jv="Greater",ty="GreaterEqual",ny="Identity",m2="IFFT",g2="Imag",ry="IsFinite",sy="IsInf",iy="IsNan",qv="LeakyRelu",Xv="Less",Kv="LessEqual",y2="LinSpace",oy="Log",ay="Log1p",Yv="LogicalAnd",Zv="LogicalNot",Jv="LogicalOr",Jge="LogicalXor",lX="LogSoftmax",Qge="LowerBound",Qv="LRN",b2="LRNGrad",eye="MatrixBandPart",ew="Max",ly="Maximum",tw="MaxPool",v2="MaxPoolGrad",nw="MaxPool3D",w2="MaxPool3DGrad",x2="MaxPoolWithArgmax",rw="Mean",sw="Min",cy="Minimum",iw="MirrorPad",uy="Mod",_2="Multinomial",hy="Multiply",ow="Neg",aw="NotEqual",S2="NonMaxSuppressionV3",_M="NonMaxSuppressionV4",C2="NonMaxSuppressionV5",lw="OnesLike",cw="OneHot",uw="Pack",hw="PadV2",tye="Pool",fy="Pow",fw="Prelu",dw="Prod",SM="RaggedGather",CM="RaggedRange",kM="RaggedTensorToTensor",k2="Range",T2="Real",dy="Reciprocal",py="Relu",pw="Reshape",mw="ResizeNearestNeighbor",E2="ResizeNearestNeighborGrad",gw="ResizeBilinear",I2="ResizeBilinearGrad",my="Relu6",yw="Reverse",gy="Round",yy="Rsqrt",A2="ScatterNd",M2="TensorScatterUpdate",N2="SearchSorted",bw="Select",by="Selu",vw="Slice",vy="Sin",wy="Sinh",xy="Sign",_y="Sigmoid",Sy="Softplus",Cy="Sqrt",ww="Sum",xw="SpaceToBatchND",_w="SplitV",Sw="Softmax",TM="SparseFillEmptyRows",EM="SparseReshape",$2="SparseSegmentMean",R2="SparseSegmentSum",P2="SparseToDense",ky="SquaredDifference",D2="Square",O2="StaticRegexReplace",F2="StridedSlice",L2="StringNGrams",IM="StringSplit",AM="StringToHashBucketFast",Ty="Sub",Ey="Tan",Iy="Tanh",Ay="Tile",z2="TopK",B2="Transform",Vd="Transpose",MM="Unique",Cw="Unpack",kw="UnsortedSegmentSum",nye="UpperBound",Tw="ZerosLike",My="Step",g_="FromPixels",V2="RotateWithOffset",Vb="_FusedMatMul",Ub="FusedConv2D",Wb="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bl(...n){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.warn(...n)}function rye(...n){Ee().getBool("IS_TEST")||Ee().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gb=TL("kernelRegistry",()=>new Map),y_=TL("gradRegistry",()=>new Map);function b_(n,e){const t=EL(n,e);return Gb.get(t)}function oD(n){return y_.get(n)}function _I(n){const e=Gb.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function U2(n){const{kernelName:e,backendName:t}=n,r=EL(e,t);Gb.has(r)&&bl(`The kernel '${e}' for backend '${t}' is already registered`),Gb.set(r,n)}function cX(n){const{kernelName:e}=n;y_.has(e)&&Ee().getBool("DEBUG")&&bl(`Overriding the gradient for '${e}'`),y_.set(e,n)}function sye(n,e){const t=EL(n,e);if(!Gb.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);Gb.delete(t)}function iye(n){if(!y_.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);y_.delete(n)}function oye(n,e){_I(n).forEach(r=>{const s=Object.assign({},r,{backendName:e});U2(s)})}function EL(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var pt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Tp(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function zf(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}var hX=as,cc=null;try{cc=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function as(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}as.prototype.__isLong__;Object.defineProperty(as.prototype,"__isLong__",{value:!0});function Qa(n){return(n&&n.__isLong__)===!0}as.isLong=Qa;var ZW={},JW={};function Ny(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=JW[n],r)?r:(t=ls(n,(n|0)<0?-1:0,!0),s&&(JW[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=ZW[n],r)?r:(t=ls(n,n<0?-1:0,!1),s&&(ZW[n]=t),t))}as.fromInt=Ny;function uc(n,e){if(isNaN(n))return e?Fm:hc;if(e){if(n<0)return Fm;if(n>=fX)return mX}else{if(n<=-eG)return Ga;if(n+1>=eG)return pX}return n<0?uc(-n,e).neg():ls(n%Hb|0,n/Hb|0,e)}as.fromNumber=uc;function ls(n,e,t){return new as(n,e,t)}as.fromBits=ls;var SI=Math.pow;function IL(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return hc;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return IL(n.substring(1),e,t).neg();for(var s=uc(SI(t,8)),i=hc,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=uc(SI(t,a));i=i.mul(c).add(uc(l))}else i=i.mul(s),i=i.add(uc(l))}return i.unsigned=e,i}as.fromString=IL;function Pu(n,e){return typeof n=="number"?uc(n,e):typeof n=="string"?IL(n,e):ls(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}as.fromValue=Pu;var QW=65536,aye=1<<24,Hb=QW*QW,fX=Hb*Hb,eG=fX/2,tG=Ny(aye),hc=Ny(0);as.ZERO=hc;var Fm=Ny(0,!0);as.UZERO=Fm;var wb=Ny(1);as.ONE=wb;var dX=Ny(1,!0);as.UONE=dX;var aD=Ny(-1);as.NEG_ONE=aD;var pX=ls(-1,2147483647,!1);as.MAX_VALUE=pX;var mX=ls(-1,-1,!0);as.MAX_UNSIGNED_VALUE=mX;var Ga=ls(0,-2147483648,!1);as.MIN_VALUE=Ga;var Nt=as.prototype;Nt.toInt=function(){return this.unsigned?this.low>>>0:this.low};Nt.toNumber=function(){return this.unsigned?(this.high>>>0)*Hb+(this.low>>>0):this.high*Hb+(this.low>>>0)};Nt.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ga)){var t=uc(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=uc(SI(e,6),this.unsigned),o=this,a="";;){var l=o.div(i),c=o.sub(l.mul(i)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};Nt.getHighBits=function(){return this.high};Nt.getHighBitsUnsigned=function(){return this.high>>>0};Nt.getLowBits=function(){return this.low};Nt.getLowBitsUnsigned=function(){return this.low>>>0};Nt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ga)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Nt.isZero=function(){return this.high===0&&this.low===0};Nt.eqz=Nt.isZero;Nt.isNegative=function(){return!this.unsigned&&this.high<0};Nt.isPositive=function(){return this.unsigned||this.high>=0};Nt.isOdd=function(){return(this.low&1)===1};Nt.isEven=function(){return(this.low&1)===0};Nt.equals=function(e){return Qa(e)||(e=Pu(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Nt.eq=Nt.equals;Nt.notEquals=function(e){return!this.eq(e)};Nt.neq=Nt.notEquals;Nt.ne=Nt.notEquals;Nt.lessThan=function(e){return this.comp(e)<0};Nt.lt=Nt.lessThan;Nt.lessThanOrEqual=function(e){return this.comp(e)<=0};Nt.lte=Nt.lessThanOrEqual;Nt.le=Nt.lessThanOrEqual;Nt.greaterThan=function(e){return this.comp(e)>0};Nt.gt=Nt.greaterThan;Nt.greaterThanOrEqual=function(e){return this.comp(e)>=0};Nt.gte=Nt.greaterThanOrEqual;Nt.ge=Nt.greaterThanOrEqual;Nt.compare=function(e){if(Qa(e)||(e=Pu(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Nt.comp=Nt.compare;Nt.negate=function(){return!this.unsigned&&this.eq(Ga)?Ga:this.not().add(wb)};Nt.neg=Nt.negate;Nt.add=function(e){Qa(e)||(e=Pu(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,i=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,f=0,d=0;return d+=i+c,f+=d>>>16,d&=65535,f+=s+l,h+=f>>>16,f&=65535,h+=r+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,ls(f<<16|d,u<<16|h,this.unsigned)};Nt.subtract=function(e){return Qa(e)||(e=Pu(e)),this.add(e.neg())};Nt.sub=Nt.subtract;Nt.multiply=function(e){if(this.isZero())return hc;if(Qa(e)||(e=Pu(e)),cc){var t=cc.mul(this.low,this.high,e.low,e.high);return ls(t,cc.get_high(),this.unsigned)}if(e.isZero())return hc;if(this.eq(Ga))return e.isOdd()?Ga:hc;if(e.eq(Ga))return this.isOdd()?Ga:hc;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(tG)&&e.lt(tG))return uc(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,i=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,f=0,d=0,p=0;return p+=o*u,d+=p>>>16,p&=65535,d+=i*u,f+=d>>>16,d&=65535,d+=o*c,f+=d>>>16,d&=65535,f+=s*u,h+=f>>>16,f&=65535,f+=i*c,h+=f>>>16,f&=65535,f+=o*l,h+=f>>>16,f&=65535,h+=r*u+s*c+i*l+o*a,h&=65535,ls(d<<16|p,h<<16|f,this.unsigned)};Nt.mul=Nt.multiply;Nt.divide=function(e){if(Qa(e)||(e=Pu(e)),e.isZero())throw Error("division by zero");if(cc){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?cc.div_u:cc.div_s)(this.low,this.high,e.low,e.high);return ls(t,cc.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Fm:hc;var r,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Fm;if(e.gt(this.shru(1)))return dX;i=Fm}else{if(this.eq(Ga)){if(e.eq(wb)||e.eq(aD))return Ga;if(e.eq(Ga))return wb;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(hc)?e.isNegative()?wb:aD:(s=this.sub(e.mul(r)),i=r.add(s.div(e)),i)}else if(e.eq(Ga))return this.unsigned?Fm:hc;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=hc}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:SI(2,a-48),c=uc(r),u=c.mul(e);u.isNegative()||u.gt(s);)r-=l,c=uc(r,this.unsigned),u=c.mul(e);c.isZero()&&(c=wb),i=i.add(c),s=s.sub(u)}return i};Nt.div=Nt.divide;Nt.modulo=function(e){if(Qa(e)||(e=Pu(e)),cc){var t=(this.unsigned?cc.rem_u:cc.rem_s)(this.low,this.high,e.low,e.high);return ls(t,cc.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Nt.mod=Nt.modulo;Nt.rem=Nt.modulo;Nt.not=function(){return ls(~this.low,~this.high,this.unsigned)};Nt.and=function(e){return Qa(e)||(e=Pu(e)),ls(this.low&e.low,this.high&e.high,this.unsigned)};Nt.or=function(e){return Qa(e)||(e=Pu(e)),ls(this.low|e.low,this.high|e.high,this.unsigned)};Nt.xor=function(e){return Qa(e)||(e=Pu(e)),ls(this.low^e.low,this.high^e.high,this.unsigned)};Nt.shiftLeft=function(e){return Qa(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ls(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):ls(0,this.low<<e-32,this.unsigned)};Nt.shl=Nt.shiftLeft;Nt.shiftRight=function(e){return Qa(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?ls(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):ls(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Nt.shr=Nt.shiftRight;Nt.shiftRightUnsigned=function(e){if(Qa(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return ls(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?ls(t,0,this.unsigned):ls(t>>>e-32,0,this.unsigned)};Nt.shru=Nt.shiftRightUnsigned;Nt.shr_u=Nt.shiftRightUnsigned;Nt.toSigned=function(){return this.unsigned?ls(this.low,this.high,!1):this};Nt.toUnsigned=function(){return this.unsigned?this:ls(this.low,this.high,!0)};Nt.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Nt.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Nt.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};as.fromBytes=function(e,t,r){return r?as.fromBytesLE(e,t):as.fromBytesBE(e,t)};as.fromBytesLE=function(e,t){return new as(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};as.fromBytesBE=function(e,t){return new as(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const gX=Tp(hX),lye=zge({__proto__:null,default:gX},[hX]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mm=gX||lye;function W2(n){return Mm.fromString(n,!0,16)}const yX=W2("c3a5c85c97cb3127"),wm=W2("b492b66fbe98f273"),Vo=W2("9ae16a3b2f90404f");function lD(n){return n.xor(n.shru(47))}function bX(n,e,t){const r=n.slice(e,e+t);return Mm.fromBytes(Array.from(r),!0,!0)}function Qr(n,e){return bX(n,e,8)}function nG(n,e){return bX(n,e,4)}function Vi(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Ud(n,e,t=W2("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function cye(n,e,t,r,s,i){s=s.add(n),i=Vi(i.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(t),i=i.add(Vi(s,44)),[s.add(r),i.add(o)]}function Wk(n,e,t,r){return cye(Qr(n,e),Qr(n,e+8),Qr(n,e+16),Qr(n,e+24),t,r)}function uye(n,e=n.length){if(e>=8){const t=Vo.add(e*2),r=Qr(n,0).add(Vo),s=Qr(n,e-8),i=Vi(s,37).mul(t).add(r),o=Vi(r,25).add(s).mul(t);return Ud(i,o,t)}if(e>=4){const t=Vo.add(e*2),r=nG(n,0);return Ud(r.shl(3).add(e),nG(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],i=t+(r<<8),o=e+(s<<2);return lD(Vo.mul(i).xor(yX.mul(o))).mul(Vo)}return Vo}function hye(n,e=n.length){const t=Vo.add(e*2),r=Qr(n,0).mul(wm),s=Qr(n,8),i=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(Vo);return Ud(Vi(r.add(s),43).add(Vi(i,30)).add(o),r.add(Vi(s.add(Vo),18)).add(i),t)}function fye(n,e=n.length){const t=Vo.add(e*2),r=Qr(n,0).mul(Vo),s=Qr(n,8),i=Qr(n,e-8).mul(t),o=Qr(n,e-16).mul(Vo),a=Vi(r.add(s),43).add(Vi(i,30)).add(o),l=Ud(a,r.add(Vi(s.add(Vo),18)).add(i),t),c=Qr(n,16).mul(t),u=Qr(n,24),h=a.add(Qr(n,e-32)).mul(t),f=l.add(Qr(n,e-24)).mul(t);return Ud(Vi(c.add(u),43).add(Vi(h,30)).add(f),c.add(Vi(u.add(r),18)).add(h),t)}function vX(n,e=n.length){const t=Mm.fromNumber(81,!0);if(e<=32)return e<=16?uye(n,e):hye(n,e);if(e<=64)return fye(n,e);let r=t,s=t.mul(wm).add(113),i=lD(s.mul(Vo).add(113)).mul(Vo),o=[Mm.UZERO,Mm.UZERO],a=[Mm.UZERO,Mm.UZERO];r=r.mul(Vo).add(Qr(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do r=Vi(r.add(s).add(o[0]).add(Qr(n,l+8)),37).mul(wm),s=Vi(s.add(o[1]).add(Qr(n,l+48)),42).mul(wm),r=r.xor(a[1]),s=s.add(o[0]).add(Qr(n,l+40)),i=Vi(i.add(a[0]),33).mul(wm),o=Wk(n,l,o[1].mul(wm),r.add(a[0])),a=Wk(n,l+32,i.add(a[1]),s.add(Qr(n,l+16))),[i,r]=[r,i],l+=64;while(l!==c);const h=wm.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=Vi(r.add(s).add(o[0]).add(Qr(n,l+8)),37).mul(h),s=Vi(s.add(o[1]).add(Qr(n,l+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(Qr(n,l+40))),i=Vi(i.add(a[0]),33).mul(h),o=Wk(n,l,o[1].mul(h),r.add(a[0])),a=Wk(n,l+32,i.add(a[1]),s.add(Qr(n,l+16))),[i,r]=[r,i],Ud(Ud(o[0],a[0],h).add(lD(s).mul(yX)).add(i),Ud(o[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(n,e){return e==="string"?gu(n):Ep([n],e)}function dye(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Ep(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Sc(n)),Ee().getBool("DEBUG")&&eX(n,e),dye(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function so(){return Ee().platform.now()}function pye(n,e){return Ee().platform.fetch(n,e)}function gu(n,e="utf-8"){return e=e||"utf-8",Ee().platform.encode(n,e)}function _c(n,e="utf-8"){return e=e||"utf-8",Ee().platform.decode(n,e)}function _i(n){return Ee().platform.isTypedArray!=null?Ee().platform.isTypedArray(n):uX(n)}function Sc(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||np(n)||n==null||_i(n)&&t)e.push(n);else if(Array.isArray(n)||_i(n))for(let r=0;r<n.length;++r)Sc(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Sc(n[s],e,t)}return e}const mye=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Rn,arraysEqualWithNull:Q7,assert:U,assertNonNegativeIntegerDimensions:Ja,assertNonNull:Pg,assertShapesMatch:qi,bytesFromStringArray:nX,bytesPerElement:d_,checkConversionForErrors:eX,clamp:ep,computeStrides:Jt,convertBackendValuesAndArrayBuffer:K1,createScalarValue:Bf,createShuffledIndices:jge,decodeString:_c,distSquared:Gge,encodeString:gu,fetch:pye,fingerPrint64:vX,flatten:Sc,getArrayFromDType:Ss,getTypedArrayFromDType:ci,hasEncodingLoss:wM,hexToLong:W2,indexToLoc:Dg,inferDtype:Cp,inferFromImplicitShape:vM,isBoolean:rX,isFunction:tp,isInt:tg,isNumber:wI,isPromise:np,isScalarShape:sD,isString:cu,isTypedArray:_i,isValidDtype:tX,locToIndex:mu,makeOnesTypedArray:xM,makeZerosNestedTypedArray:CL,makeZerosTypedArray:ji,nearestDivisor:xI,nearestLargerEven:bM,now:so,parseAxisParam:An,randUniform:Wge,repeatedTry:iD,rightPad:Hm,shuffle:_L,shuffleCombo:Uge,sizeFromShape:Te,sizeToSquarishShape:vI,squeezeShape:Lf,sum:SL,swap:xf,tanh:Hge,toNestedArray:Cl,toTypedArray:Ep},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gye=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new bye)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=so();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:so()-a})}if(Ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(h=>{yye(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}};function yye(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}let bye=class{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?Hm(`${s}ms`,9):s.error,l=Hm(e,25),c=t.rank,u=t.size,h=Hm(t.shape.toString(),14);let f="";for(const d in i){const p=i[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vye(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const f in u)i[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function wye(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Rn(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rG=20,Ux=3,r3=7;function xye(n,e,t,r){const s=Jt(e),i=_ye(n,e,t,s),o=e.length,a=NE(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function _ye(n,e,t,r){const s=Te(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?_1(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],x1(l[u+h],0,t).length)}return o}function x1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(r3))} + ${parseFloat(n[1].toFixed(r3))}j`:cu(n)?r=`'${n}'`:t==="bool"?r=wX(n):r=parseFloat(n.toFixed(r3)).toString(),Hm(r,e)}function wX(n){return n===0?"false":"true"}function NE(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=_1(n);return[x1(m[0],0,t)]}return t==="bool"?[wX(n[0])]:[n[0].toString()]}if(l===1){if(a>rG){const g=Ux*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-Ux)*o,a*o));return t==="complex64"&&(y=_1(y),b=_1(b)),["["+y.map((x,w)=>x1(x,s[w],t)).join(", ")+", ..., "+b.map((x,w)=>x1(x,s[a-Ux+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?_1(n):Array.from(n)).map((g,y)=>x1(g,s[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>rG){for(let m=0;m<Ux;m++){const g=m*h,y=g+h;f.push(...NE(n.slice(g,y),c,t,u,s,!1))}f.push("...");for(let m=a-Ux;m<a;m++){const g=m*h,y=g+h;f.push(...NE(n.slice(g,y),c,t,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...NE(n.slice(g,y),c,t,u,s,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":p),f}function _1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class li{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Te(e),r!=null){const s=r.length;U(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Ss(t,this.size),this.strides=Jt(e)}set(e,...t){t.length===0&&(t=[0]),U(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return nu().makeTensor(this.values,this.shape,this.dtype)}}let nu=null,hb=null;function Sye(n){nu=n}function Cye(n){hb=n}let jn=class{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Te(e),this.strides=Jt(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return hb.buffer(this.shape,this.dtype,e)}bufferSync(){return hb.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Cl(this.shape,e,this.dtype==="complex64")}arraySync(){return Cl(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=nu().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>_c(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),nu().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=nu().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>_c(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await nu().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),nu().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return hb.print(this,e)}clone(){return this.throwIfDisposed(),hb.clone(this)}toString(e=!1){const t=this.dataSync();return xye(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),hb.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),nu().makeVariable(this,e,t,r)}};Object.defineProperty(jn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function kye(){return TL("Tensor",()=>jn)}kye();let v_=class extends jn{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Rn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);nu().disposeTensor(this),this.dataId=e.dataId,nu().incRef(this,null)}dispose(){nu().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(v_,Symbol.hasInstance,{value:n=>n instanceof jn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var cD;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(cD||(cD={}));var uD;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(uD||(uD={}));var hD;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(hD||(hD={}));var fD;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(fD||(fD={}));var dD;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(dD||(dD={}));const Tye={float32:fD,int32:uD,bool:hD,complex64:dD};function Mi(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Tye[n][e]}function G2(n){return Mi(n,"int32")}function xX(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function _X(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(n,e){if(n.dtype===e.dtype)return[n,e];const t=Mi(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function SX(n,e){U(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function NM(n,e){return e.some(t=>t.id===n.id)}function Mf(n){const e=[];return CX(n,e,new Set),e}function CX(n,e,t){if(n==null)return;if(n instanceof jn){e.push(n);return}if(!Eye(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),CX(i,e,t))}}function Eye(n){return Array.isArray(n)||typeof n=="object"}const Iye=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:SX,getTensorsInContainer:Mf,isTensorInList:NM,makeTypesMatch:ks},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s3(n){return n.kernelName!=null}let sG=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},AL=class pD{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new sG}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(bl(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new gye(this.backendInstance),!0}setupRegisteredKernels(){_I(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){_I(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof WS)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,bl(`Initialization of backend ${e} failed`),bl(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return bl(`Initialization of backend ${e} failed`),bl(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return pD.nextTensorId++}nextVariableId(){return pD.nextVariableId++}clone(e){const t=ue.runKernel(ny,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ue.runKernel(Wg,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(b_(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=s3(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(s3(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=b_(p,this.backendName);U(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,x);const w=x.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(s){const S=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:p}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=s3(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=oD(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(U(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&cu(e[0])&&(i=e.map(l=>gu(l)));const o=s.write(i,t,r),a=new jn(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),c=nX(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new jn(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new v_(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*d_(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof v_||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*d_(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=oD(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=ji(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Mf(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(U(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));U(i instanceof jn,()=>"The result y returned by f() must be a tensor.");const o=vye(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??Aye(i.shape),wye(a,o,c=>this.tidy(c),Mye);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return U(tp(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{U(t.every(a=>a instanceof jn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),U(r.value instanceof jn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(tp(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];U(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(u.every(f=>f instanceof jn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=so(),r=await this.backend.time(e);return r.wallMs=so()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new sG;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};AL.nextTensorId=0;AL.nextVariableId=0;function Aye(n){const e=xM(Te(n),"float32");return ue.makeTensor(e,n,"float32")}function kX(){const n=oX();if(n._tfengine==null){const e=new iX(n);n._tfengine=new AL(e)}return Yge(n._tfengine.ENV),Sye(()=>n._tfengine),n._tfengine}const ue=kX();function Mye(n,e){const t={a:n,b:e};return ue.runKernel(kp,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nye(){return typeof navigator<"u"&&navigator!=null}let mD;function $ye(n){mD=n}function ML(n){if(mD!==void 0)return mD;if(n||Nye()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function NL(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Rye=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:NL,isMobile:ML,mockIsMobile:$ye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const va=Ee();va.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});va.registerFlag("IS_BROWSER",()=>NL());va.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");va.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));va.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));va.registerFlag("PROD",()=>!1);va.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>va.getBool("DEBUG"));va.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);va.registerFlag("IS_TEST",()=>!1);va.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>va.getBool("DEBUG"));va.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);va.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);va.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bh(n,e){let t=n;if(_i(n))return e==="string"?[]:[n.length];if(xX(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(_X(n))return[n.buffer.size/(e==null?4:d_(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||_i(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&TX(n,r,[]),r}function TX(n,e,t){if(t=t||[],!Array.isArray(n)&&!_i(n)){U(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}U(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),U(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)TX(n[s],r,t.concat(s))}function iG(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function j(n,e,t,r="numeric"){if(n instanceof jn)return iG(r,n.dtype,e,t),n;let s=Cp(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),iG(r,s,e,t),n==null||!_i(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=bh(n,s);!_i(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?Ep(n,s):Sc(n,[],!0);return ue.makeTensor(a,i,s)}function w_(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>j(i,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $L="__op";function he(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+$L;const s=(...i)=>{ue.startScope(t);try{const o=r(...i);return np(o)&&console.error("Cannot return a Promise inside of tidy."),ue.endScope(o),o}catch(o){throw ue.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pye(n,e){const t=j(n,"real","complex"),r=j(e,"imag","complex");qi(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return ue.runKernel(ZS,s)}const Nf=he({complex_:Pye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ip(n,e,t,r){if(r==null)r=Cp(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(_X(n)||xX(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ue.backend.createTensorFromGPUData(n,e||t,r)}if(!_i(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ja(e);const s=Te(e),i=Te(t);U(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Te(e.slice(o)):!0;U(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!_i(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Ep(n,r):Sc(n,[],!0),ue.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(n,e,t){const r=bh(n,t);return Ip(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gD={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Du{static join(e){return new Du(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>_i(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+s.byteLength;this.shards.push({buffer:s,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,i=new ArrayBuffer(s),o=new Uint8Array(i);let a=0;for(let l=r;l<this.shards.length;l++){const c=this.shards[l],h=e+a-c.start,f=a,p=Math.min(t,c.end)-c.start,m=new Uint8Array(c.buffer,h,p-h);if(o.set(m,f),a+=m.length,t<c.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Dye(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Dye(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,i=e(n[s]);if(i===0)return s;i<0?r=s:t=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CI=4;async function yD(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const f=await l.bytes(),d=f.reduce((g,y)=>g+y.length,0)+CI*f.length,p=new Uint8Array(d);let m=0;for(let g=0;g<f.length;g++){const y=f[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(b,m),m+=CI,p.set(y,m),m+=y.length}h(p)});r.push(u)}else r.push(l.data());e!=null&&(c.group=e),t.push(c)}const i=await Promise.all(r);return{data:Oye(i),specs:t}}function RL(n,e){const t=new Du(n),r={};let s,i=0;for(const o of e){const a=o.name,l=o.dtype,c=o.shape,u=Te(c);let h;if("quantization"in o){const f=o.quantization;if(f.dtype==="uint8"||f.dtype==="uint16"){if(!("min"in f&&"scale"in f))throw new Error(`Weight ${o.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`)}else if(f.dtype==="float16"){if(l!=="float32")throw new Error(`Weight ${o.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${l}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=gD[f.dtype],p=t.slice(i,i+u*d),m=f.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(l==="float32")if(f.dtype==="uint8"||f.dtype==="uint16"){h=new Float32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=y*f.scale+f.min}}else if(f.dtype==="float16")s===void 0&&(s=Uye()),h=s(m);else throw new Error(`Unsupported quantization type ${f.dtype} for weight type float32.`);else if(l==="int32"){if(f.dtype!=="uint8"&&f.dtype!=="uint16")throw new Error(`Unsupported quantization type ${f.dtype} for weight type int32.`);h=new Int32Array(m.length);for(let g=0;g<m.length;g++){const y=m[g];h[g]=Math.round(y*f.scale+f.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);i+=u*d}else if(l==="string"){const f=Te(o.shape);h=[];for(let d=0;d<f;d++){const p=new Uint32Array(t.slice(i,i+CI))[0];i+=CI;const m=new Uint8Array(t.slice(i,i+p));h.push(m),i+=p}}else{const f=gD[l],d=t.slice(i,i+u*f);if(l==="float32")h=new Float32Array(d);else if(l==="int32")h=new Int32Array(d);else if(l==="bool")h=new Uint8Array(d);else if(l==="complex64"){h=new Float32Array(d);const p=new Float32Array(h.length/2),m=new Float32Array(h.length/2);for(let b=0;b<p.length;b++)p[b]=h[b*2],m[b]=h[b*2+1];const g=Ei(p,c,"float32"),y=Ei(m,c,"float32");r[a]=Nf(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);i+=u*f}l!=="complex64"&&(r[a]=Ei(h,c,l))}return r}function Oye(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const PL=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function oG(n){return PL?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Fye(n){if(PL)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function Lye(n){if(PL){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function EX(n){return Du.join(n)}function aG(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function IX(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function DL(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function OL(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),DL(n,t,r)}function H2(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:oG(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:oG(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Du(n.weightData).byteLength}}function FL(n){const e=[];for(const t of n)e.push(...t.weights);return e}function zye(){const n=t=>{let r=t<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Bye(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Vye(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Uye(){const n=zye(),e=Bye(),t=Vye();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _s{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return _s.instance==null&&(_s.instance=new _s),_s.instance}static registerSaveRouter(e){_s.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_s.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _s.getHandlers(e,"save")}static getLoadHandlers(e,t){return _s.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?_s.getInstance().loadRouters:_s.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&s.push(a)}),s}}const Wye=n=>_s.registerSaveRouter(n),Gye=n=>_s.registerLoadRouter(n),AX=n=>_s.getSaveHandlers(n),MX=(n,e)=>_s.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bD="tensorflowjs",vD=1,Lm="models_store",Ad="model_info_store";function NX(){if(!Ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function wD(n){const e=n.result;e.createObjectStore(Lm,{keyPath:"modelPath"}),e.createObjectStore(Ad,{keyPath:"modelPath"})}class ng{constructor(e){if(this.indexedDB=NX(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const i=this.indexedDB.open(bD,vD);i.onupgradeneeded=()=>wD(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Lm,"readonly"),c=a.objectStore(Lm).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=u=>(o.close(),s(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=Du.join(t.weightData);const a=H2(t),l=o.transaction(Ad,"readwrite");let c=l.objectStore(Ad),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(f){return s(f)}let h;u.onsuccess=()=>{h=o.transaction(Lm,"readwrite");const f=h.objectStore(Lm);let d;try{d=f.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(p){return s(p)}d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=p=>{c=l.objectStore(Ad);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),s(d.error)),m.onerror=g=>(o.close(),s(d.error))}},u.onerror=f=>(o.close(),s(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>s(i.error)})}}ng.URL_SCHEME="indexeddb://";const $X=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ng.URL_SCHEME)?Hye(n.slice(ng.URL_SCHEME.length)):null;_s.registerSaveRouter($X);_s.registerLoadRouter($X);function Hye(n){return new ng(n)}function jye(n){return n.startsWith(ng.URL_SCHEME)?n.slice(ng.URL_SCHEME.length):n}class qye{constructor(){this.indexedDB=NX()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(bD,vD);r.onupgradeneeded=()=>wD(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(Ad,"readonly"),a=i.objectStore(Ad).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),t(a.error)),i.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=jye(e),new Promise((t,r)=>{const s=this.indexedDB.open(bD,vD);s.onupgradeneeded=()=>wD(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(Ad,"readwrite"),a=o.objectStore(Ad),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=i.transaction(Lm,"readwrite");const d=c.objectStore(Lm).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=p=>r(l.error)};u.onsuccess=h,u.onerror=f=>(h(),i.close(),r(l.error))}},l.onerror=u=>(i.close(),r(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},s.onerror=i=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _f="/",fb="tensorflowjs_models",RX="info",Xye="model_topology",Kye="weight_specs",Yye="weight_data",Zye="model_metadata";function PX(n){return{info:[fb,n,RX].join(_f),topology:[fb,n,Xye].join(_f),weightSpecs:[fb,n,Kye].join(_f),weightData:[fb,n,Yye].join(_f),modelMetadata:[fb,n,Zye].join(_f)}}function DX(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Jye(n){const e=n.split(_f);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(_f)}function Qye(n){return n.startsWith(rg.URL_SCHEME)?n.slice(rg.URL_SCHEME.length):n}class rg{constructor(e){if(!Ee().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=PX(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=H2(e),i=Du.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Fye(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw DX(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Lye(o),t}}rg.URL_SCHEME="localstorage://";const OX=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(rg.URL_SCHEME)?e0e(n.slice(rg.URL_SCHEME.length)):null;_s.registerSaveRouter(OX);_s.registerLoadRouter(OX);function e0e(n){return new rg(n)}class t0e{constructor(){U(Ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=fb+_f,r=_f+RX;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(r)){const o=Jye(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=Qye(e);const t=PX(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return DX(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tb="://";class zo{constructor(){this.managers={}}static getInstance(){return zo.instance==null&&(zo.instance=new zo),zo.instance}static registerManager(e,t){U(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Tb)&&(e=e.slice(0,e.indexOf(Tb))),U(e.length>0,()=>"scheme must not be an empty string.");const r=zo.getInstance();U(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=zo.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(zo.getInstance().managers)}}function $E(n){if(n.indexOf(Tb)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${zo.getSchemes().join(",")}`);return{scheme:n.split(Tb)[0],path:n.split(Tb)[1]}}async function FX(n,e,t=!1){U(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=_s.getLoadHandlers(n);U(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),U(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=_s.getSaveHandlers(e);U(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),U(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=$E(n).scheme,l=$E(n).path,c=a===$E(n).scheme,u=await s.load();t&&c&&await zo.getManager(a).removeModel(l);const h=await o.save(u);return t&&!c&&await zo.getManager(a).removeModel(l),h.modelArtifactsInfo}async function LL(){const n=zo.getSchemes(),e={};for(const t of n){const r=await zo.getManager(t).listModels();for(const s in r){const i=t+Tb+s;e[i]=r[s]}}return e}async function zL(n){const e=$E(n);return zo.getManager(e.scheme).removeModel(e.path)}async function n0e(n,e){return FX(n,e,!1)}async function r0e(n,e){return FX(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s0e{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Ee().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return uX(e)}}if(Ee().get("IS_BROWSER")){Ee().setPlatform("browser",new s0e);try{zo.registerManager(rg.URL_SCHEME,new t0e)}catch{}try{zo.registerManager(ng.URL_SCHEME,new qye)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e={importFetch:()=>require("node-fetch")};let i3;class o0e{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ee().global.fetch!=null?Ee().global.fetch(e,t):(i3==null&&(i3=i0e.importFetch()),i3(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Ee().get("IS_NODE")&&!Ee().get("IS_BROWSER")&&Ee().setPlatform("node",new o0e);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sn(n,e="float32",t){return e=e||"float32",Ja(n),new li(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0e(n,e){const t=j(n,"x","cast");if(!tX(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return ue.runKernel(Wg,r,s)}const wt=he({cast_:a0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0e(n){const t={x:j(n,"x","clone","string_or_numeric")};return ue.runKernel(ny,t)}const dh=he({clone_:l0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BL(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */kX();const c0e={buffer:Sn,cast:wt,clone:dh,print:BL};Cye(c0e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u0e(){Ee().set("PROD",!0)}function h0e(){Ee().set("DEBUG",!0)}function f0e(){Ee().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function d0e(n){Ee().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function p0e(){ue.disposeVariables()}function xo(){return ue}function kI(){return ue.memory()}function m0e(n){return ue.profile(n)}function Se(n,e){return ue.tidy(n,e)}function nn(n){Mf(n).forEach(t=>t.dispose())}function Xs(n){return ue.keep(n)}function g0e(n){return ue.time(n)}function y0e(n){return ue.setBackend(n)}function j2(){return ue.ready()}function x_(){return ue.backendName}function b0e(n){ue.removeBackend(n)}function v0e(n){return ue.findBackend(n)}function w0e(n){return ue.findBackendFactory(n)}function $M(n,e,t=1){return ue.registerBackend(n,e,t)}function sg(){return ue.backend}function x0e(n,e){Ee().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0e(n,e){let t=j(n,"a","add"),r=j(e,"b","add");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(kp,s)}const qe=he({add_:_0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0e(n,e){let t=j(n,"a","floorDiv"),r=j(e,"b","floorDiv");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(ey,s)}const VL=he({floorDiv_:S0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(n,e){let t=j(n,"a","div"),r=j(e,"b","div");if([t,r]=ks(t,r),t.dtype==="int32"&&r.dtype==="int32")return VL(t,r);const s={a:t,b:r},i={};return ue.runKernel(Xg,s,i)}const Lt=he({div_:C0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0e(n,e){let t=j(n,"a","mul"),r=j(e,"b","mul");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(hy,s)}const fe=he({mul_:k0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0e(n){const e=j(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ue.runKernel(Pv,t)}else{const t={x:e};return ue.runKernel(Tv,t)}}const wi=he({abs_:T0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0e(n){const t={x:j(n,"x","acos")};return ue.runKernel(Og,t)}const LX=he({acos_:E0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0e(n){const t={x:j(n,"x","acosh")};return ue.runKernel(Fg,t)}const zX=he({acosh_:I0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(n){U(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),U(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,i)=>j(s,`tensors${i}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!Rn(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return ue.runKernel(Ev,r)}const BX=he({addN_:A0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0e(n,e=null,t=!1){const s={x:j(n,"x","all","bool")},i={axis:e,keepDims:t};return ue.runKernel(GS,s,i)}const UL=he({all_:M0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(n,e=null,t=!1){const s={x:j(n,"x","any","bool")},i={axis:e,keepDims:t};return ue.runKernel(HS,s,i)}const TI=he({any_:N0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0e(n,e=0){const r={x:j(n,"x","argMax")},s={axis:e};return ue.runKernel(Iv,r,s)}const ig=he({argMax_:$0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(n,e=0){const r={x:j(n,"x","argMin")},s={axis:e};return ue.runKernel(Av,r,s)}const VX=he({argMin_:R0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(n){const t={x:j(n,"x","asin")};return ue.runKernel(Lg,t)}const UX=he({asin_:P0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(n){const t={x:j(n,"x","asinh")};return ue.runKernel(zg,t)}const WX=he({asinh_:D0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0e(n){const t={x:j(n,"x","atan")};return ue.runKernel(Bg,t)}const GX=he({atan_:O0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0e(n,e){let t=j(n,"a","atan2"),r=j(e,"b","atan2");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(Ug,s)}const HX=he({atan2_:F0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0e(n){const t={x:j(n,"x","atanh")};return ue.runKernel(Vg,t)}const jX=he({atanh_:L0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ap(n,e,t,r,s="NHWC",i){const o=n[3],a=[...e,o],l=el(s);return ts(n,a,t,i,r,null,null,l)}function ko(n,e,t,r,s,i,o="channelsLast"){const[a,l]=__(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ts(n,c,t,r,s,i,!1,o)}function Ol(n,e,t,r,s,i,o="NDHWC"){const[a,l,c]=xD(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Ou(n,u,t,r,s,!1,h,i)}function ts(n,e,t,r,s,i,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[f,d,,p]=e,[m,g]=__(t),[y,b]=__(r),x=Eb(f,y),w=Eb(d,b),{padInfo:S,outHeight:C,outWidth:k}=V0e(s,c,u,m,g,x,w,i,a),A=o?p*h:p;let M;return a==="channelsFirst"?M=[l,A,C,k]:a==="channelsLast"&&(M=[l,C,k,A]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:C,outWidth:k,outChannels:A,padInfo:S,strideHeight:m,strideWidth:g,filterHeight:f,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:n,outShape:M,filterShape:e}}function Ou(n,e,t,r,s,i=!1,o="channelsLast",a){let[l,c,u,h,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,f]=n;else if(o==="channelsFirst")[l,f,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,m,,g]=e,[y,b,x]=xD(t),[w,S,C]=xD(r),k=Eb(d,w),A=Eb(p,S),M=Eb(m,C),{padInfo:E,outDepth:N,outHeight:O,outWidth:R}=U0e(s,c,u,h,y,b,x,k,A,M,a),D=i?g*f:g;let z;return o==="channelsFirst"?z=[l,D,N,O,R]:o==="channelsLast"&&(z=[l,N,O,R,D]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:f,outDepth:N,outHeight:O,outWidth:R,outChannels:D,padInfo:E,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:d,filterHeight:p,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:A,effectiveFilterWidth:M,dilationDepth:w,dilationHeight:S,dilationWidth:C,inShape:n,outShape:z,filterShape:e}}function z0e(n,e,t,r,s){r==null&&(r=WL(n,e,t));const i=n[0],o=n[1],a=S_((i-e+2*r)/t+1,s),l=S_((o-e+2*r)/t+1,s);return[a,l]}function B0e(n,e,t,r,s,i){s==null&&(s=WL(n,e[0],r[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*s>=e[a]&&(o[a]=S_((n[a]-e[a]+2*s)/r[a]+1,i));return o}function WL(n,e,t,r=1){const s=Eb(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function __(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function xD(n){return typeof n=="number"?[n,n,n]:n}function Eb(n,e){return e<=1?n:n+(n-1)*(e-1)}function V0e(n,e,t,r,s,i,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=z0e([e,t],i,r,n,a);u=d[0],h=d[1]}else if(n==="same"){u=Math.ceil(e/r),h=Math.ceil(t/s);const f=Math.max(0,(u-1)*r+i-e),d=Math.max(0,(h-1)*s+o-t),p=Math.floor(f/2),m=f-p,g=Math.floor(d/2),y=d-g;c={top:p,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-i+1)/r),h=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const f=l==="channelsLast"?n[1][0]:n[2][0],d=l==="channelsLast"?n[1][1]:n[2][1],p=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:f,bottom:d,left:p,right:m,type:f===0&&d===0&&p===0&&m===0?"VALID":"EXPLICIT"},u=S_((e-i+f+d)/r+1,a),h=S_((t-o+p+m)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function U0e(n,e,t,r,s,i,o,a,l,c,u){let h,f,d,p;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=B0e([e,t,r,1],[a,l,c],1,[s,i,o],n,u);f=g[0],d=g[1],p=g[2]}else if(n==="same"){f=Math.ceil(e/s),d=Math.ceil(t/i),p=Math.ceil(r/o);const m=(f-1)*s+a-e,g=(d-1)*i+l-t,y=(p-1)*o+c-r,b=Math.floor(m/2),x=m-b,w=Math.floor(g/2),S=g-w,C=Math.floor(y/2),k=y-C;h={top:w,bottom:S,left:C,right:k,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:f,outHeight:d,outWidth:p}}function S_(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function rp(n){const[e,t,r]=__(n);return e===1&&t===1&&r===1}function Ri(n,e){return rp(n)||rp(e)}function og(n){return __(n).every(e=>e>0)}function el(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ta(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")U(tg(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{U(tg(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(n,e){const r={x:j(n,"x","reshape","string_or_numeric")},s={shape:e};return ue.runKernel(pw,r,s)}const ve=he({reshape_:W0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(n,e,t,r,s){const i=j(n,"x","avgPool","float32"),o=1;U(Ri(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),ta("avgPool",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=ue.runKernel(Mv,c,u);return h=wt(h,i.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const RM=he({avgPool_:G0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0e(n,e,t,r,s,i="NDHWC"){const o=j(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),U(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),U(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ta("avgPool3d",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i};let h=ue.runKernel(Nv,c,u);return h=wt(h,a.dtype),l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const GL=he({avgPool3d_:H0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0e(n,e=0){U(n.length>=1,()=>"Pass at least one tensor to concat");const t=w_(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return dh(t[0]);const r=t,s={axis:e};return ue.runKernel(Dv,r,s)}const cs=he({concat_:j0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(n,e,t=!1,r=!1){let s=j(n,"a","matMul"),i=j(e,"b","matMul");[s,i]=ks(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return ue.runKernel($v,o,a)}const Hn=he({matMul_:q0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0e(n){const t={x:j(n,"x","sigmoid","float32")};return ue.runKernel(_y,t)}const kl=he({sigmoid_:X0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K0e(n,e,t){const r=j(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:t};return ue.runKernel(vw,s,i)}const dn=he({slice_:K0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(n){const t={x:j(n,"x","tanh","float32")};return ue.runKernel(Iy,t)}const jb=he({tanh_:Y0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(n,e,t,r,s,i){const o=j(n,"forgetBias","basicLSTMCell"),a=j(e,"lstmKernel","basicLSTMCell"),l=j(t,"lstmBias","basicLSTMCell"),c=j(r,"data","basicLSTMCell"),u=j(s,"c","basicLSTMCell"),h=j(i,"h","basicLSTMCell"),f=cs([c,h],1),d=Hn(f,a),p=qe(d,l),m=p.shape[0],g=p.shape[1]/4,y=[m,g],b=dn(p,[0,0],y),x=dn(p,[0,g],y),w=dn(p,[0,g*2],y),S=dn(p,[0,g*3],y),C=qe(fe(kl(b),jb(x)),fe(u,kl(qe(o,w)))),k=fe(jb(C),kl(S));return[C,k]}const qX=he({basicLSTMCell_:Z0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J0e(n,e,t){const r=j(n,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);U(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),U(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),U(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:r},o={blockShape:e,crops:t};return ue.runKernel(Rv,i,o)}const PM=he({batchToSpaceND_:J0e});function Q0e(n){let e;return n.rank===0||n.rank===1?e=ve(n,[1,1,1,n.size]):n.rank===2?e=ve(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(n,e,t,r,s,i){i==null&&(i=.001);const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;r!=null&&(u=j(r,"offset","batchNorm")),U(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:Q0e(o),scale:c,offset:u,mean:a,variance:l},d={varianceEpsilon:i},p=ue.runKernel(Gv,f,d);return ve(p,o.shape)}const q2=he({batchNorm_:ebe});function tbe(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),U(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),U(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),q2(o,a,l,u,c,i)}const HL=he({batchNorm2d_:tbe});function nbe(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),U(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),U(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),q2(o,a,l,u,c,i)}const jL=he({batchNorm3d_:nbe});function rbe(n,e,t,r,s,i){const o=j(n,"x","batchNorm"),a=j(e,"mean","batchNorm"),l=j(t,"variance","batchNorm");let c;s!=null&&(c=j(s,"scale","batchNorm"));let u;return r!=null&&(u=j(r,"offset","batchNorm")),U(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),U(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),U(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),q2(o,a,l,u,c,i)}const qL=he({batchNorm4d_:rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sbe(n,e,t){const r=j(n,"x","bincount"),s=j(e,"weights","bincount");U(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:t};return ue.runKernel(XS,i,o)}const XL=he({bincount_:sbe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(n,e){const t=j(n,"x","bitwiseAnd"),r=j(e,"y","bitwiseAnd");if(!Rn(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const s={a:t,b:r};return ue.runKernel(KS,s)}const XX=he({bitwiseAnd_:ibe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obe(n,e){const t=j(n,"s0","broadcastArgs","int32"),r=j(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return ue.runKernel(YS,s)}const KX=he({broadcastArgs_:obe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(n,e){let t=j(n,"broadcastTo","x");const r=t.shape;if(Ja(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=ve(t,c)}const s=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(s[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return dh(t);const a={x:t},l={reps:i};return ue.runKernel(Ay,a,l)}const Ib=he({broadcastTo_:abe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(n){const t={x:j(n,"x","ceil","float32")};return ue.runKernel(Gg,t)}const YX=he({ceil_:lbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $y(n,e,t){Ja(n),t=t||Cp(e);const r={shape:n,value:e,dtype:t};return ue.runKernel(f2,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(n,e,t){const r=j(n,"x","clipByValue");if(U(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return $y(r.shape,e,r.dtype);const s={x:r},i={clipValueMin:e,clipValueMax:t};return ue.runKernel(Hg,s,i)}const wa=he({clipByValue_:cbe});function ube(n){return cs(n,0)}const KL=he({concat1d_:ube});function hbe(n,e){return cs(n,e)}const YL=he({concat2d_:hbe});function fbe(n,e){return cs(n,e)}const ZL=he({concat3d_:fbe});function dbe(n,e){return cs(n,e)}const JL=he({concat4d_:dbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(n,e,t,r,s="NHWC",i=[1,1],o){const a=j(n,"x","conv2d","float32"),l=j(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ta("conv2d",r,o);const h=s==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),U(Ri(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),U(og(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(og(t),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},p=ue.runKernel(Ov,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const sp=he({conv2d_:pbe});function mbe(n,e,t,r,s="NWC",i=1,o){const a=j(n,"x","conv1d"),l=j(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1]])),U(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),U(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ta("conv1d",r,o),U(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),U(Ri(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),U(og(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(og(t),()=>"Error in conv1D: Stride should be larger than 0."),U(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=ve(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=sp(f,h,[1,t],r,"NHWC",[1,i],o);return u?ve(g,[g.shape[2],g.shape[3]]):ve(g,[g.shape[0],g.shape[2],g.shape[3]])}const QL=he({conv1d_:mbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(n,e,t,r,s,i="NHWC",o){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),U(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),U(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),U(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];U(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),U(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),ta("conv2dDerInput",s,o);const f={dy:l,filter:t},d={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a},p=ue.runKernel(Fv,f,d);return c?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const ez=he({conv2DBackpropInput_:gbe});function ybe(n,e,t,r,s,i){const o=j(n,"x","conv2dTranspose"),a=j(e,"filter","conv2dTranspose");return ez(t,o,a,r,s,"NHWC",i)}const tz=he({conv2dTranspose_:ybe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbe(n,e,t,r,s="NDHWC",i=[1,1,1]){const o=j(n,"x","conv3d"),a=j(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),U(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),U(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),U(Ri(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),U(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),U(og(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(og(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:i},f=ue.runKernel(Lv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const nz=he({conv3d_:bbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vbe(n,e,t,r,s){U(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];U(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),U(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),U(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),U(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),U(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},h={pad:s,strides:r,inputShape:i},f=ue.runKernel(e2,u,h);return a?ve(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const ZX=he({conv3DBackpropInput_:vbe});function wbe(n,e,t,r,s){const i=j(n,"x","conv3dTranspose"),o=j(e,"filter","conv3dTranspose");return ZX(t,i,o,r,s)}const rz=he({conv3dTranspose_:wbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(n){const t={x:j(n,"x","cos","float32")};return ue.runKernel(jg,t)}const DM=he({cos_:xbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _be(n){const t={x:j(n,"x","cosh","float32")};return ue.runKernel(qg,t)}const sz=he({cosh_:_be});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(n,e=0,t=!1,r=!1){const i={x:j(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return ue.runKernel(t2,i,o)}const EI=he({cumprod_:Sbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cbe(n,e=0,t=!1,r=!1){const i={x:j(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return ue.runKernel(zv,i,o)}const iz=he({cumsum_:Cbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(n,e,t,r=!1){const s=j(n,"x","denseBincount"),i=j(e,"weights","denseBincount");U(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),U(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),U(t>=0,()=>`size must be non-negative, but got ${t}.`),U(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const o={x:s,weights:i},a={size:t,binaryOutput:r};return ue.runKernel(r2,o,a)}const II=he({denseBincount_:kbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(n,e,t="NHWC"){const r=j(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],i=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];U(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),U(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),U(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${r.shape}`),U(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:t};return ue.runKernel(s2,a,l)}const JX=he({depthToSpace_:Tbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ebe(n,e,t,r,s="NHWC",i=[1,1],o){const a=j(n,"x","depthwiseConv2d","float32"),l=j(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),U(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=s==="NHWC"?c.shape[3]:c.shape[1];U(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),ta("depthwiseConv2d",r,o);const f={x:c,filter:l},d={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},p=ue.runKernel(Bv,f,d);return u?ve(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const X2=he({depthwiseConv2d_:Ebe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(n){const t={x:j(n,"x","diag")};return ue.runKernel(a2,t)}const QX=he({diag_:Ibe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Abe(n,e,t,r,s=[1,1],i="NHWC"){const o=j(n,"x","dilation2d"),a=j(e,"filter","dilation2d");U(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),U(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),U(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),U(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},h={strides:t,pad:r,dilations:s},f=ue.runKernel(Vv,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const eK=he({dilation2d_:Abe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const i=t-1-s,o=n[i]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(i)}return r}function ui(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],i=e.length-r-1,o=e[i];(s==null||s===1&&o>1)&&t.unshift(i)}return t}function ln(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let i=n[n.length-s-1];i==null&&(i=1);let o=e[e.length-s-1];if(o==null&&(o=1),i===1)r[t-s-1]=o;else if(o===1)r[t-s-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-s-1]=i}return r}const Mbe=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:ln,getBroadcastDims:$f,getReductionAxes:ui},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(n,e){let t=j(n,"a","equal","string_or_numeric"),r=j(e,"b","equal","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Uv,s)}const bu=he({equal_:Nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(n,e,t){const r=j(e,"a","where"),s=j(t,"b","where"),i=j(n,"condition","where","bool"),o=ln(ln(i.shape,r.shape),s.shape),a=Ib(i,o),l=Ib(r,o),c=Ib(s,o),u={condition:a,t:l,e:c};return ue.runKernel(bw,u)}const _o=he({where_:$be});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rbe(n){const t={x:j(n,"x","zerosLike")};return ue.runKernel(Tw,t)}const lr=he({zerosLike_:Rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pbe(n,e){let t=j(n,"a","div"),r=j(e,"b","div");[t,r]=ks(t,r);const s=Lt(t,r),i=lr(s),o=bu(r,i);return _o(o,i,s)}const tK=he({divNoNan_:Pbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(n,e){const t=j(n,"t1","dot"),r=j(e,"t2","dot");U((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],i=r.rank===1?r.size:r.shape[0];if(U(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),t.rank===1&&r.rank===1){const o=ve(t,[1,-1]),a=ve(r,[-1,1]),l=Hn(o,a);return ve(l,[])}else if(t.rank===1&&r.rank===2){const o=ve(t,[1,-1]),a=ve(r,[r.shape[0],r.shape[1]]),l=Hn(o,a);return ve(l,[l.size])}else if(t.rank===2&&r.rank===1){const o=ve(r,[-1,1]),a=Hn(t,o);return ve(a,[a.size])}else{const o=ve(r,[r.shape[0],r.shape[1]]);return Hn(t,o)}}const nK=he({dot_:Dbe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obe(n,...e){const t=e.map((s,i)=>j(s,`tensors${i}`,"einsum")),r={equation:n};return ue.runKernel(c2,t,r)}const Nm=he({einsum_:Obe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fbe(n){const t={x:j(n,"x","elu","float32")};return ue.runKernel(Kg,t)}const K2=he({elu_:Fbe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lbe(n,e){const t=j(n,"x","ensureShape","string_or_numeric");if(!Q7(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const rK=he({ensureShape_:Lbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zbe(n){let e=j(n,"x","erf");U(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=wt(e,"float32"));const t={x:e};return ue.runKernel(Yg,t)}const sK=he({erf_:zbe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oz(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function iK(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function Qs(n,e){const t=[],r=n.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&t.push(n[i]);const s=e.map(i=>n[i]);return[t,s]}function Ls(n,e){const t=e.map(r=>1);return iK(n,t,e)}function fi(n,e,t){U(oz(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Lr(n,e){if(oz(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Mh(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ns(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bbe(n,e=null,t=!1){const s={x:j(n,"x","max")},i={reductionIndices:e,keepDims:t};return ue.runKernel(ew,s,i)}const bc=he({max_:Bbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbe(n,e=null,t=!1){const s={x:j(n,"x","min")},i={axis:e,keepDims:t};return ue.runKernel(sw,s,i)}const C_=he({min_:Vbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(n,e){let t=j(n,"base","pow"),r=j(e,"exp","pow");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(fy,s)}const ip=he({pow_:Ube});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(n,e){if((_i(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&_i(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ip(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wbe(n){const t={x:j(n,"x","sqrt","float32")};return ue.runKernel(Cy,t)}const So=he({sqrt_:Wbe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gbe(n){const e=j(n,"x","square"),t={};return ue.runKernel("Square",{x:e},t)}const Or=he({square_:Gbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbe(n,e=null,t=!1){let r=j(n,"x","sum");r.dtype==="bool"&&(r=wt(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ue.runKernel(ww,s,i)}const Yt=he({sum_:Hbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jbe(n,e="euclidean",t=null,r=!1){n=j(n,"x","norm");const s=oK(n,e,t);let i=s.shape;if(r){const o=An(t,n.shape);i=Ls(s.shape,o)}return ve(s,i)}function oK(n,e,t=null){if(n.rank===0)return wi(n);if(n.rank!==1&&t===null)return oK(ve(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Yt(wi(n),t);if(e===1/0)return bc(wi(n),t);if(e===-1/0)return C_(wi(n),t);if(e==="euclidean"||e===2)return So(Yt(ip(wi(n),en(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return bc(Yt(wi(n),t[0]),t[1]-1);if(e===1/0)return bc(Yt(wi(n),t[1]),t[0]);if(e===-1/0)return C_(Yt(wi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return So(Yt(Or(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Ew=he({norm_:jbe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(n,e=null,t=!1){return Ew(n,"euclidean",e,t)}const aK=he({euclideanNorm_:qbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xbe(n){const t={x:j(n,"x","exp")};return ue.runKernel(Zg,t)}const Yo=he({exp_:Xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(n,e=0){const t=j(n,"x","expandDims","string_or_numeric");U(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return ue.runKernel(Wv,r,s)}const oi=he({expandDims_:Kbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ybe(n){const t={x:j(n,"x","expm1")};return ue.runKernel(Jg,t)}const lK=he({expm1_:Ybe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(n,e){const t=j(n,"x","tile","string_or_numeric");U(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return ue.runKernel(Ay,r,s)}const fc=he({tile_:Zbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(n,e,t,r="float32"){e==null&&(e=n);const s=Sn([n,e],r),i=n<=e?n:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=ve(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return fc(oi(o,0),[t[0],1,1]);if(t.length===2)return fc(oi(oi(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return fc(oi(oi(oi(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const OM=he({eye_:Jbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(n){const t={x:j(n,"x","floor","float32")};return ue.runKernel(Qg,t)}const Y2=he({floor_:Qbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eve(n,e,t=0,r=0){const s=j(n,"x","gather"),i=j(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return ue.runKernel(Hv,o,a)}const Z2=he({gather_:eve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tve(n,e){let t=j(n,"a","greater","string_or_numeric"),r=j(e,"b","greater","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(jv,s)}const tl=he({greater_:tve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(n,e){let t=j(n,"a","greaterEqual","string_or_numeric"),r=j(e,"b","greaterEqual","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(ty,s)}const Mp=he({greaterEqual_:nve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rve(n){const t={input:j(n,"input","imag")};return ue.runKernel(g2,t)}const J2=he({imag_:rve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(n){const t={x:j(n,"x","isFinite")};return ue.runKernel(ry,t)}const cK=he({isFinite_:sve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ive(n){const t={x:j(n,"x","isInf")};return ue.runKernel(sy,t)}const uK=he({isInf_:ive});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ove(n){const t={x:j(n,"x","isNaN")};return ue.runKernel(iy,t)}const hK=he({isNaN_:ove});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(n,e=.2){const r={x:j(n,"x","leakyRelu")},s={alpha:e};return ue.runKernel(qv,r,s)}const FM=he({leakyRelu_:ave});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lve(n,e){let t=j(n,"a","less","string_or_numeric"),r=j(e,"b","less","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Xv,s)}const k_=he({less_:lve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(n,e){let t=j(n,"a","lessEqual","string_or_numeric"),r=j(e,"b","lessEqual","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Kv,s)}const Ry=he({lessEqual_:cve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fK(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return ue.runKernel(y2,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(n,e=5,t=1,r=1,s=.5){const i=j(n,"x","localResponseNormalization");U(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),U(tg(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:r,beta:s},u=ue.runKernel(Qv,l,c);return a?ve(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const dK=he({localResponseNormalization_:uve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(n){const t={x:j(n,"x","log","float32")};return ue.runKernel(oy,t)}const Al=he({log_:hve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fve(n){const t={x:j(n,"x","log1p")};return ue.runKernel(ay,t)}const LM=he({log1p_:fve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dve(n){return U(tp(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const r=j(e,"x","tf.grad","string_or_numeric"),s=t!=null?j(t,"dy","tf.grad"):null;return ue.tidy(()=>{const{value:i,grads:o}=ue.gradients(()=>n(r),[r],s);return s!=null&&qi(i.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),zM(o),o[0]})}}function pve(n){return U(tp(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{U(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=w_(e,"args","tf.grads","string_or_numeric"),s=t!=null?j(t,"dy","tf.grads"):null;return ue.tidy(()=>{const{value:i,grads:o}=ue.gradients(()=>n(...r),r,s);return s!=null&&qi(i.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),zM(o),o})}}function mve(n){return U(tp(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{U(e instanceof jn,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),U(t==null||t instanceof jn,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=ue.gradients(()=>n(e),[e],t);return zM(r),{grad:r[0],value:s}}}function gve(n){return U(tp(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{U(Array.isArray(e)&&e.every(s=>s instanceof jn),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),U(t==null||t instanceof jn,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=ue.gradients(()=>n(...e),e,t);return t!=null&&qi(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),zM(r.grads),r}}function pK(n,e){U(tp(n),()=>"The f passed in variableGrads(f) must be a function"),U(e==null||Array.isArray(e)&&e.every(c=>c instanceof v_),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in ue.registeredVariables)e.push(ue.registeredVariables[c])}const r=t?e.filter(c=>!c.trainable):null,s=e.length;e=e.filter(c=>c.trainable),U(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const i=!0,{value:o,grads:a}=ue.gradients(n,e,null,i);U(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),r!=null&&r.forEach(c=>l[c.name]=null),{value:o,grads:l}}function vh(n){return ue.customGrad(n)}function zM(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yve(n){const t={x:j(n,"x","neg")};return ue.runKernel(ow,t)}const us=he({neg_:yve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bve(n){const t={x:j(n,"x","softplus")};return ue.runKernel(Sy,t)}const Iw=he({softplus_:bve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vve(n){const e=j(n,"x","logSigmoid");return vh(r=>({value:us(Iw(us(r))),gradFunc:o=>fe(o,kl(us(r)))}))(e)}const mK=he({logSigmoid_:vve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wve(n,e){let t=j(n,"a","sub"),r=j(e,"b","sub");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(Ty,s)}const Dt=he({sub_:wve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xve(n,e=-1){const t=j(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return vh((s,i)=>{const a=bc(s,e,!0),l=Dt(s,a),c=Dt(wt(l,"float32"),Al(Yt(Yo(l),e,!0)));return i([c]),{value:c,gradFunc:(h,f)=>{const[d]=f,p=!0,m=Yo(d);return Dt(h,fe(Yt(h,e,p),m))}}})(t)}const az=he({logSoftmax_:xve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ve(n,e=null,t=!1){const r=j(n,"x","logSumExp"),s=An(e,r.shape),i=bc(r,s,!0),o=Dt(r,i),a=Yo(o),l=Yt(a,s),c=Al(l),u=qe(ve(i,c.shape),c);if(t){const h=Ls(u.shape,s);return ve(u,h)}return u}const BM=he({logSumExp_:_ve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sve(n,e){const t=j(n,"a","logicalAnd","bool"),r=j(e,"b","logicalAnd","bool");ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Yv,s)}const wh=he({logicalAnd_:Sve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(n){const t={x:j(n,"x","logicalNot","bool")};return ue.runKernel(Zv,t)}const VM=he({logicalNot_:Cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(n,e){const t=j(n,"a","logicalOr","bool"),r=j(e,"b","logicalOr","bool");ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(Jv,s)}const lz=he({logicalOr_:kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tve(n,e){const t=j(n,"a","logicalXor","bool"),r=j(e,"b","logicalXor","bool");return ln(t.shape,r.shape),wh(lz(n,e),VM(wh(n,e)))}const gK=he({logicalXor_:Tve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gk=2147483648;function Eve(n,e,t="left"){const r=j(n,"sortedSequence","searchSorted"),s=j(e,"values","searchSorted"),i=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],a=ve(r,[-1,i]),l=ve(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Te(l.shape)>=Gk)throw new Error(`values tensor size must less than ${Gk}`);if(a.shape[1]>=Gk)throw new Error(`trailing dim_size must less than ${Gk} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:t};return ue.runKernel(N2,c,u)}const UM=he({searchSorted_:Eve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yK(n,e){return UM(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(n,e,t,r,s){const i=j(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),U(Ri(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ta("maxPool",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=ue.runKernel(tw,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const WM=he({maxPool_:Ive});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(n,e=[1,1,1],t,r,s,i="NDHWC"){const o=j(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),U(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ta("maxPool3d",r,s);const c={x:a},u={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i},h=ue.runKernel(nw,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const cz=he({maxPool3d_:Ave});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(n,e,t,r,s=!1){const o={x:j(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},l=ue.runKernel(x2,o,a);return{result:l[0],indexes:l[1]}}const bK=he({maxPoolWithArgmax_:Mve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nve(n,e){let t=j(n,"a","maximum"),r=j(e,"b","maximum");[t,r]=ks(t,r),t.dtype==="bool"&&(t=wt(t,"int32"),r=wt(r,"int32")),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(ly,s)}const Vf=he({maximum_:Nve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ve(n,e=null,t=!1){const s={x:j(n,"x","mean")},i={axis:e,keepDims:t};return ue.runKernel(rw,s,i)}const Ds=he({mean_:$ve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n,e="float32"){if(Ja(n),e==="complex64"){const r=ms(n,"float32"),s=ms(n,"float32");return Nf(r,s)}const t=ji(Te(n),e);return ue.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pa(n,e="float32"){if(Ja(n),e==="complex64"){const r=pa(n,"float32"),s=ms(n,"float32");return Nf(r,s)}const t=xM(Te(n),e);return ue.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=j(n,"x","meshgrid",n instanceof jn?n.dtype:"float32");if(e===void 0)return[r];let s=j(e,"y","meshgrid",e instanceof jn?e.dtype:"float32");const i=Te(r.shape),o=Te(s.shape);return t==="xy"?(r=ve(r,[1,-1]),s=ve(s,[-1,1]),[Hn(pa([o,1],r.dtype),r),Hn(s,pa([1,i],s.dtype))]):(r=ve(r,[-1,1]),s=ve(s,[1,-1]),[Hn(r,pa([1,o],r.dtype)),Hn(pa([i,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(n,e){let t=j(n,"a","minimum"),r=j(e,"b","minimum");[t,r]=ks(t,r),t.dtype==="bool"&&(t=wt(t,"int32"),r=wt(r,"int32")),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(cy,s)}const op=he({minimum_:Rve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pve(n,e,t){U(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=j(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)U(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const i={paddings:e,mode:t},o={x:r};return ue.runKernel(iw,o,i)}const uz=he({mirrorPad_:Pve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dve(n,e){let t=j(n,"a","mod"),r=j(e,"b","mod");[t,r]=ks(t,r);const s={a:t,b:r};return ue.runKernel(uy,s)}const wK=he({mod_:Dve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ove(n,e=null,t=!1){n=j(n,"x","moments");const r=An(e,n.shape),s=Ds(n,r,t);let i=s.shape;t||(i=Ls(s.shape,r));const o=Or(Dt(wt(n,"float32"),ve(s,i))),a=Ds(o,r,t);return{mean:s,variance:a}}const Q2=he({moments_:Ove});function Fve(n,e,t,r){const s=j(e,"data","multiRNNCell"),i=w_(t,"c","multiRNNCell"),o=w_(r,"h","multiRNNCell");let a=s;const l=[];for(let h=0;h<n.length;h++){const f=n[h](a,i[h],o[h]);l.push(f[0]),l.push(f[1]),a=f[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const xK=he({multiRNNCell_:Fve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(n,e,t,r=!1){const s=j(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?ve(s,[1,-1]):s},c={numSamples:e,seed:t,normalized:r},u=ue.runKernel(_2,l,c);return o===1?ve(u,[u.size]):u}const _K=he({multinomial_:Lve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zve(n,e){let t=j(n,"a","notEqual","string_or_numeric"),r=j(e,"b","notEqual","string_or_numeric");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r};return ue.runKernel(aw,s)}const qb=he({notEqual_:zve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:j(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return ue.runKernel(cw,o,a)}const Xb=he({oneHot_:Bve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(n){const t={x:j(n,"x","onesLike")};return ue.runKernel(lw,t)}const Ml=he({onesLike_:Vve});function Uve(n,e){const t=j(n,"v1","outerProduct"),r=j(e,"v2","outerProduct");U(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=ve(t,[-1,1]),i=ve(r,[1,-1]);return Hn(s,i)}const SK=he({outerProduct_:Uve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wve(n,e,t=0){const r=j(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},i={x:r};return ue.runKernel(hw,i,s)}const vu=he({pad_:Wve});function Gve(n,e,t=0){return U(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),vu(n,[e],t)}const CK=he({pad1d_:Gve});function Hve(n,e,t=0){return U(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(n,e,t)}const kK=he({pad2d_:Hve});function jve(n,e,t=0){return U(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(n,e,t)}const TK=he({pad3d_:jve});function qve(n,e,t=0){return U(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),vu(n,e,t)}const EK=he({pad4d_:qve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xve(n,e,t){const r=j(n,"x","spaceToBatchND");U(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),U(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),U(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},i={blockShape:e,paddings:t};return ue.runKernel(xw,s,i)}const GM=he({spaceToBatchND_:Xve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kve(n,e,t,r,s,i,o){s==null&&(s=[1,1]),i==null&&(i=1),r===0&&(r="valid");const a=j(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(Ri(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=ko(l.shape,e,i,s,r),h=[u.dilationHeight,u.dilationWidth];let f;r==="same"?f=Zve([u.filterHeight,u.filterWidth],h):f=[[0,0],[0,0]];const d=h[0]===1&&h[1]===1,[p,m]=Yve([u.inHeight,u.inWidth],h,f),g=d?r:"valid",y=d?l:GM(l,h,p),x=(t==="avg"?()=>RM(y,e,i,g,o):()=>WM(y,e,i,g,o))(),w=d?x:PM(x,h,m);return c?ve(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function Yve(n,e,t){const r=t.map(u=>u[0]),s=t.map(u=>u[1]),i=n.concat(r,s),o=e.map((u,h)=>(u-i[h]%u)%u),a=s.map((u,h)=>u+o[h]),l=e.map((u,h)=>[r[h],a[h]]),c=e.map((u,h)=>[0,o[h]]);return[l,c]}function Zve(n,e){const r=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}const IK=he({pool_:Kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jve(n,e){const t=j(n,"x","prelu"),r=j(e,"alpha","prelu"),s={x:t,alpha:r};return ue.runKernel(fw,s)}const HM=he({prelu_:Jve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qve(n,e=null,t=!1){let r=j(n,"x","prod");r.dtype==="bool"&&(r=wt(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ue.runKernel(dw,s,i)}const AK=he({prod_:Qve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ewe(n,e,t,r){const s=n.map((u,h)=>j(u,`tensors${h}`,"raggedGather","int32")),i=j(e,"paramsDenseValues","raggedGather"),o=j(t,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:i,indices:o},l={outputRaggedRank:r},c=ue.runKernel(SM,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const MK=he({raggedGather_:ewe});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function twe(n,e,t){const r=j(n,"starts","raggedRange"),s=j(e,"limits","raggedRange",r.dtype),i=j(t,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:i},a=ue.runKernel(CM,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const NK=he({raggedRange_:twe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(n,e,t,r,s){const i=j(n,"shape","raggedTensorToTensor","int32"),o=j(e,"values","raggedTensorToTensor"),a=j(t,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((h,f)=>j(h,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:s};return ue.runKernel(kM,c,u)}const $K=he({raggedTensorToTensor_:nwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rwe(n,e,t){Ja(n);const r=Te(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<r;i++)s[i]=e();return ue.makeTensor(s,n,t)}const RK=he({rand_:rwe});var hz={exports:{}};hz.exports;(function(n){(function(e,t,r){function s(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new s(l),h=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,h&&(typeof h=="object"&&i(h,u),f.state=function(){return i(u,{})}),f}function a(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(pt,n,!1)})(hz);var swe=hz.exports,fz={exports:{}};fz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(pt,n,!1)})(fz);var iwe=fz.exports,dz={exports:{}};dz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(pt,n,!1)})(dz);var owe=dz.exports,pz={exports:{}};pz.exports;(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var u=l.x,h=l.i,f,d;return f=u[h],f^=f>>>7,d=f^f<<24,f=u[h+1&7],d^=f^f>>>10,f=u[h+3&7],d^=f^f>>>3,f=u[h+4&7],d^=f^f<<7,f=u[h+7&7],f=f^f<<13,d^=f^f<<9,u[h]=d,l.i=h+1&7,d};function c(u,h){var f,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,f=0;f<h.length;++f)d[f&7]=d[f&7]<<15^h.charCodeAt(f)+d[f+1&7]<<13;for(;d.length<8;)d.push(0);for(f=0;f<8&&d[f]===0;++f);for(f==8?d[7]=-1:d[f],u.x=d,u.i=0,f=256;f>0;--f)u.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.x&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(pt,n,!1)})(pz);var awe=pz.exports,mz={exports:{}};mz.exports;(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var u=l.w,h=l.X,f=l.i,d,p;return l.w=u=u+1640531527|0,p=h[f+34&127],d=h[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,p=h[f]=p^d,l.i=f,p+(u^u>>>16)|0};function c(u,h){var f,d,p,m,g,y=[],b=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,b=Math.max(b,h.length)),p=0,m=-32;m<b;++m)h&&(d^=h.charCodeAt((m+32)%h.length)),m===0&&(g=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,m>=0&&(g=g+1640531527|0,f=y[m&127]^=d+g,p=f==0?p+1:0);for(p>=128&&(y[(h&&h.length||0)&127]=-1),p=127,m=4*128;m>0;--m)d=y[p+34&127],f=y[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,y[p]=d^f;u.w=g,u.X=y,u.i=p}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(u.X&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(pt,n,!1)})(mz);var lwe=mz.exports,gz={exports:{}};gz.exports;(function(n){(function(e,t,r){function s(a){var l=this,c="";l.next=function(){var h=l.b,f=l.c,d=l.d,p=l.a;return h=h<<25^h>>>7^f,f=f-d|0,d=d<<24^d>>>8^p,p=p-h|0,l.b=h=h<<20^h>>>12^f,l.c=f=f-d|0,l.d=d<<16^f>>>16^p,l.a=p-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new s(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var f=c.next()>>>11,d=(c.next()>>>0)/4294967296,p=(f+d)/(1<<21);while(p===0);return p},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(pt,n,!1)})(gz);var cwe=gz.exports,PK={exports:{}};const uwe={},hwe=Object.freeze(Object.defineProperty({__proto__:null,default:uwe},Symbol.toStringTag,{value:"Module"})),DK=zf(hwe);(function(n){(function(e,t,r){var s=256,i=6,o=52,a="random",l=r.pow(s,i),c=r.pow(2,o),u=c*2,h=s-1,f;function d(w,S,C){var k=[];S=S==!0?{entropy:!0}:S||{};var A=y(g(S.entropy?[w,x(t)]:w??b(),3),k),M=new p(k),E=function(){for(var N=M.g(i),O=l,R=0;N<c;)N=(N+R)*s,O*=s,R=M.g(1);for(;N>=u;)N/=2,O/=2,R>>>=1;return(N+R)/O};return E.int32=function(){return M.g(4)|0},E.quick=function(){return M.g(4)/4294967296},E.double=E,y(x(M.S),t),(S.pass||C||function(N,O,R,D){return D&&(D.S&&m(D,M),N.state=function(){return m(M,{})}),R?(r[a]=N,O):N})(E,A,"global"in S?S.global:this==r,S.state)}function p(w){var S,C=w.length,k=this,A=0,M=k.i=k.j=0,E=k.S=[];for(C||(w=[C++]);A<s;)E[A]=A++;for(A=0;A<s;A++)E[A]=E[M=h&M+w[A%C]+(S=E[A])],E[M]=S;(k.g=function(N){for(var O,R=0,D=k.i,z=k.j,B=k.S;N--;)O=B[D=h&D+1],R=R*s+B[h&(B[D]=B[z=h&z+O])+(B[z]=O)];return k.i=D,k.j=z,R})(s)}function m(w,S){return S.i=w.i,S.j=w.j,S.S=w.S.slice(),S}function g(w,S){var C=[],k=typeof w,A;if(S&&k=="object")for(A in w)try{C.push(g(w[A],S-1))}catch{}return C.length?C:k=="string"?w:w+"\0"}function y(w,S){for(var C=w+"",k,A=0;A<C.length;)S[h&A]=h&(k^=S[h&A]*19)+C.charCodeAt(A++);return x(S)}function b(){try{var w;return f&&(w=f.randomBytes)?w=w(s):(w=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(w)),x(w)}catch{var S=e.navigator,C=S&&S.plugins;return[+new Date,e,C,e.screen,x(t)]}}function x(w){return String.fromCharCode.apply(0,w)}if(y(r.random(),t),n.exports){n.exports=d;try{f=DK}catch{}}else r["seed"+a]=d})(typeof self<"u"?self:pt,[],Math)})(PK);var fwe=PK.exports,dwe=swe,pwe=iwe,mwe=owe,gwe=awe,ywe=lwe,bwe=cwe,Py=fwe;Py.alea=dwe;Py.xor128=pwe;Py.xorwow=mwe;Py.xorshift7=gwe;Py.xor4096=ywe;Py.tychei=bwe;var Aw=Py;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vwe=.001,OK=.1;function wwe(n,e,t){return t==null&&(t=yz()),_D(n,e,(r,s)=>bz(r,s,t))}function yz(){return ue.backend.floatPrecision()===32?vwe:OK}function _D(n,e,t){let r=!0;if((_i(n)||_i(e))&&(r=!1),_i(n)&&_i(e)&&(r=!0),r){const o=n.constructor.name,a=e.constructor.name;if(o!==a)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${a}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=bh(n),a=bh(e);if(!Rn(o,a))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${a}]`)}const s=_i(n)?n:Sc(n),i=_i(e)?e:Sc(e);if(s.length!==i.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${i.length}.
Actual:   ${s}.
Expected: ${i}.`);for(let o=0;o<i.length;++o){const a=s[o],l=i[o];if(!t(a,l))throw new Error(`Arrays differ: actual[${o}] = ${a}, expected[${o}] = ${l}.
Actual:   ${s}.
Expected: ${i}.`)}typeof expect<"u"&&expect().nothing()}function xwe(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function _we(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return cu(n)||cu(n[0])||cu(e)||cu(e[0])?_D(n,t,(r,s)=>r==s):_D(n,e,(r,s)=>bz(r,s,0))}function Swe(n,e,t){if(t==null&&(t=yz()),!bz(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function bz(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function Cwe(n,e,t){for(let r=0;r<n.length;r++)if(n[r]<e||n[r]>t)throw new Error(`Value out of range:${n[r]} low: ${e}, high: ${t}`)}function kwe(n,e){const t=new Float32Array(n),r=new Float32Array(e);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let s=0;s<r.length;s++)if(t[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${t[s]} instead`)}function FK(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?FK(t):n[e]=gu(t)}return n}function Twe(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",r=>t(e)),e.load()})}async function Ewe(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const Iwe=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:OK,createVideoElement:Twe,encodeStrings:FK,expectArrayBuffersEqual:kwe,expectArraysClose:wwe,expectArraysEqual:_we,expectNumbersClose:Swe,expectPromiseToFail:xwe,expectValuesInRange:Cwe,play:Ewe,testEpsilon:yz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vz{constructor(e,t,r,s,i){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Aw.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,i,o;do s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Awe{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const i=s||Math.random();this.randu=Aw.alea(i.toString()),this.randn=new vz(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,i,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<t||Math.log(i)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class Mwe{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Aw.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nwe(n,e,t=1,r="float32",s){if(Ja(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const i=new Awe(e,t,r,s),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const LK=he({randomGamma_:Nwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $we(n,e=0,t=1,r,s){if(Ja(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const i=new vz(e,t,r,!1,s),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const jM=he({randomNormal_:$we});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rwe(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return jM(n,0,1,e,t)}const zK=he({randomStandardNormal_:Rwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pwe(n,e=0,t=1,r="float32",s){Ja(n);const i=Sn(n,r),o=new Mwe(e,t,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Np=he({randomUniform_:Pwe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dwe(n,e,t,r){return Np(n,e,t,"int32",r)}const BK=he({randomUniformInt_:Dwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ag(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return ue.runKernel(k2,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Owe(n){const t={input:j(n,"input","real")};return ue.runKernel(T2,t)}const Kb=he({real_:Owe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fwe(n){const t={x:j(n,"x","reciprocal")};return ue.runKernel(dy,t)}const VK=he({reciprocal_:Fwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(n){const t={x:j(n,"x","relu")};return ue.runKernel(py,t)}const Nh=he({relu_:Lwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(n){const t={x:j(n,"x","relu6")};return ue.runKernel(my,t)}const wz=he({relu6_:zwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bwe(n,e){const r={x:j(n,"x","reverse")},s={dims:e};return ue.runKernel(yw,r,s)}const Cc=he({reverse_:Bwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vwe(n){const e=j(n,"x","reverse");return U(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Cc(e,0)}const UK=he({reverse1d_:Vwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwe(n,e){const t=j(n,"x","reverse");return U(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Cc(t,e)}const WK=he({reverse2d_:Uwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wwe(n,e){const t=j(n,"x","reverse");return U(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Cc(t,e)}const GK=he({reverse3d_:Wwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(n,e){const t=j(n,"x","reverse");return U(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Cc(t,e)}const HK=he({reverse4d_:Gwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hwe(n){const t={x:j(n,"x","round")};return ue.runKernel(gy,t)}const xz=he({round_:Hwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jwe(n){const t={x:j(n,"x","rsqrt","float32")};return ue.runKernel(yy,t)}const _z=he({rsqrt_:jwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qwe(n){const t={x:j(n,"x","selu")};return ue.runKernel(by,t)}const Sz=he({selu_:qwe});function Xwe(n,e,t,r,s,i=[1,1],o="NHWC"){const a=j(n,"x","separableConv2d"),l=j(e,"depthwiseFilter","separableConv2d"),c=j(t,"pointwiseFilter","separableConv2d");let u=a,h=!1;if(a.rank===3&&(h=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),U(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),U(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),U(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],d=l.shape[3];U(c.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${c.shape[2]}.`);const p=X2(u,l,r,s,o,i),g=sp(p,c,1,"valid",o);return h?ve(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Cz=he({separableConv2d_:Xwe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Kwe(n,e){const t=j(n,"x","setdiff1d"),r=j(e,"y","setdiff1d");U(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),U(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),U(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),i=await r.data(),o=new Set(i);let a=0;for(let u=0;u<s.length;u++)o.has(s[u])||a++;const l=new li([a],t.dtype),c=new li([a],"int32");for(let u=0,h=0;u<s.length;u++)o.has(s[u])||(l.values[h]=s[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const jK=Kwe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ywe(n){const t={x:j(n,"x","sign")};return ue.runKernel(xy,t)}const qK=he({sign_:Ywe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zwe(n){const t={x:j(n,"x","sin","float32")};return ue.runKernel(vy,t)}const kz=he({sin_:Zwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jwe(n){const t={x:j(n,"x","sinh")};return ue.runKernel(wy,t)}const Tz=he({sinh_:Jwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qwe(n,e,t){const r=j(n,"x","slice1d");return U(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),dn(r,[e],[t])}const eC=he({slice1d_:Qwe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(n,e,t){const r=j(n,"x","slice2d");return U(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),dn(r,e,t)}const qM=he({slice2d_:exe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function txe(n,e,t){const r=j(n,"x","slice3d");return U(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),dn(r,e,t)}const tC=he({slice3d_:txe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(n,e,t){const r=j(n,"x","slice4d");return U(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),dn(r,e,t)}const Yb=he({slice4d_:nxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxe(n,e=-1){const t=j(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return ue.runKernel(Sw,r,s)}const nC=he({softmax_:rxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ue.runKernel(h2,e)}const XM=he({fft_:sxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ixe(n){U(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return ue.runKernel(m2,e)}const T_=he({ifft_:ixe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=ve(n,[t,e]);r=T_(s)}else{const s=[t,2*(e-1)],i=ve(Kb(n),[t,e]),o=ve(J2(n),[t,e]),a=Cc(dn(i,[0,1],[t,e-2]),1),l=fe(Cc(dn(o,[0,1],[t,e-2]),1),en(-1)),c=cs([i,a],1),u=cs([o,l],1),h=ve(Nf(c,u),[s[0],s[1]]);r=T_(h)}if(r=Kb(r),n.rank===3&&n.shape[0]!==0){const s=r,i=n.shape[0];r=ve(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}const Ez=he({irfft_:oxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axe(n,e,t=0){const s={x:j(n,"x","split")},i={numOrSizeSplits:e,axis:t};return ue.runKernel(_w,s,i)}const ja=he({split_:axe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lxe(n,e){U(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,s=dn(n,p,m),t=e}else if(e!=null&&e>t){const p=n.shape.map(m=>m);p[n.shape.length-1]=e-t,s=cs([n,ms(p)],n.shape.length-1),t=e}else s=n;const i=lr(s),o=ve(Nf(s,i),[r,t]),a=XM(o),l=Math.floor(t/2)+1,c=Kb(a),u=J2(a),h=ja(c,[l,t-l],c.shape.length-1),f=ja(u,[l,t-l],u.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=l,ve(Nf(h[0],f[0]),d)}const KM=he({rfft_:lxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cxe(n,e){let t=j(n,"a","squaredDifference"),r=j(e,"b","squaredDifference");[t,r]=ks(t,r),ln(t.shape,r.shape);const s={a:t,b:r},i={};return ue.runKernel(ky,s,i)}const Iz=he({squaredDifference_:cxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uxe(n,e){const t=j(n,"x","squeeze","string_or_numeric");return ve(t,Lf(t.shape,e).newShape)}const vr=he({squeeze_:uxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hxe(n,e=0){const t=w_(n,"tensors","stack","string_or_numeric");U(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&U(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return ue.runKernel(uw,r,s)}const xa=he({stack_:hxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe(n,e=0){const r={x:j(n,"x","step")},s={alpha:e};return ue.runKernel(My,r,s)}const Mw=he({step_:fxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(n,e,t,r,s=0,i=0,o=0,a=0,l=0){const u={x:j(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return ue.runKernel(F2,u,h)}const XK=he({stridedSlice_:dxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe(n){const t={x:j(n,"x","tan","float32")};return ue.runKernel(Ey,t)}const KK=he({tan_:pxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n,e){Pg(n);const t=bh(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ip(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qa(n,e,t){if(Pg(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=bh(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ip(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Az(n,e,t){if(Pg(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=bh(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ip(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YK(n,e,t){if(Pg(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=bh(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ip(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZK(n,e,t){if(Pg(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=bh(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ip(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JK(n,e,t){if(Pg(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=bh(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Ip(n,e,r,t)}function Mz(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(i+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(i+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function YM(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Mz(t,e,n)}function Fu(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=t.length;let o=1;for(let h=s;h<i;++h)o*=t[h];const a=s<1?1:s,l=Te(e.shape)/a,c=[...Jt(t.slice(0,s)),1],u=Te(t);return{sliceRank:s,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}const mxe=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:Fu,validateInput:YM,validateUpdateShape:Mz},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gxe(n,e,t){const r=j(n,"tensor","tensorScatterupdate"),s=j(e,"indices","tensorScatterupdate","int32"),i=j(t,"updates","tensorScatterupdate");if(YM(i,s,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);const o={tensor:r,indices:s,updates:i},a={};return ue.runKernel(M2,o,a)}const QK=he({tensorScatterUpdate_:gxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yxe(n,e=1,t=!0){const r=j(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},o={k:e,sorted:t},[a,l]=ue.runKernel(z2,i,o);return{values:a,indices:l}}const eY=he({topk_:yxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe(n,e=0,t=1,r,s){if(Ja(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new vz(e,t,r,!0,s),o=Sn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const ZM=he({truncatedNormal_:bxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(n,e=0){const t=j(n,"x","unique","string_or_numeric");U(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[i,o]=ue.runKernel(MM,r,s);return{values:i,indices:o}}const tY=he({unique_:vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wxe(n,e,t){const r=j(n,"x","unsortedSegmentSum"),s=j(e,"segmentIds","unsortedSegmentSum","int32");U(tg(t),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:s},o={numSegments:t};return ue.runKernel(kw,i,o)}const Nz=he({unsortedSegmentSum_:wxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(n,e=0){const t=j(n,"x","unstack","string_or_numeric");U(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return ue.runKernel(Cw,r,s)}const kc=he({unstack_:xxe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nY(n,e){return UM(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $z(n,e=!0,t,r){return ue.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JM(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const r=Sn(n,"int32"),s=Sn([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=r.indexToLoc(t[i]),a=i*n.length;s.values.set(o,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function _xe(n){const e=j(n,"condition","whereAsync","bool"),t=await e.data(),r=JM(e.shape,t);return n!==e&&e.dispose(),r}const Rz=_xe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Sxe(n,e,t){const r=j(n,"tensor","boolMask"),s=j(e,"mask","boolMask","bool"),i=t??0,o=s.rank,a=r.shape;U(o>0,()=>"mask cannot be scalar"),qi(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=ve(r,c),h=ve(s,[-1]),f=await Rz(h),d=vr(f,[1]),p=Z2(u,d,i);return n!==r&&r.dispose(),e!==s&&s.dispose(),d.dispose(),u.dispose(),h.dispose(),f.dispose(),p}const rY=Sxe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cxe(n,e,t){const r=j(n,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),U(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{U(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return r.dtype==="complex64"?Se(()=>{let o=Kb(r),a=J2(r);return o=ue.runKernel(Vd,{x:o},i),a=ue.runKernel(Vd,{x:a},i),t&&(a=us(a)),Nf(o,a)}):ue.runKernel(Vd,s,i)}const rr=he({transpose_:Cxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kxe(n,e,t,r,s=!0){const i=j(n,"v","movingAverage"),o=j(e,"x","movingAverage"),a=j(t,"decay","movingAverage");SX(i,o),U(Rn(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=en(1),c=Dt(l,a);let u=fe(Dt(o,i),c);if(s){U(r!=null,()=>"When using zeroDebias: true, step is required.");const h=j(r,"step","movingAverage");u=Lt(u,Dt(l,ip(a,h)))}return qe(i,u)}const sY=he({movingAverage_:kxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(n,e,t){Ja(t);const r=j(n,"indices","scatterND","int32"),s=j(e,"updates","scatterND");YM(s,r,t);const i={indices:r,updates:s},o={shape:t};return ue.runKernel(A2,i,o)}const iY=he({scatterND_:Txe});function Exe(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ixe(n,e,t,r=0){Ja(t);const s=j(n,"sparseIndices","sparseToDense","int32"),i=j(e,"sparseValues","sparseToDense","string_or_numeric"),o=j(r,"defaultValue","sparseToDense",i.dtype);Exe(s,i,t,o);const a={sparseIndices:s,sparseValues:i,defaultValue:o},l={outputShape:t};return ue.runKernel(P2,a,l)}const oY=he({sparseToDense_:Ixe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(n,e){const t=j(e,"indices","gatherND","int32"),s={params:j(n,"x","gatherND","string_or_numeric"),indices:t};return ue.runKernel(p2,s)}const aY=he({gatherND_:Axe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mxe(n,e){if(e==null)return n.shape.slice();if(Rn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(n,e,t,r){const s=j(n,"x","dropout");if(U(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),U(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof jn?s.clone():s;const i=Mxe(s,t),o=1-e,a=Lt(Y2(qe(Np(i,0,1,"float32",r),o)),o);return fe(s,a)}const Pz=he({dropout_:Nxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dz(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function QM(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=e-t*Math.cos(o)}return Ks(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $xe(n,e,t=1){const r=j(n,"predictions","inTopK"),s=j(e,"targets","inTopK");U(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),U(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),qi(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];U(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const o=await r.data(),a=await s.data(),[l,c]=[o.length/i,i],u=ci("bool",l);for(let h=0;h<l;h++){const f=h*c,d=o.subarray(f,f+c),p=[];for(let m=0;m<d.length;m++)p.push({value:d[m],index:m});p.sort((m,g)=>g.value-m.value),u[h]=0;for(let m=0;m<t;m++)if(p[m].index===a[h]){u[h]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),Ei(u,s.shape,"bool")}const lY=$xe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rxe(n,e,t,r,s,i="NHWC",o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]])),U(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),U(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),U(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],u=i==="NHWC"?l.shape[3]:l.shape[1];U(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),U(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),ta("conv2dDerFilter",s,o);const h={x:a,dy:l},f={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:t};return ue.runKernel(JS,h,f)}const Oz=he({conv2DBackpropFilter_:Rxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return fe(n,Mw(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function tN(n,e){let t=e;const r=ui(n.shape,e.shape);return r.length>0&&(t=Yt(t,r)),ve(t,n.shape)}function nN(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Nh(n);if(e==="elu")return K2(n);if(e==="relu6")return wz(n);if(e==="prelu")return HM(n,t);if(e==="leakyrelu")return FM(n,r);if(e==="sigmoid")return kl(n);throw new Error(`Unknown fused activation ${e}.`)}const rN=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pxe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",rN(ue.state.gradientDepth,l)===!1){U(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=sp(n,e,t,r,s,i,o);return a!=null&&(C=qe(C,a)),nN(C,l,c,u)}const h=j(n,"x","conv2d","float32"),f=j(e,"filter","conv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),ta("fused conv2d",r,o);const m=s==="NHWC"?d.shape[3]:d.shape[1];U(f.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${f.shape[2]}.`),U(Ri(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const g=ts(d.shape,f.shape,t,i,r,o);let y;a!=null&&(y=j(a,"bias","fused conv2d"),[y]=ks(y,h),s==="NHWC"?ln(g.outShape,y.shape):(U(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),U(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(c!=null){const C=c.shape;if(U(C.length<=1||C.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),C.length===1)U(C[0]===1||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(C.length===3)try{ln(C,g.outShape)}catch{const A=`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(A)}b=j(c,"prelu weights","fused conv2d")}const x=(C,k)=>{U(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[A,M,E,N]=k,O=eN(C,E,l);U(rp(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const R=ez(M.shape,O,A,t,r),D=Oz(M,O,A.shape,t,r),z=[R,D];if(N!=null){const B=tN(N,O);z.push(B)}return z},w={x:d,filter:f,bias:y,preluActivationWeights:b},S={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?vh((k,A,M)=>{let E=ue.runKernel(Ub,w,S);return M([A,k,E]),p&&(E=ve(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(d,f):vh((k,A,M,E)=>{let N=ue.runKernel(Ub,w,S);return E([A,k,N,M]),p&&(N=ve(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:x}})(d,f,y)}const cY=he({fusedConv2d_:Pxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(n,e,t,r,s,i=[1,1],o){let a=n;n.rank===3&&(a=ve(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:t};return ue.runKernel(i2,c,u)}const uY=he({depthwiseConv2dNativeBackpropFilter_:Dxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(n,e,t,r,s,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=ve(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n},h=ue.runKernel(o2,c,u);return l?ve(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const hY=he({depthwiseConv2dNativeBackpropInput_:Oxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fxe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(rN(ue.state.gradientDepth,l)===!1){let S=X2(n,e,t,r,s,i,o);return a!=null&&(S=qe(S,a)),nN(S,l,c,u)}const h=j(n,"x","depthwiseConv2d","float32"),f=j(e,"filter","depthwiseConv2d","float32");let d=h,p=!1;h.rank===3&&(p=!0,d=ve(h,[1,h.shape[0],h.shape[1],h.shape[2]])),U(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),U(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),U(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),i==null&&(i=[1,1]),U(Ri(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ta("fused depthwiseConv2d",r,o);const m=ts(d.shape,f.shape,t,i,r,o,!0);let g;a!=null&&(g=j(a,"bias","fused conv2d"),[g]=ks(g,h),ln(m.outShape,g.shape));let y;c!=null&&(y=j(c,"prelu weights","fused depthwiseConv2d"));const b=(S,C)=>{U(rp(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[k,A,M,E]=C,N=eN(S,M,l),O=hY(A.shape,N,k,t,r,i,o),R=uY(A,N,k.shape,t,r,i,o);if(E!=null){const D=tN(g,N);return[O,R,D]}return[O,R]},x={x:d,filter:f,bias:g,preluActivationWeights:y},w={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?vh((C,k,A)=>{let M=ue.runKernel(Wb,x,w);return A([k,C,M]),p&&(M=ve(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(d,f):vh((C,k,A,M)=>{let E=ue.runKernel(Wb,x,w);return M([k,C,E,A]),p&&(E=ve(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(d,f,g)}const Lxe=he({fusedDepthwiseConv2d_:Fxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zxe({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(rN(ue.state.gradientDepth,i)===!1){let N=Hn(n,e,t,r);return s!=null&&(N=qe(N,s)),nN(N,i,o,a)}let l=j(n,"a","fused matMul"),c=j(e,"b","fused matMul");[l,c]=ks(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=t?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=Te(p),y=Te(m);U(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${r} must match.`);const x=ln(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,d]),w=t?ve(l,[g,u,f]):ve(l,[g,f,u]),S=r?ve(c,[y,d,h]):ve(c,[y,h,d]);let C;s!=null&&(C=j(s,"bias","fused matMul"),[C]=ks(C,l),ln(x,C.shape));let k;o!=null&&(k=j(o,"prelu weights","fused matMul"));const A=(N,O)=>{const[R,D,z,B]=O,X=eN(ve(N,z.shape),z,i);let G,te;if(!t&&!r?(G=Hn(X,D,!1,!0),te=Hn(R,X,!0,!1)):!t&&r?(G=Hn(X,D,!1,!1),te=Hn(X,R,!0,!1)):t&&!r?(G=Hn(D,X,!1,!0),te=Hn(R,X,!1,!1)):(G=Hn(D,X,!0,!0),te=Hn(X,R,!0,!0)),s!=null){const ge=tN(B,X);return[G,te,ge]}else return[G,te]},M={a:w,b:S,bias:C,preluActivationWeights:k},E={transposeA:t,transposeB:r,activation:i,leakyreluAlpha:a};return s==null?vh((O,R,D)=>{const z=ue.runKernel(Vb,M,E);return D([O,R,z]),{value:ve(z,x),gradFunc:A}})(w,S):vh((O,R,D,z)=>{const B=ue.runKernel(Vb,M,E);return z([O,R,B,D]),{value:ve(B,x),gradFunc:A}})(w,S,C)}const SD=he({fusedMatMul_:zxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fY=Object.freeze(Object.defineProperty({__proto__:null,conv2d:cY,depthwiseConv2d:Lxe,matMul:SD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(n){return QM(n,.54,.46)}const Vxe=he({hammingWindow_:Bxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uxe(n){return QM(n,.5,.5)}const dY=he({hannWindow_:Uxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wxe(n,e,t,r=!1,s=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(dn(n,i,e)),i+=t;if(r)for(;i<n.size;){const a=i+e-n.size,l=cs([dn(n,i,e-a),$y([a],s)]);o.push(l),i+=t}return o.length===0?qa([],[0,e]):ve(cs(o),[o.length,e])}const pY=he({frame_:Wxe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gxe(n,e,t,r,s=dY){r==null&&(r=Dz(e));const i=pY(n,e,t),o=fe(i,s(e));return KM(o,r)}const Hxe=he({stft_:Gxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jxe(n,e,t,r,s="bilinear",i=0){const o=j(n,"image","cropAndResize"),a=j(e,"boxes","cropAndResize","float32"),l=j(t,"boxInd","cropAndResize","int32"),c=a.shape[0];U(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),U(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),U(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),U(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),U(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const u={image:o,boxes:a,boxInd:l},h={method:s,extrapolationValue:i,cropSize:r};return ue.runKernel(n2,u,h)}const qxe=he({cropAndResize_:jxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xxe(n){const e=j(n,"image","flipLeftRight","float32");U(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return ue.runKernel(d2,t,{})}const Kxe=he({flipLeftRight_:Xxe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yxe(n){const e=j(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),U(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,fc(e,s)}const Zxe=he({grayscaleToRGB_:Yxe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jxe(n){const e=j(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];U(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),U(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,i=wt(e,"float32"),o=Ks([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Nm("ij,j->i",i,o);break;case 3:a=Nm("ijk,k->ij",i,o);break;case 4:a=Nm("ijkl,l->ijk",i,o);break;case 5:a=Nm("ijklm,m->ijkl",i,o);break;case 6:a=Nm("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=oi(a,-1),wt(a,s)}const Qxe=he({rgbToGrayscale_:Jxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e(n,e,t=0,r=.5){const s=j(n,"image","rotateWithOffset","float32");U(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},o={radians:e,fillValue:t,center:r};return ue.runKernel(V2,i,o)}const t1e=he({rotateWithOffset_:e1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n,e,t,r,s,i){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),U(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),U(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),U(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),U(e.rank===1,()=>"scores must be a 1D tensor"),U(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),U(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=j(n,"boxes","nonMaxSuppression","float32"),o=j(e,"scores","nonMaxSuppression","float32"),a=Nw(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return ue.runKernel(S2,{boxes:i,scores:o},l)}const r1e=he({nonMaxSuppression_:n1e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(n,e,t){const r=i1e(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function i1e(n,e,t){return a1e(n,e,t||o1e)}function o1e(n,e){return n>e?1:n<e?-1:0}function a1e(n,e,t){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=t(e,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC(n,e,t,r,s){return Fz(n,e,t,r,s,0)}function sN(n,e,t,r,s,i){return Fz(n,e,t,r,s,0,!1,i,!0)}function sC(n,e,t,r,s,i){return Fz(n,e,t,r,s,i,!0)}function Fz(n,e,t,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<e.length;g++)e[g]>s&&c.push({score:e[g],boxIndex:g,suppressBeginIndex:0});c.sort(lG);const u=i>0?-.5/i:0,h=[],f=[];for(;h.length<t&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let w=!1;for(let S=h.length-1;S>=x;--S){const C=l1e(n,b,h[S]);if(C>=r){w=!0;break}if(g.score=g.score*c1e(r,u,C),g.score<=s)break}g.suppressBeginIndex=h.length,w||(g.score===y?(h.push(b),f.push(g.score)):g.score>s&&s1e(c,g,lG))}const d=h.length,p=t-d;a&&p>0&&(h.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=f),l&&(m.validOutputs=d),m}function l1e(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),f=Math.max(s[1],s[3]),d=(a-i)*(l-o),p=(h-c)*(f-u);if(d<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,h),b=Math.min(l,f),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(d+p-x)}function c1e(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function lG(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function u1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=j(n,"boxes","nonMaxSuppressionAsync"),o=j(e,"scores","nonMaxSuppressionAsync"),a=Nw(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=rC(c,u,t,r,s);return i!==n&&i.dispose(),o!==e&&o.dispose(),Ks(h,"int32")}const h1e=u1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Nw(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i},h=ue.runKernel(C2,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const d1e=he({nonMaxSuppressionWithScore_:f1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function p1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Nw(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:f,selectedScores:d}=sC(u,h,t,r,s,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Ks(f,"int32"),selectedScores:Ks(d)}}const m1e=p1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=j(n,"boxes","nonMaxSuppression"),a=j(e,"scores","nonMaxSuppression"),l=Nw(o,a,t,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,f={boxes:o,scores:a},d={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:i},p=ue.runKernel(_M,f,d);return{selectedIndices:p[0],validOutputs:p[1]}}const y1e=he({nonMaxSuppressionPadded_:g1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function b1e(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=j(n,"boxes","nonMaxSuppressionAsync"),a=j(e,"scores","nonMaxSuppressionAsync"),l=Nw(o,a,t,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[f,d]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=sN(f,d,c,u,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Ks(p,"int32"),validOutputs:en(m,"int32")}}const v1e=b1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1e(n,e,t=!1,r=!1){const s=j(n,"images","resizeBilinear");U(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),U(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),U(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},c=ue.runKernel(gw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const x1e=he({resizeBilinear_:w1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1e(n,e,t=!1,r=!1){const s=j(n,"images","resizeNearestNeighbor");U(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),U(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),U(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=ve(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},c=ue.runKernel(mw,a,l);return o?ve(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const S1e=he({resizeNearestNeighbor_:_1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1e(n,e="binary",t=!1,r=.5){const s=j(n,"image","threshold"),i=.2989,o=.587,a=.114,l=s.shape[0]*s.shape[1];let c=fe(Ks([r]),255),u,h,f,d;if(U(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),U(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),U(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),U(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[u,h,f]=ja(s,[1,1,1],-1);const g=fe(u,i),y=fe(h,o),b=fe(f,a);d=qe(qe(g,y),b)}else d=n;if(e==="otsu"){const g=XL(wt(xz(d),"int32"),Ei([]),256);c=k1e(g,l)}const p=t?Ry(d,c):tl(d,c);return wt(fe(p,255),"int32")}function k1e(n,e){let t=Ks([-1]),r=Ks([0]),s=Ks([0]),i,o,a,l,c,u;for(let h=0;h<n.size-1;h++){i=dn(n,0,h+1),o=dn(n,h+1),c=Lt(Yt(i),e),u=Lt(Yt(o),e);const f=Yt(fe(i,ag(0,i.size)));a=Lt(f,Yt(i));const d=$y(o.shape,i.size),p=qe(ag(0,o.size),d),m=fe(o,p);l=Lt(Yt(m),Yt(o));const g=Dt(a,l),y=Dt(a,l),b=fe(c,u);s=fe(fe(b,g),y);const x=tl(s,r);r=_o(x,s,r),t=_o(x,Ks([h]),t)}return t}const T1e=he({threshold_:C1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1e(n,e,t="nearest",r="constant",s=0,i){const o=j(n,"image","transform","float32"),a=j(e,"transforms","transform","float32");U(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),U(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:r,fillValue:s,outputShape:i};return ue.runKernel(B2,l,c)}const I1e=he({transform_:E1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(n,e,t){const r=j(n,"a","bandPart");U(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(U(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),U(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=j(e<0?i:e,"numLower","bandPart")):(U(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=_o(k_(e,0),i,op(e,i))),typeof t=="number"?(U(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),U(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=j(t<0?o:t,"numUpper","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=_o(k_(t,0),o,op(t,o)));const c=ve(ag(0,i,1,"int32"),[-1,1]),u=ag(0,o,1,"int32"),h=Dt(c,u),f=wh(Ry(h,a),Mp(h,us(l))),d=ms([i,o],r.dtype);return ve(xa(kc(ve(r,[-1,i,o])).map(p=>_o(f,p,d))),s)}const M1e=he({bandPart_:A1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(n){let e;if(Array.isArray(n)){e=!1,U(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)U(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else e=!0,n=ja(n,n.shape[0],0).map(s=>vr(s,[0]));U(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(ue.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=fe(Yt(fe(t[o],i)),t[o]);i=Dt(i,a)}return Lt(i,Ew(i,"euclidean"))}));return e?xa(t,0):t}const $1e=he({gramSchmidt_:N1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1e(n,e=!1){if(U(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return cG(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=kc(ve(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];r.forEach(l=>{const[c,u]=cG(l,e);s.push(c),i.push(u)});const o=ve(xa(s,0),n.shape),a=ve(xa(i,0),n.shape);return[o,a]}}function cG(n,e=!1){return ue.tidy(()=>{U(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=OM(t),i=dh(n);const o=qa([[1]],[1,1]);let a=dh(o);const l=t>=r?r:t;for(let c=0;c<l;++c){const u=i,h=a,f=s;[a,i,s]=ue.tidy(()=>{const d=dn(i,[c,c],[t-c,1]),p=Ew(d),m=dn(i,[c,c],[1,1]),g=_o(tl(m,0),qa([[-1]]),qa([[1]])),y=Dt(m,fe(g,p)),b=Lt(d,y);b.shape[0]===1?a=dh(o):a=cs([o,dn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const x=us(Lt(Hn(g,y),p)),w=dn(i,[c,0],[t-c,r]),S=fe(x,a),C=rr(a);if(c===0)i=Dt(w,Hn(S,Hn(C,w)));else{const M=Dt(w,Hn(S,Hn(C,w)));i=cs([dn(i,[0,0],[c,r]),M],0)}const k=rr(S),A=dn(s,[0,c],[t,s.shape[1]-c]);if(c===0)s=Dt(A,Hn(Hn(A,a),k));else{const M=Dt(A,Hn(Hn(A,a),k));s=cs([dn(s,[0,0],[t,c]),M],1)}return[a,i,s]}),nn([u,h,f])}return!e&&t>r&&(s=dn(s,[0,0],[t,r]),i=dn(i,[0,0],[r,r])),[s,i]})}const P1e=he({qr_:R1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Uo;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Uo||(Uo={}));function D1e(n,e,t=Uo.SUM_BY_NONZERO_WEIGHTS){const r=j(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=j(e,"weights","computeWeightedLoss"));const i=s==null?r:fe(r,s);if(t===Uo.NONE)return i;if(t===Uo.SUM)return Yt(i);if(t===Uo.MEAN){if(s==null)return Ds(i);{const o=r.size/s.size,a=Lt(Yt(i),Yt(s));return o>1?Lt(a,en(o)):a}}if(t===Uo.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Lt(Yt(i),en(r.size));{const o=fe(s,pa(r.shape)),a=wt(Yt(qb(o,en(0))),"float32");return Lt(Yt(i),a)}}throw Error(`Unknown reduction: ${t}`)}const Uf=he({computeWeightedLoss_:D1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1e(n,e,t,r=Uo.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","absoluteDifference"),i=j(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=j(t,"weights","absoluteDifference")),qi(s.shape,i.shape,"Error in absoluteDifference: ");const a=wi(Dt(s,i));return Uf(a,o,r)}const F1e=he({absoluteDifference_:O1e});function L1e(n,e,t,r,s=Uo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","cosineDistance"),o=j(e,"predictions","cosineDistance");let a=null;r!=null&&(a=j(r,"weights","cosineDistance")),qi(i.shape,o.shape,"Error in cosineDistance: ");const l=en(1),c=Dt(l,Yt(fe(i,o),t,!0));return Uf(c,a,s)}const z1e=he({cosineDistance_:L1e});function B1e(n,e,t,r=Uo.SUM_BY_NONZERO_WEIGHTS){let s=j(n,"labels","hingeLoss");const i=j(e,"predictions","hingeLoss");let o=null;t!=null&&(o=j(t,"weights","hingeLoss")),qi(s.shape,i.shape,"Error in hingeLoss: ");const a=en(1);s=Dt(fe(en(2),s),a);const l=Nh(Dt(a,fe(s,i)));return Uf(l,o,r)}const V1e=he({hingeLoss_:B1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1e(n,e,t,r=1,s=Uo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","huberLoss"),o=j(e,"predictions","huberLoss");let a=null;t!=null&&(a=j(t,"weights","huberLoss")),qi(i.shape,o.shape,"Error in huberLoss: ");const l=en(r),c=wi(Dt(o,i)),u=op(c,l),h=Dt(c,u),f=qe(fe(en(.5),Or(u)),fe(l,h));return Uf(f,a,s)}const W1e=he({huberLoss_:U1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1e(n,e,t,r=1e-7,s=Uo.SUM_BY_NONZERO_WEIGHTS){const i=j(n,"labels","logLoss"),o=j(e,"predictions","logLoss");let a=null;t!=null&&(a=j(t,"weights","logLoss")),qi(i.shape,o.shape,"Error in logLoss: ");const l=en(1),c=en(r),u=us(fe(i,Al(qe(o,c)))),h=fe(Dt(l,i),Al(qe(Dt(l,o),c))),f=Dt(u,h);return Uf(f,a,s)}const H1e=he({logLoss_:G1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1e(n,e,t,r=Uo.SUM_BY_NONZERO_WEIGHTS){const s=j(n,"labels","meanSquaredError"),i=j(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=j(t,"weights","meanSquaredError")),qi(s.shape,i.shape,"Error in meanSquaredError: ");const a=Iz(s,i);return Uf(a,o,r)}const q1e=he({meanSquaredError_:j1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X1e(n,e){const t=j(n,"labels","sigmoidCrossEntropyWithLogits"),r=j(e,"logits","sigmoidCrossEntropyWithLogits");qi(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Nh(r),i=fe(r,t),o=LM(Yo(us(wi(r))));return qe(Dt(s,i),o)}function K1e(n,e,t,r=0,s=Uo.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"multiClassLabels","sigmoidCrossEntropy");const o=j(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","sigmoidCrossEntropy")),qi(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=en(r),u=en(1),h=en(.5);i=qe(fe(i,Dt(u,c)),fe(h,c))}const l=X1e(i,o);return Uf(l,a,s)}const Y1e=he({sigmoidCrossEntropy_:K1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1e(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return vh((s,i,o)=>{const l=BM(i,[t],!0),c=Dt(wt(i,"float32"),l);o([s,c]);const u=us(fe(c,s));return{value:Yt(u,[t]),gradFunc:(d,p)=>{const[m,g]=p,y=Ls(d.shape,[t]);return[fe(ve(d,y),Dt(wt(m,"float32"),Yo(g))),fe(ve(d,y),Dt(Yo(g),wt(m,"float32")))]}}})(n,e)}function J1e(n,e,t,r=0,s=Uo.SUM_BY_NONZERO_WEIGHTS){let i=j(n,"onehotLabels","softmaxCrossEntropy");const o=j(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=j(t,"weights","softmaxCrossEntropy")),qi(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=en(r),u=en(1),h=en(i.shape[1]);i=qe(fe(i,Dt(u,c)),Lt(c,h))}const l=Z1e(i,o);return Uf(l,a,s)}const Q1e=he({softmaxCrossEntropy_:J1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_e(n,e,t,r){const s=j(n,"indices","sparseFillEmptyRows","int32"),i=j(e,"values","sparseFillEmptyRows"),o=j(t,"denseShape","sparseFillEmptyRows","int32"),a=j(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:i,denseShape:o,defaultValue:a},c=ue.runKernel(TM,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const t_e=he({sparseFillEmptyRows_:e_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n_e(n,e,t){const r=j(n,"inputIndices","sparseReshape","int32"),s=j(e,"inputShape","sparseReshape","int32"),i=j(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:r,inputShape:s,newShape:i},a=ue.runKernel(EM,o);return{outputIndices:a[0],outputShape:a[1]}}const r_e=he({sparseReshape_:n_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_e(n,e,t){const r=j(n,"data","sparseSegmentMean"),s=j(e,"indices","sparseSegmentMean","int32"),i=j(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return ue.runKernel($2,o)}const i_e=he({sparseSegmentMean_:s_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_e(n,e,t){const r=j(n,"data","sparseSegmentSum"),s=j(e,"indices","sparseSegmentSum","int32"),i=j(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return ue.runKernel(R2,o)}const a_e=he({sparseSegmentSum_:o_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_e(n,e,t,r,s,i,o,a){const l=j(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=j(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},f=ue.runKernel(L2,h,u);return{nGrams:f[0],nGramsSplits:f[1]}}const c_e=he({stringNGrams_:l_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_e(n,e,t=!0){const r=j(n,"input","stringSplit","string"),s=j(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:t},o={input:r,delimiter:s},a=ue.runKernel(IM,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const h_e=he({stringSplit_:u_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_e(n,e){const t=j(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return ue.runKernel(AM,s,r)}const d_e=he({stringToHashBucketFast_:f_e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_e(n,e,t,r=!0){const s=j(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:r};return ue.runKernel(O2,{x:s},i)}const m_e=he({staticRegexReplace_:p_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mY={fft:XM,ifft:T_,rfft:KM,irfft:Ez},gY={hammingWindow:Vxe,hannWindow:dY,frame:pY,stft:Hxe},Ci={flipLeftRight:Kxe,grayscaleToRGB:Zxe,resizeNearestNeighbor:S1e,resizeBilinear:x1e,rgbToGrayscale:Qxe,rotateWithOffset:t1e,cropAndResize:qxe,nonMaxSuppression:r1e,nonMaxSuppressionAsync:h1e,nonMaxSuppressionWithScore:d1e,nonMaxSuppressionWithScoreAsync:m1e,nonMaxSuppressionPadded:y1e,nonMaxSuppressionPaddedAsync:v1e,threshold:T1e,transform:I1e},Lz={bandPart:M1e,gramSchmidt:$1e,qr:P1e},yY={absoluteDifference:F1e,computeWeightedLoss:Uf,cosineDistance:z1e,hingeLoss:V1e,huberLoss:W1e,logLoss:H1e,meanSquaredError:q1e,sigmoidCrossEntropy:Y1e,softmaxCrossEntropy:Q1e},bY={sparseFillEmptyRows:t_e,sparseReshape:r_e,sparseSegmentMean:i_e,sparseSegmentSum:a_e},vY={stringNGrams:c_e,stringSplit:h_e,stringToHashBucketFast:d_e,staticRegexReplace:m_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g_e=new Map,CD=new Map;class Dy{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class vl{constructor(){this.classNameMap={}}static getMap(){return vl.instance==null&&(vl.instance=new vl),vl.instance}static register(e){vl.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ot(n,e,t){U(n.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),U(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return vl.register(n),g_e.set(s,n),CD.set(n,s),n}function y_e(n){return CD.has(n)?CD.get(n):n.className}const b_e=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Dy,SerializationMap:vl,getRegisteredName:y_e,registerClass:ot},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wf extends Dy{minimize(e,t=!1,r){const{value:s,grads:i}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return nn(i),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return pK(e,t)}dispose(){this.iterations_!=null&&nn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:en(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Wf,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zz extends Wf{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Se(()=>lr(i).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Se(()=>lr(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,c=this.accumulatedUpdates[s].variable;Se(()=>{const u=qe(fe(l,this.rho),fe(Or(a),1-this.rho)),h=fe(Lt(So(qe(c,this.epsilon)),So(qe(l,this.epsilon))),a),f=qe(fe(c,this.rho),fe(Or(h),1-this.rho));l.assign(u),c.assign(f);const d=qe(fe(h,-this.learningRate),i);i.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nn(this.accumulatedGrads.map(e=>e.variable)),nn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bz extends Wf{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Se(()=>$y(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[s].variable;Se(()=>{const l=qe(a,Or(o));a.assign(l);const c=qe(fe(Lt(o,So(qe(l,ue.backend.epsilon()))),-this.learningRate),i);i.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vz extends Wf{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Se(()=>{this.accBeta1=en(t).variable(),this.accBeta2=en(r).variable()}),s==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Dt(1,this.accBeta1),s=Dt(1,this.accBeta2);t.forEach((i,o)=>{const a=ue.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Se(()=>lr(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:Se(()=>lr(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,f=qe(fe(u,this.beta1),fe(c,1-this.beta1)),d=qe(fe(h,this.beta2),fe(Or(c),1-this.beta2)),p=Lt(f,r),m=Lt(d,s);u.assign(f),h.assign(d);const g=qe(fe(Lt(p,qe(So(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(fe(this.accBeta1,this.beta1)),this.accBeta2.assign(fe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&nn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Se(()=>{this.accBeta1.assign(ip(this.beta1,this.iterations_+1)),this.accBeta2.assign(ip(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uz extends Wf{static get className(){return"Adamax"}constructor(e,t,r,s=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Se(()=>{this.iteration=en(0).variable(),this.accBeta1=en(t).variable()}),s==null&&(this.epsilon=ue.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Se(()=>{const r=Dt(1,this.accBeta1),s=Lt(-this.learningRate,qe(fe(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=ue.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:lr(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:lr(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[i];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,f=qe(fe(u,this.beta1),fe(c,1-this.beta1)),d=fe(h,this.beta2),p=wi(c),m=Vf(d,p);u.assign(f),h.assign(m);const g=qe(fe(Lt(s,r),Lt(f,qe(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(qe(this.iteration,1)),this.accBeta1.assign(fe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&nn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iN extends Wf{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const o=ue.registeredVariables[r];Se(()=>{const a=qe(fe(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Xs(en(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wz extends iN{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=en(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Se(()=>lr(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&Se(()=>{let l;const c=qe(fe(this.m,o),a);this.useNesterov?l=qe(fe(this.c,qe(a,fe(c,this.m))),i):l=qe(fe(this.c,c),i),o.assign(c),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gz extends Wf{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=ue.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=ue.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Se(()=>lr(i).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Se(()=>lr(i).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Se(()=>lr(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,c=this.accumulatedMoments[s].variable;Se(()=>{const u=qe(fe(l,this.decay),fe(Or(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,f=qe(fe(h,this.decay),fe(a,1-this.decay)),d=Lt(fe(a,this.learningRate),So(Dt(u,qe(Or(f),this.epsilon)))),p=qe(fe(c,this.momentum),d);l.assign(u),h.assign(f),c.assign(p);const m=Dt(i,p);i.assign(m)}else{const h=qe(fe(l,this.decay),fe(Or(a),1-this.decay)),f=qe(fe(c,this.momentum),Lt(fe(a,this.learningRate),So(qe(h,this.epsilon))));l.assign(h),c.assign(f);const d=Dt(i,f);i.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&nn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v_e=[zz,Bz,Vz,Uz,Wz,Gz,iN];function w_e(){for(const n of v_e)ot(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x_e="model",__e=".json",S_e=".weights.bin";function uG(n){return new Promise(e=>setTimeout(e)).then(n)}class lg{constructor(e){if(!Ee().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(lg.URL_SCHEME)&&(e=e.slice(lg.URL_SCHEME.length)),(e==null||e.length===0)&&(e=x_e),this.modelJsonFileName=e+__e,this.weightDataFileName=e+S_e}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Du.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=IX(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await uG(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await uG(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:H2(e)}}}}lg.URL_SCHEME="downloads://";class C_e{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=OL(i,c=>this.loadWeights(c));e(l)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;r(a)},i.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(i=>aG(i.name)),s={};for(const i of e)i.paths.forEach(o=>{const a=aG(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const k_e=n=>Ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(lg.URL_SCHEME)?T_e(n.slice(lg.URL_SCHEME.length)):null;_s.registerSaveRouter(k_e);function T_e(n="model"){return new lg(n)}function wY(n){return new C_e(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hG(n,e,t,r){o(n),t=t??0,r=r??1,a(t,r);let s=0;const i=l=>(l.then(c=>{const u=t+ ++s/n.length*(r-t);return e(u),c}),l);function o(l){U(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){U(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),U(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),U(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function xY(n,e){e==null&&(e={});const t=e.fetchFunc==null?Ee().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),s=0,i=.5,a=(e.onProgress==null?await Promise.all(r):await hG(r,e.onProgress,s,i)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await hG(a,e.onProgress,l,c)}async function E_e(n,e="",t,r){return _Y(o=>xY(o,{requestInit:r}))(n,e,t)}function _Y(n){return async(e,t="",r)=>{const s=e.map(()=>!1),i={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((d,p)=>{let m=0;d.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,b=gD[y]*Te(g.shape),x=()=>{s[p]=!0,i[p]==null&&(i[p]=[]),i[p].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((w,S)=>{w===g.name&&(x(),o[S]=!0)}):x(),a.push(g.name),m+=b})}),!o.every(d=>d)){const d=r.filter((p,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((d,p,m)=>(p&&d.push(m),d),[]),c=[];l.forEach(d=>{e[d].paths.forEach(p=>{const m=t+(t.endsWith("/")?"":"/")+p;c.push(m)})});const u=await n(c),h={};let f=0;return l.forEach(d=>{const p=e[d].paths.length,m=new Du(u.slice(f,f+p));i[d].forEach(y=>{const b=m.slice(y.groupOffset,y.groupOffset+y.sizeBytes),x=RL(b,[y.manifestEntry]);for(const w in x)h[w]=x[w]}),f+=p}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I_e="application/octet-stream",A_e="application/json";class Hz{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(U(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ee().platform.fetch,U(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&U(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=IX(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:A_e}),"model.json"),e.weightData!=null){const o=Du.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:I_e}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:H2(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return OL(t,i=>this.loadWeights(i))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=M_e(t),i=this.weightPathPrefix||r,o=FL(e),a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(i+h+s);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await xY(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,c]}}Hz.URL_SCHEME_REGEX=/^https?:\/\//;function M_e(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function kD(n){return n.match(Hz.URL_SCHEME_REGEX)!=null}const SY=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>kD(r)):t=kD(n),t)return oN(n,e)}return null};_s.registerSaveRouter(SY);_s.registerLoadRouter(SY);function oN(n,e){return new Hz(n,e)}function CY(n,e){return oN(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o3{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class kY{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class N_e{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function $_e(n,e,t,r){const s=arguments;return new N_e(AI(...s))}function AI(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new o3(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new o3({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new o3({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function TY(n){return new kY(n)}function R_e(n){return new kY(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jz=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Du,browserFiles:wY,browserHTTPRequest:CY,concatenateArrayBuffers:EX,copyModel:n0e,decodeWeights:RL,encodeWeights:yD,fromMemory:$_e,fromMemorySync:AI,getLoadHandlers:MX,getModelArtifactsForJSON:OL,getModelArtifactsForJSONSync:DL,getModelArtifactsInfoForJSON:H2,getSaveHandlers:AX,getWeightSpecs:FL,http:oN,isHTTPScheme:kD,listModels:LL,loadWeights:E_e,moveModel:r0e,registerLoadRouter:Gye,registerSaveRouter:Wye,removeModel:zL,weightsLoaderFactory:_Y,withSaveHandler:TY,withSaveHandlerSync:R_e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_e(n,e,t){const r=j(n,"labels","confusionMatrix"),s=j(e,"predictions","confusionMatrix");U(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),U(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),U(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),U(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),U(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const i=Xb(wt(r,"int32"),t),o=Xb(wt(s,"int32"),t),a=rr(i),l=Hn(a,o);return wt(l,"int32")}const D_e=he({confusionMatrix_:P_e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_e=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:D_e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nm,fG=!1;function EY(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(b_(g_,ue.backendName)!=null){const p={pixels:n},m={numChannels:e};return ue.runKernel(g_,p,m)}const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||t)h=n.data;else if(i||s||a){if(nm==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")nm=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else nm=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});nm.canvas.width=c,nm.canvas.height=u,nm.drawImage(n,0,0,c,u),h=nm.getImageData(0,0,c,u).data}let f;if(e===4)f=new Int32Array(h);else{const p=c*u;f=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)f[m*e+g]=h[m*4+g]}return Az(f,[u,c,e],"int32")}function F_e(n){return n!=null&&n.data instanceof Uint8Array}function L_e(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function z_e(n){return n!=null&&n.width!==0&&n.height!==0}function B_e(n){return L_e()&&!(n instanceof ImageBitmap)&&z_e(n)&&!F_e(n)}async function V_e(n,e=3){let t=null;if(Ee().getBool("WRAP_TO_IMAGEBITMAP")&&B_e(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?t=r:t=n}else t=n;return EY(t,e)}function IY(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function U_e(n){const e=(n==null?void 0:n.alpha)||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function iC(n,e){let t=j(n,"img","toPixels");if(!(n instanceof jn)){const c=t;t=wt(c,"int32"),c.dispose()}IY(t);const[r,s]=t.shape.slice(0,2),i=t.rank===2?1:t.shape[2],o=await t.data(),a=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let c=0;c<r*s;++c){const u=[0,0,0,255];for(let f=0;f<i;f++){const d=o[c*i+f];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);i===1?(u[0]=d*a,u[1]=d*a,u[2]=d*a):u[f]=d*a}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){fG||b_(l2,ue.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),fG=!0),e.width=s,e.height=r;const c=e.getContext("2d"),u=new ImageData(l,s,r);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}function W_e(n,e,t){let r=j(n,"img","draw");if(!(n instanceof jn)){const o=r;r=wt(o,"int32"),o.dispose()}IY(r),U_e(t==null?void 0:t.imageOptions);const s={image:r},i={canvas:e,options:t};ue.runKernel(l2,s,i)}const oC=he({fromPixels_:EY}),G_e=Object.freeze(Object.defineProperty({__proto__:null,draw:W_e,fromPixels:oC,fromPixelsAsync:V_e,toPixels:iC},Symbol.toStringTag,{value:"Module"}));function aC(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Te(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,i=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const a=n.shape,l=s.slice();l.pop();let c=1;for(let h=i;h<t;++h)c*=a[h],l.push(a[h]);const u=[...Jt(n.shape).map(h=>h/c),1].slice(0,i);return[l,o,c,u]}const H_e=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:aC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TD=-2,j_e=-1;function aN(n,e,t){const r=n.shape.length;U(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),U(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)U(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function q_e(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function lN(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function AY(n,e,t,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<t;i++)i===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function MY(n,e,t){return t<=n?t:t-(e-1)}function NY(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function X_e(n,e,t,r,s,i,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),f=new Array(c);if(e.length&&t>0){const d=e[0],p=t+1;u=$Y(o,d,p,r,n),h=RY(a,d,p,s,n),f=AY(i,d,p,n)}else for(let d=0;d<c;d++)u[d]=DY(o,r,i,n,d,l),h[d]=OY(a,s,i,n,d,l),f[d]=PY(i,d,l);return{begin:u,end:h,strides:f}}function $Y(n,e,t,r,s){const i=[...s],o=NY(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=MY(e,t,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function RY(n,e,t,r,s){const i=[...s],o=NY(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=MY(e,t,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=ep(0,i[a],s[a])}return i}function PY(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function DY(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=ep(0,o,l-1),o}function OY(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),a>0?o=ep(0,o,l):o=ep(-1,o,l-1),o}function qz(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function Xz(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function lC(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{U(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(s).fill(-1):typeof t=="number"?i=[t,...new Array(s-1).fill(-1)]:t.length<s?i=t.concat(new Array(s-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(U(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function cN(n,e,t,r,s,i,o,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let x=0;x<h.dims;x++)u&&1<<x&a&&h.numAddAxisAfterEllipsis++,1<<x&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};K_e(h,f);let d=!0,p=!0,m=!0;const g=[],y=[];for(let x=0;x<n.length;++x){if(f.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const w=!!(f.shrinkAxisMask&1<<x),S=n[x];if(S===-1){g.push(w?1:-1);continue}const C=[f.beginMask&1<<x,f.endMask&1<<x],k=[f.strides[x]>0?0:-1,f.strides[x]>0?S:S-1];if(w&&f.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&f.strides[x]===1;const A=!!(f.beginMask&1<<x&&f.endMask&1<<x);if(f.beginValid&&f.endValid){if(w){const O=f.begin[x]<0?S+f.begin[x]:f.begin[x];if(f.begin[x]=O,f.end[x]=f.begin[x]+1,O<0||O>=S)throw Error(`slice index ${f.begin[x]} of dimension ${x} out of bounds.`)}else f.begin[x]=dG(f.begin[x],0,f.strides[x],S,C,k),f.end[x]=dG(f.end[x],1,f.strides[x],S,C,k);const N=f.strides[x]===1&&f.begin[x]===0&&f.end[x]===S;d=d&&N,p=p&&(x===0&&f.strides[x]===1||N)}else d=d&&f.strides[x]===1&&A,p=p&&(x===0&&f.strides[x]===1||A);let M,E=!1;if(f.beginValid&&f.endValid?(M=f.end[x]-f.begin[x],E=!0):w?(M=1,E=!0):A&&S>=0&&(f.strides[x]<0?M=-S:M=S,E=!0),E){let N;M===0||M<0!=f.strides[x]<0?N=0:N=Math.trunc(M/f.strides[x])+(M%f.strides[x]!==0?1:0),g.push(N)}else g.push(-1)}for(let x=0;x<f.finalShapeGatherIndices.length;++x){const w=f.finalShapeGatherIndices[x];w>=0?y.push(g[w]):w===TD&&y.push(1)}return{finalShapeSparse:y.filter((x,w)=>f.finalShapeGatherIndices[w]!==TD),finalShape:y,isIdentity:d,sliceDim0:p,isSimpleSlice:m,begin:f.begin,end:f.end,strides:f.strides}}function K_e(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(TD),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(j_e),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function dG(n,e,t,r,s,i){if(s[e])return t>0?i[e]:i[e+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const FY=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:aN,computeFlatOffset:Xz,computeOutShape:lN,getNormalizedAxes:X_e,isSliceContinous:qz,maskToAxes:q_e,parseSliceParams:lC,sliceInfo:cN,startForAxis:DY,startIndicesWithElidedDims:$Y,stopForAxis:OY,stopIndicesWithElidedDims:RY,stridesForAxis:PY,stridesWithElidedDims:AY},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const Y_e="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LY{static sgd(e){return new iN(e)}static momentum(e,t,r=!1){return new Wz(e,t,r)}static rmsprop(e,t=.9,r=0,s=null,i=!1){return new Gz(e,t,r,s,i)}static adam(e=.001,t=.9,r=.999,s=null){return new Vz(e,t,r,s)}static adadelta(e=.001,t=.95,r=null){return new zz(e,t,r)}static adamax(e=.002,t=.9,r=.999,s=null,i=0){return new Uz(e,t,r,s,i)}static adagrad(e,t=.1){return new Bz(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sd=LY;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z_e=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function Kz(){return new Promise(n=>Z_e(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(n,e){const t=n[0].length;n.forEach((s,i)=>{U(s.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),U(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<t;o++)U(o===e||s[o]===r[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function ya(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ru;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(ru||(ru={}));function zY(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const i=t[s],o=r[r.length-t.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function BY(n){const e={FIRST_DIM_SIZE:ru.FIRST_DIM_SIZE,VALUE_ROWIDS:ru.VALUE_ROWIDS,ROW_LENGTHS:ru.ROW_LENGTHS,ROW_SPLITS:ru.ROW_SPLITS,ROW_LIMITS:ru.ROW_LIMITS,ROW_STARTS:ru.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function VY(n){return n.length===0?0:n[0]===ru.FIRST_DIM_SIZE?n.length-1:n.length}function UY(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const i=n[s],o=e[s+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yz=30;function hN(n){return n<=Yz?n:xI(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oy(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/e[o],e[o]]);s=s.concat(n.slice(i+1))}return s}function Fy(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Ly(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?r?s.push(e[i-1]*n[i]):s.push(n[i]/e[i-1]):s.push(n[i]);return s}function dN(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function pN(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cC=1.7580993408473768,uC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mN=.3275911,gN=.254829592,yN=-.284496736,bN=1.421413741,vN=-1.453152027,wN=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wu(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function WY(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function GY(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function HY(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function Zz(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function jY(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function qY(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:t,imag:r}}function XY(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),i=Math.sin(r);return{real:s,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3="->",J_e=/->/g,pG=",",mG="...";function xN(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(J_e,"").length)/a3.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${a3}").`);const[r,s]=n.split(a3);U(r.indexOf(mG)===-1,()=>`The ellipsis notation ("${mG}") is not supported yet.`);const i=r.split(pG),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<s.length;++f){const d=s[f];if(!i.some(p=>p.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){const d=r[f];a.indexOf(d)===-1&&d!==pG&&a.push(d)}const l=new Array(i.length);for(let f=0;f<o;++f){if(new Set(i[f].split("")).size!==i[f].length)throw new Error(`Found duplicate axes in input component ${i[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<i[f].length;++d)l[f].push(a.indexOf(i[f][d]))}const c=a.length,u=s.length,h=[];for(let f=u;f<c;++f)h.push(f);return{allDims:a,summedDims:h,idDims:l}}function _N(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function SN(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const i=t[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=i[o]:U(r[e[s][o]]===i[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function CN(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=Q_e(e,a);for(const c of l)i.indexOf(c)===-1&&(r[o].push(c),i.push(c))}return{path:t,steps:r}}function kN(n){return n.every((e,t)=>e===t)}function Q_e(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function TN(n,e,t=0){let r=[];if(typeof e=="number")U(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);U(s<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}U(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KY(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function YY(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function ZY(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function QY(n,e){return`size ${n} must be non-negative, not ${e}`}function eZ(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function tZ(n,e){const t=Te(n),r=Te(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function nZ(n,e){const t=Te(n),r=Te(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ED(){return"segment ids must be >= 0"}function rZ(){return"segment ids are not increasing"}function sZ(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function iZ(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oZ(n,e){let t=!1,r;for(n<=Yz?(r=n,t=!0):r=xI(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=xI(n,r+1);return r}function Jz(n,e,t){const r=[],s=n.length;for(let i=0;i<s;i++)i!==e?r.push(n[i]):r.push(t);return r}function EN(n,e,t,r){const s=e.shape.length,i=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<r;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=t+1;h<i;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const eSe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:EN,computeOutShape:Jz,segOpComputeOptimalWindowSize:oZ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xu(n){try{return n.map(e=>_c(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function aZ(n){return n.map(e=>gu(e))}const lZ=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:gN,ERF_A2:yN,ERF_A3:bN,ERF_A4:vN,ERF_A5:wN,ERF_P:mN,PARALLELIZE_THRESHOLD:Yz,get RowPartitionType(){return ru},SELU_SCALE:uC,SELU_SCALEALPHA:cC,applyActivation:nN,assertAndGetBroadcastShape:ln,assertAxesAreInnerMostDims:fi,assertParamsConsistent:uN,assignToTypedArray:jY,axesAreInnerMostDims:oz,calculateShapes:Fu,checkEinsumDimSizes:SN,checkPadOnDimRoundingMode:ta,combineLocations:iK,combineRaggedTensorToTensorShapes:zY,complexWithEvenIndex:GY,complexWithOddIndex:HY,computeConv2DInfo:ts,computeConv3DInfo:Ou,computeDefaultPad:WL,computeDilation2DInfo:Ap,computeOptimalWindowSize:hN,computeOutAndReduceShapes:Qs,computeOutShape:ya,computePool2DInfo:ko,computePool3DInfo:Ol,convertConv2DDataFormat:el,decodeEinsumEquation:xN,eitherStridesOrDilationsAreOne:Ri,expandShapeToKeepDim:Ls,exponent:XY,exponents:qY,fromStringArrayToUint8:aZ,fromUint8ToStringArray:xu,getAxesPermutation:Lr,getBroadcastDims:$f,getComplexWithIndex:Zz,getEinsumComputePath:CN,getEinsumPermutation:_N,getFusedBiasGradient:tN,getFusedDyActivation:eN,getImageCenter:fN,getInnerMostAxes:ns,getPermuted:Fy,getRaggedRank:VY,getReductionAxes:ui,getReshaped:Oy,getReshapedPermuted:Ly,getRowPartitionTypesHelper:BY,getSliceBeginCoords:dN,getSliceSize:pN,getSparseFillEmptyRowsIndicesDenseShapeMismatch:KY,getSparseFillEmptyRowsNegativeIndexErrorMessage:YY,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:ZY,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:eZ,getSparseReshapeInputOutputMismatchErrorMessage:nZ,getSparseReshapeInputOutputMultipleErrorMessage:tZ,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:JY,getSparseReshapeNegativeOutputDimErrorMessage:QY,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:iZ,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:ED,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:rZ,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:sZ,getUndoAxesPermutation:Mh,isIdentityPermutation:kN,log:rye,mergeRealAndImagArrays:wu,prepareAndValidate:aC,prepareSplitSize:TN,segment_util:eSe,shouldFuse:rN,slice_util:FY,splitRealAndImagArrays:WY,stridesOrDilationsArePositive:og,tupleValuesAreOne:rp,upcastType:Mi,validateDefaultValueShape:UY,validateInput:YM,validateUpdateShape:Mz,warn:bl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tSe=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:rC,nonMaxSuppressionV4Impl:sN,nonMaxSuppressionV5Impl:sC,whereImpl:JM},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */w_e();const cZ=Object.freeze(Object.defineProperty({__proto__:null,Abs:Tv,Acos:Og,Acosh:Fg,AdadeltaOptimizer:zz,AdagradOptimizer:Bz,AdamOptimizer:Vz,AdamaxOptimizer:Uz,Add:kp,AddN:Ev,All:GS,Any:HS,ArgMax:Iv,ArgMin:Av,Asin:Lg,Asinh:zg,Atan:Bg,Atan2:Ug,Atanh:Vg,AvgPool:Mv,AvgPool3D:Nv,AvgPool3DGrad:qS,AvgPoolGrad:jS,BatchMatMul:$v,BatchToSpaceND:Rv,Bincount:XS,BitwiseAnd:KS,BroadcastArgs:YS,BroadcastTo:aX,Cast:Wg,Ceil:Gg,ClipByValue:Hg,Complex:ZS,ComplexAbs:Pv,Concat:Dv,Conv2D:Ov,Conv2DBackpropFilter:JS,Conv2DBackpropInput:Fv,Conv3D:Lv,Conv3DBackpropFilterV2:QS,Conv3DBackpropInputV2:e2,Cos:jg,Cosh:qg,CropAndResize:n2,Cumprod:t2,Cumsum:zv,DataStorage:yM,DenseBincount:r2,DepthToSpace:s2,DepthwiseConv2dNative:Bv,DepthwiseConv2dNativeBackpropFilter:i2,DepthwiseConv2dNativeBackpropInput:o2,Diag:a2,Dilation2D:Vv,Dilation2DBackpropFilter:m_,Dilation2DBackpropInput:p_,Draw:l2,get ENV(){return kL},Einsum:c2,Elu:Kg,EluGrad:u2,Environment:iX,Equal:Uv,Erf:Yg,Exp:Zg,ExpandDims:Wv,Expm1:Jg,FFT:h2,Fill:f2,FlipLeftRight:d2,Floor:Qg,FloorDiv:ey,FromPixels:g_,FusedBatchNorm:Gv,FusedConv2D:Ub,FusedDepthwiseConv2D:Wb,GatherNd:p2,GatherV2:Hv,Greater:jv,GreaterEqual:ty,IFFT:m2,Identity:ny,Imag:g2,IsFinite:ry,IsInf:sy,IsNan:iy,KernelBackend:WS,LRN:Qv,LRNGrad:b2,LeakyRelu:qv,Less:Xv,LessEqual:Kv,LinSpace:y2,Log:oy,Log1p:ay,LogSoftmax:lX,LogicalAnd:Yv,LogicalNot:Zv,LogicalOr:Jv,LogicalXor:Jge,LowerBound:Qge,MatrixBandPart:eye,Max:ew,MaxPool:tw,MaxPool3D:nw,MaxPool3DGrad:w2,MaxPoolGrad:v2,MaxPoolWithArgmax:x2,Maximum:ly,Mean:rw,Min:sw,Minimum:cy,MirrorPad:iw,Mod:uy,MomentumOptimizer:Wz,Multinomial:_2,Multiply:hy,Neg:ow,NonMaxSuppressionV3:S2,NonMaxSuppressionV4:_M,NonMaxSuppressionV5:C2,NotEqual:aw,OP_SCOPE_SUFFIX:$L,OneHot:cw,OnesLike:lw,Optimizer:Wf,OptimizerConstructors:LY,Pack:uw,PadV2:hw,Pool:tye,Pow:fy,Prelu:fw,Prod:dw,RMSPropOptimizer:Gz,RaggedGather:SM,RaggedRange:CM,RaggedTensorToTensor:kM,Range:k2,get Rank(){return cD},Real:T2,RealDiv:Xg,Reciprocal:dy,get Reduction(){return Uo},Relu:py,Relu6:my,Reshape:pw,ResizeBilinear:gw,ResizeBilinearGrad:I2,ResizeNearestNeighbor:mw,ResizeNearestNeighborGrad:E2,Reverse:yw,RotateWithOffset:V2,Round:gy,Rsqrt:yy,SGDOptimizer:iN,ScatterNd:A2,SearchSorted:N2,Select:bw,Selu:by,Sigmoid:_y,Sign:xy,Sin:vy,Sinh:wy,Slice:vw,Softmax:Sw,Softplus:Sy,SpaceToBatchND:xw,SparseFillEmptyRows:TM,SparseReshape:EM,SparseSegmentMean:$2,SparseSegmentSum:R2,SparseToDense:P2,SplitV:_w,Sqrt:Cy,Square:D2,SquaredDifference:ky,StaticRegexReplace:O2,Step:My,StridedSlice:F2,StringNGrams:L2,StringSplit:IM,StringToHashBucketFast:AM,Sub:Ty,Sum:ww,Tan:Ey,Tanh:Iy,Tensor:jn,TensorBuffer:li,TensorScatterUpdate:M2,Tile:Ay,TopK:z2,Transform:B2,Transpose:Vd,Unique:MM,Unpack:Cw,UnsortedSegmentSum:kw,UpperBound:nye,Variable:v_,ZerosLike:Tw,_FusedMatMul:Vb,abs:wi,acos:LX,acosh:zX,add:qe,addN:BX,all:UL,any:TI,argMax:ig,argMin:VX,asin:UX,asinh:WX,atan:GX,atan2:HX,atanh:jX,avgPool:RM,avgPool3d:GL,backend:sg,backend_util:lZ,basicLSTMCell:qX,batchNorm:q2,batchNorm2d:HL,batchNorm3d:jL,batchNorm4d:qL,batchToSpaceND:PM,bincount:XL,bitwiseAnd:XX,booleanMaskAsync:rY,broadcastArgs:KX,broadcastTo:Ib,broadcast_util:Mbe,browser:G_e,buffer:Sn,cast:wt,ceil:YX,clipByValue:wa,clone:dh,complex:Nf,concat:cs,concat1d:KL,concat2d:YL,concat3d:ZL,concat4d:JL,conv1d:QL,conv2d:sp,conv2dTranspose:tz,conv3d:nz,conv3dTranspose:rz,copyRegisteredKernels:oye,cos:DM,cosh:sz,cosineWindow:QM,cumprod:EI,cumsum:iz,customGrad:vh,denseBincount:II,deprecationWarn:d0e,depthToSpace:JX,depthwiseConv2d:X2,device_util:Rye,diag:QX,dilation2d:eK,disableDeprecationWarnings:f0e,dispose:nn,disposeVariables:p0e,div:Lt,divNoNan:tK,dot:nK,dropout:Pz,einsum:Nm,elu:K2,enableDebugMode:h0e,enableProdMode:u0e,enclosingPowerOfTwo:Dz,engine:xo,ensureShape:rK,env:Ee,equal:bu,erf:sK,euclideanNorm:aK,exp:Yo,expandDims:oi,expm1:lK,eye:OM,fft:XM,fill:$y,findBackend:v0e,findBackendFactory:w0e,floor:Y2,floorDiv:VL,fused:fY,gather:Z2,gatherND:aY,gather_util:H_e,getBackend:x_,getGradient:oD,getKernel:b_,getKernelsForBackend:_I,grad:dve,grads:pve,greater:tl,greaterEqual:Mp,ifft:T_,imag:J2,image:Ci,inTopKAsync:lY,io:jz,irfft:Ez,isFinite:cK,isInf:uK,isNaN:hK,keep:Xs,kernel_impls:tSe,leakyRelu:FM,less:k_,lessEqual:Ry,linalg:Lz,linspace:fK,localResponseNormalization:dK,log:Al,log1p:LM,logSigmoid:mK,logSoftmax:az,logSumExp:BM,logicalAnd:wh,logicalNot:VM,logicalOr:lz,logicalXor:gK,losses:yY,lowerBound:yK,matMul:Hn,math:O_e,max:bc,maxPool:WM,maxPool3d:cz,maxPoolWithArgmax:bK,maximum:Vf,mean:Ds,memory:kI,meshgrid:vK,min:C_,minimum:op,mirrorPad:uz,mod:wK,moments:Q2,movingAverage:sY,mul:fe,multiRNNCell:xK,multinomial:_K,neg:us,nextFrame:Kz,norm:Ew,notEqual:qb,oneHot:Xb,ones:pa,onesLike:Ml,op:he,outerProduct:SK,pad:vu,pad1d:CK,pad2d:kK,pad3d:TK,pad4d:EK,pool:IK,pow:ip,prelu:HM,print:BL,prod:AK,profile:m0e,raggedGather:MK,raggedRange:NK,raggedTensorToTensor:$K,rand:RK,randomGamma:LK,randomNormal:jM,randomStandardNormal:zK,randomUniform:Np,randomUniformInt:BK,range:ag,ready:j2,real:Kb,reciprocal:VK,registerBackend:$M,registerGradient:cX,registerKernel:U2,relu:Nh,relu6:wz,removeBackend:b0e,reshape:ve,reverse:Cc,reverse1d:UK,reverse2d:WK,reverse3d:GK,reverse4d:HK,rfft:KM,round:xz,rsqrt:_z,scalar:en,scatterND:iY,scatter_util:mxe,searchSorted:UM,selu:Sz,separableConv2d:Cz,serialization:b_e,setBackend:y0e,setPlatform:x0e,setdiff1dAsync:jK,sigmoid:kl,sign:qK,signal:gY,sin:kz,sinh:Tz,slice:dn,slice1d:eC,slice2d:qM,slice3d:tC,slice4d:Yb,slice_util:FY,softmax:nC,softplus:Iw,spaceToBatchND:GM,sparse:bY,sparseToDense:oY,spectral:mY,split:ja,sqrt:So,square:Or,squaredDifference:Iz,squeeze:vr,stack:xa,step:Mw,stridedSlice:XK,string:vY,sub:Dt,sum:Yt,sumOutType:G2,tan:KK,tanh:jb,tensor:Ei,tensor1d:Ks,tensor2d:qa,tensor3d:Az,tensor4d:YK,tensor5d:ZK,tensor6d:JK,tensorScatterUpdate:QK,tensor_util:Iye,test_util:Iwe,tidy:Se,tile:fc,time:g0e,topk:eY,train:Sd,transpose:rr,truncatedNormal:ZM,unique:tY,unregisterGradient:iye,unregisterKernel:sye,unsortedSegmentSum:Nz,unstack:kc,upcastType:Mi,upperBound:nY,util:mye,valueAndGrad:mve,valueAndGrads:gve,variable:$z,variableGrads:pK,version_core:Y_e,where:_o,whereAsync:Rz,zeros:ms,zerosLike:lr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nSe=JM;class IN extends WS{nextDataId(){return IN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new yM(this,xo())}write(e,t,r){this.firstUse&&(this.firstUse=!1,Ee().get("IS_NODE")&&bl(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&cu(r[0])){const i=r.map(o=>gu(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,r,s,i){this.data.set(e,{values:t,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);if(t==="complex64"){const s=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return wu(s,i)}return K1(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>_c(s));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}makeOutput(e,t,r){return xo().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=so();return e(),{kernelMs:so()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Zt([e],"where");const t=this.readSync(e.dataId);return nSe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}IN.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uZ(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const rSe=n=>{const{x:e}=n.inputs,t=n.backend;Zt(e,"abs");let r=new Float32Array(Te(e.shape));const s=t.data.get(e.dataId).values;return r=uZ(s),t.makeOutput(r,e.shape,e.dtype)},sSe={kernelName:Tv,backendName:"cpu",kernelFunc:rSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(n){return(e,t,r,s,i)=>{const o=ln(e,t),a=o.length,l=Jt(o),c=Te(o),u=ci(i,c),h=e.length,f=t.length,d=Jt(e),p=Jt(t),m=$f(e,o),g=$f(t,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<u.length;++y){const b=Dg(y,a,l),x=b.slice(-h);m.forEach(k=>x[k]=0);const w=mu(x,h,d),S=b.slice(-f);g.forEach(k=>S[k]=0);const C=mu(S,f,p);u[y]=n(r[w],s[C])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",i),imag:t.makeTensorInfo(s.shape,"float32",o)},a}const iSe={kernelName:ZS,backendName:"cpu",kernelFunc:Ua};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(n,e,t="float32"){if(t==="complex64"){const s=MI(n,e,"float32"),i=MI(n,e,"float32");return Ua({inputs:{real:s,imag:i},backend:n})}const r=ji(Te(e),t);return n.makeTensorInfo(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xh(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const oSe={kernelName:ny,backendName:"cpu",kernelFunc:xh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cg(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.real,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const aSe={kernelName:T2,backendName:"cpu",kernelFunc:cg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hZ(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=Ep([0],t),[i,o]=ei((a,l)=>a!==l?1:0)(e,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function ap(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return xh({inputs:{x:s},backend:t});const u=MI(t,s.shape,s.dtype),h=ap({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),f=Ua({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),f}if(s.dtype==="complex64"){const u=cg({inputs:{input:s},backend:t}),h=ap({inputs:{x:u},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(u),h}if(!wM(s.dtype,i)){const u=xh({inputs:{x:s},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=t.data.get(s.dataId).values,[a,l,c]=hZ(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}const lSe={kernelName:Wg,backendName:"cpu",kernelFunc:ap};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n,e,t,r){return t==null?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Zt([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=o.dtype==="string"?xu(c):c,f=o.dtype==="string"?xu(u):u,d=r||o.dtype,[p,m]=e(o.shape,a.shape,h,f,d);return l.makeTensorInfo(m,d,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=ap({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,d=l.data.get(h.dataId).values,p=l.data.get(f.dataId).values,m=ap({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,w=l.data.get(b.dataId).values,[S,C,k]=t(o.shape,a.shape,d,p,x,w),A=l.makeTensorInfo(k,"float32",S),M=l.makeTensorInfo(k,"float32",C),E=Ua({inputs:{real:A,imag:M},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(A),l.disposeIntermediateTensorInfo(M),E}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,h=r||o.dtype,[f,d]=e(o.shape,a.shape,c,u,h);return l.makeTensorInfo(d,h,f)}}}function Qz(n){return(e,t,r,s,i,o)=>{const a=ln(e,t),l=Te(a),c=a.length,u=Jt(a),h=ci("float32",l),f=ci("float32",l),d=$f(e,a),p=$f(t,a),m=wu(r,s),g=wu(i,o),y=e.length,b=Jt(e),x=t.length,w=Jt(t);if(d.length+p.length===0)for(let S=0;S<h.length;S++){const C=S%m.length,k=S%g.length,A=n(m[C*2],m[C*2+1],g[k*2],g[k*2+1]);h[S]=A.real,f[S]=A.imag}else for(let S=0;S<h.length;S++){const C=Dg(S,c,u),k=C.slice(-y);d.forEach(O=>k[O]=0);const A=mu(k,y,b),M=C.slice(-x);p.forEach(O=>M[O]=0);const E=mu(M,x,w),N=n(m[A*2],m[A*2+1],g[E*2],g[E*2+1]);h[S]=N.real,f[S]=N.imag}return[h,f,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fZ=ei((n,e)=>n+e),cSe=Qz((n,e,t,r)=>({real:n+t,imag:e+r})),Zb=Pi(kp,fZ,cSe),uSe={kernelName:kp,backendName:"cpu",kernelFunc:Zb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n,e,t,r,s){const i=Te(r),o=ji(s,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function dZ(n,e,t,r=!1){const s=n.shape[0],i=n.shape[1],o=Sn([s,t],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(r?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pZ=ei((n,e)=>n&e),hSe=Pi(KS,pZ),fSe={kernelName:KS,backendName:"cpu",kernelFunc:hSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $h(n){return(e,t,r)=>{const s=Ss(t,e.length);for(let i=0;i<e.length;++i)s[i]=n(e[i],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n,e,t){const r=$h(e);return $p(n,r,t)}function $p(n,e,t){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;Zt(o,n);const a=i,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=xu(l)}else c=l;const u=t||o.dtype,h=e(c,u,s);return a.makeTensorInfo(o.shape,u,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZ=$h(n=>Math.ceil(n)),dSe=$p(Gg,mZ),pSe={kernelName:Gg,backendName:"cpu",kernelFunc:dSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gZ(n,e,t,r){const s=Ss(t,Te(e));if(r&&t!=="string"){let i=0;n.forEach(o=>{const a=Te(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?xu(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+i;for(let h=0;h<o.shape[1];++h)s[u+h]=a[l++]}i+=o.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZ=ei((n,e)=>n===e?1:0),bZ=Pi(Uv,yZ,null,"bool"),mSe={kernelName:Uv,backendName:"cpu",kernelFunc:bZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vZ=$h(n=>Math.exp(n)),wZ=$p(Zg,vZ,"float32"),gSe={kernelName:Zg,backendName:"cpu",kernelFunc:wZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xZ=$h(n=>Math.expm1(n)),ySe=$p(Jg,xZ),bSe={kernelName:Jg,backendName:"cpu",kernelFunc:ySe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Z=$h(n=>Math.floor(n)),vSe=$p(Qg,_Z),wSe={kernelName:Qg,backendName:"cpu",kernelFunc:vSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ=ei((n,e)=>Math.floor(n/e)),xSe=Pi(ey,SZ,null,"int32"),_Se={kernelName:ey,backendName:"cpu",kernelFunc:xSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZ(n,e,t,r,s,i,o,a,l){const c=Sn([r,i],t);for(let u=0;u<r;u++){const h=[];let f=0;for(let d=0;d<s;d++){const p=n[u*s+d];f+=p*o[d],h.push(p)}if(f<0||f>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<i;d++)c.values[u*i+d]=e.get(...e.indexToLoc(f*i+d))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kZ(n,e,t){const r=Sn(t,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TZ=ei((n,e)=>n>e?1:0),SSe=Pi(jv,TZ,null,"bool"),CSe={kernelName:jv,backendName:"cpu",kernelFunc:SSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EZ=ei((n,e)=>n>=e?1:0),kSe=Pi(ty,EZ,null,"bool"),TSe={kernelName:ty,backendName:"cpu",kernelFunc:kSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZ=ei((n,e)=>n<e?1:0),ESe=Pi(Xv,IZ,null,"bool"),ISe={kernelName:Xv,backendName:"cpu",kernelFunc:ESe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ=ei((n,e)=>n<=e?1:0),ASe=Pi(Kv,AZ,null,"bool"),MSe={kernelName:Kv,backendName:"cpu",kernelFunc:ASe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MZ(n,e,t){const r=(e-n)/(t-1),s=ji(t,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZ=$h(n=>Math.log(n)),NSe=$p(oy,NZ),$Se={kernelName:oy,backendName:"cpu",kernelFunc:NSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Z(n,e,t,r){const s=ci(r,Te(t));for(let i=0;i<s.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZ=ei((n,e)=>Math.max(n,e)),RSe=Pi(ly,RZ),PSe={kernelName:ly,backendName:"cpu",kernelFunc:RSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ=ei((n,e)=>Math.min(n,e)),DSe=Pi(cy,PZ),OSe={kernelName:cy,backendName:"cpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tB=ei((n,e)=>n*e),FSe=Qz((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),AN=Pi(hy,tB,FSe),LSe={kernelName:hy,backendName:"cpu",kernelFunc:AN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DZ(n,e,t){const r=Bf(-1,t);return tB([],e,r,n,t)}function zSe(n){const{inputs:e,backend:t}=n,{x:r}=e;Zt(r,"neg");const s=t.data.get(r.dataId).values,[i,o]=DZ(s,r.shape,r.dtype);return t.makeTensorInfo(o,r.dtype,i)}const BSe={kernelName:ow,backendName:"cpu",kernelFunc:zSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZ=ei((n,e)=>n!==e?1:0),VSe=Pi(aw,OZ,null,"bool"),USe={kernelName:aw,backendName:"cpu",kernelFunc:VSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n,e,t,r,s){const i=e.length,o=Te(e),a=Jt(e),l=Jt(s),c=ci(t,Te(s));for(let u=0;u<o;++u){const h=Dg(u,i,a),f=new Array(h.length);for(let p=0;p<f.length;p++)f[p]=h[r[p]];const d=mu(f,i,l);c[d]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{perm:i}=t;Zt(s,"transpose");const o=s.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=s.shape[i[h]];const l=r.data.get(s.dataId).values,c=nB(l,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const WSe={kernelName:Vd,backendName:"cpu",kernelFunc:_a};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FZ(n,e,t,r){const[s,i]=Qs(n,r),o=Mi(e,"int32"),a=ji(Te(s),o),l=Te(i);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let f=0;f<l;++f)h*=t[u+f];a[c]=h}return{outVals:a,outShape:s,outDtype:o}}function GSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"prod");const a=s.shape.length,l=An(i,s.shape),c=Lr(l,a);let u=l,h=s;const f=[];c!=null&&(h=_a({inputs:{x:s},backend:t,attrs:{perm:c}}),f.push(h),u=ns(u.length,a));const d=t.data.get(h.dataId).values,{outVals:p,outShape:m,outDtype:g}=FZ(h.shape,h.dtype,d,u);let y=m;return o&&(y=Ls(m,l)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(y,g,p)}const HSe={kernelName:dw,backendName:"cpu",kernelFunc:GSe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jSe(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const i=Dg(s,e.length,Jt(e)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${t})`)}})}function qSe(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function XSe(n,e,t,r){const s=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);qSe(t,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)a[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let f=0;f<t.length;++f){const d=t[f],p=f+e.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-d[u];for(let y=u;y<h;++y)a[p].push(d[y+1]+g)}u=d[u],h=d[h]}h!==u&&(s.push([u,h]),i+=h-u)}return{outSplits:a,valueSlices:s,numValues:i}}function KSe(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=Ss("int32",r);e.push(s),n[t].forEach((i,o)=>s[o]=i)}return e}function gG(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function YSe(n,e,t,r,s,i){const o=gG(e,2)[1],a=gG(i,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<r;++h)s[l*a+h]=n[u*o+h];++l}}function ZSe(n,e,t,r,s){const i=e.slice();i[0]=s;const o=Ss(t,Te(i)),a=n.length,l=a===0?0:a/e[0];return YSe(n,e,r,l,o,i),[o,i]}function LZ(n,e,t,r,s,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(jSe(i,o,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:h,numValues:f}=XSe(i,o,n,c),d=KSe(u),p=ZSe(t,r,s,h,f);return[d,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yG=2147483647;function zZ(n,e,t,r,s,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(s[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],f=Ss("int32",h+1);f[0]=0;for(let g=0;g<h;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],x=c?i[0]:i[g];if(x===0)throw new Error("Requires delta != 0");let w;if(x>0&&b<y||x<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/x)),w>yG)throw new Error(`Requires ((limit - start) / delta) <= ${yG}`);f[g+1]=f[g]+w}const d=f[h],p=Ss(t,d);let m=0;for(let g=0;g<h;++g){const y=f[g+1]-f[g];let b=a?n[0]:n[g];const x=c?i[0]:i[g];for(let w=0;w<y;++w)p[m++]=b,b+=x}return[f,p]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yl=ru;class NI{constructor(e,t,r,s,i,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=BY(u),this.raggedRank=VY(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Yl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Yl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Yl.VALUE_ROWIDS:return NI.getMaxWidthValueRowID(t);case Yl.ROW_SPLITS:return NI.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Yl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const i=e[s+1]-e[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(t-r,i)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return vG(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;UY(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=zY(this.raggedRank,s,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),i=[];let o=0;for(let a=0;a<s;++a,o+=t)i.push(o);for(let a=s;a<e;++a)i.push(-1);return U(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,r,s){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let c=Math.min(s,l),u=t[a];u===-1&&(c=0);for(let h=0;h<c;++h)o.push(u),u+=r;for(let h=0;h<l-c;++h)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,r,s){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<i;++u){const h=e[u];if(h===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,r,s){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Yl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,r,s);case Yl.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,r,s);default:throw new Error(`Unsupported partition type: ${Yl[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Yl.FIRST_DIM_SIZE:return e[0];case Yl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Yl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Yl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=vG(r,!1),o=Ss(this.valuesDType,Te(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,t,r,s){if(r.length===0)return;const i=this.values,o=r;let a=s.slice();a=a.slice(e+1);const l=Te(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const p=this.defaultValueShape;Se(()=>{const m=ve(u,p);u=Ib(m,a).dataSync()})}let h=0,f=0,d=0;for(let p=0;p<=c;++p){let m=p<c?t[p]:-1;if(m===d){++d;continue}if(f<d){const g=i.subarray(h*l),y=o.subarray(f*l),b=(d-f)*l;bG(y,g,b)}if(p>=c){const g=r.length;m=Math.floor(g/l)}if(m>d)if(this.defaultValue.length===1)o.subarray(d*l,m*l).fill(this.defaultValue[0]),d=m;else for(;m>d;){const g=o.slice(d*l);bG(g,u,l),++d}m<0?(h=p+1,f=d):(h=p,f=d,d=f+1)}}}function bG(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function vG(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function BZ(n,e,t,r,s,i,o,a,l,c){return new NI(n,e,t,r,s,i,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VZ(n,e,t,r){const s=n===e,i=n<e&&t<0,o=e<n&&t>1;if(s||i||o)return ji(0,r);const a=Math.abs(Math.ceil((e-n)/t)),l=ji(a,r);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZ=$h(n=>1/Math.sqrt(n)),JSe=$p(yy,UZ),QSe={kernelName:yy,backendName:"cpu",kernelFunc:JSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zm(n,e,t,r,s,i,o,a,l,c){const u=[r/s,s],h=n.values,f=e.values;if(r===0)return Sn(t,e.dtype);const d=l instanceof li?l:Sn(u,e.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let p=0;p<i;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=h[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<s;y++)c?d.values[g*s+y]+=f[p*s+y]:d.values[g*s+y]=e.rank===0?f[0]:f[p*s+y]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e2e=$h(n=>1/(1+Math.exp(-n))),WZ=$r(_y,n=>1/(1+Math.exp(-n))),t2e={kernelName:_y,backendName:"cpu",kernelFunc:WZ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GZ(n,e,t,r,s){const i=qz(r,e,t),o=Te(t),a=Jt(r);if(i){const h=Xz(e,a);return s==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=s==="string"?xu(n):n,c=Sn(r,s,l),u=Sn(t,s);for(let h=0;h<u.size;++h){const f=u.indexToLoc(h),d=f.map((p,m)=>p+e[m]);u.set(c.get(...d),...f)}return s==="string"?aZ(u.values):u.values}function ug(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r;Zt(s,"slice");const[a,l]=lC(s,i,o);aN(s,a,l);const c=t.data.get(s.dataId).values,u=GZ(c,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,u)}const n2e={kernelName:vw,backendName:"cpu",kernelFunc:ug};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HZ(n,e,t,r,s,i,o){const a=e[0],l=i[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(KY(a));const g=Ss(t,0),y=Ss(s,0);return[g,[0,h],y,c,u]}let f=!0,d=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*h];if(y<0)throw new Error(YY(g,y));if(y>=l)throw new Error(ZY(g,y,l));++p[y],f=f&&y>=d,d=y}let m=!0;for(let g=0;g<l;++g){const y=p[g]===0;c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&f){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,h],y,c,u]}else{const g=p[l-1],y=Ss(t,g*h),b=Ss(s,g),x=new Array(l).fill(0);for(let w=0;w<a;++w){const S=n[w*h],C=x[S],k=(S===0?0:p[S-1])+C;x[S]++;for(let A=0;A<h;++A)y[k*h+A]=n[w*h+A];b[k]=r[w],u[w]=k}for(let w=0;w<l;++w)if(x[w]===0){const C=w===0?0:p[w-1];y[C*h+0]=w;for(let k=1;k<h;++k)y[C*h+k]=0;b[C]=o}return[y,[g,h],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jZ(n,e,t,r,s){const i=Te(r),o=e[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=s[g];if(y===-1){if(u!==-1)throw new Error(JY(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(QY(g,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(eZ());const g=Math.trunc(i/c);if(c*g!==i)throw new Error(tZ(r,l));l[u]=g}if(Te(l)!==i)throw new Error(nZ(r,l));const f=r.length,d=[];if(f>0){d[f-1]=1;for(let g=f-2;g>=0;--g)d[g]=d[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Ss(t,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<f;++b)y+=n[g*f+b]*d[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(n,e,t,r,s,i=!1,o=0){const a=r.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(ED());const f=e.slice();f[0]=h;const d=f.reduce((x,w)=>x*w,1),p=Ss(t,d);if(a===0)return h>0&&p.fill(o),[p,f];if(h<=0)throw new Error(ED());let m=0,g=1,y=0,b=s[m];for(;;){let x=0;if(g<a){if(x=s[g],b===x){++g;continue}if(b>=x)throw new Error(rZ())}if(b<0||b>=h)throw new Error(sZ(b,h));b>y&&p.fill(o,y*c,b*c);for(let w=m;w<g;++w){const S=r[w];if(S<0||S>=l[0])throw new Error(iZ(w,r[w],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[S*c+C]}if(i)for(let w=0;w<c;w++)p[b*c+w]/=g-m;if(m=g,++g,y=b+1,b=x,g>a)break}return y<h&&p.fill(o,y*c,h*c),[p,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2e=$h(n=>Math.sqrt(n)),s2e=$r(Cy,n=>Math.sqrt(n)),i2e={kernelName:Cy,backendName:"cpu",kernelFunc:s2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZ=ei((n,e)=>{const t=n-e;return t*t}),o2e=Pi(ky,qZ),a2e={kernelName:ky,backendName:"cpu",kernelFunc:o2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZ=$h((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:s}=e;return n.replace(new RegExp(t,r?"g":""),s)}),l2e=$p(O2,XZ),c2e={kernelName:O2,backendName:"cpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KZ(n,e,t,r){const s=Sn(n,e.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+r[l];s.set(e.get(...a),...o)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u2e{constructor(e,t,r,s,i,o){this.separator=gu(e),this.nGramWidths=t,this.leftPad=gu(r),this.rightPad=gu(s),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),h=o-(c+u),f=t+(c>0?0:a-l);let d=0;d+=c*this.leftPad.length;for(let b=0;b<h;++b)d+=e[f+b].length;d+=u*this.rightPad.length;const p=c+u+h-1;d+=p*this.separator.length,r[s+a]=new Uint8Array(d);const m=r[s+a];let g=0;const y=b=>b.forEach(x=>m[g++]=x);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<h-1;++b)y(e[f+b]),y(this.separator);if(h>0){y(e[f+h-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=t[c]>=l;if(u=u&&t[c]<=r,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${r}]`);l=t[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Ss("int32",s);if(r===0||s===0){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const f=t[l+1]-t[l],d=this.getNumNGrams(f,h);this.createNGrams(e,c,a,u,d,h),u+=d}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const f=h+2*this.padWidth,d=1;this.createNGrams(e,c,a,u,d,f)}}return[a,o]}}function YZ(n,e,t,r,s,i,o,a){return new u2e(t,r,s,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2e(n,e,t,r){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&r.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(s,i);(!t||o.length!==0)&&r.push(o),s=i+1}}function ZZ(n,e,t){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let f=0;f<r;++f){const d=s.length;h2e(n[f],e,t,s);const p=s.length-d;a[f]=p,i+=p,o=Math.max(o,p)}const l=Ss("int32",i*2),c=new Array(i),u=[r,o];let h=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[h*2]=f,l[h*2+1]=d,c[h]=s[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JZ(n,e){const t=Ss("int32",n.length);for(let r=0;r<n.length;++r)t[r]=vX(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZ=ei((n,e)=>n-e),f2e=Qz((n,e,t,r)=>({real:n-t,imag:e-r})),sB=Pi(Ty,QZ,f2e),d2e={kernelName:Ty,backendName:"cpu",kernelFunc:sB};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eJ(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Sn(t,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S1=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function tJ(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),f=Math.max(t,Math.floor(e-l*u/a+h)),d=Math.min(r,Math.floor(e+(a-l)*u/a+h));tJ(n,e,f,d)}const s=n[e];let i=t,o=r;for(xf(n,t,e),S1(n[r],s)>0&&xf(n,t,r);i<o;){for(xf(n,i,o),i++,o--;S1(n[i],s)<0;)i=i+1;for(;S1(n[o],s)>0;)o=o-1}S1(n[t],s)===0?xf(n,t,o):(o=o+1,xf(n,o,r)),o<=e&&(t=o+1),e<=o&&(r=o-1)}}function nJ(n,e,t,r,s){const i=e[e.length-1],[o,a]=[n.length/i,i],l=ci(t,o*r),c=ci("int32",o*r);for(let h=0;h<o;h++){const f=h*a,d=n.subarray(f,f+a);let p=new Array(d.length);d.forEach((b,x)=>p[x]={value:b,index:x}),r<p.length&&(tJ(p,r),p=p.slice(0,r)),s&&p.sort(S1);const m=h*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=e.slice();return u[u.length-1]=r,[Sn(u,t,l),Sn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n,e,t,r){const s=An(e,t)[0],i=[1,t[0],1];for(let p=0;p<s;p++)i[0]*=t[p];i[1]=t[s];for(let p=s+1;p<t.length;p++)i[2]*=t[p];const o=new Map,a=new Int32Array(t[s]),l=new li(i,r,n),c=[],u=i[0]===1&&i[2]===1;for(let p=0;p<t[s];p++){let m;if(u)m=n[p].toString();else{const y=[];for(let b=0;b<i[0];b++)for(let x=0;x<i[2];x++)y.push(l.get(b,p,x));m=y.join(",")}const g=o.get(m);if(g!=null)a[p]=g;else{const y=o.size;o.set(m,y),a[p]=y,c.push(p)}}const h=i.slice();h[1]=o.size;const f=new li(h,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)f.set(l.get(g,p,y),g,m,y)});const d=t.slice();return d[s]=h[1],{outputValues:f.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJ=Object.freeze(Object.defineProperty({__proto__:null,addImpl:fZ,bincountImpl:eB,bincountReduceImpl:dZ,bitwiseAndImpl:pZ,castImpl:hZ,ceilImpl:mZ,concatImpl:gZ,equalImpl:yZ,expImpl:vZ,expm1Impl:xZ,floorDivImpl:SZ,floorImpl:_Z,gatherNdImpl:CZ,gatherV2Impl:kZ,greaterEqualImpl:EZ,greaterImpl:TZ,lessEqualImpl:AZ,lessImpl:IZ,linSpaceImpl:MZ,logImpl:NZ,maxImpl:$Z,maximumImpl:RZ,minimumImpl:PZ,multiplyImpl:tB,negImpl:DZ,notEqualImpl:OZ,prodImpl:FZ,raggedGatherImpl:LZ,raggedRangeImpl:zZ,raggedTensorToTensorImpl:BZ,rangeImpl:VZ,rsqrtImpl:UZ,scatterImpl:zm,sigmoidImpl:e2e,simpleAbsImpl:uZ,sliceImpl:GZ,sparseFillEmptyRowsImpl:HZ,sparseReshapeImpl:jZ,sparseSegmentReductionImpl:rB,sqrtImpl:r2e,squaredDifferenceImpl:qZ,staticRegexReplaceImpl:XZ,stridedSliceImpl:KZ,stringNGramsImpl:YZ,stringSplitImpl:ZZ,stringToHashBucketFastImpl:JZ,subImpl:QZ,tileImpl:eJ,topKImpl:nJ,transposeImpl:nB,uniqueImpl:rJ},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */$M("cpu",()=>new IN,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iJ=$r(Kg,n=>n>=0?n:Math.exp(n)-1),p2e={kernelName:Kg,backendName:"cpu",kernelFunc:iJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r;Zt([s],"leakyRelu");const o=Te(s.shape),a=t.data.get(s.dataId).values,l=ci("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return t.makeTensorInfo(s.shape,"float32",l)}const m2e={kernelName:qv,backendName:"cpu",kernelFunc:oJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g2e=ei((n,e)=>n<0?e*n:n);function aJ(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e;Zt([r,s],"prelu");const i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,[a,l]=g2e(r.shape,s.shape,i,o,"float32");return t.makeTensorInfo(l,"float32",a)}const y2e={kernelName:fw,backendName:"cpu",kernelFunc:aJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lJ=$r(py,n=>Math.max(0,n)),b2e={kernelName:py,backendName:"cpu",kernelFunc:lJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJ=$r(my,n=>Math.min(Math.max(0,n),6)),v2e={kernelName:my,backendName:"cpu",kernelFunc:cJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $I(n,e,t,r,s){if(t==="linear")return xh({inputs:{x:e},backend:n});if(t==="relu")return lJ({inputs:{x:e},backend:n});if(t==="elu")return iJ({inputs:{x:e},backend:n});if(t==="relu6")return cJ({inputs:{x:e},backend:n});if(t==="prelu")return aJ({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return oJ({inputs:{x:e},backend:n,attrs:{alpha:s}});if(t==="sigmoid")return WZ({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function es(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=Te(s.shape),a=vM(i,o),l=Te(a);U(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(s.dataId);const c=t.data.get(s.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=a,h.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const w2e={kernelName:pw,backendName:"cpu",kernelFunc:es};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uJ(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;Zt([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],h=a?i.shape[c-1]:i.shape[c-2],f=o?s.shape[l-1]:s.shape[l-2],d=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=Te(p),y=Te(m),x=ln(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([f,d]);U(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=o?[g,u,f]:[g,f,u],S=a?[y,d,h]:[y,h,d],C=es({inputs:{x:s},backend:t,attrs:{shape:w}}),k=es({inputs:{x:i},backend:t,attrs:{shape:S}}),A=o?C.shape[1]:C.shape[2],M=o?C.shape[2]:C.shape[1],E=a?k.shape[1]:k.shape[2],N=Math.max(g,y),O=t.data.get(C.dataId).values,R=t.data.get(k.dataId).values,D=Jt(C.shape),z=Jt(k.shape),[B,X,G]=o?[D[0],1,D[1]]:[D[0],D[1],1],[te,ge,ae]=a?[1,z[1],z[0]]:[z[1],1,z[0]],Ne=M*E,ke=Sn([N,M,E],C.dtype),De=ke.values,be=t.blockSize;for(let Xe=0;Xe<N;Xe++){const Oe=Xe%g,it=Xe%y;for(let We=0;We<M;We+=be){const dt=Math.min(We+be,M);for(let ct=0;ct<E;ct+=be){const Ve=Math.min(ct+be,E);for(let ze=0;ze<A;ze+=be){const Be=Math.min(ze+be,A);for(let ut=We;ut<dt;ut++)for(let Ke=ct;Ke<Ve;Ke++){let ee=0;for(let J=ze;J<Be;J++){const rt=O[Oe*B+ut*X+J*G],Ge=R[J*te+Ke*ge+it*ae];ee+=rt*Ge}De[Xe*Ne+(ut*E+Ke)]+=ee}}}}}return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(k),t.makeTensorInfo(x,ke.dtype,ke.values)}const x2e={kernelName:$v,backendName:"cpu",kernelFunc:uJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;let f,d,p;const m=[];f=uJ({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(d=Zb({inputs:{a:f,b:o},backend:t}),m.push(f),f=d),u&&(p=$I(t,f,u,a,h),m.push(f),f=p);for(const y of m)t.disposeIntermediateTensorInfo(y);return f}const S2e={kernelName:Vb,backendName:"cpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C2e=$r(Og,n=>Math.acos(n)),k2e={kernelName:Og,backendName:"cpu",kernelFunc:C2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T2e=$r(Fg,n=>Math.acosh(n)),E2e={kernelName:Fg,backendName:"cpu",kernelFunc:T2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2e(n){const{inputs:e,backend:t}=n,r=e;Zt(e,"addN");const s=r.map(a=>t.data.get(a.dataId).values),i=Sn(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const A2e={kernelName:Ev,backendName:"cpu",kernelFunc:I2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"all");const a=An(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=_a({inputs:{x:s},backend:t,attrs:{perm:c}}),l=ns(l.length,s.shape.length)),fi("all",l,u.shape.length);const[h,f]=Qs(u.shape,l),d=Te(f),p=ji(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const S=m[b+w];x=x&&S}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=es({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const N2e={kernelName:GS,backendName:"cpu",kernelFunc:M2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"any");const a=An(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=_a({inputs:{x:s},backend:t,attrs:{perm:c}}),l=ns(l.length,s.shape.length)),fi("any",l,u.shape.length);const[h,f]=Qs(u.shape,l),d=Te(f),p=ji(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const S=m[b+w];x=x||S}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=es({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const R2e={kernelName:HS,backendName:"cpu",kernelFunc:$2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Zt(s,"argMax");let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=_a({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),o=[o[0]],fi("argMax",o,l.shape.length);const[u,h]=Qs(l.shape,o),f=Te(u),d=ji(f,"int32"),p=Te(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],x=0;for(let w=0;w<p;++w){const S=m[y+w];S>b&&(b=S,x=w)}d[g]=x}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const D2e={kernelName:Iv,backendName:"cpu",kernelFunc:P2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Zt(s,"argMin");let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=_a({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),o=[o[0]],fi("argMin",o,l.shape.length);const[u,h]=Qs(l.shape,o),f=Te(u),d=ji(f,"int32"),p=Te(h),m=t.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const y=g*p;let b=m[y],x=0;for(let w=0;w<p;++w){const S=m[y+w];S<b&&(b=S,x=w)}d[g]=x}return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",d)}const F2e={kernelName:Av,backendName:"cpu",kernelFunc:O2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L2e=$r(Lg,n=>Math.asin(n)),z2e={kernelName:Lg,backendName:"cpu",kernelFunc:L2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B2e=$r(zg,n=>Math.asinh(n)),V2e={kernelName:zg,backendName:"cpu",kernelFunc:B2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U2e=$r(Bg,n=>Math.atan(n)),W2e={kernelName:Bg,backendName:"cpu",kernelFunc:U2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G2e=ei((n,e)=>Math.atan2(n,e)),H2e=Pi(Ug,G2e),j2e={kernelName:Ug,backendName:"cpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q2e=$r(Vg,n=>Math.atanh(n)),X2e={kernelName:Vg,backendName:"cpu",kernelFunc:q2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n,e,t,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,d=s.padInfo.left,p=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Sn(s.outShape,t),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let w=0;w<s.batchSize;++w){const S=w*y,C=w*r[0];for(let k=0;k<s.inChannels;++k)for(let A=0;A<s.outHeight;++A){const M=A*o-f,E=Math.max(0,M),N=Math.min(s.inHeight,u+M),O=S+A*b;for(let R=0;R<s.outWidth;++R){const D=R*a-d,z=Math.max(0,D),B=Math.min(s.inWidth,h+D);let X=p,G=0,te=0;for(let ae=E;ae<N;ae+=l){const Ne=C+ae*r[1];for(let ke=z;ke<B;ke+=c){const De=Ne+ke*r[2],be=n[De+k];i==="max"&&be>X?X=be:i==="avg"&&(G+=be,te++)}if(isNaN(X))break}const ge=O+R*x+k;g[ge]=i==="avg"?G/te:X}}}return m}function hJ(n,e,t,r,s=!1,i=!1){const o=Sn(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,m=Sn(e,t,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const x=b*a-d;let w=x;for(;w<0;)w+=c;const S=Math.min(r.inHeight,h+x);for(let C=0;C<r.outWidth;++C){const k=C*l-p;let A=k;for(;A<0;)A+=u;const M=Math.min(r.inWidth,f+k);let E=Number.NEGATIVE_INFINITY,N=-1;for(let O=w;O<S;O+=c){const R=O-x;for(let D=A;D<M;D+=u){const z=D-k,B=m.get(g,O,D,y);B>E&&(E=B,s?N=i?((g*r.inHeight+O)*r.inWidth+D)*r.inChannels+y:(O*r.inWidth+D)*r.inChannels+y:N=R*f+z)}}o.set(N,g,b,C,y)}}return o}function fJ(n,e,t,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,h=s.dilationWidth,f=s.effectiveFilterDepth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Sn(s.outShape,t),w=x.values,S=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],A=s.outShape[4];for(let M=0;M<s.batchSize;++M){const E=M*S,N=M*r[0];for(let O=0;O<s.inChannels;++O)for(let R=0;R<s.outDepth;++R){const D=R*o-m;let z=D;for(;z<0;)z+=c;const B=Math.min(s.inDepth,f+D),X=E+R*C;for(let G=0;G<s.outHeight;++G){const te=G*a-g;let ge=te;for(;ge<0;)ge+=u;const ae=Math.min(s.inHeight,d+te),Ne=X+G*k;for(let ke=0;ke<s.outWidth;++ke){const De=ke*l-y;let be=De;for(;be<0;)be+=h;const Xe=Math.min(s.inWidth,p+De),Oe=Ne+ke*A;let it=b,We=0,dt=0;for(let Ve=z;Ve<B;Ve+=c){const ze=N+Ve*r[1];for(let Be=ge;Be<ae;Be+=u){const ut=ze+Be*r[2];for(let Ke=be;Ke<Xe;Ke+=h){const ee=ut+Ke*r[3],J=n[ee+O];if(i==="max"&&J>it?it=J:i==="avg"&&(We+=J,dt++),isNaN(it))break}if(isNaN(it))break}if(isNaN(it))break}const ct=Oe+O;w[ct]=i==="avg"?We/Math.max(dt,1):it}}}}return x}function K2e(n,e){const t=Sn(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=e.padInfo.front,d=e.padInfo.top,p=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const b=y*r-f;let x=b;for(;x<0;)x+=o;const w=Math.min(e.inDepth,c+b);for(let S=0;S<e.outHeight;++S){const C=S*s-d;let k=C;for(;k<0;)k+=a;const A=Math.min(e.inHeight,u+C);for(let M=0;M<e.outWidth;++M){const E=M*i-p;let N=E;for(;N<0;)N+=l;const O=Math.min(e.inWidth,h+E);let R=Number.NEGATIVE_INFINITY,D=-1;for(let z=x;z<w;z+=o){const B=z-b;for(let X=k;X<A;X+=a){const G=X-C;for(let te=N;te<O;te+=l){const ge=te-E,ae=n.get(m,z,X,te,g);ae>=R&&(R=ae,D=B*u*h+G*u+ge)}}}t.set(D,m,y,S,M,g)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Zt(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))h=xh({inputs:{x:s},backend:t});else{const f=t.data.get(s.dataId).values,d=Jt(s.shape),p=iB(f,s.shape,s.dtype,d,u,"avg");h=t.makeTensorInfo(u.outShape,s.dtype,p.values)}return h}const Z2e={kernelName:Mv,backendName:"cpu",kernelFunc:Y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Zt(s,"avgPool3d");const u=Ol(s.shape,i,o,1,a,l,c),h=t.data.get(s.dataId).values,f=fJ(h,s.shape,s.dtype,Jt(s.shape),u,"avg");return t.makeTensorInfo(f.shape,"float32",f.values)}const Q2e={kernelName:Nv,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Zt([s,i],"avgPool3DGrad");const u=Ol(i.shape,o,a,1,l,c),h=u.strideDepth,f=u.strideHeight,d=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,w=u.effectiveFilterDepth,S=u.effectiveFilterHeight,C=u.effectiveFilterWidth,k=w-1-u.padInfo.front,A=C-1-u.padInfo.left,M=S-1-u.padInfo.top,E=Sn(i.shape,"float32"),N=1/(p*m*g),O=t.bufferSync(s);for(let R=0;R<u.batchSize;++R)for(let D=0;D<u.inChannels;++D)for(let z=0;z<u.inDepth;++z)for(let B=0;B<u.inHeight;++B)for(let X=0;X<u.inWidth;++X){const G=z-k,te=B-M,ge=X-A;let ae=0;for(let Ne=0;Ne<w;Ne+=y){const ke=(G+Ne)/h;if(!(ke<0||ke>=u.outDepth||Math.floor(ke)!==ke))for(let De=0;De<S;De+=b){const be=(te+De)/f;if(!(be<0||be>=u.outHeight||Math.floor(be)!==be))for(let Xe=0;Xe<C;Xe+=x){const Oe=(ge+Xe)/d;if(Oe<0||Oe>=u.outWidth||Math.floor(Oe)!==Oe)continue;const it=O.get(R,ke,be,Oe,D);ae+=it}}}E.set(ae*N,R,z,B,X,D)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const tCe={kernelName:qS,backendName:"cpu",kernelFunc:eCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;Zt([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=u.strideHeight,f=u.strideWidth,d=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,w=y-1-u.padInfo.top,S=Sn(o.shape,"float32"),C=1/(d*p),k=t.data.get(s.dataId).values,A=Sn(s.shape,"float32",k);for(let M=0;M<u.batchSize;++M)for(let E=0;E<u.inChannels;++E)for(let N=0;N<u.inHeight;++N)for(let O=0;O<u.inWidth;++O){const R=N-w,D=O-x;let z=0;for(let B=0;B<y;B+=m){const X=(R+B)/h;if(!(X<0||X>=u.outHeight||Math.floor(X)!==X))for(let G=0;G<b;G+=g){const te=(D+G)/f;if(te<0||te>=u.outWidth||Math.floor(te)!==te)continue;const ge=A.get(M,X,te,E);z+=ge}}S.set(z*C,M,N,O,E)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const rCe={kernelName:jS,backendName:"cpu",kernelFunc:nCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=e;U(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Zt([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);const u=t.data.get(s.dataId).values,h=t.data.get(a.dataId).values,f=t.data.get(l.dataId).values,d=i?t.data.get(i.dataId).values:new Float32Array([1]),p=o?t.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=d.length,b=f.length,x=h.length;let w=0,S=0,C=0,k=0;for(let A=0;A<u.length;++A)m[A]=p[w++]+(u[A]-h[S++])*d[C++]/Math.sqrt(f[k++]+c),w>=g&&(w=0),S>=x&&(S=0),C>=y&&(C=0),k>=b&&(k=0);return t.makeTensorInfo(s.shape,s.dtype,m)}const iCe={kernelName:Gv,backendName:"cpu",kernelFunc:sCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;Zt([s],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=Oy(s.shape,i,a),c=Fy(l.length,i.length),u=Ly(s.shape,i,a),h=dN(o,i.length),f=pN(u,o,i.length),d=es({inputs:{x:s},backend:t,attrs:{shape:l}}),p=_a({inputs:{x:d},backend:t,attrs:{perm:c}}),m=es({inputs:{x:p},backend:t,attrs:{shape:u}}),g=ug({inputs:{x:m},backend:t,attrs:{begin:h,size:f}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const aCe={kernelName:Rv,backendName:"cpu",kernelFunc:oCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=eB(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const cCe={kernelName:XS,backendName:"cpu",kernelFunc:lCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uCe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=ln(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const hCe={kernelName:YS,backendName:"cpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCe=$r(Hg,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),dCe={kernelName:Hg,backendName:"cpu",kernelFunc:fCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pCe=n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(Te(e.shape)),s=t.data.get(e.dataId),i=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],h=l[c];r[c]=Math.hypot(u,h)}return t.makeOutput(r,e.shape,"float32")},mCe={kernelName:Pv,backendName:"cpu",kernelFunc:pCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jb(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.imag,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const gCe={kernelName:g2,backendName:"cpu",kernelFunc:Jb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qb(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=An(s,e[0].shape)[0],o=e.map(m=>m.shape);uN(o,i);let a=ya(e.map(m=>m.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(m=>Te(m.shape)>0);if(l.length===1)return xh({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const m=l.map(w=>cg({inputs:{input:w},backend:t})),g=l.map(w=>Jb({inputs:{input:w},backend:t})),y=Qb({inputs:m,backend:t,attrs:{axis:i}}),b=Qb({inputs:g,backend:t,attrs:{axis:i}}),x=Ua({inputs:{real:y,imag:b},backend:t});return m.forEach(w=>t.disposeIntermediateTensorInfo(w)),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),x}const c=l.map(m=>{const y=[-1,Te(m.shape.slice(i))];return es({inputs:{x:m},backend:t,attrs:{shape:y}})}),u=c.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));a=ya(c.map(m=>m.shape),1);const h=c[0].shape[0]===1,f=gZ(u,a,e[0].dtype,h),d=ya(l.map(m=>m.shape),i),p=t.makeTensorInfo(d,e[0].dtype,f);return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const yCe={kernelName:Dv,backendName:"cpu",kernelFunc:Qb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Zt([s,i],"conv2d");const h=el(l),f=ts(s.shape,i.shape,o,c,a,u,!1,h),d=f.filterHeight,p=f.filterWidth,m=f.dilationHeight,g=f.dilationWidth,y=f.padInfo.left,b=f.padInfo.top,x=f.dataFormat==="channelsLast",w=new li(f.outShape,s.dtype),S=Jt(s.shape),C=Jt(i.shape),k=S[0],A=x?S[1]:S[2],M=x?S[2]:1,E=x?1:S[1],N=w.strides[0],O=x?w.strides[1]:w.strides[2],R=x?w.strides[2]:1,D=x?1:w.strides[1],z=t.data.get(s.dataId).values,B=t.data.get(i.dataId).values,X=w.values;for(let G=0;G<f.batchSize;++G){const te=G*k,ge=G*N;for(let ae=0;ae<f.outHeight;++ae){const Ne=ge+ae*O,ke=ae*f.strideHeight-b;for(let De=0;De<d;++De){const be=ke+De*m;if(be<0||be>=f.inHeight)continue;const Xe=De*C[0],Oe=te+be*A;for(let it=0;it<f.outWidth;++it){const We=Ne+it*R,dt=it*f.strideWidth-y;for(let ct=0;ct<p;++ct){const Ve=dt+ct*g;if(Ve<0||Ve>=f.inWidth)continue;const ze=Xe+ct*C[1],Be=Oe+Ve*M;let ut=ze;for(let Ke=0;Ke<f.inChannels;++Ke){const ee=z[Be+Ke*E];for(let J=0;J<f.outChannels;++J)X[We+J*D]+=ee*B[ut+J];ut+=f.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,X)}const bCe={kernelName:Ov,backendName:"cpu",kernelFunc:dJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Zt([s,i],"conv2dBackpropFilter");const h=el(l),f=ts(s.shape,u,o,1,a,c,!1,h),{strideHeight:d,strideWidth:p,filterHeight:m,filterWidth:g}=f,y=f.dataFormat==="channelsLast",b=new li(f.filterShape,"float32"),x=f.padInfo.left,w=f.padInfo.top,S=t.data.get(s.dataId).values,C=t.data.get(i.dataId).values,k=new li(s.shape,s.dtype,S),A=new li(i.shape,i.dtype,C);for(let M=0;M<m;++M){const E=Math.max(0,Math.ceil((w-M)/d)),N=Math.min(f.outHeight,(f.inHeight+w-M)/d);for(let O=0;O<g;++O){const R=Math.max(0,Math.ceil((x-O)/p)),D=Math.min(f.outWidth,(f.inWidth+x-O)/p);for(let z=0;z<f.inChannels;++z)for(let B=0;B<f.outChannels;++B){let X=0;for(let G=0;G<f.batchSize;++G)for(let te=E;te<N;++te){const ge=M+te*d-w;for(let ae=R;ae<D;++ae){const Ne=O+ae*p-x;y?X+=k.get(G,ge,Ne,z)*A.get(G,te,ae,B):X+=k.get(G,z,ge,Ne)*A.get(G,B,te,ae)}}b.set(X,M,O,z,B)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const wCe={kernelName:JS,backendName:"cpu",kernelFunc:vCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Zt([s,i],"conv2dBackpropInput");const h=Jt(i.shape),f=Jt(s.shape);let d=el(c);const p=ts(o,i.shape,a,1,l,u,!1,d),m=new li(p.inShape,"float32"),g=m.values,y=t.data.get(s.dataId).values,b=t.data.get(i.dataId).values,[x,w,S]=h,{batchSize:C,filterHeight:k,filterWidth:A,inChannels:M,inHeight:E,inWidth:N,outChannels:O,outHeight:R,outWidth:D,strideHeight:z,strideWidth:B}=p;d=p.dataFormat;const X=k-1-p.padInfo.top,G=A-1-p.padInfo.left,te=d==="channelsLast",ge=m.strides[0],ae=te?m.strides[1]:m.strides[2],Ne=te?m.strides[2]:1,ke=te?1:m.strides[1],De=f[0],be=te?f[1]:f[2],Xe=te?f[2]:1,Oe=te?1:f[1];for(let it=0;it<C;++it)for(let We=0;We<M;++We)for(let dt=0;dt<E;++dt){const ct=dt-X,Ve=Math.max(0,Math.ceil(ct/z)),ze=Math.min(R,(k+ct)/z);for(let Be=0;Be<N;++Be){const ut=Be-G,Ke=Math.max(0,Math.ceil(ut/B)),ee=Math.min(D,(A+ut)/B);let J=0;for(let Ge=Ve;Ge<ze;++Ge){const ye=Ge*z-ct;for(let Ze=Ke;Ze<ee;++Ze){const yt=Ze*B-ut,Ct=De*it+be*Ge+Xe*Ze,ft=x*(k-1-ye)+w*(A-1-yt)+S*We;for(let ce=0;ce<O;++ce){const nt=y[Ct+Oe*ce],St=b[ft+ce];J+=nt*St}}}const rt=ge*it+ae*dt+Ne*Be+ke*We;g[rt]=J}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const _Ce={kernelName:Fv,backendName:"cpu",kernelFunc:xCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r;Zt([s,i],"conv3d");const c=Ou(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:h,filterWidth:f,dilationDepth:d,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,x=g.top,w=new li(c.outShape,s.dtype),S=t.data.get(s.dataId).values,C=t.data.get(i.dataId).values,k=w.values,A=Jt(s.shape),M=Jt(i.shape);for(let E=0;E<c.batchSize;++E){const N=E*A[0],O=E*w.strides[0];for(let R=0;R<c.outDepth;++R){const D=O+R*w.strides[1],z=R*c.strideDepth-y;for(let B=0;B<u;++B){const X=z+B*d;if(X<0||X>=c.inDepth)continue;const G=B*M[0],te=N+X*A[1];for(let ge=0;ge<c.outHeight;++ge){const ae=D+ge*w.strides[2],Ne=ge*c.strideHeight-x;for(let ke=0;ke<h;++ke){const De=Ne+ke*p;if(De<0||De>=c.inHeight)continue;const be=G+ke*M[1],Xe=te+De*A[2];for(let Oe=0;Oe<c.outWidth;++Oe){const it=ae+Oe*c.outChannels,We=Oe*c.strideWidth-b;for(let dt=0;dt<f;++dt){const ct=We+dt*m;if(ct<0||ct>=c.inWidth)continue;const Ve=be+dt*M[2],ze=Xe+ct*c.inChannels;let Be=Ve;for(let ut=0;ut<c.inChannels;++ut){const Ke=S[ze+ut];for(let ee=0;ee<c.outChannels;++ee)k[it+ee]+=Ke*C[Be+ee];Be+=c.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const CCe={kernelName:Lv,backendName:"cpu",kernelFunc:SCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r;Zt([s,i],"conv3dBackpropFilterV2");const c=Jt(s.shape),u=Jt(i.shape),h=Ou(s.shape,l,o,1,a),f=h.strideDepth,d=h.strideHeight,p=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new li(h.filterShape,"float32"),x=b.values,[w,S,C,k]=b.strides,A=t.data.get(i.dataId).values,[M,E,N,O]=u,R=t.data.get(s.dataId).values,[D,z,B,X]=c,G=h.padInfo.front,te=h.padInfo.left,ge=h.padInfo.top;for(let ae=0;ae<m;++ae){const Ne=Math.max(0,Math.ceil((G-ae)/f)),ke=Math.min(h.outDepth,(h.inDepth+G-ae)/f),De=ae*w;for(let be=0;be<g;++be){const Xe=Math.max(0,Math.ceil((ge-be)/d)),Oe=Math.min(h.outHeight,(h.inHeight+ge-be)/d),it=be*S+De;for(let We=0;We<y;++We){const dt=Math.max(0,Math.ceil((te-We)/p)),ct=Math.min(h.outWidth,(h.inWidth+te-We)/p),Ve=We*C+it;for(let ze=0;ze<h.inChannels;++ze){const Be=ze*k+Ve;for(let ut=0;ut<h.outChannels;++ut){let Ke=0;for(let ee=0;ee<h.batchSize;++ee){const J=ee*D,rt=ee*M;for(let Ge=Ne;Ge<ke;++Ge){const Ze=(ae+Ge*f-G)*z+J,yt=Ge*E+rt;for(let Ct=Xe;Ct<Oe;++Ct){const ce=(be+Ct*d-ge)*B+Ze,nt=Ct*N+yt;for(let St=dt;St<ct;++St){const Gt=(We+St*p-te)*X+ce,Mn=St*O+nt;Ke+=R[Gt+ze]*A[Mn+ut]}}}}x[Be+ut]=Ke}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const TCe={kernelName:QS,backendName:"cpu",kernelFunc:kCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r;Zt([s],"conv3dBackpropInputV2");const c=Jt(s.shape),u=Jt(i.shape),h=Ou(l,i.shape,a,1,o),f=new li(h.inShape,"float32"),d=f.values,[p,m,g,y]=f.strides,b=t.data.get(s.dataId).values,[x,w,S,C]=c,k=t.data.get(i.dataId).values,[A,M,E,N]=u,{batchSize:O,filterDepth:R,filterHeight:D,filterWidth:z,inChannels:B,inDepth:X,inHeight:G,inWidth:te,outChannels:ge,outDepth:ae,outHeight:Ne,outWidth:ke,strideDepth:De,strideHeight:be,strideWidth:Xe}=h,Oe=R-1-h.padInfo.front,it=D-1-h.padInfo.top,We=z-1-h.padInfo.left;for(let dt=0;dt<O;++dt)for(let ct=0;ct<B;++ct)for(let Ve=0;Ve<X;++Ve){const ze=Ve-Oe,Be=Math.max(0,Math.ceil(ze/De)),ut=Math.min(ae,(R+ze)/De);for(let Ke=0;Ke<G;++Ke){const ee=Ke-it,J=Math.max(0,Math.ceil(ee/be)),rt=Math.min(Ne,(D+ee)/be);for(let Ge=0;Ge<te;++Ge){const ye=Ge-We,Ze=Math.max(0,Math.ceil(ye/Xe)),yt=Math.min(ke,(z+ye)/Xe);let Ct=0;for(let ft=Be;ft<ut;++ft){const ce=ft*De-ze;for(let nt=J;nt<rt;++nt){const St=nt*be-ee;for(let gt=Ze;gt<yt;++gt){const Gt=gt*Xe-ye,Mn=x*dt+w*ft+S*nt+C*gt,Cr=A*(R-1-ce)+M*(D-1-St)+E*(z-1-Gt)+N*ct;for(let Bs=0;Bs<ge;++Bs){const As=b[Mn+Bs],Ms=k[Cr+Bs];Ct+=As*Ms}}}}d[p*dt+m*Ve+g*Ke+y*Ge+ct]=Ct}}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const ICe={kernelName:e2,backendName:"cpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ACe=$r(jg,n=>Math.cos(n)),MCe={kernelName:jg,backendName:"cpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NCe=$r(qg,n=>Math.cosh(n)),$Ce={kernelName:qg,backendName:"cpu",kernelFunc:NCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,[u,h,f,d]=s.shape,p=i.shape[0],[m,g]=a,y=Sn([p,m,g,d],"float32"),b=t.data.get(i.dataId).values,x=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,S=Jt(s.shape),C=Jt(y.shape);for(let k=0;k<p;k++){const A=k*4,M=b[A],E=b[A+1],N=b[A+2],O=b[A+3],R=x[k];if(R>=u)continue;const D=m>1?(N-M)*(h-1)/(m-1):0,z=g>1?(O-E)*(f-1)/(g-1):0;for(let B=0;B<m;B++){const X=m>1?M*(h-1)+B*D:.5*(M+N)*(h-1);if(X<0||X>h-1){for(let G=0;G<g;G++)for(let te=0;te<d;te++){const ge=te+G*C[2]+B*C[1]+k*C[0];y.values[ge]=c}continue}if(l==="bilinear"){const G=Math.floor(X),te=Math.ceil(X),ge=X-G;for(let ae=0;ae<g;ae++){const Ne=g>1?E*(f-1)+ae*z:.5*(E+O)*(f-1);if(Ne<0||Ne>f-1){for(let Xe=0;Xe<d;Xe++){const Oe=Xe+ae*C[2]+B*C[1]+k*C[0];y.values[Oe]=c}continue}const ke=Math.floor(Ne),De=Math.ceil(Ne),be=Ne-ke;for(let Xe=0;Xe<d;Xe++){let Oe=Xe+ke*S[2]+G*S[1]+R*S[0];const it=w[Oe];Oe=Xe+De*S[2]+G*S[1]+R*S[0];const We=w[Oe];Oe=Xe+ke*S[2]+te*S[1]+R*S[0];const dt=w[Oe];Oe=Xe+De*S[2]+te*S[1]+R*S[0];const ct=w[Oe],Ve=it+(We-it)*be,ze=dt+(ct-dt)*be;Oe=Xe+ae*C[2]+B*C[1]+k*C[0],y.values[Oe]=Ve+(ze-Ve)*ge}}}else for(let G=0;G<g;++G){const te=g>1?E*(f-1)+G*z:.5*(E+O)*(f-1);if(te<0||te>f-1){for(let Ne=0;Ne<d;Ne++){const ke=Ne+G*C[2]+B*C[1]+k*C[0];y.values[ke]=c}continue}const ge=Math.round(te),ae=Math.round(X);for(let Ne=0;Ne<d;Ne++){const ke=Ne+ge*S[2]+ae*S[1]+R*S[0],De=Ne+G*C[2]+B*C[1]+k*C[0];y.values[De]=w[ke]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const PCe={kernelName:n2,backendName:"cpu",kernelFunc:RCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Zt(s,"cumprod");const l=Lr([i],s.shape.length);let c=s;l!=null&&(c=_a({inputs:{x:s},backend:t,attrs:{perm:l}}));const u=ns(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Mi(c.dtype,"int32"),f=xM(Te(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const x=m(y,b);if(b===0)f[x]=o?1:d[x];else{const w=m(y,b-1);f[x]=o?d[w]*f[w]:d[x]*f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Mh(l),b=_a({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const OCe={kernelName:t2,backendName:"cpu",kernelFunc:DCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Zt(s,"cumsum");const l=Lr([i],s.shape.length);let c=s;l!=null&&(c=_a({inputs:{x:s},backend:t,attrs:{perm:l}}));const u=ns(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Mi(c.dtype,"int32"),f=ji(Te(c.shape),h),d=t.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<d.length;y+=p)for(let b=0;b<p;b++){const x=m(y,b);if(b===0)f[x]=o?0:d[x];else{const w=m(y,b-1);f[x]=o?d[w]+f[w]:d[x]+f[w]}}const g=t.makeTensorInfo(c.shape,h,f);if(l!=null){const y=Mh(l),b=_a({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(c),b}return g}const LCe={kernelName:zv,backendName:"cpu",kernelFunc:FCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=eB(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(s.shape.length===2){const l=t.bufferSync(s),c=t.bufferSync(i),u=dZ(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const BCe={kernelName:r2,backendName:"cpu",kernelFunc:zCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r;U(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],h=l*i,f=c*i,d=u/(i*i),p=t.data.get(s.dataId).values,m=new Float32Array(a*h*f*d);let g=0;for(let y=0;y<a;++y)for(let b=0;b<h;++b){const x=Math.floor(b/i),w=b%i;for(let S=0;S<f;++S){const C=Math.floor(S/i),k=S%i,A=(w*i+k)*d;for(let M=0;M<d;++M){const N=M+A+u*(C+c*(x+l*y));m[g++]=p[N]}}}return t.makeTensorInfo([a,h,f,d],s.dtype,m)}const UCe={kernelName:s2,backendName:"cpu",kernelFunc:VCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Zt([s,i],"depthwiseConv2DNative");const u=Jt(s.shape),h=Jt(i.shape);let f=l;f==null&&(f=[1,1]),U(Ri(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const d=ts(s.shape,i.shape,o,f,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=d,x=b.left,w=b.top,S=d.outChannels/d.inChannels,C=new li(d.outShape,s.dtype),k=t.data.get(s.dataId).values,A=t.data.get(i.dataId).values,M=C.values;for(let E=0;E<d.batchSize;++E){const N=E*u[0],O=E*C.strides[0];for(let R=0;R<d.outHeight;++R){const D=O+R*C.strides[1],z=R*d.strideHeight-w;for(let B=0;B<p;++B){const X=z+B*g;if(X<0||X>=d.inHeight)continue;const G=B*h[0],te=N+X*u[1];for(let ge=0;ge<d.outWidth;++ge){const ae=D+ge*C.strides[2],Ne=ge*d.strideWidth-x;for(let ke=0;ke<m;++ke){const De=Ne+ke*y;if(De<0||De>=d.inWidth)continue;const be=G+ke*h[1],Xe=te+De*d.inChannels;let Oe=ae,it=be;for(let We=0;We<d.inChannels;++We){const dt=k[Xe+We];for(let ct=0;ct<S;++ct)M[Oe+ct]+=dt*A[it+ct];Oe+=S,it+=S}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const WCe={kernelName:Bv,backendName:"cpu",kernelFunc:pJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Zt([s,i],"depthwiseConv2dNativeBackpropFilter");const h=ts(s.shape,u,o,a,l,c,!0),{strideHeight:f,strideWidth:d,filterHeight:p,filterWidth:m}=h,g=new li(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,w=t.data.get(s.dataId).values,S=new li(s.shape,s.dtype,w),C=t.data.get(i.dataId).values,k=new li(i.shape,i.dtype,C);for(let A=0;A<p;++A){const M=Math.max(0,Math.ceil((b-A)/f)),E=Math.min(h.outHeight,(h.inHeight+b-A)/f);for(let N=0;N<m;++N){const O=Math.max(0,Math.ceil((y-N)/d)),R=Math.min(h.outWidth,(h.inWidth+y-N)/d);for(let D=0;D<h.outChannels;++D){const z=Math.trunc(D/x),B=D%x;let X=0;for(let G=0;G<h.batchSize;++G)for(let te=M;te<E;++te){const ge=A+te*f-b;for(let ae=O;ae<R;++ae){const Ne=N+ae*d-y;X+=S.get(G,ge,Ne,z)*k.get(G,te,ae,D)}}g.set(X,A,N,z,B)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const HCe={kernelName:i2,backendName:"cpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jCe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Zt([s,i],"depthwiseConv2DNativeBackpropInput");const h=Jt(s.shape),f=Jt(i.shape),d=ts(u,i.shape,o,a,l,c,!0),p=new li(d.inShape,"float32"),m=p.values,[g,y,b]=p.strides,x=t.data.get(s.dataId).values,[w,S,C]=h,k=t.data.get(i.dataId).values,[A,M,E]=f,{batchSize:N,filterHeight:O,filterWidth:R,inChannels:D,inHeight:z,inWidth:B,outChannels:X,outHeight:G,outWidth:te,strideHeight:ge,strideWidth:ae}=d,Ne=O-1-d.padInfo.top,ke=R-1-d.padInfo.left,De=X/D;for(let be=0;be<N;++be)for(let Xe=0;Xe<D;++Xe)for(let Oe=0;Oe<z;++Oe){const it=Oe-Ne,We=Math.max(0,Math.ceil(it/ge)),dt=Math.min(G,(O+it)/ge);for(let ct=0;ct<B;++ct){const Ve=ct-ke,ze=Math.max(0,Math.ceil(Ve/ae)),Be=Math.min(te,(R+Ve)/ae);let ut=0;for(let Ke=We;Ke<dt;++Ke){const ee=Ke*ge-it;for(let J=ze;J<Be;++J){const rt=J*ae-Ve,Ge=w*be+S*Ke+C*J,ye=A*(O-1-ee)+M*(R-1-rt)+E*Xe;for(let Ze=0;Ze<De;++Ze){const yt=Xe*De+Ze,Ct=x[Ge+yt],ft=k[ye+Ze];ut+=Ct*ft}}}m[g*be+y*Oe+b*ct+Xe]=ut}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const qCe={kernelName:o2,backendName:"cpu",kernelFunc:jCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=Te(r.shape),i=t.data.get(r.dataId).values,o=Sn([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const KCe={kernelName:a2,backendName:"cpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YCe={kernelName:Vv,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=t,l=e,c=l.data.get(r.dataId).values,u=r.shape.length,h=l.data.get(s.dataId).values,f=s.shape.length,{batchSize:d,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:w,strideWidth:S,filterHeight:C,filterWidth:k,dilationHeight:A,dilationWidth:M,outShape:E}=Ap(r.shape,s.shape,i,o,"NHWC",a),N=Te(E),O=E.length,R=Ss(r.dtype,N);for(let z=0;z<d;++z)for(let B=0;B<y;++B){const X=B*w-x.top;for(let G=0;G<b;++G){const te=G*S-x.left;for(let ge=0;ge<g;++ge){let ae=Number.MIN_SAFE_INTEGER;for(let ke=0;ke<C;++ke){const De=X+ke*A;if(De>=0&&De<p)for(let be=0;be<k;++be){const Xe=te+be*M;if(Xe>=0&&Xe<m){const Oe=mu([z,De,Xe,ge],u,Jt(r.shape)),it=mu([ke,be,ge],f,Jt(s.shape)),We=c[Oe]+h[it];We>ae&&(ae=We)}}}const Ne=mu([z,B,G,ge],O,Jt(E));R[Ne]=ae}}}return{dataId:l.write(Ep(R,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZCe={kernelName:m_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Cl(r.shape,c.data.get(r.dataId).values),h=Cl(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=Ap(r.shape,s.shape,o,a,"NHWC",l);U(i.rank===M.length,()=>`Error in ${m_}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const E=Cl(M,c.data.get(i.dataId).values),N=CL(s.shape,s.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*x-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let G=0;G<m;++G){let te=Number.MIN_SAFE_INTEGER,ge=0,ae=0;for(let Ne=0;Ne<S;++Ne){const ke=z+Ne*k;if(ke>=0&&ke<d)for(let De=0;De<C;++De){const be=X+De*A;if(be>=0&&be<p){const Xe=u[R][ke][be][G]+h[Ne][De][G];Xe>te&&(te=Xe,ge=Ne,ae=De)}}}N[ge][ae][G]+=E[R][D][B][G]}}}return{dataId:c.write(Ep(N,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JCe={kernelName:p_,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Cl(r.shape,c.data.get(r.dataId).values),h=Cl(s.shape,c.data.get(s.dataId).values),{batchSize:f,inHeight:d,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:w,filterHeight:S,filterWidth:C,dilationHeight:k,dilationWidth:A,outShape:M}=Ap(r.shape,s.shape,o,a,"NHWC",l);U(i.rank===M.length,()=>`Error in ${p_}, dy must have the same rank as output ${M.length}, but got ${i.rank}`);const E=Cl(M,c.data.get(i.dataId).values),N=CL(r.shape,r.dtype);for(let R=0;R<f;++R)for(let D=0;D<g;++D){const z=D*x-b.top;for(let B=0;B<y;++B){const X=B*w-b.left;for(let G=0;G<m;++G){let te=Number.MIN_SAFE_INTEGER,ge=z<0?0:z,ae=X<0?0:X;for(let Ne=0;Ne<S;++Ne){const ke=z+Ne*k;if(ke>=0&&ke<d)for(let De=0;De<C;++De){const be=X+De*A;if(be>=0&&be<p){const Xe=u[R][ke][be][G]+h[Ne][De][G];Xe>te&&(te=Xe,ge=ke,ae=be)}}}N[R][ge][ae][G]+=E[R][D][B][G]}}}return{dataId:c.write(Ep(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QCe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,{contextOptions:a,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,u=(a==null?void 0:a.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(u,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${u} type.`);const[f,d]=s.shape.slice(0,2),p=s.shape.length===2?1:s.shape[2],m=t.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let x=0;x<f*d;++x){const w=[0,0,0,255*c];for(let C=0;C<p;C++){const k=m[x*p+C];if(s.dtype==="float32"){if(k<0||k>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${k}.`)}else if(s.dtype==="int32"&&(k<0||k>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${k}.`);p===1?(w[0]=k*g,w[1]=k*g,w[2]=k*g):w[C]=k*g}const S=x*4;y[S+0]=Math.round(w[0]),y[S+1]=Math.round(w[1]),y[S+2]=Math.round(w[2]),y[S+3]=Math.round(w[3])}i.width=d,i.height=f;const b=new ImageData(y,d,f);return h.putImageData(b,0,0),s}const eke={kernelName:l2,backendName:"cpu",kernelFunc:QCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"sum");let a;s.dtype==="bool"?a=ap({inputs:{x:s},backend:t,attrs:{dtype:"int32"}}):a=xh({inputs:{x:s},backend:t});const l=a.shape.length,c=An(i,a.shape),u=Lr(c,l);let h=c,f=a;u!=null&&(f=_a({inputs:{x:a},backend:t,attrs:{perm:u}}),h=ns(h.length,l)),fi("sum",h,f.shape.length);const[d,p]=Qs(f.shape,h),m=Mi(f.dtype,"int32");let g=MI(t,d,m);const y=Te(p),b=t.data.get(g.dataId).values,x=t.data.get(f.dataId).values;for(let w=0;w<b.length;++w){const S=w*y;let C=0;for(let k=0;k<y;++k)C+=x[S+k];b[w]=C}if(o){const w=Ls(g.shape,c),S=g;g=es({inputs:{x:g},backend:t,attrs:{shape:w}}),t.disposeIntermediateTensorInfo(S)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(f),g}const tke={kernelName:ww,backendName:"cpu",kernelFunc:hC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nke(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=xN(s,i.length);SN(o.length,l,i);const{path:c,steps:u}=CN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=_N(d,l[g]);let x;kN(y)?x=i[g]:(x=_a({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(x.shape,w)||(x=es({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=AN({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=hC({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const rke={kernelName:c2,backendName:"cpu",kernelFunc:nke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ske(n){const{inputs:e,backend:t}=n,{dy:r,y:s}=e;Zt([r,s],"eluGrad");const i=new Float32Array(Te(s.shape)),o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?i[l]=a[l]:i[l]=a[l]*(c+1)}return t.makeTensorInfo(s.shape,"float32",i)}const ike={kernelName:u2,backendName:"cpu",kernelFunc:ske};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oke=mN,ake=gN,lke=yN,cke=bN,uke=vN,hke=wN,fke=$r(Yg,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+oke*t);return e*(1-((((hke*r+uke)*r+cke)*r+lke)*r+ake)*r*Math.exp(-t*t))}),dke={kernelName:Yg,backendName:"cpu",kernelFunc:fke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n){const{inputs:e,backend:t,attrs:r}=n,{input:s}=e,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(U(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),es({inputs:{x:s},backend:t,attrs:{shape:a}})}const pke={kernelName:Wv,backendName:"cpu",kernelFunc:RI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mke=ei((n,e)=>n/e),oB=Pi(Xg,mke),ID={kernelName:Xg,backendName:"cpu",kernelFunc:oB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(n,e,t){const r=n.shape,s=r[0],i=r[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=Te(c),h=ci("float32",u),f=ci("float32",u);for(let g=0;g<s;g++){const y=ug({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,i]}}),b=ug({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,i]}}),x=Ua({inputs:{real:y,imag:b},backend:t}),{real:w,imag:S}=gke(x,e,t),C=wu(w,S);for(let k=0;k<i;k++){const A=Zz(C,k);h[g*i+k]=A.real,f[g*i+k]=A.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x)}const d=t.makeTensorInfo(c,"float32",h),p=t.makeTensorInfo(c,"float32",f),m=Ua({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),m}function gke(n,e,t){const r=Te(n.shape),s=t.data.get(n.dataId),i=t.data.get(s.complexTensorInfos.real.dataId).values,o=t.data.get(s.complexTensorInfos.imag.dataId).values;if(yke(r)){const a=AD(i,o,r,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Bf(r,"float32")),f=xh({inputs:{x:h},backend:t}),d=ID.kernelFunc({inputs:{a:c,b:h},backend:t}),p=ID.kernelFunc({inputs:{a:u,b:f},backend:t}),m=t.data.get(d.dataId).values,g=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}else{const a=wu(i,o),l=bke(a,r,e);return WY(l)}}function yke(n){return(n&n-1)===0}function AD(n,e,t,r,s){if(t===1)return{real:n,imag:e};const i=wu(n,e),o=t/2,a=GY(i),l=a.real,c=a.imag,u=[l.length],h=s.makeTensorInfo(u,"float32",l),f=s.makeTensorInfo(u,"float32",c),d=Ua({inputs:{real:h,imag:f},backend:s}),p=HY(i),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),w=Ua({inputs:{real:b,imag:x},backend:s}),S=AD(l,c,o,r,s),C=S.real,k=S.imag,A=[C.length],M=s.makeTensorInfo(A,"float32",C),E=s.makeTensorInfo(A,"float32",k),N=Ua({inputs:{real:M,imag:E},backend:s}),O=AD(m,g,o,r,s),R=O.real,D=O.imag,z=[R.length],B=s.makeTensorInfo(z,"float32",R),X=s.makeTensorInfo(z,"float32",D),G=Ua({inputs:{real:B,imag:X},backend:s}),te=qY(t,r),ge=[te.real.length],ae=s.makeTensorInfo(ge,"float32",te.real),Ne=s.makeTensorInfo(ge,"float32",te.imag),ke=Ua({inputs:{real:ae,imag:Ne},backend:s}),De=AN({inputs:{a:ke,b:G},backend:s}),be=Zb({inputs:{a:N,b:De},backend:s}),Xe=sB({inputs:{a:N,b:De},backend:s}),Oe=cg({inputs:{input:be},backend:s}),it=cg({inputs:{input:Xe},backend:s}),We=Jb({inputs:{input:be},backend:s}),dt=Jb({inputs:{input:Xe},backend:s}),ct=Qb({inputs:[Oe,it],backend:s,attrs:{axis:0}}),Ve=Qb({inputs:[We,dt],backend:s,attrs:{axis:0}}),ze=s.data.get(ct.dataId).values,Be=s.data.get(Ve.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(X),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(Ne),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(De),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Xe),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(We),s.disposeIntermediateTensorInfo(it),s.disposeIntermediateTensorInfo(dt),s.disposeIntermediateTensorInfo(ct),s.disposeIntermediateTensorInfo(Ve),{real:ze,imag:Be}}function bke(n,e,t){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let i=0,o=0;for(let a=0;a<e;a++){const l=XY(s*a,e,t),c=Zz(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(i/=e,o/=e),jY(r,i,o,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vke(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Te(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=es({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=mJ(a,!1,t),c=es({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const wke={kernelName:h2,backendName:"cpu",kernelFunc:vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(n){const{backend:e,attrs:t}=n,{shape:r,value:s,dtype:i}=t,o=i||Cp(s),a=Ss(o,Te(r));return _ke(a,s,o),e.makeTensorInfo(r,o,a)}const xke={kernelName:f2,backendName:"cpu",kernelFunc:aB};function _ke(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ske={kernelName:d2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,s=t,i=ci(r.dtype,Te(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let f=0;f<o;f++){const d=f*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const x=Math.round(l-g-1),w=d+m+y+b;let S=u[w];if(x>=0&&x<l){const C=x*c,k=d+m+C+b;S=u[k]}i[w]=S}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=dJ({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const y=es({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});m=Zb({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=Zb({inputs:{a:m,b:o},backend:t});t.disposeIntermediateTensorInfo(g)}if(d){const g=m;if(u==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const y=es({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=$I(t,m,d,y,p),t.disposeIntermediateTensorInfo(y)}else m=$I(t,m,d,a,p);t.disposeIntermediateTensorInfo(g)}return m}const kke={kernelName:Ub,backendName:"cpu",kernelFunc:Cke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r;let m=pJ({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f}});if(o){const g=m;m=Zb({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){const g=m;m=$I(t,m,d,a,p),t.disposeIntermediateTensorInfo(g)}return m}const Eke={kernelName:Wb,backendName:"cpu",kernelFunc:Tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ike(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=Te(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,h]=aC(r,s);if(c===0)return t.makeTensorInfo(l,r.dtype,[]);const f=t.data.get(s.dataId).values,d=t.bufferSync(r),p=CZ(f,d,r.dtype,c,a,u,h,r.shape,i);return t.makeTensorInfo(l,r.dtype,p.values)}const Ake={kernelName:p2,backendName:"cpu",kernelFunc:Ike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r;Zt([s,i],"gatherV2");const l=An(o,s.shape)[0],c=t.data.get(i.dataId).values,u=s.shape[l];for(let w=0;w<c.length;++w){const S=c[w];U(S<=u-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${u-1}]`)}let h=a;a==null&&(h=0);const f=Te(i.shape),d=EN(s,i,l,h),p=es({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=es({inputs:{x:i},backend:t,attrs:{shape:[d.batchSize,f/d.batchSize]}}),g=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=t.bufferSync(m),b=t.bufferSync(p),x=kZ(b,y,g);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(d.outputShape,x.dtype,x.values)}const Nke={kernelName:Hv,backendName:"cpu",kernelFunc:Mke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ke(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Te(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=es({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=mJ(a,!0,t),c=es({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Rke={kernelName:m2,backendName:"cpu",kernelFunc:$ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pke=$r(ry,n=>Number.isFinite(n)?1:0,"bool"),Dke={kernelName:ry,backendName:"cpu",kernelFunc:Pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oke=$r(sy,n=>Math.abs(n)===1/0?1:0,"bool"),Fke={kernelName:sy,backendName:"cpu",kernelFunc:Oke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lke=$r(iy,n=>Number.isNaN(n)?1:0,"bool"),zke={kernelName:iy,backendName:"cpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bke(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=MZ(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const Vke={kernelName:y2,backendName:"cpu",kernelFunc:Bke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uke=$r(ay,n=>Math.log1p(n)),Wke={kernelName:ay,backendName:"cpu",kernelFunc:Uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gke=ei((n,e)=>n&&e),Hke=Pi(Yv,Gke,null,"bool"),jke={kernelName:Yv,backendName:"cpu",kernelFunc:Hke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qke=$r(Zv,n=>n?0:1,"bool"),Xke={kernelName:Zv,backendName:"cpu",kernelFunc:qke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kke=ei((n,e)=>n||e),Yke=Pi(Jv,Kke,null,"bool"),Zke={kernelName:Jv,backendName:"cpu",kernelFunc:Yke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jke(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Zt(s,"LRN");const c=s.shape[3],u=c-1,h=t.data.get(s.dataId).values,f=Te(s.shape),d=new Float32Array(f);function p(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let x=0;for(;y<=b;y++){const w=h[y];x+=w*w}return x}for(let m=0;m<f;m++){const g=p(m),y=h[m]*Math.pow(o+a*g,-l);d[m]=y}return t.makeTensorInfo(s.shape,s.dtype,d)}const Qke={kernelName:Qv,backendName:"cpu",kernelFunc:Jke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Zt(o,"LRNGrad");const h=Te(o.shape),f=o.shape[3],d=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,m=t.data.get(i.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const x=b%f,w=b-x+Math.max(0,x-a),S=b-x+Math.min(f,x+a+1);let C=0;for(let k=w;k<S;k++)C+=Math.pow(p[k],2);C=c*C+l;for(let k=w;k<S;k++){let A=-2*c*u*p[k]*m[b]/C;b===k&&(A+=Math.pow(C,-u)),A*=d[b],g[k]+=A}}return t.makeTensorInfo(o.shape,s.dtype,g)}const tTe={kernelName:b2,backendName:"cpu",kernelFunc:eTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=t;let l=s.shape;const c=l.length,u=An(i,l);let h=u;const f=Lr(h,c);let d=a.data.get(s.dataId).values;if(f!=null){const w=new Array(c);for(let S=0;S<w.length;S++)w[S]=l[f[S]];d=nB(d,l,s.dtype,f,w),h=ns(h.length,c),l=w}Zt(s,"max"),fi("max",h,c);const[p,m]=Qs(l,h),g=Te(m),y=$Z(d,g,p,s.dtype),b=a.write(y,p,s.dtype);let x=p;return o&&(x=Ls(p,u)),{dataId:b,shape:x,dtype:s.dtype}}const nTe={kernelName:ew,backendName:"cpu",kernelFunc:gJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Zt(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))h=xh({inputs:{x:s},backend:t});else{const f=t.data.get(s.dataId).values,d=Jt(s.shape),p=iB(f,s.shape,s.dtype,d,u,"max");h=t.makeTensorInfo(u.outShape,s.dtype,p.values)}return h}const sTe={kernelName:tw,backendName:"cpu",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Zt(s,"maxPool3d");const u=Ol(s.shape,i,o,1,a,l,c),h=t.data.get(s.dataId).values,f=fJ(h,s.shape,s.dtype,Jt(s.shape),u,"max");return t.makeTensorInfo(f.shape,"float32",f.values)}const oTe={kernelName:nw,backendName:"cpu",kernelFunc:iTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aTe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Zt([s,i],"maxPool3DGrad");const u=Ol(i.shape,o,a,1,l,c),h=t.bufferSync(i),f=K2e(h,u),d=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,S=u.effectiveFilterWidth,C=x-1-u.padInfo.front,k=S-1-u.padInfo.left,A=w-1-u.padInfo.top,M=Sn(i.shape,"float32"),E=t.bufferSync(s);for(let N=0;N<u.batchSize;++N)for(let O=0;O<u.inChannels;++O)for(let R=0;R<u.inDepth;++R)for(let D=0;D<u.inHeight;++D)for(let z=0;z<u.inWidth;++z){const B=R-C,X=D-A,G=z-k;let te=0;for(let ge=0;ge<x;ge+=g){const ae=(B+ge)/d;if(!(ae<0||ae>=u.outDepth||Math.floor(ae)!==ae))for(let Ne=0;Ne<w;Ne+=y){const ke=(X+Ne)/p;if(!(ke<0||ke>=u.outHeight||Math.floor(ke)!==ke))for(let De=0;De<S;De+=b){const be=(G+De)/m;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;const Xe=x*w*S-1-f.get(N,ae,ke,be,O),Oe=ge*w*S+Ne*S+De,it=Xe===Oe?1:0;if(it===0)continue;const We=E.get(N,ae,ke,be,O);te+=We*it}}}M.set(te,N,R,D,z,O)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const lTe={kernelName:w2,backendName:"cpu",kernelFunc:aTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cTe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;Zt([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=t.data.get(a.dataId).values,p=Sn(f.outShape,a.dtype,hJ(d,a.shape,a.dtype,f).values),m=f.strideHeight,g=f.strideWidth,y=f.dilationHeight,b=f.dilationWidth,x=f.effectiveFilterHeight,w=f.effectiveFilterWidth,S=w-1-f.padInfo.left,C=x-1-f.padInfo.top,k=Sn(a.shape,"float32"),A=t.data.get(s.dataId).values,M=Sn(s.shape,"float32",A);for(let E=0;E<f.batchSize;++E)for(let N=0;N<f.inChannels;++N)for(let O=0;O<f.inHeight;++O)for(let R=0;R<f.inWidth;++R){const D=O-C,z=R-S;let B=0;for(let X=0;X<x;X+=y){const G=(D+X)/m;if(!(G<0||G>=f.outHeight||Math.floor(G)!==G))for(let te=0;te<w;te+=b){const ge=(z+te)/g;if(ge<0||ge>=f.outWidth||Math.floor(ge)!==ge)continue;const ae=x*w-1-p.get(E,G,ge,N),Ne=X*w+te,ke=ae===Ne?1:0;if(ke===0)continue;const De=M.get(E,G,ge,N);B+=De*ke}}k.set(B,E,O,R,N)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const uTe={kernelName:v2,backendName:"cpu",kernelFunc:cTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(n,e,t,r,s){const i=Jt(e),o=iB(n,e,t,i,s,"max"),a=hJ(n,e,t,s,!0,r);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fTe={kernelName:x2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;Zt(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=ko(r.shape,s,i,[1,1],o),[h,f]=hTe(c,r.shape,r.dtype,a,u),d=l.write(h,u.outShape,r.dtype),p=l.write(f,u.outShape,r.dtype);return[{dataId:d,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=An(i,s.shape),c=Qs(s.shape,a)[1],u=Te(c),h=[],f=t.makeTensorInfo([],"float32",new Float32Array([u]));h.push(f);const d=ap({inputs:{x:s},backend:t,attrs:{dtype:"float32"}});h.push(d);const p=oB({inputs:{a:d,b:f},backend:t});h.push(p);const m=hC({inputs:{x:p},backend:t,attrs:{axis:i,keepDims:o}});return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const pTe={kernelName:rw,backendName:"cpu",kernelFunc:dTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Zt(s,"min");const a=An(i,s.shape);let l=a;const c=Lr(l,s.shape.length);let u=s;c!=null&&(u=_a({inputs:{x:s},backend:t,attrs:{perm:c}}),l=ns(l.length,s.shape.length)),fi("min",l,u.shape.length);const[h,f]=Qs(u.shape,l),d=Te(f),p=ji(Te(h),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*d;let x=m[b];for(let w=0;w<d;++w){const S=m[b+w];(Number.isNaN(S)||S<x)&&(x=S)}p[y]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(h,u.dtype,p);if(o){const y=Ls(h,a),b=es({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}const gTe={kernelName:sw,backendName:"cpu",kernelFunc:mTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,mode:o}=r;Zt(s,"mirrorPad");const a=i.map((x,w)=>x[0]+s.shape[w]+x[1]),l=i.map(x=>x[0]),c=i.map((x,w)=>x[0]+s.shape[w]),u=o==="reflect"?0:1,h=t.data.get(s.dataId).values,f=s.shape.length,d=Jt(s.shape),p=Te(a),m=a.length,g=Jt(a),y=ci(s.dtype,p);for(let x=0;x<p;x++){let w=Dg(x,m,g);for(let C=0;C<m;C++)w[C]<l[C]?w[C]=l[C]*2-w[C]-u:w[C]>=c[C]&&(w[C]=(c[C]-1)*2-w[C]+u);w=w.map((C,k)=>C-l[k]);const S=mu(w,f,d);y[x]=h[S]}return{dataId:t.write(y,a,s.dtype),shape:a,dtype:s.dtype}}const bTe={kernelName:iw,backendName:"cpu",kernelFunc:yTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vTe=ei((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),wTe=Pi(uy,vTe),xTe={kernelName:uy,backendName:"cpu",kernelFunc:wTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yJ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=s.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=An([a],s.shape),c=gJ({inputs:{x:s},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=Ls(c.shape,l),h=es({inputs:{x:c},backend:t,attrs:{shape:u}}),f=sB({inputs:{a:s,b:h},backend:t}),d=wZ({inputs:{x:f},backend:t}),p=hC({inputs:{x:d},backend:t,attrs:{axis:l,keepDims:!1}}),m=es({inputs:{x:p},backend:t,attrs:{shape:u}}),g=oB({inputs:{a:d,b:m},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const _Te={kernelName:Sw,backendName:"cpu",kernelFunc:yJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function STe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r;Zt(s,"multinomial");const l=a?s:yJ({inputs:{logits:s},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,f=[c,i],d=ji(Te(f),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=h[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+h[m+x];const y=Aw.alea(o.toString()),b=p*i;for(let x=0;x<i;++x){const w=y();d[b+x]=g.length;for(let S=0;S<g.length;S++)if(w<g[S]){d[b+x]=S;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(f,"int32",d)}const CTe={kernelName:_2,backendName:"cpu",kernelFunc:STe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kTe=rC;function TTe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Zt(s,"NonMaxSuppression");const c=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,{selectedIndices:h}=kTe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const ETe={kernelName:S2,backendName:"cpu",kernelFunc:TTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ITe=sN;function ATe(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Zt(s,"NonMaxSuppressionPadded");const u=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:f,validOutputs:d}=ITe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const MTe={kernelName:_M,backendName:"cpu",kernelFunc:ATe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NTe=sC;function $Te(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Zt(s,"NonMaxSuppressionWithScore");const u=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=NTe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const RTe={kernelName:C2,backendName:"cpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PTe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r;Zt(s,"oneHot");const c=Te(s.shape),u=new Float32Array(c*o);u.fill(l);const h=t.data.get(s.dataId).values;for(let f=0;f<c;++f)h[f]>=0&&h[f]<o&&(u[f*o+h[f]]=a);return t.makeTensorInfo([...s.shape,o],i,u)}const DTe={kernelName:cw,backendName:"cpu",kernelFunc:PTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=cg({inputs:{input:r},backend:t}),i=PI({inputs:{x:s},backend:t}),o=Jb({inputs:{input:r},backend:t}),a=PI({inputs:{x:o},backend:t}),l=Ua({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return aB({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const OTe={kernelName:Tw,backendName:"cpu",kernelFunc:PI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=cg({inputs:{input:r},backend:t}),i=bJ({inputs:{x:s},backend:t}),o=Jb({inputs:{input:r},backend:t}),a=PI({inputs:{x:o},backend:t}),l=Ua({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return aB({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const FTe={kernelName:lw,backendName:"cpu",kernelFunc:bJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return RI({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{qi(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=RI({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=Qb({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const LTe={kernelName:uw,backendName:"cpu",kernelFunc:vJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;Zt(s,"pad");const a=i.map((b,x)=>b[0]+s.shape[x]+b[1]),l=i.map(b=>b[0]),c=t.data.get(s.dataId).values,u=Te(s.shape),h=s.shape.length,f=Jt(s.shape),d=Te(a),p=a.length,m=Jt(a),g=ci(s.dtype,d);o!==0&&g.fill(o);for(let b=0;b<u;b++){const w=Dg(b,h,f).map((C,k)=>C+l[k]),S=mu(w,p,m);g[S]=c[b]}return{dataId:t.write(g,a,s.dtype),shape:a,dtype:s.dtype}}const wJ={kernelName:hw,backendName:"cpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BTe=ei((n,e)=>Math.pow(n,e)),VTe=Pi(fy,BTe),UTe={kernelName:fy,backendName:"cpu",kernelFunc:VTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,a=s.map(g=>t.data.get(g.dataId).values),l=s.map(g=>g.shape),c=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values,[h,f,d]=LZ(a,l,c,i.shape,i.dtype,u,o.shape),p=h.map(g=>t.makeTensorInfo([g.length],"int32",g)),m=t.makeTensorInfo(d,i.dtype,f);return p.concat([m])}const GTe={kernelName:SM,backendName:"cpu",kernelFunc:WTe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HTe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=zZ(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const jTe={kernelName:CM,backendName:"cpu",kernelFunc:HTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qTe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,f=a.map(g=>t.data.get(g.dataId).values),d=a.map(g=>g.shape),[p,m]=BZ(c,s.shape,u,i.shape,i.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,i.dtype,m)}const XTe={kernelName:kM,backendName:"cpu",kernelFunc:qTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KTe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,dtype:i,step:o}=t,a=VZ(r,s,o,i);return e.makeTensorInfo([a.length],i,a)}const YTe={kernelName:k2,backendName:"cpu",kernelFunc:KTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZTe=$r(dy,n=>1/n),JTe={kernelName:dy,backendName:"cpu",kernelFunc:ZTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QTe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Zt(s,"resizeBilinear");const l=Jt(s.shape),[c,u]=a,[h,f,d,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(Te([h,c,u,p])),y=[i&&c>1?f-1:f,i&&u>1?d-1:d],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let x=0;const w=y[0]/b[0],S=y[1]/b[1];for(let C=0;C<h;C++)for(let k=0;k<c;k++){let A;o?A=w*(k+.5)-.5:A=w*k;const M=Math.max(0,Math.floor(A)),E=A-M,N=Math.min(f-1,Math.ceil(A)),O=C*l[0]+M*l[1],R=C*l[0]+N*l[1];for(let D=0;D<u;D++){let z;o?z=S*(D+.5)-.5:z=S*D;const B=Math.max(0,Math.floor(z)),X=z-B,G=Math.min(d-1,Math.ceil(z)),te=O+B*l[2],ge=R+B*l[2],ae=O+G*l[2],Ne=R+G*l[2];for(let ke=0;ke<p;ke++){const De=m[te+ke],be=m[ge+ke],Xe=m[ae+ke],Oe=m[Ne+ke],it=De+(Xe-De)*X,We=be+(Oe-be)*X,dt=it+(We-it)*E;g[x++]=dt}}}return t.makeTensorInfo([h,c,u,p],"float32",g)}const eEe={kernelName:gw,backendName:"cpu",kernelFunc:QTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Zt([i,s],"resizeBilinearGrad");const a=Jt(s.shape),[l,c,u,h]=s.shape,[,f,d]=i.shape,p=new Float32Array(l*c*u*h),m=[o&&f>1?c-1:c,o&&d>1?u-1:u],g=[o&&f>1?f-1:f,o&&d>1?d-1:d],y=m[0]/g[0],b=m[1]/g[1],x=t.data.get(i.dataId).values;let w=0;for(let S=0;S<l;S++){const C=S*a[0];for(let k=0;k<f;k++){const A=k*y,M=Math.floor(A),E=Math.min(Math.ceil(A),c-1),N=C+M*a[1],O=C+E*a[1],R=A-M,D=1-R;for(let z=0;z<d;z++){const B=z*b,X=Math.floor(B),G=Math.min(Math.ceil(B),u-1),te=B-X,ge=1-te,ae=N+X*a[2],Ne=N+G*a[2],ke=O+X*a[2],De=O+G*a[2],be=D*ge,Xe=D*te,Oe=R*ge,it=R*te;for(let We=0;We<h;We++){const dt=x[w++];p[ae+We]+=dt*be,p[Ne+We]+=dt*Xe,p[ke+We]+=dt*Oe,p[De+We]+=dt*it}}}}return t.makeTensorInfo([l,u,c,h],"float32",p)}const nEe={kernelName:I2,backendName:"cpu",kernelFunc:tEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Zt(s,"resizeNearestNeighbor");const l=Jt(s.shape),[c,u]=a,[h,f,d,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(h*c*u*p),y=[i&&c>1?f-1:f,i&&u>1?d-1:d],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],x=y[0]/b[0],w=y[1]/b[1];let S=0;for(let C=0;C<h;C++){const k=C*l[0];for(let A=0;A<c;A++){const M=o?x*(A+.5):x*A;let E=Math.min(f-1,i?Math.round(M):Math.floor(M));o&&(E=Math.max(0,E));const N=k+E*l[1];for(let O=0;O<u;O++){const R=o?w*(O+.5):w*O;let D=Math.min(d-1,i?Math.round(R):Math.floor(R));o&&(D=Math.max(0,D));const z=N+D*l[2];for(let B=0;B<p;B++){const X=m[z+B];g[S++]=X}}}}return t.makeTensorInfo([h,c,u,p],s.dtype,g)}const sEe={kernelName:mw,backendName:"cpu",kernelFunc:rEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Zt([i,s],"resizeNearestNeighborGrad");const a=Jt(s.shape),l=Jt(i.shape),[c,u,h,f]=s.shape,[,d,p]=i.shape,m=new Float32Array(c*u*h*f),g=t.data.get(i.dataId).values,y=[o&&d>1?u-1:u,o&&p>1?h-1:h],b=[o&&d>1?d-1:d,o&&p>1?p-1:p],x=y[0]/b[0],w=y[1]/b[1],S=1/x,C=1/w,k=Math.ceil(S)*2+2,A=Math.ceil(C)*2+2;for(let M=0;M<c;M++){const E=M*a[0];for(let N=0;N<u;N++){const O=E+N*a[1],R=Math.floor(N*S),D=Math.floor(R-k/2);for(let z=0;z<h;z++){const B=O+z*a[2],X=Math.floor(z*C),G=Math.floor(X-A/2);for(let te=0;te<f;te++){let ge=0;for(let ae=0;ae<k;ae++){const Ne=ae+D;if(Ne<0||Ne>=d)continue;const ke=E+Ne*l[1],De=Ne*x,be=Math.min(u-1,o?Math.round(De):Math.floor(De));if(N===be)for(let Xe=0;Xe<A;Xe++){const Oe=Xe+G;if(Oe<0||Oe>=p)continue;const it=ke+Oe*l[2],We=Oe*w,dt=Math.min(h-1,o?Math.round(We):Math.floor(We));z===dt&&(ge+=g[it+te])}}m[B+te]=ge}}}}return t.makeTensorInfo(s.shape,s.dtype,m)}const oEe={kernelName:E2,backendName:"cpu",kernelFunc:iEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r;Zt(s,"reverse");const o=s.shape.length,a=An(i,s.shape);if(o===0)return xh({inputs:{x:s},backend:t});const l=new li(s.shape,s.dtype),c=t.bufferSync(s);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),f=h.slice();a.forEach(d=>f[d]=s.shape[d]-1-f[d]),l.set(c.get(...f),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const lEe={kernelName:yw,backendName:"cpu",kernelFunc:aEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cEe={kernelName:V2,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=ci(r.dtype,Te(r.shape)),[c,u,h,f]=r.shape,[d,p]=fN(o,u,h),m=255,g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let w=0;w<c;w++){const S=w*h*u*f;for(let C=0;C<u;C++){const k=C*(h*f);for(let A=0;A<h;A++){const M=A*f;for(let E=0;E<f;E++){const N=[c,C,A,E],O=N[2],R=N[1];let D=(O-d)*y-(R-p)*g,z=(O-d)*g+(R-p)*y;D=Math.round(D+d),z=Math.round(z+p);let B=i;if(typeof i!="number"&&(E===3?B=m:B=i[E]),D>=0&&D<h&&z>=0&&z<u){const G=z*(h*f),te=D*f,ge=S+G+te+E;B=b[ge]}const X=S+k+M+E;l[X]=B}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uEe=$r(gy,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),hEe={kernelName:gy,backendName:"cpu",kernelFunc:uEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fEe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(i,s,o),f=!0,d=t.bufferSync(s),p=t.bufferSync(i),m=zm(d,p,o,h,c,l,a,u,0,f);return t.makeTensorInfo(o,m.dtype,m.values)}const dEe={kernelName:A2,backendName:"cpu",kernelFunc:fEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pEe(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<e?t=s+1:r=s;return r}function mEe(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<=e?t=s+1:r=s;return r}function gEe(n,e,t,r,s,i){const o=Ss("int32",t*s);for(let a=0;a<t;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)o[c+u]=i==="left"?pEe(l,e[u+c]):mEe(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yEe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=gEe(a,l,s.shape[0],s.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",c)}const bEe={kernelName:N2,backendName:"cpu",kernelFunc:yEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vEe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e;Zt([r,s,i],"select");const o=r.shape.length,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=Mi(s.dtype,i.dtype),h=ji(Te(s.shape),u);let f=0;const d=o===0||o>1||s.shape.length===1?1:Te(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<d;m++)a[p]===1?h[f++]=l[p]:h[f++]=c[p];return t.makeTensorInfo(s.shape,u,h)}const wEe={kernelName:bw,backendName:"cpu",kernelFunc:vEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xEe=cC,_Ee=uC,SEe=$r(by,n=>n>=0?_Ee*n:xEe*(Math.exp(n)-1)),CEe={kernelName:by,backendName:"cpu",kernelFunc:SEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kEe=$r(xy,n=>n<0?-1:n>0?1:0),TEe={kernelName:xy,backendName:"cpu",kernelFunc:kEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EEe=$r(vy,n=>Math.sin(n)),IEe={kernelName:vy,backendName:"cpu",kernelFunc:EEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AEe=$r(wy,n=>Math.sinh(n)),MEe={kernelName:wy,backendName:"cpu",kernelFunc:AEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NEe=11920928955078125e-23,wG=Math.log(NEe)+2,$Ee=$r(Sy,n=>{const e=n>-wG,t=n<wG,r=Math.exp(n);let s;return t?s=r:e?s=n:s=Math.log(1+r),s}),REe={kernelName:Sy,backendName:"cpu",kernelFunc:$Ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;Zt([s],"spaceToBatchND");const a=Te(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=wJ.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),u=Oy(c.shape,i,a,!1),h=Fy(u.length,i.length,!1),f=Ly(c.shape,i,a,!1),m=es({inputs:{x:c},backend:t,attrs:{shape:u}}),b=_a({inputs:{x:m},backend:t,attrs:{perm:h}}),S=es({inputs:{x:b},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),S}const DEe={kernelName:xw,backendName:"cpu",kernelFunc:PEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OEe(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,u=t.data.get(o.dataId).values[0],[h,f,d,p,m]=HZ(a,r.shape,r.dtype,l,s.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],s.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const FEe={kernelName:TM,backendName:"cpu",kernelFunc:OEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LEe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(s.dataId).values),a=t.data.get(r.dataId).values,l=Array.from(t.data.get(i.dataId).values),[c,u,h]=jZ(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const zEe={kernelName:EM,backendName:"cpu",kernelFunc:LEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BEe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=rB(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const VEe={kernelName:$2,backendName:"cpu",kernelFunc:BEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UEe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[c,u]=rB(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const WEe={kernelName:R2,backendName:"cpu",kernelFunc:UEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GEe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Fu(i,s,a),d=!1,p=t.bufferSync(s);let m;switch(i.dtype){case"bool":{const g=t.bufferSync(i),y=!!t.data.get(o.dataId).values[0];m=zm(p,g,a,f,u,c,l,h,y,d);break}case"float32":{const g=t.bufferSync(i),y=t.data.get(o.dataId).values[0];m=zm(p,g,a,f,u,c,l,h,y,d);break}case"int32":{const g=t.bufferSync(i),y=t.data.get(o.dataId).values[0];m=zm(p,g,a,f,u,c,l,h,y,d);break}case"string":{const g=t.bufferSync(i),y=_c(t.data.get(o.dataId).values[0]);m=zm(p,g,a,f,u,c,l,h,y,d);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,m.dtype,m.values)}const HEe={kernelName:P2,backendName:"cpu",kernelFunc:GEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=An(o,s.shape)[0],l=TN(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(h=>{const f=[...u];f[a]=h;const d=ug({inputs:{x:s},backend:t,attrs:{begin:c,size:f}});return c[a]+=h,d})}const qEe={kernelName:_w,backendName:"cpu",kernelFunc:jEe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XEe={kernelName:D2,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Zt(t,"square");const s=r.data.get(t.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KEe=$r(My,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),YEe={kernelName:My,backendName:"cpu",kernelFunc:KEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r;Zt(s,"stridedSlice");const{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=cN(s.shape,i,o,a,l,c,u,h,f);let S;if(m)S=es({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=lN(b,x,w),k=ug({inputs:{x:s},backend:t,attrs:{begin:b,size:C}});S=es({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(k)}else{const C=t.bufferSync(s),k=KZ(d,C,w,b);S=t.makeTensorInfo(p,k.dtype,k.values)}return S}const JEe={kernelName:F2,backendName:"cpu",kernelFunc:ZEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QEe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.data.get(u.dataId).values,d=t.data.get(h.dataId).values,[p,m]=YZ(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const eIe={kernelName:L2,backendName:"cpu",kernelFunc:QEe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tIe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,h]=ZZ(a,l,s),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const nIe={kernelName:IM,backendName:"cpu",kernelFunc:tIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rIe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=JZ(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const sIe={kernelName:AM,backendName:"cpu",kernelFunc:rIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iIe=$r(Ey,n=>Math.tan(n)),oIe={kernelName:Ey,backendName:"cpu",kernelFunc:iIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aIe=$r(Iy,n=>Math.tanh(n)),lIe={kernelName:Iy,backendName:"cpu",kernelFunc:aIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cIe(n){const{inputs:e,backend:t}=n,{tensor:r,indices:s,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=Fu(i,s,r.shape),h=!1,f=t.bufferSync(s),d=t.bufferSync(i),p=t.bufferSync(r),m=zm(f,d,r.shape,u,l,a,o,c,p,h);return t.makeTensorInfo(r.shape,m.dtype,m.values)}const uIe={kernelName:M2,backendName:"cpu",kernelFunc:cIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;Zt(s,"tile");const o=eJ(t.bufferSync(s),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const fIe={kernelName:Ay,backendName:"cpu",kernelFunc:hIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r;Zt(s,"topk");const a=t.data.get(s.dataId).values,[l,c]=nJ(a,s.shape,s.dtype,i,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const pIe={kernelName:z2,backendName:"cpu",kernelFunc:dIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mIe(n){const{inputs:e,attrs:t,backend:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=Jt(s.shape),b=y[0],x=y[1],w=y[2],S=Jt(g),C=S[0],k=S[1],A=S[2],M=ci(s.dtype,Te(g));M.fill(l);const E=r.data.get(s.dataId).values,N=r.data.get(i.dataId).values;for(let R=0;R<u;++R){const D=i.shape[0]===1?N:N.subarray(R*8,R*8+8);for(let z=0;z<p;++z)for(let B=0;B<m;++B)for(let X=0;X<d;++X){let G;const te=D[6]*B+D[7]*z+1;if(te===0)continue;const ge=(D[0]*B+D[1]*z+D[2])/te,ae=(D[3]*B+D[4]*z+D[5])/te,Ne=xG(ge,f,a),ke=xG(ae,h,a);switch(o){case"nearest":G=xIe(E,h,f,b,x,w,R,ke,Ne,X,l);break;case"bilinear":G=_Ie(E,h,f,b,x,w,R,ke,Ne,X,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const De=R*C+z*k+B*A+X;M[De]=G}return r.makeTensorInfo(g,s.dtype,M)}return{dataId:r.write(M,g,s.dtype),shape:s.shape,dtype:s.dtype}}const gIe={kernelName:B2,backendName:"cpu",kernelFunc:mIe};function xG(n,e,t){switch(t){case"reflect":return yIe(n,e);case"wrap":return bIe(n,e);case"nearest":return wIe(n,e);case"constant":default:return vIe(n)}}function yIe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{const r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return ep(0,t,e-1)}function bIe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{const r=e-1;t-=e*Math.trunc(t/r)}return ep(0,t,e-1)}function vIe(n,e){return n}function wIe(n,e){return ep(0,n,e-1)}function C1(n,e,t,r,s,i,o,a,l,c,u){const h=o*r+a*s+l*i+c;return 0<=a&&a<e&&0<=l&&l<t?n[h]:u}function xIe(n,e,t,r,s,i,o,a,l,c,u){const h=Math.round(a),f=Math.round(l);return C1(n,e,t,r,s,i,o,h,f,c,u)}function _Ie(n,e,t,r,s,i,o,a,l,c,u){const h=Math.floor(a),f=Math.floor(l),d=h+1,p=f+1,m=(p-l)*C1(n,e,t,r,s,i,o,h,f,c,u)+(l-f)*C1(n,e,t,r,s,i,o,h,p,c,u),g=(p-l)*C1(n,e,t,r,s,i,o,d,f,c,u)+(l-f)*C1(n,e,t,r,s,i,o,d,p,c,u);return(d-a)*m+(a-h)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SIe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;Zt(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=rJ(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const CIe={kernelName:MM,backendName:"cpu",kernelFunc:SIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kIe(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let d=0;d<o;d++)d!==i&&(l[c++]=s.shape[d]);const u=new Array(o).fill(0),h=s.shape.slice();h[i]=1;const f=new Array(a);for(let d=0;d<f.length;d++){u[i]=d;const p=ug({inputs:{x:s},backend:t,attrs:{begin:u,size:h}});f[d]=es({inputs:{x:p},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(p)}return f}const TIe={kernelName:Cw,backendName:"cpu",kernelFunc:kIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EIe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r;Zt(s,"unsortedSegmentSum");const a=s.shape.length,l=i.shape.length,c=[],u=[],h=a-l;let f=i;for(let p=0;p<h;++p){const m=RI({inputs:{input:f},backend:t,attrs:{dim:p+1}});f=m,u.push(m)}for(let p=0;p<o;++p){const m=Bf(p,"int32"),g=t.makeTensorInfo([],"int32",m),y=bZ({inputs:{a:g,b:f},backend:t}),b=ap({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),x=AN({inputs:{a:b,b:s},backend:t}),w=hC({inputs:{x},backend:t,attrs:{axis:0,keepDims:!1}});c.push(w),u.push(g),u.push(y),u.push(b),u.push(x),u.push(w)}const d=vJ({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const IIe={kernelName:kw,backendName:"cpu",kernelFunc:EIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AIe=[S2e,sSe,k2e,E2e,uSe,A2e,N2e,R2e,D2e,F2e,z2e,V2e,W2e,j2e,X2e,Z2e,Q2e,tCe,rCe,x2e,iCe,aCe,cCe,fSe,hCe,lSe,pSe,dCe,iSe,mCe,yCe,bCe,wCe,_Ce,CCe,TCe,ICe,MCe,$Ce,PCe,OCe,LCe,BCe,UCe,WCe,HCe,qCe,KCe,YCe,ZCe,JCe,eke,rke,p2e,ike,mSe,dke,gSe,pke,bSe,wke,xke,Ske,wSe,_Se,kke,Eke,Ake,Nke,CSe,TSe,oSe,Rke,gCe,Dke,Fke,zke,m2e,ISe,MSe,Vke,$Se,Wke,jke,Xke,Zke,Qke,tTe,nTe,PSe,sTe,oTe,lTe,uTe,fTe,pTe,gTe,OSe,bTe,xTe,CTe,LSe,BSe,ETe,MTe,RTe,USe,DTe,FTe,LTe,wJ,UTe,y2e,HSe,GTe,jTe,XTe,YTe,aSe,ID,JTe,b2e,v2e,w2e,eEe,nEe,sEe,oEe,lEe,cEe,hEe,QSe,dEe,bEe,wEe,CEe,t2e,TEe,IEe,MEe,n2e,_Te,REe,DEe,FEe,zEe,VEe,WEe,HEe,qEe,i2e,XEe,a2e,c2e,YEe,JEe,eIe,nIe,sIe,d2e,tke,oIe,lIe,uIe,fIe,pIe,gIe,WSe,CIe,TIe,IIe,OTe];for(const n of AIe)U2(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $m={},Hk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function MIe(n,e){$m[n]=e}function _u(n,e){if(!(n in $m)||e!=null){const r=$Ie(n,e);if(r!==null)$m[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=$m[n];return t==null||t.isContextLost()?(delete $m[n],_u(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),$m[n])}function NIe(n){if(!Ee().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function $Ie(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??NIe(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete $m[n]},!1),Ee().getBool("SOFTWARE_WEBGL_ENABLED")&&(Hk.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",Hk)||t.getContext("experimental-webgl",Hk):t.getContext("webgl2",Hk)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var E_;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(E_||(E_={}));var xl;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(xl||(xl={}));var oo;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(oo||(oo={}));function fC(n,e){return[e,n]}function RIe(n,e){return n*e}function jk(n){const e=Te(n),t=Math.ceil(e/4);return vI(t)}function $w(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function PIe(n,e){const[t,r]=$w(n,e);return t*r*4}function lB(n,e){const t=n;let r,s,i,o,a,l,c,u,h,f;return Ee().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,f=t.FLOAT,l=t.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,f=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(n,e){const t=e();return Ee().getBool("DEBUG")&&DIe(n),t}function DIe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+zIe(n,e))}const OIe=596e-10,FIe=65504;function LIe(n){return!!(Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||OIe<Math.abs(n)&&Math.abs(n)<FIe)}function zIe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function qk(n,e){return Gf(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function BIe(n,e){const t=Gf(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function VIe(n,e){const t=Gf(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Bt(n,()=>n.shaderSource(t,e)),Bt(n,()=>n.compileShader(t)),Ee().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw xJ(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const UIe=/ERROR: [0-9]+:([0-9]+):/g;function xJ(n,e){const t=UIe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),i=s.length.toString().length+2,o=s.map((h,f)=>Hm((f+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Hm(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function WIe(n){return Gf(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function GIe(n,e){if(Bt(n,()=>n.linkProgram(e)),!Ee().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function l3(n,e){if(Bt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function HIe(n,e){const t=Gf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function jIe(n,e){const t=Gf(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Bt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Bt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function qIe(n){return Gf(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function XIe(n,e){const t=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function KIe(n){return Gf(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function _G(n,e,t,r,s,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Bt(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),Bt(n,()=>n.enableVertexAttribArray(a)),!0)}function YIe(n,e,t){tAe(n,t),Bt(n,()=>n.activeTexture(n.TEXTURE0+t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function ZIe(n,e,t){return Gf(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function JIe(n,e,t){return n.getUniformLocation(e,t)}function QIe(n,e,t,r){Bt(n,()=>YIe(n,e,r)),Bt(n,()=>n.uniform1i(t,r))}function c3(n,e,t){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function SG(n,e){Bt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Bt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Xk(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+eAe(n,e))}function eAe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Gf(n,e,t){const r=Bt(n,()=>e());if(r==null)throw new Error(t);return r}function tAe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function ev(n,e=2){return Te(n.slice(0,n.length-e))}function tv(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Kk(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ev(n),...tv(n)]),e}function nAe(n,e=!1){let t=Ee().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Ee().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Ee().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,l)=>l>=n.length-2?bM(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Lf(n).newShape);let s=Te(n),i=null;n.length<=1&&s<=t?i=[1,s]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=ev(n);let l=2,c=2;n.length&&([l,c]=tv(n)),s=a*(l/2)*(c/2),i=vI(s).map(u=>u*2)}else i=vI(s);return i}function Yk(n){return n%2===0}function DI(n,e){if(n=n.slice(-2),e=e.slice(-2),Rn(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r||Yk(t)&&Yk(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Yk(n[0])&&Yk(e[0])}let u3,h3;function rAe(n){if(u3==null){const e=_u(n);u3=e.getParameter(e.MAX_TEXTURE_SIZE)}return u3}function sAe(n){if(h3==null){const e=_u(n);h3=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,h3)}function iAe(n){if(n===0)return 0;let e;const t=_u(n);return dc(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:dc(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function dc(n,e){return n.getExtension(e)!=null}function CG(n){try{if(_u(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function oAe(n){if(n===0)return!1;const e=_u(n);if(n===1){if(!dc(e,"OES_texture_float"))return!1}else if(!dc(e,"EXT_color_buffer_float"))return!1;return MD(e)}function aAe(n){if(n===0)return!1;const e=_u(n);if(n===1){if(!dc(e,"OES_texture_float")||!dc(e,"WEBGL_color_buffer_float"))return!1}else{if(dc(e,"EXT_color_buffer_float"))return MD(e);const r="EXT_color_buffer_half_float";if(dc(e,r)){const s=e.getExtension(r);return lAe(e,s)}return!1}return MD(e)}function MD(n){const e=lB(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function lAe(n,e){const t=lB(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,i=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,i,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}function cAe(n){return n!==2?!1:_u(n).fenceSync!=null}function dC(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qt=Ee();Qt.registerFlag("HAS_WEBGL",()=>Qt.getNumber("WEBGL_VERSION")>0);Qt.registerFlag("WEBGL_VERSION",()=>CG(2)?2:CG(1)?1:0);Qt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Qt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Qt.get("WEBGL_VERSION")===2);Qt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Qt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Qt.registerFlag("WEBGL_PACK",()=>Qt.getBool("HAS_WEBGL"));Qt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CLIP",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_REDUCE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_CONV_IM2COL",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Qt.getBool("WEBGL_PACK"));Qt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>rAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>sAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Qt.getNumber("WEBGL_VERSION");return n===0?0:iAe(n)});Qt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Qt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ML());Qt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>oAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Qt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Qt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Qt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>aAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>cAe(Qt.getNumber("WEBGL_VERSION")));Qt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Qt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Qt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Qt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ML()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Qt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Qt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Qt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Qt.registerFlag("WEBGL_EXP_CONV",()=>!1);Qt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Qt.getBool("IS_TEST"));Qt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Qt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Qt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Qt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function na(){let n,e,t,r,s,i,o,a,l,c;return Ee().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=Ee().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zy(n,e,t="index"){const r=Jt(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / ${s}`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`;return`${o}; ${a};`}).join("")}function MN(n,e,t="index"){const r=Jt(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function uAe(n,e){const t=n.length,r=n.map(i=>`${e}[${i}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let i=t-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}function hAe(n,e,t="index"){const r=n.map((i,o)=>o),s=uAe(r,e);return s.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${s[o]}`,l=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`;return`${a}; ${l};`}).join("")}function cB(n){const e=Jt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function uB(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const _J=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:SJ}=lZ;function fAe(n,e,t){const r=[];if(n.forEach(d=>{const p=Te(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:m}=hB(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),i=n.map(d=>dAe(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=na(),l=gAe(a);let c,u,h=vAe(a);return e.isPacked?(c=pAe(e.logicalShape,o,t.enableShapeUniforms),u=bAe(a)):(c=mAe(e.logicalShape,o,t.enableShapeUniforms),u=yAe(a)),t.packedInputs&&(h+=SAe),[h,l,u,s,c,i,t.userCode].join(`
`)}function Rw(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return DAe(n,e);case 1:return FAe(n,e);case 2:return zAe(n,e);case 3:return VAe(n,e);case 4:return WAe(n,e);case 5:return GAe(n);case 6:return HAe(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function CJ(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return PAe(n);case 1:return OAe(n,e);case 2:return LAe(n,e);case 3:return BAe(n,e);default:return UAe(n,e)}}function dAe(n,e,t=!1,r){let s="";t?s+=CJ(n,r):s+=Rw(n,r);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?s+=jAe(n,e):s+=qAe(n,e)),s}function pAe(n,e,t){switch(n.length){case 0:return kJ();case 1:return CAe(n,e,t);case 2:return $Ae(n,e,t);case 3:return TAe(n,e,t);default:return IAe(n,e,t)}}function mAe(n,e,t){switch(n.length){case 0:return kJ();case 1:return kAe(n,e,t);case 2:return RAe(n,e,t);case 3:return EAe(n,e,t);case 4:return AAe(n,e,t);case 5:return MAe(n,e);case 6:return NAe(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function gAe(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function yAe(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function bAe(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function vAe(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${wAe}
    ${xAe}
    ${_Ae}
  `}const wAe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,xAe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,_Ae=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SAe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function kJ(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function CAe(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function kAe(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function TAe(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function EAe(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${MN(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=zy(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function IAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${l});
    }
  `}function AAe(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${MN(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=zy(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function MAe(n,e){const t=zy(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function NAe(n,e){const t=zy(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function $Ae(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Rn(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function RAe(n,e,t){return Rn(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function By(n){return`offset${n}`}function PAe(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=na();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function DAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,i]=n.shapeInfo.texShape;if(s===1&&i===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=By(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function OAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,i=na();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function FAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Pw(n)}
      }
    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(o===1&&i===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=By(t);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function LAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=na();if(i!=null&&Rn(t,i))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function zAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Rn(t,i)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=i[0],d=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=Lf(t),l=o;if(l.length<t.length){const f=Dw(n,l),d=["row","col"];return`
      ${Rw(f,e)}
      float ${s}(int row, int col) {
        return ${s}(${Ow(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Pw(n)}
      }
    `;const c=i[0],u=i[1],h=By(r);return u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function BAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const f=t.slice(1),d=[1,2],p=Dw(n,f),m=["b","row","col"];return`
        ${CJ(p,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Ow(m,d)});
        }
      `}const a=na();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function VAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Lf(t),c=a;if(c.length<t.length){const m=Dw(n,c),g=["row","col","depth"];return`
        ${Rw(m,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Ow(g,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Pw(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],f=u[1],d=n.shapeInfo.flatOffset;if(f===i&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const p=By(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${h}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function UAe(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=na();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(i[o-1]/2);let f=h*Math.ceil(i[o-2]/2),d="int b, int row, int col",p=`b * ${f} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)d=`int b${m}, `+d,f*=i[o-m-1],p=`b${m} * ${f} + `+p;return`
    vec4 ${r}(${d}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${s.texture2D}(${t}, uv);
    }
  `}function WAe(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Lf(t);if(l.length<t.length){const b=Dw(n,l),x=["row","col","depth","depth2"];return`
      ${Rw(b,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Ow(x,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Pw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${p}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===i&&u==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=By(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function GAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],i=e[3]*s,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Lf(e);if(l.length<e.length){const m=Dw(n,l),g=["row","col","depth","depth2","depth3"];return`
      ${Rw(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Ow(g,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${s})) +
          depth3;
        ${Pw(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],d=h[1];if(d===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===s&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;const p=By(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function HAe(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:i}=Lf(e);if(s.length<e.length){const g=Dw(n,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Rw(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Ow(y,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Pw(n)}
      }
    `;const h=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],p=f[1];if(p===u&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===o&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=By(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Pw(n){const e=n.name,t=Te(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function jAe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=SJ(n.shapeInfo.logicalShape,e.logicalShape),l=Fr(o),c=o-i;let u;const h=["x","y","z","w","u","v"];i===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${h[b+c]} = 0;`).join(`
`);let f="";o<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((b,x)=>`coords.${h[x+c]}`).join(", ");let d="return outputValue;";const m=Te(n.shapeInfo.logicalShape)===1,y=Te(e.logicalShape)===1;if(i===1&&!m&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=i-2,x=i-1;a.indexOf(b)>-1&&a.indexOf(x)>-1?d="return vec4(outputValue.x);":a.indexOf(b)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(x)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function qAe(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Rn(o,i))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Fr(l),u=SJ(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let f;const d=["x","y","z","w","u","v"];a===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(m=>`coords.${d[m+h]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((m,g)=>`coords.${d[g+h]}`).join(", "),`
    float ${s}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${p});
    }
  `}function Fr(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function hB(n,e,t){const{newShape:r,keptDims:s}=Lf(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):r,l=!n&&i>1&&!Rn(e,t)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function Dw(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Ow(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XAe(n,e,t,r){const s=t.map((u,h)=>{const f={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(f.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:f}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=fAe(s,o,e),l=VIe(n.gl,a),c=n.createProgram(l);return Ee().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},TJ(n,e,c)))}function TJ(n,e,t){const r=[],s=[];let i,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),Ee().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const h of e.variableNames){const f={name:h,uniform:n.getUniformLocation(t,h,u),offset:n.getUniformLocation(t,`offset${h}`,u)};e.enableShapeUniforms&&(f.shape=n.getUniformLocation(t,`${h}Shape`,u),f.texShape=n.getUniformLocation(t,`${h}TexShape`,u)),r.push(f)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),o=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const h of e.customUniforms)s.push(n.getUniformLocation(t,h.name,u));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:c,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function kG(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,i=e[r],o=i.shape;if(!Rn(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!Rn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function KAe(n,e,t,r,s){e.program.enableShapeUniforms||(kG(e.inShapeInfos,t),kG([e.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),Ee().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:u,offset:h,shape:f,texShape:d}=e.variablesLocations[l];if(f){const{uniformShape:p}=hB(e.program.packedInputs,c.shape,c.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(f,new Int32Array(p));break;case 2:n.gl.uniform2iv(f,new Int32Array(p));break;case 3:n.gl.uniform3iv(f,new Int32Array(p));break;case 4:n.gl.uniform4iv(f,new Int32Array(p));break}}if(d&&n.gl.uniform2i(d,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(Te(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let p=c.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(u,p)}continue}c.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Jt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],u=e.customUniformLocations[l],h=s[l];if(c.type==="float")n.gl.uniform1fv(u,h);else if(c.type==="vec2")n.gl.uniform2fv(u,h);else if(c.type==="vec3")n.gl.uniform3fv(u,h);else if(c.type==="vec4")n.gl.uniform4fv(u,h);else if(c.type==="int")n.gl.uniform1iv(u,h);else if(c.type==="ivec2")n.gl.uniform2iv(u,h);else if(c.type==="ivec3")n.gl.uniform3iv(u,h);else if(c.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function YAe(n,e,t){let r="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=hB(n.packedInputs,o.shape,l);let f="",d="",p="";if(u.length===1&&n.packedInputs){const S=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${S[0]>1}_${S[1]>1}`}else if(u.length===2&&!n.packedInputs)d=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const S=Jt(u);p=`${S[0]===l[1]}_${S[S.length-1]===l[1]}`}const m=o.shape.length,g=u.length===2&&Rn(o.shape,l),y=Te(o.shape)===1,b=$f(o.shape,t.shape),x=!n.packedInputs&&m===t.shape.length&&Rn(l,t.texData.texShape),w=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${c?h:""}_${u.length}_${y}_${b}_${g}_${f}_${d}_${p}_${w}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const s=n.userCode;let i=n.constructor.name;return i+="_"+r+"_"+s+`${Ee().getNumber("WEBGL_VERSION")}`,i}function To(n){return Ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZAe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=E_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=na();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?MN(["r","c","d"],e):zy(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=E_.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=na();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?MN(["r","c","d"],e):zy(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QAe{constructor(e){this.variableNames=["A"],this.outTexUsage=xl.DOWNLOAD;const t=na();this.outputShape=e,this.userCode=`
      ${_J}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eMe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=xl.DOWNLOAD;const t=na();this.outputShape=e,this.userCode=`
      ${_J}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tMe={R:0,G:1,B:2,A:3};class TG{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=na();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++){const l=r[a];o+=`
          if(offset == ${a}) {
            result = values[${tMe[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?uB():cB(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${o}
        }
        ${s.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nMe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=na();this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let s="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?uB():cB(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rMe(n){const e=na(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return BIe(n,t)}function sMe(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return HIe(n,e)}function iMe(n){const e=new Uint16Array([0,1,2,2,1,3]);return jIe(n,e)}function pC(n,e,t,r,s,i){XIe(e,t);const o=qIe(n),a=n.TEXTURE_2D;return Bt(n,()=>n.bindTexture(a,o)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Bt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),Ee().getNumber("WEBGL_VERSION")===1?Bt(n,()=>n.texImage2D(a,0,r,e,t,0,s,i,null)):Bt(n,()=>n.texStorage2D(a,1,r,e,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function EJ(n){return n.internalFormatFloat}function oMe(n,e,t,r){const[s,i]=fC(e,t);return pC(n,s,i,EJ(r),r.textureFormatFloat,n.FLOAT)}function IJ(n){return n.internalFormatHalfFloat}function aMe(n,e,t,r){const[s,i]=fC(e,t);return pC(n,s,i,IJ(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function AJ(n){return n.downloadTextureFormat}function lMe(n,e,t,r){const[s,i]=fC(e,t);return pC(n,s,i,AJ(r),n.RGBA,n.UNSIGNED_BYTE)}function MJ(n){return n.internalFormatPackedFloat}function cMe(n,e,t,r){const[s,i]=$w(e,t);return pC(n,s,i,MJ(r),n.RGBA,n.FLOAT)}function NJ(n){return n.internalFormatPackedHalfFloat}function uMe(n,e,t,r){const[s,i]=$w(e,t);return pC(n,s,i,NJ(r),n.RGBA,r.textureTypeHalfFloat)}function hMe(n,e,t){return Bt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),_G(n,e,"clipSpacePos",t,3,20,0)&&_G(n,e,"uv",t,2,20,12)}function fMe(n,e,t,r,s,i){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;s instanceof Uint8Array?(o=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,o)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,r,0,n.RGBA,a,o)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function dMe(n,e,t){Bt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ee().getNumber("WEBGL_VERSION")===2?Bt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Bt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Bt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function pMe(n,e,t,r){const s=n.createBuffer();Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=4*4*e*t;return Bt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Bt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function mMe(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function gMe(n,e,t,r){const[s,i]=fC(e,t),o=4,a=new Uint8Array(RIe(e*t,o));return Bt(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function yMe(n,e,t,r,s,i,o,a){const l=n,c=new Float32Array(PIe(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function bMe(n,e,t){const r=new Float32Array(e*t*4);return Bt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f3{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Ee().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,MIe(t,e)):this.gl=_u(t),e=this.gl,Ee().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Bt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>Bt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>Bt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>Bt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Bt(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>Bt(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Bt(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>Bt(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Ee().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=qk(this.gl,i),dc(this.gl,o))this.textureHalfFloatExtension=qk(this.gl,o);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),dc(this.gl,s))this.colorBufferHalfFloatExtension=qk(this.gl,s);else if(Ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",dc(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(dc(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=sMe(this.gl),this.indexBuffer=iMe(this.gl),this.framebuffer=KIe(this.gl),this.textureConfig=lB(this.gl,this.textureHalfFloatExtension)}get debug(){return Ee().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Bt(e,()=>e.finish()),Bt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Bt(e,()=>e.deleteFramebuffer(this.framebuffer)),Bt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Bt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Bt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),oMe(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),aMe(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),lMe(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),dMe(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),fMe(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),uMe(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),cMe(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(SG(this.gl,this.framebuffer),this.outputTexture=null),Bt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>gMe(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,i,o){return yMe(this.gl,e,t,r,s,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return mMe(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=pMe(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(Ee().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},t=i}else Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>bMe(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=rMe(t));const r=WIe(t);Bt(t,()=>t.attachShader(r,this.vertexShader)),Bt(t,()=>t.attachShader(r,e)),GIe(t,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&l3(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Bt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),hMe(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Bt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&l3(this.gl,this.program),Bt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?ZIe(this.gl,e,t):JIe(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Bt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),QIe(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,i]=$w(t,r);this.setOutputMatrixTextureDriver(e,s,i)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&l3(this.gl,this.program),Xk(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Bt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=qk(this.gl,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await iD(()=>this.disposed||this.isQueryAvailable(e,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=vMe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Ee().platform&&(r=Ee().platform.setTimeoutCustom.bind(Ee().platform)),iD(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),c3(this.gl,e,this.framebuffer),this.debug&&Xk(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(c3(this.gl,this.outputTexture,this.framebuffer),this.debug&&Xk(this.gl)):SG(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;c3(s,e,this.framebuffer),this.debug&&Xk(s),this.outputTexture=e,Bt(s,()=>s.viewport(0,0,t,r)),Bt(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Bt(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function vMe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:wMe,bincountImpl:$J,bincountReduceImpl:xMe,bitwiseAndImpl:_Me,castImpl:SMe,ceilImpl:CMe,concatImpl:kMe,equalImpl:TMe,expImpl:EMe,expm1Impl:IMe,floorImpl:AMe,gatherNdImpl:MMe,gatherV2Impl:NMe,greaterImpl:$Me,greaterEqualImpl:RMe,lessImpl:PMe,lessEqualImpl:DMe,linSpaceImpl:OMe,logImpl:FMe,maxImpl:LMe,maximumImpl:zMe,minimumImpl:BMe,multiplyImpl:VMe,negImpl:UMe,notEqualImpl:WMe,prodImpl:GMe,raggedGatherImpl:HMe,raggedRangeImpl:jMe,raggedTensorToTensorImpl:qMe,rangeImpl:XMe,rsqrtImpl:KMe,scatterImpl:YMe,sigmoidImpl:ZMe,simpleAbsImpl:RJ,sliceImpl:JMe,sparseFillEmptyRowsImpl:QMe,sparseReshapeImpl:eNe,sparseSegmentReductionImpl:PJ,sqrtImpl:tNe,staticRegexReplaceImpl:nNe,stridedSliceImpl:rNe,stringNGramsImpl:sNe,stringSplitImpl:iNe,stringToHashBucketFastImpl:oNe,subImpl:aNe,tileImpl:lNe,topKImpl:cNe,transposeImpl:fB,uniqueImpl:uNe}=sJ;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DJ(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Wo(n,e){return e===1?[n]:DJ(n,e)}function hNe(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fNe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=To(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Wo("rc",this.rank),r=Fr(this.rank),s=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2===1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`
        ${i}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${dNe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?uB():cB(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function dNe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?hAe(["r","c","d"],"inputShape"):zy(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pNe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){const s=IG(t,r),i=AG(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=EG(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return s===oo.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===oo.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===oo.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===oo.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===oo.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const i=IG(r,s),o=AG(t,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=EG(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=Ee().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function mNe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function EG(n,e,t,r,s){const i=gNe(e,r);let o;if(s){const[l,c]=$w(n[0],n[1]);o=l*c}else{const[l,c]=fC(n[0],n[1]);o=l*c}const a=mNe(t,i);return o*a}function gNe(n,e){switch(n){case oo.PACKED_2X2_FLOAT32:return MJ(e);case oo.PACKED_2X2_FLOAT16:return NJ(e);case oo.UNPACKED_FLOAT32:return EJ(e);case oo.UNPACKED_FLOAT16:return IJ(e);case oo.PACKED_4X1_UNSIGNED_BYTE:return AJ(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function yNe(n){return Ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?oo.PACKED_2X2_FLOAT32:oo.UNPACKED_FLOAT32:n?oo.PACKED_2X2_FLOAT16:oo.UNPACKED_FLOAT16}function IG(n,e){if(n===xl.UPLOAD)return oo.PACKED_2X2_FLOAT32;if(n===xl.RENDER||n==null)return yNe(e);if(n===xl.DOWNLOAD||n===xl.PIXELS)return oo.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function AG(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uh=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const $c="if (isnan(x)) return x;",bNe="return x;",MG="return abs(x);",vNe="return (x >= 0.0) ? x : (exp(x) - 1.0);",wNe=$c+`
  return (x < 0.0) ? 0.0 : x;
`,xNe=$c+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Cd="return x;",_Ne="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SNe="return x;",CNe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,kNe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,TNe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ENe="return 1.0 / (1.0 + exp(-1.0 * x));";class Md{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class INe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);const t=e.length,r=Wo("rc",t),s=Fr(t),i=hNe(t,r),o=r.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ANe=JM,MNe=1e-7,NNe=1e-4,Zk={};function $Ne(n){return n in Zk||(Zk[n]={}),Zk[n]}const RNe=Ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),PNe=600;function DNe(){return Ee().global.screen==null?1024:Ee().global.screen.height*Ee().global.screen.width*window.devicePixelRatio*PNe/1024/1024}class NN extends WS{nextDataId(){return NN.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof f3)t=e;else{const r=_u(Ee().getNumber("WEBGL_VERSION"),e);t=new f3(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=_u(Ee().getNumber("WEBGL_VERSION"));t=new f3(r),this.binaryCache=$Ne(Ee().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new pNe(this.gpgpu),this.numMBBeforeWarning=DNe(),this.texData=new yM(this,xo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,s,i,o){const a=this.makeTensorInfo(t,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,i]},l.texShape=[s,i];const c=Kk(t),u=new TG(c,!1,o),h=this.runWebGLProgram(u,[a],r,[[s,i]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,r){if((Ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Ee().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:xl.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,i){if(Ee().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:xl.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let f;l?f=new Md(a,Cd):f=new uh(a,Cd);const d=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:s}],s),p=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),p}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const c=this.activeTimers!=null;let u;c&&(u=so());let h;if(s==="complex64"){const f=this.readSync(i.real.dataId),d=this.readSync(i.imag.dataId);h=wu(f,d)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=so()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(m=>p.push(m))}const t=this.texData.get(e),{values:r,shape:s,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let p;l?p=new Md(s,Cd):p=new uh(s,Cd);const m=this.runWebGLProgram(p,[{dataId:e,shape:s,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(Ee().getBool("DEBUG")&&!Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Ee().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&Ee().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(p.texture.texture,...jk(s))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=p[0],g=p[1];h=wu(m,g)}else if(c==null)h=this.getValuesFromTexture(e);else{const p=Te(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const p=this.gpgpu.gl;Bt(p,()=>p.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(p=>p(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&xo().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:i,slice:o,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let d;l?d=new Md(i,Cd):d=new uh(i,Cd);const p=this.runWebGLProgram(d,[{dataId:e,shape:i,dtype:a}],a),m=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),m}if(c==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=xo().makeTensorFromTensorInfo(u),f=this.texData.get(u.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>_c(s));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!LIe(r))throw Ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),i=Te(t);if(Ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),d=this.texData.get(f.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...jk(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),p}const o=Ee().getBool("WEBGL_PACK")&&s===!0,a=o?Kk(t):t,l=o?new eMe(a):new QAe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Sc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Sc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=SL(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:so(),endMs:null}}endTimer(e){return Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=so(),e)}async getQueryTime(e){if(Ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,i,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=RNe){return Ee().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Te(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){bl("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return ANe(e.shape,t)}packedUnaryOp(e,t,r){const s=new Md(e.shape,t),i=this.compileAndRun(s,[e],r);return xo().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=RJ(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,MG,e.dtype);const t=new uh(e.shape,MG),r=this.compileAndRun(t,[e]);return xo().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&cu(r[0])){const i=r.map(o=>gu(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return xo().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new INe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new fNe(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[ev(e.shape),...tv(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},i=[ev(t),...tv(t)],o=new OJ(i,r),a=!0,l=[r],c=this.runWebGLProgram(o,[s],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:i,dtype:o}=r;if(t!=null){const f=Te(i),d=t[0]*t[1]*4;U(f<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=Kk(i);let l;s?l=new JAe(a):l=new ZAe(a);const c=!0,u=[t??jk(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(e,t,r,s,i=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===E_.DENSE){const y=o??jk(e.outputShape);l.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Te(a.shape)===0)return l.values=ci(a.dtype,0),a;const c=[],u=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&Te(y.shape)<=Ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!DI(b.shape,y.shape)){const x=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),c.push(y),b=this.texData.get(y.dataId),x.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},f=YAe(e,u,h),d=this.getAndSaveBinary(f,()=>XAe(this.gpgpu,e,u,h)),p=this.activeTimers!=null;let m;p&&(m=this.startTimer()),Ee().get("ENGINE_COMPILE_ONLY")||KAe(this.gpgpu,d,u,h,s),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const g=Ee().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=so();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!Ee().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,t,r,s,i=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Se(()=>{if(!Ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Ee().getBool("DEBUG");Ee().set("DEBUG",!1);const t=this.abs(en(1e-8)).dataSync()[0];if(Ee().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?MNe:NNe}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=so());let h=t.texShape;if(h==null&&(h=nAe(r,l),t.texShape=h),i!=null){const f=Kk(r);let d,p=h[1],m=h[0];const g=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!g)&&([p,m]=$w(h[0],h[1])),l?d=new nMe(f,g):d=new TG(f,g);const y=g?[m,p]:h,b=this.makeTensorInfo(y,s),x=this.texData.get(b.dataId);g?x.usage=xl.PIXELS:x.usage=xl.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),p,m,i);const w=[[m,p]],S=!0,C=this.runWebGLProgram(d,[b],s,w,S),k=this.texData.get(C.dataId);t.texShape=k.texShape,t.isPacked=k.isPacked,t.usage=k.usage,Ee().get("ENGINE_COMPILE_ONLY")?this.disposeData(C.dataId):(t.texture=k.texture,t.values=null,this.texData.delete(C.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=so()-u)}else{const f=this.acquireTexture(h,a,s,l);t.texture=f}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return t!=null&&(r.values=ONe(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*d_(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(i){throw i}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Kz(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(xJ(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:r,infLoc:s,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=TJ(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";const{texture:s,height:i,width:o,channels:a}=e,l=xo().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(s,t,r,i,o,a);return xo().makeTensorFromDataId(c,t,r,l)}}NN.nextDataId=0;function ONe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */NL()&&$M("webgl",()=>new NN,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dB=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let hg=class{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=ln(t,r),this.enableShapeUniforms=To(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vy=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Fw{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ln(t,r);const i=this.outputShape.length;this.enableShapeUniforms=To(i);let o="";if(s)if(i===0||Te(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Fr(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Wo("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xa(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const FNe={kernelName:ny,backendName:"webgl",kernelFunc:Xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rp(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.texData.get(i.dataId),a=Xa({inputs:{x:r},backend:t}),l=Xa({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const LNe={kernelName:ZS,backendName:"webgl",kernelFunc:Rp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FJ="return (a < 0.) ? b * a : a;",LJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function zNe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=t.makeTensorInfo([],"float32",Bf(i,"float32")),a=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fw(LJ,s.shape,o.shape):new hg(FJ,s.shape,o.shape),l=t.runWebGLProgram(a,[s,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const BNe={kernelName:qv,backendName:"webgl",kernelFunc:zNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zJ="return (a < 0.) ? b * a : a;",BJ=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function VNe(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fw(BJ,r.shape,s.shape):new hg(zJ,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],"float32")}const UNe={kernelName:fw,backendName:"webgl",kernelFunc:VNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lw="if (isnan(x)) return x;";function gr({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),f=t(h.values,l);return a.makeTensorInfo(o.shape,l,f)}const c=Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Md(o.shape,e):u=new uh(o.shape,n),a.runWebGLProgram(u,[o],l)}}function uo({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&l.dtype==="complex64"){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{const[w,S]=x,C={dataId:w.dataId,dtype:w.dtype,shape:l.shape},k={dataId:S.dataId,dtype:S.dtype,shape:c.shape},A=new hg(n,l.shape,c.shape);return u.runWebGLProgram(A,[C,k],Mi(w.dtype,S.dtype))}),b=Rp({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const h=i||Mi(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&s!=null){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g=l.dtype==="string"?xu(p):p,y=l.dtype==="string"?xu(m):m,[b,x]=s(l.shape,c.shape,g,y,h),w=u.makeTensorInfo(x,h),S=u.texData.get(w.dataId);return S.values=b,w}const f=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return f?d=new Fw(e,l.shape,c.shape,t):d=new hg(n,l.shape,c.shape),u.runWebGLProgram(d,[l,c],h)}}function I_(n,e=!1){if(n==="linear")return e?SNe:bNe;if(n==="relu")return e?kNe:wNe;if(n==="elu")return e?CNe:vNe;if(n==="relu6")return e?TNe:xNe;if(n==="prelu")return e?BJ:zJ;if(n==="leakyrelu")return e?LJ:FJ;if(n==="sigmoid")return e?ENe:_Ne;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VJ=class{constructor(e,t,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=To(this.outputShape.length);const u=s?e[1]:e[2],h=Math.ceil(u/2),f=s?"i * 2, rc.y":"rc.y, i * 2",d=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let x="rc.x",w="rc.x";e[0]<t[0]?x=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${w};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${m[0]});
          result += (${p[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let $G=class{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ln(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG="return a * b;";function pB(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=Mi(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),c=new $G(NG.REAL,r.shape,s.shape),u=new $G(NG.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Rp({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),[c,u]=VMe(r.shape,s.shape,a.values,l.values,i),h=t.makeTensorInfo(u,i),f=t.texData.get(h.dataId);return f.values=c,h}let o;return Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new Fw(RG,r.shape,s.shape):o=new hg(RG,r.shape,s.shape),t.runWebGLProgram(o,[r,s],i)}const WNe={kernelName:hy,backendName:"webgl",kernelFunc:pB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GNe(n,e,t){const r=[ev(n.shape),...tv(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[ev(e),...tv(e)],o=new OJ(i,r),a=!0,l=[r],c=t.runWebGLProgram(o,[s],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=t,a=Te(s.shape),l=vM(i,a),c=Te(l);U(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return u.isPacked&&!DI(s.shape,l)&&!(u.texture!==null&&DI(u.shape,l))?GNe(s,l,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const HNe={kernelName:pw,backendName:"webgl",kernelFunc:At};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PG{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${tg(h)?h.toPrecision(2):h}, ones);`}let u="";i%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jNe=class{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(r/4)*4,h=r%4;let f=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qNe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=hN(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Uy(n,e,t,r){const s=qNe(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,h;t==="mean"?u=o===0?new PG({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new PG({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new jNe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=i,i=r.runWebGLProgram(u,[i],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XNe=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[t[o]];this.outputShape=r,this.rank=r.length;const s=Fr(this.rank),i=KNe(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}};function KNe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YNe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Fr(this.rank),i=DJ("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n,e,t){const r=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new YNe(n.shape,e):new XNe(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZNe(n,e,t,r){const s=e,i=n.shape.length,o=An(s,n.shape);let a=o;const l=Lr(a,i),c=l!=null;let u=n;c&&(u=$N(n,l,r),a=ns(a.length,i)),fi("sum",a,i);const[h,f]=Qs(u.shape,a);let d=h;t&&(d=Ls(h,o));const p=Te(f),g=Te(n.shape)/p,y=At({inputs:{x:u},attrs:{shape:[g,p]},backend:r}),b=G2(n.dtype),x=Uy(y,b,"sum",r),w=At({inputs:{x},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),c&&r.disposeIntermediateTensorInfo(u),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return ZNe(s,i,o,t)}const JNe={kernelName:ww,backendName:"webgl",kernelFunc:RN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zo(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const h=o.texData.get(s.dataId).values,f=fB(h,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype);const d=o.texData.get(c.dataId);d.values=f}else c=$N(s,i,o);return c}const QNe={kernelName:Vd,backendName:"webgl",kernelFunc:Zo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UJ=1e3;function OI({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Te(m),b=Te(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=At({inputs:{x:n},backend:s,attrs:{shape:S}}),A=At({inputs:{x:e},backend:s,attrs:{shape:C}}),M=[k,A],E=Math.max(y,b),N=t?k.shape[1]:k.shape[2],O=i!=null,R=o!=null,D=l==="leakyrelu",z=l!=null?I_(l,!0):null,B=O||R||D||z!=null;let X;if((d===1||p===1)&&N>UJ&&B===!1){let te=k,ge=A;t&&(te=Zo({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),M.push(te)),r&&(ge=Zo({inputs:{x:A},backend:s,attrs:{perm:[0,2,1]}}),M.push(ge));const ae=p!==1,Ne=p===1;let ke=te;ae&&(ke=At({inputs:{x:te},backend:s,attrs:{shape:[E,N,1]}}),M.push(ke));const De=p===1?2:1;let be=ge;Ne&&(be=At({inputs:{x:ge},backend:s,attrs:{shape:[E,1,N]}}),M.push(be));const Xe=pB({inputs:{a:ke,b:be},backend:s});X=RN({inputs:{x:Xe},backend:s,attrs:{axis:De,keepDims:!0}}),M.push(Xe)}else{const te=Mi(n.dtype,e.dtype),ge=new VJ(S,C,[E,d,p],t,r,O,z,R,D),ae=[k,A];if(i!=null&&ae.push(i),R&&ae.push(o),D){const Ne=s.makeTensorInfo([],"float32",Bf(a,"float32"));ae.push(Ne),M.push(Ne)}X=s.runWebGLProgram(ge,ae,te)}const G=At({inputs:{x:X},backend:s,attrs:{shape:w}});M.push(X);for(const te of M)s.disposeIntermediateTensorInfo(te);return G}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return OI({a:s,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const t$e={kernelName:Vb,backendName:"webgl",kernelFunc:e$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG="return abs(x);";function n$e(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=t.texData.get(r.dataId),o=RJ(i.values);return t.makeTensorInfo(r.shape,r.dtype,o)}let s;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Md(r.shape,DG):s=new uh(r.shape,DG),t.runWebGLProgram(s,[r],r.dtype)}const r$e={kernelName:Tv,backendName:"webgl",kernelFunc:n$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$e=$c+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,i$e=gr({opSnippet:s$e}),o$e={kernelName:Og,backendName:"webgl",kernelFunc:i$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$e=$c+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,l$e=gr({opSnippet:a$e}),c$e={kernelName:Fg,backendName:"webgl",kernelFunc:l$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG="return a + b;",u$e=uo({opSnippet:OG,packedOpSnippet:OG,supportsComplex:!0,cpuKernelImpl:wMe}),h$e={kernelName:kp,backendName:"webgl",kernelFunc:u$e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f$e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let d$e=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Xa({inputs:{x:r[0]},backend:t});if(r.length>Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=RE({inputs:r.slice(0,l),backend:t}),u=RE({inputs:r.slice(l),backend:t});return RE({inputs:[c,u],backend:t})}const s=r.map(l=>l.dtype).reduce((l,c)=>Mi(l,c)),i=r.map(l=>l.shape),a=Ee().getBool("WEBGL_PACK")?new d$e(r[0].shape,i):new f$e(r[0].shape,i);return t.runWebGLProgram(a,r,s)}const p$e={kernelName:Ev,backendName:"webgl",kernelFunc:RE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),c=ns(c.length,a)),fi("all",c,a);const[f,d]=Qs(h.shape,c),p=Te(d),m=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Uy(m,m.dtype,"all",t);let y;if(o){const b=Ls(f,l);y=At({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=At({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const g$e={kernelName:GS,backendName:"webgl",kernelFunc:m$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),c=ns(c.length,a)),fi("any",c,a);const[f,d]=Qs(h.shape,c),p=Te(d),m=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Uy(m,m.dtype,"any",t);let y;if(o){const b=Ls(f,l);y=At({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=At({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const b$e={kernelName:HS,backendName:"webgl",kernelFunc:y$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v$e=class{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w$e{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,U(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Fr(l),u=Wo("coords",l);let h,f;if(o===1){f=l+1;const A=Fr(f);h=`
        ${A} sourceLocR = ${A}(${u.join()}, 0);
        ++${u[l-1]};
        ${A} sourceLocG = ${A}(${u.join()}, 0);
        ++${u[l-2]};
        ${A} sourceLocA = ${A}(${u.join()}, 0);
        --${u[l-1]};
        ${A} sourceLocB = ${A}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const d=["x","y","z","w","u","v"].slice(0,f),p="."+d[f-1],m=d.map(A=>"int "+A),g=Wo("sourceLocR",f-1).concat("inIdx.r"),y=Wo("sourceLocG",f-1).concat("inIdx.g"),b=Wo("sourceLocB",f-1).concat("inIdx.b"),x=Wo("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",S=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,C=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,k=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${C};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${C};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n,e,t,r=null){let s=e.shape[0],i=e.shape[1];r!=null&&(s=r.shape[0],i=r.shape[1]);const o=hN(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new v$e(a,t,r==null),c=[e];r!=null&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=WJ(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function GJ(n,e,t,r=null){const s=r!=null?r.shape:e.shape,i=s[s.length-1],o=hN(i),a=new w$e(s,o,t,r==null),l=r==null?[e]:[e,r],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=GJ(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function HJ(n,e,t,r){const s=[t];if(fi("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!Ee().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[c,u]=Qs(l.shape,s),h=Te(u),f=At({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});i.push(f);const d=WJ(n,f,r);i.push(d);const p=At({inputs:{x:d},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return GJ(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Zo({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMax",[o[0]],l.shape.length);const u=HJ(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const _$e={kernelName:Iv,backendName:"webgl",kernelFunc:x$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=Zo({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMin",[o[0]],l.shape.length);const u=HJ(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const C$e={kernelName:Av,backendName:"webgl",kernelFunc:S$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k$e=$c+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,T$e=gr({opSnippet:k$e}),E$e={kernelName:Lg,backendName:"webgl",kernelFunc:T$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I$e=$c+"return log(x + sqrt(x * x + 1.0));",A$e=gr({opSnippet:I$e}),M$e={kernelName:zg,backendName:"webgl",kernelFunc:A$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$e=$c+`
  return atan(x);
`,$$e=gr({opSnippet:N$e}),R$e={kernelName:Bg,backendName:"webgl",kernelFunc:$$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P$e=dB+`
  return atan(a, b);
`,D$e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vy+`
  return result;
`,O$e=uo({opSnippet:P$e,packedOpSnippet:D$e}),F$e={kernelName:Ug,backendName:"webgl",kernelFunc:O$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L$e=$c+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,z$e=gr({opSnippet:L$e}),B$e={kernelName:Vg,backendName:"webgl",kernelFunc:z$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let A_=class{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),r){const A=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${A} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?i?g:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");const S=Math.floor(o/4)*4,C=o%4,k=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${S};
          if (${C===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${C===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${w});
      }
    `}},mB=class{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg";let w="0.0";if(x||(w="-1.0 / 1e-20"),r){const E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const k=Math.floor(o/4)*4,A=o%4,M=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${k};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${M}
            }
          }
        }
        setOutput(${C});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;dC(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))return Xa({inputs:{x:s},backend:t});const h=new A_(u,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}const U$e={kernelName:Mv,backendName:"webgl",kernelFunc:V$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],h=Ol(s.shape,i,o,u,a,l,c),f=new mB(h,"avg",!1);return t.runWebGLProgram(f,[s],"float32")}const G$e={kernelName:Nv,backendName:"webgl",kernelFunc:W$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,f=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},j$e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=h-1-e.padInfo.front,m=f-1-e.padInfo.top,g=d-1-e.padInfo.left,y=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ol(o.shape,a,l,h,c,u),d=new j$e(f);return t.runWebGLProgram(d,[s],o.dtype)}const X$e={kernelName:qS,backendName:"webgl",kernelFunc:q$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;dC([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=new H$e(u);return t.runWebGLProgram(h,[s],o.dtype)}const Y$e={kernelName:jS,backendName:"webgl",kernelFunc:K$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return OI({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const J$e={kernelName:$v,backendName:"webgl",kernelFunc:Z$e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Q$e=class{constructor(e,t,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="0.0";s!=null&&(ln(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(ln(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eRe{constructor(e,t,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r);let a="vec4(0.0)";s!=null&&(ln(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(ln(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tRe=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;U(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[r,s,i];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const f=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new eRe(r.shape,s.shape,i.shape,u,h,l):new Q$e(r.shape,s.shape,i.shape,u,h,l);return e.runWebGLProgram(f,c,c[0].dtype)},nRe={kernelName:Gv,backendName:"webgl",kernelFunc:tRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rRe=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Fr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=sRe(this.rank);let s;const i=e.map((o,a)=>`sourceLoc.${ND[a]} = start[${a}] + coords.${ND[a]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}};const ND=["x","y","z","w","u","v"];function sRe(n){if(n===1)return"sourceLoc";if(n<=6)return ND.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iRe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Fr(this.rank),r=Wo("coords",this.rank),s=Wo("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${o};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oRe(n,e,t,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(t,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Xz(e,Jt(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}function zw(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=lC(s,i,o);if(aN(s,a,l),Te(l)===0)return t.makeTensorInfo(l,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.texData.get(s.dataId),f=JMe(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,f)}const{isPacked:c}=t.texData.get(s.dataId),u=qz(s.shape,a,l);if(c||!u){const h=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iRe(l):new rRe(l),f=[a];return t.runWebGLProgram(h,[s],s.dtype,f)}return t.uploadToGPU(s.dataId),oRe(s,a,l,t)}const aRe={kernelName:vw,backendName:"webgl",kernelFunc:zw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lRe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=Oy(s.shape,i,a),c=Fy(l.length,i.length),u=Ly(s.shape,i,a),h=dN(o,i.length),f=pN(u,o,i.length),d=[],p=At({inputs:{x:s},backend:t,attrs:{shape:l}}),m=Zo({inputs:{x:p},backend:t,attrs:{perm:c}}),g=At({inputs:{x:m},backend:t,attrs:{shape:u}}),y=zw({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},cRe={kernelName:Rv,backendName:"webgl",kernelFunc:lRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.readSync(s.dataId),l=t.readSync(i.dataId),c=$J(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const hRe={kernelName:XS,backendName:"webgl",kernelFunc:uRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fRe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,dRe=`
  return float(int(a.r) & int(b.r));
`;function pRe(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=Ee().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,s])||o===1){const l=t.texData.get(r.dataId).values,c=t.texData.get(s.dataId).values,[u,h]=_Me(r.shape,s.shape,l,c,r.dtype),f=t.makeTensorInfo(h,r.dtype),d=t.texData.get(f.dataId);return d.values=u,f}let a;return i?a=new Fw(fRe,r.shape,s.shape,!1):a=new hg(dRe,r.shape,s.shape),t.runWebGLProgram(a,[r,s],r.dtype)}const mRe={kernelName:KS,backendName:"webgl",kernelFunc:pRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gRe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.readSync(r.dataId),o=t.readSync(s.dataId),a=ln(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const yRe={kernelName:YS,backendName:"webgl",kernelFunc:gRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bRe="return float(a != b);",jJ=uo({opSnippet:bRe,cpuKernelImpl:WMe,dtype:"bool"}),vRe={kernelName:aw,backendName:"webgl",kernelFunc:jJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Xa({inputs:{x:s.complexTensorInfos.real},backend:t})}const wRe={kernelName:T2,backendName:"webgl",kernelFunc:mC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xRe="return float(int(x));";function _Re(n,e){const t=new uh(n.shape,xRe),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $D(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Xa({inputs:{x:s},backend:t});const o=ms(s.shape),a=$D({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=Rp({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const o=mC({inputs:{input:s},backend:t}),a=$D({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!wM(s.dtype,i)){const o=Xa({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId).values,[a,l,c]=SMe(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return _Re(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",ci("bool",1)),l=jJ({inputs:{a:s,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const SRe={kernelName:Wg,backendName:"webgl",kernelFunc:$D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG="return ceil(x);",CRe=gr({opSnippet:FG,packedOpSnippet:FG,cpuKernelImpl:CMe}),kRe={kernelName:Gg,backendName:"webgl",kernelFunc:CRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TRe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ERe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;Ee().getBool("WEBGL_PACK_CLIP")?a=new ERe(s.shape):a=new TRe(s.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[s],s.dtype,l)}const ARe={kernelName:Hg,backendName:"webgl",kernelFunc:IRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MRe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LG(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function NRe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),i=new MRe(r.shape),o=[LG(r,s.complexTensorInfos.real),LG(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const $Re={kernelName:Pv,backendName:"webgl",kernelFunc:NRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RRe=class{constructor(e){this.outputShape=[],this.outputShape=ya(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];r.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const s=t.length,i=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PRe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ya(e,t);const r=this.outputShape,s=r.length,i=Fr(s),o=Wo("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((m,g)=>`T${g}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const c=a[t],u=a.slice(-2),h=a.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];f+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Jk(a,c,g)}),
            vec2(${Jk(u,c,g)}));
        }`}const d=l.length,p=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${Jk(a,c,p)}),
          vec2(${Jk(u,c,p)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${f}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[s-1]} = ${o[s-1]} + 1;
        if (${o[s-1]} < ${r[s-1]}) {
          result.g = getValue(${o});
        }

        ${o[s-2]} = ${o[s-2]} + 1;
        if (${o[s-2]} < ${r[s-2]}) {
          result.a = getValue(${o});
        }

        ${o[s-1]} = ${o[s-1]} - 1;
        if (${o[s-2]} < ${r[s-2]} &&
            ${o[s-1]} < ${r[s-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Jk(n,e,t){const r=n.indexOf(e);return n.map((i,o)=>o===r?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PN(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Xa({inputs:{x:s.complexTensorInfos.imag},backend:t})}const DRe={kernelName:g2,backendName:"webgl",kernelFunc:PN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const d=n.map(b=>mC({inputs:{input:b},backend:t})),p=n.map(b=>PN({inputs:{input:b},backend:t})),m=k1(d,e,t),g=k1(p,e,t),y=Rp({inputs:{real:m,imag:g},backend:t});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const d=n.map(w=>{const C=[-1,Te(w.shape.slice(e))];return At({inputs:{x:w},backend:t,attrs:{shape:C}})}),p=d.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),m=ya(d.map(w=>w.shape),1),g=d[0].shape[0]===1,y=kMe(p,m,r,g),b=ya(n.map(w=>w.shape),e),x=t.makeTensorInfo(b,r,y);return d.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const i=n.filter(d=>Te(d.shape)>0),o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const d=o?new uh(n[0].shape,Cd):new Md(n[0].shape,Cd);return t.runWebGLProgram(d,n,r)}const a=Ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const d=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);d.push(k1(g,e,t))}const p=k1(d,e,t);for(const m of d)t.disposeIntermediateTensorInfo(m);return p}if(o){const d=new PRe(i.map(p=>p.shape),e);return t.runWebGLProgram(d,i,r)}const{tensors2D:l,outShape:c}=ORe(i,e,t),u=new RRe(l.map(d=>d.shape)),h=t.runWebGLProgram(u,l,r);l.forEach(d=>t.disposeIntermediateTensorInfo(d));const f=At({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),f}function ORe(n,e,t){const r=ya(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>At({inputs:{x:i},attrs:{shape:[-1,Te(i.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=An(s,e[0].shape)[0],o=e.map(c=>c.shape);uN(o,i);const a=ya(e.map(c=>c.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Te(c.shape)>0);return l.length===1?Xa({inputs:{x:l[0]},backend:t}):k1(l,i,t)}const FRe={kernelName:Dv,backendName:"webgl",kernelFunc:qJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XJ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,x=g?3:1;let w="",S="";r&&(s?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,S="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${C}
        ${S}
        setOutput(result);
      }
    `}}class LRe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,f=e.filterHeight,d=e.filterWidth,p=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KJ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<u;g++)f+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<u;g++)f+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(h+1)/2;g++){const y=g*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){const b=o%2===0?bM(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",p="";r&&(s?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:i?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,p="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zRe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=To(this.outputShape.length);const{dataFormat:r}=t,s=na(),i=r==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function YJ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],f=t.outChannels,d=t.dataFormat==="channelsLast",p=!1,m=!1;let g;const y=[];if(i!=null){const w=FI(i.shape,d);w!=null&&(i=At({inputs:{x:i},backend:r,attrs:{shape:w}}),y.push(i))}if(s!=null){const w=FI(s.shape,d);w!=null&&(s=At({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(!((h===1||f===1)&&u>UJ)&&c.isPacked&&d&&c.texture!=null&&l[2]%2!==0&&Rn(c.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),S={dataId:n.dataId,shape:[1,w,t.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,U(DI(c.shape,S.shape),()=>`packed reshape ${c.shape} to ${S.shape} isn't free`);const k=At({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(k);const A=OI({a:S,b:k,backend:r,transposeA:p,transposeB:m,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),M=r.texData.get(A.dataId);U(M.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,M.shape=t.outShape,g=Xa({inputs:{x:A},backend:r}),g.shape=t.outShape,y.push(A)}else{const w=t.outHeight*t.outWidth,S=At({inputs:{x:n},backend:r,attrs:{shape:d?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),C=At({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),k=OI({a:d?S:C,b:d?C:S,transposeA:!d,transposeB:m,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=At({inputs:{x:k},backend:r,attrs:{shape:t.outShape}}),y.push(S),y.push(C),y.push(k)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function ZJ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:f,dataFormat:d}=t,p=d==="channelsLast",m=l*c*u,g=f*h,y=[t.batchSize,m,g],b=!0,x=!1,w=[];if(i!=null){const G=FI(i.shape,p);G!=null&&(i=At({inputs:{x:i},backend:r,attrs:{shape:G}}),w.push(i))}if(s!=null){const G=FI(s.shape,p);G!=null&&(s=At({inputs:{x:s},backend:r,attrs:{shape:G}}),w.push(s))}const S=At({inputs:{x:e},backend:r,attrs:{shape:[1,m,Te(e.shape)/m]}});w.push(S);const C=new zRe(y,t),k=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=r.runWebGLProgram(C,[n],"float32",k),M=At({inputs:{x:A},backend:r,attrs:{shape:y}});w.push(A),w.push(M);const E=s!=null,N=i!=null,O=a==="leakyrelu",R=a?I_(a,!0):null,D=new VJ(p?M.shape:S.shape,p?S.shape:M.shape,p?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],b,x,E,R,N,O),z=p?[M,S]:[S,M];if(s&&z.push(s),N&&z.push(i),O){const G=r.makeTensorInfo([],"float32",Bf(o,"float32"));z.push(G),w.push(G)}const B=r.runWebGLProgram(D,z,"float32"),X=At({inputs:{x:B},backend:r,attrs:{shape:t.outShape}});w.push(B);for(const G of w)r.disposeIntermediateTensorInfo(G);return X}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=el(l),f=ts(s.shape,i.shape,o,c,a,u,!1,h);let d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=YJ({x:s,filter:i,convInfo:f,backend:t});else if(f.strideWidth<=2&&h==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const m=new KJ(f),g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=t.runWebGLProgram(m,[s,i],"float32",g)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))d=ZJ({x:s,filter:i,convInfo:f,backend:t});else{const m=new XJ(f);d=t.runWebGLProgram(m,[s,i],"float32")}const p=At({inputs:{x:d},backend:t,attrs:{shape:f.outShape}});return t.disposeIntermediateTensorInfo(d),p}const VRe={kernelName:Ov,backendName:"webgl",kernelFunc:BRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let URe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},WRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=r-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},GRe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},HRe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=r-1-e.padInfo.top,u=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=el(l),f=ts(s.shape,u,o,1,a,c,!1,h),d=new URe(f);return t.runWebGLProgram(d,[s,i],"float32")}const qRe={kernelName:JS,backendName:"webgl",kernelFunc:jRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XRe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=To(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,s=t-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KRe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=el(c),f=ts(o,i.shape,a,1,l,u,!1,h);if(Ee().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const d=[[f.strideHeight,f.strideWidth]],p=new XRe(f);return t.runWebGLProgram(p,[s,i],"float32",d)}else{const d=new WRe(f);return t.runWebGLProgram(d,[s,i],"float32")}}const YRe={kernelName:Fv,backendName:"webgl",kernelFunc:KRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Ou(s.shape,i.shape,o,l,a),u=new LRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const JRe={kernelName:Lv,backendName:"webgl",kernelFunc:ZRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,c=Ou(s.shape,l,o,1,a),u=new GRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const e3e={kernelName:QS,backendName:"webgl",kernelFunc:QRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r,c=Ou(l,i.shape,a,1,o),u=new HRe(c);return t.runWebGLProgram(u,[s,i],"float32")}const n3e={kernelName:e2,backendName:"webgl",kernelFunc:t3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r3e=Lw+`
  return cos(x);
`,s3e=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Vy}
  return result;
`,i3e=gr({opSnippet:r3e,packedOpSnippet:s3e}),o3e={kernelName:jg,backendName:"webgl",kernelFunc:i3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3e=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,l3e=gr({opSnippet:a3e}),c3e={kernelName:qg,backendName:"webgl",kernelFunc:l3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u3e=class{constructor(e,t,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,f]=r;this.outputShape=[u,h,f,c];const d=s==="bilinear"?1:0,[p,m]=[`${a-1}.0`,`${l-1}.0`],[g,y,b]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,w,S]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3e=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new u3e(s.shape,i.shape,a,l,c);return t.runWebGLProgram(u,[s,i,o],"float32")},f3e={kernelName:n2,backendName:"webgl",kernelFunc:h3e};var M_;(function(n){n.Prod="*",n.Sum="+"})(M_||(M_={}));let zG=class{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===M_.Prod?"1.0":"0.0",a=r?o:`getX(${BG(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?`end != ${l-1}`:"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Fr(i)} coords = getOutputCoords();
        int end = ${VG(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${VG(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${BG(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function BG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function VG(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JJ(n,e,t,r,s,i){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=Zo({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=ns(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Xa({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new zG(n,l.shape,!1,i),p=[[f]],m=h;h=t.runWebGLProgram(d,[h],h.dtype,p),t.disposeIntermediateTensorInfo(m)}if(s){const f=new zG(n,l.shape,s,i),d=h;h=t.runWebGLProgram(f,[h],h.dtype),t.disposeIntermediateTensorInfo(d)}if(a!=null){const f=Mh(a),d=Zo({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return JJ(M_.Prod,s,t,i,o,a)}const p3e={kernelName:t2,backendName:"webgl",kernelFunc:d3e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return JJ(M_.Sum,s,t,i,o,a)}const g3e={kernelName:zv,backendName:"webgl",kernelFunc:m3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.readSync(s.dataId),c=t.readSync(i.dataId),u=$J(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(s.shape.length===2){const l=t.bufferSync(s),c=t.bufferSync(i),u=xMe(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const b3e={kernelName:r2,backendName:"webgl",kernelFunc:y3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v3e=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],u=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,f=c*i,d=u/(i*i),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=new v3e(p,i,o);return t.runWebGLProgram(m,[s],s.dtype)}const x3e={kernelName:s2,backendName:"webgl",kernelFunc:w3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QJ=class{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";r&&(s?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eQ{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=To(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,f=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<h;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<h;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const b=y*2;if(d+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?d+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const x=a%2===0?bM(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:d+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?d+=`
                    xC${b+1} = xTexelC${b};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(d+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(d+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(d+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let p="",m="";r&&(s?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:p=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;u==null&&(u=[1,1]),U(Ri(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=ts(s.shape,i.shape,o,u,a,c,!0);let f;Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?f=new eQ(h):f=new QJ(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(f,[s,i],"float32",d)}const S3e={kernelName:Bv,backendName:"webgl",kernelFunc:_3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let C3e=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},k3e=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ts(s.shape,u,o,a,l,c,!0),f=new C3e(h);return t.runWebGLProgram(f,[s,i],"float32")}const E3e={kernelName:i2,backendName:"webgl",kernelFunc:T3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3e(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ts(u,i.shape,o,a,l,c,!0),f=new k3e(h);return t.runWebGLProgram(f,[s,i],"float32")}const A3e={kernelName:o2,backendName:"webgl",kernelFunc:I3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let M3e=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3e(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Te(r.shape),o=At({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new M3e(i),l=t.runWebGLProgram(a,[o],o.dtype),c=At({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const $3e={kernelName:a2,backendName:"webgl",kernelFunc:N3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let R3e=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:f}=s;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P3e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Ap(s.shape,i.shape,o,a,"NHWC",l);let u;const h=new R3e(c);u=t.runWebGLProgram(h,[s,i],"float32");const f=At({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),f}const D3e={kernelName:Vv,backendName:"webgl",kernelFunc:P3e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3e(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=xN(s,i.length);SN(o.length,l,i);const{path:c,steps:u}=CN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=_N(d,l[g]);let x;kN(y)?x=i[g]:(x=Zo({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(x.shape,w)||(x=At({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=pB({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=RN({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeIntermediateTensorInfo(m);return f}const F3e={kernelName:c2,backendName:"webgl",kernelFunc:O3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3e="return (x >= 0.0) ? x : (exp(x) - 1.0);",z3e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,B3e=gr({opSnippet:L3e,packedOpSnippet:z3e}),V3e={kernelName:Kg,backendName:"webgl",kernelFunc:B3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3e="return (b >= 0.0) ? a : a * (b + 1.0);",W3e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,G3e=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=Ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Fw(W3e,r.shape,s.shape):new hg(U3e,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],r.dtype)},H3e={kernelName:u2,backendName:"webgl",kernelFunc:G3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j3e=`
  return vec4(equal(a, b));
`,q3e="return float(a == b);",X3e=uo({opSnippet:q3e,packedOpSnippet:j3e,dtype:"bool",cpuKernelImpl:TMe}),K3e={kernelName:Uv,backendName:"webgl",kernelFunc:X3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y3e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${mN};
  float a1 = ${gN};
  float a2 = ${yN};
  float a3 = ${bN};
  float a4 = ${vN};
  float a5 = ${wN};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Z3e=gr({opSnippet:Y3e}),J3e={kernelName:Yg,backendName:"webgl",kernelFunc:Z3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q3e=Lw+`
  return exp(x);
`,ePe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tQ=gr({opSnippet:Q3e,packedOpSnippet:ePe,cpuKernelImpl:EMe,dtype:"float32"}),tPe={kernelName:Zg,backendName:"webgl",kernelFunc:tQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),At({inputs:{x:i},backend:r,attrs:{shape:a}})}const nPe={kernelName:Wv,backendName:"webgl",kernelFunc:RD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG="return exp(x) - 1.0;",rPe=gr({opSnippet:UG,packedOpSnippet:UG,cpuKernelImpl:IMe}),sPe={kernelName:Jg,backendName:"webgl",kernelFunc:rPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let WG=class{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nQ(n,e,t){const r=t.texData.get(n.dataId),s=Te(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=At({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,c=new WG("real",l,e),u=new WG("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=t.runWebGLProgram(c,h,"float32"),d=t.runWebGLProgram(u,h,"float32"),p=Rp({inputs:{real:f,imag:d},backend:t});t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d);const m=At({inputs:{x:p},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iPe(n){const{inputs:e,backend:t}=n,{input:r}=e;return nQ(r,!1,t)}const oPe={kernelName:h2,backendName:"webgl",kernelFunc:iPe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aPe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gC(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||Cp(s),i==="string"){const o=Ss(i,Te(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new aPe(r,s),a=[[s]];return e.runWebGLProgram(o,[],i,a)}}const lPe={kernelName:f2,backendName:"webgl",kernelFunc:gC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cPe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uPe={kernelName:d2,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new cPe(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GG="return floor(x);",hPe=gr({opSnippet:GG,packedOpSnippet:GG,cpuKernelImpl:AMe}),fPe={kernelName:Qg,backendName:"webgl",kernelFunc:hPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dPe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,pPe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,mPe=uo({opSnippet:dPe,packedOpSnippet:pPe,dtype:"int32"}),gPe={kernelName:ey,backendName:"webgl",kernelFunc:mPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yPe=class{constructor(e){this.variableNames=["A"];const t=na(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bPe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=na(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vPe={kernelName:g_,backendName:"webgl",kernelFunc:wPe};let I0,d3=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function wPe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],h=[c,l,i];if(a||o){const m=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(I0==null||m!==d3)&&(d3=m,I0=document.createElement("canvas").getContext("2d",{willReadFrequently:d3})),I0.canvas.width=l,I0.canvas.height=c,I0.drawImage(s,0,0,l,c),s=I0.canvas}const f=t.makeTensorInfo(u,"int32");t.texData.get(f.dataId).usage=xl.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(f.dataId),s);const d=Ee().getBool("WEBGL_PACK")?new bPe(h):new yPe(h),p=t.runWebGLProgram(d,[f],"int32");return t.disposeData(f.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xPe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=el(u),g=ts(s.shape,i.shape,l,h,c,f,!1,m);let y;const b=[],x=o!=null,w=a!=null,S=d==="leakyrelu",C=()=>{const A=[s,i],M=(E,N)=>{if(N==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){const O=At({inputs:{x:E},backend:t,attrs:{shape:[E.shape[0],1,1]}});return b.push(O),O}return E};if(x&&A.push(M(o,u)),w&&A.push(M(a,u)),S){const E=t.makeTensorInfo([],"float32",Bf(p,"float32"));A.push(E),b.push(E)}return A};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=YJ({x:s,filter:i,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else if(g.strideWidth<=2&&m==="channelsLast"&&Ee().getBool("WEBGL_EXP_CONV")){const A=d?I_(d,!0):null,M=new KJ(g,x,A,w,S),E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=C();y=t.runWebGLProgram(M,N,"float32",E)}else if(Ee().getBool("WEBGL_CONV_IM2COL"))y=ZJ({x:s,filter:i,convInfo:g,backend:t,bias:o,activation:d,preluActivationWeights:a,leakyreluAlpha:p});else{const A=d?I_(d,!1):null,M=new XJ(g,x,A,w,S),E=C();y=t.runWebGLProgram(M,E,"float32")}const k=At({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return b.push(y),b.forEach(A=>t.disposeIntermediateTensorInfo(A)),k}const _Pe={kernelName:Ub,backendName:"webgl",kernelFunc:xPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SPe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r,p=[];let m=u;m==null&&(m=[1,1]),U(Ri(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=ts(s.shape,i.shape,l,m,c,h,!0),y=Ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=f?I_(f,y):null,x=[s,i],w=o!=null,S=a!=null,C=f==="leakyrelu";if(w&&x.push(o),S&&x.push(a),C){const E=t.makeTensorInfo([],"float32",Bf(d,"float32"));x.push(E),p.push(E)}let k;y?k=new eQ(g,w,b,S,C):k=new QJ(g,w,b,S,C);const A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=t.runWebGLProgram(k,x,"float32",A);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),M}const CPe={kernelName:Wb,backendName:"webgl",kernelFunc:SPe};let kPe=class{constructor(e,t,r,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=Fr(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TPe(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Te(r.shape),[l,c,u,h]=aC(r,s),f=At({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),d=At({inputs:{x:r},backend:t,attrs:{shape:[Te(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=t.readSync(s.dataId),b=t.bufferSync(r),x=MMe(y,b,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,x.values)}const p=new kPe(o,h,[c,u],r.shape),m=t.runWebGLProgram(p,[d,f],d.dtype),g=At({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),g}const EPe={kernelName:p2,backendName:"webgl",kernelFunc:TPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let IPe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Fr(this.rank),s=APe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}};function APe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=An(o,s.shape)[0];if(Ee().get("DEBUG")){const b=t.readSync(i.dataId),x=s.shape[l];for(let w=0;w<b.length;++w){const S=b[w];U(S<=x-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${x-1}]`)}}const c=EN(s,i,l,a),u=Te(i.shape),h=[],f=At({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=At({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=t.bufferSync(d),x=t.bufferSync(f),w=NMe(x,b,p);return h.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(c.outputShape,w.dtype,w.values)}const m=new IPe(f.shape,p),g=t.runWebGLProgram(m,[f,d],f.dtype);h.push(g);const y=At({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const MPe={kernelName:Hv,backendName:"webgl",kernelFunc:rQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NPe="return float(a > b);",$Pe=`
  return vec4(greaterThan(a, b));
`,RPe=uo({opSnippet:NPe,packedOpSnippet:$Pe,cpuKernelImpl:$Me,dtype:"bool"}),PPe={kernelName:jv,backendName:"webgl",kernelFunc:RPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DPe="return float(a >= b);",OPe=`
  return vec4(greaterThanEqual(a, b));
`,FPe=uo({opSnippet:DPe,packedOpSnippet:OPe,dtype:"bool",cpuKernelImpl:RMe}),LPe={kernelName:ty,backendName:"webgl",kernelFunc:FPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zPe(n){const{inputs:e,backend:t}=n,{input:r}=e;return nQ(r,!0,t)}const BPe={kernelName:m2,backendName:"webgl",kernelFunc:zPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VPe="return float(!isnan(x) && !isinf(x));",UPe=gr({opSnippet:VPe,dtype:"bool"}),WPe={kernelName:ry,backendName:"webgl",kernelFunc:UPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GPe="return float(isinf(x));",HPe=gr({opSnippet:GPe,dtype:"bool"}),jPe={kernelName:sy,backendName:"webgl",kernelFunc:HPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qPe="return float(isnan(x));",XPe=gr({opSnippet:qPe,dtype:"bool"}),KPe={kernelName:iy,backendName:"webgl",kernelFunc:XPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YPe="return float(a < b);",ZPe=`
  return vec4(lessThan(a, b));
`,JPe=uo({opSnippet:YPe,packedOpSnippet:ZPe,cpuKernelImpl:PMe,dtype:"bool"}),QPe={kernelName:Xv,backendName:"webgl",kernelFunc:JPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eDe="return float(a <= b);",tDe=`
  return vec4(lessThanEqual(a, b));
`,nDe=uo({opSnippet:eDe,packedOpSnippet:tDe,cpuKernelImpl:DMe,dtype:"bool"}),rDe={kernelName:Kv,backendName:"webgl",kernelFunc:nDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sDe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=OMe(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const iDe={kernelName:y2,backendName:"webgl",kernelFunc:sDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oDe=Lw+`
  return x < 0.0 ? 0./0. : log(x);
`,aDe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,lDe=gr({opSnippet:oDe,packedOpSnippet:aDe,cpuKernelImpl:FMe}),cDe={kernelName:oy,backendName:"webgl",kernelFunc:lDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uDe=Lw+`
  return log(1.0 + x);
`,hDe=gr({opSnippet:uDe}),fDe={kernelName:ay,backendName:"webgl",kernelFunc:hDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dDe="return float(a >= 1.0 && b >= 1.0);",pDe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,mDe=uo({opSnippet:dDe,packedOpSnippet:pDe,dtype:"bool"}),gDe={kernelName:Yv,backendName:"webgl",kernelFunc:mDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yDe="return float(!(x >= 1.0));",bDe=gr({opSnippet:yDe}),vDe={kernelName:Zv,backendName:"webgl",kernelFunc:bDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wDe="return float(a >= 1.0 || b >= 1.0);",xDe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,_De=uo({opSnippet:wDe,packedOpSnippet:xDe,dtype:"bool"}),SDe={kernelName:Jv,backendName:"webgl",kernelFunc:_De};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CDe=class{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kDe{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TDe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=Ee().getBool("WEBGL_PACK_NORMALIZATION")?new kDe(s.shape,i,o,a,l):new CDe(s.shape,i,o,a,l);return t.runWebGLProgram(c,[s],s.dtype)},EDe={kernelName:Qv,backendName:"webgl",kernelFunc:TDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let IDe=class{constructor(e,t,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ADe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new IDe(s.shape,a,l,c,u);return t.runWebGLProgram(h,[s,i,o],s.dtype)},MDe={kernelName:b2,backendName:"webgl",kernelFunc:ADe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NDe(n,e,t,r){const s=Te(e),o=Te(n.shape)/s,a=At({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=Uy(a,n.dtype,"max",r),c=At({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a),h=u!=null,f=t.shouldExecuteOnCPU([s]);let d=s;if(h){if(f){const x=t.texData.get(d.dataId).values,w=new Array(a);for(let k=0;k<w.length;k++)w[k]=s.shape[u[k]];const S=fB(x,s.shape,s.dtype,u,w);d=t.makeTensorInfo(w,s.dtype);const C=t.texData.get(d.dataId);C.values=S}else d=$N(s,u,t);c=ns(c.length,a)}fi("max",c,a);const[p,m]=Qs(d.shape,c);let g=p;o&&(g=Ls(p,l));let y;if(f){const x=t.texData.get(d.dataId).values,w=LMe(x,Te(m),g,s.dtype);y=t.makeTensorInfo(g,s.dtype);const S=t.texData.get(y.dataId);S.values=w}else y=NDe(d,m,g,t);return h&&t.disposeIntermediateTensorInfo(d),y}const $De={kernelName:ew,backendName:"webgl",kernelFunc:sQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RDe=dB+`
  return max(a, b);
`,PDe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vy+`
  return result;
`,DDe=uo({opSnippet:RDe,packedOpSnippet:PDe,cpuKernelImpl:zMe}),ODe={kernelName:ly,backendName:"webgl",kernelFunc:DDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;dC(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1;U(Ri(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=ko(s.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Rn(u.inShape,u.outShape))return Xa({inputs:{x:s},backend:t});const h=new A_(u,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}const LDe={kernelName:tw,backendName:"webgl",kernelFunc:FDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ol(s.shape,i,o,u,a,c,l),f=new mB(h,"max",!1);return t.runWebGLProgram(f,[s],s.dtype)}const BDe={kernelName:nw,backendName:"webgl",kernelFunc:zDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},UDe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,f=c-1-e.padInfo.top,d=u-1-e.padInfo.left,p=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ol(o.shape,a,l,h,c,u),d=new mB(f,"max",!0),p=t.runWebGLProgram(d,[o],o.dtype),m=new UDe(f),g=t.runWebGLProgram(m,[s,p],o.dtype);return t.disposeIntermediateTensorInfo(p),g}const GDe={kernelName:w2,backendName:"webgl",kernelFunc:WDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HDe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;dC([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=!0,p=new A_(f,"max",d),m=t.runWebGLProgram(p,[a],a.dtype),g=new VDe(f),y=t.runWebGLProgram(g,[s,m],a.dtype);return t.disposeIntermediateTensorInfo(m),y}const jDe={kernelName:v2,backendName:"webgl",kernelFunc:HDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qDe(n,e,t,r){let s=new A_(t,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");s=new A_(t,"max",!0,!0,e);const o=r.runWebGLProgram(s,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XDe={kernelName:x2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;U(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];U(Ri(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=ko(r.shape,s,i,c,o),[h,f]=qDe(r,a,u,l);return[h,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KDe(n,e,t,r){const s=Te(e),o=Te(n.shape)/s,a=At({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=Uy(a,"float32","mean",r),c=At({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YDe={kernelName:rw,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:i}=e,o=t,a=r.shape.length,l=An(i,r.shape);let c=l;const u=Lr(c,a),h=u!=null,f=o.shouldExecuteOnCPU([r]),d=[];let p=r;if(h){if(f){const w=o.texData.get(p.dataId).values,S=new Array(a);for(let A=0;A<S.length;A++)S[A]=r.shape[u[A]];const C=fB(w,r.shape,r.dtype,u,S);p=o.makeTensorInfo(S,r.dtype);const k=o.texData.get(p.dataId);k.values=C}else p=$N(r,u,o);d.push(p),c=ns(c.length,a)}fi("sum",c,a);const[m,g]=Qs(p.shape,c);let y=m;s&&(y=Ls(m,l));const b=KDe(p,g,y,o);for(const x of d)o.disposeIntermediateTensorInfo(x);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZDe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=An(i,s.shape);let c=l;const u=Lr(c,a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),c=ns(c.length,s.shape.length)),fi("min",c,a);const[f,d]=Qs(h.shape,c),p=Te(d),m=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}}),g=Uy(m,m.dtype,"min",t);let y;if(o){const b=Ls(f,l);y=At({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=At({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(h),y}const JDe={kernelName:sw,backendName:"webgl",kernelFunc:ZDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QDe=dB+`
  return min(a, b);
`,eOe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vy+`
  return result;
`,tOe=uo({opSnippet:QDe,packedOpSnippet:eOe,cpuKernelImpl:BMe}),nOe={kernelName:cy,backendName:"webgl",kernelFunc:tOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rOe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const s=e.length,i=Fr(s),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sOe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);const s=e.length,i=Fr(s),o=t.map(p=>p[0]).join(","),a=t.map((p,m)=>p[0]+e[m]).join(","),l=Wo("rc",s),c=Wo("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let d="";if(s===1){const p=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[s-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const p=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${i} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[s-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${p}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[s-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iOe=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:i}=t,o=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sOe(r.shape,s,i):new rOe(r.shape,s,i);return e.runWebGLProgram(o,[r],r.dtype)},oOe={kernelName:iw,backendName:"webgl",kernelFunc:iOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aOe=`if (b == 0.0) return NAN;
  return mod(a, b);`,lOe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Vy+`
  return result;
`,cOe=uo({opSnippet:aOe,packedOpSnippet:lOe}),uOe={kernelName:uy,backendName:"webgl",kernelFunc:cOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hOe=class{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fOe=`
if (a == b) {
  return 1.0;
};
return a / b;`,dOe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,iQ=uo({opSnippet:fOe,packedOpSnippet:dOe,checkOutOfBounds:!0}),pOe={kernelName:Xg,backendName:"webgl",kernelFunc:iQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HG="return a - b;",oQ=uo({opSnippet:HG,packedOpSnippet:HG,supportsComplex:!0,cpuKernelImpl:aNe}),mOe={kernelName:Ty,backendName:"webgl",kernelFunc:oQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aQ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=An([i],s.shape),a=sQ({inputs:{x:s},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Ls(a.shape,o),c=At({inputs:{x:a},backend:t,attrs:{shape:l}}),u=oQ({inputs:{a:s,b:c},backend:t}),h=tQ({inputs:{x:u},backend:t}),f=RN({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),d=At({inputs:{x:f},backend:t,attrs:{shape:l}}),p=iQ({inputs:{a:h,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),p}const gOe={kernelName:Sw,backendName:"webgl",kernelFunc:aQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yOe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:aQ({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new hOe(c,u,i),f=[[o]],d=t.runWebGLProgram(h,[l],"int32",f);return a||t.disposeIntermediateTensorInfo(l),d}const bOe={kernelName:_2,backendName:"webgl",kernelFunc:yOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vOe=$c+`
  return -x;
`,wOe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function xOe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId),[o,a]=UMe(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}let s;return Ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Md(r.shape,wOe):s=new uh(r.shape,vOe),t.runWebGLProgram(s,[r],r.dtype)}const _Oe={kernelName:ow,backendName:"webgl",kernelFunc:xOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SOe=rC;function COe(n){bl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=SOe(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const kOe={kernelName:S2,backendName:"webgl",kernelFunc:COe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TOe=sN;function EOe(n){bl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),{selectedIndices:f,validOutputs:d}=TOe(u,h,o,a,l,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const IOe={kernelName:_M,backendName:"webgl",kernelFunc:EOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AOe=sC;function MOe(n){bl("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=AOe(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const NOe={kernelName:C2,backendName:"webgl",kernelFunc:MOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $Oe=class{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ROe=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=Te(s.shape),u=new $Oe(c,o,a,l),h=At({inputs:{x:s},backend:t,attrs:{shape:[c]}}),f=t.runWebGLProgram(u,[h],i);t.disposeIntermediateTensorInfo(h);const d=[...s.shape,o],p=At({inputs:{x:f},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(f),p},POe={kernelName:cw,backendName:"webgl",kernelFunc:ROe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=mC({inputs:{input:r},backend:t}),i=LI({inputs:{x:s},backend:t}),o=PN({inputs:{input:r},backend:t}),a=LI({inputs:{x:o},backend:t}),l=Rp({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return gC({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const DOe={kernelName:Tw,backendName:"webgl",kernelFunc:LI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=mC({inputs:{input:r},backend:t}),i=lQ({inputs:{x:s},backend:t}),o=PN({inputs:{input:r},backend:t}),a=LI({inputs:{x:o},backend:t}),l=Rp({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return gC({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const OOe={kernelName:lw,backendName:"webgl",kernelFunc:lQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FOe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return RD({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{qi(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=RD({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=qJ({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const LOe={kernelName:uw,backendName:"webgl",kernelFunc:FOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zOe=class{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const s=e.length,i=Fr(s),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BOe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const s=e.length,i=Fr(s),o=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+e[g]).join(","),l=Wo("rc",s),c=Wo("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${u}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${u}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=s===1?2:4;m<g;m++)p+=`
        ${f[m]}
        if (${d}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;p+=s===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cQ=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(Te(s.shape)===0){const c=i.map((u,h)=>u[0]+s.shape[h]+u[1]);return gC({backend:t,attrs:{shape:c,value:o,dtype:s.dtype}})}const a=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new BOe(s.shape,i,o):new zOe(s.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[s],s.dtype,l)},VOe={kernelName:hw,backendName:"webgl",kernelFunc:cQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UOe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,WOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Vy+`
  return result;
`,GOe=uo({opSnippet:UOe,packedOpSnippet:WOe}),HOe={kernelName:fy,backendName:"webgl",kernelFunc:GOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jOe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=An(i,s.shape);let u=c;const h=Lr(u,a);let f=s;h!=null&&(f=Zo({inputs:{x:s},backend:t,attrs:{perm:h}}),u=ns(u.length,a),l.push(f)),fi("prod",u,a);let d;if(t.shouldExecuteOnCPU([f])){const p=t.texData.get(f.dataId).values,{outVals:m,outShape:g,outDtype:y}=GMe(f.shape,f.dtype,p,u);d=t.makeTensorInfo(g,y,m)}else{const[p,m]=Qs(f.shape,u),g=Te(m),y=At({inputs:{x:f},backend:t,attrs:{shape:[-1,g]}}),b=G2(s.dtype),x=Uy(y,b,"prod",t);d=At({inputs:{x},backend:t,attrs:{shape:p}}),l.push(y),l.push(x)}if(o){l.push(d);const p=Ls(d.shape,c);d=At({inputs:{x:d},backend:t,attrs:{shape:p}})}return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),d}const qOe={kernelName:dw,backendName:"webgl",kernelFunc:jOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XOe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(y=>t.readSync(y.dataId)),c=s.map(y=>y.shape),u=t.readSync(i.dataId),h=t.readSync(o.dataId),[f,d,p]=HMe(l,c,u,i.shape,i.dtype,h,o.shape,a),m=f.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,i.dtype,d);return m.concat([g])}const KOe={kernelName:SM,backendName:"webgl",kernelFunc:XOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YOe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=jMe(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([c.length],"int32",c),f=t.makeTensorInfo([u.length],r.dtype,u);return[h,f]}const ZOe={kernelName:CM,backendName:"webgl",kernelFunc:YOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JOe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),h=t.readSync(o.dataId),f=a.map(g=>t.readSync(g.dataId)),d=a.map(g=>g.shape),[p,m]=qMe(c,s.shape,u,i.shape,i.dtype,h,o.shape,f,d,l);return t.makeTensorInfo(p,i.dtype,m)}const QOe={kernelName:kM,backendName:"webgl",kernelFunc:JOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uQ=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=XMe(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},eFe={kernelName:k2,backendName:"webgl",kernelFunc:uQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tFe="return 1.0 / x;",nFe=gr({opSnippet:tFe}),rFe={kernelName:dy,backendName:"webgl",kernelFunc:nFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sFe=$c+`
  return (x < 0.0) ? 0.0 : x;
`,iFe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,oFe=gr({opSnippet:sFe,packedOpSnippet:iFe}),aFe={kernelName:py,backendName:"webgl",kernelFunc:oFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lFe=$c+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,cFe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uFe=gr({opSnippet:lFe,packedOpSnippet:cFe}),hFe={kernelName:my,backendName:"webgl",kernelFunc:uFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fFe=class{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;i?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dFe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;i?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dFe(s.shape,l,c,i,o):new fFe(s.shape,l,c,i,o);return t.runWebGLProgram(u,[s],"float32")}const mFe={kernelName:gw,backendName:"webgl",kernelFunc:pFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gFe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new gFe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const bFe={kernelName:I2,backendName:"webgl",kernelFunc:yFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vFe=class{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;i?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wFe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,r,c];const u=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],f=s?"0.5":"0.0";let d;i?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=Ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wFe(s.shape,l,c,i,o):new vFe(s.shape,l,c,i,o);return t.runWebGLProgram(u,[s],s.dtype)}const _Fe={kernelName:mw,backendName:"webgl",kernelFunc:xFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SFe=class{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],f=1/u,d=1/h,p=Math.ceil(f)*2+2,m=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${p});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CFe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new SFe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const kFe={kernelName:E2,backendName:"webgl",kernelFunc:CFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TFe=class{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>s(l)).join(","),o=Fr(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EFe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=Wo("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Fr(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${i}){
            result.g = ${c(s.slice())};
          }
          if(${o}) {
            result.b = ${u(s.slice())};
            if(${i}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return f(p)}function c(p){return p[r-1]="("+p[r-1]+" + 1)",f(p)}function u(p){return p[r-2]="("+p[r-2]+" + 1)",f(p)}function h(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",f(p)}function f(p){const m=e.map((b,x)=>d(x,p)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function d(p,m){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${m[p]} - 1`:`${m[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IFe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length,a=An(i,s.shape);if(o===0)return Xa({inputs:{x:s},backend:t});const l=Ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EFe(s.shape,a):new TFe(s.shape,a);return t.runWebGLProgram(l,[s],s.dtype)}const AFe={kernelName:yw,backendName:"webgl",kernelFunc:IFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MFe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NFe={kernelName:V2,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new MFe(r.shape,i),[c,u]=fN(o,r.shape[1],r.shape[2]),h=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Fe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,RFe=gr({opSnippet:$Fe}),PFe={kernelName:gy,backendName:"webgl",kernelFunc:RFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DFe="return inversesqrt(x);",OFe=gr({opSnippet:DFe,cpuKernelImpl:KMe}),FFe={kernelName:yy,backendName:"webgl",kernelFunc:OFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gB=class{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Fr(i.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LFe{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Fr(i.length),u=Fr(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const f=`getIndices(${h})`;let d="";s===1?d="i":s===2&&(d="i, coords[1]");const p=`getUpdates(${d})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${i});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zFe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(i,s,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,s.dtype);const d=At({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=At({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;Ee().getBool("WEBGL_PACK")?g=new LFe(l,a,d.shape.length,p.shape.length,u,f):g=new gB(l,a,d.shape.length,p.shape.length,u,f);const y=t.runWebGLProgram(g,[p,d,m],p.dtype),b=At({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),b}const BFe={kernelName:A2,backendName:"webgl",kernelFunc:zFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let VFe=class{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=Ee().getNumber("WEBGL_VERSION")===2?i:o,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UFe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new VFe(s.shape[0],s.shape[1],i.shape[1],o),l=[[s.shape[1]]];return t.runWebGLProgram(a,[s,i],"int32",l)}const WFe={kernelName:N2,backendName:"webgl",kernelFunc:UFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GFe=class{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,i;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=Fr(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HFe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new GFe(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(o,[r,s,i],Mi(s.dtype,i.dtype))}const jFe={kernelName:bw,backendName:"webgl",kernelFunc:HFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qFe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${cC};
  float scale = ${uC};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,XFe=gr({opSnippet:qFe}),KFe={kernelName:by,backendName:"webgl",kernelFunc:XFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YFe=Lw+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,ZFe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,JFe=gr({opSnippet:YFe,packedOpSnippet:ZFe,cpuKernelImpl:ZMe}),QFe={kernelName:_y,backendName:"webgl",kernelFunc:JFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eLe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,tLe=gr({opSnippet:eLe}),nLe={kernelName:xy,backendName:"webgl",kernelFunc:tLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rLe=Lw+`
  return sin(x);
`,sLe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Vy}
  return result;
`,iLe=gr({opSnippet:rLe,packedOpSnippet:sLe}),oLe={kernelName:vy,backendName:"webgl",kernelFunc:iLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aLe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,lLe=gr({opSnippet:aLe}),cLe={kernelName:wy,backendName:"webgl",kernelFunc:lLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uLe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,hLe=gr({opSnippet:uLe}),fLe={kernelName:Sy,backendName:"webgl",kernelFunc:hLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dLe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<s.shape.length;++y)l.push([0,0]);const c=[],u=cQ({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),h=Oy(u.shape,i,a,!1),f=Fy(h.length,i.length,!1),d=Ly(u.shape,i,a,!1),p=At({inputs:{x:u},backend:t,attrs:{shape:h}}),m=Zo({inputs:{x:p},backend:t,attrs:{perm:f}}),g=At({inputs:{x:m},backend:t,attrs:{shape:d}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},pLe={kernelName:xw,backendName:"webgl",kernelFunc:dLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mLe(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(s.dataId),c=t.readSync(i.dataId),u=t.readSync(o.dataId)[0],[h,f,d,p,m]=QMe(a,r.shape,r.dtype,l,s.dtype,c,u);return[t.makeTensorInfo(f,r.dtype,h),t.makeTensorInfo([f[0]],s.dtype,d),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const gLe={kernelName:TM,backendName:"webgl",kernelFunc:mLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yLe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),l=Array.from(t.readSync(i.dataId)),[c,u,h]=eNe(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(u,r.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const bLe={kernelName:EM,backendName:"webgl",kernelFunc:yLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vLe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=PJ(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(u,r.dtype,c)}const wLe={kernelName:$2,backendName:"webgl",kernelFunc:vLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xLe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[c,u]=PJ(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(u,r.dtype,c)}const _Le={kernelName:R2,backendName:"webgl",kernelFunc:xLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SLe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Fu(i,s,a),d=!1;if(i.dtype==="string"){const y=t.bufferSync(s),b=t.bufferSync(i),x=_c(t.readSync(o.dataId)[0]),w=YMe(y,b,a,f,u,c,l,h,x,d);return t.makeTensorInfo(a,w.dtype,w.values)}const p=new gB(c,l,s.shape.length,i.shape.length,h,[f,1],d),m=t.runWebGLProgram(p,[i,s,o],i.dtype),g=At({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),g}const CLe={kernelName:P2,backendName:"webgl",kernelFunc:SLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=An(o,s.shape)[0],l=TN(s,i,a),c=s.shape.length,u=new Array(c).fill(0),h=s.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=zw({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const TLe={kernelName:_w,backendName:"webgl",kernelFunc:kLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jG="return sqrt(x);",ELe=gr({opSnippet:jG,packedOpSnippet:jG,cpuKernelImpl:tNe}),ILe={kernelName:Cy,backendName:"webgl",kernelFunc:ELe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ALe="return x * x;",MLe=gr({opSnippet:ALe}),NLe={kernelName:D2,backendName:"webgl",kernelFunc:MLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qG="return (a - b) * (a - b);",$Le=uo({opSnippet:qG,packedOpSnippet:qG}),RLe={kernelName:ky,backendName:"webgl",kernelFunc:$Le};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(s.dataId),o=xu(i),a=nNe(o,"string",r);return t.makeTensorInfo(s.shape,"string",a)}const DLe={kernelName:O2,backendName:"webgl",kernelFunc:PLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OLe({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=$c+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new uh(r.shape,s);return t.runWebGLProgram(i,[r],r.dtype)}const FLe={kernelName:My,backendName:"webgl",kernelFunc:OLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LLe=class{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=Fr(r.length),o=Fr(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zLe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=cN(s.shape,i,o,a,l,c,u,h,f);let S;if(m)S=At({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=lN(b,x,w),A=zw({inputs:{x:s},backend:t,attrs:{begin:b,size:k}});S=At({inputs:{x:A},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(A)}else if(t.shouldExecuteOnCPU([s])){const A=t.readSync(s.dataId),M=Sn(s.shape,s.dtype,A),E=rNe(d,M,w,b);S=t.makeTensorInfo(p,s.dtype,E.values)}else{const A=new LLe(b,w,d);S=t.runWebGLProgram(A,[s],s.dtype)}const C=At({inputs:{x:S},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(S),C}const BLe={kernelName:F2,backendName:"webgl",kernelFunc:zLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VLe(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=sNe(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const ULe={kernelName:L2,backendName:"webgl",kernelFunc:VLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WLe(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=iNe(a,l,s),f=u.length;return[t.makeTensorInfo([f,2],"int32",c),t.makeTensorInfo([f],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const GLe={kernelName:IM,backendName:"webgl",kernelFunc:WLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HLe(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=oNe(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const jLe={kernelName:AM,backendName:"webgl",kernelFunc:HLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qLe="return tan(x);",XLe=gr({opSnippet:qLe}),KLe={kernelName:Ey,backendName:"webgl",kernelFunc:XLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YLe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ZLe=gr({opSnippet:YLe}),JLe={kernelName:Iy,backendName:"webgl",kernelFunc:ZLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QLe(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(o,i,s.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const d=At({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),p=At({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),m=At({inputs:{x:s},backend:t,attrs:{shape:f}}),g=new gB(l,a,d.shape.length,p.shape.length,u,f,!1,!0),y=t.runWebGLProgram(g,[p,d,m],m.dtype),b=At({inputs:{x:y},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const eze={kernelName:M2,backendName:"webgl",kernelFunc:QLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tze=class{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*t[o];this.outputShape=r,this.rank=r.length;const s=Fr(this.rank),i=nze(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}};function nze(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(s.dtype==="string"||s.shape.length>5){const l=t.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>_c(f)):l,u=Sn(s.shape,s.dtype,c),h=lNe(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new tze(s.shape,i);return t.runWebGLProgram(o,[s],s.dtype)}const rze={kernelName:Ay,backendName:"webgl",kernelFunc:hQ};let sze=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},ize=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rm(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function XG(n){let e=1;for(;e<n;)e*=2;return e}function oze(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=Ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([s])||u<a||i>l){const E=t.readSync(s.dataId),[N,O]=cNe(E,c,s.dtype,i,o);return[t.makeTensorInfo(N.shape,N.dtype,N.values),t.makeTensorInfo(O.shape,O.dtype,O.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,s.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[s,gC({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(s.dataId),f=h!==null&&h.isPacked,d=f?t.unpackTensor(s):s,m=Te(c)/u,g=At({inputs:{x:d},attrs:{shape:[m,u]},backend:t});f&&rm(t,d);const y=XG(i),b=XG(u);let x=null;const w=()=>x===null?[g,g]:[g,x],S=(E,N,O)=>{const R=w(),D=new sze(O),B=[[u],[x===null?1:0],[Number.NEGATIVE_INFINITY],[E],[N]],X=x;x=t.runWebGLProgram(D,R,"int32",B),rm(t,X)};for(let E=1;E<y;E*=2){const N=E*2;for(let O=E;O>=1;O/=2)S(N,O,[m,b])}for(let E=b;E>y;E/=2){const N=w(),O=new ize([m,E/2]),D=[[u],[x===null?1:0],[y]],z=x;x=t.runWebGLProgram(O,N,"int32",D),rm(t,z);const B=y/2,X=B*2;for(let G=B;G>=1;G/=2)S(X,G,x.shape)}let C=x;x=zw({inputs:{x},backend:t,attrs:{begin:0,size:[m,i]}}),rm(t,C);let k=rQ({inputs:{x:g,indices:x},backend:t,attrs:{axis:1,batchDims:1}});rm(t,g);const A=c.slice(0,-1);A.push(i),C=x,x=At({inputs:{x},attrs:{shape:A},backend:t}),rm(t,C);const M=k;return k=At({inputs:{x:k},attrs:{shape:A},backend:t}),rm(t,M),[k,x]}const aze={kernelName:z2,backendName:"webgl",kernelFunc:oze};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lze=class{constructor(e,t,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cze(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new lze(h,f,o,a,l,g);return t.runWebGLProgram(y,[s,i],"float32")}const uze={kernelName:B2,backendName:"webgl",kernelFunc:cze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hze(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;dC(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=uNe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const fze={kernelName:MM,backendName:"webgl",kernelFunc:hze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dze(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[i]=m;const g=zw({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=At({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const pze={kernelName:Cw,backendName:"webgl",kernelFunc:dze};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mze{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const l="0.0",c="sumValue",u=Math.floor(r/4)*4,h=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let d="";i%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gze(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Lr([c],a);let h=s;u!=null&&(h=Zo({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),c=ns(1,a)[0]);const f=Jz(h.shape,c,o),d=Te([h.shape[c]]),p=At({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=G2(s.dtype),g=(w,S,C,k,A)=>{const M=w.shape[0],E=w.shape[1],N=oZ(E,A),O={windowSize:N,inSize:E,batchSize:M,numSegments:A},R=new mze(O,S),D=t.compileAndRun(R,[w,C],k);if(l.push(D),D.shape[1]===A)return D;const z=uQ({backend:t,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),B=hQ({inputs:{x:z},backend:t,attrs:{reps:[E/N]}});return l.push(z),l.push(B),g(D,S,B,k,A)},y=g(p,"unsortedSegmentSum",i,m,o),b=At({inputs:{x:y},backend:t,attrs:{shape:f}});let x=b;if(u!=null){l.push(b);const w=Mh(u);x=Zo({inputs:{x},backend:t,attrs:{perm:w}})}return l.forEach(w=>t.disposeIntermediateTensorInfo(w)),x}const yze={kernelName:kw,backendName:"webgl",kernelFunc:gze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bze=[t$e,r$e,o$e,c$e,h$e,p$e,g$e,b$e,_$e,C$e,E$e,M$e,R$e,F$e,B$e,U$e,G$e,X$e,Y$e,J$e,nRe,cRe,hRe,mRe,yRe,SRe,kRe,ARe,LNe,$Re,FRe,VRe,qRe,YRe,JRe,e3e,n3e,o3e,c3e,f3e,p3e,g3e,b3e,x3e,S3e,E3e,A3e,$3e,D3e,F3e,V3e,H3e,K3e,J3e,tPe,nPe,sPe,oPe,lPe,uPe,fPe,gPe,vPe,_Pe,CPe,EPe,MPe,PPe,LPe,FNe,BPe,DRe,WPe,jPe,KPe,BNe,QPe,rDe,iDe,cDe,fDe,gDe,vDe,SDe,EDe,MDe,$De,ODe,LDe,BDe,GDe,jDe,XDe,YDe,JDe,nOe,oOe,uOe,bOe,WNe,_Oe,kOe,IOe,NOe,vRe,POe,OOe,LOe,VOe,HOe,UNe,qOe,KOe,ZOe,QOe,eFe,wRe,pOe,rFe,aFe,hFe,HNe,mFe,bFe,_Fe,kFe,AFe,NFe,PFe,FFe,BFe,WFe,jFe,KFe,QFe,nLe,oLe,cLe,aRe,gOe,fLe,pLe,gLe,bLe,wLe,_Le,CLe,TLe,ILe,NLe,RLe,DLe,FLe,BLe,ULe,GLe,jLe,mOe,JNe,KLe,JLe,eze,rze,aze,uze,QNe,fze,pze,yze,DOe];for(const n of bze)U2(n);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fl=Ee();Fl.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Fl.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Fl.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Fl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Fl.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Fl.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Fl.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Fl.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Fl.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Fl.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Fl.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Fl.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Fl.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vze{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wze{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,r=!1,s=!0){let i;const o=KG(e,t);return s?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(i=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,i=KG(r,s),o=this.usedBuffers.get(i),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,t?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function KG(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xze{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,r,s){const i=ZG(r),o=e*t*i,a=YG(e,t,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,t],format:r,usage:s});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,r=e.height,s=e.format,i=e.usage,o=YG(t,r,s,i);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=ZG(s),u=t*r*c;this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function YG(n,e,t,r){return`${n}_${e}_${t}_${r}`}function ZG(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ze(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,r="xyzwuv",s=n.map(o=>`${e}.${r[o]}`),i=new Array(t-1);i[t-2]=s[t-1];for(let o=t-3;o>=0;--o)i[o]=`(${i[o+1]} * ${s[o+1]})`;return i}const Pp=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var nv;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(nv||(nv={}));const Sze=(n,e,t,r,s)=>{const i={dtype:r.dtype,shape:r.shape},o=kze(t,i,e),a=n.createShaderModule({code:o,label:e.constructor.name});let l=Ee().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(u=>e.shaderKey.toLowerCase().includes(u)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return s?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},Vn=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Ys(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Ef(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function xt(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function JG(n,e){let t;return t=`
     ${Cze(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function Cze(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function kze(n,e,t){const r=[],s=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${fQ(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const p=t.pixelsOpType===nv.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Rm(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Rm(n[0].dtype,t.outputComponent)}>;`,m=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${m},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${p}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const g=eH(t);return[QG,r.join(`
`),PE(e.shape),t.getUserCode(),JG(g,t)].join(`
`)}let i,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((p,m)=>{const g=Ys(n[m].shape.length);a+=`${p.charAt(0).toLowerCase()+p.slice(1)}Shape : ${g}, `,i=n[m].shape.length-1,o=Ys(i),a+=`${p.charAt(0).toLowerCase()+p.slice(1)}ShapeStrides: ${o}, `});const l=Ys(e.shape.length);a+=`outShape : ${l}, `,i=e.shape.length-1,o=Ys(i),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=Pze(a),r.push(a),t.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Rm(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((p,m)=>{r.push(`
      @group(0) @binding(${1+m}) var<storage, read> ${p}: array<${t.variableComponents?Rm(n[m].dtype,t.variableComponents[m]):Rm(n[m].dtype,t.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=Nze(e.shape,t.dispatchLayout),u=[QG,r.join(`
`)+Eze,PE(e.shape),c,$ze(e.shape.length)];t.atomic||u.push(Rze(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((p,m)=>{u.push(`${PE(n[m].shape,p)}`)});const h=n.map((p,m)=>Mze(p,e.shape,t.variableComponents?t.variableComponents[m]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);u.push(h),u.push(t.getUserCode());const f=eH(t);return u.push(JG(f,t)),u.join(`
`)}function Tze(n,e,t){let r=n.shaderKey;if(n.pixelsOpType!=null)return r;const s=[],i=[];e.forEach(u=>{s.push(u.shape),i.push(u.dtype)}),s.push(t.shape),i.push(t.dtype);const o=e.map(u=>$f(u.shape,t.shape)),a=e.map(u=>Rn(u.shape,t.shape)).join("_"),l=o.map(u=>u.join("_")).join(";"),c=fQ(n)?"flatDispatch":"";return r+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+s.map(u=>u.length).join(",")+i.join(",")+n.variableNames.join(",")+l+a+c,r}const QG=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,Eze=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function PE(n,e=""){const t=n.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const i=Jt(n),o=Ys(t),a=[];for(let c=0;c<t;c++)a.push(`d${c}`);if(i.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+i.map((c,u)=>{const h=`let ${a[u]} = index2 / uniforms.${s}.${Ef(u)}`,f=u===i.length-1?`let ${a[u+1]} = index2 - ${a[u]} * uniforms.${s}.${Ef(u)}`:`index2 = index2 - ${a[u]} * uniforms.${s}.${Ef(u)}`;return`${h}; ${f};`}).join(""),`
    fn ${r}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function Ize(n,e){const t=n.name,r=n.shape.length,s=Ys(r),i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=o.map(u=>`${u} : i32`).join(", ");if(r<1)return`
      fn ${i}() -> ${Vn(e)} {
        return ${Vn(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${r}D`;return r===0&&(c="1D"),`
    fn ${i}(${a}) -> ${Vn(e)} {
      return ${Vn(e)}(${t}[getIndexFromCoords${c}(${s}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function Aze(n,e,t,r){const s=n.name,i=s.charAt(0).toUpperCase()+s.slice(1),o="get"+i+"ByOutput",a=n.shape.length,l=e.length,c=Ys(l);if(Rn(n.shape,e)&&r)return`
    fn ${o}Index(globalIndex : i32) -> ${Vn(t)} {
      return ${Vn(t)}(${s}[globalIndex]);
    }

    fn ${o}Coords(coords : ${c}) -> ${Vn(t)} {
      return ${Vn(t)}(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const u=$f(n.shape,e),h=l-a;let f="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${Vn(t)}{
      return get${i}();
    }

    fn ${o}Coords(coords : ${c}) -> ${Vn(t)}{
      return get${i}();
    }
  `;l<2&&u.length>=1?f="coords = 0;":f=u.map(g=>`coords.${Ef(g+h)} = 0;`).join(`
`);let d="";if(l<2&&a>0)d="coords";else if(l>1){const g=Ys(a),y=n.shape.map((b,x)=>`coords.${Ef(x+h)}`).join(", ");d=`${g}(${y})`}else d="coords";const p=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,m=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${Vn(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${f}
    return ${Vn(t)}(${s}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${c}) -> ${Vn(t)} {
    var coords = coordsIn;
    ${f}
    return ${Vn(t)}(${s}[getIndexFromCoords${m}(${d}, ${p})${t===1?"":` / ${t}`}]);
  }
`}function Mze(n,e,t,r){let s=Ize(n,t);return n.shape.length<=e.length&&(s+=Aze(n,e,t,r)),s}function Nze(n,e){const{x:t,y:r=[],z:s=[]}=e,i=n.length,o=t.length+r.length+s.length;if(o!==i)return"";if(t.length===i)return`fn getOutputCoords() -> ${Ys(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[t,r,s];for(let f=0;f<l.length;f++){const d=l[f];if(d.length!==0)if(d.length===1)a+=`let d${d[0]} = i32(globalId[${f}]);`;else{const p=_ze(d,"uniforms.outShape");a+=`var index${f} = i32(globalId[${f}]);`;for(let m=0;m<p.length;m++)a+=`let d${d[m]} = index${f} / ${p[m]};`,m===p.length-1?a+=`let d${d[m+1]} = index${f} - d${d[m]} * ${p[m]};`:a+=`index${f} = index${f} - d${d[m]} * ${p[m]};`}}const c=[];for(let f=0;f<o;f++)c.push(`d${f}`);const u=Ys(o);let h=`fn getOutputCoords() -> ${u} {
  ${a}
`;return c.length===0?h+=`return ${u}(0); }`:h+=`return ${u}(${c.join(",")}); }`,h}function $ze(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:U(!1,()=>`Unsupported ${n}D shape`);break}return e}function fQ(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function Rm(n,e=1){if(n==="float32")return Vn(e,"f32");if(n==="int32"||n==="bool")return Vn(e,"i32");throw new Error(`type ${n} is not supported.`)}function Rze(n,e,t){const r=n.length,s=Rm(e,t);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${Vn(t)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Vn(t,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=Ys(r);i+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Vn(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${Vn(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return i}function Pze(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,r=>"@align(16) "+r);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(r,s,i)=>`vec${s}, @align(16) ${i}`),n}function eH(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jm=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function _t(n,e,t=[1,1,1],r=[1,1,1]){const[s,i,o]=[Math.ceil(jm(n.x.map(a=>e[a]))/(t[0]*r[0])),n.y?Math.ceil(jm(n.y.map(a=>e[a]))/(t[1]*r[1])):1,n.z?Math.ceil(jm(n.z.map(a=>e[a]))/(t[2]*r[2])):1];return[s,i,o]}function Dze(n,e,t,r=!1){const s=[8,8,1],i=[4,4,1];return r||(n<=8&&(i[1]=1),e<=16&&t<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:i}}function dQ(n,e,t=!1){if(t)return[8,8,1];const r=jm(n.x.map(i=>e[i])),s=jm(n.y.map(i=>e[i]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function pQ(n,e,t=!1){if(t)return[4,4,1];const r=jm(n.x.map(i=>e[i])),s=jm(n.y.map(i=>e[i]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function Ot(n){return{x:n.map((e,t)=>t)}}function tH(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function mQ(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}function gQ(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&U(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var th;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(th||(th={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oze=Ee().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Fze=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(o=>o<=t))return s;U(s[0]>t&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(s[0]));return i>t?(i=Math.ceil(Math.cbrt(s[0])),U(i<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class Bw extends WS{nextDataId(){return Bw.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!mQ())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new vze(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new wze(this.device),this.textureManager=new xze(this.device),this.tensorMap=new yM(this,xo()),Ee().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return t?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:t,values:e,refCount:1}),s}move(e,t,r,s,i){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:t,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,r)=>{this.pipelineCache[t]=e[r]})}async getBufferData(e){if(Ee().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,r=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),Ee().getBool("WEBGPU_USE_PROFILE_TOOL")&&(U(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,t){const r=this.tensorMap.get(e);return r.values=t,r.values}readSync(e){const t=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=t;if(r!=null||t.dtype==="string")return r;if(t.dtype==="complex64"){const m=this.readSync(s.real.dataId),g=this.readSync(s.imag.dataId),y=K1(wu(m,g).buffer,"float32");return this.convertAndCacheOnCPU(e,y),y}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],o=t.resource,a=o.size;U(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),u=256,h=256,f=i.map(m=>new OffscreenCanvas(u,h)),d=new OffscreenCanvas(u,h);this.endComputePassEncoder(),f.map((m,g)=>{const y=m.getContext("webgpu");return y.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[g]}),y.getCurrentTexture()}).map((m,g)=>{const y=u*4,b=(A,M,E)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:y,offset:E},{texture:m},{width:A,height:M}),this.submitQueue();const N=d.getContext("2d",{willReadFrequently:!0});N.clearRect(0,0,A,M),N.drawImage(f[g],0,0);const O=N.getImageData(0,0,A,M).data,R=i[g],D=new Uint8ClampedArray(c,E,A*M*4);for(let z=0;z<D.length;z+=4)if(R==="premultiplied")D[z+3]=O[z+3];else{const B=O[z];D[z]=O[z+2],D[z+1]=O[z+1],D[z+2]=B}},x=Math.floor(l/(u*h));let w=u,S=h,C=0;for(let A=0;A<x;A++)b(w,S,C),C+=u*h*4;const k=l%(u*h);S=Math.floor(k/u),S>0&&(b(w,S,C),C+=S*(u*4)),w=k%u,w>0&&b(w,1,C)});const p=K1(c,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:r}=t;if(r!=null)return r;let s;if(t.dtype==="complex64"){const i=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=i[0],a=i[1];s=wu(o,a)}else{const i=await this.getBufferData(t.resource);s=K1(i,t.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const t=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(t,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),s}createTensorFromGPUData(e,t,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:r,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(i),a=tH(o.dtype)*Te(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),o.resource=s,xo().makeTensorFromDataId(i,t,r,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:r,dtype:s,shape:i,resource:o}=t;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,c=a.usage,u=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,u,0,l),this.submitQueue();const h=this.makeTensorInfo(i,s),f=xo().makeTensorFromTensorInfo(h),d=this.tensorMap.get(h.dataId);return d.resource=u,{tensorRef:f,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>_c(s));return Sn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Sn(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Sc(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=Sc(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(i);return a.kernelMs=SL(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,r){return t==="string"&&r!=null&&r.length>0&&cu(r[0])&&(r=r.map(i=>gu(i))),{dataId:this.write(r,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const r=tH(t.dtype)*Te(t.shape);let s;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(s=this.bufferManager.acquireBuffer(r,i,!0),s.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,s,0,r),this.stagingPendingDisposal.push(o)}else{const o=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),s.unmap()}t.values=null}else s=this.bufferManager.acquireBuffer(r,i);t.resource=s}makeUniforms(e){let t=0,r=0;const s=[];let i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:U(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(c=16),c>i&&(i=c),t=Math.ceil(t/c)*c,r=l.data.length,s.push(t),t+=l.data.length*4}),t=Math.ceil(t/i)*i;const o=new ArrayBuffer(t);e.forEach((l,c)=>{const u=s[c];l.type==="int32"?new Int32Array(o,u,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,u,l.data.length).set(l.data):new Float32Array(o,u,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,r,s,i){if(i||(i=this.makeTensorInfo(e.outputShape,r)),Te(i.shape)===0)return this.tensorMap.get(i.dataId).values=ci(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=Fze(this.device,e);const o=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=Tze(e,o,i);const a=Ee().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=Sze(this.device,e,o,i,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,i,t,s),i}recordAndSubmit(e,t,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],o=[];const a="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=r.concat(t).map(d=>d.shape);const f="int32";o.map(d=>{i.push({type:f,data:d});const p=Jt(d);i.push({type:f,data:p})})}else{const f=Jt(t.shape);i.push({type:a,data:f})}if(e.size){const f=Te(e.outputShape);i.push({type:a,data:[e.outputComponent?f/e.outputComponent:f]})}s&&(i=[...i,...s]);const l=[this.tensorToBinding(t),...r.map(f=>this.tensorToBinding(f)),this.makeUniforms(i)];r.forEach(f=>{this.commandQueueOwnedIds.add(f.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((f,d)=>({binding:d,resource:f}))}),u=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};u&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites=[{querySet:this.querySet,queryIndex:0,location:"beginning"},{querySet:this.querySet,queryIndex:1,location:"end"}],this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(u||Ee().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===nv.DRAW)&&(this.endComputePassEncoder(),u?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),r=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,t=Oze){return Ee().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&Te(r.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Bw.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */mQ()&&$M("webgpu",async()=>{const n={powerPreference:Ee().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),t.requiredFeatures=r;const s=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(t),o=await e.requestAdapterInfo();return new Bw(i,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yn;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(yn||(yn={}));const Lze="let resultTemp = a + b;",zze="let resultTemp = atan2(a, b);",Bze="let resultTemp = areal * breal - aimag * bimag;",Vze="let resultTemp = areal * bimag + aimag * breal;",Uze="let resultTemp = a / b;",Wze="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",Gze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,Hze=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,jze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,qze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,Xze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,Kze=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,Yze="return f32(a >= 1.0 && b >= 1.0);",Zze=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Jze="return f32(a >= 1.0 || b >= 1.0);",Qze=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,eBe="let resultTemp = max(a, b);",tBe="let resultTemp = min(a, b);",nBe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,rBe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,sBe="let resultTemp = a * b;",iBe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,oBe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,aBe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,lBe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,cBe="if (a < 0.0) { return b * a; }  return a;",uBe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,hBe="let resultTemp = (a - b) * (a - b);",fBe="let resultTemp = a - b;";function yB(n,e){let t;do{switch(n){case yn.ATAN2:t=zze;break;case yn.MAX:t=eBe;break;case yn.MIN:t=tBe;break;case yn.MOD:t=e?rBe:nBe;break;case yn.NOT_EQUAL:t=e?oBe:iBe;break;case yn.POW:t=e?lBe:aBe;break;default:continue}let r,s,i;return e?(r="isnanVec4",s="vec4<f32>",i="vec4<bool>"):(r="isnan",s="f32",i="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case yn.ADD:t=Lze;break;case yn.COMPLEX_MULTIPLY_IMAG:t=Vze;break;case yn.COMPLEX_MULTIPLY_REAL:t=Bze;break;case yn.DIV:t=Uze;break;case yn.ELU_DER:t=Wze;break;case yn.EQUAL:t=Gze;break;case yn.FLOOR_DIV:t=Hze;break;case yn.GREATER:t=jze;break;case yn.GREATER_EQUAL:t=qze;break;case yn.LESS:t=Xze;break;case yn.LESS_EQUAL:t=Kze;break;case yn.LOGICAL_AND:return e?Zze:Yze;case yn.LOGICAL_OR:return e?Qze:Jze;case yn.MUL:t=sBe;break;case yn.PRELU:return e?uBe:cBe;case yn.SQUARED_DIFFERENCE:t=hBe;break;case yn.SUB:t=fBe;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bt;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(bt||(bt={}));const dBe="return abs(a);",pBe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,mBe=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,gBe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,yBe="return asinh(a);",bBe=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,vBe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,wBe="return ceil(a);",xBe="return cos(a);",_Be=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,SBe="return exp(a) - 1.0;",CBe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",kBe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,TBe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${mN};
  let a1 = ${gN};
  let a2 = ${yN};
  let a3 = ${bN};
  let a4 = ${vN};
  let a5 = ${wN};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,EBe="return exp(a);",IBe="return floor(a);",ABe="return f32(!isnan(a) && !isinf(a));",MBe="return f32(isinf(a));",NBe="return f32(isnan(a));",$Be="return a;",RBe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,PBe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,DBe="return f32(!(a >= 1.0));",OBe="return -a;",FBe="if (a < 0.0) { return uniforms.alpha * a; } return a;",LBe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,zBe="return 1.0 / a;",BBe="return select(a, 0.0, a < 0.0);",VBe="return clamp(a, 0.0, 6.0);",UBe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",WBe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,GBe="return round(a);",HBe="return inverseSqrt(a);",jBe=`
  if (a >= 0.0) {
    return ${uC} * a;
  } else {
    return ${cC} * (exp(a) - 1.0);
  }
`,qBe="return 1.0 / (1.0 + exp(-1.0 * a));",XBe="return sign(a);",KBe="return sin(a);",YBe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,ZBe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,JBe="return sqrt(a);",QBe="return a * a;",e4e=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,t4e="return tan(a);",n4e=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,r4e="return f32(i32((a)));";function xm(n,e){switch(n){case bt.ABS:return dBe;case bt.ACOS:return pBe;case bt.ACOSH:return mBe;case bt.ASIN:return gBe;case bt.ASINH:return yBe;case bt.ATAN:return bBe;case bt.ATANH:return vBe;case bt.COS:return xBe;case bt.COSH:return _Be;case bt.CEIL:return wBe;case bt.ELU:return e?kBe:CBe;case bt.ERF:return TBe;case bt.EXP:return EBe;case bt.EXPM1:return SBe;case bt.FLOOR:return IBe;case bt.IS_FINITE:return ABe;case bt.IS_INF:return MBe;case bt.IS_NAN:return NBe;case bt.LINEAR:return $Be;case bt.LOG:return RBe;case bt.LOG1P:return PBe;case bt.LOGICAL_NOT:return DBe;case bt.NEG:return OBe;case bt.LEAKYRELU:return e?LBe:FBe;case bt.RECIPROCAL:return zBe;case bt.RELU:return e?WBe:BBe;case bt.RELU6:return e?UBe:VBe;case bt.ROUND:return GBe;case bt.RSQRT:return HBe;case bt.SELU:return jBe;case bt.SIGMOID:return qBe;case bt.SIGN:return XBe;case bt.SIN:return KBe;case bt.SINH:return YBe;case bt.SOFTPLUS:return ZBe;case bt.SQRT:return JBe;case bt.SQUARE:return QBe;case bt.STEP:return e4e;case bt.TAN:return t4e;case bt.TANH:return n4e;case bt.TO_INT:return r4e;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hf(n,e=!1,t=!1,r=3){if(n===null)return"";let s="";if(n==="linear")s=xm(bt.LINEAR);else if(n==="relu")s=xm(bt.RELU,t);else if(n==="elu")s=xm(bt.ELU,t);else if(n==="relu6")s=xm(bt.RELU6,t);else if(n==="prelu")s=yB(yn.PRELU,t);else if(n==="sigmoid")s=xm(bt.SIGMOID,t);else if(n==="leakyrelu")s=xm(bt.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=Vn(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${o}, coords : vec${r}<i32>) -> ${o} {
        ${s}
      }`,a}function Wy(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yQ(n,e,t=!1,r=!1,s=!1,i=1){U(n&&i===1||!n,()=>`transposeA ${n} is not compatible with component size ${i}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Vn(i)} {
    var value = ${Vn(i)}(0.0);
    ${t&&s?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Vn(i)} {
    var value = ${Vn(i)}(0.0);
    ${a}
    return value;
  }
  `}function bB(n,e,t,r,s=!1,i=!1,o=!1,a=1){return`
  ${yQ(t,r,s,i,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Vn(a)}) {
    ${s&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Wy(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const s4e=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,i4e=(n,e,t,r)=>{if(n)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",i="";for(let o=0;o<e;o++)s+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,i+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function DN(n,e,t=!1,r=32,s=!1,i=32,o=!1){const a=e[1]*n[1],l=e[0]*n[0],c=t?a:r,u=t?r:a,h=c/e[0],f=r/e[1],d=n[1],p=n[0];return U((t&&h===4&&n[1]===4||!t&&(h===3||h===4))&&c%e[0]===0&&r%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${c/h}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${r}>;

  ${xt()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${d};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${d};
    let globalCol = i32(globalId.x) * ${p};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${d}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${f};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${s4e(t,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${i4e(t,h,d,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const nH=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,o4e=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function ON(n,e,t=!1,r=32,s=!1,i=32,o=!1,a=!1){const l=n[1]*e[1],c=n[0]*e[0],u=t?l:r,h=t?r:l;U(h%e[1]===0&&u%e[0]===0&&r%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const f=h/e[1],d=u/e[0],p=r/e[1],m=n[1],g=n[0],y=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${nH(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${f};
  let tileColA = i32(localId.x) * ${d};
  let tileRowB = i32(localId.y) * ${p};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${d}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${nH(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${o4e(t)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${r}>;

    ${xt()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${g}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${y}
    }
  `}const a4e=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function l4e(n,e=!1){U(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${xt()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${a4e(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class c4e{constructor(e,t,r=!1,s=!1,i=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=r?e[1]:e[2];if(this.isVec4=(c%4===0&&!r||t[1]%4===0&&r)&&t[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const f=Dze(t[1],c,t[2],r);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const u=i!=null,h=a!=null;u&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const o=e%s===0,a=t%i===0,l=r%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${Hf(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${bB(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?DN(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?l4e(this.workgroupSize,this.transposeA):ON(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4e(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${xt()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class h4e{constructor(e,t=!1,r=!1,s=null,i=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=r,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${r}`}getUserCode(){return`
      ${Hf(this.activation,this.hasPreluActivationWeights)}
      ${bB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${u4e(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4e(n){const e=n[1],t=n[0],r=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${xt()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class d4e{constructor(e,t,r,s=!1,i=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const c=o!=null;c&&this.variableNames.push("bias");const u=l!=null;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=i,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${i}`}getUserCode(){return`
      ${Hf(this.activation,this.hasPreluActivationWeights)}
      ${bB(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${f4e(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p4e{constructor(e,t,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,U(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(r&&this.outputShape[1]%4===0||!r&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=_t(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${yQ(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Vn(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Pp("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?DN(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):ON(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class m4e{constructor(e,t=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${Hf(this.activation,this.hasPreluActivationWeights)}
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Wy(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g4e{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||Cp(s),i==="string"){const o=Ss(i,Te(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new g4e(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(o,[],i,a)}}const y4e={kernelName:f2,backendName:"webgpu",kernelFunc:ba};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:s}=t,i=Te(r.shape),o=vM(s,i),a=Te(o);return U(i===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}const b4e={kernelName:pw,backendName:"webgpu",kernelFunc:Kt};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],d=t?n.shape[c-1]:n.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=Te(m),b=Te(g),w=ln(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,p]);U(h===f,()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=t?[y,h,d]:[y,d,h],C=r?[b,p,f]:[b,f,p],k=Kt({inputs:{x:n},backend:s,attrs:{shape:S}}),A=Kt({inputs:{x:e},backend:s,attrs:{shape:C}}),M=[k,A],E=Math.max(y,b),N=[k,A],O=[{type:"int32",data:[d]},{type:"int32",data:[p]},{type:"int32",data:[h]}];let R,D;const z=[E,d,p];let B=Ee().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(B<0){const G=Ee().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),te=G>0?G:s.thresholdToIncreaseWorkgroups,ge=E*Math.ceil(d/32)*Math.ceil(p/32);ge<=te||d<=8&&ge<=te*2?E*d*p<=128?B=th.MatMulReduceProgram:E===1&&f>=2e3?B=th.MatMulSplitKProgram:B=th.MatMulSmallOutputSizeProgram:B=th.MatMulPackedProgram}switch(B){case th.MatMulReduceProgram:R=new h4e(z,t,r,i,l,o);break;case th.MatMulSplitKProgram:{if(D=ba({backend:s,attrs:{shape:z,value:0,dtype:n.dtype}}),R=new p4e(z,f,t,r),i||l){D=s.runWebGPUProgram(R,N,n.dtype,O,D);const te=new m4e(D.shape,i,l,o);let ge=null;const ae=[D];i&&ae.push(i),o&&ae.push(o),l==="leakyrelu"&&(ge=[{type:"float32",data:[a]}],te.uniforms+=" alpha : f32,");const Ne=s.runWebGPUProgram(te,ae,D.dtype,ge);M.push(D);const ke=Kt({inputs:{x:Ne},backend:s,attrs:{shape:w}});M.push(Ne);for(const De of M)s.disposeData(De.dataId);return ke}break}case th.MatMulSmallOutputSizeProgram:R=new d4e(S,C,z,t,r,i,l,o);break;case th.MatMulPackedProgram:const G=s.adapterInfo.isIntel();R=new c4e(S,z,t,r,i,l,o,G);break;default:throw new Error(`Unsupported MatMulProgramType ${B}.`)}i&&N.push(i),o&&N.push(o),l==="leakyrelu"&&(O.push({type:"float32",data:[a]}),R.uniforms+=" alpha : f32,"),D=s.runWebGPUProgram(R,N,n.dtype,O,D);const X=Kt({inputs:{x:D},backend:s,attrs:{shape:w}});M.push(D);for(const G of M)s.disposeData(G.dataId);return X}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v4e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=r;return FN({a:s,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const w4e={kernelName:Vb,backendName:"webgpu",kernelFunc:v4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rH{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ln(t,r),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${yB(this.op,!1)}
      }

      ${xt("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zI{constructor(e,t,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ln(t,r),this.dispatchLayout=Ot(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&r.length>1&&t[0]<128,this.useSharedMemoryWithB=r.length<=1&&t.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=t.length>0&&t[t.length-1]%4===0,i=r.length>0&&r[r.length-1]%4===0;s&&i?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(sD(r)||r[r.length-1]===1)||i&&(sD(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${yB(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${xt("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${xt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ka(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const x4e={kernelName:ny,backendName:"webgpu",kernelFunc:Ka};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gy(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.tensorMap.get(i.dataId),a=Ka({inputs:{x:r},backend:t}),l=Ka({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const _4e={kernelName:ZS,backendName:"webgpu",kernelFunc:Gy};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vw{constructor(e,t,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${xm(this.op,!1)}
      }
      ${xt("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yr({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:r,backend:s})=>{const{x:i}=r,o=s,a=t||i.dtype;if(o.shouldExecuteOnCPU([i])&&e!=null){const c=o.tensorMap.get(i.dataId),u=e(c.values,a);return o.makeTensorInfo(i.shape,a,u)}const l=new Vw(i.shape,n);return o.runWebGPUProgram(l,[i],a)}}function Xi({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:r}){return({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(t&&o.dtype==="complex64"){const h=l.tensorMap.get(o.dataId),f=l.tensorMap.get(a.dataId);let d,p;if(n!==yn.MUL)[d,p]=[[h.complexTensorInfos.real,f.complexTensorInfos.real],[h.complexTensorInfos.imag,f.complexTensorInfos.imag]].map(g=>{const[y,b]=g,x={dataId:y.dataId,dtype:y.dtype,shape:o.shape},w={dataId:b.dataId,dtype:b.dtype,shape:a.shape},S=new zI(n,o.shape,a.shape);return l.runWebGPUProgram(S,[x,w],Mi(y.dtype,b.dtype))});else{const g=new rH(yn.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),y=new rH(yn.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:o.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:a.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:a.shape}];d=l.runWebGPUProgram(g,b,"float32"),p=l.runWebGPUProgram(y,b,"float32")}const m=Gy({inputs:{real:d,imag:p},backend:l});return l.disposeData(d.dataId),l.disposeData(p.dataId),m}const c=r||Mi(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const h=l.tensorMap.get(o.dataId).values,f=l.tensorMap.get(a.dataId).values,d=o.dtype==="string"?xu(h):h,p=o.dtype==="string"?xu(f):f,[m,g]=e(o.shape,a.shape,d,p,c);return l.makeTensorInfo(g,c,m)}const u=new zI(n,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:S4e,castImpl:C4e,ceilImpl:k4e,concatImpl:T4e,equalImpl:E4e,expImpl:I4e,expm1Impl:A4e,floorImpl:M4e,floorDivImpl:N4e,gatherNdImpl:$4e,gatherV2Impl:R4e,greaterEqualImpl:P4e,greaterImpl:D4e,lessEqualImpl:O4e,lessImpl:F4e,logImpl:L4e,maxImpl:z4e,maximumImpl:B4e,minimumImpl:V4e,multiplyImpl:U4e,negImpl:W4e,notEqualImpl:G4e,prodImpl:H4e,rangeImpl:j4e,rsqrtImpl:q4e,scatterImpl:X4e,simpleAbsImpl:K4e,sliceImpl:Y4e,stridedSliceImpl:Z4e,stringNGramsImpl:J4e,subImpl:Q4e,tileImpl:eVe,topKImpl:tVe,transposeImpl:nVe,uniqueImpl:WIt}=sJ;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rVe=yr({opType:bt.ABS,cpuKernelImpl:K4e}),sVe={kernelName:Tv,backendName:"webgpu",kernelFunc:rVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iVe=yr({opType:bt.ACOS}),oVe={kernelName:Og,backendName:"webgpu",kernelFunc:iVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aVe=yr({opType:bt.ACOSH}),lVe={kernelName:Fg,backendName:"webgpu",kernelFunc:aVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cVe=Xi({opType:yn.ADD,cpuKernelImpl:S4e,supportsComplex:!0}),uVe={kernelName:kp,backendName:"webgpu",kernelFunc:cVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hVe{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const t=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${xt("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fVe(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Ka({inputs:{x:r[0]},backend:t});const s=r.map(a=>a.dtype).reduce((a,l)=>Mi(a,l)),i=r.map(a=>a.shape),o=new hVe(i);return t.runWebGPUProgram(o,r,s)}const dVe={kernelName:Ev,backendName:"webgpu",kernelFunc:fVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pVe{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){U(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${xt()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mVe{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Ys(this.outputShape.length),t=bQ(this.newDim);return`
      ${xt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function bQ(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let r=0;r<n.length;r++)t[n[r]]=`coords.${Ef(r)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _h(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];if(t.shouldExecuteOnCPU([s])){const h=o.tensorMap.get(s.dataId).values,f=nVe(h,s.shape,s.dtype,i,l);return t.makeTensorInfo(l,s.dtype,f)}if(s.shape.length===2&&Rn(i,[1,0])){const u=new pVe(s.shape,i);return o.runWebGPUProgram(u,[s],s.dtype)}const c=new mVe(s.shape,i);return o.runWebGPUProgram(c,[s],s.dtype)}const gVe={kernelName:Vd,backendName:"webgpu",kernelFunc:_h};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yVe{constructor(e,t,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=Qs(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${xt("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bVe={mean:"float32",all:"bool",any:"bool"};function Hy(n,e,t,r,s){const i=n.shape.length,o=[],a=An(e,n.shape);let l=a;const c=Lr(l,i);let u=n;c!=null&&(u=_h({inputs:{x:n},attrs:{perm:c},backend:s}),l=ns(l.length,i),o.push(u)),fi(r,l,i);const[h,f]=Qs(u.shape,l);let d=h;t&&(d=Ls(h,a));let p;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([u])){const m=s.tensorMap.get(u.dataId).values;switch(r){case"max":const g=z4e(m,Te(f),d,n.dtype);p=s.makeTensorInfo(d,n.dtype,g);break;case"prod":const{outVals:y,outShape:b,outDtype:x}=H4e(u.shape,u.dtype,m,l);p=s.makeTensorInfo(b,x,y);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const m=Te(f),y=Te(u.shape)/m,b={windowSize:m,inSize:m,batchSize:y,outSize:1},x=bVe[r]||G2(n.dtype),w=[{type:"int32",data:[m]}],S=new yVe(b,r,s.device.limits.maxComputeWorkgroupSizeX),C=s.runWebGPUProgram(S,[u],x,w);o.push(C),p=Kt({inputs:{x:C},attrs:{shape:d},backend:s})}return o.forEach(m=>s.disposeData(m.dataId)),p}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Hy(s,o,i,"all",t)}const wVe={kernelName:GS,backendName:"webgpu",kernelFunc:vVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Hy(s,o,i,"any",t)}const _Ve={kernelName:HS,backendName:"webgpu",kernelFunc:xVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vQ{constructor(e,t,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[t];this.op=r==="min"?"<":">";const[i,o]=Qs(e,s);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=Ot(this.outputShape),Te(o)<32?(this.type="plain",this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=_t(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Ef(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)s+=`outputCoords.${Ef(i)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${xt("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${xt("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=_h({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMax",[o[0]],l.shape.length);const u=new vQ(l.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const CVe={kernelName:Iv,backendName:"webgpu",kernelFunc:SVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=An(i,s.shape);const a=Lr(o,s.shape.length);let l=s;const c=[];a!=null&&(l=_h({inputs:{x:s},backend:t,attrs:{perm:a}}),c.push(l),o=ns(o.length,l.shape.length)),fi("argMin",[o[0]],l.shape.length);const u=new vQ(l.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=t.runWebGPUProgram(u,[l],"int32",h);return c.forEach(d=>t.disposeData(d.dataId)),f}const TVe={kernelName:Av,backendName:"webgpu",kernelFunc:kVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EVe=yr({opType:bt.ASIN}),IVe={kernelName:Lg,backendName:"webgpu",kernelFunc:EVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AVe=yr({opType:bt.ASINH}),MVe={kernelName:zg,backendName:"webgpu",kernelFunc:AVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NVe=yr({opType:bt.ATAN}),$Ve={kernelName:Bg,backendName:"webgpu",kernelFunc:NVe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RVe=Xi({opType:yn.ATAN2}),PVe={kernelName:Ug,backendName:"webgpu",kernelFunc:RVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DVe=yr({opType:bt.ATANH}),OVe={kernelName:Vg,backendName:"webgpu",kernelFunc:DVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FVe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N_{constructor(e,t,r=!1,s=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=i,this.shaderKey=`pool2D_${t}_${r}_${s}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class vB{constructor(e,t,r=!1,s=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=i,this.shaderKey=`pool3D_${t}_${r}_${s}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r;return Hy(s,i,o,"max",t)}const LVe={kernelName:ew,backendName:"webgpu",kernelFunc:wQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:i,axis:o}=r;return Hy(s,o,i,"mean",t)}const zVe={kernelName:rw,backendName:"webgpu",kernelFunc:xQ};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Q(n,e,t,r){if(e.filterWidth===1&&e.filterHeight===1&&Rn(e.inShape,e.outShape))return Ka({inputs:{x:n},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=Kt({inputs:{x:n},backend:r,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let l;t==="avg"?l=xQ({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(U(t==="max",()=>`Invalid pool type ${t}`),l=wQ({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const c=Kt({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(l.dataId),c}let s;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new FVe(e):(t==="avg"?s=new N_(e,"avg"):(U(t==="max",()=>`Invalid pool type ${t}`),s=new N_(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[n],n.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=ko(s.shape,i,o,c,a,l);return _Q(s,u,"avg",t)}const VVe={kernelName:Mv,backendName:"webgpu",kernelFunc:BVe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UVe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ol(s.shape,i,o,u,a,c,l),f=new vB(h,"avg"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[s],s.dtype,d)}const WVe={kernelName:Nv,backendName:"webgpu",kernelFunc:UVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class HVe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Ol(o.shape,a,l,1,c,u),f=new HVe(h),d=1/(h.filterDepth*h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(f,[s],o.dtype,p)}const qVe={kernelName:qS,backendName:"webgpu",kernelFunc:jVe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XVe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;gQ([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=ko(o.shape,a,l,1,c),h=new GVe(u),f=1/(u.filterHeight*u.filterWidth),d=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[f]}];return t.runWebGPUProgram(h,[s],o.dtype,d)}const KVe={kernelName:jS,backendName:"webgpu",kernelFunc:XVe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YVe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return FN({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const ZVe={kernelName:$v,backendName:"webgpu",kernelFunc:YVe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JVe{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ys(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ys(this.rank),t=QVe(this.rank);let r;return this.start.length===1?r=this.outputShape.map((i,o)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((i,o)=>`sourceLoc.${PD[o]} = uniforms.start.${Ef(o)} + coords.${PD[o]};`),`
      ${xt("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const PD=["x","y","z","w","u","v"];function QVe(n){if(n===1)return"sourceLoc";if(n<=6)return PD.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=lC(s,i,o);if(aN(s,a,l),t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.tensorMap.get(s.dataId),f=Y4e(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,f)}if(Te(l)===0)return t.makeTensorInfo(l,s.dtype,[]);const c=new JVe(a,l),u=[{type:"int32",data:a}];return t.runWebGPUProgram(c,[s],s.dtype,u)}const eUe={kernelName:vw,backendName:"webgpu",kernelFunc:Uw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tUe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;U(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=Oy(s.shape,i,a),c=Fy(l.length,i.length),u=Ly(s.shape,i,a),h=dN(o,i.length),f=pN(u,o,i.length),d=[],p=Kt({inputs:{x:s},backend:t,attrs:{shape:l}}),m=_h({inputs:{x:p},backend:t,attrs:{perm:c}}),g=Kt({inputs:{x:m},backend:t,attrs:{shape:u}}),y=Uw({inputs:{x:g},backend:t,attrs:{begin:h,size:f}});return d.push(p),d.push(m),d.push(g),d.forEach(b=>t.disposeData(b.dataId)),y},nUe={kernelName:Rv,backendName:"webgpu",kernelFunc:tUe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rUe=`
  fn bincount_write(index: i32, value: f32) {
    ${Pp("&result[index]","value","float32")}
  }
`,sUe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class SQ{constructor(e,t,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?sUe:rUe}
  ${xt("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=Te(s.shape),c=Te(i.shape)>0,u=[o],h=i.dtype,f=ba({backend:t,attrs:{shape:u,value:0,dtype:h}}),d=new SQ([a],c),p=[{type:"int32",data:[o]}],m=c?[s,i]:[s];return t.runWebGPUProgram(d,m,h,p,f)}const oUe={kernelName:XS,backendName:"webgpu",kernelFunc:iUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aUe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${xt("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lUe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e;if(t.shouldExecuteOnCPU([r,s])){const u=t.tensorMap.get(r.dataId),h=t.tensorMap.get(s.dataId),f=u.values,d=h.values,p=ln(Array.from(f),Array.from(d));return t.makeTensorInfo([p.length],"int32",Int32Array.from(p))}const i=Te(r.shape),o=Te(s.shape),a=Math.max(i,o),l=new aUe(a),c=[{type:"int32",data:[i]},{type:"int32",data:[o]}];return t.runWebGPUProgram(l,[r,s],"int32",c)}const cUe={kernelName:YS,backendName:"webgpu",kernelFunc:lUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CQ=Xi({opType:yn.NOT_EQUAL,dtype:"bool",cpuKernelImpl:G4e}),uUe={kernelName:aw,backendName:"webgpu",kernelFunc:CQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yC(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return Ka({inputs:{x:s.complexTensorInfos.real},backend:t})}const hUe={kernelName:T2,backendName:"webgpu",kernelFunc:yC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fUe(n,e){const t=new Vw(n.shape,bt.TO_INT),r=e.runWebGPUProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Ka({inputs:{x:s},backend:t});const o=ms(s.shape),a=DD({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=Gy({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),l}if(s.dtype==="complex64"){const o=yC({inputs:{input:s},backend:t}),a=DD({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeData(o.dataId),a}if(!wM(s.dtype,i)){const o=Ka({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.tensorMap.get(s.dataId).values,[a,l,c]=C4e(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,c)}if(i==="int32")return fUe(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",ci("bool",1)),l=CQ({inputs:{a:s,b:o},backend:t});return t.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const dUe={kernelName:Wg,backendName:"webgpu",kernelFunc:DD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pUe=yr({opType:bt.CEIL,cpuKernelImpl:k4e}),mUe={kernelName:Gg,backendName:"webgpu",kernelFunc:pUe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gUe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${xt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yUe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${xt("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;const l=[{type:"float32",data:[i]},{type:"float32",data:[o]}];return Te(s.shape)%4===0?a=new gUe(s.shape):a=new yUe(s.shape),t.runWebGPUProgram(a,[s],s.dtype,l)}const vUe={kernelName:Hg,backendName:"webgpu",kernelFunc:bUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wUe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function xUe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.tensorMap.get(r.dataId),i=new wUe(r.shape),o=[sH(r,s.complexTensorInfos.real),sH(r,s.complexTensorInfos.imag)];return t.runWebGPUProgram(i,o,o[0].dtype)}const _Ue={kernelName:Pv,backendName:"webgpu",kernelFunc:xUe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SUe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ya(e,1),this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${xt("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LN(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return Ka({inputs:{x:s.complexTensorInfos.imag},backend:t})}const CUe={kernelName:g2,backendName:"webgpu",kernelFunc:LN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(n,e,t){const r=n[0].dtype;if(r==="complex64"){const p=n.map(x=>yC({inputs:{input:x},backend:t})),m=n.map(x=>LN({inputs:{input:x},backend:t})),g=T1(p,e,t),y=T1(m,e,t),b=Gy({inputs:{real:g,imag:y},backend:t});return p.forEach(x=>t.disposeData(x.dataId)),m.forEach(x=>t.disposeData(x.dataId)),t.disposeData(g.dataId),t.disposeData(y.dataId),b}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const p=n.map(S=>{const k=[-1,Te(S.shape.slice(e))];return Kt({inputs:{x:S},backend:t,attrs:{shape:k}})}),m=p.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=ya(p.map(S=>S.shape),1),y=p[0].shape[0]===1,b=T4e(m,g,r,y),x=ya(n.map(S=>S.shape),e),w=t.makeTensorInfo(x,r,b);return p.forEach(S=>t.disposeData(S.dataId)),w}const i=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>i){const p=[];for(let g=0;g<n.length;g+=i){const y=n.slice(g,g+i);p.push(T1(y,e,t))}const m=T1(p,e,t);for(const g of p)t.disposeData(g.dataId);return m}const{tensors2D:o,outShape:a}=kUe(n,e,t),l=o.map(p=>p.shape),c=new SUe(l),u=[],h=new Array(l.length-1);if(h.length>0){h[0]=l[0][1],u.push({type:"int32",data:[h[0]]});for(let p=1;p<h.length;p++)h[p]=h[p-1]+l[p][1],u.push({type:"int32",data:[h[p]]})}const f=t.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach(p=>t.disposeData(p.dataId));const d=Kt({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),d}function kUe(n,e,t){const r=ya(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Kt({inputs:{x:i},backend:t,attrs:{shape:[Te(i.shape.slice(0,e)),Te(i.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kQ(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=An(s,e[0].shape)[0],o=e.map(c=>c.shape);uN(o,i);const a=ya(e.map(c=>c.shape),i);if(Te(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Te(c.shape)>0);return l.length===1?Ka({inputs:{x:l[0]},backend:t}):T1(l,i,t)}const TUe={kernelName:Dv,backendName:"webgpu",kernelFunc:kQ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EUe(n,e,t,r,s=!1,i=null,o=!1,a=4,l=4,c=4){const u=M=>{switch(M){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},h=M=>{switch(M){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${M} is not supported.`)}},f=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,p=n?"uniforms.xShape[1]":"uniforms.xShape[2]",m=n?"uniforms.xShape[2]":"uniforms.xShape[3]",g=n?"row":"col",y=n?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${y} % inChannels;
      var resData = ${Vn(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${m}) {
        ${f}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${u(a)}
      }
      return resData;`,x=n?e&&r?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${Vn(a)}(0.0);`:r&&t?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${Vn(a)}(0.0);`,w=`${h(l)}`,S=Vn(c),C=Vn(n?a:l),k=Vn(n?l:a);return`
      ${Hf(i,o,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${C} {
        ${n?x:w}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${k} {
        ${n?w:x}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${S}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${Wy(s,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class IUe{constructor(e,t,r,s,i=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=dQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=pQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=i,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?DN(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):ON(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${EUe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AUe{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=r,this.hasPreluActivationWeights=s,t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Hf(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Wy(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${xt("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MUe{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${xt("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function NUe({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.dataFormat==="channelsLast",c=!l,u=!1,h=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=[];let d,p;if(h){const y=t.inHeight*t.inWidth*t.inChannels;d=Kt({inputs:{x:n},backend:r,attrs:{shape:[1,t.batchSize,y]}}),p=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,y,t.outChannels]}})}else d=Kt({inputs:{x:n},backend:r,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),p=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(f.push(d),f.push(p),i!=null){const y=BI(i.shape,l);y!=null&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:y}}),f.push(i))}if(s!=null){const y=BI(s.shape,l);y!=null&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:y}}),f.push(s))}const m=FN({a:l?d:p,b:l?p:d,transposeA:c,transposeB:u,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),g=Kt({inputs:{x:m},backend:r,attrs:{shape:t.outShape}});f.push(m);for(const y of f)r.disposeData(y.dataId);return g}function $Ue({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:h,strideHeight:f,padInfo:d,outWidth:p,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:b}=t,x=b==="channelsLast",w=l*c*u,S=m*p,C=x?[t.batchSize,S,w]:[t.batchSize,w,S],k=new MUe(C,x),A=[{type:"int32",data:[d.top,d.left]},{type:"int32",data:[f,h]},{type:"int32",data:[y,g]},{type:"int32",data:[p]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],M=r.runWebGPUProgram(k,[n],n.dtype,A),E=[];E.push(M);const N=Kt({inputs:{x:e},backend:r,attrs:{shape:[1,w,-1]}});if(E.push(N),i!=null){const B=BI(i.shape,x);B!=null&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:B}}),E.push(i))}if(s!=null){const B=BI(s.shape,x);B!=null&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:B}}),E.push(s))}const D=FN({a:x?M:N,b:x?N:M,transposeA:!x,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),z=Kt({inputs:{x:D},backend:r,attrs:{shape:t.outShape}});E.push(D);for(const B of E)r.disposeData(B.dataId);return z}function TQ({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=s!=null,c=i!=null,u=t.dataFormat==="channelsLast",h=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",f=Ee().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!f&&(h||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return NUe({x:n,filter:e,convInfo:t,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});const d=Ee().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),p=d>-1?d:r.thresholdToIncreaseWorkgroups,m=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(Ee().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||m<=p)return $Ue({x:n,filter:e,convInfo:t,backend:r,bias:s,preluActivationWeights:i,leakyreluAlpha:o,activation:a});let g;const y=[t.padInfo.top,t.padInfo.left],b=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...y]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(f)g=new AUe(t,l,a,c);else{const C=u?t.outHeight*t.outWidth:t.outChannels,k=u?t.outChannels:t.outHeight*t.outWidth,A=t.filterHeight*t.filterWidth*t.inChannels;b.push({type:"int32",data:[C]},{type:"int32",data:[k]},{type:"int32",data:[A]});const M=r.adapterInfo.isIntel();g=new IUe(t,C,k,A,l,a,c,M)}const x=[],w=[n,e];l&&(!u&&s.shape.length===1&&(s=Kt({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),x.push(s)),w.push(s)),c&&(!u&&i.shape.length===1&&(i=Kt({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),x.push(i)),w.push(i)),a==="leakyrelu"&&(b.push({type:"float32",data:[o]}),g.uniforms+=" alpha : f32,");const S=r.runWebGPUProgram(g,w,n.dtype,b);for(const C of x)r.disposeData(C.dataId);return S}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RUe(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=t,h=el(l),f=ts(s.shape,i.shape,o,c,a,u,!1,h);return TQ({x:s,filter:i,convInfo:f,backend:r})}const PUe={kernelName:Ov,backendName:"webgpu",kernelFunc:RUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DUe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${xt()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class OUe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class FUe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class LUe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${xt("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,h=el(l),f=ts(s.shape,u,o,1,a,c,!1,h),d=new OUe(f),p=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]}];return t.runWebGPUProgram(d,[s,i],s.dtype,p)}const BUe={kernelName:JS,backendName:"webgpu",kernelFunc:zUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VUe(n=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Vn(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Vn(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${Vn(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Vn(n)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Vn(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${Vn(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Vn(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class UUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=dQ(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=pQ(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?DN(this.elementsPerThread,this.workgroupSize):ON(this.elementsPerThread,this.workgroupSize);return`
    ${VUe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,h=el(c),f=ts(o,i.shape,a,1,l,u,!1,h),d=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let p;if(Ee().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.dataFormat!=="channelsLast")p=new DUe(f);else{p=new UUe(f);const m=f.inHeight*f.inWidth,g=f.inChannels,y=f.filterHeight*f.filterWidth*f.outChannels;d.push({type:"uint32",data:[m]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return t.runWebGPUProgram(p,[s,i],"float32",d)}const GUe={kernelName:Fv,backendName:"webgpu",kernelFunc:WUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HUe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Ou(s.shape,i.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],f=new HUe(c),d=Mi(s.dtype,i.dtype);return t.runWebGPUProgram(f,[s,i],d,h)}const qUe={kernelName:Lv,backendName:"webgpu",kernelFunc:jUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XUe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,c=Ou(s.shape,l,o,1,a),u=new FUe(c),h=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(u,[s,i],i.dtype,h)}const KUe={kernelName:QS,backendName:"webgpu",kernelFunc:XUe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YUe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,pad:a,inputShape:l}=r,c=Ou(l,i.shape,o,1,a),u=new LUe(c),h=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(u,[s,i],s.dtype,h)}const ZUe={kernelName:e2,backendName:"webgpu",kernelFunc:YUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JUe=yr({opType:bt.COS}),QUe={kernelName:jg,backendName:"webgpu",kernelFunc:JUe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eWe=yr({opType:bt.COSH}),tWe={kernelName:qg,backendName:"webgpu",kernelFunc:eWe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nWe{constructor(e,t,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,r[0],r[1],e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rWe=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new nWe(s.shape[3],i.shape,a,l),h=[{type:"float32",data:[c]}];return t.runWebGPUProgram(u,[s,i,o],"float32",h)},sWe={kernelName:n2,backendName:"webgpu",kernelFunc:rWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $_;(function(n){n.Prod="*",n.Sum="+"})($_||($_={}));class iH{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===$_.Prod?"1.0":"0.0",r=this.exclusive?t:`getX(${oH(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let i="",o="";return this.exclusive?(i=this.reverse?`end != ${s-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${s}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${xt("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${aH(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${o};
           ${aH(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${oH(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function oH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function aH(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EQ(n,e,t,r,s,i){const o=e.shape.length,a=Lr([r],o);let l=e;a!=null&&(l=_h({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=ns(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let h=Ka({inputs:{x:l},backend:t});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const d=new iH(n,l.shape,!1,i),p=h,m=[{type:"float32",data:[f]}];h=t.runWebGPUProgram(d,[h],h.dtype,m),t.disposeData(p.dataId)}if(s){const f=new iH(n,l.shape,s,i),d=h,p=[{type:"float32",data:[0]}];h=t.runWebGPUProgram(f,[h],h.dtype,p),t.disposeData(d.dataId)}if(a!=null){const f=Mh(a),d=_h({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeData(h.dataId),t.disposeData(l.dataId),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return EQ($_.Prod,s,t,i,o,a)}const oWe={kernelName:t2,backendName:"webgpu",kernelFunc:iWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return EQ($_.Sum,s,t,i,o,a)}const lWe={kernelName:zv,backendName:"webgpu",kernelFunc:aWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r,l=s.shape.length===1,u=Te(i.shape)>0,h=i.dtype,f=l?[s.shape[0]]:[s.shape[0],s.shape[1]],d=l?[o]:[s.shape[0],o],p=ba({backend:t,attrs:{shape:d,value:0,dtype:h}}),m=new SQ(f,u,a),g=[{type:"int32",data:[o]}],y=u?[s,i]:[s];return t.runWebGPUProgram(m,y,h,g,p)}const uWe={kernelName:r2,backendName:"webgpu",kernelFunc:cWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hWe{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],c=o==="NHWC"?s.shape[2]:s.shape[3],u=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,f=c*i,d=u/(i*i),p=o==="NHWC"?[a,h,f,d]:[a,d,h,f],m=[{type:"int32",data:[i]}],g=new hWe(p,o);return t.runWebGPUProgram(g,[s],s.dtype,m)}const dWe={kernelName:s2,backendName:"webgpu",kernelFunc:fWe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pWe{constructor(e,t,r,s=!1,i=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=i,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Hf(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${xt()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Wy(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IQ{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Ot(i),this.dispatch=_t(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),U(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${Hf(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${xt("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Wy(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AQ{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Hf(this.activation,this.hasPreluActivation,!1,4)}

      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Wy(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,h=el(l);let f=c;f==null&&(f=[1,1]);const d=ts(s.shape,i.shape,o,f,a,u,!0,h),p=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],m=d.dataFormat==="channelsLast";let g;return!m&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new pWe(d.outShape,d.filterHeight,d.filterWidth):m&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?(g=new IQ(d),p.push({type:"int32",data:[g.virtualWidth]})):(g=new AQ(d),p.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(g,[s,i],s.dtype,p)}const gWe={kernelName:Bv,backendName:"webgpu",kernelFunc:mWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yWe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class bWe{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,h=ts(s.shape,u,o,a,l,c,!0),f=new yWe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[s,i],"float32",d)}const wWe={kernelName:i2,backendName:"webgpu",kernelFunc:vWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xWe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,h=ts(u,i.shape,o,a,l,c,!0),f=new bWe(h),d=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return t.runWebGPUProgram(f,[s,i],s.dtype,d)}const _We={kernelName:o2,backendName:"webgpu",kernelFunc:xWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SWe{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CWe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Te(r.shape),o=Kt({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new SWe(i),l=t.runWebGPUProgram(a,[o],o.dtype),c=Kt({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const kWe={kernelName:a2,backendName:"webgpu",kernelFunc:CWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TWe{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${xt("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,c=Ap(s.shape,i.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],h=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],f=new TWe(c);return t.runWebGPUProgram(f,[s,i],s.dtype,h)}const IWe={kernelName:Vv,backendName:"webgpu",kernelFunc:EWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AWe{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(e.outShape),this.dispatch=_t(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${xt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Pp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class MWe{constructor(e,t,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ot(e.outShape),this.dispatch=_t(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${xt("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Pp("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=Ap(s.shape,i.shape,a,l,"NHWC",c),h=i.dtype,f=new MWe(u,i.shape,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Te(u.outShape)]}],p=ba({backend:t,attrs:{shape:i.shape,value:0,dtype:h}});return t.runWebGPUProgram(f,[s,i,o],h,d,p)}const $We={kernelName:m_,backendName:"webgpu",kernelFunc:NWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RWe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,dy:o}=e,{strides:a,pad:l,dilations:c}=r,u=Ap(s.shape,i.shape,a,l,"NHWC",c),h=s.dtype,f=new AWe(u,h),d=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Te(u.outShape)]}],p=ba({backend:t,attrs:{shape:u.inShape,value:0,dtype:h}});return t.runWebGPUProgram(f,[s,i,o],h,d,p)}const PWe={kernelName:p_,backendName:"webgpu",kernelFunc:RWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DWe{constructor(e,t,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=nv.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=r,this.shaderKey=`draw_${t}_${r}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${xt("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OWe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,[a,l]=s.shape.slice(0,2),{imageOptions:c}=o||{},u=(c==null?void 0:c.alpha)||1,h=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",f=[a,l],d=new DWe(f,s.dtype,h);i.width=l,i.height=a;const p="webgpu";let m=i.getContext(p),g;m||(g=new OffscreenCanvas(l,a),m=g.getContext(p));const y=s.shape.length===3?s.shape[2]:1;m.configure({device:t.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",x=t.makeTensorInfo(f,b),w=t.tensorMap.get(x.dataId);w.resource=m.getCurrentTexture(),w.external=!0;const S=[{type:"uint32",data:[y]},{type:"float32",data:[u]}];if(t.runWebGPUProgram(d,[s],b,S,x),g){const C=i.getContext("2d");if(!C)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");C.drawImage(g,0,0)}return t.disposeData(x.dataId),s}const FWe={kernelName:l2,backendName:"webgpu",kernelFunc:OWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MQ=Xi({opType:yn.MUL,cpuKernelImpl:U4e,supportsComplex:!0}),LWe={kernelName:hy,backendName:"webgpu",kernelFunc:MQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Hy(s,i,o,"sum",t)}const zWe={kernelName:ww,backendName:"webgpu",kernelFunc:NQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BWe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=xN(s,i.length);SN(o.length,l,i);const{path:c,steps:u}=CN(a,l),h=u.length;let f=null,d=o.length;const p=[];for(let m=0;m<h;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=_N(d,l[g]);let x;kN(y)?x=i[g]:(x=_h({inputs:{x:i[g]},backend:t,attrs:{perm:y}}),p.push(x));const w=x.shape.slice();for(let S=0;S<b.length;++S)w.splice(b[S],0,1);Rn(x.shape,w)||(x=Kt({inputs:{x},backend:t,attrs:{shape:w}}),p.push(x)),f===null?f=x:(f=MQ({inputs:{a:x,b:f},backend:t}),p.push(f))}m<h-1&&(c[m]>=0&&(f=NQ({inputs:{x:f},backend:t,attrs:{axis:c[m]-(o.length-d),keepDims:!1}}),p.push(f)),d--)}for(const m of p)m!==f&&t.disposeData(m.dataId);return f}const VWe={kernelName:c2,backendName:"webgpu",kernelFunc:BWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UWe=yr({opType:bt.ELU}),WWe={kernelName:Kg,backendName:"webgpu",kernelFunc:UWe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GWe=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=new zI(yn.ELU_DER,r.shape,s.shape);return t.runWebGPUProgram(i,[r,s],r.dtype)},HWe={kernelName:u2,backendName:"webgpu",kernelFunc:GWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jWe=Xi({opType:yn.EQUAL,dtype:"bool",cpuKernelImpl:E4e}),qWe={kernelName:Uv,backendName:"webgpu",kernelFunc:jWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XWe=yr({opType:bt.ERF}),KWe={kernelName:Yg,backendName:"webgpu",kernelFunc:XWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YWe=yr({opType:bt.EXP,cpuKernelImpl:I4e,dtype:"float32"}),ZWe={kernelName:Zg,backendName:"webgpu",kernelFunc:YWe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OD(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(U(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),Kt({inputs:{x:i},backend:r,attrs:{shape:a}})}const JWe={kernelName:Wv,backendName:"webgpu",kernelFunc:OD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QWe=yr({opType:bt.EXPM1,cpuKernelImpl:A4e}),eGe={kernelName:Jg,backendName:"webgpu",kernelFunc:QWe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lH{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Q(n,e,t){const r=t.tensorMap.get(n.dataId),s=Te(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=[],l=Kt({inputs:{x:n},backend:t,attrs:{shape:[o,i]}});a.push(l);const c=l.shape,u=new lH("real",c),h=new lH("imag",c),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=e?2*Math.PI:-2*Math.PI,p=e?c[1]:1,m=[{type:"float32",data:[d]},{type:"float32",data:[p]}],g=t.runWebGPUProgram(u,f,"float32",m);a.push(g);const y=t.runWebGPUProgram(h,f,"float32",m);a.push(y);const b=Gy({inputs:{real:g,imag:y},backend:t});a.push(b);const x=Kt({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return a.forEach(w=>t.disposeData(w.dataId)),x}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tGe(n){const{inputs:e,backend:t}=n,{input:r}=e;return $Q(r,!1,t)}const nGe={kernelName:h2,backendName:"webgpu",kernelFunc:tGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rGe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sGe={kernelName:d2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new rGe(t.shape);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iGe=yr({opType:bt.FLOOR,cpuKernelImpl:M4e}),oGe={kernelName:Qg,backendName:"webgpu",kernelFunc:iGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aGe=Xi({opType:yn.FLOOR_DIV,cpuKernelImpl:N4e,dtype:"int32"}),lGe={kernelName:ey,backendName:"webgpu",kernelFunc:aGe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cGe{constructor(e,t,r=!1){this.pixelsOpType=nv.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${xt("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uGe={kernelName:g_,backendName:"webgpu",kernelFunc:hGe};let A0,p3=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function hGe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[u,h]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],f=[h,u,i],d=Ee().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,p=o||a;if(c||l||p){let b;if(d)b=t.device.importExternalTexture({source:s});else{if(p){const R=Ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(A0==null||R!==p3)&&(p3=R,A0=document.createElement("canvas").getContext("2d",{willReadFrequently:p3})),A0.canvas.width=u,A0.canvas.height=h,A0.drawImage(s,0,0,u,h),s=A0.canvas}const E=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,N="rgba8unorm",O=t.textureManager.acquireTexture(f[1],f[0],N,E);t.queue.copyExternalImageToTexture({source:s},{texture:O},[f[1],f[0]]),b=O}const x=Te(f),w=Jt(f),S=new cGe(f,i,d),C=[{type:"uint32",data:[x]},{type:"uint32",data:[i]},{type:"uint32",data:[...w]}],k=t.makeTensorInfo([h,u],"int32"),A=t.tensorMap.get(k.dataId);A.resource=b;const M=t.runWebGPUProgram(S,[k],"int32",C);return t.disposeData(k.dataId),M}const m=s.data;let g=m;if(i!=null&&i!==4){g=new Uint8Array(s.width*s.height*i);const b=m.length;let x=0;for(let w=0;w<b;w++)w%4<i&&(g[x++]=m[w])}const y=t.makeTensorInfo(f,"int32",new Int32Array(g));return t.uploadToGPU(y.dataId),y}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fGe{constructor(e,t,r,s,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ln(e,t),ln(e,r),this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(ln(e,s),this.variableNames.push("offset")),i!=null&&(ln(e,i),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${xt("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dGe={kernelName:Gv,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r,scale:s,offset:i,mean:o,variance:a}=n,{varianceEpsilon:l}=e,c=t,u=[r,o,a];let h=null;i!=null&&(h=i.shape,u.push(i));let f=null;s!=null&&(f=s.shape,u.push(s));const d=new fGe(r.shape,o.shape,a.shape,h,f),p=[{type:"float32",data:[l]}];return c.runWebGPUProgram(d,u,r.dtype,p)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:f,activation:d,leakyreluAlpha:p}=r,m=el(u),g=ts(s.shape,i.shape,l,h,c,f,!1,m);return TQ({x:s,filter:i,convInfo:g,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:p,activation:d})}const mGe={kernelName:Ub,backendName:"webgpu",kernelFunc:pGe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:f,leakyreluAlpha:d}=r;let p=u;p==null&&(p=[1,1]),U(Ri(l,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${p}'`);const m=ts(s.shape,i.shape,l,p,c,h,!0),g=[s,i],y=o!=null,b=a!=null;y&&g.push(o),b&&g.push(a);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let w;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&m.dilationHeight===1&&m.dilationWidth===1&&m.inChannels%4===0?(w=new IQ(m,y,f,b),x.push({type:"int32",data:[w.virtualWidth]})):(w=new AQ(m,y,f,b),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),f==="leakyrelu"&&(x.push({type:"float32",data:[d]}),w.uniforms+=" alpha : f32,"),t.runWebGPUProgram(w,g,"float32",x)}const yGe={kernelName:Wb,backendName:"webgpu",kernelFunc:gGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bGe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ys(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vGe(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Te(r.shape),[l,c,u,h]=aC(r,s),f=Kt({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),d=Kt({inputs:{x:r},backend:t,attrs:{shape:[Te(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const b=t.readSync(s.dataId),x=t.bufferSync(r),w=$4e(b,x,r.dtype,c,o,u,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,w.values)}const p=new bGe(o,[c,u]),m=[{type:"int32",data:[o]},{type:"int32",data:h}],g=t.runWebGPUProgram(p,[d,f],d.dtype,m),y=Kt({inputs:{x:g},backend:t,attrs:{shape:l}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),y}const wGe={kernelName:p2,backendName:"webgpu",kernelFunc:vGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xGe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=_Ge(this.aShape);return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function _Ge(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let r=0;r<n.length;r++)r===2?t.push("indexZ"):t.push(`${e[r]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=An(o,s.shape)[0],c=EN(s,i,l,a),u=Te(i.shape),h=[],f=Kt({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=Kt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(f),h.push(d);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([s,i])){const x=t.tensorMap.get(d.dataId).values,w=Sn(d.shape,d.dtype,x),C=t.tensorMap.get(f.dataId).values,k=Sn(f.shape,f.dtype,C),A=R4e(k,w,p);return h.forEach(M=>t.disposeData(M.dataId)),t.makeTensorInfo(c.outputShape,A.dtype,A.values)}const m=new xGe(f.shape,p),g=t.runWebGPUProgram(m,[f,d],f.dtype);h.push(g);const y=Kt({inputs:{x:g},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeData(b.dataId)),y}const SGe={kernelName:Hv,backendName:"webgpu",kernelFunc:RQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CGe=Xi({opType:yn.GREATER,cpuKernelImpl:D4e,dtype:"bool"}),kGe={kernelName:jv,backendName:"webgpu",kernelFunc:CGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TGe=Xi({opType:yn.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:P4e}),EGe={kernelName:ty,backendName:"webgpu",kernelFunc:TGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IGe(n){const{inputs:e,backend:t}=n,{input:r}=e;return $Q(r,!0,t)}const AGe={kernelName:m2,backendName:"webgpu",kernelFunc:IGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MGe=yr({opType:bt.IS_FINITE,dtype:"bool"}),NGe={kernelName:ry,backendName:"webgpu",kernelFunc:MGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ge=yr({opType:bt.IS_INF,dtype:"bool"}),RGe={kernelName:sy,backendName:"webgpu",kernelFunc:$Ge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PGe=yr({opType:bt.IS_NAN,dtype:"bool"}),DGe={kernelName:iy,backendName:"webgpu",kernelFunc:PGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OGe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=[{type:"float32",data:[i]}],a=new Vw(s.shape,bt.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[s],"float32",o)}const FGe={kernelName:qv,backendName:"webgpu",kernelFunc:OGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LGe=Xi({opType:yn.LESS,dtype:"bool",cpuKernelImpl:F4e}),zGe={kernelName:Xv,backendName:"webgpu",kernelFunc:LGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BGe=Xi({opType:yn.LESS_EQUAL,dtype:"bool",cpuKernelImpl:O4e}),VGe={kernelName:Kv,backendName:"webgpu",kernelFunc:BGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UGe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WGe(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=(s-r)/(i-1),a=new UGe(i),l=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const GGe={kernelName:y2,backendName:"webgpu",kernelFunc:WGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HGe=yr({opType:bt.LOG,cpuKernelImpl:L4e}),jGe={kernelName:oy,backendName:"webgpu",kernelFunc:HGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qGe=yr({opType:bt.LOG1P}),XGe={kernelName:ay,backendName:"webgpu",kernelFunc:qGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KGe=Xi({opType:yn.LOGICAL_AND,dtype:"bool"}),YGe={kernelName:Yv,backendName:"webgpu",kernelFunc:KGe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZGe=yr({opType:bt.LOGICAL_NOT}),JGe={kernelName:Zv,backendName:"webgpu",kernelFunc:ZGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QGe=Xi({opType:yn.LOGICAL_OR}),eHe={kernelName:Jv,backendName:"webgpu",kernelFunc:QGe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PQ=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class tHe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${PQ}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class nHe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,U(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_t(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${xt()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${PQ}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;let c;i>16?c=new tHe(s.shape):c=new nHe(s.shape,i);const u=[{type:"int32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[s],s.dtype,u)}const sHe={kernelName:Qv,backendName:"webgpu",kernelFunc:rHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iHe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,h=new iHe(s.shape),f=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return t.runWebGPUProgram(h,[s,i,o],s.dtype,f)}const aHe={kernelName:b2,backendName:"webgpu",kernelFunc:oHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lHe=Xi({opType:yn.MAX,cpuKernelImpl:B4e}),cHe={kernelName:ly,backendName:"webgpu",kernelFunc:lHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,c=1,u=ko(s.shape,i,o,c,a,l);return _Q(s,u,"max",t)}const hHe={kernelName:tw,backendName:"webgpu",kernelFunc:uHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fHe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],h=Ol(s.shape,i,o,u,a,c,l),f=new vB(h,"max"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return t.runWebGPUProgram(f,[s],s.dtype,d)}const dHe={kernelName:nw,backendName:"webgpu",kernelFunc:fHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pHe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class mHe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gHe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=[1,1,1],f=Ol(o.shape,a,l,h,c,u),d=new vB(f,"max",!0);let p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.front,f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inDepth,f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[o],"int32",p),g=new mHe(f);p=[{type:"int32",data:[f.strideDepth,f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterDepth-1-f.padInfo.front,f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.effectiveFilterDepth,f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outDepth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[s,m],o.dtype,p);return t.disposeData(m.dataId),y}const yHe={kernelName:w2,backendName:"webgpu",kernelFunc:gHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bHe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;gQ([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=r,f=ko(a.shape,l,c,1,u,h),d=new N_(f,"max",!0);let p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]}];const m=t.runWebGPUProgram(d,[a],"int32",p),g=new pHe(f);p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]}];const y=t.runWebGPUProgram(g,[s,m],a.dtype,p);return t.disposeData(m.dataId),y}const vHe={kernelName:v2,backendName:"webgpu",kernelFunc:bHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wHe(n){const{inputs:e,backend:t,attrs:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=r,{x:l}=e;U(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];U(Ri(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=ko(l.shape,s,i,c,o),h=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let f=new N_(u,"max",!1);const d=t.runWebGPUProgram(f,[l],l.dtype,h);f=new N_(u,"max",!0,!0,a);const p=t.runWebGPUProgram(f,[l],"int32",h);return[d,p]}const xHe={kernelName:x2,backendName:"webgpu",kernelFunc:wHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _He(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Hy(s,i,o,"min",t)}const SHe={kernelName:sw,backendName:"webgpu",kernelFunc:_He};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CHe=Xi({opType:yn.MIN,cpuKernelImpl:V4e}),kHe={kernelName:cy,backendName:"webgpu",kernelFunc:CHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class THe{constructor(e,t,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,i)=>s[0]+e[i]+s[1]),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,u)=>`uniforms.pad${u}[0]`).join(","),r=this.xShape.map((c,u)=>`uniforms.pad${u}[0] + uniforms.xShape${e>1?`[${u}]`:""}`).join(","),s=e===1?"start":"start[i]",i=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=Ys(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${s}) {
              ${o} = ${s} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${i}) {
              ${o} = (${i} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EHe={kernelName:iw,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=t,a=s.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new THe(r.shape,s,i);return o.runWebGPUProgram(l,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IHe=Xi({opType:yn.MOD}),AHe={kernelName:uy,backendName:"webgpu",kernelFunc:IHe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MHe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${xt("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NHe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${xt("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQ(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=Kt({inputs:{x:s},backend:t,attrs:{shape:[Te(s.shape)/s.shape[i],s.shape[i]]}}),a=new NHe(o.shape),l=t.runWebGPUProgram(a,[o],s.dtype),c=Kt({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const $He={kernelName:Sw,backendName:"webgpu",kernelFunc:DQ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RHe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:DQ({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new MHe(c,i),f=[{type:"float32",data:[o]},{type:"int32",data:[u]}],d=t.runWebGPUProgram(h,[l],"int32",f);return a||t.disposeData(l.dataId),d}const PHe={kernelName:_2,backendName:"webgpu",kernelFunc:RHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DHe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.tensorMap.get(r.dataId),[o,a]=W4e(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}const s=new Vw(r.shape,bt.NEG);return t.runWebGPUProgram(s,[r],r.dtype)}const OHe={kernelName:ow,backendName:"webgpu",kernelFunc:DHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FHe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=t.readSync(s.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=rC(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const LHe={kernelName:S2,backendName:"webgpu",kernelFunc:FHe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zHe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=t.readSync(s.dataId),h=t.readSync(i.dataId),f=o,d=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=sC(u,h,f,d,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const BHe={kernelName:C2,backendName:"webgpu",kernelFunc:zHe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VHe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${xt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UHe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=Te(s.shape),u=new VHe(c,o),h=Kt({inputs:{x:s},backend:t,attrs:{shape:[c]}}),f=[{type:"float32",data:[a]},{type:"float32",data:[l]}],d=t.runWebGPUProgram(u,[h],i,f);t.disposeData(h.dataId);const p=[...s.shape,o],m=Kt({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeData(d.dataId),m}const WHe={kernelName:cw,backendName:"webgpu",kernelFunc:UHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=yC({inputs:{input:r},backend:t}),i=VI({inputs:{x:s},backend:t}),o=LN({inputs:{input:r},backend:t}),a=VI({inputs:{x:o},backend:t}),l=Gy({inputs:{real:i,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return ba({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const GHe={kernelName:Tw,backendName:"webgpu",kernelFunc:VI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OQ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=yC({inputs:{input:r},backend:t}),i=OQ({inputs:{x:s},backend:t}),o=LN({inputs:{input:r},backend:t}),a=VI({inputs:{x:o},backend:t}),l=Gy({inputs:{real:i,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return ba({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const HHe={kernelName:lw,backendName:"webgpu",kernelFunc:OQ};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jHe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return OD({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{qi(i,u.shape,"All tensors passed to stack must have matching shapes"),U(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=OD({inputs:{input:u},backend:t,attrs:{dim:s}});return a.push(h),h}),c=kQ({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(u=>t.disposeData(u.dataId)),c}const qHe={kernelName:uw,backendName:"webgpu",kernelFunc:jHe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FQ(n,e=!1){const t=n.length,r=Ys(t),s=n.map((h,f)=>`uniforms.pad${f}[0]`).join(","),i=n.map((h,f)=>`uniforms.pad${f}[0] + uniforms.xShape${t>1?`[${f}]`:""}`).join(","),o=t>1?`${r}(${s})`:`${s}`,a=t>1?`${r}(${i})`:`${i}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${u}));
        }
  `}class XHe{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${FQ(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KHe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(i.every(c=>Rn(c,[0,0])))return Ka({inputs:{x:s},backend:t});if(Te(s.shape)===0){const c=i.map((u,h)=>u[0]+s.shape[h]+u[1]);return ba({backend:t,attrs:{shape:c,value:o,dtype:s.dtype}})}const a=[{type:"float32",data:[o]}];i.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new XHe(s.shape,i);return t.runWebGPUProgram(l,[s],s.dtype,a)},YHe={kernelName:hw,backendName:"webgpu",kernelFunc:KHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZHe=Xi({opType:yn.POW}),JHe={kernelName:fy,backendName:"webgpu",kernelFunc:ZHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QHe(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=new zI(yn.PRELU,r.shape,s.shape);return t.runWebGPUProgram(i,[r,s],"float32")}const e6e={kernelName:fw,backendName:"webgpu",kernelFunc:QHe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return Hy(s,i,o,"prod",t)}const n6e={kernelName:dw,backendName:"webgpu",kernelFunc:t6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r6e=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=j4e(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},s6e={kernelName:k2,backendName:"webgpu",kernelFunc:r6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i6e=Xi({opType:yn.DIV}),o6e={kernelName:Xg,backendName:"webgpu",kernelFunc:i6e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a6e=yr({opType:bt.RECIPROCAL}),l6e={kernelName:dy,backendName:"webgpu",kernelFunc:a6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c6e=yr({opType:bt.RELU}),u6e={kernelName:py,backendName:"webgpu",kernelFunc:c6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h6e=yr({opType:bt.RELU6}),f6e={kernelName:my,backendName:"webgpu",kernelFunc:h6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d6e{constructor(e,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,size:o,halfPixelCenters:a}=r,[l,c]=o,u=i&&l>1?1:0,h=i&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[a?.5:0]}],p=new d6e(s.shape,l,c);return t.runWebGPUProgram(p,[s],"float32",d)}const m6e={kernelName:gw,backendName:"webgpu",kernelFunc:p6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g6e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,[,a,l]=s.shape,[,c,u]=i.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,x=new g6e(s.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[d]},{type:"float32",data:[p]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(x,[i],i.dtype,w)}const b6e={kernelName:I2,backendName:"webgpu",kernelFunc:y6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v6e{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=i&&l>1?1:0,h=i&&c>1?1:0,d=[{type:"float32",data:[u,h]},{type:"float32",data:[i?.5:0]}],p=new v6e(s.shape,l,c,o);return t.runWebGPUProgram(p,[s],s.dtype,d)}const x6e={kernelName:mw,backendName:"webgpu",kernelFunc:w6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _6e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S6e(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,[,a,l]=s.shape,[,c,u]=i.shape,h=[o&&c>1?a-1:a,o&&u>1?l-1:l],f=[o&&c>1?c-1:c,o&&u>1?u-1:u],d=h[0]/f[0],p=h[1]/f[1],m=1/d,g=1/p,y=Math.ceil(m)*2+2,b=Math.ceil(g)*2+2,x=new _6e(s.shape,o),w=[{type:"int32",data:h},{type:"int32",data:f},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return t.runWebGPUProgram(x,[i],i.dtype,w)}const C6e={kernelName:E2,backendName:"webgpu",kernelFunc:S6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k6e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length;if(o===0)return Ka({inputs:{x:s},backend:t});const a=s.shape,l=[1,1,1,1];a.forEach((g,y)=>{const b=y+4-o;l[b]=g});const c=An(i,s.shape),u=[0,0,0,0];c.forEach(g=>{const y=g+4-o;u[y]=1});const h=[{type:"int32",data:u}],f=Kt({inputs:{x:s},backend:t,attrs:{shape:l}}),d=new k6e(l),p=t.runWebGPUProgram(d,[f],f.dtype,h);t.disposeData(f.dataId);const m=Kt({inputs:{x:p},backend:t,attrs:{shape:a}});return t.disposeData(p.dataId),m}const E6e={kernelName:yw,backendName:"webgpu",kernelFunc:T6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I6e{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${xt("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A6e={kernelName:V2,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new I6e(r.shape,i),[c,u]=fN(o,r.shape[1],r.shape[2]),h=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof i=="number"?h.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):h.push({type:"float32",data:i}),a.runWebGPUProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M6e=yr({opType:bt.ROUND}),N6e={kernelName:gy,backendName:"webgpu",kernelFunc:M6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $6e=yr({opType:bt.RSQRT,cpuKernelImpl:q4e}),R6e={kernelName:yy,backendName:"webgpu",kernelFunc:$6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y1{constructor(e,t,r,s,i,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=Ot(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${l}_${i.length}`;const c=Ys(i.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",i="";this.dispatchLayout.x.length===1?(s="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,u)=>`coords[${u}]`).join(", ")})`;return`
    ${i}
      ${xt("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${Rm(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?Pp("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P6e(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(i,s,o),f=[h/c,c];if(h===0)return t.makeTensorInfo(o,s.dtype);const d=Kt({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=Kt({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=p.dtype,g=ba({backend:t,attrs:{shape:f,value:0,dtype:m}}),y=Te(p.shape),b=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[y]}],x=new Y1(p.shape,a,d.shape.length,p.shape.length,u,f,m),w=t.runWebGPUProgram(x,[p,d],m,b,g),S=Kt({inputs:{x:w},backend:t,attrs:{shape:o}});return t.disposeData(d.dataId),t.disposeData(p.dataId),t.disposeData(w.dataId),S}const D6e={kernelName:A2,backendName:"webgpu",kernelFunc:P6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O6e{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${xt("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6e(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new O6e([i.shape[0],i.shape[1]],o),l=[{type:"int32",data:[s.shape[1]]}];return t.runWebGPUProgram(a,[s,i],"int32",l)}const L6e={kernelName:N2,backendName:"webgpu",kernelFunc:F6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z6e{constructor(e,t,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${s[a]}`),a<this.cRank&&i.push(`${s[a]}`);e=i.join(),t=o.join()}return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6e(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new z6e(r.shape.length,s.shape,s.shape.length);return t.runWebGPUProgram(o,[r,s,i],Mi(s.dtype,i.dtype))}const V6e={kernelName:bw,backendName:"webgpu",kernelFunc:B6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U6e=yr({opType:bt.SELU}),W6e={kernelName:by,backendName:"webgpu",kernelFunc:U6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G6e=yr({opType:bt.SIGMOID}),H6e={kernelName:_y,backendName:"webgpu",kernelFunc:G6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j6e=yr({opType:bt.SIGN}),q6e={kernelName:xy,backendName:"webgpu",kernelFunc:j6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X6e=yr({opType:bt.SIN}),K6e={kernelName:vy,backendName:"webgpu",kernelFunc:X6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y6e=yr({opType:bt.SINH}),Z6e={kernelName:wy,backendName:"webgpu",kernelFunc:Y6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J6e=yr({opType:bt.SOFTPLUS}),Q6e={kernelName:Sy,backendName:"webgpu",kernelFunc:J6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e5e{constructor(e,t,r,s,i,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let l=0;l<a.length;l++)a[l]=s[i[l]];this.outputShape=a,this.newDim=i,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Ys(s.length)}, paddedXShapeStrides : ${Ys(o)}, `,r.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Ys(this.outputShape.length),t=bQ(this.newDim);return`
      ${PE(this.paddedXShape,"PaddedX")}
      ${xt("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${FQ(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t5e=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;U(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=i.reduce((b,x)=>b*x),l=[[0,0]];l.push(...o);for(let b=1+i.length;b<s.shape.length;++b)l.push([0,0]);const c=l.map((b,x)=>b[0]+s.shape[x]+b[1]),u=Oy(c,i,a,!1),h=Fy(u.length,i.length,!1),f=Ly(c,i,a,!1),d=Jt(c),p=new e5e(s.shape,c,l,u,h,d.length),m=[{type:"int32",data:u},{type:"int32",data:d}];l.map(b=>m.push({type:"int32",data:[b[0],b[1]]}));const g=t.runWebGPUProgram(p,[s],s.dtype,m),y=Kt({inputs:{x:g},backend:t,attrs:{shape:f}});return t.disposeData(g.dataId),y},n5e={kernelName:xw,backendName:"webgpu",kernelFunc:t5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r5e{constructor(e,t,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=Ot([t]),this.dispatch=_t(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Pp("&result[outIndex]","value",this.type)}
      }
    }
  `}}class s5e{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Ot(t),this.dispatch=_t(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Pp("&result[segmentId]","1","int32")}
      }
    }
  `}}class i5e{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Ot(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LQ(n,e,t,r=!1,s){const o=Te(n.shape)/n.shape[0],a=n.dtype,l=Te(e.shape),c=s.readSync(t.dataId),h=l>0?c[l-1]+1:0;let f;const d=n.shape.slice();d[0]=h;const p=l*o,m=ba({backend:s,attrs:{shape:d,value:0,dtype:a}});f=new r5e(d,p,a);let g=[{type:"int32",data:[o]},{type:"int32",data:[p]}];const y=s.runWebGPUProgram(f,[n,e,t],a,g,m);if(r)return y;const b=ba({backend:s,attrs:{shape:[h],value:0,dtype:"int32"}});f=new s5e(h,t.shape);const x=s.runWebGPUProgram(f,[t],"int32",null,b),w=ba({backend:s,attrs:{shape:d,value:0,dtype:a}});f=new i5e(d,a),g=[{type:"int32",data:[o]}];const S=s.runWebGPUProgram(f,[y,x],a,g,w);return s.disposeData(y.dataId),s.disposeData(x.dataId),S}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5e(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;return LQ(r,s,i,!1,t)}const a5e={kernelName:$2,backendName:"webgpu",kernelFunc:o5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5e(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;return LQ(r,s,i,!0,t)}const c5e={kernelName:R2,backendName:"webgpu",kernelFunc:l5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u5e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*t[s];this.outputShape=r,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=h5e(this.rank,"uniforms.");return`
      ${xt("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function h5e(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n;s++)r.push(`(${t[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(t.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const l=t.readSync(s.dataId),c=s.dtype==="string"?l.map(f=>_c(f)):l,u=Sn(s.shape,s.dtype,c),h=eVe(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new u5e(s.shape,i);return t.runWebGPUProgram(o,[s],s.dtype)}const f5e={kernelName:Ay,backendName:"webgpu",kernelFunc:wB};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5e(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:f}=Fu(i,s,a),d=!1;if(i.dtype==="string"){const A=t.bufferSync(s),M=t.bufferSync(i),E=_c(t.readSync(o.dataId)[0]),N=X4e(A,M,a,f,u,c,l,h,E,d);return t.makeTensorInfo(a,N.dtype,N.values)}const p=[f/u,u],m=Kt({inputs:{x:s},backend:t,attrs:{shape:[c,l]}}),g=i.shape.length?Kt({inputs:{x:i},backend:t,attrs:{shape:[c,u]}}):Ka({inputs:{x:i},backend:t}),y=g.dtype,b=t.makeTensorInfo([],y,ji(1,y)),x=Kt({inputs:{x:o},backend:t,attrs:{shape:Array(p.length).fill(1)}}),w=wB({inputs:{x},backend:t,attrs:{reps:p}}),S=Te([c,u]),C=[{type:"int32",data:[l]},{type:"int32",data:h},{type:"int32",data:[S]}];switch(c){case 0:break;case 1:{const A=new Y1([c,u],l,m.shape.length,g.shape.length,h,p,y,d);t.runWebGPUProgram(A,[g,m],y,C,w)}break;default:{const A=new Y1([c,u],l,m.shape.length,b.shape.length,h,p,y,d);t.runWebGPUProgram(A,[b,m],y,C,w)}{const A=new Y1([c,u],l,m.shape.length,g.shape.length,h,p,y);t.runWebGPUProgram(A,[g,m],y,C,w)}}const k=Kt({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeData(m.dataId),t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),k}const p5e={kernelName:P2,backendName:"webgpu",kernelFunc:d5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=An(o,s.shape)[0],l=TN(s,i,a),c=s.shape.length,u=new Array(c).fill(0),h=s.shape.slice();return l.map(f=>{const d=[...h];d[a]=f;const p=Uw({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=f,p})}const g5e={kernelName:_w,backendName:"webgpu",kernelFunc:m5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y5e=yr({opType:bt.SQRT}),b5e={kernelName:Cy,backendName:"webgpu",kernelFunc:y5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v5e={kernelName:D2,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e,s=new Vw(t.shape,bt.SQUARE);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w5e=Xi({opType:yn.SQUARED_DIFFERENCE}),x5e={kernelName:ky,backendName:"webgpu",kernelFunc:w5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5e({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=new Vw(r.shape,bt.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(s,[r],r.dtype,i)}const S5e={kernelName:My,backendName:"webgpu",kernelFunc:_5e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C5e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ys(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let s=0;t=this.outputShape.map((i,o)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${s-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${xt("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=cN(s.shape,i,o,a,l,c,u,h,f);let S;if(m)S=Kt({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){U(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=lN(b,x,w),k=Uw({inputs:{x:s},backend:t,attrs:{begin:b,size:C}});S=Kt({inputs:{x:k},backend:t,attrs:{shape:p}}),t.disposeData(k.dataId)}else if(t.shouldExecuteOnCPU([s])){const k=t.readSync(s.dataId),A=Sn(s.shape,s.dtype,k),M=Z4e(d,A,w,b);S=t.makeTensorInfo(p,s.dtype,M.values)}else{const k=new C5e(d),A=[{type:"int32",data:b},{type:"int32",data:w}],M=t.runWebGPUProgram(k,[s],s.dtype,A);S=Kt({inputs:{x:M},backend:t,attrs:{shape:p}}),t.disposeData(M.dataId)}return S}const T5e={kernelName:F2,backendName:"webgpu",kernelFunc:k5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5e(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:h}=e,f=t.readSync(u.dataId),d=t.readSync(h.dataId),[p,m]=J4e(f,d,s,i,o,a,l,c);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(h.shape,"int32",m)]}const I5e={kernelName:L2,backendName:"webgpu",kernelFunc:E5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A5e=Xi({opType:yn.SUB,cpuKernelImpl:Q4e,supportsComplex:!0}),M5e={kernelName:Ty,backendName:"webgpu",kernelFunc:A5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N5e=yr({opType:bt.TAN}),$5e={kernelName:Ey,backendName:"webgpu",kernelFunc:N5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R5e=yr({opType:bt.TANH}),P5e={kernelName:Iy,backendName:"webgpu",kernelFunc:R5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D5e(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Fu(o,i,s.shape),f=[h/c,c];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const d=[],p=Kt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}});d.push(p);const m=Kt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}});d.push(m);const g=Kt({inputs:{x:s},backend:t,attrs:{shape:f}});d.push(g);const y=wB({inputs:{x:g},backend:t,attrs:{reps:Array(f.length).fill(1)}}),b=new Y1([l,c],a,p.shape.length,m.shape.length,u,f,s.dtype,!1),x=Te([l,c]),w=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[x]}],S=t.runWebGPUProgram(b,[m,p],g.dtype,w,y);d.push(S);const C=Kt({inputs:{x:S},backend:t,attrs:{shape:s.shape}});return d.forEach(k=>t.disposeData(k.dataId)),C}const O5e={kernelName:M2,backendName:"webgpu",kernelFunc:D5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${xt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class L5e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${xt("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0(n,e){e!==null&&n.disposeData(e.dataId)}function cH(n){let e=1;for(;e<n;)e*=2;return e}function z5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=s.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([s])){const S=t.readSync(s.dataId),[C,k]=tVe(S,a,s.dtype,i,o);return[t.makeTensorInfo(C.shape,C.dtype,C.values),t.makeTensorInfo(k.shape,k.dtype,k.values)]}if(i===0)return a[a.length-1]=0,[t.makeTensorInfo(a,s.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[s,ba({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=Te(a)/l,h=Kt({inputs:{x:s},attrs:{shape:[u,l]},backend:t}),f=cH(i),d=cH(l);let p=null;const m=()=>p===null?[h,h]:[h,p],g=(S,C,k)=>{const A=m(),M=new F5e(k),N=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[S]},{type:"int32",data:[C]}],O=p;p=t.runWebGPUProgram(M,A,"int32",N),M0(t,O)};for(let S=1;S<f;S*=2){const C=S*2;for(let k=S;k>=1;k/=2)g(C,k,[u,d])}for(let S=d;S>f;S/=2){const C=m(),k=new L5e([u,S/2]),M=[{type:"int32",data:[l]},{type:"int32",data:[p===null?1:0]},{type:"int32",data:[f]}],E=p;p=t.runWebGPUProgram(k,C,"int32",M),M0(t,E);const N=f/2,O=N*2;for(let R=N;R>=1;R/=2)g(O,R,p.shape)}let y=p;p=Uw({inputs:{x:p},backend:t,attrs:{begin:0,size:[u,i]}}),M0(t,y);let b=RQ({inputs:{x:h,indices:p},backend:t,attrs:{axis:1,batchDims:1}});M0(t,h);const x=a.slice(0,-1);x.push(i),y=p,p=Kt({inputs:{x:p},attrs:{shape:x},backend:t}),M0(t,y);const w=b;return b=Kt({inputs:{x:b},attrs:{shape:x},backend:t}),M0(t,w),[b,p]}const B5e={kernelName:z2,backendName:"webgpu",kernelFunc:z5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V5e{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${xt("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5e(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,h,f,d]=s.shape,[p,m]=c??[h,f],g=[u,p,m,d],y=new V5e(g),b=o==="nearest"?1:2;let x;switch(a){case"constant":x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4;break;default:x=1;break}const w=[{type:"int32",data:[b]},{type:"int32",data:[x]},{type:"float32",data:[l]}];return t.runWebGPUProgram(y,[s,i],"float32",w)}const W5e={kernelName:B2,backendName:"webgpu",kernelFunc:U5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G5e(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],f=new Array(a).fill(0),d=o.shape.slice();d[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){f[i]=m;const g=Uw({inputs:{x:o},backend:t,attrs:{begin:f,size:d}}),y=Kt({inputs:{x:g},backend:t,attrs:{shape:c}});p[m]=y,h.push(g)}return h.forEach(m=>t.disposeData(m.dataId)),p}const H5e={kernelName:Cw,backendName:"webgpu",kernelFunc:G5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j5e{constructor(e,t,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Ot(e),this.dispatch=_t(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${xt("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Pp("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Lr([c],a);let h=s;u!=null&&(h=_h({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),c=ns(1,a)[0]);const f=Jz(h.shape,c,o),d=Te([h.shape[c]]),p=Kt({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});l.push(p);const m=s.dtype,g=[p.shape[0],o],y=ba({backend:t,attrs:{shape:g,value:0,dtype:m}}),b=new j5e(p.shape,g,m),x=[{type:"int32",data:[o]},{type:"int32",data:[Te(p.shape)]}],w=t.runWebGPUProgram(b,[p,i],m,x,y),S=Kt({inputs:{x:w},backend:t,attrs:{shape:f}});l.push(w);let C=S;if(u!=null){l.push(S);const k=Mh(u);C=_h({inputs:{x:C},backend:t,attrs:{perm:k}})}return l.forEach(k=>t.disposeData(k.dataId)),C}const X5e={kernelName:kw,backendName:"webgpu",kernelFunc:q5e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K5e=[w4e,sVe,oVe,lVe,uVe,dVe,wVe,_Ve,CVe,TVe,IVe,MVe,$Ve,PVe,OVe,VVe,WVe,qVe,KVe,ZVe,nUe,oUe,cUe,dUe,mUe,vUe,_4e,_Ue,TUe,PUe,BUe,GUe,qUe,KUe,ZUe,QUe,tWe,sWe,oWe,lWe,uWe,dWe,wWe,_We,gWe,kWe,IWe,$We,PWe,FWe,VWe,WWe,HWe,qWe,KWe,ZWe,JWe,eGe,nGe,y4e,sGe,uGe,oGe,lGe,dGe,mGe,yGe,wGe,SGe,kGe,EGe,x4e,AGe,CUe,NGe,RGe,DGe,FGe,zGe,VGe,GGe,XGe,jGe,YGe,JGe,eHe,sHe,aHe,LVe,cHe,hHe,vHe,dHe,yHe,xHe,zVe,SHe,kHe,EHe,AHe,PHe,LWe,OHe,LHe,BHe,uUe,WHe,HHe,qHe,YHe,JHe,e6e,n6e,s6e,hUe,o6e,l6e,u6e,f6e,b4e,m6e,b6e,x6e,C6e,E6e,A6e,N6e,R6e,D6e,L6e,V6e,W6e,H6e,q6e,K6e,Z6e,eUe,S5e,T5e,I5e,$He,Q6e,n5e,a5e,c5e,p5e,g5e,b5e,v5e,x5e,M5e,zWe,$5e,P5e,O5e,f5e,B5e,W5e,gVe,H5e,X5e,GHe];for(const n of K5e)U2(n);function FD(n){"@babel/helpers - typeof";return FD=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},FD(n)}function Lu(n,e){if(e.length<n)throw new TypeError(n+" argument"+(n>1?"s":"")+" required, but only "+e.length+" present")}function qo(n){Lu(1,arguments);var e=Object.prototype.toString.call(n);return n instanceof Date||FD(n)==="object"&&e==="[object Date]"?new Date(n.getTime()):typeof n=="number"||e==="[object Number]"?new Date(n):((typeof n=="string"||e==="[object String]")&&typeof console<"u"&&(console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"),console.warn(new Error().stack)),new Date(NaN))}var Y5e={};function Z5e(){return Y5e}function uH(n){var e=new Date(Date.UTC(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds(),n.getMilliseconds()));return e.setUTCFullYear(n.getFullYear()),n.getTime()-e.getTime()}function DE(n,e){Lu(2,arguments);var t=qo(n),r=qo(e),s=t.getTime()-r.getTime();return s<0?-1:s>0?1:s}function J5e(n,e){Lu(2,arguments);var t=qo(n),r=qo(e),s=t.getFullYear()-r.getFullYear(),i=t.getMonth()-r.getMonth();return s*12+i}function Q5e(n,e){return Lu(2,arguments),qo(n).getTime()-qo(e).getTime()}var hH={ceil:Math.ceil,round:Math.round,floor:Math.floor,trunc:function(e){return e<0?Math.ceil(e):Math.floor(e)}},eje="trunc";function tje(n){return n?hH[n]:hH[eje]}function nje(n){Lu(1,arguments);var e=qo(n);return e.setHours(23,59,59,999),e}function rje(n){Lu(1,arguments);var e=qo(n),t=e.getMonth();return e.setFullYear(e.getFullYear(),t+1,0),e.setHours(23,59,59,999),e}function sje(n){Lu(1,arguments);var e=qo(n);return nje(e).getTime()===rje(e).getTime()}function ije(n,e){Lu(2,arguments);var t=qo(n),r=qo(e),s=DE(t,r),i=Math.abs(J5e(t,r)),o;if(i<1)o=0;else{t.getMonth()===1&&t.getDate()>27&&t.setDate(30),t.setMonth(t.getMonth()-s*i);var a=DE(t,r)===-s;sje(qo(n))&&i===1&&DE(n,r)===1&&(a=!1),o=s*(i-Number(a))}return o===0?0:o}function oje(n,e,t){Lu(2,arguments);var r=Q5e(n,e)/1e3;return tje(t==null?void 0:t.roundingMethod)(r)}var aje={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}},lje=function(e,t,r){var s,i=aje[e];return typeof i=="string"?s=i:t===1?s=i.one:s=i.other.replace("{{count}}",t.toString()),r!=null&&r.addSuffix?r.comparison&&r.comparison>0?"in "+s:s+" ago":s};const cje=lje;function m3(n){return function(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=e.width?String(e.width):n.defaultWidth,r=n.formats[t]||n.formats[n.defaultWidth];return r}}var uje={full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},hje={full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},fje={full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},dje={date:m3({formats:uje,defaultWidth:"full"}),time:m3({formats:hje,defaultWidth:"full"}),dateTime:m3({formats:fje,defaultWidth:"full"})};const pje=dje;var mje={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"},gje=function(e,t,r,s){return mje[e]};const yje=gje;function Wx(n){return function(e,t){var r=t!=null&&t.context?String(t.context):"standalone",s;if(r==="formatting"&&n.formattingValues){var i=n.defaultFormattingWidth||n.defaultWidth,o=t!=null&&t.width?String(t.width):i;s=n.formattingValues[o]||n.formattingValues[i]}else{var a=n.defaultWidth,l=t!=null&&t.width?String(t.width):n.defaultWidth;s=n.values[l]||n.values[a]}var c=n.argumentCallback?n.argumentCallback(e):e;return s[c]}}var bje={narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},vje={narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},wje={narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},xje={narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},_je={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},Sje={narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},Cje=function(e,t){var r=Number(e),s=r%100;if(s>20||s<10)switch(s%10){case 1:return r+"st";case 2:return r+"nd";case 3:return r+"rd"}return r+"th"},kje={ordinalNumber:Cje,era:Wx({values:bje,defaultWidth:"wide"}),quarter:Wx({values:vje,defaultWidth:"wide",argumentCallback:function(e){return e-1}}),month:Wx({values:wje,defaultWidth:"wide"}),day:Wx({values:xje,defaultWidth:"wide"}),dayPeriod:Wx({values:_je,defaultWidth:"wide",formattingValues:Sje,defaultFormattingWidth:"wide"})};const Tje=kje;function Gx(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=t.width,s=r&&n.matchPatterns[r]||n.matchPatterns[n.defaultMatchWidth],i=e.match(s);if(!i)return null;var o=i[0],a=r&&n.parsePatterns[r]||n.parsePatterns[n.defaultParseWidth],l=Array.isArray(a)?Ije(a,function(h){return h.test(o)}):Eje(a,function(h){return h.test(o)}),c;c=n.valueCallback?n.valueCallback(l):l,c=t.valueCallback?t.valueCallback(c):c;var u=e.slice(o.length);return{value:c,rest:u}}}function Eje(n,e){for(var t in n)if(n.hasOwnProperty(t)&&e(n[t]))return t}function Ije(n,e){for(var t=0;t<n.length;t++)if(e(n[t]))return t}function Aje(n){return function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},r=e.match(n.matchPattern);if(!r)return null;var s=r[0],i=e.match(n.parsePattern);if(!i)return null;var o=n.valueCallback?n.valueCallback(i[0]):i[0];o=t.valueCallback?t.valueCallback(o):o;var a=e.slice(s.length);return{value:o,rest:a}}}var Mje=/^(\d+)(th|st|nd|rd)?/i,Nje=/\d+/i,$je={narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},Rje={any:[/^b/i,/^(a|c)/i]},Pje={narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},Dje={any:[/1/i,/2/i,/3/i,/4/i]},Oje={narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},Fje={narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},Lje={narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},zje={narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},Bje={narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},Vje={any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},Uje={ordinalNumber:Aje({matchPattern:Mje,parsePattern:Nje,valueCallback:function(e){return parseInt(e,10)}}),era:Gx({matchPatterns:$je,defaultMatchWidth:"wide",parsePatterns:Rje,defaultParseWidth:"any"}),quarter:Gx({matchPatterns:Pje,defaultMatchWidth:"wide",parsePatterns:Dje,defaultParseWidth:"any",valueCallback:function(e){return e+1}}),month:Gx({matchPatterns:Oje,defaultMatchWidth:"wide",parsePatterns:Fje,defaultParseWidth:"any"}),day:Gx({matchPatterns:Lje,defaultMatchWidth:"wide",parsePatterns:zje,defaultParseWidth:"any"}),dayPeriod:Gx({matchPatterns:Bje,defaultMatchWidth:"any",parsePatterns:Vje,defaultParseWidth:"any"})};const Wje=Uje;var Gje={code:"en-US",formatDistance:cje,formatLong:pje,formatRelative:yje,localize:Tje,match:Wje,options:{weekStartsOn:0,firstWeekContainsDate:1}};const Hje=Gje;function zQ(n,e){if(n==null)throw new TypeError("assign requires that input parameter not be null or undefined");for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function jje(n){return zQ({},n)}var fH=1440,qje=2520,g3=43200,Xje=86400;function Kje(n,e,t){var r,s;Lu(2,arguments);var i=Z5e(),o=(r=(s=t==null?void 0:t.locale)!==null&&s!==void 0?s:i.locale)!==null&&r!==void 0?r:Hje;if(!o.formatDistance)throw new RangeError("locale must contain formatDistance property");var a=DE(n,e);if(isNaN(a))throw new RangeError("Invalid time value");var l=zQ(jje(t),{addSuffix:!!(t!=null&&t.addSuffix),comparison:a}),c,u;a>0?(c=qo(e),u=qo(n)):(c=qo(n),u=qo(e));var h=oje(u,c),f=(uH(u)-uH(c))/1e3,d=Math.round((h-f)/60),p;if(d<2)return t!=null&&t.includeSeconds?h<5?o.formatDistance("lessThanXSeconds",5,l):h<10?o.formatDistance("lessThanXSeconds",10,l):h<20?o.formatDistance("lessThanXSeconds",20,l):h<40?o.formatDistance("halfAMinute",0,l):h<60?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",1,l):d===0?o.formatDistance("lessThanXMinutes",1,l):o.formatDistance("xMinutes",d,l);if(d<45)return o.formatDistance("xMinutes",d,l);if(d<90)return o.formatDistance("aboutXHours",1,l);if(d<fH){var m=Math.round(d/60);return o.formatDistance("aboutXHours",m,l)}else{if(d<qje)return o.formatDistance("xDays",1,l);if(d<g3){var g=Math.round(d/fH);return o.formatDistance("xDays",g,l)}else if(d<Xje)return p=Math.round(d/g3),o.formatDistance("aboutXMonths",p,l)}if(p=ije(u,c),p<12){var y=Math.round(d/g3);return o.formatDistance("xMonths",y,l)}else{var b=p%12,x=Math.floor(p/12);return b<3?o.formatDistance("aboutXYears",x,l):b<9?o.formatDistance("overXYears",x,l):o.formatDistance("almostXYears",x+1,l)}}function Yje(n,e){return Lu(1,arguments),Kje(n,Date.now(),e)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function BQ(n,e){for(var t=e.length,r=new Array(t+1),s=0;s<t;++s)r[s]=e[s];return r[t]=n,r}function Zje(n,e){var t=n.length,r=e.length,s=new Array(t+r),i=0;for(i=0;i<t;i++)s[i]=n[i];for(var o=0;o<r;o++)s[i++]=e[o];return s}function Jje(n,e){for(var t=e.length,r=new Array(t),s=0;s<t;++s)r[s]=n(e[s]);return r}function zN(n,e,t){for(var r=e,s=0,i=t.length;s<i;++s)r=n(r,t[s],s);return r}function Qje(n,e){if(n<0)throw new TypeError("i must be >= 0");var t=e.length;return t===0||n>=t?e:t===1?[]:e8e(n,e,t-1)}function e8e(n,e,t){var r=new Array(t),s;for(s=0;s<n;++s)r[s]=e[s];for(s=n;s<t;++s)r[s]=e[s+1];return r}function t8e(n,e){for(var t=e.length,r=new Array(t),s=0,i=void 0,o=0;o<t;++o)i=e[o],n(i)||(r[s]=i,++s);return r.length=s,r}function VQ(n,e){for(var t=0,r=e.length;t<r;++t)if(n===e[t])return t;return-1}/** @license MIT License (c) copyright 2010-2016 original author or authors */var n8e=function(n){return n},r8e=function(n,e){return function(t){return n(e(t))}},s8e=function(n,e){return n(e)};function Tr(n){function e(t,r){switch(arguments.length){case 0:return e;case 1:return function(s){return n(t,s)};default:return n(t,r)}}return e}function zu(n){function e(t,r,s){switch(arguments.length){case 0:return e;case 1:return Tr(function(i,o){return n(t,i,o)});case 2:return function(i){return n(t,r,i)};default:return n(t,r,s)}}return e}var i8e=function(){function n(e,t,r,s,i){this.time=e,this.localOffset=t,this.period=r,this.task=s,this.scheduler=i,this.active=!0}return n.prototype.run=function(){return this.task.run(this.time-this.localOffset)},n.prototype.error=function(e){return this.task.error(this.time-this.localOffset,e)},n.prototype.dispose=function(){return this.active=!1,this.scheduler.cancel(this),this.task.dispose()},n}(),UQ=function(){function n(e,t){this.origin=e,this.scheduler=t}return n.prototype.currentTime=function(){return this.scheduler.currentTime()-this.origin},n.prototype.scheduleTask=function(e,t,r,s){return this.scheduler.scheduleTask(e+this.origin,t,r,s)},n.prototype.relative=function(e){return new n(e+this.origin,this.scheduler)},n.prototype.cancel=function(e){return this.scheduler.cancel(e)},n.prototype.cancelAll=function(e){return this.scheduler.cancelAll(e)},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var o8e=function(n){return Promise.resolve(n).then(WQ)};function WQ(n){try{return n.run()}catch(e){return n.error(e)}}/** @license MIT License (c) copyright 2010-2017 original author or authors */var a8e=function(){function n(e,t){var r=this;this._runReadyTasksBound=function(){return r._runReadyTasks()},this.timer=e,this.timeline=t,this._timer=null,this._nextArrival=1/0}return n.prototype.currentTime=function(){return this.timer.now()},n.prototype.scheduleTask=function(e,t,r,s){var i=this.currentTime()+Math.max(0,t),o=new i8e(i,e,r,s,this);return this.timeline.add(o),this._scheduleNextRun(),o},n.prototype.relative=function(e){return new UQ(e,this)},n.prototype.cancel=function(e){e.active=!1,this.timeline.remove(e)&&this._reschedule()},n.prototype.cancelAll=function(e){this.timeline.removeAll(e),this._reschedule()},n.prototype._reschedule=function(){this.timeline.isEmpty()?this._unschedule():this._scheduleNextRun()},n.prototype._unschedule=function(){this.timer.clearTimer(this._timer),this._timer=null},n.prototype._scheduleNextRun=function(){if(!this.timeline.isEmpty()){var e=this.timeline.nextArrival();this._timer===null?this._scheduleNextArrival(e):e<this._nextArrival&&(this._unschedule(),this._scheduleNextArrival(e))}},n.prototype._scheduleNextArrival=function(e){this._nextArrival=e;var t=Math.max(0,e-this.currentTime());this._timer=this.timer.setTimer(this._runReadyTasksBound,t)},n.prototype._runReadyTasks=function(){this._timer=null,this.timeline.runTasks(this.currentTime(),WQ),this._scheduleNextRun()},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var l8e=function(){function n(){this.tasks=[]}return n.prototype.nextArrival=function(){return this.isEmpty()?1/0:this.tasks[0].time},n.prototype.isEmpty=function(){return this.tasks.length===0},n.prototype.add=function(e){GQ(e,this.tasks)},n.prototype.remove=function(e){var t=jQ(HQ(e),this.tasks);if(t>=0&&t<this.tasks.length){var r=this.tasks[t].events,s=VQ(e,r);if(s>=0)return r.splice(s,1),r.length===0&&this.tasks.splice(t,1),!0}return!1},n.prototype.removeAll=function(e){for(var t=0;t<this.tasks.length;++t)d8e(e,this.tasks[t])},n.prototype.runTasks=function(e,t){for(var r=this.tasks,s=r.length,i=0;i<s&&r[i].time<=e;)++i;this.tasks=r.slice(i);for(var o=0;o<i;++o)this.tasks=c8e(t,r[o].events,this.tasks)},n}();function c8e(n,e,t){for(var r=0;r<e.length;++r){var s=e[r];s.active&&(n(s),s.period>=0&&s.active&&(s.time=s.time+s.period,GQ(s,t)))}return t}function GQ(n,e){var t=e.length,r=HQ(n);if(t===0){e.push(LD(r,[n]));return}var s=jQ(r,e);s>=t?e.push(LD(r,[n])):u8e(n,e,r,s)}function u8e(n,e,t,r){var s=e[r];t===s.time?h8e(n,s.events):e.splice(r,0,LD(t,[n]))}function h8e(n,e){e.length===0||n.time>=e[e.length-1].time?e.push(n):f8e(n,e)}function f8e(n,e){for(var t=0;t<e.length;t++)if(n.time<e[t].time){e.splice(t,0,n);break}}function HQ(n){return Math.floor(n.time)}function d8e(n,e){e.events=t8e(n,e.events)}function jQ(n,e){for(var t=0,r=e.length,s,i;t<r;){if(s=Math.floor((t+r)/2),i=e[s],n===i.time)return s;n<i.time?r=s:t=s+1}return r}var LD=function(n,e){return{time:n,events:e}};/** @license MIT License (c) copyright 2010-2017 original author or authors */var p8e=function(){function n(e){this._clock=e}return n.prototype.now=function(){return this._clock.now()},n.prototype.setTimer=function(e,t){return t<=0?m8e(e):setTimeout(e,t)},n.prototype.clearTimer=function(e){return e instanceof qQ?e.cancel():clearTimeout(e)},n}(),qQ=function(){function n(e){this.f=e,this.active=!0}return n.prototype.run=function(){if(this.active)return this.f()},n.prototype.error=function(e){throw e},n.prototype.cancel=function(){this.active=!1},n}();function m8e(n){var e=new qQ(n);return o8e(e),e}var g8e=function(){function n(e,t){this.origin=t,this.clock=e}return n.prototype.now=function(){return this.clock.now()-this.origin},n}(),y8e=function(){function n(e,t){this.origin=t,this.hrtime=e}return n.prototype.now=function(){var e=this.hrtime(this.origin);return(e[0]*1e9+e[1])/1e6},n}(),XQ=function(n){return new g8e(n,n.now())},b8e=function(){return XQ(performance)},v8e=function(){return XQ(Date)},w8e=function(){return new y8e(process.hrtime,process.hrtime())},x8e=function(){return typeof performance<"u"&&typeof performance.now=="function"?b8e():typeof process<"u"&&typeof process.hrtime=="function"?w8e():v8e()},OE=function(n){return n.currentTime()},BN=Tr(function(n,e){return e.scheduleTask(0,0,-1,n)}),UI=zu(function(n,e,t){return t.scheduleTask(0,n,-1,e)}),_8e=zu(function(n,e,t){return t.scheduleTask(0,0,n,e)}),S8e=function(n){return n.dispose()},xB=Tr(function(n,e){return new UQ(n,e)}),C8e=function(){return new a8e(k8e(),new l8e)},k8e=function(){return new p8e(x8e())},R_=function(){return KQ},KQ=new(function(){function n(){}return n.prototype.dispose=function(){},n}()),T8e=function(n){return n===KQ},_B=function(n){return new E8e(n)},E8e=function(){function n(e){this.disposed=!1,this.disposable=e}return n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable&&(this.disposable.dispose(),this.disposable=void 0))},n}();/** @license MIT License (c) copyright 2010 original author or authors */var bC=function(n){var e=zN(I8e,[],n);return e.length===0?R_():new YQ(e)},Ww=Tr(function(n,e){return bC([n,e])}),I8e=function(n,e){return T8e(e)?n:e instanceof YQ?Zje(n,e.disposables):BQ(e,n)},YQ=function(){function n(e){this.disposables=e}return n.prototype.dispose=function(){N8e(A8e(this.disposables))},n}(),A8e=function(n){return zN(M8e,[],n)},M8e=function(n,e){try{e.dispose()}catch(t){n.push(t)}return n},N8e=function(n){if(n.length>0)throw new ZQ(n.length+" errors",n)},ZQ=function(){function n(e,t){this.name="DisposeAllError",this.message=e,this.errors=t,Error.call(this,e),Error.captureStackTrace&&Error.captureStackTrace(this,n),this.stack=""+this.stack+$8e(this.errors)}return n}();ZQ.prototype=Object.create(Error.prototype);var $8e=function(n){return zN(R8e,"",n)},R8e=function(n,e,t){return n+(`
[`+(t+1)+"] "+e.stack)};/** @license MIT License (c) copyright 2010-2017 original author or authors */var fg=zu(function(n,e,t){try{e.dispose()}catch(r){t.error(n,r)}});/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var zD=function(n,e){return zD=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])},zD(n,e)};function Yr(n,e){zD(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}/** @license MIT License (c) copyright 2010-2016 original author or authors */function JQ(n){setTimeout(P8e,0,n)}function P8e(n){throw n}/** @license MIT License (c) copyright 2010-2016 original author or authors */var D8e=function(n,e,t){return new F8e(n,e,t)},SB=function(n,e){return new L8e(n,e)},QQ=function(n){return new z8e(n)},O8e=function(n,e){return new B8e(n,e)},VN=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.dispose=function(){this.active=!1},n.prototype.run=function(e){this.active&&this.runIfActive(e)},n.prototype.error=function(e,t){if(!this.active)return JQ(t);this.sink.error(e,t)},n}(),F8e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.runEvent=t,i.value=r,i}return e.prototype.runIfActive=function(t){this.runEvent(t,this.value,this.sink)},e}(VN),L8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.value=t,s}return e.prototype.runIfActive=function(t){this.sink.event(t,this.value)},e}(VN),z8e=function(n){Yr(e,n);function e(){return n!==null&&n.apply(this,arguments)||this}return e.prototype.runIfActive=function(t){this.sink.end(t)},e}(VN),B8e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.value=t,s}return e.prototype.runIfActive=function(t){this.sink.error(t,this.value)},e}(VN);/** @license MIT License (c) copyright 2010-2017 original author or authors */var Ki=function(){return tee},Ni=function(n){return n===tee},eee=function(n){return n.some(Ni)},V8e=function(){function n(){}return n.prototype.run=function(e,t){return BN(QQ(e),t)},n}(),tee=new V8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var P_=function(){return W8e},U8e=function(){function n(){}return n.prototype.run=function(){return R_()},n}(),W8e=new U8e;/** @license MIT License (c) copyright 2010-2017 original author or authors */var nee=function(n,e){return new G8e(n,e)},G8e=function(){function n(e,t){this.time=e,this.value=t}return n.prototype.run=function(e,t){return UI(this.time,D8e(H8e,this.value,e),t)},n}();function H8e(n,e,t){t.event(n,e),t.end(n)}/** @license MIT License (c) copyright 2010-2017 original author or authors */var BD=function(n){return nee(0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var j8e=function(n){return new q8e(n)},q8e=function(){function n(e){this.period=e}return n.prototype.run=function(e,t){return _8e(this.period,SB(void 0,e),t)},n}(),UN=function(){function n(){this.disposable=void 0,this.disposed=!1}return n.prototype.setDisposable=function(e){if(this.disposable!==void 0)throw new Error("setDisposable called more than once");this.disposable=e,this.disposed&&e.dispose()},n.prototype.dispose=function(){this.disposed||(this.disposed=!0,this.disposable!==void 0&&this.disposable.dispose())},n}();/** @license MIT License (c) copyright 2010-2017 original author or authors */var X8e=Tr(function(n,e){return new Promise(function(t,r){return K8e(n,e,t,r)})});function K8e(n,e,t,r){var s=new UN,i=new Y8e(t,r,s);s.setDisposable(n.run(i,e))}var Y8e=function(){function n(e,t,r){this._end=e,this._error=t,this._disposable=r,this.active=!0}return n.prototype.event=function(){},n.prototype.end=function(){this.active&&this.dispose(this._error,this._end,void 0)},n.prototype.error=function(e,t){this.dispose(this._error,this._error,t)},n.prototype.dispose=function(e,t,r){this.active=!1,Z8e(e,t,r,this._disposable)},n}();function Z8e(n,e,t,r){try{r.dispose()}catch(s){n(s);return}e(t)}var ree=function(n,e,t){return t.run(n,e)},y3=function(){function n(e,t){this.sink=t,this.offset=e}return n.prototype.event=function(e,t){this.sink.event(e+this.offset,t)},n.prototype.error=function(e,t){this.sink.error(e+this.offset,t)},n.prototype.end=function(e){this.sink.end(e+this.offset)},n}(),CB=function(n,e){return new J8e(n,e)},J8e=function(){function n(e,t){this.origin=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(Q8e(this.origin,e),xB(this.origin,t))},n}(),Q8e=function(n,e){return e instanceof y3?new y3(n+e.offset,e.sink):new y3(n,e)},Is=function(){function n(e){this.sink=e}return n.prototype.end=function(e){return this.sink.end(e)},n.prototype.error=function(e,t){return this.sink.error(e,t)},n}();/** @license MIT License (c) copyright 2010 original author or authors */var eqe=function(n,e,t){return Ni(t)?Ki():new tqe(n,e,t)},tqe=function(){function n(e,t,r){this.step=e,this.seed=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new nqe(this.step,this.seed,e),t)},n}(),nqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.step=t,i.seed=r,i}return e.prototype.event=function(t,r){var s=this.step(this.seed,r);this.seed=s.seed,this.sink.event(t,s.value)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var rqe=function(n,e,t){return new sqe(n,e,t)},sqe=function(){function n(e,t,r){this.source=r,this.f=e,this.value=t}return n.prototype.run=function(e,t){var r=BN(SB(this.value,e),t),s=this.source.run(new iqe(this.f,this.value,e),t);return Ww(r,s)},n}(),iqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.f=t,i.value=r,i}return e.prototype.event=function(t,r){var s=this.f;this.value=s(this.value,r),this.sink.event(t,this.value)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var see=function(n,e){return new oqe(n,e)},oqe=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new aqe(this.f,this.source,e,t)},n}(),aqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.f=t,o.scheduler=i,o.active=!0,o.disposable=_B(r.run(o,i)),o}return e.prototype.event=function(t,r){this.active&&this.sink.event(t,r)},e.prototype.end=function(t){this.active&&(fg(t,this.disposable,this.sink),this.startNext(t,this.sink))},e.prototype.startNext=function(t,r){try{this.disposable=this.continue(this.f,t,r)}catch(s){r.error(t,s)}},e.prototype.continue=function(t,r,s){return ree(s,this.scheduler,CB(r,t()))},e.prototype.dispose=function(){return this.active=!1,this.disposable.dispose()},e}(Is);/** @license MIT License (c) copyright 2010-2017 original author or authors */var lqe=function(n,e){return see(function(){return e},BD(n))};/** @license MIT License (c) copyright 2010-2016 original author or authors */var iee=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new cqe(this.p,e),t)},n.create=function(e,t){return Ni(t)?t:t instanceof n?new n(uqe(t.p,e),t.source):new n(e,t)},n}(),cqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s}return e.prototype.event=function(t,r){var s=this.p;s(r)&&this.sink.event(t,r)},e}(Is),uqe=function(n,e){return function(t){return n(t)&&e(t)}};/** @license MIT License (c) copyright 2010-2016 original author or authors */var hqe=function(){function n(e,t,r){this.p=e,this.f=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new fqe(this.p,this.f,e),t)},n}(),fqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.p=t,i.f=r,i}return e.prototype.event=function(t,r){var s=this.f,i=this.p;i(r)&&this.sink.event(t,s(r))},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var vC=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new dqe(this.f,e),t)},n.create=function(e,t){return Ni(t)?Ki():t instanceof n?new n(r8e(e,t.f),t.source):t instanceof iee?new hqe(t.p,e,t.source):new n(e,t)},n}(),dqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s}return e.prototype.event=function(t,r){var s=this.f;this.sink.event(t,s(r))},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var WN=function(n,e){return vC.create(n,e)},pqe=function(n,e){return WN(function(){return n},e)},mqe=function(n,e){return new gqe(n,e)},gqe=function(){function n(e,t){this.source=t,this.f=e}return n.prototype.run=function(e,t){return this.source.run(new yqe(this.f,e),t)},n}(),yqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s}return e.prototype.event=function(t,r){var s=this.f;s(r),this.sink.event(t,r)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var kB=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.index=t,s.active=!0,s.value=void 0,s}return e.prototype.event=function(t,r){this.active&&(this.value=r,this.sink.event(t,this))},e.prototype.end=function(t){this.active&&(this.active=!1,this.sink.event(t,this))},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */function oee(n,e){switch(e.length){case 0:return n();case 1:return n(e[0]);case 2:return n(e[0],e[1]);case 3:return n(e[0],e[1],e[2]);case 4:return n(e[0],e[1],e[2],e[3]);case 5:return n(e[0],e[1],e[2],e[3],e[4]);default:return n.apply(void 0,e)}}/** @license MIT License (c) copyright 2010 original author or authors */var aee=function(n,e,t){return bqe(n,[e,t])},bqe=function(n,e){return e.length===0||eee(e)?Ki():e.length===1?WN(n,e[0]):new vqe(n,e)},vqe=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new wqe(s,i.length,e,this.f),a=void 0,l=0;l<r;++l)a=i[l]=new kB(l,o),s[l]=this.sources[l].run(a,t);return bC(s)},n}(),wqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.disposables=t,o.f=i,o.awaiting=r,o.values=new Array(r),o.hasValue=new Array(r).fill(!1),o.activeCount=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var s=r.index,i=this.updateReady(s);this.values[s]=r.value,i===0&&this.sink.event(t,oee(this.f,this.values))},e.prototype.updateReady=function(t){return this.awaiting>0&&(this.hasValue[t]||(this.hasValue[t]=!0,this.awaiting-=1)),this.awaiting},e.prototype.dispose=function(t,r){fg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */function xqe(n,e){return aee(s8e,n,e)}/** @license MIT License (c) copyright 2010 original author or authors */var lee=function(n,e){return GN(n8e,n,e)},GN=function(n,e,t){return Ni(t)?Ki():new _qe(n,e,t)},_qe=function(){function n(e,t,r){this.f=e,this.concurrency=t,this.source=r}return n.prototype.run=function(e,t){return new Cqe(this.f,this.concurrency,this.source,e,t)},n}(),Sqe=function(n){return n.length>0},Cqe=function(){function n(e,t,r,s,i){this.f=e,this.concurrency=t,this.sink=s,this.scheduler=i,this.pending=[],this.current=[],this.disposable=_B(r.run(this,i)),this.active=!0}return n.prototype.event=function(e,t){this.addInner(e,t)},n.prototype.addInner=function(e,t){this.current.length<this.concurrency?this.startInner(e,t):this.pending.push(t)},n.prototype.startInner=function(e,t){try{this.initInner(e,t)}catch(r){this.error(e,r)}},n.prototype.initInner=function(e,t){var r=new Tqe(e,this,this.sink);r.disposable=kqe(this.f,e,t,r,this.scheduler),this.current.push(r)},n.prototype.end=function(e){this.active=!1,fg(e,this.disposable,this.sink),this.checkEnd(e)},n.prototype.error=function(e,t){this.active=!1,this.sink.error(e,t)},n.prototype.dispose=function(){this.active=!1,this.pending.length=0,this.disposable.dispose(),bC(this.current).dispose()},n.prototype.endInner=function(e,t){var r=this.current.indexOf(t);r>=0&&this.current.splice(r,1),fg(e,t,this);var s=this.pending;Sqe(s)?this.startInner(e,s.shift()):this.checkEnd(e)},n.prototype.checkEnd=function(e){!this.active&&this.current.length===0&&this.sink.end(e)},n}(),kqe=function(n,e,t,r,s){return n(t).run(r,xB(e,s))},Tqe=function(){function n(e,t,r){this.time=e,this.outer=t,this.sink=r,this.disposable=R_()}return n.prototype.event=function(e,t){this.sink.event(e+this.time,t)},n.prototype.end=function(e){this.outer.endInner(e+this.time,this)},n.prototype.error=function(e,t){this.outer.error(e+this.time,t)},n.prototype.dispose=function(){return this.disposable.dispose()},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var Eqe=function(n,e){return GN(n,1/0,e)},cee=function(n){return lee(1/0,n)};/** @license MIT License (c) copyright 2010-2016 original author or authors */var Iqe=function(n,e){return GN(n,1,e)};/** @license MIT License (c) copyright 2010-2016 original author or authors */function Aqe(n,e){return Mqe([n,e])}var Mqe=function(n){return Nqe($qe(n))},Nqe=function(n){return n.length===0?Ki():n.length===1?n[0]:new uee(zN(Pqe,[],n))},$qe=function(n){return n.filter(Rqe)},Rqe=function(n){return!Ni(n)},Pqe=function(n,e){return n.concat(e instanceof uee?e.sources:e)},uee=function(){function n(e){this.sources=e}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new Dqe(s,i,e),a=void 0,l=0;l<r;++l)a=i[l]=new kB(l,o),s[l]=this.sources[l].run(a,t);return bC(s)},n}(),Dqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.disposables=t,i.activeCount=r.length,i}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}this.sink.event(t,r.value)},e.prototype.dispose=function(t,r){fg(t,this.disposables[r],this.sink),--this.activeCount===0&&this.sink.end(t)},e}(Is);/** @license MIT License (c) copyright 2010 original author or authors */var Oqe=function(n,e){return hee(function(t){return t},n,e)},hee=function(n,e,t){return Ni(t)||Ni(e)?Ki():new Fqe(n,e,t)},Fqe=function(){function n(e,t,r){this.f=e,this.values=t,this.sampler=r}return n.prototype.run=function(e,t){var r=new Lqe(this.f,e),s=this.values.run(r.latest,t),i=this.sampler.run(r,t);return Ww(i,s)},n}(),Lqe=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.f=t,s.latest=new zqe(s),s}return e.prototype.event=function(t,r){if(this.latest.hasValue){var s=this.f;this.sink.event(t,s(this.latest.value,r))}},e}(Is),zqe=function(n){Yr(e,n);function e(t){var r=n.call(this,t)||this;return r.hasValue=!1,r}return e.prototype.event=function(t,r){this.value=r,this.hasValue=!0},e.prototype.end=function(){},e}(Is);/** @license MIT License (c) copyright 2010 original author or authors */var fee=function(n,e){var t=Math.max(0,n),r=Math.max(t,e);return{min:t,max:r}},Bqe=function(n,e){return fee(n.min+e.min,Math.min(n.max,n.min+e.max))},Vqe=function(n){return n.min>=n.max},Uqe=function(n){return n.min<=0&&n.max===1/0},dee=function(n,e){return TB(0,n,e)},Wqe=function(n,e){return TB(n,1/0,e)},TB=function(n,e,t){return EB(fee(n,e),t)},EB=function(n,e){return Gqe(n,e)?Ki():e instanceof vC?jqe(n,e):e instanceof pee?qqe(n,e):Hqe(n,e)},Gqe=function(n,e){return Ni(e)||Vqe(n)},Hqe=function(n,e){return Uqe(n)?e:new pee(n,e)},jqe=function(n,e){return vC.create(e.f,EB(n,e.source))},qqe=function(n,e){return EB(Bqe(e.bounds,n),e.source)},pee=function(){function n(e,t){this.source=t,this.bounds=e}return n.prototype.run=function(e,t){var r=new UN,s=new Xqe(this.bounds.min,this.bounds.max-this.bounds.min,e,r);return r.setDisposable(this.source.run(s,t)),r},n}(),Xqe=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,s)||this;return o.skip=t,o.take=r,o.disposable=i,o}return e.prototype.event=function(t,r){if(this.skip>0){this.skip-=1;return}this.take!==0&&(this.take-=1,this.sink.event(t,r),this.take===0&&(this.disposable.dispose(),this.sink.end(t)))},e}(Is),Kqe=function(n,e){return Ni(e)?Ki():new Yqe(n,e)},Yqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){var r=new UN,s=new Zqe(this.p,e,r);return r.setDisposable(this.source.run(s,t)),r},n}(),Zqe=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.p=t,i.active=!0,i.disposable=s,i}return e.prototype.event=function(t,r){if(this.active){var s=this.p;this.active=s(r),this.active?this.sink.event(t,r):(this.disposable.dispose(),this.sink.end(t))}},e}(Is),Jqe=function(n,e){return Ni(e)?Ki():new Qqe(n,e)},Qqe=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new e9e(this.p,e),t)},n}(),e9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s.skipping=!0,s}return e.prototype.event=function(t,r){if(this.skipping){var s=this.p;if(this.skipping=s(r),this.skipping)return}this.sink.event(t,r)},e}(Is),t9e=function(n,e){return Ni(e)?Ki():new n9e(n,e)},n9e=function(){function n(e,t){this.p=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new r9e(this.p,e),t)},n}(),r9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.p=t,s.skipping=!1,s}return e.prototype.event=function(t,r){if(!this.skipping){var s=this.p;this.skipping=s(r),this.sink.event(t,r),this.skipping&&this.sink.end(t)}},e}(Is);/** @license MIT License (c) copyright 2017 original author or authors */var s9e=function(n,e){return mee(i9e,n,e)},mee=function(n,e,t){return Ni(t)||e.length===0?Ki():new o9e(n,e,dee(e.length,t))},i9e=function(n){return n},o9e=function(){function n(e,t,r){this.f=e,this.items=t,this.source=r}return n.prototype.run=function(e,t){return this.source.run(new a9e(this.f,this.items,e),t)},n}(),a9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,s)||this;return i.f=t,i.items=r,i.index=0,i}return e.prototype.event=function(t,r){var s=this.f;this.sink.event(t,s(this.items[this.index],r)),this.index+=1},e}(Is),l9e=2,c9e=1e4,u9e=function(){function n(){this.head=0,this.tail=0,this.capacityMask=3,this.list=new Array(4)}return n.prototype.push=function(e){var t=this.tail;return this.list[t]=e,this.tail=t+1&this.capacityMask,this.tail===this.head&&this.growArray(),this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.shift=function(){var e=this.head;if(e!==this.tail){var t=this.list[e];return this.list[e]=void 0,this.head=e+1&this.capacityMask,e<l9e&&this.tail>c9e&&this.tail<=this.list.length>>>2&&this.shrinkArray(),t}},n.prototype.isEmpty=function(){return this.head===this.tail},n.prototype.length=function(){return this.head===this.tail?0:this.head<this.tail?this.tail-this.head:this.capacityMask+1-(this.head-this.tail)},n.prototype.growArray=function(){this.head&&(this.list=this.copyArray(),this.head=0),this.tail=this.list.length,this.list.length*=2,this.capacityMask=this.capacityMask<<1|1},n.prototype.shrinkArray=function(){this.list.length>>>=1,this.capacityMask>>>=1},n.prototype.copyArray=function(){var e=[],t=this.list,r=t.length,s;for(s=this.head;s<r;s++)e.push(t[s]);for(s=0;s<this.tail;s++)e.push(t[s]);return e},n}();/** @license MIT License (c) copyright 2010 original author or authors */function h9e(n,e,t){return f9e(n,[e,t])}var f9e=function(n,e){return e.length===0||eee(e)?Ki():e.length===1?WN(n,e[0]):new d9e(n,e)},d9e=function(){function n(e,t){this.f=e,this.sources=t}return n.prototype.run=function(e,t){for(var r=this.sources.length,s=new Array(r),i=new Array(r),o=new Array(r),a=new p9e(this.f,o,i,e),l=void 0,c=0;c<r;++c)o[c]=new u9e,l=i[c]=new kB(c,a),s[c]=this.sources[c].run(l,t);return bC(s)},n}(),p9e=function(n){Yr(e,n);function e(t,r,s,i){var o=n.call(this,i)||this;return o.f=t,o.sinks=s,o.buffers=r,o}return e.prototype.event=function(t,r){if(!r.active){this.dispose(t,r.index);return}var s=this.buffers,i=s[r.index];if(i.push(r.value),i.length()===1){if(!b9e(s))return;m9e(this.f,t,s,this.sink),y9e(this.buffers,this.sinks)&&this.sink.end(t)}},e.prototype.dispose=function(t,r){var s=this.buffers[r];s.isEmpty()&&this.sink.end(t)},e}(Is),m9e=function(n,e,t,r){return r.event(e,oee(n,Jje(g9e,t)))},g9e=function(n){return n.shift()};function y9e(n,e){for(var t=0,r=n.length;t<r;++t)if(n[t].isEmpty()&&!e[t].active)return!0;return!1}function b9e(n){for(var e=0,t=n.length;e<t;++e)if(n[e].isEmpty())return!1;return!0}/** @license MIT License (c) copyright 2010-2016 original author or authors */var v9e=function(n){return Ni(n)?Ki():new w9e(n)},w9e=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){var r=new x9e(e,t);return Ww(r,this.source.run(r,t))},n}(),x9e=function(){function n(e,t){this.sink=e,this.scheduler=t,this.current=null,this.ended=!1}return n.prototype.event=function(e,t){this.disposeCurrent(e),this.current=new _9e(t,e,1/0,this,this.sink,this.scheduler)},n.prototype.end=function(e){this.ended=!0,this.checkEnd(e)},n.prototype.error=function(e,t){this.ended=!0,this.sink.error(e,t)},n.prototype.dispose=function(){return this.disposeCurrent(OE(this.scheduler))},n.prototype.disposeCurrent=function(e){if(this.current!==null)return this.current.dispose(e)},n.prototype.disposeInner=function(e,t){t.dispose(e),t===this.current&&(this.current=null)},n.prototype.checkEnd=function(e){this.ended&&this.current===null&&this.sink.end(e)},n.prototype.endInner=function(e,t){this.disposeInner(e,t),this.checkEnd(e)},n.prototype.errorInner=function(e,t,r){this.disposeInner(e,r),this.sink.error(e,t)},n}(),_9e=function(){function n(e,t,r,s,i,o){this.min=t,this.max=r,this.outer=s,this.sink=i,this.disposable=e.run(this,xB(t,o))}return n.prototype.event=function(e,t){var r=Math.max(0,e+this.min);r<this.max&&this.sink.event(r,t)},n.prototype.end=function(e){this.outer.endInner(e+this.min,this)},n.prototype.error=function(e,t){this.outer.errorInner(e+this.min,t,this)},n.prototype.dispose=function(e){fg(e,this.disposable,this.sink)},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function S9e(n,e){return iee.create(n,e)}var C9e=function(n){return gee(E9e,n)},gee=function(n,e){return Ni(e)?Ki():new k9e(n,e)},k9e=function(){function n(e,t){this.equals=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new T9e(this.equals,e),t)},n}(),T9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.equals=t,s.value=void 0,s.init=!0,s}return e.prototype.event=function(t,r){this.init?(this.init=!1,this.value=r,this.sink.event(t,r)):this.equals(this.value,r)||(this.value=r,this.sink.event(t,r))},e}(Is);function E9e(n,e){return n===e}/** @license MIT License (c) copyright 2010-2016 original author or authors */var yee=function(n,e){return new A9e(n,e)},bee=function(n,e){return new M9e(n,e)},I9e=function(n,e){return yee(cee(n),bee(n,e))},A9e=function(){function n(e,t){this.maxSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new UN,s=this.source.run(e,t),i=this.maxSignal.run(new R9e(e,r),t);return r.setDisposable(Ww(s,i)),r},n}(),M9e=function(){function n(e,t){this.minSignal=e,this.source=t}return n.prototype.run=function(e,t){var r=new $9e(this.minSignal,e,t),s=this.source.run(new N9e(r,e),t);return Ww(r,s)},n}(),N9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.min=t,s}return e.prototype.event=function(t,r){this.min.allow&&this.sink.event(t,r)},e}(Is),$9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.allow=!1,i.disposable=t.run(i,s),i}return e.prototype.event=function(){this.allow=!0,this.dispose()},e.prototype.end=function(){},e.prototype.dispose=function(){this.disposable.dispose()},e}(Is),R9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,t)||this;return s.disposable=r,s}return e.prototype.event=function(t){this.disposable.dispose(),this.sink.end(t)},e.prototype.end=function(){},e}(Is);/** @license MIT License (c) copyright 2010-2016 original author or authors */var P9e=function(n,e){return n<=0?e:new D9e(n,e)},D9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){var r=new O9e(this.dt,e,t);return Ww(r,this.source.run(r,t))},n}(),O9e=function(n){Yr(e,n);function e(t,r,s){var i=n.call(this,r)||this;return i.dt=t,i.scheduler=s,i.tasks=[],i}return e.prototype.dispose=function(){this.tasks.forEach(S8e)},e.prototype.event=function(t,r){this.tasks.push(UI(this.dt,SB(r,this.sink),this.scheduler))},e.prototype.end=function(){this.tasks.push(UI(this.dt,QQ(this.sink),this.scheduler))},e}(Is);/** @license MIT License (c) copyright 2010-2017 original author or authors */var vee=function(n,e){return Ni(e)?Ki():e instanceof vC?F9e(n,e):e instanceof VD?L9e(n,e):new VD(n,e)},F9e=function(n,e){return vC.create(e.f,vee(n,e.source))},L9e=function(n,e){return new VD(Math.max(n,e.period),e.source)},VD=function(){function n(e,t){this.period=e,this.source=t}return n.prototype.run=function(e,t){return this.source.run(new z9e(this.period,e),t)},n}(),z9e=function(n){Yr(e,n);function e(t,r){var s=n.call(this,r)||this;return s.time=0,s.period=t,s}return e.prototype.event=function(t,r){t>=this.time&&(this.time=t+this.period,this.sink.event(t,r))},e}(Is),B9e=function(n,e){return Ni(e)?Ki():new V9e(n,e)},V9e=function(){function n(e,t){this.dt=e,this.source=t}return n.prototype.run=function(e,t){return new U9e(this.dt,this.source,e,t)},n}(),U9e=function(){function n(e,t,r,s){this.dt=e,this.sink=r,this.scheduler=s,this.timer=null,this.disposable=t.run(this,s)}return n.prototype.event=function(e,t){this.clearTimer(),this.value=t,this.timer=UI(this.dt,new W9e(this,t),this.scheduler)},n.prototype.handleEventFromTask=function(e,t){this.clearTimer(),this.sink.event(e,t)},n.prototype.end=function(e){this.clearTimer()&&(this.sink.event(e,this.value),this.value=void 0),this.sink.end(e)},n.prototype.error=function(e,t){this.clearTimer(),this.sink.error(e,t)},n.prototype.dispose=function(){this.clearTimer(),this.disposable.dispose()},n.prototype.clearTimer=function(){return this.timer===null?!1:(this.timer.dispose(),this.timer=null,!0)},n}(),W9e=function(){function n(e,t){this.sink=e,this.value=t}return n.prototype.run=function(e){this.sink.handleEventFromTask(e,this.value)},n.prototype.error=function(e,t){this.sink.error(e,t)},n.prototype.dispose=function(){},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */var G9e=function(n){return Ni(n)?Ki():new H9e(n)},H9e=function(){function n(e){this.source=e}return n.prototype.run=function(e,t){return this.source.run(new j9e(e,t),t)},n}(),j9e=function(){function n(e,t){var r=this;this.eventBound=function(s){return r.sink.event(OE(r.scheduler),s)},this.endBound=function(){return r.sink.end(OE(r.scheduler))},this.errorBound=function(s){return r.sink.error(OE(r.scheduler),s)},this.sink=e,this.scheduler=t,this.queue=Promise.resolve()}return n.prototype.event=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.handlePromise(t)}).catch(this.errorBound)},n.prototype.end=function(){this.queue=this.queue.then(this.endBound).catch(this.errorBound)},n.prototype.error=function(e,t){var r=this;this.queue=this.queue.then(function(){return r.errorBound(t)}).catch(JQ)},n.prototype.handlePromise=function(e){return e.then(this.eventBound)},n}(),q9e=function(){function n(e){this.sink=e,this.active=!0}return n.prototype.event=function(e,t){this.active&&this.sink.event(e,t)},n.prototype.end=function(e){this.active&&(this.disable(),this.sink.end(e))},n.prototype.error=function(e,t){this.disable(),this.sink.error(e,t)},n.prototype.disable=function(){return this.active=!1,this.sink},n}();/** @license MIT License (c) copyright 2010-2016 original author or authors */function wee(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}function xee(n,e){try{e.end(n)}catch(t){e.error(n,t)}}/** @license MIT License (c) copyright 2010-2016 original author or authors */var X9e=function(n,e){return Ni(e)?Ki():new Z9e(n,e)},K9e=function(n){return new Y9e(n)},Y9e=function(){function n(e){this.value=e}return n.prototype.run=function(e,t){return BN(O8e(this.value,e),t)},n}(),Z9e=function(){function n(e,t){this.f=e,this.source=t}return n.prototype.run=function(e,t){return new J9e(this.f,this.source,e,t)},n}(),J9e=function(){function n(e,t,r,s){this.f=e,this.sink=new q9e(r),this.scheduler=s,this.disposable=t.run(this,s)}return n.prototype.event=function(e,t){wee(e,t,this.sink)},n.prototype.end=function(e){xee(e,this.sink)},n.prototype.error=function(e,t){var r=this.sink.disable();fg(e,this.disposable,this.sink),this._startNext(e,t,r)},n.prototype._startNext=function(e,t,r){try{this.disposable=this._continue(this.f,e,t,r)}catch(s){r.error(e,s)}},n.prototype._continue=function(e,t,r,s){return ree(s,this.scheduler,CB(t,e(r)))},n.prototype.dispose=function(){return this.disposable.dispose()},n}(),Q9e=function(n){return n instanceof dH||Ni(n)?n:new dH(n)},dH=function(){function n(e){this.source=new e7e(e)}return n.prototype.run=function(e,t){return this.source.run(e,t)},n}(),e7e=function(){function n(e){this.source=e,this.sinks=[],this.disposable=R_()}return n.prototype.run=function(e,t){var r=this.add(e);return r===1&&(this.disposable=this.source.run(this,t)),_B(new t7e(this,e))},n.prototype.dispose=function(){var e=this.disposable;return this.disposable=R_(),e.dispose()},n.prototype.add=function(e){return this.sinks=BQ(e,this.sinks),this.sinks.length},n.prototype.remove=function(e){var t=VQ(e,this.sinks);return t>=0&&(this.sinks=Qje(t,this.sinks)),this.sinks.length},n.prototype.event=function(e,t){var r=this.sinks;if(r.length===1)return r[0].event(e,t);for(var s=0;s<r.length;++s)wee(e,t,r[s])},n.prototype.end=function(e){for(var t=this.sinks,r=0;r<t.length;++r)xee(e,t[r])},n.prototype.error=function(e,t){for(var r=this.sinks,s=0;s<r.length;++s)r[s].error(e,t)},n}(),t7e=function(){function n(e,t){this.source=e,this.sink=t}return n.prototype.dispose=function(){this.source.remove(this.sink)===0&&this.source.dispose()},n}(),n7e=Tr(CB),r7e=zu(eqe),s7e=zu(rqe),i7e=Tr(lqe),pH=Tr(WN),o7e=Tr(pqe),mH=Tr(mqe),a7e=Tr(xqe),l7e=Tr(Eqe),c7e=Tr(see),u7e=Tr(Iqe),h7e=Tr(lee),f7e=zu(GN),gH=Tr(Aqe),d7e=zu(aee),yH=Tr(Oqe),p7e=zu(hee),m7e=zu(mee),g7e=Tr(s9e),y7e=zu(h9e),b7e=Tr(S9e),v7e=Tr(gee),w7e=Tr(dee),x7e=Tr(Wqe),_7e=zu(TB),S7e=Tr(Kqe),C7e=Tr(Jqe),k7e=Tr(t9e),bH=Tr(yee),T7e=Tr(bee),E7e=Tr(I9e),I7e=Tr(P9e),A7e=Tr(vee),M7e=Tr(B9e),N7e=Tr(X9e),vH=function(){var n=[];return[function(e){return $7e(n,e)},new R7e(n)]},$7e=function(n,e){return n.forEach(function(t){var r=t.sink,s=t.scheduler;return D7e(s.currentTime(),e,r)})},R7e=function(){function n(e){this.sinks=e}return n.prototype.run=function(e,t){var r={sink:e,scheduler:t};return this.sinks.push(r),new P7e(r,this.sinks)},n}(),P7e=function(){function n(e,t){this.sink=e,this.sinks=t}return n.prototype.dispose=function(){var e=this.sinks.indexOf(this.sink);e>=0&&this.sinks.splice(e,1)},n}();function D7e(n,e,t){try{t.event(n,e)}catch(r){t.error(n,r)}}const O7e=n=>{const e=new Set;do for(const t of Reflect.ownKeys(n))e.add([n,t]);while((n=Reflect.getPrototypeOf(n))&&n!==Object.prototype);return e};function F7e(n,{include:e,exclude:t}={}){const r=s=>{const i=o=>typeof o=="string"?s===o:o.test(s);return e?e.some(i):t?!t.some(i):!0};for(const[s,i]of O7e(n.constructor.prototype)){if(i==="constructor"||!r(i))continue;const o=Reflect.getOwnPropertyDescriptor(s,i);o&&typeof o.value=="function"&&(n[i]=n[i].bind(n))}return n}var UD={exports:{}},L7e=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,z7e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],_ee=function(e){var t=e,r=e.indexOf("["),s=e.indexOf("]");r!=-1&&s!=-1&&(e=e.substring(0,r)+e.substring(r,s).replace(/:/g,";")+e.substring(s,e.length));for(var i=L7e.exec(e||""),o={},a=14;a--;)o[z7e[a]]=i[a]||"";return r!=-1&&s!=-1&&(o.source=t,o.host=o.host.substring(1,o.host.length-1).replace(/;/g,":"),o.authority=o.authority.replace("[","").replace("]","").replace(/;/g,":"),o.ipv6uri=!0),o.pathNames=B7e(o,o.path),o.queryKey=V7e(o,o.query),o};function B7e(n,e){var t=/\/{2,9}/g,r=e.replace(t,"/").split("/");return(e.substr(0,1)=="/"||e.length===0)&&r.splice(0,1),e.substr(e.length-1,1)=="/"&&r.splice(r.length-1,1),r}function V7e(n,e){var t={};return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,function(r,s,i){s&&(t[s]=i)}),t}var WD={exports:{}},GD={exports:{}},D_=1e3,O_=D_*60,F_=O_*60,L_=F_*24,U7e=L_*365.25,W7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return G7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?j7e(n):H7e(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function G7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*U7e;case"days":case"day":case"d":return t*L_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*F_;case"minutes":case"minute":case"mins":case"min":case"m":return t*O_;case"seconds":case"second":case"secs":case"sec":case"s":return t*D_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function H7e(n){return n>=L_?Math.round(n/L_)+"d":n>=F_?Math.round(n/F_)+"h":n>=O_?Math.round(n/O_)+"m":n>=D_?Math.round(n/D_)+"s":n+"ms"}function j7e(n){return Qk(n,L_,"day")||Qk(n,F_,"hour")||Qk(n,O_,"minute")||Qk(n,D_,"second")||n+" ms"}function Qk(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=W7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];x=S.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(GD,GD.exports);var q7e=GD.exports;(function(n,e){e=n.exports=q7e,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(WD,WD.exports);var HN=WD.exports,X7e=_ee,wH=HN("socket.io-client:url"),K7e=Y7e;function Y7e(n,e){var t=n;e=e||typeof location<"u"&&location,n==null&&(n=e.protocol+"//"+e.host),typeof n=="string"&&(n.charAt(0)==="/"&&(n.charAt(1)==="/"?n=e.protocol+n:n=e.host+n),/^(https?|wss?):\/\//.test(n)||(wH("protocol-less url %s",n),typeof e<"u"?n=e.protocol+"//"+n:n="https://"+n),wH("parse %s",n),t=X7e(n)),t.port||(/^(http|ws)$/.test(t.protocol)?t.port="80":/^(http|ws)s$/.test(t.protocol)&&(t.port="443")),t.path=t.path||"/";var r=t.host.indexOf(":")!==-1,s=r?"["+t.host+"]":t.host;return t.id=t.protocol+"://"+s+":"+t.port,t.href=t.protocol+"://"+s+(e&&e.port===t.port?"":":"+t.port),t}var jN={},HD={exports:{}},jD={exports:{}},z_=1e3,B_=z_*60,V_=B_*60,U_=V_*24,Z7e=U_*365.25,J7e=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return Q7e(n);if(t==="number"&&isNaN(n)===!1)return e.long?tXe(n):eXe(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function Q7e(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*Z7e;case"days":case"day":case"d":return t*U_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*V_;case"minutes":case"minute":case"mins":case"min":case"m":return t*B_;case"seconds":case"second":case"secs":case"sec":case"s":return t*z_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function eXe(n){return n>=U_?Math.round(n/U_)+"d":n>=V_?Math.round(n/V_)+"h":n>=B_?Math.round(n/B_)+"m":n>=z_?Math.round(n/z_)+"s":n+"ms"}function tXe(n){return eT(n,U_,"day")||eT(n,V_,"hour")||eT(n,B_,"minute")||eT(n,z_,"second")||n+" ms"}function eT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=J7e,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];x=S.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(jD,jD.exports);var nXe=jD.exports;(function(n,e){e=n.exports=nXe,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(HD,HD.exports);var rXe=HD.exports,See={exports:{}};(function(n){n.exports=e;function e(r){if(r)return t(r)}function t(r){for(var s in e.prototype)r[s]=e.prototype[s];return r}e.prototype.on=e.prototype.addEventListener=function(r,s){return this._callbacks=this._callbacks||{},(this._callbacks["$"+r]=this._callbacks["$"+r]||[]).push(s),this},e.prototype.once=function(r,s){function i(){this.off(r,i),s.apply(this,arguments)}return i.fn=s,this.on(r,i),this},e.prototype.off=e.prototype.removeListener=e.prototype.removeAllListeners=e.prototype.removeEventListener=function(r,s){if(this._callbacks=this._callbacks||{},arguments.length==0)return this._callbacks={},this;var i=this._callbacks["$"+r];if(!i)return this;if(arguments.length==1)return delete this._callbacks["$"+r],this;for(var o,a=0;a<i.length;a++)if(o=i[a],o===s||o.fn===s){i.splice(a,1);break}return i.length===0&&delete this._callbacks["$"+r],this},e.prototype.emit=function(r){this._callbacks=this._callbacks||{};for(var s=new Array(arguments.length-1),i=this._callbacks["$"+r],o=1;o<arguments.length;o++)s[o-1]=arguments[o];if(i){i=i.slice(0);for(var o=0,a=i.length;o<a;++o)i[o].apply(this,s)}return this},e.prototype.listeners=function(r){return this._callbacks=this._callbacks||{},this._callbacks["$"+r]||[]},e.prototype.hasListeners=function(r){return!!this.listeners(r).length}})(See);var Gw=See.exports,qN={},sXe={}.toString,Cee=Array.isArray||function(n){return sXe.call(n)=="[object Array]"},kee=lXe,iXe=typeof Buffer=="function"&&typeof Buffer.isBuffer=="function",oXe=typeof ArrayBuffer=="function",aXe=function(n){return typeof ArrayBuffer.isView=="function"?ArrayBuffer.isView(n):n.buffer instanceof ArrayBuffer};function lXe(n){return iXe&&Buffer.isBuffer(n)||oXe&&(n instanceof ArrayBuffer||aXe(n))}var IB=Cee,Tee=kee,Eee=Object.prototype.toString,cXe=typeof Blob=="function"||typeof Blob<"u"&&Eee.call(Blob)==="[object BlobConstructor]",uXe=typeof File=="function"||typeof File<"u"&&Eee.call(File)==="[object FileConstructor]";qN.deconstructPacket=function(n){var e=[],t=n.data,r=n;return r.data=qD(t,e),r.attachments=e.length,{packet:r,buffers:e}};function qD(n,e){if(!n)return n;if(Tee(n)){var t={_placeholder:!0,num:e.length};return e.push(n),t}else if(IB(n)){for(var r=new Array(n.length),s=0;s<n.length;s++)r[s]=qD(n[s],e);return r}else if(typeof n=="object"&&!(n instanceof Date)){var r={};for(var i in n)r[i]=qD(n[i],e);return r}return n}qN.reconstructPacket=function(n,e){return n.data=XD(n.data,e),n.attachments=void 0,n};function XD(n,e){if(!n)return n;if(n&&n._placeholder===!0){var t=typeof n.num=="number"&&n.num>=0&&n.num<e.length;if(t)return e[n.num];throw new Error("illegal attachments")}else if(IB(n))for(var r=0;r<n.length;r++)n[r]=XD(n[r],e);else if(typeof n=="object")for(var s in n)n[s]=XD(n[s],e);return n}qN.removeBlobs=function(n,e){function t(i,o,a){if(!i)return i;if(cXe&&i instanceof Blob||uXe&&i instanceof File){r++;var l=new FileReader;l.onload=function(){a?a[o]=this.result:s=this.result,--r||e(s)},l.readAsArrayBuffer(i)}else if(IB(i))for(var c=0;c<i.length;c++)t(i[c],c,i);else if(typeof i=="object"&&!Tee(i))for(var u in i)t(i[u],u,i)}var r=0,s=n;t(s),r||e(s)};(function(n){var e=rXe("socket.io-parser"),t=Gw,r=qN,s=Cee,i=kee;n.protocol=4,n.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],n.CONNECT=0,n.DISCONNECT=1,n.EVENT=2,n.ACK=3,n.ERROR=4,n.BINARY_EVENT=5,n.BINARY_ACK=6,n.Encoder=o,n.Decoder=h;function o(){}var a=n.ERROR+'"encode error"';o.prototype.encode=function(g,y){if(e("encoding packet %j",g),n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)u(g,y);else{var b=l(g);y([b])}};function l(g){var y=""+g.type;if((n.BINARY_EVENT===g.type||n.BINARY_ACK===g.type)&&(y+=g.attachments+"-"),g.nsp&&g.nsp!=="/"&&(y+=g.nsp+","),g.id!=null&&(y+=g.id),g.data!=null){var b=c(g.data);if(b!==!1)y+=b;else return a}return e("encoded %j as %s",g,y),y}function c(g){try{return JSON.stringify(g)}catch{return!1}}function u(g,y){function b(x){var w=r.deconstructPacket(x),S=l(w.packet),C=w.buffers;C.unshift(S),y(C)}r.removeBlobs(g,b)}function h(){this.reconstructor=null}t(h.prototype),h.prototype.add=function(g){var y;if(typeof g=="string"){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");y=f(g),n.BINARY_EVENT===y.type||n.BINARY_ACK===y.type?(this.reconstructor=new p(y),this.reconstructor.reconPack.attachments===0&&this.emit("decoded",y)):this.emit("decoded",y)}else if(i(g)||g.base64)if(this.reconstructor)y=this.reconstructor.takeBinaryData(g),y&&(this.reconstructor=null,this.emit("decoded",y));else throw new Error("got binary data when not reconstructing a packet");else throw new Error("Unknown type: "+g)};function f(g){var y=0,b={type:Number(g.charAt(0))};if(n.types[b.type]==null)return m("unknown packet type "+b.type);if(n.BINARY_EVENT===b.type||n.BINARY_ACK===b.type){for(var x=y+1;g.charAt(++y)!=="-"&&y!=g.length;);var w=g.substring(x,y);if(w!=Number(w)||g.charAt(y)!=="-")throw new Error("Illegal attachments");b.attachments=Number(w)}if(g.charAt(y+1)==="/"){for(var x=y+1;++y;){var S=g.charAt(y);if(S===","||y===g.length)break}b.nsp=g.substring(x,y)}else b.nsp="/";var C=g.charAt(y+1);if(C!==""&&Number(C)==C){for(var x=y+1;++y;){var S=g.charAt(y);if(S==null||Number(S)!=S){--y;break}if(y===g.length)break}b.id=Number(g.substring(x,y+1))}if(g.charAt(++y)){var k=d(g.substr(y)),A=k!==!1&&(b.type===n.ERROR||s(k));if(A)b.data=k;else return m("invalid payload")}return e("decoded %s as %j",g,b),b}function d(g){try{return JSON.parse(g)}catch{return!1}}h.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()};function p(g){this.reconPack=g,this.buffers=[]}p.prototype.takeBinaryData=function(g){if(this.buffers.push(g),this.buffers.length===this.reconPack.attachments){var y=r.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),y}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]};function m(g){return{type:n.ERROR,data:"parser error: "+g}}})(jN);var AB={exports:{}},XN={},KD={exports:{}};try{KD.exports=typeof XMLHttpRequest<"u"&&"withCredentials"in new XMLHttpRequest}catch{KD.exports=!1}var hXe=KD.exports,MB=function(){return typeof self<"u"?self:typeof window<"u"?window:Function("return this")()}(),fXe=hXe,dXe=MB,NB=function(n){var e=n.xdomain,t=n.xscheme,r=n.enablesXDR;try{if(typeof XMLHttpRequest<"u"&&(!e||fXe))return new XMLHttpRequest}catch{}try{if(typeof XDomainRequest<"u"&&!t&&r)return new XDomainRequest}catch{}if(!e)try{return new dXe[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP")}catch{}},$B={exports:{}},jy={},pXe=Object.keys||function(e){var t=[],r=Object.prototype.hasOwnProperty;for(var s in e)r.call(e,s)&&t.push(s);return t},mXe={}.toString,gXe=Array.isArray||function(n){return mXe.call(n)=="[object Array]"},yXe=gXe,Iee=Object.prototype.toString,bXe=typeof Blob=="function"||typeof Blob<"u"&&Iee.call(Blob)==="[object BlobConstructor]",vXe=typeof File=="function"||typeof File<"u"&&Iee.call(File)==="[object FileConstructor]",Aee=FE;function FE(n){if(!n||typeof n!="object")return!1;if(yXe(n)){for(var e=0,t=n.length;e<t;e++)if(FE(n[e]))return!0;return!1}if(typeof Buffer=="function"&&Buffer.isBuffer&&Buffer.isBuffer(n)||typeof ArrayBuffer=="function"&&n instanceof ArrayBuffer||bXe&&n instanceof Blob||vXe&&n instanceof File)return!0;if(n.toJSON&&typeof n.toJSON=="function"&&arguments.length===1)return FE(n.toJSON(),!0);for(var r in n)if(Object.prototype.hasOwnProperty.call(n,r)&&FE(n[r]))return!0;return!1}var wXe=function(n,e,t){var r=n.byteLength;if(e=e||0,t=t||r,n.slice)return n.slice(e,t);if(e<0&&(e+=r),t<0&&(t+=r),t>r&&(t=r),e>=r||e>=t||r===0)return new ArrayBuffer(0);for(var s=new Uint8Array(n),i=new Uint8Array(t-e),o=e,a=0;o<t;o++,a++)i[a]=s[o];return i.buffer},xXe=_Xe;function _Xe(n,e,t){var r=!1;return t=t||SXe,s.count=n,n===0?e():s;function s(i,o){if(s.count<=0)throw new Error("after called too many times");--s.count,i?(r=!0,e(i),e=t):s.count===0&&!r&&e(null,o)}}function SXe(){}/*! https://mths.be/utf8js v2.1.2 by @mathias */var Ed=String.fromCharCode;function Mee(n){for(var e=[],t=0,r=n.length,s,i;t<r;)s=n.charCodeAt(t++),s>=55296&&s<=56319&&t<r?(i=n.charCodeAt(t++),(i&64512)==56320?e.push(((s&1023)<<10)+(i&1023)+65536):(e.push(s),t--)):e.push(s);return e}function CXe(n){for(var e=n.length,t=-1,r,s="";++t<e;)r=n[t],r>65535&&(r-=65536,s+=Ed(r>>>10&1023|55296),r=56320|r&1023),s+=Ed(r);return s}function Nee(n,e){if(n>=55296&&n<=57343){if(e)throw Error("Lone surrogate U+"+n.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function b3(n,e){return Ed(n>>e&63|128)}function kXe(n,e){if(!(n&4294967168))return Ed(n);var t="";return n&4294965248?n&4294901760?n&4292870144||(t=Ed(n>>18&7|240),t+=b3(n,12),t+=b3(n,6)):(Nee(n,e)||(n=65533),t=Ed(n>>12&15|224),t+=b3(n,6)):t=Ed(n>>6&31|192),t+=Ed(n&63|128),t}function TXe(n,e){e=e||{};for(var t=e.strict!==!1,r=Mee(n),s=r.length,i=-1,o,a="";++i<s;)o=r[i],a+=kXe(o,t);return a}function N0(){if(Nd>=GI)throw Error("Invalid byte index");var n=WI[Nd]&255;if(Nd++,(n&192)==128)return n&63;throw Error("Invalid continuation byte")}function EXe(n){var e,t,r,s,i;if(Nd>GI)throw Error("Invalid byte index");if(Nd==GI)return!1;if(e=WI[Nd]&255,Nd++,!(e&128))return e;if((e&224)==192){if(t=N0(),i=(e&31)<<6|t,i>=128)return i;throw Error("Invalid continuation byte")}if((e&240)==224){if(t=N0(),r=N0(),i=(e&15)<<12|t<<6|r,i>=2048)return Nee(i,n)?i:65533;throw Error("Invalid continuation byte")}if((e&248)==240&&(t=N0(),r=N0(),s=N0(),i=(e&7)<<18|t<<12|r<<6|s,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}var WI,GI,Nd;function IXe(n,e){e=e||{};var t=e.strict!==!1;WI=Mee(n),GI=WI.length,Nd=0;for(var r=[],s;(s=EXe(t))!==!1;)r.push(s);return CXe(r)}var AXe={version:"2.1.2",encode:TXe,decode:IXe},tT={},xH;function MXe(){return xH||(xH=1,function(n){tT.encode=function(e){var t=new Uint8Array(e),r,s=t.length,i="";for(r=0;r<s;r+=3)i+=n[t[r]>>2],i+=n[(t[r]&3)<<4|t[r+1]>>4],i+=n[(t[r+1]&15)<<2|t[r+2]>>6],i+=n[t[r+2]&63];return s%3===2?i=i.substring(0,i.length-1)+"=":s%3===1&&(i=i.substring(0,i.length-2)+"=="),i},tT.decode=function(e){var t=e.length*.75,r=e.length,s,i=0,o,a,l,c;e[e.length-1]==="="&&(t--,e[e.length-2]==="="&&t--);var u=new ArrayBuffer(t),h=new Uint8Array(u);for(s=0;s<r;s+=4)o=n.indexOf(e[s]),a=n.indexOf(e[s+1]),l=n.indexOf(e[s+2]),c=n.indexOf(e[s+3]),h[i++]=o<<2|a>>4,h[i++]=(a&15)<<4|l>>2,h[i++]=(l&3)<<6|c&63;return u}}("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")),tT}var v3,_H;function NXe(){if(_H)return v3;_H=1;var n=typeof n<"u"?n:typeof WebKitBlobBuilder<"u"?WebKitBlobBuilder:typeof MSBlobBuilder<"u"?MSBlobBuilder:typeof MozBlobBuilder<"u"?MozBlobBuilder:!1,e=function(){try{var a=new Blob(["hi"]);return a.size===2}catch{return!1}}(),t=e&&function(){try{var a=new Blob([new Uint8Array([1,2])]);return a.size===2}catch{return!1}}(),r=n&&n.prototype.append&&n.prototype.getBlob;function s(a){return a.map(function(l){if(l.buffer instanceof ArrayBuffer){var c=l.buffer;if(l.byteLength!==c.byteLength){var u=new Uint8Array(l.byteLength);u.set(new Uint8Array(c,l.byteOffset,l.byteLength)),c=u.buffer}return c}return l})}function i(a,l){l=l||{};var c=new n;return s(a).forEach(function(u){c.append(u)}),l.type?c.getBlob(l.type):c.getBlob()}function o(a,l){return new Blob(s(a),l||{})}return typeof Blob<"u"&&(i.prototype=Blob.prototype,o.prototype=Blob.prototype),v3=function(){return e?t?Blob:o:r?i:void 0}(),v3}(function(n){var e=pXe,t=Aee,r=wXe,s=xXe,i=AXe,o;typeof ArrayBuffer<"u"&&(o=MXe());var a=typeof navigator<"u"&&/Android/i.test(navigator.userAgent),l=typeof navigator<"u"&&/PhantomJS/i.test(navigator.userAgent),c=a||l;n.protocol=3;var u=n.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},h=e(u),f={type:"error",data:"parser error"},d=NXe();n.encodePacket=function(w,S,C,k){typeof S=="function"&&(k=S,S=!1),typeof C=="function"&&(k=C,C=null);var A=w.data===void 0?void 0:w.data.buffer||w.data;if(typeof ArrayBuffer<"u"&&A instanceof ArrayBuffer)return m(w,S,k);if(typeof d<"u"&&A instanceof d)return y(w,S,k);if(A&&A.base64)return p(w,k);var M=u[w.type];return w.data!==void 0&&(M+=C?i.encode(String(w.data),{strict:!1}):String(w.data)),k(""+M)};function p(w,S){var C="b"+n.packets[w.type]+w.data.data;return S(C)}function m(w,S,C){if(!S)return n.encodeBase64Packet(w,C);var k=w.data,A=new Uint8Array(k),M=new Uint8Array(1+k.byteLength);M[0]=u[w.type];for(var E=0;E<A.length;E++)M[E+1]=A[E];return C(M.buffer)}function g(w,S,C){if(!S)return n.encodeBase64Packet(w,C);var k=new FileReader;return k.onload=function(){n.encodePacket({type:w.type,data:k.result},S,!0,C)},k.readAsArrayBuffer(w.data)}function y(w,S,C){if(!S)return n.encodeBase64Packet(w,C);if(c)return g(w,S,C);var k=new Uint8Array(1);k[0]=u[w.type];var A=new d([k.buffer,w.data]);return C(A)}n.encodeBase64Packet=function(w,S){var C="b"+n.packets[w.type];if(typeof d<"u"&&w.data instanceof d){var k=new FileReader;return k.onload=function(){var O=k.result.split(",")[1];S(C+O)},k.readAsDataURL(w.data)}var A;try{A=String.fromCharCode.apply(null,new Uint8Array(w.data))}catch{for(var M=new Uint8Array(w.data),E=new Array(M.length),N=0;N<M.length;N++)E[N]=M[N];A=String.fromCharCode.apply(null,E)}return C+=btoa(A),S(C)},n.decodePacket=function(w,S,C){if(w===void 0)return f;if(typeof w=="string"){if(w.charAt(0)==="b")return n.decodeBase64Packet(w.substr(1),S);if(C&&(w=b(w),w===!1))return f;var A=w.charAt(0);return Number(A)!=A||!h[A]?f:w.length>1?{type:h[A],data:w.substring(1)}:{type:h[A]}}var k=new Uint8Array(w),A=k[0],M=r(w,1);return d&&S==="blob"&&(M=new d([M])),{type:h[A],data:M}};function b(w){try{w=i.decode(w,{strict:!1})}catch{return!1}return w}n.decodeBase64Packet=function(w,S){var C=h[w.charAt(0)];if(!o)return{type:C,data:{base64:!0,data:w.substr(1)}};var k=o.decode(w.substr(1));return S==="blob"&&d&&(k=new d([k])),{type:C,data:k}},n.encodePayload=function(w,S,C){typeof S=="function"&&(C=S,S=null);var k=t(w);if(S&&k)return d&&!c?n.encodePayloadAsBlob(w,C):n.encodePayloadAsArrayBuffer(w,C);if(!w.length)return C("0:");function A(E){return E.length+":"+E}function M(E,N){n.encodePacket(E,k?S:!1,!1,function(O){N(null,A(O))})}x(w,M,function(E,N){return C(N.join(""))})};function x(w,S,C){for(var k=new Array(w.length),A=s(w.length,C),M=function(N,O,R){S(O,function(D,z){k[N]=z,R(D,k)})},E=0;E<w.length;E++)M(E,w[E],A)}n.decodePayload=function(w,S,C){if(typeof w!="string")return n.decodePayloadAsBinary(w,S,C);typeof S=="function"&&(C=S,S=null);var k;if(w==="")return C(f,0,1);for(var A="",M,E,N=0,O=w.length;N<O;N++){var R=w.charAt(N);if(R!==":"){A+=R;continue}if(A===""||A!=(M=Number(A))||(E=w.substr(N+1,M),A!=E.length))return C(f,0,1);if(E.length){if(k=n.decodePacket(E,S,!1),f.type===k.type&&f.data===k.data)return C(f,0,1);var D=C(k,N+M,O);if(D===!1)return}N+=M,A=""}if(A!=="")return C(f,0,1)},n.encodePayloadAsArrayBuffer=function(w,S){if(!w.length)return S(new ArrayBuffer(0));function C(k,A){n.encodePacket(k,!0,!0,function(M){return A(null,M)})}x(w,C,function(k,A){var M=A.reduce(function(O,R){var D;return typeof R=="string"?D=R.length:D=R.byteLength,O+D.toString().length+D+2},0),E=new Uint8Array(M),N=0;return A.forEach(function(O){var R=typeof O=="string",D=O;if(R){for(var X=new Uint8Array(O.length),z=0;z<O.length;z++)X[z]=O.charCodeAt(z);D=X.buffer}R?E[N++]=0:E[N++]=1;for(var B=D.byteLength.toString(),z=0;z<B.length;z++)E[N++]=parseInt(B[z]);E[N++]=255;for(var X=new Uint8Array(D),z=0;z<X.length;z++)E[N++]=X[z]}),S(E.buffer)})},n.encodePayloadAsBlob=function(w,S){function C(k,A){n.encodePacket(k,!0,!0,function(M){var E=new Uint8Array(1);if(E[0]=1,typeof M=="string"){for(var N=new Uint8Array(M.length),O=0;O<M.length;O++)N[O]=M.charCodeAt(O);M=N.buffer,E[0]=0}for(var R=M instanceof ArrayBuffer?M.byteLength:M.size,D=R.toString(),z=new Uint8Array(D.length+1),O=0;O<D.length;O++)z[O]=parseInt(D[O]);if(z[D.length]=255,d){var B=new d([E.buffer,z.buffer,M]);A(null,B)}})}x(w,C,function(k,A){return S(new d(A))})},n.decodePayloadAsBinary=function(w,S,C){typeof S=="function"&&(C=S,S=null);for(var k=w,A=[];k.byteLength>0;){for(var M=new Uint8Array(k),E=M[0]===0,N="",O=1;M[O]!==255;O++){if(N.length>310)return C(f,0,1);N+=M[O]}k=r(k,2+N.length),N=parseInt(N);var R=r(k,0,N);if(E)try{R=String.fromCharCode.apply(null,new Uint8Array(R))}catch{var D=new Uint8Array(R);R="";for(var O=0;O<D.length;O++)R+=String.fromCharCode(D[O])}A.push(R),k=r(k,N)}var z=A.length;A.forEach(function(B,X){C(n.decodePacket(B,S,!0),X,z)})}})(jy);var w3,SH;function RB(){if(SH)return w3;SH=1;var n=jy,e=Gw;w3=t;function t(r){this.path=r.path,this.hostname=r.hostname,this.port=r.port,this.secure=r.secure,this.query=r.query,this.timestampParam=r.timestampParam,this.timestampRequests=r.timestampRequests,this.readyState="",this.agent=r.agent||!1,this.socket=r.socket,this.enablesXDR=r.enablesXDR,this.withCredentials=r.withCredentials,this.pfx=r.pfx,this.key=r.key,this.passphrase=r.passphrase,this.cert=r.cert,this.ca=r.ca,this.ciphers=r.ciphers,this.rejectUnauthorized=r.rejectUnauthorized,this.forceNode=r.forceNode,this.isReactNative=r.isReactNative,this.extraHeaders=r.extraHeaders,this.localAddress=r.localAddress}return e(t.prototype),t.prototype.onError=function(r,s){var i=new Error(r);return i.type="TransportError",i.description=s,this.emit("error",i),this},t.prototype.open=function(){return(this.readyState==="closed"||this.readyState==="")&&(this.readyState="opening",this.doOpen()),this},t.prototype.close=function(){return(this.readyState==="opening"||this.readyState==="open")&&(this.doClose(),this.onClose()),this},t.prototype.send=function(r){if(this.readyState==="open")this.write(r);else throw new Error("Transport not open")},t.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},t.prototype.onData=function(r){var s=n.decodePacket(r,this.socket.binaryType);this.onPacket(s)},t.prototype.onPacket=function(r){this.emit("packet",r)},t.prototype.onClose=function(){this.readyState="closed",this.emit("close")},w3}var Hw={};Hw.encode=function(n){var e="";for(var t in n)n.hasOwnProperty(t)&&(e.length&&(e+="&"),e+=encodeURIComponent(t)+"="+encodeURIComponent(n[t]));return e};Hw.decode=function(n){for(var e={},t=n.split("&"),r=0,s=t.length;r<s;r++){var i=t[r].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e};var KN=function(n,e){var t=function(){};t.prototype=e.prototype,n.prototype=new t,n.prototype.constructor=n},$ee="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),HI=64,Ree={},CH=0,$d=0,kH;function YD(n){var e="";do e=$ee[n%HI]+e,n=Math.floor(n/HI);while(n>0);return e}function $Xe(n){var e=0;for($d=0;$d<n.length;$d++)e=e*HI+Ree[n.charAt($d)];return e}function PB(){var n=YD(+new Date);return n!==kH?(CH=0,kH=n):n+"."+YD(CH++)}for(;$d<HI;$d++)Ree[$ee[$d]]=$d;PB.encode=YD;PB.decode=$Xe;var Pee=PB,ZD={exports:{}},JD={exports:{}},W_=1e3,G_=W_*60,H_=G_*60,j_=H_*24,RXe=j_*365.25,PXe=function(n,e){e=e||{};var t=typeof n;if(t==="string"&&n.length>0)return DXe(n);if(t==="number"&&isNaN(n)===!1)return e.long?FXe(n):OXe(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))};function DXe(n){if(n=String(n),!(n.length>100)){var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return t*RXe;case"days":case"day":case"d":return t*j_;case"hours":case"hour":case"hrs":case"hr":case"h":return t*H_;case"minutes":case"minute":case"mins":case"min":case"m":return t*G_;case"seconds":case"second":case"secs":case"sec":case"s":return t*W_;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function OXe(n){return n>=j_?Math.round(n/j_)+"d":n>=H_?Math.round(n/H_)+"h":n>=G_?Math.round(n/G_)+"m":n>=W_?Math.round(n/W_)+"s":n+"ms"}function FXe(n){return nT(n,j_,"day")||nT(n,H_,"hour")||nT(n,G_,"minute")||nT(n,W_,"second")||n+" ms"}function nT(n,e,t){if(!(n<e))return n<e*1.5?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}(function(n,e){e=n.exports=r.debug=r.default=r,e.coerce=l,e.disable=o,e.enable=i,e.enabled=a,e.humanize=PXe,e.instances=[],e.names=[],e.skips=[],e.formatters={};function t(c){var u=0,h;for(h in c)u=(u<<5)-u+c.charCodeAt(h),u|=0;return e.colors[Math.abs(u)%e.colors.length]}function r(c){var u;function h(){if(h.enabled){var f=h,d=+new Date,p=d-(u||d);f.diff=p,f.prev=u,f.curr=d,u=d;for(var m=new Array(arguments.length),g=0;g<m.length;g++)m[g]=arguments[g];m[0]=e.coerce(m[0]),typeof m[0]!="string"&&m.unshift("%O");var y=0;m[0]=m[0].replace(/%([a-zA-Z%])/g,function(x,w){if(x==="%%")return x;y++;var S=e.formatters[w];if(typeof S=="function"){var C=m[y];x=S.call(f,C),m.splice(y,1),y--}return x}),e.formatArgs.call(f,m);var b=h.log||e.log||console.log.bind(console);b.apply(f,m)}}return h.namespace=c,h.enabled=e.enabled(c),h.useColors=e.useColors(),h.color=t(c),h.destroy=s,typeof e.init=="function"&&e.init(h),e.instances.push(h),h}function s(){var c=e.instances.indexOf(this);return c!==-1?(e.instances.splice(c,1),!0):!1}function i(c){e.save(c),e.names=[],e.skips=[];var u,h=(typeof c=="string"?c:"").split(/[\s,]+/),f=h.length;for(u=0;u<f;u++)h[u]&&(c=h[u].replace(/\*/g,".*?"),c[0]==="-"?e.skips.push(new RegExp("^"+c.substr(1)+"$")):e.names.push(new RegExp("^"+c+"$")));for(u=0;u<e.instances.length;u++){var d=e.instances[u];d.enabled=e.enabled(d.namespace)}}function o(){e.enable("")}function a(c){if(c[c.length-1]==="*")return!0;var u,h;for(u=0,h=e.skips.length;u<h;u++)if(e.skips[u].test(c))return!1;for(u=0,h=e.names.length;u<h;u++)if(e.names[u].test(c))return!0;return!1}function l(c){return c instanceof Error?c.stack||c.message:c}})(JD,JD.exports);var LXe=JD.exports;(function(n,e){e=n.exports=LXe,e.log=s,e.formatArgs=r,e.save=i,e.load=o,e.useColors=t,e.storage=typeof chrome<"u"&&typeof chrome.storage<"u"?chrome.storage.local:a(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&window.process.type==="renderer"?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}e.formatters.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}};function r(l){var c=this.useColors;if(l[0]=(c?"%c":"")+this.namespace+(c?" %c":" ")+l[0]+(c?"%c ":" ")+"+"+e.humanize(this.diff),!!c){var u="color: "+this.color;l.splice(1,0,u,"color: inherit");var h=0,f=0;l[0].replace(/%[a-zA-Z%]/g,function(d){d!=="%%"&&(h++,d==="%c"&&(f=h))}),l.splice(f,0,u)}}function s(){return typeof console=="object"&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function i(l){try{l==null?e.storage.removeItem("debug"):e.storage.debug=l}catch{}}function o(){var l;try{l=e.storage.debug}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}e.enable(o());function a(){try{return window.localStorage}catch{}}})(ZD,ZD.exports);var YN=ZD.exports,Dee=RB(),zXe=Hw,Oee=jy,BXe=KN,VXe=Pee,ou=YN("engine.io-client:polling"),Fee=Rh,UXe=function(){var n=NB,e=new n({xdomain:!1});return e.responseType!=null}();function Rh(n){var e=n&&n.forceBase64;(!UXe||e)&&(this.supportsBinary=!1),Dee.call(this,n)}BXe(Rh,Dee);Rh.prototype.name="polling";Rh.prototype.doOpen=function(){this.poll()};Rh.prototype.pause=function(n){var e=this;this.readyState="pausing";function t(){ou("paused"),e.readyState="paused",n()}if(this.polling||!this.writable){var r=0;this.polling&&(ou("we are currently polling - waiting to pause"),r++,this.once("pollComplete",function(){ou("pre-pause polling complete"),--r||t()})),this.writable||(ou("we are currently writing - waiting to pause"),r++,this.once("drain",function(){ou("pre-pause writing complete"),--r||t()}))}else t()};Rh.prototype.poll=function(){ou("polling"),this.polling=!0,this.doPoll(),this.emit("poll")};Rh.prototype.onData=function(n){var e=this;ou("polling got data %s",n);var t=function(r,s,i){if(e.readyState==="opening"&&r.type==="open"&&e.onOpen(),r.type==="close")return e.onClose(),!1;e.onPacket(r)};Oee.decodePayload(n,this.socket.binaryType,t),this.readyState!=="closed"&&(this.polling=!1,this.emit("pollComplete"),this.readyState==="open"?this.poll():ou('ignoring poll - transport state "%s"',this.readyState))};Rh.prototype.doClose=function(){var n=this;function e(){ou("writing close packet"),n.write([{type:"close"}])}this.readyState==="open"?(ou("transport open - closing"),e()):(ou("transport not open - deferring close"),this.once("open",e))};Rh.prototype.write=function(n){var e=this;this.writable=!1;var t=function(){e.writable=!0,e.emit("drain")};Oee.encodePayload(n,this.supportsBinary,function(r){e.doWrite(r,t)})};Rh.prototype.uri=function(){var n=this.query||{},e=this.secure?"https":"http",t="";this.timestampRequests!==!1&&(n[this.timestampParam]=VXe()),!this.supportsBinary&&!n.sid&&(n.b64=1),n=zXe.encode(n),this.port&&(e==="https"&&Number(this.port)!==443||e==="http"&&Number(this.port)!==80)&&(t=":"+this.port),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};var WXe=NB,Lee=Fee,GXe=Gw,HXe=KN,QD=YN("engine.io-client:polling-xhr"),jXe=MB;$B.exports=jw;$B.exports.Request=Hi;function TH(){}function jw(n){if(Lee.call(this,n),this.requestTimeout=n.requestTimeout,this.extraHeaders=n.extraHeaders,typeof location<"u"){var e=location.protocol==="https:",t=location.port;t||(t=e?443:80),this.xd=typeof location<"u"&&n.hostname!==location.hostname||t!==n.port,this.xs=n.secure!==e}}HXe(jw,Lee);jw.prototype.supportsBinary=!0;jw.prototype.request=function(n){return n=n||{},n.uri=this.uri(),n.xd=this.xd,n.xs=this.xs,n.agent=this.agent||!1,n.supportsBinary=this.supportsBinary,n.enablesXDR=this.enablesXDR,n.withCredentials=this.withCredentials,n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized,n.requestTimeout=this.requestTimeout,n.extraHeaders=this.extraHeaders,new Hi(n)};jw.prototype.doWrite=function(n,e){var t=typeof n!="string"&&n!==void 0,r=this.request({method:"POST",data:n,isBinary:t}),s=this;r.on("success",e),r.on("error",function(i){s.onError("xhr post error",i)}),this.sendXhr=r};jw.prototype.doPoll=function(){QD("xhr poll");var n=this.request(),e=this;n.on("data",function(t){e.onData(t)}),n.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=n};function Hi(n){this.method=n.method||"GET",this.uri=n.uri,this.xd=!!n.xd,this.xs=!!n.xs,this.async=n.async!==!1,this.data=n.data!==void 0?n.data:null,this.agent=n.agent,this.isBinary=n.isBinary,this.supportsBinary=n.supportsBinary,this.enablesXDR=n.enablesXDR,this.withCredentials=n.withCredentials,this.requestTimeout=n.requestTimeout,this.pfx=n.pfx,this.key=n.key,this.passphrase=n.passphrase,this.cert=n.cert,this.ca=n.ca,this.ciphers=n.ciphers,this.rejectUnauthorized=n.rejectUnauthorized,this.extraHeaders=n.extraHeaders,this.create()}GXe(Hi.prototype);Hi.prototype.create=function(){var n={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};n.pfx=this.pfx,n.key=this.key,n.passphrase=this.passphrase,n.cert=this.cert,n.ca=this.ca,n.ciphers=this.ciphers,n.rejectUnauthorized=this.rejectUnauthorized;var e=this.xhr=new WXe(n),t=this;try{QD("xhr open %s: %s",this.method,this.uri),e.open(this.method,this.uri,this.async);try{if(this.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(var r in this.extraHeaders)this.extraHeaders.hasOwnProperty(r)&&e.setRequestHeader(r,this.extraHeaders[r])}}catch{}if(this.method==="POST")try{this.isBinary?e.setRequestHeader("Content-type","application/octet-stream"):e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch{}try{e.setRequestHeader("Accept","*/*")}catch{}"withCredentials"in e&&(e.withCredentials=this.withCredentials),this.requestTimeout&&(e.timeout=this.requestTimeout),this.hasXDR()?(e.onload=function(){t.onLoad()},e.onerror=function(){t.onError(e.responseText)}):e.onreadystatechange=function(){if(e.readyState===2)try{var s=e.getResponseHeader("Content-Type");(t.supportsBinary&&s==="application/octet-stream"||s==="application/octet-stream; charset=UTF-8")&&(e.responseType="arraybuffer")}catch{}e.readyState===4&&(e.status===200||e.status===1223?t.onLoad():setTimeout(function(){t.onError(typeof e.status=="number"?e.status:0)},0))},QD("xhr data %s",this.data),e.send(this.data)}catch(s){setTimeout(function(){t.onError(s)},0);return}typeof document<"u"&&(this.index=Hi.requestsCount++,Hi.requests[this.index]=this)};Hi.prototype.onSuccess=function(){this.emit("success"),this.cleanup()};Hi.prototype.onData=function(n){this.emit("data",n),this.onSuccess()};Hi.prototype.onError=function(n){this.emit("error",n),this.cleanup(!0)};Hi.prototype.cleanup=function(n){if(!(typeof this.xhr>"u"||this.xhr===null)){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=TH:this.xhr.onreadystatechange=TH,n)try{this.xhr.abort()}catch{}typeof document<"u"&&delete Hi.requests[this.index],this.xhr=null}};Hi.prototype.onLoad=function(){var n;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch{}e==="application/octet-stream"||e==="application/octet-stream; charset=UTF-8"?n=this.xhr.response||this.xhr.responseText:n=this.xhr.responseText}catch(t){this.onError(t)}n!=null&&this.onData(n)};Hi.prototype.hasXDR=function(){return typeof XDomainRequest<"u"&&!this.xs&&this.enablesXDR};Hi.prototype.abort=function(){this.cleanup()};Hi.requestsCount=0;Hi.requests={};if(typeof document<"u"){if(typeof attachEvent=="function")attachEvent("onunload",EH);else if(typeof addEventListener=="function"){var qXe="onpagehide"in jXe?"pagehide":"unload";addEventListener(qXe,EH,!1)}}function EH(){for(var n in Hi.requests)Hi.requests.hasOwnProperty(n)&&Hi.requests[n].abort()}var XXe=$B.exports,DB=Fee,KXe=KN,IH=MB,YXe=qw,ZXe=/\n/g,JXe=/\\n/g,rT;function QXe(){}function qw(n){DB.call(this,n),this.query=this.query||{},rT||(rT=IH.___eio=IH.___eio||[]),this.index=rT.length;var e=this;rT.push(function(t){e.onData(t)}),this.query.j=this.index,typeof addEventListener=="function"&&addEventListener("beforeunload",function(){e.script&&(e.script.onerror=QXe)},!1)}KXe(qw,DB);qw.prototype.supportsBinary=!1;qw.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),DB.prototype.doClose.call(this)};qw.prototype.doPoll=function(){var n=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(s){n.onError("jsonp poll error",s)};var t=document.getElementsByTagName("script")[0];t?t.parentNode.insertBefore(e,t):(document.head||document.body).appendChild(e),this.script=e;var r=typeof navigator<"u"&&/gecko/i.test(navigator.userAgent);r&&setTimeout(function(){var s=document.createElement("iframe");document.body.appendChild(s),document.body.removeChild(s)},100)};qw.prototype.doWrite=function(n,e){var t=this;if(!this.form){var r=document.createElement("form"),s=document.createElement("textarea"),i=this.iframeId="eio_iframe_"+this.index,o;r.className="socketio",r.style.position="absolute",r.style.top="-1000px",r.style.left="-1000px",r.target=i,r.method="POST",r.setAttribute("accept-charset","utf-8"),s.name="d",r.appendChild(s),document.body.appendChild(r),this.form=r,this.area=s}this.form.action=this.uri();function a(){l(),e()}function l(){if(t.iframe)try{t.form.removeChild(t.iframe)}catch(u){t.onError("jsonp polling iframe removal error",u)}try{var c='<iframe src="javascript:0" name="'+t.iframeId+'">';o=document.createElement(c)}catch{o=document.createElement("iframe"),o.name=t.iframeId,o.src="javascript:0"}o.id=t.iframeId,t.form.appendChild(o),t.iframe=o}l(),n=n.replace(JXe,`\\
`),this.area.value=n.replace(ZXe,"\\n");try{this.form.submit()}catch{}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){t.iframe.readyState==="complete"&&a()}:this.iframe.onload=a};var OB=RB(),eKe=jy,tKe=Hw,nKe=KN,rKe=Pee,sKe=YN("engine.io-client:websocket"),jI,FB;typeof WebSocket<"u"?jI=WebSocket:typeof self<"u"&&(jI=self.WebSocket||self.MozWebSocket);if(typeof window>"u")try{FB=DK}catch{}var Ab=jI||FB,iKe=Tc;function Tc(n){var e=n&&n.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=n.perMessageDeflate,this.usingBrowserWebSocket=jI&&!n.forceNode,this.protocols=n.protocols,this.usingBrowserWebSocket||(Ab=FB),OB.call(this,n)}nKe(Tc,OB);Tc.prototype.name="websocket";Tc.prototype.supportsBinary=!0;Tc.prototype.doOpen=function(){if(this.check()){var n=this.uri(),e=this.protocols,t={};this.isReactNative||(t.agent=this.agent,t.perMessageDeflate=this.perMessageDeflate,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized),this.extraHeaders&&(t.headers=this.extraHeaders),this.localAddress&&(t.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket&&!this.isReactNative?e?new Ab(n,e):new Ab(n):new Ab(n,e,t)}catch(r){return this.emit("error",r)}this.ws.binaryType===void 0&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}};Tc.prototype.addEventListeners=function(){var n=this;this.ws.onopen=function(){n.onOpen()},this.ws.onclose=function(){n.onClose()},this.ws.onmessage=function(e){n.onData(e.data)},this.ws.onerror=function(e){n.onError("websocket error",e)}};Tc.prototype.write=function(n){var e=this;this.writable=!1;for(var t=n.length,r=0,s=t;r<s;r++)(function(o){eKe.encodePacket(o,e.supportsBinary,function(a){if(!e.usingBrowserWebSocket){var l={};if(o.options&&(l.compress=o.options.compress),e.perMessageDeflate){var c=typeof a=="string"?Buffer.byteLength(a):a.length;c<e.perMessageDeflate.threshold&&(l.compress=!1)}}try{e.usingBrowserWebSocket?e.ws.send(a):e.ws.send(a,l)}catch{sKe("websocket closed before onclose event")}--t||i()})})(n[r]);function i(){e.emit("flush"),setTimeout(function(){e.writable=!0,e.emit("drain")},0)}};Tc.prototype.onClose=function(){OB.prototype.onClose.call(this)};Tc.prototype.doClose=function(){typeof this.ws<"u"&&this.ws.close()};Tc.prototype.uri=function(){var n=this.query||{},e=this.secure?"wss":"ws",t="";this.port&&(e==="wss"&&Number(this.port)!==443||e==="ws"&&Number(this.port)!==80)&&(t=":"+this.port),this.timestampRequests&&(n[this.timestampParam]=rKe()),this.supportsBinary||(n.b64=1),n=tKe.encode(n),n.length&&(n="?"+n);var r=this.hostname.indexOf(":")!==-1;return e+"://"+(r?"["+this.hostname+"]":this.hostname)+t+this.path+n};Tc.prototype.check=function(){return!!Ab&&!("__initialize"in Ab&&this.name===Tc.prototype.name)};var oKe=NB,aKe=XXe,lKe=YXe,cKe=iKe;XN.polling=uKe;XN.websocket=cKe;function uKe(n){var e,t=!1,r=!1,s=n.jsonp!==!1;if(typeof location<"u"){var i=location.protocol==="https:",o=location.port;o||(o=i?443:80),t=n.hostname!==location.hostname||o!==n.port,r=n.secure!==i}if(n.xdomain=t,n.xscheme=r,e=new oKe(n),"open"in e&&!n.forceJSONP)return new aKe(n);if(!s)throw new Error("JSONP disabled");return new lKe(n)}var hKe=[].indexOf,zee=function(n,e){if(hKe)return n.indexOf(e);for(var t=0;t<n.length;++t)if(n[t]===e)return t;return-1},fKe=XN,dKe=Gw,xi=YN("engine.io-client:socket"),pKe=zee,Bee=jy,AH=_ee,mKe=Hw,gKe=mr;function mr(n,e){if(!(this instanceof mr))return new mr(n,e);e=e||{},n&&typeof n=="object"&&(e=n,n=null),n?(n=AH(n),e.hostname=n.host,e.secure=n.protocol==="https"||n.protocol==="wss",e.port=n.port,n.query&&(e.query=n.query)):e.host&&(e.hostname=AH(e.host).host),this.secure=e.secure!=null?e.secure:typeof location<"u"&&location.protocol==="https:",e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.agent=e.agent||!1,this.hostname=e.hostname||(typeof location<"u"?location.hostname:"localhost"),this.port=e.port||(typeof location<"u"&&location.port?location.port:this.secure?443:80),this.query=e.query||{},typeof this.query=="string"&&(this.query=mKe.decode(this.query)),this.upgrade=e.upgrade!==!1,this.path=(e.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!e.forceJSONP,this.jsonp=e.jsonp!==!1,this.forceBase64=!!e.forceBase64,this.enablesXDR=!!e.enablesXDR,this.withCredentials=e.withCredentials!==!1,this.timestampParam=e.timestampParam||"t",this.timestampRequests=e.timestampRequests,this.transports=e.transports||["polling","websocket"],this.transportOptions=e.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=e.policyPort||843,this.rememberUpgrade=e.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=e.onlyBinaryUpgrades,this.perMessageDeflate=e.perMessageDeflate!==!1?e.perMessageDeflate||{}:!1,this.perMessageDeflate===!0&&(this.perMessageDeflate={}),this.perMessageDeflate&&this.perMessageDeflate.threshold==null&&(this.perMessageDeflate.threshold=1024),this.pfx=e.pfx||void 0,this.key=e.key||void 0,this.passphrase=e.passphrase||void 0,this.cert=e.cert||void 0,this.ca=e.ca||void 0,this.ciphers=e.ciphers||void 0,this.rejectUnauthorized=e.rejectUnauthorized===void 0?!0:e.rejectUnauthorized,this.forceNode=!!e.forceNode,this.isReactNative=typeof navigator<"u"&&typeof navigator.product=="string"&&navigator.product.toLowerCase()==="reactnative",(typeof self>"u"||this.isReactNative)&&(e.extraHeaders&&Object.keys(e.extraHeaders).length>0&&(this.extraHeaders=e.extraHeaders),e.localAddress&&(this.localAddress=e.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}mr.priorWebsocketSuccess=!1;dKe(mr.prototype);mr.protocol=Bee.protocol;mr.Socket=mr;mr.Transport=RB();mr.transports=XN;mr.parser=jy;mr.prototype.createTransport=function(n){xi('creating transport "%s"',n);var e=yKe(this.query);e.EIO=Bee.protocol,e.transport=n;var t=this.transportOptions[n]||{};this.id&&(e.sid=this.id);var r=new fKe[n]({query:e,socket:this,agent:t.agent||this.agent,hostname:t.hostname||this.hostname,port:t.port||this.port,secure:t.secure||this.secure,path:t.path||this.path,forceJSONP:t.forceJSONP||this.forceJSONP,jsonp:t.jsonp||this.jsonp,forceBase64:t.forceBase64||this.forceBase64,enablesXDR:t.enablesXDR||this.enablesXDR,withCredentials:t.withCredentials||this.withCredentials,timestampRequests:t.timestampRequests||this.timestampRequests,timestampParam:t.timestampParam||this.timestampParam,policyPort:t.policyPort||this.policyPort,pfx:t.pfx||this.pfx,key:t.key||this.key,passphrase:t.passphrase||this.passphrase,cert:t.cert||this.cert,ca:t.ca||this.ca,ciphers:t.ciphers||this.ciphers,rejectUnauthorized:t.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:t.perMessageDeflate||this.perMessageDeflate,extraHeaders:t.extraHeaders||this.extraHeaders,forceNode:t.forceNode||this.forceNode,localAddress:t.localAddress||this.localAddress,requestTimeout:t.requestTimeout||this.requestTimeout,protocols:t.protocols||void 0,isReactNative:this.isReactNative});return r};function yKe(n){var e={};for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e}mr.prototype.open=function(){var n;if(this.rememberUpgrade&&mr.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)n="websocket";else if(this.transports.length===0){var e=this;setTimeout(function(){e.emit("error","No transports available")},0);return}else n=this.transports[0];this.readyState="opening";try{n=this.createTransport(n)}catch{this.transports.shift(),this.open();return}n.open(),this.setTransport(n)};mr.prototype.setTransport=function(n){xi("setting transport %s",n.name);var e=this;this.transport&&(xi("clearing existing transport %s",this.transport.name),this.transport.removeAllListeners()),this.transport=n,n.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})};mr.prototype.probe=function(n){xi('probing transport "%s"',n);var e=this.createTransport(n,{probe:1}),t=!1,r=this;mr.priorWebsocketSuccess=!1;function s(){if(r.onlyBinaryUpgrades){var h=!this.supportsBinary&&r.transport.supportsBinary;t=t||h}t||(xi('probe transport "%s" opened',n),e.send([{type:"ping",data:"probe"}]),e.once("packet",function(f){if(!t)if(f.type==="pong"&&f.data==="probe"){if(xi('probe transport "%s" pong',n),r.upgrading=!0,r.emit("upgrading",e),!e)return;mr.priorWebsocketSuccess=e.name==="websocket",xi('pausing current transport "%s"',r.transport.name),r.transport.pause(function(){t||r.readyState!=="closed"&&(xi("changing transport and sending upgrade packet"),u(),r.setTransport(e),e.send([{type:"upgrade"}]),r.emit("upgrade",e),e=null,r.upgrading=!1,r.flush())})}else{xi('probe transport "%s" failed',n);var d=new Error("probe error");d.transport=e.name,r.emit("upgradeError",d)}}))}function i(){t||(t=!0,u(),e.close(),e=null)}function o(h){var f=new Error("probe error: "+h);f.transport=e.name,i(),xi('probe transport "%s" failed because of error: %s',n,h),r.emit("upgradeError",f)}function a(){o("transport closed")}function l(){o("socket closed")}function c(h){e&&h.name!==e.name&&(xi('"%s" works - aborting "%s"',h.name,e.name),i())}function u(){e.removeListener("open",s),e.removeListener("error",o),e.removeListener("close",a),r.removeListener("close",l),r.removeListener("upgrading",c)}e.once("open",s),e.once("error",o),e.once("close",a),this.once("close",l),this.once("upgrading",c),e.open()};mr.prototype.onOpen=function(){if(xi("socket open"),this.readyState="open",mr.priorWebsocketSuccess=this.transport.name==="websocket",this.emit("open"),this.flush(),this.readyState==="open"&&this.upgrade&&this.transport.pause){xi("starting upgrade probes");for(var n=0,e=this.upgrades.length;n<e;n++)this.probe(this.upgrades[n])}};mr.prototype.onPacket=function(n){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing")switch(xi('socket receive: type "%s", data "%s"',n.type,n.data),this.emit("packet",n),this.emit("heartbeat"),n.type){case"open":this.onHandshake(JSON.parse(n.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=n.data,this.onError(e);break;case"message":this.emit("data",n.data),this.emit("message",n.data);break}else xi('packet received with socket readyState "%s"',this.readyState)};mr.prototype.onHandshake=function(n){this.emit("handshake",n),this.id=n.sid,this.transport.query.sid=n.sid,this.upgrades=this.filterUpgrades(n.upgrades),this.pingInterval=n.pingInterval,this.pingTimeout=n.pingTimeout,this.onOpen(),this.readyState!=="closed"&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))};mr.prototype.onHeartbeat=function(n){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){e.readyState!=="closed"&&e.onClose("ping timeout")},n||e.pingInterval+e.pingTimeout)};mr.prototype.setPing=function(){var n=this;clearTimeout(n.pingIntervalTimer),n.pingIntervalTimer=setTimeout(function(){xi("writing ping packet - expecting pong within %sms",n.pingTimeout),n.ping(),n.onHeartbeat(n.pingTimeout)},n.pingInterval)};mr.prototype.ping=function(){var n=this;this.sendPacket("ping",function(){n.emit("ping")})};mr.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,this.writeBuffer.length===0?this.emit("drain"):this.flush()};mr.prototype.flush=function(){this.readyState!=="closed"&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(xi("flushing %d packets in socket",this.writeBuffer.length),this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))};mr.prototype.write=mr.prototype.send=function(n,e,t){return this.sendPacket("message",n,e,t),this};mr.prototype.sendPacket=function(n,e,t,r){if(typeof e=="function"&&(r=e,e=void 0),typeof t=="function"&&(r=t,t=null),!(this.readyState==="closing"||this.readyState==="closed")){t=t||{},t.compress=t.compress!==!1;var s={type:n,data:e,options:t};this.emit("packetCreate",s),this.writeBuffer.push(s),r&&this.once("flush",r),this.flush()}};mr.prototype.close=function(){if(this.readyState==="opening"||this.readyState==="open"){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():e()}):this.upgrading?r():e()}function e(){n.onClose("forced close"),xi("socket closing - telling transport to close"),n.transport.close()}function t(){n.removeListener("upgrade",t),n.removeListener("upgradeError",t),e()}function r(){n.once("upgrade",t),n.once("upgradeError",t)}return this};mr.prototype.onError=function(n){xi("socket error %j",n),mr.priorWebsocketSuccess=!1,this.emit("error",n),this.onClose("transport error",n)};mr.prototype.onClose=function(n,e){if(this.readyState==="opening"||this.readyState==="open"||this.readyState==="closing"){xi('socket close with reason: "%s"',n);var t=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",n,e),t.writeBuffer=[],t.prevBufferLen=0}};mr.prototype.filterUpgrades=function(n){for(var e=[],t=0,r=n.length;t<r;t++)~pKe(this.transports,n[t])&&e.push(n[t]);return e};AB.exports=gKe;AB.exports.parser=jy;var bKe=AB.exports,Vee={exports:{}},vKe=wKe;function wKe(n,e){var t=[];e=e||0;for(var r=e||0;r<n.length;r++)t[r-e]=n[r];return t}var Uee=xKe;function xKe(n,e,t){return n.on(e,t),{destroy:function(){n.removeListener(e,t)}}}var MH=[].slice,Wee=function(n,e){if(typeof e=="string"&&(e=n[e]),typeof e!="function")throw new Error("bind() requires a function");var t=MH.call(arguments,2);return function(){return e.apply(n,t.concat(MH.call(arguments)))}};(function(n,e){var t=jN,r=Gw,s=vKe,i=Uee,o=Wee,a=HN("socket.io-client:socket"),l=Hw,c=Aee;n.exports=f;var u={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},h=r.prototype.emit;function f(d,p,m){this.io=d,this.nsp=p,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},m&&m.query&&(this.query=m.query),this.io.autoConnect&&this.open()}r(f.prototype),f.prototype.subEvents=function(){if(!this.subs){var d=this.io;this.subs=[i(d,"open",o(this,"onopen")),i(d,"packet",o(this,"onpacket")),i(d,"close",o(this,"onclose"))]}},f.prototype.open=f.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.reconnecting||this.io.open(),this.io.readyState==="open"&&this.onopen(),this.emit("connecting"),this)},f.prototype.send=function(){var d=s(arguments);return d.unshift("message"),this.emit.apply(this,d),this},f.prototype.emit=function(d){if(u.hasOwnProperty(d))return h.apply(this,arguments),this;var p=s(arguments),m={type:(this.flags.binary!==void 0?this.flags.binary:c(p))?t.BINARY_EVENT:t.EVENT,data:p};return m.options={},m.options.compress=!this.flags||this.flags.compress!==!1,typeof p[p.length-1]=="function"&&(a("emitting packet with ack id %d",this.ids),this.acks[this.ids]=p.pop(),m.id=this.ids++),this.connected?this.packet(m):this.sendBuffer.push(m),this.flags={},this},f.prototype.packet=function(d){d.nsp=this.nsp,this.io.packet(d)},f.prototype.onopen=function(){if(a("transport is open - connecting"),this.nsp!=="/")if(this.query){var d=typeof this.query=="object"?l.encode(this.query):this.query;a("sending connect packet with query %s",d),this.packet({type:t.CONNECT,query:d})}else this.packet({type:t.CONNECT})},f.prototype.onclose=function(d){a("close (%s)",d),this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",d)},f.prototype.onpacket=function(d){var p=d.nsp===this.nsp,m=d.type===t.ERROR&&d.nsp==="/";if(!(!p&&!m))switch(d.type){case t.CONNECT:this.onconnect();break;case t.EVENT:this.onevent(d);break;case t.BINARY_EVENT:this.onevent(d);break;case t.ACK:this.onack(d);break;case t.BINARY_ACK:this.onack(d);break;case t.DISCONNECT:this.ondisconnect();break;case t.ERROR:this.emit("error",d.data);break}},f.prototype.onevent=function(d){var p=d.data||[];a("emitting event %j",p),d.id!=null&&(a("attaching ack callback to event"),p.push(this.ack(d.id))),this.connected?h.apply(this,p):this.receiveBuffer.push(p)},f.prototype.ack=function(d){var p=this,m=!1;return function(){if(!m){m=!0;var g=s(arguments);a("sending ack %j",g),p.packet({type:c(g)?t.BINARY_ACK:t.ACK,id:d,data:g})}}},f.prototype.onack=function(d){var p=this.acks[d.id];typeof p=="function"?(a("calling ack %s with %j",d.id,d.data),p.apply(this,d.data),delete this.acks[d.id]):a("bad ack %s",d.id)},f.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emitBuffered(),this.emit("connect")},f.prototype.emitBuffered=function(){var d;for(d=0;d<this.receiveBuffer.length;d++)h.apply(this,this.receiveBuffer[d]);for(this.receiveBuffer=[],d=0;d<this.sendBuffer.length;d++)this.packet(this.sendBuffer[d]);this.sendBuffer=[]},f.prototype.ondisconnect=function(){a("server disconnect (%s)",this.nsp),this.destroy(),this.onclose("io server disconnect")},f.prototype.destroy=function(){if(this.subs){for(var d=0;d<this.subs.length;d++)this.subs[d].destroy();this.subs=null}this.io.destroy(this)},f.prototype.close=f.prototype.disconnect=function(){return this.connected&&(a("performing disconnect (%s)",this.nsp),this.packet({type:t.DISCONNECT})),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},f.prototype.compress=function(d){return this.flags.compress=d,this},f.prototype.binary=function(d){return this.flags.binary=d,this}})(Vee);var Gee=Vee.exports,_Ke=Xw;function Xw(n){n=n||{},this.ms=n.min||100,this.max=n.max||1e4,this.factor=n.factor||2,this.jitter=n.jitter>0&&n.jitter<=1?n.jitter:0,this.attempts=0}Xw.prototype.duration=function(){var n=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),t=Math.floor(e*this.jitter*n);n=Math.floor(e*10)&1?n+t:n-t}return Math.min(n,this.max)|0};Xw.prototype.reset=function(){this.attempts=0};Xw.prototype.setMin=function(n){this.ms=n};Xw.prototype.setMax=function(n){this.max=n};Xw.prototype.setJitter=function(n){this.jitter=n};var SKe=bKe,CKe=Gee,kKe=Gw,TKe=jN,kd=Uee,$0=Wee,Go=HN("socket.io-client:manager"),Hee=zee,EKe=_Ke,jee=Object.prototype.hasOwnProperty,NH=kr;function kr(n,e){if(!(this instanceof kr))return new kr(n,e);n&&typeof n=="object"&&(e=n,n=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new EKe({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(e.timeout==null?2e4:e.timeout),this.readyState="closed",this.uri=n,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var t=e.parser||TKe;this.encoder=new t.Encoder,this.decoder=new t.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}kr.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var n in this.nsps)jee.call(this.nsps,n)&&this.nsps[n].emit.apply(this.nsps[n],arguments)};kr.prototype.updateSocketIds=function(){for(var n in this.nsps)jee.call(this.nsps,n)&&(this.nsps[n].id=this.generateId(n))};kr.prototype.generateId=function(n){return(n==="/"?"":n+"#")+this.engine.id};kKe(kr.prototype);kr.prototype.reconnection=function(n){return arguments.length?(this._reconnection=!!n,this):this._reconnection};kr.prototype.reconnectionAttempts=function(n){return arguments.length?(this._reconnectionAttempts=n,this):this._reconnectionAttempts};kr.prototype.reconnectionDelay=function(n){return arguments.length?(this._reconnectionDelay=n,this.backoff&&this.backoff.setMin(n),this):this._reconnectionDelay};kr.prototype.randomizationFactor=function(n){return arguments.length?(this._randomizationFactor=n,this.backoff&&this.backoff.setJitter(n),this):this._randomizationFactor};kr.prototype.reconnectionDelayMax=function(n){return arguments.length?(this._reconnectionDelayMax=n,this.backoff&&this.backoff.setMax(n),this):this._reconnectionDelayMax};kr.prototype.timeout=function(n){return arguments.length?(this._timeout=n,this):this._timeout};kr.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&this.backoff.attempts===0&&this.reconnect()};kr.prototype.open=kr.prototype.connect=function(n,e){if(Go("readyState %s",this.readyState),~this.readyState.indexOf("open"))return this;Go("opening %s",this.uri),this.engine=SKe(this.uri,this.opts);var t=this.engine,r=this;this.readyState="opening",this.skipReconnect=!1;var s=kd(t,"open",function(){r.onopen(),n&&n()}),i=kd(t,"error",function(l){if(Go("connect_error"),r.cleanup(),r.readyState="closed",r.emitAll("connect_error",l),n){var c=new Error("Connection error");c.data=l,n(c)}else r.maybeReconnectOnOpen()});if(this._timeout!==!1){var o=this._timeout;Go("connect attempt will timeout after %d",o),o===0&&s.destroy();var a=setTimeout(function(){Go("connect attempt timed out after %d",o),s.destroy(),t.close(),t.emit("error","timeout"),r.emitAll("connect_timeout",o)},o);this.subs.push({destroy:function(){clearTimeout(a)}})}return this.subs.push(s),this.subs.push(i),this};kr.prototype.onopen=function(){Go("open"),this.cleanup(),this.readyState="open",this.emit("open");var n=this.engine;this.subs.push(kd(n,"data",$0(this,"ondata"))),this.subs.push(kd(n,"ping",$0(this,"onping"))),this.subs.push(kd(n,"pong",$0(this,"onpong"))),this.subs.push(kd(n,"error",$0(this,"onerror"))),this.subs.push(kd(n,"close",$0(this,"onclose"))),this.subs.push(kd(this.decoder,"decoded",$0(this,"ondecoded")))};kr.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")};kr.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)};kr.prototype.ondata=function(n){this.decoder.add(n)};kr.prototype.ondecoded=function(n){this.emit("packet",n)};kr.prototype.onerror=function(n){Go("error",n),this.emitAll("error",n)};kr.prototype.socket=function(n,e){var t=this.nsps[n];if(!t){t=new CKe(this,n,e),this.nsps[n]=t;var r=this;t.on("connecting",s),t.on("connect",function(){t.id=r.generateId(n)}),this.autoConnect&&s()}function s(){~Hee(r.connecting,t)||r.connecting.push(t)}return t};kr.prototype.destroy=function(n){var e=Hee(this.connecting,n);~e&&this.connecting.splice(e,1),!this.connecting.length&&this.close()};kr.prototype.packet=function(n){Go("writing packet %j",n);var e=this;n.query&&n.type===0&&(n.nsp+="?"+n.query),e.encoding?e.packetBuffer.push(n):(e.encoding=!0,this.encoder.encode(n,function(t){for(var r=0;r<t.length;r++)e.engine.write(t[r],n.options);e.encoding=!1,e.processPacketQueue()}))};kr.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var n=this.packetBuffer.shift();this.packet(n)}};kr.prototype.cleanup=function(){Go("cleanup");for(var n=this.subs.length,e=0;e<n;e++){var t=this.subs.shift();t.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()};kr.prototype.close=kr.prototype.disconnect=function(){Go("disconnect"),this.skipReconnect=!0,this.reconnecting=!1,this.readyState==="opening"&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()};kr.prototype.onclose=function(n){Go("onclose"),this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",n),this._reconnection&&!this.skipReconnect&&this.reconnect()};kr.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var n=this;if(this.backoff.attempts>=this._reconnectionAttempts)Go("reconnect failed"),this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();Go("will wait %dms before reconnect attempt",e),this.reconnecting=!0;var t=setTimeout(function(){n.skipReconnect||(Go("attempting reconnect"),n.emitAll("reconnect_attempt",n.backoff.attempts),n.emitAll("reconnecting",n.backoff.attempts),!n.skipReconnect&&n.open(function(r){r?(Go("reconnect attempt error"),n.reconnecting=!1,n.reconnect(),n.emitAll("reconnect_error",r.data)):(Go("reconnect success"),n.onreconnect())}))},e);this.subs.push({destroy:function(){clearTimeout(t)}})}};kr.prototype.onreconnect=function(){var n=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",n)};(function(n,e){var t=K7e,r=jN,s=NH,i=HN("socket.io-client");n.exports=e=a;var o=e.managers={};function a(l,c){typeof l=="object"&&(c=l,l=void 0),c=c||{};var u=t(l),h=u.source,f=u.id,d=u.path,p=o[f]&&d in o[f].nsps,m=c.forceNew||c["force new connection"]||c.multiplex===!1||p,g;return m?(i("ignoring socket cache for %s",h),g=s(h,c)):(o[f]||(i("new io instance for %s",h),o[f]=s(h,c)),g=o[f]),u.query&&!c.query&&(c.query=u.query),g.socket(u.path,c)}e.protocol=r.protocol,e.connect=a,e.Manager=NH,e.Socket=Gee})(UD,UD.exports);var IKe=UD.exports;const AKe=Tp(IKe);var eO={exports:{}},ZN={},tO={exports:{}},x3,$H;function MKe(){if($H)return x3;$H=1;var n=1e3,e=n*60,t=e*60,r=t*24,s=r*7,i=r*365.25;x3=function(u,h){h=h||{};var f=typeof u;if(f==="string"&&u.length>0)return o(u);if(f==="number"&&isFinite(u))return h.long?l(u):a(u);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(u))};function o(u){if(u=String(u),!(u.length>100)){var h=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(u);if(h){var f=parseFloat(h[1]),d=(h[2]||"ms").toLowerCase();switch(d){case"years":case"year":case"yrs":case"yr":case"y":return f*i;case"weeks":case"week":case"w":return f*s;case"days":case"day":case"d":return f*r;case"hours":case"hour":case"hrs":case"hr":case"h":return f*t;case"minutes":case"minute":case"mins":case"min":case"m":return f*e;case"seconds":case"second":case"secs":case"sec":case"s":return f*n;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return f;default:return}}}}function a(u){var h=Math.abs(u);return h>=r?Math.round(u/r)+"d":h>=t?Math.round(u/t)+"h":h>=e?Math.round(u/e)+"m":h>=n?Math.round(u/n)+"s":u+"ms"}function l(u){var h=Math.abs(u);return h>=r?c(u,h,r,"day"):h>=t?c(u,h,t,"hour"):h>=e?c(u,h,e,"minute"):h>=n?c(u,h,n,"second"):u+" ms"}function c(u,h,f,d){var p=h>=f*1.5;return Math.round(u/f)+" "+d+(p?"s":"")}return x3}function NKe(n){t.debug=t,t.default=t,t.coerce=l,t.disable=i,t.enable=s,t.enabled=o,t.humanize=MKe(),t.destroy=c,Object.keys(n).forEach(u=>{t[u]=n[u]}),t.names=[],t.skips=[],t.formatters={};function e(u){let h=0;for(let f=0;f<u.length;f++)h=(h<<5)-h+u.charCodeAt(f),h|=0;return t.colors[Math.abs(h)%t.colors.length]}t.selectColor=e;function t(u){let h,f=null,d,p;function m(...g){if(!m.enabled)return;const y=m,b=Number(new Date),x=b-(h||b);y.diff=x,y.prev=h,y.curr=b,h=b,g[0]=t.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let w=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(C,k)=>{if(C==="%%")return"%";w++;const A=t.formatters[k];if(typeof A=="function"){const M=g[w];C=A.call(y,M),g.splice(w,1),w--}return C}),t.formatArgs.call(y,g),(y.log||t.log).apply(y,g)}return m.namespace=u,m.useColors=t.useColors(),m.color=t.selectColor(u),m.extend=r,m.destroy=t.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>f!==null?f:(d!==t.namespaces&&(d=t.namespaces,p=t.enabled(u)),p),set:g=>{f=g}}),typeof t.init=="function"&&t.init(m),m}function r(u,h){const f=t(this.namespace+(typeof h>"u"?":":h)+u);return f.log=this.log,f}function s(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let h;const f=(typeof u=="string"?u:"").split(/[\s,]+/),d=f.length;for(h=0;h<d;h++)f[h]&&(u=f[h].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.slice(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function i(){const u=[...t.names.map(a),...t.skips.map(a).map(h=>"-"+h)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let h,f;for(h=0,f=t.skips.length;h<f;h++)if(t.skips[h].test(u))return!1;for(h=0,f=t.names.length;h<f;h++)if(t.names[h].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function l(u){return u instanceof Error?u.stack||u.message:u}function c(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}var $Ke=NKe;(function(n,e){e.formatArgs=r,e.save=s,e.load=i,e.useColors=t,e.storage=o(),e.destroy=(()=>{let l=!1;return()=>{l||(l=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function r(l){if(l[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+l[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),!this.useColors)return;const c="color: "+this.color;l.splice(1,0,c,"color: inherit");let u=0,h=0;l[0].replace(/%[a-zA-Z%]/g,f=>{f!=="%%"&&(u++,f==="%c"&&(h=u))}),l.splice(h,0,c)}e.log=console.debug||console.log||(()=>{});function s(l){try{l?e.storage.setItem("debug",l):e.storage.removeItem("debug")}catch{}}function i(){let l;try{l=e.storage.getItem("debug")}catch{}return!l&&typeof process<"u"&&"env"in process&&(l={}.DEBUG),l}function o(){try{return localStorage}catch{}}n.exports=$Ke(e);const{formatters:a}=n.exports;a.j=function(l){try{return JSON.stringify(l)}catch(c){return"[UnexpectedJSONParseError]: "+c.message}}})(tO,tO.exports);var LB=tO.exports;const RH=LB("@feathersjs/errors");function Qn(n,e,t,r,s){n=n||"Error";let i,o,a;n instanceof Error?(o=n.message||"Error",n.errors&&(i=n.errors)):typeof n=="object"?(o=n.message||"Error",s=n):o=n,s&&(a=JSON.parse(JSON.stringify(s)),a.errors?(i=a.errors,delete a.errors):s.errors&&(i=JSON.parse(JSON.stringify(s.errors)))),this.type="FeathersError",this.name=e,this.message=o,this.code=t,this.className=r,this.data=a,this.errors=i||{},RH(`${this.name}(${this.code}): ${this.message}`),RH(this.errors),Error.captureStackTrace?Error.captureStackTrace(this,Qn):this.stack=new Error().stack}function ho(n,e){n.prototype=Object.create(e.prototype),n.prototype.constructor=n}ho(Qn,Error);Object.defineProperty(Qn.prototype,"toJSON",{value:function(){return{name:this.name,message:this.message,code:this.code,className:this.className,data:this.data,errors:this.errors}}});function nO(n,e){Qn.call(this,n,"BadRequest",400,"bad-request",e)}ho(nO,Qn);function rO(n,e){Qn.call(this,n,"NotAuthenticated",401,"not-authenticated",e)}ho(rO,Qn);function sO(n,e){Qn.call(this,n,"PaymentError",402,"payment-error",e)}ho(sO,Qn);function iO(n,e){Qn.call(this,n,"Forbidden",403,"forbidden",e)}ho(iO,Qn);function oO(n,e){Qn.call(this,n,"NotFound",404,"not-found",e)}ho(oO,Qn);function aO(n,e){Qn.call(this,n,"MethodNotAllowed",405,"method-not-allowed",e)}ho(aO,Qn);function lO(n,e){Qn.call(this,n,"NotAcceptable",406,"not-acceptable",e)}ho(lO,Qn);function cO(n,e){Qn.call(this,n,"Timeout",408,"timeout",e)}ho(cO,Qn);function uO(n,e){Qn.call(this,n,"Conflict",409,"conflict",e)}ho(uO,Qn);function hO(n,e){Qn(this,n,"Gone",410,"gone")}ho(hO,Qn);function fO(n,e){Qn.call(this,n,"LengthRequired",411,"length-required",e)}ho(fO,Qn);function dO(n,e){Qn.call(this,n,"Unprocessable",422,"unprocessable",e)}ho(dO,Qn);function pO(n,e){Qn.call(this,n,"TooManyRequests",429,"too-many-requests",e)}ho(pO,Qn);function mO(n,e){Qn.call(this,n,"GeneralError",500,"general-error",e)}ho(mO,Qn);function gO(n,e){Qn.call(this,n,"NotImplemented",501,"not-implemented",e)}ho(gO,Qn);function yO(n,e){Qn.call(this,n,"BadGateway",502,"bad-gateway",e)}ho(yO,Qn);function bO(n,e){Qn.call(this,n,"Unavailable",503,"unavailable",e)}ho(bO,Qn);const qee={FeathersError:Qn,BadRequest:nO,NotAuthenticated:rO,PaymentError:sO,Forbidden:iO,NotFound:oO,MethodNotAllowed:aO,NotAcceptable:lO,Timeout:cO,Conflict:uO,Gone:hO,LengthRequired:fO,Unprocessable:dO,TooManyRequests:pO,GeneralError:mO,NotImplemented:gO,BadGateway:yO,Unavailable:bO,400:nO,401:rO,402:sO,403:iO,404:oO,405:aO,406:lO,408:cO,409:uO,410:hO,411:fO,422:dO,429:pO,500:mO,501:gO,502:yO,503:bO};function RKe(n){if(!n)return n;const e=qee[n.name],t=e?new e(n.message,n.data):new Error(n.message||n);return typeof n=="object"&&Object.assign(t,n),t}var wC=Object.assign({convert:RKe},qee),dg={};Object.defineProperty(dg,"__esModule",{value:!0});dg.StorageWrapper=dg.MemoryStorage=void 0;class PKe{constructor(){this.store={}}getItem(e){return Promise.resolve(this.store[e])}setItem(e,t){return Promise.resolve(this.store[e]=t)}removeItem(e){const t=this.store[e];return delete this.store[e],Promise.resolve(t)}}dg.MemoryStorage=PKe;class DKe{constructor(e){this.storage=e}getItem(e){return Promise.resolve(this.storage.getItem(e))}setItem(e,t){return Promise.resolve(this.storage.setItem(e,t))}removeItem(e){return Promise.resolve(this.storage.removeItem(e))}}dg.StorageWrapper=DKe;Object.defineProperty(ZN,"__esModule",{value:!0});ZN.AuthenticationClient=void 0;const PH=wC,OKe=dg,DH=(n,e)=>{const t=new RegExp(`(?:&?)${e}=([^&]*)`),r=n.hash?n.hash.match(t):null;if(r!==null){const[,s]=r;return[s,t]}return[null,t]};class FKe{constructor(e,t){const r=e.io||e.primus,s=new OKe.StorageWrapper(e.get("storage")||t.storage);this.app=e,this.options=t,this.authenticated=!1,this.app.set("storage",s),r&&this.handleSocket(r)}get service(){return this.app.service(this.options.path)}get storage(){return this.app.get("storage")}handleSocket(e){const t=this.app.io?"connect":"open",r=this.app.io?"disconnect":"disconnection";e.on(r,()=>{const s=new Promise(i=>e.once(t,o=>i(o))).then(()=>this.authenticated?this.reAuthenticate(!0):null);this.app.set("authentication",s)})}getFromLocation(e){const[t,r]=DH(e,this.options.locationKey);if(t!==null)return e.hash=e.hash.replace(r,""),Promise.resolve(t);const[s,i]=DH(e,this.options.locationErrorKey);return s!==null?(e.hash=e.hash.replace(i,""),Promise.reject(new PH.NotAuthenticated(decodeURIComponent(s)))):Promise.resolve(null)}setAccessToken(e){return this.storage.setItem(this.options.storageKey,e)}getAccessToken(){return this.storage.getItem(this.options.storageKey).then(e=>!e&&typeof window<"u"&&window.location?this.getFromLocation(window.location):e||null)}removeAccessToken(){return this.storage.removeItem(this.options.storageKey)}reset(){return this.app.set("authentication",null),this.authenticated=!1,Promise.resolve(null)}handleError(e,t){if(e.code===401||e.code===403){const r=this.removeAccessToken().then(()=>this.reset());return t==="logout"?r:r.then(()=>Promise.reject(e))}return Promise.reject(e)}reAuthenticate(e=!1,t){const r=this.app.get("authentication");return!r||e===!0?this.getAccessToken().then(s=>{if(!s)throw new PH.NotAuthenticated("No accessToken found in storage");return this.authenticate({strategy:t||this.options.jwtStrategy,accessToken:s})}):r}authenticate(e,t){if(!e)return this.reAuthenticate();const r=this.service.create(e,t).then(s=>{const{accessToken:i}=s;return this.authenticated=!0,this.app.emit("login",s),this.app.emit("authenticated",s),this.setAccessToken(i).then(()=>s)}).catch(s=>this.handleError(s,"authenticate"));return this.app.set("authentication",r),r}logout(){return Promise.resolve(this.app.get("authentication")).then(()=>this.service.remove(null).then(e=>this.removeAccessToken().then(()=>this.reset()).then(()=>(this.app.emit("logout",e),e)))).catch(e=>this.handleError(e,"logout"))}}ZN.AuthenticationClient=FKe;var Xee={},JN={},Dp={},bi={},zB={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.createSymbol=n.makeUrl=n.isPromise=n._=n.stripSlashes=void 0;function e(i){return i.replace(/^(\/+)|(\/+)$/g,"")}n.stripSlashes=e,n._={each(i,o){i&&typeof i.forEach=="function"?i.forEach(o):n._.isObject(i)&&Object.keys(i).forEach(a=>o(i[a],a))},some(i,o){return Object.keys(i).map(a=>[i[a],a]).some(([a,l])=>o(a,l))},every(i,o){return Object.keys(i).map(a=>[i[a],a]).every(([a,l])=>o(a,l))},keys(i){return Object.keys(i)},values(i){return n._.keys(i).map(o=>i[o])},isMatch(i,o){return n._.keys(o).every(a=>i[a]===o[a])},isEmpty(i){return n._.keys(i).length===0},isObject(i){return typeof i=="object"&&!Array.isArray(i)&&i!==null},isObjectOrArray(i){return typeof i=="object"&&i!==null},extend(i,...o){return Object.assign(i,...o)},omit(i,...o){const a=n._.extend({},i);return o.forEach(l=>delete a[l]),a},pick(i,...o){return o.reduce((a,l)=>(i[l]!==void 0&&(a[l]=i[l]),a),{})},merge(i,o){return n._.isObject(i)&&n._.isObject(o)&&Object.keys(o).forEach(a=>{n._.isObject(o[a])?(i[a]||Object.assign(i,{[a]:{}}),n._.merge(i[a],o[a])):Object.assign(i,{[a]:o[a]})}),i}};function t(i){return n._.isObject(i)&&typeof i.then=="function"}n.isPromise=t;function r(i,o={}){const a=typeof o.get=="function"?o.get.bind(o):()=>{},l=a("env")||"production",c=a("host")||{}.HOST_NAME||"localhost",u=l==="development"||l==="test"||l===void 0?"http":"https",h=a("port")||{}.PORT||3030,f=l==="development"||l==="test"||l===void 0?`:${h}`:"";return i=i||"",`${u}://${c}${f}/${n.stripSlashes(i)}`}n.makeUrl=r;function s(i){return typeof Symbol<"u"?Symbol(i):i}n.createSymbol=s})(zB);Object.defineProperty(bi,"__esModule",{value:!0});bi.enableHooks=bi.processHooks=bi.getHooks=bi.isHookObject=bi.convertHookData=bi.makeArguments=bi.defaultMakeArguments=bi.createHookObject=bi.ACTIVATE_HOOKS=void 0;const Kee=zB,{each:vO,pick:LKe}=Kee._;bi.ACTIVATE_HOOKS=(0,Kee.createSymbol)("__feathersActivateHooks");function zKe(n,e={}){const t={};return Object.defineProperty(t,"toJSON",{value(){return LKe(this,"type","method","path","params","id","data","result","error")}}),Object.assign(t,e,{method:n,get path(){const{app:r,service:s}=e;return!s||!r||!r.services?null:Object.keys(r.services).find(i=>r.services[i]===s)}})}bi.createHookObject=zKe;function Yee(n){const e=[];return typeof n.id<"u"&&e.push(n.id),n.data&&e.push(n.data),e.push(n.params||{}),e}bi.defaultMakeArguments=Yee;function BKe(n){switch(n.method){case"find":return[n.params];case"get":case"remove":return[n.id,n.params];case"update":case"patch":return[n.id,n.data,n.params];case"create":return[n.data,n.params]}return Yee(n)}bi.makeArguments=BKe;function Zee(n){let e={};return Array.isArray(n)?e={all:n}:typeof n!="object"?e={all:[n]}:vO(n,function(t,r){e[r]=Array.isArray(t)?t:[t]}),e}bi.convertHookData=Zee;function Jee(n){return typeof n=="object"&&typeof n.method=="string"&&typeof n.type=="string"}bi.isHookObject=Jee;function VKe(n,e,t,r,s=!1){const i=n.__hooks[t][r]||[],o=e.__hooks[t][r]||[];return s?o.concat(i):i.concat(o)}bi.getHooks=VKe;function UKe(n,e){let t=e;const r=i=>{if(i){if(!Jee(i))throw new Error(`${t.type} hook for '${t.method}' method returned invalid hook object`);t=i}return t};return n.reduce((i,o)=>{const a=o.bind(this);return i.then(l=>a(l)).then(r)},Promise.resolve(t)).then(()=>t).catch(i=>{throw i.hook=t,i})}bi.processHooks=UKe;function WKe(n,e,t){if(typeof n.hooks=="function")return n;const r={};return t.forEach(s=>{r[s]={}}),Object.defineProperty(n,"__hooks",{configurable:!0,value:r,writable:!0}),Object.assign(n,{hooks(s){return vO(s,(i,o)=>{if(!this.__hooks[o])throw new Error(`'${o}' is not a valid hook type`);const a=Zee(i);vO(a,(l,c)=>{if(c!=="all"&&e.indexOf(c)===-1)throw new Error(`'${c}' is not a valid hook method`)}),e.forEach(l=>{const c=this.__hooks[o][l]||(this.__hooks[o][l]=[]);a.all&&c.push.apply(c,a.all),a[l]&&c.push.apply(c,a[l])})}),this}})}bi.enableHooks=WKe;(function(n){var e=pt&&pt.__createBinding||(Object.create?function(o,a,l,c){c===void 0&&(c=l);var u=Object.getOwnPropertyDescriptor(a,l);(!u||("get"in u?!a.__esModule:u.writable||u.configurable))&&(u={enumerable:!0,get:function(){return a[l]}}),Object.defineProperty(o,c,u)}:function(o,a,l,c){c===void 0&&(c=l),o[c]=a[l]}),t=pt&&pt.__setModuleDefault||(Object.create?function(o,a){Object.defineProperty(o,"default",{enumerable:!0,value:a})}:function(o,a){o.default=a}),r=pt&&pt.__importStar||function(o){if(o&&o.__esModule)return o;var a={};if(o!=null)for(var l in o)l!=="default"&&Object.prototype.hasOwnProperty.call(o,l)&&e(a,o,l);return t(a,o),a},s=pt&&pt.__exportStar||function(o,a){for(var l in o)l!=="default"&&!Object.prototype.hasOwnProperty.call(a,l)&&e(a,o,l)};Object.defineProperty(n,"__esModule",{value:!0}),n.hooks=void 0;const i=r(bi);s(zB,n),n.hooks=i})(Dp);Object.defineProperty(JN,"__esModule",{value:!0});JN.authentication=void 0;const GKe=Dp,HKe=()=>n=>{const{app:e,params:t,path:r,method:s,app:{authentication:i}}=n;return(0,GKe.stripSlashes)(i.options.path)===r&&s==="create"?n:Promise.resolve(e.get("authentication")).then(o=>(o&&(n.params=Object.assign({},o,t)),n))};JN.authentication=HKe;var QN={};Object.defineProperty(QN,"__esModule",{value:!0});QN.populateHeader=void 0;const jKe=()=>n=>{const{app:e,params:{accessToken:t}}=n,r=e.authentication;if(e.rest&&t){const{scheme:s,header:i}=r.options,o=`${s} ${t}`;n.params.headers=Object.assign({},{[i]:o},n.params.headers)}return n};QN.populateHeader=jKe;(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.populateHeader=n.authentication=void 0;var e=JN;Object.defineProperty(n,"authentication",{enumerable:!0,get:function(){return e.authentication}});var t=QN;Object.defineProperty(n,"populateHeader",{enumerable:!0,get:function(){return t.populateHeader}})})(Xee);(function(n,e){var t=pt&&pt.__createBinding||(Object.create?function(u,h,f,d){d===void 0&&(d=f);var p=Object.getOwnPropertyDescriptor(h,f);(!p||("get"in p?!h.__esModule:p.writable||p.configurable))&&(p={enumerable:!0,get:function(){return h[f]}}),Object.defineProperty(u,d,p)}:function(u,h,f,d){d===void 0&&(d=f),u[d]=h[f]}),r=pt&&pt.__setModuleDefault||(Object.create?function(u,h){Object.defineProperty(u,"default",{enumerable:!0,value:h})}:function(u,h){u.default=h}),s=pt&&pt.__importStar||function(u){if(u&&u.__esModule)return u;var h={};if(u!=null)for(var f in u)f!=="default"&&Object.prototype.hasOwnProperty.call(u,f)&&t(h,u,f);return r(h,u),h};Object.defineProperty(e,"__esModule",{value:!0}),e.defaults=e.defaultStorage=e.hooks=e.MemoryStorage=e.AuthenticationClient=e.getDefaultStorage=void 0;const i=ZN;Object.defineProperty(e,"AuthenticationClient",{enumerable:!0,get:function(){return i.AuthenticationClient}});const o=s(Xee);e.hooks=o;const a=dg;Object.defineProperty(e,"MemoryStorage",{enumerable:!0,get:function(){return a.MemoryStorage}});const l=()=>{try{return new a.StorageWrapper(window.localStorage)}catch{}return new a.MemoryStorage};e.getDefaultStorage=l,e.defaultStorage=(0,e.getDefaultStorage)(),e.defaults={header:"Authorization",scheme:"Bearer",storageKey:"feathers-jwt",locationKey:"access_token",locationErrorKey:"error",jwtStrategy:"jwt",path:"/authentication",Authentication:i.AuthenticationClient,storage:e.defaultStorage};const c=(u={})=>{const h=Object.assign({},e.defaults,u),{Authentication:f}=h;return d=>{const p=new f(d,h);d.authentication=p,d.authenticate=p.authenticate.bind(p),d.reAuthenticate=p.reAuthenticate.bind(p),d.logout=p.logout.bind(p),d.hooks({before:{all:[o.authentication(),o.populateHeader()]}})}};e.default=c,n.exports=Object.assign(c,n.exports)})(eO,eO.exports);var qKe=eO.exports;const XKe=Tp(qKe);var BB={exports:{}},Qee={exports:{}};(function(n,e){(function(t,r){n.exports=r()})(pt,function(){var t=typeof Object.getOwnPropertySymbols=="function";function r(s,i,o,a){var l=typeof i=="function",c=function(){var u=this._super;this._super=l?i:s[o];var h=a.apply(this,arguments);return this._super=u,h};return l&&(Object.keys(i).forEach(function(u){c[u]=i[u]}),t&&Object.getOwnPropertySymbols(i).forEach(function(u){c[u]=i[u]})),c}return{create:function(){var s=Object.create(this),i=typeof s.__init=="string"?s.__init:"init";return typeof s[i]=="function"&&s[i].apply(s,arguments),s},mixin:function(s,i){var o=i||this,a=/\b_super\b/,l=Object.getPrototypeOf(o)||o.prototype,c={},u=s,h=function(d){var p=Object.getOwnPropertyDescriptor(u,d);!c[d]&&p&&(c[d]=p)};do Object.getOwnPropertyNames(u).forEach(h),t&&Object.getOwnPropertySymbols(u).forEach(h);while((u=Object.getPrototypeOf(u))&&Object.getPrototypeOf(u));var f=function(d){var p=c[d];typeof p.value=="function"&&a.test(p.value)&&(p.value=r(l,o[d],d,p.value)),Object.defineProperty(o,d,p)};return Object.keys(c).forEach(f),t&&Object.getOwnPropertySymbols(c).forEach(f),o},extend:function(s,i){return this.mixin(s,Object.create(i||this))},proxy:function(s){var i=this[s],o=Array.prototype.slice.call(arguments,1);return o.unshift(this),i.bind.apply(i,o)}}})})(Qee);var VB=Qee.exports,wO={exports:{}},UB={exports:{}},Mb=typeof Reflect=="object"?Reflect:null,OH=Mb&&typeof Mb.apply=="function"?Mb.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)},LE;Mb&&typeof Mb.ownKeys=="function"?LE=Mb.ownKeys:Object.getOwnPropertySymbols?LE=function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:LE=function(e){return Object.getOwnPropertyNames(e)};function KKe(n){console&&console.warn&&console.warn(n)}var ete=Number.isNaN||function(e){return e!==e};function Xr(){Xr.init.call(this)}UB.exports=Xr;UB.exports.once=QKe;Xr.EventEmitter=Xr;Xr.prototype._events=void 0;Xr.prototype._eventsCount=0;Xr.prototype._maxListeners=void 0;var FH=10;function e$(n){if(typeof n!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}Object.defineProperty(Xr,"defaultMaxListeners",{enumerable:!0,get:function(){return FH},set:function(n){if(typeof n!="number"||n<0||ete(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");FH=n}});Xr.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};Xr.prototype.setMaxListeners=function(e){if(typeof e!="number"||e<0||ete(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this};function tte(n){return n._maxListeners===void 0?Xr.defaultMaxListeners:n._maxListeners}Xr.prototype.getMaxListeners=function(){return tte(this)};Xr.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var s=e==="error",i=this._events;if(i!==void 0)s=s&&i.error===void 0;else if(!s)return!1;if(s){var o;if(t.length>0&&(o=t[0]),o instanceof Error)throw o;var a=new Error("Unhandled error."+(o?" ("+o.message+")":""));throw a.context=o,a}var l=i[e];if(l===void 0)return!1;if(typeof l=="function")OH(l,this,t);else for(var c=l.length,u=ote(l,c),r=0;r<c;++r)OH(u[r],this,t);return!0};function nte(n,e,t,r){var s,i,o;if(e$(t),i=n._events,i===void 0?(i=n._events=Object.create(null),n._eventsCount=0):(i.newListener!==void 0&&(n.emit("newListener",e,t.listener?t.listener:t),i=n._events),o=i[e]),o===void 0)o=i[e]=t,++n._eventsCount;else if(typeof o=="function"?o=i[e]=r?[t,o]:[o,t]:r?o.unshift(t):o.push(t),s=tte(n),s>0&&o.length>s&&!o.warned){o.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=n,a.type=e,a.count=o.length,KKe(a)}return n}Xr.prototype.addListener=function(e,t){return nte(this,e,t,!1)};Xr.prototype.on=Xr.prototype.addListener;Xr.prototype.prependListener=function(e,t){return nte(this,e,t,!0)};function YKe(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function rte(n,e,t){var r={fired:!1,wrapFn:void 0,target:n,type:e,listener:t},s=YKe.bind(r);return s.listener=t,r.wrapFn=s,s}Xr.prototype.once=function(e,t){return e$(t),this.on(e,rte(this,e,t)),this};Xr.prototype.prependOnceListener=function(e,t){return e$(t),this.prependListener(e,rte(this,e,t)),this};Xr.prototype.removeListener=function(e,t){var r,s,i,o,a;if(e$(t),s=this._events,s===void 0)return this;if(r=s[e],r===void 0)return this;if(r===t||r.listener===t)--this._eventsCount===0?this._events=Object.create(null):(delete s[e],s.removeListener&&this.emit("removeListener",e,r.listener||t));else if(typeof r!="function"){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){a=r[o].listener,i=o;break}if(i<0)return this;i===0?r.shift():ZKe(r,i),r.length===1&&(s[e]=r[0]),s.removeListener!==void 0&&this.emit("removeListener",e,a||t)}return this};Xr.prototype.off=Xr.prototype.removeListener;Xr.prototype.removeAllListeners=function(e){var t,r,s;if(r=this._events,r===void 0)return this;if(r.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):r[e]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete r[e]),this;if(arguments.length===0){var i=Object.keys(r),o;for(s=0;s<i.length;++s)o=i[s],o!=="removeListener"&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(t=r[e],typeof t=="function")this.removeListener(e,t);else if(t!==void 0)for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this};function ste(n,e,t){var r=n._events;if(r===void 0)return[];var s=r[e];return s===void 0?[]:typeof s=="function"?t?[s.listener||s]:[s]:t?JKe(s):ote(s,s.length)}Xr.prototype.listeners=function(e){return ste(this,e,!0)};Xr.prototype.rawListeners=function(e){return ste(this,e,!1)};Xr.listenerCount=function(n,e){return typeof n.listenerCount=="function"?n.listenerCount(e):ite.call(n,e)};Xr.prototype.listenerCount=ite;function ite(n){var e=this._events;if(e!==void 0){var t=e[n];if(typeof t=="function")return 1;if(t!==void 0)return t.length}return 0}Xr.prototype.eventNames=function(){return this._eventsCount>0?LE(this._events):[]};function ote(n,e){for(var t=new Array(e),r=0;r<e;++r)t[r]=n[r];return t}function ZKe(n,e){for(;e+1<n.length;e++)n[e]=n[e+1];n.pop()}function JKe(n){for(var e=new Array(n.length),t=0;t<e.length;++t)e[t]=n[t].listener||n[t];return e}function QKe(n,e){return new Promise(function(t,r){function s(o){n.removeListener(e,i),r(o)}function i(){typeof n.removeListener=="function"&&n.removeListener("error",s),t([].slice.call(arguments))}ate(n,e,i,{once:!0}),e!=="error"&&eYe(n,s,{once:!0})})}function eYe(n,e,t){typeof n.on=="function"&&ate(n,"error",e,t)}function ate(n,e,t,r){if(typeof n.on=="function")r.once?n.once(e,t):n.on(e,t);else if(typeof n.addEventListener=="function")n.addEventListener(e,function s(i){r.once&&n.removeEventListener(e,s),t(i)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n)}var tYe=UB.exports;(function(n,e){const{EventEmitter:t}=tYe,r=VB,s=e.eventHook=function(){return function(a){const{app:l,service:c}=a,u=a.event===null?a.event:l.eventMappings[a.method],h=c._hookEvents&&c._hookEvents.indexOf(u)!==-1;u&&h&&a.type!=="error"&&(Array.isArray(a.result)?a.result:[a.result]).forEach(d=>c.emit(u,d,a))}},i=e.eventMixin=function(a){if(a._serviceEvents)return;const l=this,c=typeof a.on=="function"&&typeof a.emit=="function";typeof a.mixin=="function"&&!c&&a.mixin(t.prototype),Object.defineProperties(a,{_serviceEvents:{value:Array.isArray(a.events)?a.events.slice():[]},_hookEvents:{value:[]}}),Object.keys(l.eventMappings).forEach(u=>{const h=l.eventMappings[u],f=a._serviceEvents.indexOf(h)!==-1;typeof a[u]=="function"&&!f&&(a._serviceEvents.push(h),a._hookEvents.push(h))})};n.exports=function(){return function(o){Object.assign(o,{eventMappings:{create:"created",update:"updated",remove:"removed",patch:"patched"}}),o.hooks({finally:s()}),r.mixin(t.prototype,o),o.mixins.push(i)}}})(wO,wO.exports);var nYe=wO.exports,xO={exports:{}};const{_:rYe}=Dp,sYe=n=>{const{service:e,method:t}=n,r=e.methods[t];return n.arguments.forEach((s,i)=>{n[r[i]]=s}),n.params||(n.params={}),n},iYe=n=>{const{service:e,method:t,path:r}=n,s=e.methods[t];if(s.includes("id")&&n.id===void 0)throw new Error(`An id must be provided to the '${r}.${t}' method`);if(s.includes("data")&&!rYe.isObjectOrArray(n.data))throw new Error(`A data object must be provided to the '${r}.${t}' method`);return n};var oYe=[sYe,iYe];(function(n,e){const{hooks:t,isPromise:r}=Dp,s=oYe,{createHookObject:i,getHooks:o,processHooks:a,enableHooks:l,ACTIVATE_HOOKS:c}=t,u=function({app:d,service:p,method:m,original:g}){return(y={})=>{const b=d.hookTypes.reduce((x,w)=>{const S=y[w]||[];return x[w]=Array.isArray(S)?S:[S],x},{});return function(...x){const w=x[x.length-1]===!0?x.pop():!1,S=i(m,{type:"before",arguments:x,service:p,app:d});return Promise.resolve(S).then(C=>a.call(p,s.concat(b.before),C)).then(C=>typeof C.result<"u"?C:new Promise(A=>{const M=g||p[m],E=p.methods[m].map(O=>C[O]),N=M.apply(p,E);if(!r(N))throw new Error(`Service method '${C.method}' for '${C.path}' service must return a promise`);A(N)}).then(A=>(C.result=A,C)).catch(A=>{throw A.hook=C,A})).then(C=>{const k=Object.assign({},C,{type:"after"});return a.call(p,b.after,k)}).catch(C=>{const k=Object.assign({},C.hook,{type:"error",original:C.hook,error:C,result:void 0});return a.call(p,b.error,k).catch(A=>Object.assign({},A.hook,{error:A,result:void 0}))}).then(C=>a.call(p,b.finally,C).catch(k=>Object.assign({},k.hook,{error:k,result:void 0}))).then(C=>typeof C.error<"u"&&typeof C.result>"u"?Promise.reject(w?C:C.error):w?C:C.result)}}},h=e.hookMixin=function(d){if(typeof d.hooks=="function")return;d.methods=Object.getOwnPropertyNames(d).filter(y=>typeof d[y]=="function"&&d[y][c]).reduce((y,b)=>(y[b]=d[b][c],y),d.methods||{}),Object.assign(d.methods,{find:["params"],get:["id","params"],create:["data","params"],update:["id","data","params"],patch:["id","data","params"],remove:["id","params"]});const p=this,m=Object.keys(d.methods),g=m.reduce((y,b)=>(typeof d[b]!="function"||(y[b]=function(){const x=this,w=Array.from(arguments),S=x._super.bind(x);return u({app:p,service:x,method:b,original:S})({before:o(p,x,"before",b),after:o(p,x,"after",b,!0),error:o(p,x,"error",b,!0),finally:o(p,x,"finally",b,!0)})(...w)}),y),{});l(d,m,p.hookTypes),d.mixin(g)};n.exports=function(){return function(f){Object.assign(f,{hookTypes:["before","after","error","finally"]}),l(f,f.methods,f.hookTypes),f.mixins.push(h)}},n.exports.withHooks=u,n.exports.ACTIVATE_HOOKS=c,n.exports.activateHooks=function(d){return p=>(Object.defineProperty(p,c,{value:d}),p)}})(xO,xO.exports);var lte=xO.exports,cte="4.5.17";const _3=LB("feathers:application"),{stripSlashes:LH}=Dp,aYe=VB,lYe=nYe,cYe=lte,uYe=cte,zH=aYe.extend({create:null}),hYe={init(){Object.assign(this,{version:uYe,methods:["find","get","create","update","patch","remove"],mixins:[],services:{},providers:[],_setup:!1,settings:{}}),this.configure(cYe()),this.configure(lYe())},get(n){return this.settings[n]},set(n,e){return this.settings[n]=e,this},disable(n){return this.settings[n]=!1,this},disabled(n){return!this.settings[n]},enable(n){return this.settings[n]=!0,this},enabled(n){return!!this.settings[n]},configure(n){return n.call(this,this),this},service(n,e){if(typeof e<"u")throw new Error("Registering a new service with `app.service(path, service)` is no longer supported. Use `app.use(path, service)` instead.");const t=LH(n)||"/",r=this.services.hasOwnProperty(t)?this.services[t]:void 0;return typeof r>"u"&&typeof this.defaultService=="function"?this.use(t,this.defaultService(t)).service(t):r},use(n,e,t={}){if(typeof n!="string")throw new Error(`'${n}' is not a valid service path.`);const r=LH(n)||"/",s=typeof e.service=="function"&&e.services,i=this.methods.concat("setup").some(a=>typeof e[a]=="function");if(s){const a=e;return Object.keys(a.services).forEach(l=>this.use(`${r}/${l}`,a.service(l))),this}if(!i)throw new Error(`Invalid service object passed for path \`${r}\``);const o=zH.isPrototypeOf(e)?e:zH.extend(e);return _3(`Registering new service at \`${r}\``),this.mixins.forEach(a=>a.call(this,o,r,t)),typeof o._setup=="function"&&o._setup(this,r),this.providers.forEach(a=>a.call(this,o,r,t)),this._isSetup&&typeof o.setup=="function"&&(_3(`Setting up service for \`${r}\``),o.setup(this,r)),this.services[r]=o,this},setup(){return Object.keys(this.services).forEach(n=>{const e=this.services[n];_3(`Setting up service for \`${n}\``),typeof e.setup=="function"&&e.setup(this,n)}),this._isSetup=!0,this}};var fYe=hYe;const dYe=VB,pYe=fYe,mYe=cte,{ACTIVATE_HOOKS:gYe,activateHooks:yYe}=lte,bYe=Object.create(null);function xC(){const n=Object.create(bYe);return dYe.mixin(pYe,n),n.init(),n}xC.version=mYe;xC.ACTIVATE_HOOKS=gYe;xC.activateHooks=yYe;BB.exports=xC;BB.exports.default=xC;var vYe=BB.exports;const wYe=Tp(vYe);var WB={exports:{}},t$={},xYe=pt&&pt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(t$,"__esModule",{value:!0});t$.Service=void 0;const _Ye=xYe(LB),BH=wC,ute=(0,_Ye.default)("@feathersjs/transport-commons/client"),SYe=["addListener","emit","listenerCount","listeners","on","once","prependListener","prependOnceListener","removeAllListeners","removeListener"],CYe=["eventNames","getMaxListeners","setMaxListeners"],kYe=n=>{CYe.forEach(e=>{n[e]=function(...t){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);return this.connection[e](...t)}}),SYe.forEach(e=>{n[e]=function(t,...r){if(typeof this.connection[e]!="function")throw new Error(`Can not call '${e}' on the client service connection`);const s=`${this.path} ${t}`;ute(`Calling emitter method ${e} with namespaced event '${s}'`);const i=this.connection[e](s,...r);return i===this.connection?this:i}})};let TYe=class{constructor(e){this.events=e.events,this.path=e.name,this.connection=e.connection,this.method=e.method,this.timeout=e.timeout||5e3,kYe(this)}send(e,...t){return new Promise((r,s)=>{const i=setTimeout(()=>s(new BH.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${e} on ${this.path}`,{timeout:this.timeout,method:e,path:this.path})),this.timeout);t.unshift(e,this.path),t.push(function(o,a){return o=(0,BH.convert)(o),clearTimeout(i),o?s(o):r(a)}),ute(`Sending socket.${this.method}`,t),this.connection[this.method](...t)})}find(e={}){return this.send("find",e.query||{})}get(e,t={}){return this.send("get",e,t.query||{})}create(e,t={}){return this.send("create",e,t.query||{})}update(e,t,r={}){return this.send("update",e,t,r.query||{})}patch(e,t,r={}){return this.send("patch",e,t,r.query||{})}remove(e,t={}){return this.send("remove",e,t.query||{})}off(e,...t){if(typeof this.connection.off=="function"){const r=this.connection.off(`${this.path} ${e}`,...t);return r===this.connection?this:r}else if(t.length===0)return this.removeAllListeners(e);return this.removeListener(e,...t)}};t$.Service=TYe;var EYe=t$.Service;const VH=EYe;function hte(n,e){if(!n)throw new Error("Socket.io connection needs to be provided");if(n&&n.io&&n.io.engine&&n.io.engine.transport&&n.io.engine.transport.query&&n.io.engine.transport.query.EIO>3)throw console.error("You are trying to use the Socket.io client version 3 or later with Feathers v4 which only supports Socket.io version 2. Please use socket.io-client version 2 instead."),new Error("socket.io-client must be version 2.x");const t=function(s){const i=Object.keys(this.eventMappings||{}).map(a=>this.eventMappings[a]),o=Object.assign({},e,{events:i,name:s,connection:n,method:"emit"});return new VH(o)},r=function(s){if(typeof s.defaultService=="function")throw new Error("Only one default client provider can be configured");s.io=n,s.defaultService=t};return r.Service=VH,r.service=t,r}WB.exports=hte;WB.exports.default=hte;var IYe=WB.exports;const AYe=Tp(IYe);var GB={exports:{}},fte={},n$={},_O={exports:{}};(function(n,e){Object.defineProperty(e,"__esModule",{value:!0}),e.OPERATORS=e.FILTERS=void 0;const t=Dp,r=wC;function s(u){if(typeof u<"u")return Math.abs(parseInt(u,10))}function i(u,h){if(h&&h.default){const f=typeof u=="number"&&!isNaN(u)?u:h.default,d=typeof h.max=="number"?h.max:Number.MAX_VALUE;return Math.min(f,d)}return u}function o(u){return typeof u!="object"||Array.isArray(u)?u:Object.keys(u).reduce((h,f)=>(h[f]=typeof u[f]=="object"?u[f]:parseInt(u[f],10),h),{})}function a(u,h,f){if(Array.isArray(u))return u.map(d=>a(d,h,f));if(t._.isObject(u)&&u.constructor==={}.constructor){const d={};return t._.each(u,(p,m)=>{if(m[0]==="$"){if(f[m]!==void 0)return;if(!h.includes(m))throw new r.BadRequest(`Invalid query parameter ${m}`,u)}d[m]=a(p,h,f)}),Object.getOwnPropertySymbols(u).forEach(p=>{d[p]=u[p]}),d}return u}function l(u,h,f,d){return Array.isArray(f)?t._.each(f,p=>{h[p]!==void 0&&(u[p]=h[p])}):t._.each(f,(p,m)=>{const g=p(h[m],d);g!==void 0&&(u[m]=g)}),u}e.FILTERS={$sort:u=>o(u),$limit:(u,h)=>i(s(u),h.paginate),$skip:u=>s(u),$select:u=>u},e.OPERATORS=["$in","$nin","$lt","$lte","$gt","$gte","$ne","$or"];function c(u,h={}){const{filters:f={},operators:d=[]}=h,p={};return p.filters=l({},u,e.FILTERS,h),p.filters=l(p.filters,u,f,h),p.query=a(u,e.OPERATORS.concat(d),p.filters),p}e.default=c,n.exports=Object.assign(c,n.exports)})(_O,_O.exports);var dte=_O.exports,MYe=pt&&pt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(n$,"__esModule",{value:!0});n$.AdapterService=void 0;const E1=wC,NYe=MYe(dte),R0=(n,e,...t)=>typeof n[e]!="function"?Promise.reject(new E1.NotImplemented(`Method ${e} not available`)):n[e](...t),$Ye={find:!0,get:!1,update:!1};let RYe=class{constructor(e){this.options=Object.assign({id:"id",events:[],paginate:{},multi:!1,filters:[],whitelist:[]},e)}get id(){return this.options.id}get events(){return this.options.events}filterQuery(e={},t={}){const r=typeof e.paginate<"u"?e.paginate:this.options.paginate,{query:s={}}=e,i=Object.assign({operators:this.options.whitelist||[],filters:this.options.filters,paginate:r},t),o=(0,NYe.default)(s,i);return Object.assign(o,{paginate:r})}allowsMulti(e){const t=$Ye[e];if(typeof t<"u")return t;const r=this.options.multi;return r===!0||r===!1?r:r.includes(e)}find(e){return R0(this,"_find",e)}get(e,t){return R0(this,"_get",e,t)}create(e,t){return Array.isArray(e)&&!this.allowsMulti("create")?Promise.reject(new E1.MethodNotAllowed("Can not create multiple entries")):R0(this,"_create",e,t)}update(e,t,r){return e===null||Array.isArray(t)?Promise.reject(new E1.BadRequest("You can not replace multiple instances. Did you mean 'patch'?")):R0(this,"_update",e,t,r)}patch(e,t,r){return e===null&&!this.allowsMulti("patch")?Promise.reject(new E1.MethodNotAllowed("Can not patch multiple entries")):R0(this,"_patch",e,t,r)}remove(e,t){return e===null&&!this.allowsMulti("remove")?Promise.reject(new E1.MethodNotAllowed("Can not remove multiple entries")):R0(this,"_remove",e,t)}};n$.AdapterService=RYe;var pte={};(function(n){Object.defineProperty(n,"__esModule",{value:!0}),n.sorter=n.compare=n.compareArrays=n.compareNSB=void 0;function e(i,o){return i<o?-1:i>o?1:0}n.compareNSB=e;function t(i,o){let a,l;for(a=0;a<Math.min(i.length,o.length);a+=1)if(l=n.compare(i[a],o[a]),l!==0)return l;return n.compareNSB(i.length,o.length)}n.compareArrays=t;function r(i,o,a=n.compareNSB){const{compareNSB:l,compare:c,compareArrays:u}=n;if(i===void 0)return o===void 0?0:-1;if(o===void 0)return i===void 0?0:1;if(i===null)return o===null?0:-1;if(o===null)return i===null?0:1;if(typeof i=="number")return typeof o=="number"?l(i,o):-1;if(typeof o=="number")return typeof i=="number"?l(i,o):1;if(typeof i=="string")return typeof o=="string"?a(i,o):-1;if(typeof o=="string")return typeof i=="string"?a(i,o):1;if(typeof i=="boolean")return typeof o=="boolean"?l(i,o):-1;if(typeof o=="boolean")return typeof i=="boolean"?l(i,o):1;if(i instanceof Date)return o instanceof Date?l(i.getTime(),o.getTime()):-1;if(o instanceof Date)return i instanceof Date?l(i.getTime(),o.getTime()):1;if(Array.isArray(i))return Array.isArray(o)?u(i,o):-1;if(Array.isArray(o))return Array.isArray(i)?u(i,o):1;const h=Object.keys(i).sort(),f=Object.keys(o).sort();let d=0;for(let p=0;p<Math.min(h.length,f.length);p+=1)if(d=c(i[h[p]],o[f[p]]),d!==0)return d;return l(h.length,f.length)}n.compare=r;function s(i){const o=Object.keys(i).map(a=>{const l=i[a];return{key:a,direction:l}});return function(a,l){let c;for(const u of o)if(c=u.direction*n.compare(a[u.key],l[u.key]),c!==0)return c;return 0}}n.sorter=s})(pte);(function(n){var e=pt&&pt.__createBinding||(Object.create?function(l,c,u,h){h===void 0&&(h=u);var f=Object.getOwnPropertyDescriptor(c,u);(!f||("get"in f?!c.__esModule:f.writable||f.configurable))&&(f={enumerable:!0,get:function(){return c[u]}}),Object.defineProperty(l,h,f)}:function(l,c,u,h){h===void 0&&(h=u),l[h]=c[u]}),t=pt&&pt.__exportStar||function(l,c){for(var u in l)u!=="default"&&!Object.prototype.hasOwnProperty.call(c,u)&&e(c,l,u)},r=pt&&pt.__importDefault||function(l){return l&&l.__esModule?l:{default:l}};Object.defineProperty(n,"__esModule",{value:!0}),n.select=n.OPERATORS=n.FILTERS=n.filterQuery=n.AdapterService=void 0;const s=Dp;var i=n$;Object.defineProperty(n,"AdapterService",{enumerable:!0,get:function(){return i.AdapterService}});var o=dte;Object.defineProperty(n,"filterQuery",{enumerable:!0,get:function(){return r(o).default}}),Object.defineProperty(n,"FILTERS",{enumerable:!0,get:function(){return o.FILTERS}}),Object.defineProperty(n,"OPERATORS",{enumerable:!0,get:function(){return o.OPERATORS}}),t(pte,n);function a(l,...c){const u=l&&l.query&&l.query.$select;Array.isArray(u)&&c.length&&u.push(...c);const h=f=>Array.isArray(u)?s._.pick(f,...u):f;return f=>Array.isArray(f)?f.map(h):h(f)}n.select=a})(fte);function HB(n){var e="[object "+n+"]";return function(t){return Object.prototype.toString.call(t)===e}}var lp=HB("Array"),mte=HB("Object"),PYe=HB("Function");function vc(n,e){return PYe(n.get)?n.get(e):n[e]}const DYe=n=>(e,t,r,s,i)=>i?!!i.find(([o,a,l])=>n(e,a,l)):n(e,t,r,s),oc=DYe(n=>function(e,t,r,s,i){if(!lp(t)||!t.length)return n(e,t);for(var o=0,a=t.length;o<a;o++)if(n(e,vc(t,o)))return!0;return!1});function gte(n){return function(e,t,r,s){if(!lp(t)||!t.length)return n(e,t,r,s);for(var i=0,o=t.length;i<o;i++)if(!n(e,vc(t,i),t,s))return!1;return!0}}function uu(n,e,t,r,s){return n.validate(n.options,e,t,r,s)}var qI={$eq:oc(function(n,e){return n(e)}),$ne:gte(function(n,e){return n(e)}),$gt:oc(function(n,e){return n(e)}),$gte:oc(function(n,e){return n(e)}),$lt:oc(function(n,e){return n(e)}),$lte:oc(function(n,e){return n(e)}),$mod:oc(function(n,e){return n(e)}),$in(n,e){return n(e)},$nin:function(n,e){return n(e)},$not:function(n,e,t,r){return n(e,t,r)},$type:function(n,e){return n(e)},$all:function(n,e,t,r,s){return qI.$and(n,e,t,r,s)},$size:function(n,e){return e?n===e.length:!1},$or:function(n,e,t,r){for(var s=0,i=n.length;s<i;s++)if(uu(vc(n,s),e,t,r))return!0;return!1},$nor:function(n,e,t,r){return!qI.$or(n,e,t,r)},$and:function(n,e,t,r,s){if(s){for(var i=0,o=n.length;i<o;i++)if(!uu(vc(n,i),e,t,r,s))return!1}else for(var i=0,o=n.length;i<o;i++)if(!uu(vc(n,i),e,t,r,s))return!1;return!0},$regex:oc(function(n,e){return typeof e=="string"&&n.test(e)}),$where:function(n,e,t,r){return n.call(e,e,t,r)},$elemMatch:function(n,e,t,r){return lp(e)?!!~OYe(e,n):uu(n,e,t,r)},$exists:function(n,e,t,r){return r.hasOwnProperty(t)===n}},Z1={$eq:function(n,e,{comparable:t,compare:r}){return n instanceof RegExp?oc(function(s){return typeof s=="string"&&n.test(s)}):n instanceof Function?oc(n):lp(n)&&!n.length?oc(function(s){return lp(s)&&!s.length}):oc(n===null?function(s){return s==null}:function(s){return r(t(s),t(n))===0})},$gt:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))>0}},$gte:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))>=0}},$lt:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))<0}},$lte:function(n,e,{comparable:t,compare:r}){return function(s){return r(t(s),t(n))<=0}},$in:function(n,e,t){const{comparable:r}=t;return function(s){if(s instanceof Array){for(var i=s.length;i--;)if(~n.indexOf(r(vc(s,i))))return!0}else{var o=r(s);if(o===s&&typeof s=="object"){for(var i=n.length;i--;)if(String(n[i])===String(s)&&String(s)!=="[object Object]")return!0}if(typeof o>"u"){for(var i=n.length;i--;)if(n[i]==null)return!0}for(var i=n.length;i--;){var a=bte(vc(n,i),t),l=uu(a,o,i,n);if(l&&String(l)!=="[object Object]"&&String(o)!=="[object Object]")return!0}return!!~n.indexOf(o)}return!1}},$nin:function(n,e,t){const r=Z1.$in(n,e,t);return function(s,i,o,a){return!r(s,i,o,a)}},$mod:function(n){return function(e){return e%n[0]==n[1]}},$ne:function(n,e,t){const r=Z1.$eq(n,e,t);return gte(function(s,i,o,a){return!r(s,i,o,a)})},$and:function(n,e,t){return n.map(db(t))},$all:function(n,e,t){return Z1.$and(n,e,t)},$or:function(n,e,t){return n.map(db(t))},$nor:function(n,e,t){return n.map(db(t))},$not:function(n,e,t){const r=db(t)(n);return function(s,i,o){return!uu(r,s,i,o)}},$type:function(n){return function(e,t,r){return e!=null?e instanceof n||e.constructor==n:!1}},$regex:function(n,e){return new RegExp(n,e.$options)},$where:function(n){return typeof n=="string"?new Function("obj","return "+n):n},$elemMatch:function(n,e,t){return db(t)(n)},$exists:function(n){return!!n}};function OYe(n,e){for(var t=0;t<n.length;t++)if(vc(n,t),uu(e,vc(n,t)))return t;return-1}function zE(n,e){return{options:n,validate:e}}function FYe({keyPath:n,child:e,query:t},r){const s=[];if(SO(r,n,0,r,s),s.length===1){const[i,o,a]=s[0];return uu(e,i,o,a)}return t&&typeof t.$ne<"u",s.map(([i])=>i),uu(e,void 0,void 0,void 0,s)}function SO(n,e,t,r,s){if(t===e.length||n==null){s.push([n,e[t-1],r]);return}var i=vc(e,t);if(lp(n)&&isNaN(Number(i)))for(var o=0,a=n.length;o<a;o++)SO(vc(n,o),e,t,n,s);else SO(vc(n,i),e,t+1,n,s)}function LYe(n,e,t){return zE({keyPath:n,child:e,query:t},FYe)}function zYe(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")}function db(n){const{comparable:e,expressions:t}=n;var r=function(a){return(!a||!zYe(a))&&(a={$eq:a}),a},s=function(a){a=e(a);var l=[];for(var c in a){var u=a[c];if(c!=="$options"){var h=qI[c]||n&&t&&t[c];if(h)Z1[c]&&(u=Z1[c](u,a,n)),l.push(zE(e(u),h));else{if(c.charCodeAt(0)===36)throw new Error("Unknown operation "+c);var f=c.split(".");l.push(LYe(f,i(u),u))}}}return l.length===1?l[0]:zE(l,qI.$and)},i=function(a){return a=r(a),BYe(a)?zE(a,XI):s(a)},o=function(a){return s(r(a))};return o}function XI(n,e){if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(mte(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var t in n)if(!XI(n[t],e[t]))return!1;return!0}else if(lp(n)){if(n.length!==e.length)return!1;for(var r=0,s=n.length;r<s;r++)if(!XI(n[r],e[r]))return!1;return!0}else return n===e}function yte(n,e){if(!mte(n))return e;for(var t in n)e.push(t),yte(n[t],e);return e}function BYe(n){return yte(n,[]).join(",").search(/[$.]/)===-1}function bte(n,e){var t=db(e)(n);return e&&e.select&&(t={options:t,validate:function(r,s,i,o){return uu(r,s&&e.select(s),i,o)}}),t}function VYe(n,e){e=Object.assign({compare:vte,comparable:jB},e);var t=bte(n,e);return function(r,s,i){return uu(t,r,s,i)}}function vte(n,e){if(XI(n,e))return 0;if(typeof n==typeof e){if(n>e)return 1;if(n<e)return-1}}function jB(n){return n instanceof Date?n.getTime():lp(n)?n.map(jB):n&&typeof n.toJSON=="function"?n.toJSON():n}const UYe=Object.freeze(Object.defineProperty({__proto__:null,comparable:jB,compare:vte,default:VYe},Symbol.toStringTag,{value:"Module"})),WYe=zf(UYe),GYe=wC,{_:P0}=Dp,{sorter:HYe,select:jYe,AdapterService:qYe}=fte,XYe=WYe.default,sT=(n,...e)=>jYe(...e)(JSON.parse(JSON.stringify(n)));let wte=class extends qYe{constructor(e={}){super(P0.extend({id:"id",matcher:XYe,sorter:HYe},e)),this._uId=e.startId||0,this.store=e.store||{}}async getEntries(e={}){const{query:t}=this.filterQuery(e);return this._find(Object.assign({},e,{paginate:!1,query:t}))}async _find(e={}){const{query:t,filters:r,paginate:s}=this.filterQuery(e);let i=P0.values(this.store).filter(this.options.matcher(t));const o=i.length;r.$sort!==void 0&&i.sort(this.options.sorter(r.$sort)),r.$skip!==void 0&&(i=i.slice(r.$skip)),r.$limit!==void 0&&(i=i.slice(0,r.$limit));const a={total:o,limit:r.$limit,skip:r.$skip||0,data:i.map(l=>sT(l,e))};return s&&s.default?a:a.data}async _get(e,t={}){if(e in this.store){const{query:r}=this.filterQuery(t),s=this.store[e];if(this.options.matcher(r)(s))return sT(s,t,this.id)}throw new GYe.NotFound(`No record found for id '${e}'`)}async _create(e,t={}){if(Array.isArray(e))return Promise.all(e.map(o=>this._create(o,t)));const r=e[this.id]||this._uId++,s=P0.extend({},e,{[this.id]:r}),i=this.store[r]=s;return sT(i,t,this.id)}async _update(e,t,r={}){const i=(await this._get(e))[this.id];return e=i==e?i:e,this.store[e]=P0.extend({},t,{[this.id]:e}),this._get(e,r)}async _patch(e,t,r={}){const s=i=>{const o=i[this.id];return this.store[o]=P0.extend(this.store[o],P0.omit(t,this.id)),sT(this.store[o],r,this.id)};return e===null?(await this.getEntries(r)).map(s):s(await this._get(e,r))}async _remove(e,t={}){if(e===null){const s=await this.getEntries(t);return Promise.all(s.map(i=>this._remove(i[this.id],t)))}const r=await this._get(e,t);return delete this.store[e],r}};GB.exports=n=>new wte(n);GB.exports.Service=wte;var xte=GB.exports;const KYe=Tp(xte);var qB={exports:{}};const{Service:YYe}=xte,UH=[];class _te extends YYe{constructor(e={}){if(super(e),this._storageKey=e.name||"feathers",this._storage=e.storage||typeof window<"u"&&window.localStorage,this._throttle=e.throttle||200,this._reuseKeys=e.reuseKeys||!1,this.store=null,!this._storage)throw new Error("The `storage` option needs to be provided");if(UH.indexOf(this._storageKey)===-1)UH.push(this._storageKey);else if(!this._reuseKeys)throw new Error(`The storage name '${this._storageKey}' is already in use by another instance.`);this.ready()}ready(){return this.store?Promise.resolve(this.store):Promise.resolve(this._storage.getItem(this._storageKey)).then(e=>JSON.parse(e||"{}")).then(e=>{const t=Object.keys(e),r=e[t[t.length-1]];return this._uId=t.length&&typeof r[this.id]<"u"?r[this.id]+1:this._uId,this.store=e})}flush(e){return this._timeout||(this._timeout=setTimeout(()=>{this._storage.setItem(this._storageKey,JSON.stringify(this.store)),delete this._timeout},this._throttle)),e}execute(e,...t){return this.ready().then(()=>super[e](...t))}find(...e){return this.execute("find",...e)}get(...e){return this.execute("get",...e)}create(...e){return this.execute("create",...e).then(t=>this.flush(t))}patch(...e){return this.execute("patch",...e).then(t=>this.flush(t))}update(...e){return this.execute("update",...e).then(t=>this.flush(t))}remove(...e){return this.execute("remove",...e).then(t=>this.flush(t))}}qB.exports=function(e){return new _te(e)};qB.exports.Service=_te;var ZYe=qB.exports;const JYe=Tp(ZYe);var KI={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */KI.exports;(function(n,e){(function(){var t,r="4.17.21",s=200,i="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",o="Expected a function",a="Invalid `variable` option passed into `_.template`",l="__lodash_hash_undefined__",c=500,u="__lodash_placeholder__",h=1,f=2,d=4,p=1,m=2,g=1,y=2,b=4,x=8,w=16,S=32,C=64,k=128,A=256,M=512,E=30,N="...",O=800,R=16,D=1,z=2,B=3,X=1/0,G=9007199254740991,te=17976931348623157e292,ge=0/0,ae=4294967295,Ne=ae-1,ke=ae>>>1,De=[["ary",k],["bind",g],["bindKey",y],["curry",x],["curryRight",w],["flip",M],["partial",S],["partialRight",C],["rearg",A]],be="[object Arguments]",Xe="[object Array]",Oe="[object AsyncFunction]",it="[object Boolean]",We="[object Date]",dt="[object DOMException]",ct="[object Error]",Ve="[object Function]",ze="[object GeneratorFunction]",Be="[object Map]",ut="[object Number]",Ke="[object Null]",ee="[object Object]",J="[object Promise]",rt="[object Proxy]",Ge="[object RegExp]",ye="[object Set]",Ze="[object String]",yt="[object Symbol]",Ct="[object Undefined]",ft="[object WeakMap]",ce="[object WeakSet]",nt="[object ArrayBuffer]",St="[object DataView]",gt="[object Float32Array]",Gt="[object Float64Array]",Mn="[object Int8Array]",Cr="[object Int16Array]",Bs="[object Int32Array]",As="[object Uint8Array]",Ms="[object Uint8ClampedArray]",Oh="[object Uint16Array]",Bl="[object Uint32Array]",Vl=/\b__p \+= '';/g,go=/\b(__p \+=) '' \+/g,Ul=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Fc=/&(?:amp|lt|gt|quot|#39);/g,Lc=/[&<>"']/g,Di=RegExp(Fc.source),Fh=RegExp(Lc.source),rl=/<%-([\s\S]+?)%>/g,Lh=/<%([\s\S]+?)%>/g,re=/<%=([\s\S]+?)%>/g,Ue=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Fe=/^\w*$/,Je=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,vt=/[\\^$.*+?()[\]{}|]/g,zn=RegExp(vt.source),sn=/^\s+/,Tn=/\s/,En=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Nn=/\{\n\/\* \[wrapped with (.+)\] \*/,er=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,ur=/[()=,{}\[\]\/\s]/,Oi=/\\(\\)?/g,xr=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Zi=/\w*$/,Ar=/^[-+]0x[0-9a-f]+$/i,Io=/^0b[01]+$/i,rs=/^\[object .+?Constructor\]$/,yo=/^0o[0-7]+$/i,Ao=/^(?:0|[1-9]\d*)$/,Ns=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,bo=/($^)/,zh=/['\n\r\u2028\u2029\\]/g,sl="\\ud800-\\udfff",Ji="\\u0300-\\u036f",zc="\\ufe20-\\ufe2f",Aa="\\u20d0-\\u20ff",$s=Ji+zc+Aa,Bc="\\u2700-\\u27bf",Qi="a-z\\xdf-\\xf6\\xf8-\\xff",Vs="\\xac\\xb1\\xd7\\xf7",Bh="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",o0="\\u2000-\\u206f",Vh=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",eo="A-Z\\xc0-\\xd6\\xd8-\\xde",Uh="\\ufe0e\\ufe0f",Jf=Vs+Bh+o0+Vh,Hu="['’]",Qf="["+sl+"]",Wh="["+Jf+"]",Wl="["+$s+"]",Zr="\\d+",a0="["+Bc+"]",ed="["+Qi+"]",Vc="[^"+sl+Jf+Zr+Bc+Qi+eo+"]",Gh="\\ud83c[\\udffb-\\udfff]",l0="(?:"+Wl+"|"+Gh+")",c0="[^"+sl+"]",H="(?:\\ud83c[\\udde6-\\uddff]){2}",Y="[\\ud800-\\udbff][\\udc00-\\udfff]",pe="["+eo+"]",Re="\\u200d",at="(?:"+ed+"|"+Vc+")",Vt="(?:"+pe+"|"+Vc+")",$n="(?:"+Hu+"(?:d|ll|m|re|s|t|ve))?",Rs="(?:"+Hu+"(?:D|LL|M|RE|S|T|VE))?",Us=l0+"?",pi="["+Uh+"]?",Ma="(?:"+Re+"(?:"+[c0,H,Y].join("|")+")"+pi+Us+")*",bx="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Gp="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",ZC=pi+Us+Ma,K$="(?:"+[a0,H,Y].join("|")+")"+ZC,Y$="(?:"+[c0+Wl+"?",Wl,H,Y,Qf].join("|")+")",Z$=RegExp(Hu,"g"),vx=RegExp(Wl,"g"),u0=RegExp(Gh+"(?="+Gh+")|"+Y$+ZC,"g"),JC=RegExp([pe+"?"+ed+"+"+$n+"(?="+[Wh,pe,"$"].join("|")+")",Vt+"+"+Rs+"(?="+[Wh,pe+at,"$"].join("|")+")",pe+"?"+at+"+"+$n,pe+"+"+Rs,Gp,bx,Zr,K$].join("|"),"g"),Hp=RegExp("["+Re+sl+$s+Uh+"]"),il=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,J$=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Q$=-1,Br={};Br[gt]=Br[Gt]=Br[Mn]=Br[Cr]=Br[Bs]=Br[As]=Br[Ms]=Br[Oh]=Br[Bl]=!0,Br[be]=Br[Xe]=Br[nt]=Br[it]=Br[St]=Br[We]=Br[ct]=Br[Ve]=Br[Be]=Br[ut]=Br[ee]=Br[Ge]=Br[ye]=Br[Ze]=Br[ft]=!1;var Rr={};Rr[be]=Rr[Xe]=Rr[nt]=Rr[St]=Rr[it]=Rr[We]=Rr[gt]=Rr[Gt]=Rr[Mn]=Rr[Cr]=Rr[Bs]=Rr[Be]=Rr[ut]=Rr[ee]=Rr[Ge]=Rr[ye]=Rr[Ze]=Rr[yt]=Rr[As]=Rr[Ms]=Rr[Oh]=Rr[Bl]=!0,Rr[ct]=Rr[Ve]=Rr[ft]=!1;var wx={À:"A",Á:"A",Â:"A",Ã:"A",Ä:"A",Å:"A",à:"a",á:"a",â:"a",ã:"a",ä:"a",å:"a",Ç:"C",ç:"c",Ð:"D",ð:"d",È:"E",É:"E",Ê:"E",Ë:"E",è:"e",é:"e",ê:"e",ë:"e",Ì:"I",Í:"I",Î:"I",Ï:"I",ì:"i",í:"i",î:"i",ï:"i",Ñ:"N",ñ:"n",Ò:"O",Ó:"O",Ô:"O",Õ:"O",Ö:"O",Ø:"O",ò:"o",ó:"o",ô:"o",õ:"o",ö:"o",ø:"o",Ù:"U",Ú:"U",Û:"U",Ü:"U",ù:"u",ú:"u",û:"u",ü:"u",Ý:"Y",ý:"y",ÿ:"y",Æ:"Ae",æ:"ae",Þ:"Th",þ:"th",ß:"ss",Ā:"A",Ă:"A",Ą:"A",ā:"a",ă:"a",ą:"a",Ć:"C",Ĉ:"C",Ċ:"C",Č:"C",ć:"c",ĉ:"c",ċ:"c",č:"c",Ď:"D",Đ:"D",ď:"d",đ:"d",Ē:"E",Ĕ:"E",Ė:"E",Ę:"E",Ě:"E",ē:"e",ĕ:"e",ė:"e",ę:"e",ě:"e",Ĝ:"G",Ğ:"G",Ġ:"G",Ģ:"G",ĝ:"g",ğ:"g",ġ:"g",ģ:"g",Ĥ:"H",Ħ:"H",ĥ:"h",ħ:"h",Ĩ:"I",Ī:"I",Ĭ:"I",Į:"I",İ:"I",ĩ:"i",ī:"i",ĭ:"i",į:"i",ı:"i",Ĵ:"J",ĵ:"j",Ķ:"K",ķ:"k",ĸ:"k",Ĺ:"L",Ļ:"L",Ľ:"L",Ŀ:"L",Ł:"L",ĺ:"l",ļ:"l",ľ:"l",ŀ:"l",ł:"l",Ń:"N",Ņ:"N",Ň:"N",Ŋ:"N",ń:"n",ņ:"n",ň:"n",ŋ:"n",Ō:"O",Ŏ:"O",Ő:"O",ō:"o",ŏ:"o",ő:"o",Ŕ:"R",Ŗ:"R",Ř:"R",ŕ:"r",ŗ:"r",ř:"r",Ś:"S",Ŝ:"S",Ş:"S",Š:"S",ś:"s",ŝ:"s",ş:"s",š:"s",Ţ:"T",Ť:"T",Ŧ:"T",ţ:"t",ť:"t",ŧ:"t",Ũ:"U",Ū:"U",Ŭ:"U",Ů:"U",Ű:"U",Ų:"U",ũ:"u",ū:"u",ŭ:"u",ů:"u",ű:"u",ų:"u",Ŵ:"W",ŵ:"w",Ŷ:"Y",ŷ:"y",Ÿ:"Y",Ź:"Z",Ż:"Z",Ž:"Z",ź:"z",ż:"z",ž:"z",Ĳ:"IJ",ĳ:"ij",Œ:"Oe",œ:"oe",ŉ:"'n",ſ:"s"},xx={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},td={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},QC={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},_x=parseFloat,eR=parseInt,ek=typeof pt=="object"&&pt&&pt.Object===Object&&pt,jp=typeof self=="object"&&self&&self.Object===Object&&self,mi=ek||jp||Function("return this")(),h0=e&&!e.nodeType&&e,Hh=h0&&!0&&n&&!n.nodeType&&n,tk=Hh&&Hh.exports===h0,nd=tk&&ek.process,ia=function(){try{var Ae=Hh&&Hh.require&&Hh.require("util").types;return Ae||nd&&nd.binding&&nd.binding("util")}catch{}}(),nk=ia&&ia.isArrayBuffer,Sx=ia&&ia.isDate,rk=ia&&ia.isMap,sk=ia&&ia.isRegExp,f0=ia&&ia.isSet,d0=ia&&ia.isTypedArray;function Mo(Ae,je,Le){switch(Le.length){case 0:return Ae.call(je);case 1:return Ae.call(je,Le[0]);case 2:return Ae.call(je,Le[0],Le[1]);case 3:return Ae.call(je,Le[0],Le[1],Le[2])}return Ae.apply(je,Le)}function tR(Ae,je,Le,jt){for(var Pn=-1,Er=Ae==null?0:Ae.length;++Pn<Er;){var Li=Ae[Pn];je(jt,Li,Le(Li),Ae)}return jt}function Na(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt&&je(Ae[Le],Le,Ae)!==!1;);return Ae}function nR(Ae,je){for(var Le=Ae==null?0:Ae.length;Le--&&je(Ae[Le],Le,Ae)!==!1;);return Ae}function ik(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt;)if(!je(Ae[Le],Le,Ae))return!1;return!0}function Uc(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length,Pn=0,Er=[];++Le<jt;){var Li=Ae[Le];je(Li,Le,Ae)&&(Er[Pn++]=Li)}return Er}function p0(Ae,je){var Le=Ae==null?0:Ae.length;return!!Le&&T(Ae,je,0)>-1}function Cx(Ae,je,Le){for(var jt=-1,Pn=Ae==null?0:Ae.length;++jt<Pn;)if(Le(je,Ae[jt]))return!0;return!1}function Vr(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length,Pn=Array(jt);++Le<jt;)Pn[Le]=je(Ae[Le],Le,Ae);return Pn}function ju(Ae,je){for(var Le=-1,jt=je.length,Pn=Ae.length;++Le<jt;)Ae[Pn+Le]=je[Le];return Ae}function kx(Ae,je,Le,jt){var Pn=-1,Er=Ae==null?0:Ae.length;for(jt&&Er&&(Le=Ae[++Pn]);++Pn<Er;)Le=je(Le,Ae[Pn],Pn,Ae);return Le}function rR(Ae,je,Le,jt){var Pn=Ae==null?0:Ae.length;for(jt&&Pn&&(Le=Ae[--Pn]);Pn--;)Le=je(Le,Ae[Pn],Pn,Ae);return Le}function rd(Ae,je){for(var Le=-1,jt=Ae==null?0:Ae.length;++Le<jt;)if(je(Ae[Le],Le,Ae))return!0;return!1}var sR=ne("length");function iR(Ae){return Ae.split("")}function oR(Ae){return Ae.match(_n)||[]}function Tx(Ae,je,Le){var jt;return Le(Ae,function(Pn,Er,Li){if(je(Pn,Er,Li))return jt=Er,!1}),jt}function qp(Ae,je,Le,jt){for(var Pn=Ae.length,Er=Le+(jt?1:-1);jt?Er--:++Er<Pn;)if(je(Ae[Er],Er,Ae))return Er;return-1}function T(Ae,je,Le){return je===je?Sue(Ae,je,Le):qp(Ae,L,Le)}function $(Ae,je,Le,jt){for(var Pn=Le-1,Er=Ae.length;++Pn<Er;)if(jt(Ae[Pn],je))return Pn;return-1}function L(Ae){return Ae!==Ae}function W(Ae,je){var Le=Ae==null?0:Ae.length;return Le?Pe(Ae,je)/Le:ge}function ne(Ae){return function(je){return je==null?t:je[Ae]}}function oe(Ae){return function(je){return Ae==null?t:Ae[je]}}function ie(Ae,je,Le,jt,Pn){return Pn(Ae,function(Er,Li,Jr){Le=jt?(jt=!1,Er):je(Le,Er,Li,Jr)}),Le}function Ce(Ae,je){var Le=Ae.length;for(Ae.sort(je);Le--;)Ae[Le]=Ae[Le].value;return Ae}function Pe(Ae,je){for(var Le,jt=-1,Pn=Ae.length;++jt<Pn;){var Er=je(Ae[jt]);Er!==t&&(Le=Le===t?Er:Le+Er)}return Le}function ht(Ae,je){for(var Le=-1,jt=Array(Ae);++Le<Ae;)jt[Le]=je(Le);return jt}function Et(Ae,je){return Vr(je,function(Le){return[Le,Ae[Le]]})}function hn(Ae){return Ae&&Ae.slice(0,oU(Ae)+1).replace(sn,"")}function Ut(Ae){return function(je){return Ae(je)}}function Rt(Ae,je){return Vr(je,function(Le){return Ae[Le]})}function an(Ae,je){return Ae.has(je)}function Bn(Ae,je){for(var Le=-1,jt=Ae.length;++Le<jt&&T(je,Ae[Le],0)>-1;);return Le}function Ur(Ae,je){for(var Le=Ae.length;Le--&&T(je,Ae[Le],0)>-1;);return Le}function Wr(Ae,je){for(var Le=Ae.length,jt=0;Le--;)Ae[Le]===je&&++jt;return jt}var Fi=oe(wx),$a=oe(xx);function No(Ae){return"\\"+QC[Ae]}function br(Ae,je){return Ae==null?t:Ae[je]}function xs(Ae){return Hp.test(Ae)}function qu(Ae){return il.test(Ae)}function aR(Ae){for(var je,Le=[];!(je=Ae.next()).done;)Le.push(je.value);return Le}function Ex(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt,Pn){Le[++je]=[Pn,jt]}),Le}function ok(Ae,je){return function(Le){return Ae(je(Le))}}function Xu(Ae,je){for(var Le=-1,jt=Ae.length,Pn=0,Er=[];++Le<jt;){var Li=Ae[Le];(Li===je||Li===u)&&(Ae[Le]=u,Er[Pn++]=Le)}return Er}function m0(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt){Le[++je]=jt}),Le}function g0(Ae){var je=-1,Le=Array(Ae.size);return Ae.forEach(function(jt){Le[++je]=[jt,jt]}),Le}function Sue(Ae,je,Le){for(var jt=Le-1,Pn=Ae.length;++jt<Pn;)if(Ae[jt]===je)return jt;return-1}function Cue(Ae,je,Le){for(var jt=Le+1;jt--;)if(Ae[jt]===je)return jt;return jt}function y0(Ae){return xs(Ae)?Tue(Ae):sR(Ae)}function Wc(Ae){return xs(Ae)?Eue(Ae):iR(Ae)}function oU(Ae){for(var je=Ae.length;je--&&Tn.test(Ae.charAt(je)););return je}var kue=oe(td);function Tue(Ae){for(var je=u0.lastIndex=0;u0.test(Ae);)++je;return je}function Eue(Ae){return Ae.match(u0)||[]}function Iue(Ae){return Ae.match(JC)||[]}var Aue=function Ae(je){je=je==null?mi:b0.defaults(mi.Object(),je,b0.pick(mi,J$));var Le=je.Array,jt=je.Date,Pn=je.Error,Er=je.Function,Li=je.Math,Jr=je.Object,lR=je.RegExp,Mue=je.String,Gl=je.TypeError,ak=Le.prototype,Nue=Er.prototype,v0=Jr.prototype,lk=je["__core-js_shared__"],ck=Nue.toString,Pr=v0.hasOwnProperty,$ue=0,aU=function(){var v=/[^.]+$/.exec(lk&&lk.keys&&lk.keys.IE_PROTO||"");return v?"Symbol(src)_1."+v:""}(),uk=v0.toString,Rue=ck.call(Jr),Pue=mi._,Due=lR("^"+ck.call(Pr).replace(vt,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),hk=tk?je.Buffer:t,sd=je.Symbol,fk=je.Uint8Array,lU=hk?hk.allocUnsafe:t,dk=ok(Jr.getPrototypeOf,Jr),cU=Jr.create,uU=v0.propertyIsEnumerable,pk=ak.splice,hU=sd?sd.isConcatSpreadable:t,Ix=sd?sd.iterator:t,Xp=sd?sd.toStringTag:t,mk=function(){try{var v=Qp(Jr,"defineProperty");return v({},"",{}),v}catch{}}(),Oue=je.clearTimeout!==mi.clearTimeout&&je.clearTimeout,Fue=jt&&jt.now!==mi.Date.now&&jt.now,Lue=je.setTimeout!==mi.setTimeout&&je.setTimeout,gk=Li.ceil,yk=Li.floor,cR=Jr.getOwnPropertySymbols,zue=hk?hk.isBuffer:t,fU=je.isFinite,Bue=ak.join,Vue=ok(Jr.keys,Jr),zi=Li.max,$o=Li.min,Uue=jt.now,Wue=je.parseInt,dU=Li.random,Gue=ak.reverse,uR=Qp(je,"DataView"),Ax=Qp(je,"Map"),hR=Qp(je,"Promise"),w0=Qp(je,"Set"),Mx=Qp(je,"WeakMap"),Nx=Qp(Jr,"create"),bk=Mx&&new Mx,x0={},Hue=em(uR),jue=em(Ax),que=em(hR),Xue=em(w0),Kue=em(Mx),vk=sd?sd.prototype:t,$x=vk?vk.valueOf:t,pU=vk?vk.toString:t;function q(v){if(Ws(v)&&!On(v)&&!(v instanceof sr)){if(v instanceof Hl)return v;if(Pr.call(v,"__wrapped__"))return mW(v)}return new Hl(v)}var _0=function(){function v(){}return function(_){if(!Ps(_))return{};if(cU)return cU(_);v.prototype=_;var I=new v;return v.prototype=t,I}}();function wk(){}function Hl(v,_){this.__wrapped__=v,this.__actions__=[],this.__chain__=!!_,this.__index__=0,this.__values__=t}q.templateSettings={escape:rl,evaluate:Lh,interpolate:re,variable:"",imports:{_:q}},q.prototype=wk.prototype,q.prototype.constructor=q,Hl.prototype=_0(wk.prototype),Hl.prototype.constructor=Hl;function sr(v){this.__wrapped__=v,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=ae,this.__views__=[]}function Yue(){var v=new sr(this.__wrapped__);return v.__actions__=Ra(this.__actions__),v.__dir__=this.__dir__,v.__filtered__=this.__filtered__,v.__iteratees__=Ra(this.__iteratees__),v.__takeCount__=this.__takeCount__,v.__views__=Ra(this.__views__),v}function Zue(){if(this.__filtered__){var v=new sr(this);v.__dir__=-1,v.__filtered__=!0}else v=this.clone(),v.__dir__*=-1;return v}function Jue(){var v=this.__wrapped__.value(),_=this.__dir__,I=On(v),P=_<0,V=I?v.length:0,K=ufe(0,V,this.__views__),le=K.start,xe=K.end,Me=xe-le,Qe=P?xe:le-1,et=this.__iteratees__,lt=et.length,Ft=0,tn=$o(Me,this.__takeCount__);if(!I||!P&&V==Me&&tn==Me)return LU(v,this.__actions__);var mn=[];e:for(;Me--&&Ft<tn;){Qe+=_;for(var Xn=-1,gn=v[Qe];++Xn<lt;){var tr=et[Xn],hr=tr.iteratee,ll=tr.type,la=hr(gn);if(ll==z)gn=la;else if(!la){if(ll==D)continue e;break e}}mn[Ft++]=gn}return mn}sr.prototype=_0(wk.prototype),sr.prototype.constructor=sr;function Kp(v){var _=-1,I=v==null?0:v.length;for(this.clear();++_<I;){var P=v[_];this.set(P[0],P[1])}}function Que(){this.__data__=Nx?Nx(null):{},this.size=0}function ehe(v){var _=this.has(v)&&delete this.__data__[v];return this.size-=_?1:0,_}function the(v){var _=this.__data__;if(Nx){var I=_[v];return I===l?t:I}return Pr.call(_,v)?_[v]:t}function nhe(v){var _=this.__data__;return Nx?_[v]!==t:Pr.call(_,v)}function rhe(v,_){var I=this.__data__;return this.size+=this.has(v)?0:1,I[v]=Nx&&_===t?l:_,this}Kp.prototype.clear=Que,Kp.prototype.delete=ehe,Kp.prototype.get=the,Kp.prototype.has=nhe,Kp.prototype.set=rhe;function jh(v){var _=-1,I=v==null?0:v.length;for(this.clear();++_<I;){var P=v[_];this.set(P[0],P[1])}}function she(){this.__data__=[],this.size=0}function ihe(v){var _=this.__data__,I=xk(_,v);if(I<0)return!1;var P=_.length-1;return I==P?_.pop():pk.call(_,I,1),--this.size,!0}function ohe(v){var _=this.__data__,I=xk(_,v);return I<0?t:_[I][1]}function ahe(v){return xk(this.__data__,v)>-1}function lhe(v,_){var I=this.__data__,P=xk(I,v);return P<0?(++this.size,I.push([v,_])):I[P][1]=_,this}jh.prototype.clear=she,jh.prototype.delete=ihe,jh.prototype.get=ohe,jh.prototype.has=ahe,jh.prototype.set=lhe;function qh(v){var _=-1,I=v==null?0:v.length;for(this.clear();++_<I;){var P=v[_];this.set(P[0],P[1])}}function che(){this.size=0,this.__data__={hash:new Kp,map:new(Ax||jh),string:new Kp}}function uhe(v){var _=Rk(this,v).delete(v);return this.size-=_?1:0,_}function hhe(v){return Rk(this,v).get(v)}function fhe(v){return Rk(this,v).has(v)}function dhe(v,_){var I=Rk(this,v),P=I.size;return I.set(v,_),this.size+=I.size==P?0:1,this}qh.prototype.clear=che,qh.prototype.delete=uhe,qh.prototype.get=hhe,qh.prototype.has=fhe,qh.prototype.set=dhe;function Yp(v){var _=-1,I=v==null?0:v.length;for(this.__data__=new qh;++_<I;)this.add(v[_])}function phe(v){return this.__data__.set(v,l),this}function mhe(v){return this.__data__.has(v)}Yp.prototype.add=Yp.prototype.push=phe,Yp.prototype.has=mhe;function Gc(v){var _=this.__data__=new jh(v);this.size=_.size}function ghe(){this.__data__=new jh,this.size=0}function yhe(v){var _=this.__data__,I=_.delete(v);return this.size=_.size,I}function bhe(v){return this.__data__.get(v)}function vhe(v){return this.__data__.has(v)}function whe(v,_){var I=this.__data__;if(I instanceof jh){var P=I.__data__;if(!Ax||P.length<s-1)return P.push([v,_]),this.size=++I.size,this;I=this.__data__=new qh(P)}return I.set(v,_),this.size=I.size,this}Gc.prototype.clear=ghe,Gc.prototype.delete=yhe,Gc.prototype.get=bhe,Gc.prototype.has=vhe,Gc.prototype.set=whe;function mU(v,_){var I=On(v),P=!I&&tm(v),V=!I&&!P&&cd(v),K=!I&&!P&&!V&&T0(v),le=I||P||V||K,xe=le?ht(v.length,Mue):[],Me=xe.length;for(var Qe in v)(_||Pr.call(v,Qe))&&!(le&&(Qe=="length"||V&&(Qe=="offset"||Qe=="parent")||K&&(Qe=="buffer"||Qe=="byteLength"||Qe=="byteOffset")||Zh(Qe,Me)))&&xe.push(Qe);return xe}function gU(v){var _=v.length;return _?v[_R(0,_-1)]:t}function xhe(v,_){return Pk(Ra(v),Zp(_,0,v.length))}function _he(v){return Pk(Ra(v))}function fR(v,_,I){(I!==t&&!Hc(v[_],I)||I===t&&!(_ in v))&&Xh(v,_,I)}function Rx(v,_,I){var P=v[_];(!(Pr.call(v,_)&&Hc(P,I))||I===t&&!(_ in v))&&Xh(v,_,I)}function xk(v,_){for(var I=v.length;I--;)if(Hc(v[I][0],_))return I;return-1}function She(v,_,I,P){return id(v,function(V,K,le){_(P,V,I(V),le)}),P}function yU(v,_){return v&&Yu(_,to(_),v)}function Che(v,_){return v&&Yu(_,Da(_),v)}function Xh(v,_,I){_=="__proto__"&&mk?mk(v,_,{configurable:!0,enumerable:!0,value:I,writable:!0}):v[_]=I}function dR(v,_){for(var I=-1,P=_.length,V=Le(P),K=v==null;++I<P;)V[I]=K?t:qR(v,_[I]);return V}function Zp(v,_,I){return v===v&&(I!==t&&(v=v<=I?v:I),_!==t&&(v=v>=_?v:_)),v}function jl(v,_,I,P,V,K){var le,xe=_&h,Me=_&f,Qe=_&d;if(I&&(le=V?I(v,P,V,K):I(v)),le!==t)return le;if(!Ps(v))return v;var et=On(v);if(et){if(le=ffe(v),!xe)return Ra(v,le)}else{var lt=Ro(v),Ft=lt==Ve||lt==ze;if(cd(v))return VU(v,xe);if(lt==ee||lt==be||Ft&&!V){if(le=Me||Ft?{}:oW(v),!xe)return Me?tfe(v,Che(le,v)):efe(v,yU(le,v))}else{if(!Rr[lt])return V?v:{};le=dfe(v,lt,xe)}}K||(K=new Gc);var tn=K.get(v);if(tn)return tn;K.set(v,le),DW(v)?v.forEach(function(gn){le.add(jl(gn,_,I,gn,v,K))}):RW(v)&&v.forEach(function(gn,tr){le.set(tr,jl(gn,_,I,tr,v,K))});var mn=Qe?Me?RR:$R:Me?Da:to,Xn=et?t:mn(v);return Na(Xn||v,function(gn,tr){Xn&&(tr=gn,gn=v[tr]),Rx(le,tr,jl(gn,_,I,tr,v,K))}),le}function khe(v){var _=to(v);return function(I){return bU(I,v,_)}}function bU(v,_,I){var P=I.length;if(v==null)return!P;for(v=Jr(v);P--;){var V=I[P],K=_[V],le=v[V];if(le===t&&!(V in v)||!K(le))return!1}return!0}function vU(v,_,I){if(typeof v!="function")throw new Gl(o);return Bx(function(){v.apply(t,I)},_)}function Px(v,_,I,P){var V=-1,K=p0,le=!0,xe=v.length,Me=[],Qe=_.length;if(!xe)return Me;I&&(_=Vr(_,Ut(I))),P?(K=Cx,le=!1):_.length>=s&&(K=an,le=!1,_=new Yp(_));e:for(;++V<xe;){var et=v[V],lt=I==null?et:I(et);if(et=P||et!==0?et:0,le&&lt===lt){for(var Ft=Qe;Ft--;)if(_[Ft]===lt)continue e;Me.push(et)}else K(_,lt,P)||Me.push(et)}return Me}var id=jU(Ku),wU=jU(mR,!0);function The(v,_){var I=!0;return id(v,function(P,V,K){return I=!!_(P,V,K),I}),I}function _k(v,_,I){for(var P=-1,V=v.length;++P<V;){var K=v[P],le=_(K);if(le!=null&&(xe===t?le===le&&!al(le):I(le,xe)))var xe=le,Me=K}return Me}function Ehe(v,_,I,P){var V=v.length;for(I=Wn(I),I<0&&(I=-I>V?0:V+I),P=P===t||P>V?V:Wn(P),P<0&&(P+=V),P=I>P?0:FW(P);I<P;)v[I++]=_;return v}function xU(v,_){var I=[];return id(v,function(P,V,K){_(P,V,K)&&I.push(P)}),I}function vo(v,_,I,P,V){var K=-1,le=v.length;for(I||(I=mfe),V||(V=[]);++K<le;){var xe=v[K];_>0&&I(xe)?_>1?vo(xe,_-1,I,P,V):ju(V,xe):P||(V[V.length]=xe)}return V}var pR=qU(),_U=qU(!0);function Ku(v,_){return v&&pR(v,_,to)}function mR(v,_){return v&&_U(v,_,to)}function Sk(v,_){return Uc(_,function(I){return Jh(v[I])})}function Jp(v,_){_=ad(_,v);for(var I=0,P=_.length;v!=null&&I<P;)v=v[Zu(_[I++])];return I&&I==P?v:t}function SU(v,_,I){var P=_(v);return On(v)?P:ju(P,I(v))}function oa(v){return v==null?v===t?Ct:Ke:Xp&&Xp in Jr(v)?cfe(v):_fe(v)}function gR(v,_){return v>_}function Ihe(v,_){return v!=null&&Pr.call(v,_)}function Ahe(v,_){return v!=null&&_ in Jr(v)}function Mhe(v,_,I){return v>=$o(_,I)&&v<zi(_,I)}function yR(v,_,I){for(var P=I?Cx:p0,V=v[0].length,K=v.length,le=K,xe=Le(K),Me=1/0,Qe=[];le--;){var et=v[le];le&&_&&(et=Vr(et,Ut(_))),Me=$o(et.length,Me),xe[le]=!I&&(_||V>=120&&et.length>=120)?new Yp(le&&et):t}et=v[0];var lt=-1,Ft=xe[0];e:for(;++lt<V&&Qe.length<Me;){var tn=et[lt],mn=_?_(tn):tn;if(tn=I||tn!==0?tn:0,!(Ft?an(Ft,mn):P(Qe,mn,I))){for(le=K;--le;){var Xn=xe[le];if(!(Xn?an(Xn,mn):P(v[le],mn,I)))continue e}Ft&&Ft.push(mn),Qe.push(tn)}}return Qe}function Nhe(v,_,I,P){return Ku(v,function(V,K,le){_(P,I(V),K,le)}),P}function Dx(v,_,I){_=ad(_,v),v=uW(v,_);var P=v==null?v:v[Zu(Xl(_))];return P==null?t:Mo(P,v,I)}function CU(v){return Ws(v)&&oa(v)==be}function $he(v){return Ws(v)&&oa(v)==nt}function Rhe(v){return Ws(v)&&oa(v)==We}function Ox(v,_,I,P,V){return v===_?!0:v==null||_==null||!Ws(v)&&!Ws(_)?v!==v&&_!==_:Phe(v,_,I,P,Ox,V)}function Phe(v,_,I,P,V,K){var le=On(v),xe=On(_),Me=le?Xe:Ro(v),Qe=xe?Xe:Ro(_);Me=Me==be?ee:Me,Qe=Qe==be?ee:Qe;var et=Me==ee,lt=Qe==ee,Ft=Me==Qe;if(Ft&&cd(v)){if(!cd(_))return!1;le=!0,et=!1}if(Ft&&!et)return K||(K=new Gc),le||T0(v)?rW(v,_,I,P,V,K):afe(v,_,Me,I,P,V,K);if(!(I&p)){var tn=et&&Pr.call(v,"__wrapped__"),mn=lt&&Pr.call(_,"__wrapped__");if(tn||mn){var Xn=tn?v.value():v,gn=mn?_.value():_;return K||(K=new Gc),V(Xn,gn,I,P,K)}}return Ft?(K||(K=new Gc),lfe(v,_,I,P,V,K)):!1}function Dhe(v){return Ws(v)&&Ro(v)==Be}function bR(v,_,I,P){var V=I.length,K=V,le=!P;if(v==null)return!K;for(v=Jr(v);V--;){var xe=I[V];if(le&&xe[2]?xe[1]!==v[xe[0]]:!(xe[0]in v))return!1}for(;++V<K;){xe=I[V];var Me=xe[0],Qe=v[Me],et=xe[1];if(le&&xe[2]){if(Qe===t&&!(Me in v))return!1}else{var lt=new Gc;if(P)var Ft=P(Qe,et,Me,v,_,lt);if(!(Ft===t?Ox(et,Qe,p|m,P,lt):Ft))return!1}}return!0}function kU(v){if(!Ps(v)||yfe(v))return!1;var _=Jh(v)?Due:rs;return _.test(em(v))}function Ohe(v){return Ws(v)&&oa(v)==Ge}function Fhe(v){return Ws(v)&&Ro(v)==ye}function Lhe(v){return Ws(v)&&Bk(v.length)&&!!Br[oa(v)]}function TU(v){return typeof v=="function"?v:v==null?Oa:typeof v=="object"?On(v)?AU(v[0],v[1]):IU(v):XW(v)}function vR(v){if(!zx(v))return Vue(v);var _=[];for(var I in Jr(v))Pr.call(v,I)&&I!="constructor"&&_.push(I);return _}function zhe(v){if(!Ps(v))return xfe(v);var _=zx(v),I=[];for(var P in v)P=="constructor"&&(_||!Pr.call(v,P))||I.push(P);return I}function wR(v,_){return v<_}function EU(v,_){var I=-1,P=Pa(v)?Le(v.length):[];return id(v,function(V,K,le){P[++I]=_(V,K,le)}),P}function IU(v){var _=DR(v);return _.length==1&&_[0][2]?lW(_[0][0],_[0][1]):function(I){return I===v||bR(I,v,_)}}function AU(v,_){return FR(v)&&aW(_)?lW(Zu(v),_):function(I){var P=qR(I,v);return P===t&&P===_?XR(I,v):Ox(_,P,p|m)}}function Ck(v,_,I,P,V){v!==_&&pR(_,function(K,le){if(V||(V=new Gc),Ps(K))Bhe(v,_,le,I,Ck,P,V);else{var xe=P?P(zR(v,le),K,le+"",v,_,V):t;xe===t&&(xe=K),fR(v,le,xe)}},Da)}function Bhe(v,_,I,P,V,K,le){var xe=zR(v,I),Me=zR(_,I),Qe=le.get(Me);if(Qe){fR(v,I,Qe);return}var et=K?K(xe,Me,I+"",v,_,le):t,lt=et===t;if(lt){var Ft=On(Me),tn=!Ft&&cd(Me),mn=!Ft&&!tn&&T0(Me);et=Me,Ft||tn||mn?On(xe)?et=xe:ni(xe)?et=Ra(xe):tn?(lt=!1,et=VU(Me,!0)):mn?(lt=!1,et=UU(Me,!0)):et=[]:Vx(Me)||tm(Me)?(et=xe,tm(xe)?et=LW(xe):(!Ps(xe)||Jh(xe))&&(et=oW(Me))):lt=!1}lt&&(le.set(Me,et),V(et,Me,P,K,le),le.delete(Me)),fR(v,I,et)}function MU(v,_){var I=v.length;if(I)return _+=_<0?I:0,Zh(_,I)?v[_]:t}function NU(v,_,I){_.length?_=Vr(_,function(K){return On(K)?function(le){return Jp(le,K.length===1?K[0]:K)}:K}):_=[Oa];var P=-1;_=Vr(_,Ut(fn()));var V=EU(v,function(K,le,xe){var Me=Vr(_,function(Qe){return Qe(K)});return{criteria:Me,index:++P,value:K}});return Ce(V,function(K,le){return Qhe(K,le,I)})}function Vhe(v,_){return $U(v,_,function(I,P){return XR(v,P)})}function $U(v,_,I){for(var P=-1,V=_.length,K={};++P<V;){var le=_[P],xe=Jp(v,le);I(xe,le)&&Fx(K,ad(le,v),xe)}return K}function Uhe(v){return function(_){return Jp(_,v)}}function xR(v,_,I,P){var V=P?$:T,K=-1,le=_.length,xe=v;for(v===_&&(_=Ra(_)),I&&(xe=Vr(v,Ut(I)));++K<le;)for(var Me=0,Qe=_[K],et=I?I(Qe):Qe;(Me=V(xe,et,Me,P))>-1;)xe!==v&&pk.call(xe,Me,1),pk.call(v,Me,1);return v}function RU(v,_){for(var I=v?_.length:0,P=I-1;I--;){var V=_[I];if(I==P||V!==K){var K=V;Zh(V)?pk.call(v,V,1):kR(v,V)}}return v}function _R(v,_){return v+yk(dU()*(_-v+1))}function Whe(v,_,I,P){for(var V=-1,K=zi(gk((_-v)/(I||1)),0),le=Le(K);K--;)le[P?K:++V]=v,v+=I;return le}function SR(v,_){var I="";if(!v||_<1||_>G)return I;do _%2&&(I+=v),_=yk(_/2),_&&(v+=v);while(_);return I}function Yn(v,_){return BR(cW(v,_,Oa),v+"")}function Ghe(v){return gU(E0(v))}function Hhe(v,_){var I=E0(v);return Pk(I,Zp(_,0,I.length))}function Fx(v,_,I,P){if(!Ps(v))return v;_=ad(_,v);for(var V=-1,K=_.length,le=K-1,xe=v;xe!=null&&++V<K;){var Me=Zu(_[V]),Qe=I;if(Me==="__proto__"||Me==="constructor"||Me==="prototype")return v;if(V!=le){var et=xe[Me];Qe=P?P(et,Me,xe):t,Qe===t&&(Qe=Ps(et)?et:Zh(_[V+1])?[]:{})}Rx(xe,Me,Qe),xe=xe[Me]}return v}var PU=bk?function(v,_){return bk.set(v,_),v}:Oa,jhe=mk?function(v,_){return mk(v,"toString",{configurable:!0,enumerable:!1,value:YR(_),writable:!0})}:Oa;function qhe(v){return Pk(E0(v))}function ql(v,_,I){var P=-1,V=v.length;_<0&&(_=-_>V?0:V+_),I=I>V?V:I,I<0&&(I+=V),V=_>I?0:I-_>>>0,_>>>=0;for(var K=Le(V);++P<V;)K[P]=v[P+_];return K}function Xhe(v,_){var I;return id(v,function(P,V,K){return I=_(P,V,K),!I}),!!I}function kk(v,_,I){var P=0,V=v==null?P:v.length;if(typeof _=="number"&&_===_&&V<=ke){for(;P<V;){var K=P+V>>>1,le=v[K];le!==null&&!al(le)&&(I?le<=_:le<_)?P=K+1:V=K}return V}return CR(v,_,Oa,I)}function CR(v,_,I,P){var V=0,K=v==null?0:v.length;if(K===0)return 0;_=I(_);for(var le=_!==_,xe=_===null,Me=al(_),Qe=_===t;V<K;){var et=yk((V+K)/2),lt=I(v[et]),Ft=lt!==t,tn=lt===null,mn=lt===lt,Xn=al(lt);if(le)var gn=P||mn;else Qe?gn=mn&&(P||Ft):xe?gn=mn&&Ft&&(P||!tn):Me?gn=mn&&Ft&&!tn&&(P||!Xn):tn||Xn?gn=!1:gn=P?lt<=_:lt<_;gn?V=et+1:K=et}return $o(K,Ne)}function DU(v,_){for(var I=-1,P=v.length,V=0,K=[];++I<P;){var le=v[I],xe=_?_(le):le;if(!I||!Hc(xe,Me)){var Me=xe;K[V++]=le===0?0:le}}return K}function OU(v){return typeof v=="number"?v:al(v)?ge:+v}function ol(v){if(typeof v=="string")return v;if(On(v))return Vr(v,ol)+"";if(al(v))return pU?pU.call(v):"";var _=v+"";return _=="0"&&1/v==-X?"-0":_}function od(v,_,I){var P=-1,V=p0,K=v.length,le=!0,xe=[],Me=xe;if(I)le=!1,V=Cx;else if(K>=s){var Qe=_?null:ife(v);if(Qe)return m0(Qe);le=!1,V=an,Me=new Yp}else Me=_?[]:xe;e:for(;++P<K;){var et=v[P],lt=_?_(et):et;if(et=I||et!==0?et:0,le&&lt===lt){for(var Ft=Me.length;Ft--;)if(Me[Ft]===lt)continue e;_&&Me.push(lt),xe.push(et)}else V(Me,lt,I)||(Me!==xe&&Me.push(lt),xe.push(et))}return xe}function kR(v,_){return _=ad(_,v),v=uW(v,_),v==null||delete v[Zu(Xl(_))]}function FU(v,_,I,P){return Fx(v,_,I(Jp(v,_)),P)}function Tk(v,_,I,P){for(var V=v.length,K=P?V:-1;(P?K--:++K<V)&&_(v[K],K,v););return I?ql(v,P?0:K,P?K+1:V):ql(v,P?K+1:0,P?V:K)}function LU(v,_){var I=v;return I instanceof sr&&(I=I.value()),kx(_,function(P,V){return V.func.apply(V.thisArg,ju([P],V.args))},I)}function TR(v,_,I){var P=v.length;if(P<2)return P?od(v[0]):[];for(var V=-1,K=Le(P);++V<P;)for(var le=v[V],xe=-1;++xe<P;)xe!=V&&(K[V]=Px(K[V]||le,v[xe],_,I));return od(vo(K,1),_,I)}function zU(v,_,I){for(var P=-1,V=v.length,K=_.length,le={};++P<V;){var xe=P<K?_[P]:t;I(le,v[P],xe)}return le}function ER(v){return ni(v)?v:[]}function IR(v){return typeof v=="function"?v:Oa}function ad(v,_){return On(v)?v:FR(v,_)?[v]:pW(Mr(v))}var Khe=Yn;function ld(v,_,I){var P=v.length;return I=I===t?P:I,!_&&I>=P?v:ql(v,_,I)}var BU=Oue||function(v){return mi.clearTimeout(v)};function VU(v,_){if(_)return v.slice();var I=v.length,P=lU?lU(I):new v.constructor(I);return v.copy(P),P}function AR(v){var _=new v.constructor(v.byteLength);return new fk(_).set(new fk(v)),_}function Yhe(v,_){var I=_?AR(v.buffer):v.buffer;return new v.constructor(I,v.byteOffset,v.byteLength)}function Zhe(v){var _=new v.constructor(v.source,Zi.exec(v));return _.lastIndex=v.lastIndex,_}function Jhe(v){return $x?Jr($x.call(v)):{}}function UU(v,_){var I=_?AR(v.buffer):v.buffer;return new v.constructor(I,v.byteOffset,v.length)}function WU(v,_){if(v!==_){var I=v!==t,P=v===null,V=v===v,K=al(v),le=_!==t,xe=_===null,Me=_===_,Qe=al(_);if(!xe&&!Qe&&!K&&v>_||K&&le&&Me&&!xe&&!Qe||P&&le&&Me||!I&&Me||!V)return 1;if(!P&&!K&&!Qe&&v<_||Qe&&I&&V&&!P&&!K||xe&&I&&V||!le&&V||!Me)return-1}return 0}function Qhe(v,_,I){for(var P=-1,V=v.criteria,K=_.criteria,le=V.length,xe=I.length;++P<le;){var Me=WU(V[P],K[P]);if(Me){if(P>=xe)return Me;var Qe=I[P];return Me*(Qe=="desc"?-1:1)}}return v.index-_.index}function GU(v,_,I,P){for(var V=-1,K=v.length,le=I.length,xe=-1,Me=_.length,Qe=zi(K-le,0),et=Le(Me+Qe),lt=!P;++xe<Me;)et[xe]=_[xe];for(;++V<le;)(lt||V<K)&&(et[I[V]]=v[V]);for(;Qe--;)et[xe++]=v[V++];return et}function HU(v,_,I,P){for(var V=-1,K=v.length,le=-1,xe=I.length,Me=-1,Qe=_.length,et=zi(K-xe,0),lt=Le(et+Qe),Ft=!P;++V<et;)lt[V]=v[V];for(var tn=V;++Me<Qe;)lt[tn+Me]=_[Me];for(;++le<xe;)(Ft||V<K)&&(lt[tn+I[le]]=v[V++]);return lt}function Ra(v,_){var I=-1,P=v.length;for(_||(_=Le(P));++I<P;)_[I]=v[I];return _}function Yu(v,_,I,P){var V=!I;I||(I={});for(var K=-1,le=_.length;++K<le;){var xe=_[K],Me=P?P(I[xe],v[xe],xe,I,v):t;Me===t&&(Me=v[xe]),V?Xh(I,xe,Me):Rx(I,xe,Me)}return I}function efe(v,_){return Yu(v,OR(v),_)}function tfe(v,_){return Yu(v,sW(v),_)}function Ek(v,_){return function(I,P){var V=On(I)?tR:She,K=_?_():{};return V(I,v,fn(P,2),K)}}function S0(v){return Yn(function(_,I){var P=-1,V=I.length,K=V>1?I[V-1]:t,le=V>2?I[2]:t;for(K=v.length>3&&typeof K=="function"?(V--,K):t,le&&aa(I[0],I[1],le)&&(K=V<3?t:K,V=1),_=Jr(_);++P<V;){var xe=I[P];xe&&v(_,xe,P,K)}return _})}function jU(v,_){return function(I,P){if(I==null)return I;if(!Pa(I))return v(I,P);for(var V=I.length,K=_?V:-1,le=Jr(I);(_?K--:++K<V)&&P(le[K],K,le)!==!1;);return I}}function qU(v){return function(_,I,P){for(var V=-1,K=Jr(_),le=P(_),xe=le.length;xe--;){var Me=le[v?xe:++V];if(I(K[Me],Me,K)===!1)break}return _}}function nfe(v,_,I){var P=_&g,V=Lx(v);function K(){var le=this&&this!==mi&&this instanceof K?V:v;return le.apply(P?I:this,arguments)}return K}function XU(v){return function(_){_=Mr(_);var I=xs(_)?Wc(_):t,P=I?I[0]:_.charAt(0),V=I?ld(I,1).join(""):_.slice(1);return P[v]()+V}}function C0(v){return function(_){return kx(jW(HW(_).replace(Z$,"")),v,"")}}function Lx(v){return function(){var _=arguments;switch(_.length){case 0:return new v;case 1:return new v(_[0]);case 2:return new v(_[0],_[1]);case 3:return new v(_[0],_[1],_[2]);case 4:return new v(_[0],_[1],_[2],_[3]);case 5:return new v(_[0],_[1],_[2],_[3],_[4]);case 6:return new v(_[0],_[1],_[2],_[3],_[4],_[5]);case 7:return new v(_[0],_[1],_[2],_[3],_[4],_[5],_[6])}var I=_0(v.prototype),P=v.apply(I,_);return Ps(P)?P:I}}function rfe(v,_,I){var P=Lx(v);function V(){for(var K=arguments.length,le=Le(K),xe=K,Me=k0(V);xe--;)le[xe]=arguments[xe];var Qe=K<3&&le[0]!==Me&&le[K-1]!==Me?[]:Xu(le,Me);if(K-=Qe.length,K<I)return QU(v,_,Ik,V.placeholder,t,le,Qe,t,t,I-K);var et=this&&this!==mi&&this instanceof V?P:v;return Mo(et,this,le)}return V}function KU(v){return function(_,I,P){var V=Jr(_);if(!Pa(_)){var K=fn(I,3);_=to(_),I=function(xe){return K(V[xe],xe,V)}}var le=v(_,I,P);return le>-1?V[K?_[le]:le]:t}}function YU(v){return Yh(function(_){var I=_.length,P=I,V=Hl.prototype.thru;for(v&&_.reverse();P--;){var K=_[P];if(typeof K!="function")throw new Gl(o);if(V&&!le&&$k(K)=="wrapper")var le=new Hl([],!0)}for(P=le?P:I;++P<I;){K=_[P];var xe=$k(K),Me=xe=="wrapper"?PR(K):t;Me&&LR(Me[0])&&Me[1]==(k|x|S|A)&&!Me[4].length&&Me[9]==1?le=le[$k(Me[0])].apply(le,Me[3]):le=K.length==1&&LR(K)?le[xe]():le.thru(K)}return function(){var Qe=arguments,et=Qe[0];if(le&&Qe.length==1&&On(et))return le.plant(et).value();for(var lt=0,Ft=I?_[lt].apply(this,Qe):et;++lt<I;)Ft=_[lt].call(this,Ft);return Ft}})}function Ik(v,_,I,P,V,K,le,xe,Me,Qe){var et=_&k,lt=_&g,Ft=_&y,tn=_&(x|w),mn=_&M,Xn=Ft?t:Lx(v);function gn(){for(var tr=arguments.length,hr=Le(tr),ll=tr;ll--;)hr[ll]=arguments[ll];if(tn)var la=k0(gn),cl=Wr(hr,la);if(P&&(hr=GU(hr,P,V,tn)),K&&(hr=HU(hr,K,le,tn)),tr-=cl,tn&&tr<Qe){var ri=Xu(hr,la);return QU(v,_,Ik,gn.placeholder,I,hr,ri,xe,Me,Qe-tr)}var jc=lt?I:this,ef=Ft?jc[v]:v;return tr=hr.length,xe?hr=Sfe(hr,xe):mn&&tr>1&&hr.reverse(),et&&Me<tr&&(hr.length=Me),this&&this!==mi&&this instanceof gn&&(ef=Xn||Lx(ef)),ef.apply(jc,hr)}return gn}function ZU(v,_){return function(I,P){return Nhe(I,v,_(P),{})}}function Ak(v,_){return function(I,P){var V;if(I===t&&P===t)return _;if(I!==t&&(V=I),P!==t){if(V===t)return P;typeof I=="string"||typeof P=="string"?(I=ol(I),P=ol(P)):(I=OU(I),P=OU(P)),V=v(I,P)}return V}}function MR(v){return Yh(function(_){return _=Vr(_,Ut(fn())),Yn(function(I){var P=this;return v(_,function(V){return Mo(V,P,I)})})})}function Mk(v,_){_=_===t?" ":ol(_);var I=_.length;if(I<2)return I?SR(_,v):_;var P=SR(_,gk(v/y0(_)));return xs(_)?ld(Wc(P),0,v).join(""):P.slice(0,v)}function sfe(v,_,I,P){var V=_&g,K=Lx(v);function le(){for(var xe=-1,Me=arguments.length,Qe=-1,et=P.length,lt=Le(et+Me),Ft=this&&this!==mi&&this instanceof le?K:v;++Qe<et;)lt[Qe]=P[Qe];for(;Me--;)lt[Qe++]=arguments[++xe];return Mo(Ft,V?I:this,lt)}return le}function JU(v){return function(_,I,P){return P&&typeof P!="number"&&aa(_,I,P)&&(I=P=t),_=Qh(_),I===t?(I=_,_=0):I=Qh(I),P=P===t?_<I?1:-1:Qh(P),Whe(_,I,P,v)}}function Nk(v){return function(_,I){return typeof _=="string"&&typeof I=="string"||(_=Kl(_),I=Kl(I)),v(_,I)}}function QU(v,_,I,P,V,K,le,xe,Me,Qe){var et=_&x,lt=et?le:t,Ft=et?t:le,tn=et?K:t,mn=et?t:K;_|=et?S:C,_&=~(et?C:S),_&b||(_&=~(g|y));var Xn=[v,_,V,tn,lt,mn,Ft,xe,Me,Qe],gn=I.apply(t,Xn);return LR(v)&&hW(gn,Xn),gn.placeholder=P,fW(gn,v,_)}function NR(v){var _=Li[v];return function(I,P){if(I=Kl(I),P=P==null?0:$o(Wn(P),292),P&&fU(I)){var V=(Mr(I)+"e").split("e"),K=_(V[0]+"e"+(+V[1]+P));return V=(Mr(K)+"e").split("e"),+(V[0]+"e"+(+V[1]-P))}return _(I)}}var ife=w0&&1/m0(new w0([,-0]))[1]==X?function(v){return new w0(v)}:QR;function eW(v){return function(_){var I=Ro(_);return I==Be?Ex(_):I==ye?g0(_):Et(_,v(_))}}function Kh(v,_,I,P,V,K,le,xe){var Me=_&y;if(!Me&&typeof v!="function")throw new Gl(o);var Qe=P?P.length:0;if(Qe||(_&=~(S|C),P=V=t),le=le===t?le:zi(Wn(le),0),xe=xe===t?xe:Wn(xe),Qe-=V?V.length:0,_&C){var et=P,lt=V;P=V=t}var Ft=Me?t:PR(v),tn=[v,_,I,P,V,et,lt,K,le,xe];if(Ft&&wfe(tn,Ft),v=tn[0],_=tn[1],I=tn[2],P=tn[3],V=tn[4],xe=tn[9]=tn[9]===t?Me?0:v.length:zi(tn[9]-Qe,0),!xe&&_&(x|w)&&(_&=~(x|w)),!_||_==g)var mn=nfe(v,_,I);else _==x||_==w?mn=rfe(v,_,xe):(_==S||_==(g|S))&&!V.length?mn=sfe(v,_,I,P):mn=Ik.apply(t,tn);var Xn=Ft?PU:hW;return fW(Xn(mn,tn),v,_)}function tW(v,_,I,P){return v===t||Hc(v,v0[I])&&!Pr.call(P,I)?_:v}function nW(v,_,I,P,V,K){return Ps(v)&&Ps(_)&&(K.set(_,v),Ck(v,_,t,nW,K),K.delete(_)),v}function ofe(v){return Vx(v)?t:v}function rW(v,_,I,P,V,K){var le=I&p,xe=v.length,Me=_.length;if(xe!=Me&&!(le&&Me>xe))return!1;var Qe=K.get(v),et=K.get(_);if(Qe&&et)return Qe==_&&et==v;var lt=-1,Ft=!0,tn=I&m?new Yp:t;for(K.set(v,_),K.set(_,v);++lt<xe;){var mn=v[lt],Xn=_[lt];if(P)var gn=le?P(Xn,mn,lt,_,v,K):P(mn,Xn,lt,v,_,K);if(gn!==t){if(gn)continue;Ft=!1;break}if(tn){if(!rd(_,function(tr,hr){if(!an(tn,hr)&&(mn===tr||V(mn,tr,I,P,K)))return tn.push(hr)})){Ft=!1;break}}else if(!(mn===Xn||V(mn,Xn,I,P,K))){Ft=!1;break}}return K.delete(v),K.delete(_),Ft}function afe(v,_,I,P,V,K,le){switch(I){case St:if(v.byteLength!=_.byteLength||v.byteOffset!=_.byteOffset)return!1;v=v.buffer,_=_.buffer;case nt:return!(v.byteLength!=_.byteLength||!K(new fk(v),new fk(_)));case it:case We:case ut:return Hc(+v,+_);case ct:return v.name==_.name&&v.message==_.message;case Ge:case Ze:return v==_+"";case Be:var xe=Ex;case ye:var Me=P&p;if(xe||(xe=m0),v.size!=_.size&&!Me)return!1;var Qe=le.get(v);if(Qe)return Qe==_;P|=m,le.set(v,_);var et=rW(xe(v),xe(_),P,V,K,le);return le.delete(v),et;case yt:if($x)return $x.call(v)==$x.call(_)}return!1}function lfe(v,_,I,P,V,K){var le=I&p,xe=$R(v),Me=xe.length,Qe=$R(_),et=Qe.length;if(Me!=et&&!le)return!1;for(var lt=Me;lt--;){var Ft=xe[lt];if(!(le?Ft in _:Pr.call(_,Ft)))return!1}var tn=K.get(v),mn=K.get(_);if(tn&&mn)return tn==_&&mn==v;var Xn=!0;K.set(v,_),K.set(_,v);for(var gn=le;++lt<Me;){Ft=xe[lt];var tr=v[Ft],hr=_[Ft];if(P)var ll=le?P(hr,tr,Ft,_,v,K):P(tr,hr,Ft,v,_,K);if(!(ll===t?tr===hr||V(tr,hr,I,P,K):ll)){Xn=!1;break}gn||(gn=Ft=="constructor")}if(Xn&&!gn){var la=v.constructor,cl=_.constructor;la!=cl&&"constructor"in v&&"constructor"in _&&!(typeof la=="function"&&la instanceof la&&typeof cl=="function"&&cl instanceof cl)&&(Xn=!1)}return K.delete(v),K.delete(_),Xn}function Yh(v){return BR(cW(v,t,bW),v+"")}function $R(v){return SU(v,to,OR)}function RR(v){return SU(v,Da,sW)}var PR=bk?function(v){return bk.get(v)}:QR;function $k(v){for(var _=v.name+"",I=x0[_],P=Pr.call(x0,_)?I.length:0;P--;){var V=I[P],K=V.func;if(K==null||K==v)return V.name}return _}function k0(v){var _=Pr.call(q,"placeholder")?q:v;return _.placeholder}function fn(){var v=q.iteratee||ZR;return v=v===ZR?TU:v,arguments.length?v(arguments[0],arguments[1]):v}function Rk(v,_){var I=v.__data__;return gfe(_)?I[typeof _=="string"?"string":"hash"]:I.map}function DR(v){for(var _=to(v),I=_.length;I--;){var P=_[I],V=v[P];_[I]=[P,V,aW(V)]}return _}function Qp(v,_){var I=br(v,_);return kU(I)?I:t}function cfe(v){var _=Pr.call(v,Xp),I=v[Xp];try{v[Xp]=t;var P=!0}catch{}var V=uk.call(v);return P&&(_?v[Xp]=I:delete v[Xp]),V}var OR=cR?function(v){return v==null?[]:(v=Jr(v),Uc(cR(v),function(_){return uU.call(v,_)}))}:e3,sW=cR?function(v){for(var _=[];v;)ju(_,OR(v)),v=dk(v);return _}:e3,Ro=oa;(uR&&Ro(new uR(new ArrayBuffer(1)))!=St||Ax&&Ro(new Ax)!=Be||hR&&Ro(hR.resolve())!=J||w0&&Ro(new w0)!=ye||Mx&&Ro(new Mx)!=ft)&&(Ro=function(v){var _=oa(v),I=_==ee?v.constructor:t,P=I?em(I):"";if(P)switch(P){case Hue:return St;case jue:return Be;case que:return J;case Xue:return ye;case Kue:return ft}return _});function ufe(v,_,I){for(var P=-1,V=I.length;++P<V;){var K=I[P],le=K.size;switch(K.type){case"drop":v+=le;break;case"dropRight":_-=le;break;case"take":_=$o(_,v+le);break;case"takeRight":v=zi(v,_-le);break}}return{start:v,end:_}}function hfe(v){var _=v.match(Nn);return _?_[1].split(er):[]}function iW(v,_,I){_=ad(_,v);for(var P=-1,V=_.length,K=!1;++P<V;){var le=Zu(_[P]);if(!(K=v!=null&&I(v,le)))break;v=v[le]}return K||++P!=V?K:(V=v==null?0:v.length,!!V&&Bk(V)&&Zh(le,V)&&(On(v)||tm(v)))}function ffe(v){var _=v.length,I=new v.constructor(_);return _&&typeof v[0]=="string"&&Pr.call(v,"index")&&(I.index=v.index,I.input=v.input),I}function oW(v){return typeof v.constructor=="function"&&!zx(v)?_0(dk(v)):{}}function dfe(v,_,I){var P=v.constructor;switch(_){case nt:return AR(v);case it:case We:return new P(+v);case St:return Yhe(v,I);case gt:case Gt:case Mn:case Cr:case Bs:case As:case Ms:case Oh:case Bl:return UU(v,I);case Be:return new P;case ut:case Ze:return new P(v);case Ge:return Zhe(v);case ye:return new P;case yt:return Jhe(v)}}function pfe(v,_){var I=_.length;if(!I)return v;var P=I-1;return _[P]=(I>1?"& ":"")+_[P],_=_.join(I>2?", ":" "),v.replace(En,`{
/* [wrapped with `+_+`] */
`)}function mfe(v){return On(v)||tm(v)||!!(hU&&v&&v[hU])}function Zh(v,_){var I=typeof v;return _=_??G,!!_&&(I=="number"||I!="symbol"&&Ao.test(v))&&v>-1&&v%1==0&&v<_}function aa(v,_,I){if(!Ps(I))return!1;var P=typeof _;return(P=="number"?Pa(I)&&Zh(_,I.length):P=="string"&&_ in I)?Hc(I[_],v):!1}function FR(v,_){if(On(v))return!1;var I=typeof v;return I=="number"||I=="symbol"||I=="boolean"||v==null||al(v)?!0:Fe.test(v)||!Ue.test(v)||_!=null&&v in Jr(_)}function gfe(v){var _=typeof v;return _=="string"||_=="number"||_=="symbol"||_=="boolean"?v!=="__proto__":v===null}function LR(v){var _=$k(v),I=q[_];if(typeof I!="function"||!(_ in sr.prototype))return!1;if(v===I)return!0;var P=PR(I);return!!P&&v===P[0]}function yfe(v){return!!aU&&aU in v}var bfe=lk?Jh:t3;function zx(v){var _=v&&v.constructor,I=typeof _=="function"&&_.prototype||v0;return v===I}function aW(v){return v===v&&!Ps(v)}function lW(v,_){return function(I){return I==null?!1:I[v]===_&&(_!==t||v in Jr(I))}}function vfe(v){var _=Lk(v,function(P){return I.size===c&&I.clear(),P}),I=_.cache;return _}function wfe(v,_){var I=v[1],P=_[1],V=I|P,K=V<(g|y|k),le=P==k&&I==x||P==k&&I==A&&v[7].length<=_[8]||P==(k|A)&&_[7].length<=_[8]&&I==x;if(!(K||le))return v;P&g&&(v[2]=_[2],V|=I&g?0:b);var xe=_[3];if(xe){var Me=v[3];v[3]=Me?GU(Me,xe,_[4]):xe,v[4]=Me?Xu(v[3],u):_[4]}return xe=_[5],xe&&(Me=v[5],v[5]=Me?HU(Me,xe,_[6]):xe,v[6]=Me?Xu(v[5],u):_[6]),xe=_[7],xe&&(v[7]=xe),P&k&&(v[8]=v[8]==null?_[8]:$o(v[8],_[8])),v[9]==null&&(v[9]=_[9]),v[0]=_[0],v[1]=V,v}function xfe(v){var _=[];if(v!=null)for(var I in Jr(v))_.push(I);return _}function _fe(v){return uk.call(v)}function cW(v,_,I){return _=zi(_===t?v.length-1:_,0),function(){for(var P=arguments,V=-1,K=zi(P.length-_,0),le=Le(K);++V<K;)le[V]=P[_+V];V=-1;for(var xe=Le(_+1);++V<_;)xe[V]=P[V];return xe[_]=I(le),Mo(v,this,xe)}}function uW(v,_){return _.length<2?v:Jp(v,ql(_,0,-1))}function Sfe(v,_){for(var I=v.length,P=$o(_.length,I),V=Ra(v);P--;){var K=_[P];v[P]=Zh(K,I)?V[K]:t}return v}function zR(v,_){if(!(_==="constructor"&&typeof v[_]=="function")&&_!="__proto__")return v[_]}var hW=dW(PU),Bx=Lue||function(v,_){return mi.setTimeout(v,_)},BR=dW(jhe);function fW(v,_,I){var P=_+"";return BR(v,pfe(P,Cfe(hfe(P),I)))}function dW(v){var _=0,I=0;return function(){var P=Uue(),V=R-(P-I);if(I=P,V>0){if(++_>=O)return arguments[0]}else _=0;return v.apply(t,arguments)}}function Pk(v,_){var I=-1,P=v.length,V=P-1;for(_=_===t?P:_;++I<_;){var K=_R(I,V),le=v[K];v[K]=v[I],v[I]=le}return v.length=_,v}var pW=vfe(function(v){var _=[];return v.charCodeAt(0)===46&&_.push(""),v.replace(Je,function(I,P,V,K){_.push(V?K.replace(Oi,"$1"):P||I)}),_});function Zu(v){if(typeof v=="string"||al(v))return v;var _=v+"";return _=="0"&&1/v==-X?"-0":_}function em(v){if(v!=null){try{return ck.call(v)}catch{}try{return v+""}catch{}}return""}function Cfe(v,_){return Na(De,function(I){var P="_."+I[0];_&I[1]&&!p0(v,P)&&v.push(P)}),v.sort()}function mW(v){if(v instanceof sr)return v.clone();var _=new Hl(v.__wrapped__,v.__chain__);return _.__actions__=Ra(v.__actions__),_.__index__=v.__index__,_.__values__=v.__values__,_}function kfe(v,_,I){(I?aa(v,_,I):_===t)?_=1:_=zi(Wn(_),0);var P=v==null?0:v.length;if(!P||_<1)return[];for(var V=0,K=0,le=Le(gk(P/_));V<P;)le[K++]=ql(v,V,V+=_);return le}function Tfe(v){for(var _=-1,I=v==null?0:v.length,P=0,V=[];++_<I;){var K=v[_];K&&(V[P++]=K)}return V}function Efe(){var v=arguments.length;if(!v)return[];for(var _=Le(v-1),I=arguments[0],P=v;P--;)_[P-1]=arguments[P];return ju(On(I)?Ra(I):[I],vo(_,1))}var Ife=Yn(function(v,_){return ni(v)?Px(v,vo(_,1,ni,!0)):[]}),Afe=Yn(function(v,_){var I=Xl(_);return ni(I)&&(I=t),ni(v)?Px(v,vo(_,1,ni,!0),fn(I,2)):[]}),Mfe=Yn(function(v,_){var I=Xl(_);return ni(I)&&(I=t),ni(v)?Px(v,vo(_,1,ni,!0),t,I):[]});function Nfe(v,_,I){var P=v==null?0:v.length;return P?(_=I||_===t?1:Wn(_),ql(v,_<0?0:_,P)):[]}function $fe(v,_,I){var P=v==null?0:v.length;return P?(_=I||_===t?1:Wn(_),_=P-_,ql(v,0,_<0?0:_)):[]}function Rfe(v,_){return v&&v.length?Tk(v,fn(_,3),!0,!0):[]}function Pfe(v,_){return v&&v.length?Tk(v,fn(_,3),!0):[]}function Dfe(v,_,I,P){var V=v==null?0:v.length;return V?(I&&typeof I!="number"&&aa(v,_,I)&&(I=0,P=V),Ehe(v,_,I,P)):[]}function gW(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=I==null?0:Wn(I);return V<0&&(V=zi(P+V,0)),qp(v,fn(_,3),V)}function yW(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=P-1;return I!==t&&(V=Wn(I),V=I<0?zi(P+V,0):$o(V,P-1)),qp(v,fn(_,3),V,!0)}function bW(v){var _=v==null?0:v.length;return _?vo(v,1):[]}function Ofe(v){var _=v==null?0:v.length;return _?vo(v,X):[]}function Ffe(v,_){var I=v==null?0:v.length;return I?(_=_===t?1:Wn(_),vo(v,_)):[]}function Lfe(v){for(var _=-1,I=v==null?0:v.length,P={};++_<I;){var V=v[_];P[V[0]]=V[1]}return P}function vW(v){return v&&v.length?v[0]:t}function zfe(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=I==null?0:Wn(I);return V<0&&(V=zi(P+V,0)),T(v,_,V)}function Bfe(v){var _=v==null?0:v.length;return _?ql(v,0,-1):[]}var Vfe=Yn(function(v){var _=Vr(v,ER);return _.length&&_[0]===v[0]?yR(_):[]}),Ufe=Yn(function(v){var _=Xl(v),I=Vr(v,ER);return _===Xl(I)?_=t:I.pop(),I.length&&I[0]===v[0]?yR(I,fn(_,2)):[]}),Wfe=Yn(function(v){var _=Xl(v),I=Vr(v,ER);return _=typeof _=="function"?_:t,_&&I.pop(),I.length&&I[0]===v[0]?yR(I,t,_):[]});function Gfe(v,_){return v==null?"":Bue.call(v,_)}function Xl(v){var _=v==null?0:v.length;return _?v[_-1]:t}function Hfe(v,_,I){var P=v==null?0:v.length;if(!P)return-1;var V=P;return I!==t&&(V=Wn(I),V=V<0?zi(P+V,0):$o(V,P-1)),_===_?Cue(v,_,V):qp(v,L,V,!0)}function jfe(v,_){return v&&v.length?MU(v,Wn(_)):t}var qfe=Yn(wW);function wW(v,_){return v&&v.length&&_&&_.length?xR(v,_):v}function Xfe(v,_,I){return v&&v.length&&_&&_.length?xR(v,_,fn(I,2)):v}function Kfe(v,_,I){return v&&v.length&&_&&_.length?xR(v,_,t,I):v}var Yfe=Yh(function(v,_){var I=v==null?0:v.length,P=dR(v,_);return RU(v,Vr(_,function(V){return Zh(V,I)?+V:V}).sort(WU)),P});function Zfe(v,_){var I=[];if(!(v&&v.length))return I;var P=-1,V=[],K=v.length;for(_=fn(_,3);++P<K;){var le=v[P];_(le,P,v)&&(I.push(le),V.push(P))}return RU(v,V),I}function VR(v){return v==null?v:Gue.call(v)}function Jfe(v,_,I){var P=v==null?0:v.length;return P?(I&&typeof I!="number"&&aa(v,_,I)?(_=0,I=P):(_=_==null?0:Wn(_),I=I===t?P:Wn(I)),ql(v,_,I)):[]}function Qfe(v,_){return kk(v,_)}function ede(v,_,I){return CR(v,_,fn(I,2))}function tde(v,_){var I=v==null?0:v.length;if(I){var P=kk(v,_);if(P<I&&Hc(v[P],_))return P}return-1}function nde(v,_){return kk(v,_,!0)}function rde(v,_,I){return CR(v,_,fn(I,2),!0)}function sde(v,_){var I=v==null?0:v.length;if(I){var P=kk(v,_,!0)-1;if(Hc(v[P],_))return P}return-1}function ide(v){return v&&v.length?DU(v):[]}function ode(v,_){return v&&v.length?DU(v,fn(_,2)):[]}function ade(v){var _=v==null?0:v.length;return _?ql(v,1,_):[]}function lde(v,_,I){return v&&v.length?(_=I||_===t?1:Wn(_),ql(v,0,_<0?0:_)):[]}function cde(v,_,I){var P=v==null?0:v.length;return P?(_=I||_===t?1:Wn(_),_=P-_,ql(v,_<0?0:_,P)):[]}function ude(v,_){return v&&v.length?Tk(v,fn(_,3),!1,!0):[]}function hde(v,_){return v&&v.length?Tk(v,fn(_,3)):[]}var fde=Yn(function(v){return od(vo(v,1,ni,!0))}),dde=Yn(function(v){var _=Xl(v);return ni(_)&&(_=t),od(vo(v,1,ni,!0),fn(_,2))}),pde=Yn(function(v){var _=Xl(v);return _=typeof _=="function"?_:t,od(vo(v,1,ni,!0),t,_)});function mde(v){return v&&v.length?od(v):[]}function gde(v,_){return v&&v.length?od(v,fn(_,2)):[]}function yde(v,_){return _=typeof _=="function"?_:t,v&&v.length?od(v,t,_):[]}function UR(v){if(!(v&&v.length))return[];var _=0;return v=Uc(v,function(I){if(ni(I))return _=zi(I.length,_),!0}),ht(_,function(I){return Vr(v,ne(I))})}function xW(v,_){if(!(v&&v.length))return[];var I=UR(v);return _==null?I:Vr(I,function(P){return Mo(_,t,P)})}var bde=Yn(function(v,_){return ni(v)?Px(v,_):[]}),vde=Yn(function(v){return TR(Uc(v,ni))}),wde=Yn(function(v){var _=Xl(v);return ni(_)&&(_=t),TR(Uc(v,ni),fn(_,2))}),xde=Yn(function(v){var _=Xl(v);return _=typeof _=="function"?_:t,TR(Uc(v,ni),t,_)}),_de=Yn(UR);function Sde(v,_){return zU(v||[],_||[],Rx)}function Cde(v,_){return zU(v||[],_||[],Fx)}var kde=Yn(function(v){var _=v.length,I=_>1?v[_-1]:t;return I=typeof I=="function"?(v.pop(),I):t,xW(v,I)});function _W(v){var _=q(v);return _.__chain__=!0,_}function Tde(v,_){return _(v),v}function Dk(v,_){return _(v)}var Ede=Yh(function(v){var _=v.length,I=_?v[0]:0,P=this.__wrapped__,V=function(K){return dR(K,v)};return _>1||this.__actions__.length||!(P instanceof sr)||!Zh(I)?this.thru(V):(P=P.slice(I,+I+(_?1:0)),P.__actions__.push({func:Dk,args:[V],thisArg:t}),new Hl(P,this.__chain__).thru(function(K){return _&&!K.length&&K.push(t),K}))});function Ide(){return _W(this)}function Ade(){return new Hl(this.value(),this.__chain__)}function Mde(){this.__values__===t&&(this.__values__=OW(this.value()));var v=this.__index__>=this.__values__.length,_=v?t:this.__values__[this.__index__++];return{done:v,value:_}}function Nde(){return this}function $de(v){for(var _,I=this;I instanceof wk;){var P=mW(I);P.__index__=0,P.__values__=t,_?V.__wrapped__=P:_=P;var V=P;I=I.__wrapped__}return V.__wrapped__=v,_}function Rde(){var v=this.__wrapped__;if(v instanceof sr){var _=v;return this.__actions__.length&&(_=new sr(this)),_=_.reverse(),_.__actions__.push({func:Dk,args:[VR],thisArg:t}),new Hl(_,this.__chain__)}return this.thru(VR)}function Pde(){return LU(this.__wrapped__,this.__actions__)}var Dde=Ek(function(v,_,I){Pr.call(v,I)?++v[I]:Xh(v,I,1)});function Ode(v,_,I){var P=On(v)?ik:The;return I&&aa(v,_,I)&&(_=t),P(v,fn(_,3))}function Fde(v,_){var I=On(v)?Uc:xU;return I(v,fn(_,3))}var Lde=KU(gW),zde=KU(yW);function Bde(v,_){return vo(Ok(v,_),1)}function Vde(v,_){return vo(Ok(v,_),X)}function Ude(v,_,I){return I=I===t?1:Wn(I),vo(Ok(v,_),I)}function SW(v,_){var I=On(v)?Na:id;return I(v,fn(_,3))}function CW(v,_){var I=On(v)?nR:wU;return I(v,fn(_,3))}var Wde=Ek(function(v,_,I){Pr.call(v,I)?v[I].push(_):Xh(v,I,[_])});function Gde(v,_,I,P){v=Pa(v)?v:E0(v),I=I&&!P?Wn(I):0;var V=v.length;return I<0&&(I=zi(V+I,0)),Vk(v)?I<=V&&v.indexOf(_,I)>-1:!!V&&T(v,_,I)>-1}var Hde=Yn(function(v,_,I){var P=-1,V=typeof _=="function",K=Pa(v)?Le(v.length):[];return id(v,function(le){K[++P]=V?Mo(_,le,I):Dx(le,_,I)}),K}),jde=Ek(function(v,_,I){Xh(v,I,_)});function Ok(v,_){var I=On(v)?Vr:EU;return I(v,fn(_,3))}function qde(v,_,I,P){return v==null?[]:(On(_)||(_=_==null?[]:[_]),I=P?t:I,On(I)||(I=I==null?[]:[I]),NU(v,_,I))}var Xde=Ek(function(v,_,I){v[I?0:1].push(_)},function(){return[[],[]]});function Kde(v,_,I){var P=On(v)?kx:ie,V=arguments.length<3;return P(v,fn(_,4),I,V,id)}function Yde(v,_,I){var P=On(v)?rR:ie,V=arguments.length<3;return P(v,fn(_,4),I,V,wU)}function Zde(v,_){var I=On(v)?Uc:xU;return I(v,zk(fn(_,3)))}function Jde(v){var _=On(v)?gU:Ghe;return _(v)}function Qde(v,_,I){(I?aa(v,_,I):_===t)?_=1:_=Wn(_);var P=On(v)?xhe:Hhe;return P(v,_)}function epe(v){var _=On(v)?_he:qhe;return _(v)}function tpe(v){if(v==null)return 0;if(Pa(v))return Vk(v)?y0(v):v.length;var _=Ro(v);return _==Be||_==ye?v.size:vR(v).length}function npe(v,_,I){var P=On(v)?rd:Xhe;return I&&aa(v,_,I)&&(_=t),P(v,fn(_,3))}var rpe=Yn(function(v,_){if(v==null)return[];var I=_.length;return I>1&&aa(v,_[0],_[1])?_=[]:I>2&&aa(_[0],_[1],_[2])&&(_=[_[0]]),NU(v,vo(_,1),[])}),Fk=Fue||function(){return mi.Date.now()};function spe(v,_){if(typeof _!="function")throw new Gl(o);return v=Wn(v),function(){if(--v<1)return _.apply(this,arguments)}}function kW(v,_,I){return _=I?t:_,_=v&&_==null?v.length:_,Kh(v,k,t,t,t,t,_)}function TW(v,_){var I;if(typeof _!="function")throw new Gl(o);return v=Wn(v),function(){return--v>0&&(I=_.apply(this,arguments)),v<=1&&(_=t),I}}var WR=Yn(function(v,_,I){var P=g;if(I.length){var V=Xu(I,k0(WR));P|=S}return Kh(v,P,_,I,V)}),EW=Yn(function(v,_,I){var P=g|y;if(I.length){var V=Xu(I,k0(EW));P|=S}return Kh(_,P,v,I,V)});function IW(v,_,I){_=I?t:_;var P=Kh(v,x,t,t,t,t,t,_);return P.placeholder=IW.placeholder,P}function AW(v,_,I){_=I?t:_;var P=Kh(v,w,t,t,t,t,t,_);return P.placeholder=AW.placeholder,P}function MW(v,_,I){var P,V,K,le,xe,Me,Qe=0,et=!1,lt=!1,Ft=!0;if(typeof v!="function")throw new Gl(o);_=Kl(_)||0,Ps(I)&&(et=!!I.leading,lt="maxWait"in I,K=lt?zi(Kl(I.maxWait)||0,_):K,Ft="trailing"in I?!!I.trailing:Ft);function tn(ri){var jc=P,ef=V;return P=V=t,Qe=ri,le=v.apply(ef,jc),le}function mn(ri){return Qe=ri,xe=Bx(tr,_),et?tn(ri):le}function Xn(ri){var jc=ri-Me,ef=ri-Qe,KW=_-jc;return lt?$o(KW,K-ef):KW}function gn(ri){var jc=ri-Me,ef=ri-Qe;return Me===t||jc>=_||jc<0||lt&&ef>=K}function tr(){var ri=Fk();if(gn(ri))return hr(ri);xe=Bx(tr,Xn(ri))}function hr(ri){return xe=t,Ft&&P?tn(ri):(P=V=t,le)}function ll(){xe!==t&&BU(xe),Qe=0,P=Me=V=xe=t}function la(){return xe===t?le:hr(Fk())}function cl(){var ri=Fk(),jc=gn(ri);if(P=arguments,V=this,Me=ri,jc){if(xe===t)return mn(Me);if(lt)return BU(xe),xe=Bx(tr,_),tn(Me)}return xe===t&&(xe=Bx(tr,_)),le}return cl.cancel=ll,cl.flush=la,cl}var ipe=Yn(function(v,_){return vU(v,1,_)}),ope=Yn(function(v,_,I){return vU(v,Kl(_)||0,I)});function ape(v){return Kh(v,M)}function Lk(v,_){if(typeof v!="function"||_!=null&&typeof _!="function")throw new Gl(o);var I=function(){var P=arguments,V=_?_.apply(this,P):P[0],K=I.cache;if(K.has(V))return K.get(V);var le=v.apply(this,P);return I.cache=K.set(V,le)||K,le};return I.cache=new(Lk.Cache||qh),I}Lk.Cache=qh;function zk(v){if(typeof v!="function")throw new Gl(o);return function(){var _=arguments;switch(_.length){case 0:return!v.call(this);case 1:return!v.call(this,_[0]);case 2:return!v.call(this,_[0],_[1]);case 3:return!v.call(this,_[0],_[1],_[2])}return!v.apply(this,_)}}function lpe(v){return TW(2,v)}var cpe=Khe(function(v,_){_=_.length==1&&On(_[0])?Vr(_[0],Ut(fn())):Vr(vo(_,1),Ut(fn()));var I=_.length;return Yn(function(P){for(var V=-1,K=$o(P.length,I);++V<K;)P[V]=_[V].call(this,P[V]);return Mo(v,this,P)})}),GR=Yn(function(v,_){var I=Xu(_,k0(GR));return Kh(v,S,t,_,I)}),NW=Yn(function(v,_){var I=Xu(_,k0(NW));return Kh(v,C,t,_,I)}),upe=Yh(function(v,_){return Kh(v,A,t,t,t,_)});function hpe(v,_){if(typeof v!="function")throw new Gl(o);return _=_===t?_:Wn(_),Yn(v,_)}function fpe(v,_){if(typeof v!="function")throw new Gl(o);return _=_==null?0:zi(Wn(_),0),Yn(function(I){var P=I[_],V=ld(I,0,_);return P&&ju(V,P),Mo(v,this,V)})}function dpe(v,_,I){var P=!0,V=!0;if(typeof v!="function")throw new Gl(o);return Ps(I)&&(P="leading"in I?!!I.leading:P,V="trailing"in I?!!I.trailing:V),MW(v,_,{leading:P,maxWait:_,trailing:V})}function ppe(v){return kW(v,1)}function mpe(v,_){return GR(IR(_),v)}function gpe(){if(!arguments.length)return[];var v=arguments[0];return On(v)?v:[v]}function ype(v){return jl(v,d)}function bpe(v,_){return _=typeof _=="function"?_:t,jl(v,d,_)}function vpe(v){return jl(v,h|d)}function wpe(v,_){return _=typeof _=="function"?_:t,jl(v,h|d,_)}function xpe(v,_){return _==null||bU(v,_,to(_))}function Hc(v,_){return v===_||v!==v&&_!==_}var _pe=Nk(gR),Spe=Nk(function(v,_){return v>=_}),tm=CU(function(){return arguments}())?CU:function(v){return Ws(v)&&Pr.call(v,"callee")&&!uU.call(v,"callee")},On=Le.isArray,Cpe=nk?Ut(nk):$he;function Pa(v){return v!=null&&Bk(v.length)&&!Jh(v)}function ni(v){return Ws(v)&&Pa(v)}function kpe(v){return v===!0||v===!1||Ws(v)&&oa(v)==it}var cd=zue||t3,Tpe=Sx?Ut(Sx):Rhe;function Epe(v){return Ws(v)&&v.nodeType===1&&!Vx(v)}function Ipe(v){if(v==null)return!0;if(Pa(v)&&(On(v)||typeof v=="string"||typeof v.splice=="function"||cd(v)||T0(v)||tm(v)))return!v.length;var _=Ro(v);if(_==Be||_==ye)return!v.size;if(zx(v))return!vR(v).length;for(var I in v)if(Pr.call(v,I))return!1;return!0}function Ape(v,_){return Ox(v,_)}function Mpe(v,_,I){I=typeof I=="function"?I:t;var P=I?I(v,_):t;return P===t?Ox(v,_,t,I):!!P}function HR(v){if(!Ws(v))return!1;var _=oa(v);return _==ct||_==dt||typeof v.message=="string"&&typeof v.name=="string"&&!Vx(v)}function Npe(v){return typeof v=="number"&&fU(v)}function Jh(v){if(!Ps(v))return!1;var _=oa(v);return _==Ve||_==ze||_==Oe||_==rt}function $W(v){return typeof v=="number"&&v==Wn(v)}function Bk(v){return typeof v=="number"&&v>-1&&v%1==0&&v<=G}function Ps(v){var _=typeof v;return v!=null&&(_=="object"||_=="function")}function Ws(v){return v!=null&&typeof v=="object"}var RW=rk?Ut(rk):Dhe;function $pe(v,_){return v===_||bR(v,_,DR(_))}function Rpe(v,_,I){return I=typeof I=="function"?I:t,bR(v,_,DR(_),I)}function Ppe(v){return PW(v)&&v!=+v}function Dpe(v){if(bfe(v))throw new Pn(i);return kU(v)}function Ope(v){return v===null}function Fpe(v){return v==null}function PW(v){return typeof v=="number"||Ws(v)&&oa(v)==ut}function Vx(v){if(!Ws(v)||oa(v)!=ee)return!1;var _=dk(v);if(_===null)return!0;var I=Pr.call(_,"constructor")&&_.constructor;return typeof I=="function"&&I instanceof I&&ck.call(I)==Rue}var jR=sk?Ut(sk):Ohe;function Lpe(v){return $W(v)&&v>=-G&&v<=G}var DW=f0?Ut(f0):Fhe;function Vk(v){return typeof v=="string"||!On(v)&&Ws(v)&&oa(v)==Ze}function al(v){return typeof v=="symbol"||Ws(v)&&oa(v)==yt}var T0=d0?Ut(d0):Lhe;function zpe(v){return v===t}function Bpe(v){return Ws(v)&&Ro(v)==ft}function Vpe(v){return Ws(v)&&oa(v)==ce}var Upe=Nk(wR),Wpe=Nk(function(v,_){return v<=_});function OW(v){if(!v)return[];if(Pa(v))return Vk(v)?Wc(v):Ra(v);if(Ix&&v[Ix])return aR(v[Ix]());var _=Ro(v),I=_==Be?Ex:_==ye?m0:E0;return I(v)}function Qh(v){if(!v)return v===0?v:0;if(v=Kl(v),v===X||v===-X){var _=v<0?-1:1;return _*te}return v===v?v:0}function Wn(v){var _=Qh(v),I=_%1;return _===_?I?_-I:_:0}function FW(v){return v?Zp(Wn(v),0,ae):0}function Kl(v){if(typeof v=="number")return v;if(al(v))return ge;if(Ps(v)){var _=typeof v.valueOf=="function"?v.valueOf():v;v=Ps(_)?_+"":_}if(typeof v!="string")return v===0?v:+v;v=hn(v);var I=Io.test(v);return I||yo.test(v)?eR(v.slice(2),I?2:8):Ar.test(v)?ge:+v}function LW(v){return Yu(v,Da(v))}function Gpe(v){return v?Zp(Wn(v),-G,G):v===0?v:0}function Mr(v){return v==null?"":ol(v)}var Hpe=S0(function(v,_){if(zx(_)||Pa(_)){Yu(_,to(_),v);return}for(var I in _)Pr.call(_,I)&&Rx(v,I,_[I])}),zW=S0(function(v,_){Yu(_,Da(_),v)}),Uk=S0(function(v,_,I,P){Yu(_,Da(_),v,P)}),jpe=S0(function(v,_,I,P){Yu(_,to(_),v,P)}),qpe=Yh(dR);function Xpe(v,_){var I=_0(v);return _==null?I:yU(I,_)}var Kpe=Yn(function(v,_){v=Jr(v);var I=-1,P=_.length,V=P>2?_[2]:t;for(V&&aa(_[0],_[1],V)&&(P=1);++I<P;)for(var K=_[I],le=Da(K),xe=-1,Me=le.length;++xe<Me;){var Qe=le[xe],et=v[Qe];(et===t||Hc(et,v0[Qe])&&!Pr.call(v,Qe))&&(v[Qe]=K[Qe])}return v}),Ype=Yn(function(v){return v.push(t,nW),Mo(BW,t,v)});function Zpe(v,_){return Tx(v,fn(_,3),Ku)}function Jpe(v,_){return Tx(v,fn(_,3),mR)}function Qpe(v,_){return v==null?v:pR(v,fn(_,3),Da)}function eme(v,_){return v==null?v:_U(v,fn(_,3),Da)}function tme(v,_){return v&&Ku(v,fn(_,3))}function nme(v,_){return v&&mR(v,fn(_,3))}function rme(v){return v==null?[]:Sk(v,to(v))}function sme(v){return v==null?[]:Sk(v,Da(v))}function qR(v,_,I){var P=v==null?t:Jp(v,_);return P===t?I:P}function ime(v,_){return v!=null&&iW(v,_,Ihe)}function XR(v,_){return v!=null&&iW(v,_,Ahe)}var ome=ZU(function(v,_,I){_!=null&&typeof _.toString!="function"&&(_=uk.call(_)),v[_]=I},YR(Oa)),ame=ZU(function(v,_,I){_!=null&&typeof _.toString!="function"&&(_=uk.call(_)),Pr.call(v,_)?v[_].push(I):v[_]=[I]},fn),lme=Yn(Dx);function to(v){return Pa(v)?mU(v):vR(v)}function Da(v){return Pa(v)?mU(v,!0):zhe(v)}function cme(v,_){var I={};return _=fn(_,3),Ku(v,function(P,V,K){Xh(I,_(P,V,K),P)}),I}function ume(v,_){var I={};return _=fn(_,3),Ku(v,function(P,V,K){Xh(I,V,_(P,V,K))}),I}var hme=S0(function(v,_,I){Ck(v,_,I)}),BW=S0(function(v,_,I,P){Ck(v,_,I,P)}),fme=Yh(function(v,_){var I={};if(v==null)return I;var P=!1;_=Vr(_,function(K){return K=ad(K,v),P||(P=K.length>1),K}),Yu(v,RR(v),I),P&&(I=jl(I,h|f|d,ofe));for(var V=_.length;V--;)kR(I,_[V]);return I});function dme(v,_){return VW(v,zk(fn(_)))}var pme=Yh(function(v,_){return v==null?{}:Vhe(v,_)});function VW(v,_){if(v==null)return{};var I=Vr(RR(v),function(P){return[P]});return _=fn(_),$U(v,I,function(P,V){return _(P,V[0])})}function mme(v,_,I){_=ad(_,v);var P=-1,V=_.length;for(V||(V=1,v=t);++P<V;){var K=v==null?t:v[Zu(_[P])];K===t&&(P=V,K=I),v=Jh(K)?K.call(v):K}return v}function gme(v,_,I){return v==null?v:Fx(v,_,I)}function yme(v,_,I,P){return P=typeof P=="function"?P:t,v==null?v:Fx(v,_,I,P)}var UW=eW(to),WW=eW(Da);function bme(v,_,I){var P=On(v),V=P||cd(v)||T0(v);if(_=fn(_,4),I==null){var K=v&&v.constructor;V?I=P?new K:[]:Ps(v)?I=Jh(K)?_0(dk(v)):{}:I={}}return(V?Na:Ku)(v,function(le,xe,Me){return _(I,le,xe,Me)}),I}function vme(v,_){return v==null?!0:kR(v,_)}function wme(v,_,I){return v==null?v:FU(v,_,IR(I))}function xme(v,_,I,P){return P=typeof P=="function"?P:t,v==null?v:FU(v,_,IR(I),P)}function E0(v){return v==null?[]:Rt(v,to(v))}function _me(v){return v==null?[]:Rt(v,Da(v))}function Sme(v,_,I){return I===t&&(I=_,_=t),I!==t&&(I=Kl(I),I=I===I?I:0),_!==t&&(_=Kl(_),_=_===_?_:0),Zp(Kl(v),_,I)}function Cme(v,_,I){return _=Qh(_),I===t?(I=_,_=0):I=Qh(I),v=Kl(v),Mhe(v,_,I)}function kme(v,_,I){if(I&&typeof I!="boolean"&&aa(v,_,I)&&(_=I=t),I===t&&(typeof _=="boolean"?(I=_,_=t):typeof v=="boolean"&&(I=v,v=t)),v===t&&_===t?(v=0,_=1):(v=Qh(v),_===t?(_=v,v=0):_=Qh(_)),v>_){var P=v;v=_,_=P}if(I||v%1||_%1){var V=dU();return $o(v+V*(_-v+_x("1e-"+((V+"").length-1))),_)}return _R(v,_)}var Tme=C0(function(v,_,I){return _=_.toLowerCase(),v+(I?GW(_):_)});function GW(v){return KR(Mr(v).toLowerCase())}function HW(v){return v=Mr(v),v&&v.replace(Ns,Fi).replace(vx,"")}function Eme(v,_,I){v=Mr(v),_=ol(_);var P=v.length;I=I===t?P:Zp(Wn(I),0,P);var V=I;return I-=_.length,I>=0&&v.slice(I,V)==_}function Ime(v){return v=Mr(v),v&&Fh.test(v)?v.replace(Lc,$a):v}function Ame(v){return v=Mr(v),v&&zn.test(v)?v.replace(vt,"\\$&"):v}var Mme=C0(function(v,_,I){return v+(I?"-":"")+_.toLowerCase()}),Nme=C0(function(v,_,I){return v+(I?" ":"")+_.toLowerCase()}),$me=XU("toLowerCase");function Rme(v,_,I){v=Mr(v),_=Wn(_);var P=_?y0(v):0;if(!_||P>=_)return v;var V=(_-P)/2;return Mk(yk(V),I)+v+Mk(gk(V),I)}function Pme(v,_,I){v=Mr(v),_=Wn(_);var P=_?y0(v):0;return _&&P<_?v+Mk(_-P,I):v}function Dme(v,_,I){v=Mr(v),_=Wn(_);var P=_?y0(v):0;return _&&P<_?Mk(_-P,I)+v:v}function Ome(v,_,I){return I||_==null?_=0:_&&(_=+_),Wue(Mr(v).replace(sn,""),_||0)}function Fme(v,_,I){return(I?aa(v,_,I):_===t)?_=1:_=Wn(_),SR(Mr(v),_)}function Lme(){var v=arguments,_=Mr(v[0]);return v.length<3?_:_.replace(v[1],v[2])}var zme=C0(function(v,_,I){return v+(I?"_":"")+_.toLowerCase()});function Bme(v,_,I){return I&&typeof I!="number"&&aa(v,_,I)&&(_=I=t),I=I===t?ae:I>>>0,I?(v=Mr(v),v&&(typeof _=="string"||_!=null&&!jR(_))&&(_=ol(_),!_&&xs(v))?ld(Wc(v),0,I):v.split(_,I)):[]}var Vme=C0(function(v,_,I){return v+(I?" ":"")+KR(_)});function Ume(v,_,I){return v=Mr(v),I=I==null?0:Zp(Wn(I),0,v.length),_=ol(_),v.slice(I,I+_.length)==_}function Wme(v,_,I){var P=q.templateSettings;I&&aa(v,_,I)&&(_=t),v=Mr(v),_=Uk({},_,P,tW);var V=Uk({},_.imports,P.imports,tW),K=to(V),le=Rt(V,K),xe,Me,Qe=0,et=_.interpolate||bo,lt="__p += '",Ft=lR((_.escape||bo).source+"|"+et.source+"|"+(et===re?xr:bo).source+"|"+(_.evaluate||bo).source+"|$","g"),tn="//# sourceURL="+(Pr.call(_,"sourceURL")?(_.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++Q$+"]")+`
`;v.replace(Ft,function(gn,tr,hr,ll,la,cl){return hr||(hr=ll),lt+=v.slice(Qe,cl).replace(zh,No),tr&&(xe=!0,lt+=`' +
__e(`+tr+`) +
'`),la&&(Me=!0,lt+=`';
`+la+`;
__p += '`),hr&&(lt+=`' +
((__t = (`+hr+`)) == null ? '' : __t) +
'`),Qe=cl+gn.length,gn}),lt+=`';
`;var mn=Pr.call(_,"variable")&&_.variable;if(!mn)lt=`with (obj) {
`+lt+`
}
`;else if(ur.test(mn))throw new Pn(a);lt=(Me?lt.replace(Vl,""):lt).replace(go,"$1").replace(Ul,"$1;"),lt="function("+(mn||"obj")+`) {
`+(mn?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(xe?", __e = _.escape":"")+(Me?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+lt+`return __p
}`;var Xn=qW(function(){return Er(K,tn+"return "+lt).apply(t,le)});if(Xn.source=lt,HR(Xn))throw Xn;return Xn}function Gme(v){return Mr(v).toLowerCase()}function Hme(v){return Mr(v).toUpperCase()}function jme(v,_,I){if(v=Mr(v),v&&(I||_===t))return hn(v);if(!v||!(_=ol(_)))return v;var P=Wc(v),V=Wc(_),K=Bn(P,V),le=Ur(P,V)+1;return ld(P,K,le).join("")}function qme(v,_,I){if(v=Mr(v),v&&(I||_===t))return v.slice(0,oU(v)+1);if(!v||!(_=ol(_)))return v;var P=Wc(v),V=Ur(P,Wc(_))+1;return ld(P,0,V).join("")}function Xme(v,_,I){if(v=Mr(v),v&&(I||_===t))return v.replace(sn,"");if(!v||!(_=ol(_)))return v;var P=Wc(v),V=Bn(P,Wc(_));return ld(P,V).join("")}function Kme(v,_){var I=E,P=N;if(Ps(_)){var V="separator"in _?_.separator:V;I="length"in _?Wn(_.length):I,P="omission"in _?ol(_.omission):P}v=Mr(v);var K=v.length;if(xs(v)){var le=Wc(v);K=le.length}if(I>=K)return v;var xe=I-y0(P);if(xe<1)return P;var Me=le?ld(le,0,xe).join(""):v.slice(0,xe);if(V===t)return Me+P;if(le&&(xe+=Me.length-xe),jR(V)){if(v.slice(xe).search(V)){var Qe,et=Me;for(V.global||(V=lR(V.source,Mr(Zi.exec(V))+"g")),V.lastIndex=0;Qe=V.exec(et);)var lt=Qe.index;Me=Me.slice(0,lt===t?xe:lt)}}else if(v.indexOf(ol(V),xe)!=xe){var Ft=Me.lastIndexOf(V);Ft>-1&&(Me=Me.slice(0,Ft))}return Me+P}function Yme(v){return v=Mr(v),v&&Di.test(v)?v.replace(Fc,kue):v}var Zme=C0(function(v,_,I){return v+(I?" ":"")+_.toUpperCase()}),KR=XU("toUpperCase");function jW(v,_,I){return v=Mr(v),_=I?t:_,_===t?qu(v)?Iue(v):oR(v):v.match(_)||[]}var qW=Yn(function(v,_){try{return Mo(v,t,_)}catch(I){return HR(I)?I:new Pn(I)}}),Jme=Yh(function(v,_){return Na(_,function(I){I=Zu(I),Xh(v,I,WR(v[I],v))}),v});function Qme(v){var _=v==null?0:v.length,I=fn();return v=_?Vr(v,function(P){if(typeof P[1]!="function")throw new Gl(o);return[I(P[0]),P[1]]}):[],Yn(function(P){for(var V=-1;++V<_;){var K=v[V];if(Mo(K[0],this,P))return Mo(K[1],this,P)}})}function ege(v){return khe(jl(v,h))}function YR(v){return function(){return v}}function tge(v,_){return v==null||v!==v?_:v}var nge=YU(),rge=YU(!0);function Oa(v){return v}function ZR(v){return TU(typeof v=="function"?v:jl(v,h))}function sge(v){return IU(jl(v,h))}function ige(v,_){return AU(v,jl(_,h))}var oge=Yn(function(v,_){return function(I){return Dx(I,v,_)}}),age=Yn(function(v,_){return function(I){return Dx(v,I,_)}});function JR(v,_,I){var P=to(_),V=Sk(_,P);I==null&&!(Ps(_)&&(V.length||!P.length))&&(I=_,_=v,v=this,V=Sk(_,to(_)));var K=!(Ps(I)&&"chain"in I)||!!I.chain,le=Jh(v);return Na(V,function(xe){var Me=_[xe];v[xe]=Me,le&&(v.prototype[xe]=function(){var Qe=this.__chain__;if(K||Qe){var et=v(this.__wrapped__),lt=et.__actions__=Ra(this.__actions__);return lt.push({func:Me,args:arguments,thisArg:v}),et.__chain__=Qe,et}return Me.apply(v,ju([this.value()],arguments))})}),v}function lge(){return mi._===this&&(mi._=Pue),this}function QR(){}function cge(v){return v=Wn(v),Yn(function(_){return MU(_,v)})}var uge=MR(Vr),hge=MR(ik),fge=MR(rd);function XW(v){return FR(v)?ne(Zu(v)):Uhe(v)}function dge(v){return function(_){return v==null?t:Jp(v,_)}}var pge=JU(),mge=JU(!0);function e3(){return[]}function t3(){return!1}function gge(){return{}}function yge(){return""}function bge(){return!0}function vge(v,_){if(v=Wn(v),v<1||v>G)return[];var I=ae,P=$o(v,ae);_=fn(_),v-=ae;for(var V=ht(P,_);++I<v;)_(I);return V}function wge(v){return On(v)?Vr(v,Zu):al(v)?[v]:Ra(pW(Mr(v)))}function xge(v){var _=++$ue;return Mr(v)+_}var _ge=Ak(function(v,_){return v+_},0),Sge=NR("ceil"),Cge=Ak(function(v,_){return v/_},1),kge=NR("floor");function Tge(v){return v&&v.length?_k(v,Oa,gR):t}function Ege(v,_){return v&&v.length?_k(v,fn(_,2),gR):t}function Ige(v){return W(v,Oa)}function Age(v,_){return W(v,fn(_,2))}function Mge(v){return v&&v.length?_k(v,Oa,wR):t}function Nge(v,_){return v&&v.length?_k(v,fn(_,2),wR):t}var $ge=Ak(function(v,_){return v*_},1),Rge=NR("round"),Pge=Ak(function(v,_){return v-_},0);function Dge(v){return v&&v.length?Pe(v,Oa):0}function Oge(v,_){return v&&v.length?Pe(v,fn(_,2)):0}return q.after=spe,q.ary=kW,q.assign=Hpe,q.assignIn=zW,q.assignInWith=Uk,q.assignWith=jpe,q.at=qpe,q.before=TW,q.bind=WR,q.bindAll=Jme,q.bindKey=EW,q.castArray=gpe,q.chain=_W,q.chunk=kfe,q.compact=Tfe,q.concat=Efe,q.cond=Qme,q.conforms=ege,q.constant=YR,q.countBy=Dde,q.create=Xpe,q.curry=IW,q.curryRight=AW,q.debounce=MW,q.defaults=Kpe,q.defaultsDeep=Ype,q.defer=ipe,q.delay=ope,q.difference=Ife,q.differenceBy=Afe,q.differenceWith=Mfe,q.drop=Nfe,q.dropRight=$fe,q.dropRightWhile=Rfe,q.dropWhile=Pfe,q.fill=Dfe,q.filter=Fde,q.flatMap=Bde,q.flatMapDeep=Vde,q.flatMapDepth=Ude,q.flatten=bW,q.flattenDeep=Ofe,q.flattenDepth=Ffe,q.flip=ape,q.flow=nge,q.flowRight=rge,q.fromPairs=Lfe,q.functions=rme,q.functionsIn=sme,q.groupBy=Wde,q.initial=Bfe,q.intersection=Vfe,q.intersectionBy=Ufe,q.intersectionWith=Wfe,q.invert=ome,q.invertBy=ame,q.invokeMap=Hde,q.iteratee=ZR,q.keyBy=jde,q.keys=to,q.keysIn=Da,q.map=Ok,q.mapKeys=cme,q.mapValues=ume,q.matches=sge,q.matchesProperty=ige,q.memoize=Lk,q.merge=hme,q.mergeWith=BW,q.method=oge,q.methodOf=age,q.mixin=JR,q.negate=zk,q.nthArg=cge,q.omit=fme,q.omitBy=dme,q.once=lpe,q.orderBy=qde,q.over=uge,q.overArgs=cpe,q.overEvery=hge,q.overSome=fge,q.partial=GR,q.partialRight=NW,q.partition=Xde,q.pick=pme,q.pickBy=VW,q.property=XW,q.propertyOf=dge,q.pull=qfe,q.pullAll=wW,q.pullAllBy=Xfe,q.pullAllWith=Kfe,q.pullAt=Yfe,q.range=pge,q.rangeRight=mge,q.rearg=upe,q.reject=Zde,q.remove=Zfe,q.rest=hpe,q.reverse=VR,q.sampleSize=Qde,q.set=gme,q.setWith=yme,q.shuffle=epe,q.slice=Jfe,q.sortBy=rpe,q.sortedUniq=ide,q.sortedUniqBy=ode,q.split=Bme,q.spread=fpe,q.tail=ade,q.take=lde,q.takeRight=cde,q.takeRightWhile=ude,q.takeWhile=hde,q.tap=Tde,q.throttle=dpe,q.thru=Dk,q.toArray=OW,q.toPairs=UW,q.toPairsIn=WW,q.toPath=wge,q.toPlainObject=LW,q.transform=bme,q.unary=ppe,q.union=fde,q.unionBy=dde,q.unionWith=pde,q.uniq=mde,q.uniqBy=gde,q.uniqWith=yde,q.unset=vme,q.unzip=UR,q.unzipWith=xW,q.update=wme,q.updateWith=xme,q.values=E0,q.valuesIn=_me,q.without=bde,q.words=jW,q.wrap=mpe,q.xor=vde,q.xorBy=wde,q.xorWith=xde,q.zip=_de,q.zipObject=Sde,q.zipObjectDeep=Cde,q.zipWith=kde,q.entries=UW,q.entriesIn=WW,q.extend=zW,q.extendWith=Uk,JR(q,q),q.add=_ge,q.attempt=qW,q.camelCase=Tme,q.capitalize=GW,q.ceil=Sge,q.clamp=Sme,q.clone=ype,q.cloneDeep=vpe,q.cloneDeepWith=wpe,q.cloneWith=bpe,q.conformsTo=xpe,q.deburr=HW,q.defaultTo=tge,q.divide=Cge,q.endsWith=Eme,q.eq=Hc,q.escape=Ime,q.escapeRegExp=Ame,q.every=Ode,q.find=Lde,q.findIndex=gW,q.findKey=Zpe,q.findLast=zde,q.findLastIndex=yW,q.findLastKey=Jpe,q.floor=kge,q.forEach=SW,q.forEachRight=CW,q.forIn=Qpe,q.forInRight=eme,q.forOwn=tme,q.forOwnRight=nme,q.get=qR,q.gt=_pe,q.gte=Spe,q.has=ime,q.hasIn=XR,q.head=vW,q.identity=Oa,q.includes=Gde,q.indexOf=zfe,q.inRange=Cme,q.invoke=lme,q.isArguments=tm,q.isArray=On,q.isArrayBuffer=Cpe,q.isArrayLike=Pa,q.isArrayLikeObject=ni,q.isBoolean=kpe,q.isBuffer=cd,q.isDate=Tpe,q.isElement=Epe,q.isEmpty=Ipe,q.isEqual=Ape,q.isEqualWith=Mpe,q.isError=HR,q.isFinite=Npe,q.isFunction=Jh,q.isInteger=$W,q.isLength=Bk,q.isMap=RW,q.isMatch=$pe,q.isMatchWith=Rpe,q.isNaN=Ppe,q.isNative=Dpe,q.isNil=Fpe,q.isNull=Ope,q.isNumber=PW,q.isObject=Ps,q.isObjectLike=Ws,q.isPlainObject=Vx,q.isRegExp=jR,q.isSafeInteger=Lpe,q.isSet=DW,q.isString=Vk,q.isSymbol=al,q.isTypedArray=T0,q.isUndefined=zpe,q.isWeakMap=Bpe,q.isWeakSet=Vpe,q.join=Gfe,q.kebabCase=Mme,q.last=Xl,q.lastIndexOf=Hfe,q.lowerCase=Nme,q.lowerFirst=$me,q.lt=Upe,q.lte=Wpe,q.max=Tge,q.maxBy=Ege,q.mean=Ige,q.meanBy=Age,q.min=Mge,q.minBy=Nge,q.stubArray=e3,q.stubFalse=t3,q.stubObject=gge,q.stubString=yge,q.stubTrue=bge,q.multiply=$ge,q.nth=jfe,q.noConflict=lge,q.noop=QR,q.now=Fk,q.pad=Rme,q.padEnd=Pme,q.padStart=Dme,q.parseInt=Ome,q.random=kme,q.reduce=Kde,q.reduceRight=Yde,q.repeat=Fme,q.replace=Lme,q.result=mme,q.round=Rge,q.runInContext=Ae,q.sample=Jde,q.size=tpe,q.snakeCase=zme,q.some=npe,q.sortedIndex=Qfe,q.sortedIndexBy=ede,q.sortedIndexOf=tde,q.sortedLastIndex=nde,q.sortedLastIndexBy=rde,q.sortedLastIndexOf=sde,q.startCase=Vme,q.startsWith=Ume,q.subtract=Pge,q.sum=Dge,q.sumBy=Oge,q.template=Wme,q.times=vge,q.toFinite=Qh,q.toInteger=Wn,q.toLength=FW,q.toLower=Gme,q.toNumber=Kl,q.toSafeInteger=Gpe,q.toString=Mr,q.toUpper=Hme,q.trim=jme,q.trimEnd=qme,q.trimStart=Xme,q.truncate=Kme,q.unescape=Yme,q.uniqueId=xge,q.upperCase=Zme,q.upperFirst=KR,q.each=SW,q.eachRight=CW,q.first=vW,JR(q,function(){var v={};return Ku(q,function(_,I){Pr.call(q.prototype,I)||(v[I]=_)}),v}(),{chain:!1}),q.VERSION=r,Na(["bind","bindKey","curry","curryRight","partial","partialRight"],function(v){q[v].placeholder=q}),Na(["drop","take"],function(v,_){sr.prototype[v]=function(I){I=I===t?1:zi(Wn(I),0);var P=this.__filtered__&&!_?new sr(this):this.clone();return P.__filtered__?P.__takeCount__=$o(I,P.__takeCount__):P.__views__.push({size:$o(I,ae),type:v+(P.__dir__<0?"Right":"")}),P},sr.prototype[v+"Right"]=function(I){return this.reverse()[v](I).reverse()}}),Na(["filter","map","takeWhile"],function(v,_){var I=_+1,P=I==D||I==B;sr.prototype[v]=function(V){var K=this.clone();return K.__iteratees__.push({iteratee:fn(V,3),type:I}),K.__filtered__=K.__filtered__||P,K}}),Na(["head","last"],function(v,_){var I="take"+(_?"Right":"");sr.prototype[v]=function(){return this[I](1).value()[0]}}),Na(["initial","tail"],function(v,_){var I="drop"+(_?"":"Right");sr.prototype[v]=function(){return this.__filtered__?new sr(this):this[I](1)}}),sr.prototype.compact=function(){return this.filter(Oa)},sr.prototype.find=function(v){return this.filter(v).head()},sr.prototype.findLast=function(v){return this.reverse().find(v)},sr.prototype.invokeMap=Yn(function(v,_){return typeof v=="function"?new sr(this):this.map(function(I){return Dx(I,v,_)})}),sr.prototype.reject=function(v){return this.filter(zk(fn(v)))},sr.prototype.slice=function(v,_){v=Wn(v);var I=this;return I.__filtered__&&(v>0||_<0)?new sr(I):(v<0?I=I.takeRight(-v):v&&(I=I.drop(v)),_!==t&&(_=Wn(_),I=_<0?I.dropRight(-_):I.take(_-v)),I)},sr.prototype.takeRightWhile=function(v){return this.reverse().takeWhile(v).reverse()},sr.prototype.toArray=function(){return this.take(ae)},Ku(sr.prototype,function(v,_){var I=/^(?:filter|find|map|reject)|While$/.test(_),P=/^(?:head|last)$/.test(_),V=q[P?"take"+(_=="last"?"Right":""):_],K=P||/^find/.test(_);V&&(q.prototype[_]=function(){var le=this.__wrapped__,xe=P?[1]:arguments,Me=le instanceof sr,Qe=xe[0],et=Me||On(le),lt=function(tr){var hr=V.apply(q,ju([tr],xe));return P&&Ft?hr[0]:hr};et&&I&&typeof Qe=="function"&&Qe.length!=1&&(Me=et=!1);var Ft=this.__chain__,tn=!!this.__actions__.length,mn=K&&!Ft,Xn=Me&&!tn;if(!K&&et){le=Xn?le:new sr(this);var gn=v.apply(le,xe);return gn.__actions__.push({func:Dk,args:[lt],thisArg:t}),new Hl(gn,Ft)}return mn&&Xn?v.apply(this,xe):(gn=this.thru(lt),mn?P?gn.value()[0]:gn.value():gn)})}),Na(["pop","push","shift","sort","splice","unshift"],function(v){var _=ak[v],I=/^(?:push|sort|unshift)$/.test(v)?"tap":"thru",P=/^(?:pop|shift)$/.test(v);q.prototype[v]=function(){var V=arguments;if(P&&!this.__chain__){var K=this.value();return _.apply(On(K)?K:[],V)}return this[I](function(le){return _.apply(On(le)?le:[],V)})}}),Ku(sr.prototype,function(v,_){var I=q[_];if(I){var P=I.name+"";Pr.call(x0,P)||(x0[P]=[]),x0[P].push({name:_,func:I})}}),x0[Ik(t,y).name]=[{name:"wrapper",func:t}],sr.prototype.clone=Yue,sr.prototype.reverse=Zue,sr.prototype.value=Jue,q.prototype.at=Ede,q.prototype.chain=Ide,q.prototype.commit=Ade,q.prototype.next=Mde,q.prototype.plant=$de,q.prototype.reverse=Rde,q.prototype.toJSON=q.prototype.valueOf=q.prototype.value=Pde,q.prototype.first=q.prototype.head,Ix&&(q.prototype[Ix]=Nde),q},b0=Aue();Hh?((Hh.exports=b0)._=b0,h0._=b0):mi._=b0}).call(pt)})(KI,KI.exports);var QYe=KI.exports;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var CO=function(n,e){return CO=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])},CO(n,e)};function Eo(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");CO(n,e);function t(){this.constructor=n}n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var XB=function(n){var e="[object "+n+"]";return function(t){return eZe(t)===e}},eZe=function(n){return Object.prototype.toString.call(n)},rv=function(n){return n instanceof Date?n.getTime():Kw(n)?n.map(rv):n&&typeof n.toJSON=="function"?n.toJSON():n},Kw=XB("Array"),tZe=XB("Object"),nZe=XB("Function"),rZe=function(n){return n&&(n.constructor===Object||n.constructor===Array||n.constructor.toString()==="function Object() { [native code] }"||n.constructor.toString()==="function Array() { [native code] }")&&!n.toJSON},kO=function(n,e){if(n==null&&n==e||n===e)return!0;if(Object.prototype.toString.call(n)!==Object.prototype.toString.call(e))return!1;if(Kw(n)){if(n.length!==e.length)return!1;for(var t=0,r=n.length;t<r;t++)if(!kO(n[t],e[t]))return!1;return!0}else if(tZe(n)){if(Object.keys(n).length!==Object.keys(e).length)return!1;for(var s in n)if(!kO(n[s],e[s]))return!1;return!0}return!1},TO=function(n,e,t,r,s,i){var o=e[r];if(Kw(n)&&isNaN(Number(o))){for(var a=0,l=n.length;a<l;a++)if(!TO(n[a],e,t,r,a,n))return!1}return r===e.length||n==null?t(n,s,i,r===0):TO(n[o],e,t,r+1,o,n)},Bu=function(){function n(e,t,r,s){this.params=e,this.owneryQuery=t,this.options=r,this.name=s,this.init()}return n.prototype.init=function(){},n.prototype.reset=function(){this.done=!1,this.keep=!1},n}(),KB=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s)||this;return o.children=i,o}return e.prototype.reset=function(){this.keep=!1,this.done=!1;for(var t=0,r=this.children.length;t<r;t++)this.children[t].reset()},e.prototype.childrenNext=function(t,r,s,i){for(var o=!0,a=!0,l=0,c=this.children.length;l<c;l++){var u=this.children[l];if(u.done||u.next(t,r,s,i),u.keep||(a=!1),u.done){if(!u.keep)break}else o=!1}this.done=o,this.keep=a},e}(Bu),Ste=function(n){Eo(e,n);function e(t,r,s,i,o){var a=n.call(this,t,r,s,i)||this;return a.name=o,a}return e}(KB),sZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(KB),EO=function(n){Eo(e,n);function e(t,r,s,i,o){var a=n.call(this,r,s,i,o)||this;return a.keyPath=t,a.propop=!0,a._nextNestedValue=function(l,c,u,h){return a.childrenNext(l,c,u,h),!a.done},a}return e.prototype.next=function(t,r,s){TO(t,this.keyPath,this._nextNestedValue,0,r,s)},e}(KB),YB=function(n,e){if(n instanceof Function)return n;if(n instanceof RegExp)return function(r){var s=typeof r=="string"&&n.test(r);return n.lastIndex=0,s};var t=rv(n);return function(r){return e(t,rv(r))}},Op=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=YB(this.params,this.options.compare)},e.prototype.next=function(t,r,s){(!Array.isArray(s)||s.hasOwnProperty(r))&&this._test(t,r,s)&&(this.done=!0,this.keep=!0)},e}(Bu),iZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(){this.done=!0,this.keep=!1},e}(Bu),oZe=function(n){return function(e,t,r,s){return e==null?new iZe(e,t,r,s):n(e,t,r,s)}},r$=function(n){return oZe(function(e,t,r,s){var i=typeof rv(e),o=n(e);return new Op(function(a){return typeof rv(a)===i&&o(a)},t,r,s)})},aZe=function(n,e,t,r){var s=r.operations[n];return s||Cte(n),s(e,t,r,n)},Cte=function(n){throw new Error("Unsupported operation: "+n)},kte=function(n,e){for(var t in n)if(e.operations.hasOwnProperty(t)||t.charAt(0)==="$")return!0;return!1},lZe=function(n,e,t,r,s){if(kte(e,s)){var i=Tte(e,t,s),o=i[0],a=i[1];if(a.length)throw new Error("Property queries must contain only operations, or exact objects.");return new EO(n,e,r,s,o)}return new EO(n,e,r,s,[new Op(e,r,s)])},Yw=function(n,e,t){e===void 0&&(e=null);var r=t===void 0?{}:t,s=r.compare,i=r.operations,o={compare:s||kO,operations:Object.assign({},i||{})},a=Tte(n,null,o),l=a[0],c=a[1],u=[];return l.length&&u.push(new EO([],n,e,o,l)),u.push.apply(u,c),u.length===1?u[0]:new sZe(n,e,o,u)},Tte=function(n,e,t){var r=[],s=[];if(!rZe(n))return r.push(new Op(n,n,t)),[r,s];for(var i in n)if(t.operations.hasOwnProperty(i)){var o=aZe(i,n[i],n,t);if(o&&!o.propop&&e&&!t.operations[e])throw new Error("Malformed query. "+i+" cannot be matched against property.");o!=null&&r.push(o)}else i.charAt(0)==="$"?Cte(i):s.push(lZe(i.split("."),n[i],i,n,t));return[r,s]},cZe=function(n){return function(e,t,r){return n.reset(),n.next(e,t,r),n.keep}},uZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._test=YB(this.params,this.options.compare)},e.prototype.reset=function(){n.prototype.reset.call(this),this.keep=!0},e.prototype.next=function(t){this._test(t)&&(this.done=!0,this.keep=!1)},e}(Bu),hZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){if(!this.params||typeof this.params!="object")throw new Error("Malformed query. $elemMatch must by an object.");this._queryOperation=Yw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t){if(Kw(t)){for(var r=0,s=t.length;r<s;r++){this._queryOperation.reset();var i=t[r];this._queryOperation.next(i,r,t,!1),this.keep=this.keep||this._queryOperation.keep}this.done=!0}else this.done=!1,this.keep=!1},e}(Bu),fZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){this._queryOperation=Yw(this.params,this.owneryQuery,this.options)},e.prototype.reset=function(){n.prototype.reset.call(this),this._queryOperation.reset()},e.prototype.next=function(t,r,s,i){this._queryOperation.next(t,r,s,i),this.done=this._queryOperation.done,this.keep=!this._queryOperation.keep},e}(Bu),Ete=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){},e.prototype.next=function(t){Kw(t)&&t.length===this.params&&(this.done=!0,this.keep=!0)},e}(Bu),Ite=function(n){if(n.length===0)throw new Error("$and/$or/$nor must be a nonempty array")},Ate=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.init=function(){var t=this;Ite(this.params),this._ops=this.params.map(function(r){return Yw(r,null,t.options)})},e.prototype.reset=function(){this.done=!1,this.keep=!1;for(var t=0,r=this._ops.length;t<r;t++)this._ops[t].reset()},e.prototype.next=function(t,r,s){for(var i=!1,o=!1,a=0,l=this._ops.length;a<l;a++){var c=this._ops[a];if(c.next(t,r,s),c.keep){i=!0,o=c.keep;break}}this.keep=o,this.done=i},e}(Bu),dZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!1,t}return e.prototype.next=function(t,r,s){n.prototype.next.call(this,t,r,s),this.keep=!this.keep},e}(Ate),Mte=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.init=function(){var t=this;this._testers=this.params.map(function(r){if(kte(r,t.options))throw new Error("cannot nest $ under "+t.name.toLowerCase());return YB(r,t.options.compare)})},e.prototype.next=function(t,r,s){for(var i=!1,o=!1,a=0,l=this._testers.length;a<l;a++){var c=this._testers[a];if(c(t)){i=!0,o=!0;break}}this.keep=o,this.done=i},e}(Bu),pZe=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,i)||this;return o.propop=!0,o._in=new Mte(t,r,s,i),o}return e.prototype.next=function(t,r,s,i){this._in.next(t,r,s),Kw(s)&&!i?this._in.keep?(this.keep=!1,this.done=!0):r==s.length-1&&(this.keep=!0,this.done=!0):(this.keep=!this._in.keep,this.done=!0)},e.prototype.reset=function(){n.prototype.reset.call(this),this._in.reset()},e}(Bu),mZe=function(n){Eo(e,n);function e(){var t=n!==null&&n.apply(this,arguments)||this;return t.propop=!0,t}return e.prototype.next=function(t,r,s){s.hasOwnProperty(r)===this.params&&(this.done=!0,this.keep=!0)},e}(Bu),gZe=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,t.map(function(a){return Yw(a,r,s)}),i)||this;return o.propop=!1,Ite(t),o}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(Ste),yZe=function(n){Eo(e,n);function e(t,r,s,i){var o=n.call(this,t,r,s,t.map(function(a){return Yw(a,r,s)}),i)||this;return o.propop=!0,o}return e.prototype.next=function(t,r,s,i){this.childrenNext(t,r,s,i)},e}(Ste),bZe=function(n,e,t){return new Op(n,e,t)},vZe=function(n,e,t,r){return new uZe(n,e,t,r)},wZe=function(n,e,t,r){return new Ate(n,e,t,r)},xZe=function(n,e,t,r){return new dZe(n,e,t,r)},_Ze=function(n,e,t,r){return new hZe(n,e,t,r)},SZe=function(n,e,t,r){return new pZe(n,e,t,r)},CZe=function(n,e,t,r){return new Mte(n,e,t,r)},kZe=r$(function(n){return function(e){return e<n}}),TZe=r$(function(n){return function(e){return e<=n}}),EZe=r$(function(n){return function(e){return e>n}}),IZe=r$(function(n){return function(e){return e>=n}}),AZe=function(n,e,t){var r=n[0],s=n[1];return new Op(function(i){return rv(i)%r===s},e,t)},MZe=function(n,e,t,r){return new mZe(n,e,t,r)},NZe=function(n,e,t){return new Op(new RegExp(n,e.$options),e,t)},$Ze=function(n,e,t,r){return new fZe(n,e,t,r)},WH={number:function(n){return typeof n=="number"},string:function(n){return typeof n=="string"},bool:function(n){return typeof n=="boolean"},array:function(n){return Array.isArray(n)},null:function(n){return n===null},timestamp:function(n){return n instanceof Date}},RZe=function(n,e,t){return new Op(function(r){if(typeof n=="string"){if(!WH[n])throw new Error("Type alias does not exist");return WH[n](r)}return r!=null?r instanceof n||r.constructor===n:!1},e,t)},PZe=function(n,e,t,r){return new gZe(n,e,t,r)},DZe=function(n,e,t,r){return new yZe(n,e,t,r)},OZe=function(n,e,t){return new Ete(n,e,t,"$size")},FZe=function(){return null},LZe=function(n,e,t){var r;if(nZe(n))r=n;else if(!{}.CSP_ENABLED)r=new Function("obj","return "+n);else throw new Error('In CSP mode, sift does not support strings in "$where" condition');return new Op(function(s){return r.bind(s)(s)},e,t)},zZe=Object.freeze({__proto__:null,$Size:Ete,$eq:bZe,$ne:vZe,$or:wZe,$nor:xZe,$elemMatch:_Ze,$nin:SZe,$in:CZe,$lt:kZe,$lte:TZe,$gt:EZe,$gte:IZe,$mod:AZe,$exists:MZe,$regex:NZe,$not:$Ze,$type:RZe,$and:PZe,$all:DZe,$size:OZe,$options:FZe,$where:LZe}),BZe=function(n,e,t){var r=t===void 0?{}:t,s=r.compare,i=r.operations;return Yw(n,e,{compare:s,operations:Object.assign({},zZe,i||{})})},VZe=function(n,e){e===void 0&&(e={});var t=BZe(n,null,e);return cZe(t)};const GH=VZe;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZe=Ee();UZe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var tc;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(tc||(tc={}));var HH;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(HH||(HH={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZB={};function WZe(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};ZB[n]=t}function Nte(n){return ZB[n]}function GZe(n){delete ZB[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F(n,e,t,r,s){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,c=a<0?e.inputNames.length+a:a;if(i.type==="tensor")return ao(e.inputNames[c],t,r,s);if(i.type==="tensors"){const f=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((p,m)=>{var g;return((g=f[m])===null||g===void 0?void 0:g.op)!=="NoOp"}).map(p=>ao(p,t,r,s))}const u=ao(e.inputNames[c],t,r,s),h=u.dataSync();return i.type==="number"?h[0]:Cl(u.shape,h)}const o=e.attrParams[n];return o&&o.value}function ao(n,e,t,r){const[s,i]=Ba(n,t);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[YI(s,a)]);return o!==void 0?e[YI(s,o)][i]:void 0}function jH(n,e,t){return e[YI(n,t.currentContextId)]}function pf(n,e){const[t,r,s]=Ba(n,e);return[YI(t,e&&e.currentContextId),r,s]}function YI(n,e){return e?`${n}-${e}`:n}function Ba(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const r=n.split(":");let s;if(r.length===1)s=[n,0,void 0];else{const i=r[0],o=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[i,a,o]}return t&&e.parseNodeNameCache.set(n,s),s}function BE(n,e,t){let r=F("pad",n,e,t);if(r==="explicit"){r=F("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[i*2],s[i][1]=r[i*2+1];return s}return r}function mf(n){return n.kept?n:dh(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jZe=Object.freeze(Object.defineProperty({__proto__:null,json:HZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],XZe=Object.freeze(Object.defineProperty({__proto__:null,json:qZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],YZe=Object.freeze(Object.defineProperty({__proto__:null,json:KZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZZe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],JZe=Object.freeze(Object.defineProperty({__proto__:null,json:ZZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],eJe=Object.freeze(Object.defineProperty({__proto__:null,json:QZe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tJe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],nJe=Object.freeze(Object.defineProperty({__proto__:null,json:tJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rJe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],sJe=Object.freeze(Object.defineProperty({__proto__:null,json:rJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iJe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],oJe=Object.freeze(Object.defineProperty({__proto__:null,json:iJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],lJe=Object.freeze(Object.defineProperty({__proto__:null,json:aJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],uJe=Object.freeze(Object.defineProperty({__proto__:null,json:cJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hJe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],fJe=Object.freeze(Object.defineProperty({__proto__:null,json:hJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dJe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],pJe=Object.freeze(Object.defineProperty({__proto__:null,json:dJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mJe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],gJe=Object.freeze(Object.defineProperty({__proto__:null,json:mJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yJe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],bJe=Object.freeze(Object.defineProperty({__proto__:null,json:yJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vJe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],wJe=Object.freeze(Object.defineProperty({__proto__:null,json:vJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xJe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],_Je=Object.freeze(Object.defineProperty({__proto__:null,json:xJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SJe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],CJe=Object.freeze(Object.defineProperty({__proto__:null,json:SJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kJe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],TJe=Object.freeze(Object.defineProperty({__proto__:null,json:kJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EJe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],IJe=Object.freeze(Object.defineProperty({__proto__:null,json:EJe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qH{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[jZe,XZe,YZe,JZe,eJe,nJe,sJe,oJe,lJe,uJe,fJe,pJe,gJe,bJe,wJe,_Je,CJe,TJe,IJe],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],i=[],o=[],a=r.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):g.op==="Const"?i.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const f=Object.keys(a);f.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[x,,w]=pf(y),S=a[x];if(S.outputs!=null){const C=S.outputs.indexOf(w);if(C!==-1){const k=`${x}:${C}`;g.inputNames[b]=k}}g.inputs.push(S),S.children.push(g)})}),Object.keys(h).length===0?f.forEach(m=>{const g=a[m];g.children.length===0&&c.push(g)}):Object.keys(h).forEach(m=>{const[g]=pf(m),y=a[g];y!=null&&(y.signatureKey=h[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=pf(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:i,placeholders:s,signature:t,functions:d};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=Nte(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=IO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=IO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=DO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=DO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=MO(e.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=MO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=PO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=PO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=AO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=AO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=FO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=FO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=RO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=RO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=OO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=OO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=NO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=NO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=$O(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=$O(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=XH(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=XH(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let i={};t!=null&&(i=t.reduce((h,f)=>(h[f.name]=this.mapNode(f),f.op==="Const"&&s.push(h[f.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[f]=pf(h.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:JB(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,o.push(d),i[f]=d}),Object.keys(i).forEach(h=>{const f=i[h];f.inputNames.forEach((d,p)=>{const[m,,g]=pf(d),y=i[m];if(y.outputs!=null){const b=y.outputs.indexOf(g);if(b!==-1){const x=`${m}:${b}`;f.inputNames[p]=x}}f.inputs.push(y),y.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[f,d]=pf(c[h.name]),p=i[f];p!=null&&(p.defaultOutput=d,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function AJe(n){const e=Ee().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function $te(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):AJe(n);return e?t:t.toLowerCase()}function IO(n,e,t,r=!1){const s=n[e];return s!=null?$te(s.s,r):t}function AO(n,e,t){const r=n[e];return r?r.b:t}function MO(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function JB(n){switch(typeof n=="string"&&(n=tc[n]),n){case tc.DT_FLOAT:case tc.DT_HALF:return"float32";case tc.DT_INT32:case tc.DT_INT64:case tc.DT_INT8:case tc.DT_UINT8:return"int32";case tc.DT_BOOL:return"bool";case tc.DT_DOUBLE:return"float32";case tc.DT_STRING:return"string";default:return null}}function XH(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function NO(n,e,t){const r=n[e];return r&&r.type?JB(r.type):t}function $O(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>JB(s)):t}function Rte(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function RO(n,e,t){const r=n[e];return r&&r.shape?Rte(r.shape):t}function PO(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function DO(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(i=>$te(i,r)):t}function OO(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Rte(s)):t}function FO(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MJe{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(e){return ao(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return ao(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return MO(this.node.rawAttrs,e,t);if(r.s!=null)return IO(this.node.rawAttrs,e,t);if(r.b!=null)return AO(this.node.rawAttrs,e,t);if(r.shape!=null)return RO(this.node.rawAttrs,e,t);if(r.type!=null)return NO(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return PO(this.node.rawAttrs,e,t);if(r.list.s!=null)return DO(this.node.rawAttrs,e,t);if(r.list.shape!=null)return OO(this.node.rawAttrs,e,t);if(r.list.b!=null)return FO(this.node.rawAttrs,e,t);if(r.list.type!=null)return $O(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:$L,abs:wi,acos:LX,acosh:zX,add:qe,addN:BX,all:UL,any:TI,argMax:ig,argMin:VX,asin:UX,asinh:WX,atan:GX,atan2:HX,atanh:jX,avgPool:RM,avgPool3d:GL,basicLSTMCell:qX,batchNorm:q2,batchNorm2d:HL,batchNorm3d:jL,batchNorm4d:qL,batchToSpaceND:PM,bincount:XL,bitwiseAnd:XX,booleanMaskAsync:rY,broadcastArgs:KX,broadcastTo:Ib,buffer:Sn,cast:wt,ceil:YX,clipByValue:wa,clone:dh,complex:Nf,concat:cs,concat1d:KL,concat2d:YL,concat3d:ZL,concat4d:JL,conv1d:QL,conv2d:sp,conv2dTranspose:tz,conv3d:nz,conv3dTranspose:rz,cos:DM,cosh:sz,cosineWindow:QM,cumprod:EI,cumsum:iz,denseBincount:II,depthToSpace:JX,depthwiseConv2d:X2,diag:QX,dilation2d:eK,div:Lt,divNoNan:tK,dot:nK,dropout:Pz,einsum:Nm,elu:K2,enclosingPowerOfTwo:Dz,ensureShape:rK,equal:bu,erf:sK,euclideanNorm:aK,exp:Yo,expandDims:oi,expm1:lK,eye:OM,fft:XM,fill:$y,floor:Y2,floorDiv:VL,fused:fY,gather:Z2,gatherND:aY,greater:tl,greaterEqual:Mp,ifft:T_,imag:J2,image:Ci,inTopKAsync:lY,irfft:Ez,isFinite:cK,isInf:uK,isNaN:hK,leakyRelu:FM,less:k_,lessEqual:Ry,linalg:Lz,linspace:fK,localResponseNormalization:dK,log:Al,log1p:LM,logSigmoid:mK,logSoftmax:az,logSumExp:BM,logicalAnd:wh,logicalNot:VM,logicalOr:lz,logicalXor:gK,losses:yY,lowerBound:yK,matMul:Hn,max:bc,maxPool:WM,maxPool3d:cz,maxPoolWithArgmax:bK,maximum:Vf,mean:Ds,meshgrid:vK,min:C_,minimum:op,mirrorPad:uz,mod:wK,moments:Q2,movingAverage:sY,mul:fe,multiRNNCell:xK,multinomial:_K,neg:us,norm:Ew,notEqual:qb,oneHot:Xb,ones:pa,onesLike:Ml,op:he,outerProduct:SK,pad:vu,pad1d:CK,pad2d:kK,pad3d:TK,pad4d:EK,pool:IK,pow:ip,prelu:HM,print:BL,prod:AK,raggedGather:MK,raggedRange:NK,raggedTensorToTensor:$K,rand:RK,randomGamma:LK,randomNormal:jM,randomStandardNormal:zK,randomUniform:Np,randomUniformInt:BK,range:ag,real:Kb,reciprocal:VK,relu:Nh,relu6:wz,reshape:ve,reverse:Cc,reverse1d:UK,reverse2d:WK,reverse3d:GK,reverse4d:HK,rfft:KM,round:xz,rsqrt:_z,scalar:en,scatterND:iY,searchSorted:UM,selu:Sz,separableConv2d:Cz,setdiff1dAsync:jK,sigmoid:kl,sign:qK,signal:gY,sin:kz,sinh:Tz,slice:dn,slice1d:eC,slice2d:qM,slice3d:tC,slice4d:Yb,softmax:nC,softplus:Iw,spaceToBatchND:GM,sparse:bY,sparseToDense:oY,spectral:mY,split:ja,sqrt:So,square:Or,squaredDifference:Iz,squeeze:vr,stack:xa,step:Mw,stridedSlice:XK,string:vY,sub:Dt,sum:Yt,tan:KK,tanh:jb,tensor:Ei,tensor1d:Ks,tensor2d:qa,tensor3d:Az,tensor4d:YK,tensor5d:ZK,tensor6d:JK,tensorScatterUpdate:QK,tile:fc,topk:eY,transpose:rr,truncatedNormal:ZM,unique:tY,unsortedSegmentSum:Nz,unstack:kc,upperBound:nY,variable:$z,where:_o,whereAsync:Rz,zeros:ms,zerosLike:lr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NJe=(n,e,t,r=fo)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(F("a",n,e,t),F("b",n,e,t))];case"AddN":return[r.addN(F("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(F("a",n,e,t),F("b",n,e,t))];case"Mul":return[r.mul(F("a",n,e,t),F("b",n,e,t))];case"RealDiv":case"Div":return[r.div(F("a",n,e,t),F("b",n,e,t))];case"DivNoNan":return[r.divNoNan(F("a",n,e,t),F("b",n,e,t))];case"FloorDiv":return[r.floorDiv(F("a",n,e,t),F("b",n,e,t))];case"Sub":return[r.sub(F("a",n,e,t),F("b",n,e,t))];case"Minimum":return[r.minimum(F("a",n,e,t),F("b",n,e,t))];case"Maximum":return[r.maximum(F("a",n,e,t),F("b",n,e,t))];case"Pow":return[r.pow(F("a",n,e,t),F("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Je=(n,e,t,r=fo)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(F("x",n,e,t))];case"Acos":return[r.acos(F("x",n,e,t))];case"Acosh":return[r.acosh(F("x",n,e,t))];case"Asin":return[r.asin(F("x",n,e,t))];case"Asinh":return[r.asinh(F("x",n,e,t))];case"Atan":return[r.atan(F("x",n,e,t))];case"Atan2":return[r.atan2(F("x",n,e,t),F("y",n,e,t))];case"Atanh":return[r.atanh(F("x",n,e,t))];case"Ceil":return[r.ceil(F("x",n,e,t))];case"Complex":return[r.complex(F("real",n,e,t),F("imag",n,e,t))];case"Cos":return[r.cos(F("x",n,e,t))];case"Cosh":return[r.cosh(F("x",n,e,t))];case"Elu":return[r.elu(F("x",n,e,t))];case"Erf":return[r.erf(F("x",n,e,t))];case"Exp":return[r.exp(F("x",n,e,t))];case"Expm1":return[r.expm1(F("x",n,e,t))];case"Floor":return[r.floor(F("x",n,e,t))];case"Log":return[r.log(F("x",n,e,t))];case"Log1p":return[r.log1p(F("x",n,e,t))];case"Imag":return[r.imag(F("x",n,e,t))];case"Neg":return[r.neg(F("x",n,e,t))];case"Reciprocal":return[r.reciprocal(F("x",n,e,t))];case"Real":return[r.real(F("x",n,e,t))];case"Relu":return[r.relu(F("x",n,e,t))];case"Round":return[r.round(F("x",n,e,t))];case"Selu":return[r.selu(F("x",n,e,t))];case"Sigmoid":return[r.sigmoid(F("x",n,e,t))];case"Sin":return[r.sin(F("x",n,e,t))];case"Sign":return[r.sign(F("x",n,e,t))];case"Sinh":return[r.sinh(F("x",n,e,t))];case"Softplus":return[r.softplus(F("x",n,e,t))];case"Sqrt":return[r.sqrt(F("x",n,e,t))];case"Square":return[r.square(F("x",n,e,t))];case"Tanh":return[r.tanh(F("x",n,e,t))];case"Tan":return[r.tan(F("x",n,e,t))];case"ClipByValue":return[r.clipByValue(F("x",n,e,t),F("clipValueMin",n,e,t),F("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(F("x",n,e,t))];case"Rsqrt":return[r.rsqrt(ao(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(F("x",n,e,t),F("alpha",n,e,t))];case"Prelu":return[r.prelu(F("x",n,e,t),F("alpha",n,e,t))];case"IsNan":return[r.isNaN(ao(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(ao(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(ao(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ic(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){U(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=e[r];U(s<0||i<0||s===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function KH(n){return!(typeof n=="number"||n.some(e=>e<0))}function Hx(n,e,t){let r=LO(n,t);const s=!KH(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(i=>{r=LO(i.shape,r)}),!KH(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function LO(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],i=e[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RJe{constructor(e,t,r,s,i,o,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=en(0),Xs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ic(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Xs(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Ei([],[0].concat(this.elementShape));const r=this.readMany(e);return ic(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),xa(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ei([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return ic(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),cs(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,kc(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=r===0?0:t.size/r,o=[];Se(()=>{t=ve(t,[1,r,i]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:s[l-1],0],h=[1,e[l],i];o[l]=ve(dn(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pg{get id(){return this.idTensor.id}constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);ic(t,i.shape,"TensorList shape mismatch: "),Xs(i)}),this.idTensor=en(0),this.maxNumElements=s,Xs(this.idTensor)}copy(){return new pg([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ic(e,this.elementShape,"TensorList shape mismatch: ");const s=Hx(this.elementShape,this.tensors,e);return Se(()=>{const i=this.tensors.map(o=>ve(o,s));return xa(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Hx(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,ic(s.shape,e,"TensorList shape mismatch: "),ve(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ic(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Xs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new pg([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ic(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Hx(this.elementShape,this.tensors,t);return ve(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ic(this.elementShape,t.shape,"TensorList shape mismatch: "),Xs(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ic(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Hx(this.elementShape,this.tensors,r);return e.length===0?Ei([],[0].concat(s)):Se(()=>{const i=e.map(o=>ve(this.tensors[o],s));return xa(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ic(this.elementShape,t,"TensorList shape mismatch: ");const r=Hx(this.elementShape,this.tensors,t);return this.size()===0?Ei([],[0].concat(r)):Se(()=>{const s=this.tensors.map(i=>ve(i,r));return cs(s,0)})}}function PJe(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);ic(s,e,"TensorList shape mismatch: ");const i=kc(n);return new pg(i,e,r)}function DJe(n,e,t,r){return new pg([],n,e,r)}function OJe(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new pg([],t,n.dtype,r),o=kc(n,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function FJe(n,e,t){let r=0;const s=e.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=LO(i,t),a=r===0?0:n.size/r,l=Se(()=>{const u=[];n=ve(n,[1,r,a]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:s[h-1],0],p=[1,e[h],a];u[h]=ve(dn(n,d,p),o)}return n.dispose(),u}),c=new pg([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LJe=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=F("thenBranch",n,e,t),s=F("elseBranch",n,e,t),i=F("cond",n,e,t),o=F("args",n,e,t);return(await i.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=F("body",n,e,t),s=F("cond",n,e,t),i=F("args",n,e,t),o=await t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),a=i.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=i;for(;l[0];){const u=c;c=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(d=>d.id);u.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const f=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{const r=F("pred",n,e,t);return[mf(r)]}case"Switch":{const r=F("pred",n,e,t);let s=F("data",n,e,t);return s.kept||(s=mf(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>ao(s,e,t)!==void 0);if(r){const s=ao(r,e,t);return[mf(s)]}return}case"Enter":{const r=F("frameName",n,e,t),s=F("tensor",n,e,t);return t.enterFrame(r),[mf(s)]}case"Exit":{const r=F("tensor",n,e,t);return t.exitFrame(),[mf(r)]}case"NextIteration":{const r=F("tensor",n,e,t);return t.nextIteration(),[mf(r)]}case"TensorArrayV3":{const r=F("size",n,e,t),s=F("dtype",n,e,t),i=F("elementShape",n,e,t),o=F("dynamicSize",n,e,t),a=F("clearAfterRead",n,e,t),l=F("identicalElementShapes",n,e,t),c=F("name",n,e,t),u=new RJe(c,s,r,i,l,o,a);return t.addTensorArray(u),[u.idTensor,en(1)]}case"TensorArrayWriteV3":{const r=F("tensorArrayId",n,e,t),s=F("index",n,e,t),i=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(s,i),[o.idTensor]}case"TensorArrayReadV3":{const r=F("tensorArrayId",n,e,t),s=F("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=F("tensorArrayId",n,e,t),s=F("indices",n,e,t),i=F("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,i)]}case"TensorArrayScatterV3":{const r=F("tensorArrayId",n,e,t),s=F("indices",n,e,t),i=F("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(s,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),i=F("dtype",n,e,t);return[s.concat(i)]}case"TensorArraySplitV3":{const r=F("tensorArrayId",n,e,t),s=F("tensor",n,e,t),i=F("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(i,s),[o.idTensor]}case"TensorArraySizeV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[en(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=F("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=F("tensorListId",n,e,t),s=F("index",n,e,t),i=F("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(s,i),[o.idTensor]}case"TensorListGetItem":{const r=F("tensorListId",n,e,t),s=F("index",n,e,t),i=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=F("indices",n,e,t),s=F("tensor",n,e,t),i=F("elementShape",n,e,t),o=F("numElements",n,e,t),a=OJe(s,r,i,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=F("elementShape",n,e,t),s=F("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=F(i,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=DJe(r,s,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=F("tensorListId",n,e,t),s=F("indices",n,e,t),i=F("elementShape",n,e,t),o=F("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,o,i)]}case"TensorListStack":{const r=F("tensorListId",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t),o=F("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,i,o)]}case"TensorListFromTensor":{const r=F("tensor",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t),o=PJe(r,s,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=F("tensorListId",n,e,t),s=t.getTensorList(r.id),i=F("dtype",n,e,t),o=F("elementShape",n,e,t);return[s.concat(i,o)]}case"TensorListPushBack":{const r=F("tensorListId",n,e,t),s=F("tensor",n,e,t),i=t.getTensorList(r.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const r=F("tensorListId",n,e,t),s=F("elementShape",n,e,t),i=F("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,i)]}case"TensorListSplit":{const r=F("tensor",n,e,t),s=F("elementShape",n,e,t),i=F("lengths",n,e,t),o=FJe(r,i,s);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=F("tensorListId",n,e,t),s=t.getTensorList(r.id);return[en(s.size(),"int32")]}case"TensorListResize":{const r=F("tensorListId",n,e,t),s=F("size",n,e,t),o=t.getTensorList(r.id).resize(s);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YH(n,e,t){const[r,s]=F("fusedOps",n,e,t),i=r==="biasadd",o=!i,a=s==="prelu",l=r==="fusedbatchnorm",c=F("numArgs",n,e,t);if(i){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=F("strides",n,e,t),h=BE(n,e,t),f=F("dataFormat",n,e,t).toUpperCase(),d=F("dilations",n,e,t);let[p,m]=F("args",n,e,t);o&&(m=p,p=void 0);const g=F("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:f,dilations:d,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:g}}const zJe=(n,e,t,r=fo)=>{switch(n.op){case"Conv1D":{const s=F("stride",n,e,t),i=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilation",n,e,t);return[r.conv1d(F("x",n,e,t),F("filter",n,e,t),s,i,o,a)]}case"Conv2D":{const s=F("strides",n,e,t),i=BE(n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv2d(F("x",n,e,t),F("filter",n,e,t),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=YH(n,e,t);return[r.fused.conv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=YH(n,e,t);return[r.fused.depthwiseConv2d({x:F("x",n,e,t),filter:F("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=F("outputShape",n,e,t),i=F("strides",n,e,t),o=BE(n,e,t);return[r.conv2dTranspose(F("x",n,e,t),F("filter",n,e,t),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=F("strides",n,e,t),i=BE(n,e,t),o=F("dilations",n,e,t),a=F("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(F("input",n,e,t),F("filter",n,e,t),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("dataFormat",n,e,t).toUpperCase(),a=F("dilations",n,e,t);return[r.conv3d(F("x",n,e,t),F("filter",n,e,t),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t),a=F("includeBatchInIndex",n,e,t),{result:l,indexes:c}=r.maxPoolWithArgmax(F("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i,a);return[l,c]}case"AvgPool3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.avgPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("kernelSize",n,e,t);return[r.maxPool3d(F("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=F("strides",n,e,t),i=F("pad",n,e,t),o=F("dilations",n,e,t),a=s[1],l=s[2],c=o[1],u=o[2];return[r.dilation2d(F("x",n,e,t),F("filter",n,e,t),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BJe=(n,e,t,r=fo)=>{switch(n.op){case"Fill":{const s=F("shape",n,e,t),i=F("dtype",n,e,t),o=F("value",n,e,t);return[r.fill(s,o,i)]}case"LinSpace":{const s=F("start",n,e,t),i=F("stop",n,e,t),o=F("num",n,e,t);return[r.linspace(s,i,o)]}case"Multinomial":{const s=F("logits",n,e,t),i=F("numSamples",n,e,t),o=F("seed",n,e,t);return[r.multinomial(s,i,o)]}case"OneHot":{const s=F("indices",n,e,t),i=F("depth",n,e,t),o=F("onValue",n,e,t),a=F("offValue",n,e,t),l=F("dtype",n,e,t);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(F("shape",n,e,t),F("dtype",n,e,t))];case"OnesLike":return[r.onesLike(F("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(F("shape",n,e,t),F("dtype",n,e,t),F("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(F("shape",n,e,t),F("minval",n,e,t),F("maxval",n,e,t),F("seed",n,e,t))];case"Range":{const s=F("start",n,e,t),i=F("stop",n,e,t),o=F("step",n,e,t);return[r.range(s,i,o,F("dtype",n,e,t))]}case"TruncatedNormal":{const s=F("shape",n,e,t),i=F("mean",n,e,t),o=F("stdDev",n,e,t),a=F("seed",n,e,t);return[r.truncatedNormal(s,i,o,F("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(F("shape",n,e,t),F("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3(n,e,t){const r=F("boxes",n,e,t),s=F("scores",n,e,t),i=F("maxOutputSize",n,e,t),o=F("iouThreshold",n,e,t),a=F("scoreThreshold",n,e,t),l=F("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const VJe=async(n,e,t,r,s=fo)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=S3(n,e,t),h=await s.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=S3(n,e,t),u=F("padToMaxOutputSize",n,e,t),h=await s.image.nonMaxSuppressionPaddedAsync(i,o,a,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=S3(n,e,t);return[await s.image.nonMaxSuppressionAsync(i,o,a,l,c)]}case"Where":{const i=s.cast(F("condition",n,e,t),"bool"),o=[await s.whereAsync(i)];return i.dispose(),o}case"ListDiff":return s.setdiff1dAsync(F("x",n,e,t),F("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UJe=(n,e,t,r=fo)=>{switch(n.op){case"LowerBound":{const s=F("sortedSequence",n,e,t),i=F("values",n,e,t);return[r.lowerBound(s,i)]}case"TopKV2":{const s=F("x",n,e,t),i=F("k",n,e,t),o=F("sorted",n,e,t),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=F("sortedSequence",n,e,t),i=F("values",n,e,t);return[r.upperBound(s,i)]}case"Unique":{const s=F("x",n,e,t),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=F("x",n,e,t),i=F("axis",n,e,t),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WJe=(n,e,t,r=fo)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=F("default",n,e,t);return[ao(n.name,e,t)||s];case"Placeholder":return[ao(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=F("x",n,e,t);return[mf(u)]}case"IdentityN":return F("x",n,e,t).map(u=>mf(u));case"Snapshot":const i=F("x",n,e,t);return[mf(i)];case"Shape":return[r.tensor1d(F("x",n,e,t).shape,"int32")];case"ShapeN":return F("x",n,e,t).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(F("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(F("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=F("x",n,e,t),a=F("data",n,e,t),l=F("message",n,e,t),c=F("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GJe{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=en(0),this.tensorMap=new Map,Xs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return en(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Se(()=>{const s=kc(t),i=r.length,o=s.length;U(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=r[a],c=s[a];Xs(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return Se(()=>{const s=[];for(let i=0;i<r.length;i++){const o=r[i],a=this.findWithDefault(o,t);s.push(a)}return xa(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HJe=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(n.name);if(s!=null)return[s];{const i=F("keyDType",n,e,t),o=F("valueDType",n,e,t),a=new GJe(i,o);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=F("tableHandle",n,e,t,r),i=F("keys",n,e,t),o=F("values",n,e,t);return[await r.getHashTableById(s.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=F("tableHandle",n,e,t,r),i=F("keys",n,e,t),o=F("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=F("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jJe=(n,e,t,r=fo)=>{switch(n.op){case"ResizeBilinear":{const s=F("images",n,e,t),i=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=F("images",n,e,t),i=F("size",n,e,t),o=F("alignCorners",n,e,t),a=F("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=F("image",n,e,t),i=F("boxes",n,e,t),o=F("boxInd",n,e,t),a=F("cropSize",n,e,t),l=F("method",n,e,t),c=F("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const s=F("images",n,e,t),i=F("transforms",n,e,t),o=F("outputShape",n,e,t),a=F("fillValue",n,e,t),l=F("interpolation",n,e,t),c=F("fillMode",n,e,t);return[r.image.transform(s,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qJe=(n,e,t,r=fo)=>{switch(n.op){case"Equal":return[r.equal(F("a",n,e,t),F("b",n,e,t))];case"NotEqual":return[r.notEqual(F("a",n,e,t),F("b",n,e,t))];case"Greater":return[r.greater(F("a",n,e,t),F("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(F("a",n,e,t),F("b",n,e,t))];case"Less":return[r.less(F("a",n,e,t),F("b",n,e,t))];case"LessEqual":return[r.lessEqual(F("a",n,e,t),F("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(F("a",n,e,t),F("b",n,e,t))];case"LogicalNot":return[r.logicalNot(F("a",n,e,t))];case"LogicalOr":return[r.logicalOr(F("a",n,e,t),F("b",n,e,t))];case"Select":case"SelectV2":return[r.where(F("condition",n,e,t),F("a",n,e,t),F("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(F("a",n,e,t),F("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XJe=(n,e,t,r=fo)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(F("a",n,e,t),F("b",n,e,t),F("transposeA",n,e,t),F("transposeB",n,e,t))];case"Einsum":return[r.einsum(F("equation",n,e,t),...F("tensors",n,e,t))];case"Transpose":return[r.transpose(F("x",n,e,t),F("perm",n,e,t))];case"_FusedMatMul":const[s,i]=F("fusedOps",n,e,t),o=s==="biasadd",a=i==="prelu",l=F("numArgs",n,e,t),c=F("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=F("args",n,e,t);return[r.fused.matMul({a:F("a",n,e,t),b:F("b",n,e,t),transposeA:F("transposeA",n,e,t),transposeB:F("transposeB",n,e,t),bias:u,activation:i,preluActivationWeights:h,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(F("a",n,e,t),F("numLower",n,e,t),F("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJe=(n,e,t,r=fo)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(F("x",n,e,t),F("axis",n,e,t),F("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(F("x",n,e,t),F("mean",n,e,t),F("variance",n,e,t),F("offset",n,e,t),F("scale",n,e,t),F("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(F("x",n,e,t),F("radius",n,e,t),F("bias",n,e,t),F("alpha",n,e,t),F("beta",n,e,t))];case"Softmax":return[r.softmax(F("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YJe=(n,e,t,r=fo)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(F("paramsNestedSplits",n,e,t),F("paramsDenseValues",n,e,t),F("indices",n,e,t),F("outputRaggedRank",n,e,t));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(F("starts",n,e,t),F("limits",n,e,t),F("splits",n,e,t));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(F("shape",n,e,t),F("values",n,e,t),F("defaultValue",n,e,t),F("rowPartitionTensors",n,e,t),F("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZJe=(n,e,t,r=fo)=>{switch(n.op){case"Max":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.max(F("x",n,e,t),a,l)]}case"Mean":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.mean(F("x",n,e,t),a,l)]}case"Min":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.min(F("x",n,e,t),a,l)]}case"Sum":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.sum(F("x",n,e,t),a,l)]}case"All":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.all(F("x",n,e,t),a,l)]}case"Any":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.any(F("x",n,e,t),a,l)]}case"ArgMax":{const a=F("axis",n,e,t);return[r.argMax(F("x",n,e,t),a)]}case"ArgMin":{const a=F("axis",n,e,t);return[r.argMin(F("x",n,e,t),a)]}case"Prod":{const a=F("axis",n,e,t),l=F("keepDims",n,e,t);return[r.prod(F("x",n,e,t),a,l)]}case"Cumprod":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumprod(F("x",n,e,t),a,l,c)]}case"Cumsum":{const a=F("axis",n,e,t),l=F("exclusive",n,e,t),c=F("reverse",n,e,t);return[r.cumsum(F("x",n,e,t),a,l,c)]}case"Bincount":const s=F("x",n,e,t),i=F("weights",n,e,t),o=F("size",n,e,t);return[r.bincount(s,i,o)];case"DenseBincount":{const a=F("x",n,e,t),l=F("weights",n,e,t),c=F("size",n,e,t),u=F("binaryOutput",n,e,t);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JJe=(n,e,t,r=fo)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=F("n",n,e,t),i=F("axis",n,e,t);let o=F("tensors",n,e,t);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=F("x",n,e,t),i=F("indices",n,e,t);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=F("axis",n,e,t),i=F("batchDims",n,e,t),o=F("x",n,e,t),a=F("indices",n,e,t);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=F("dims",n,e,t),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=F("x",n,e,t);return[r.reverse(o,i)]}case"ReverseV2":{const s=F("axis",n,e,t),i=F("x",n,e,t);return[r.reverse(i,s)]}case"Slice":{const s=F("begin",n,e,t),i=F("size",n,e,t);return[r.slice(F("x",n,e,t),s,i)]}case"StridedSlice":{const s=F("begin",n,e,t),i=F("end",n,e,t),o=F("strides",n,e,t),a=F("beginMask",n,e,t),l=F("endMask",n,e,t),c=F("ellipsisMask",n,e,t),u=F("newAxisMask",n,e,t),h=F("shrinkAxisMask",n,e,t),f=F("x",n,e,t);return[r.stridedSlice(f,s,i,o,a,l,c,u,h)]}case"Pack":return Se(()=>{const s=F("axis",n,e,t),i=F("tensors",n,e,t),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(c=>{const u=Rn(c.shape,o);if(!u&&!Rn(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,s)]});case"Unpack":{const s=F("axis",n,e,t),i=F("tensor",n,e,t);return r.unstack(i,s)}case"Tile":{const s=F("reps",n,e,t);return[r.tile(F("x",n,e,t),s)]}case"Split":case"SplitV":{const s=F("axis",n,e,t),i=F("numOrSizeSplits",n,e,t),o=F("x",n,e,t);return r.split(o,i,s)}case"ScatterNd":{const s=F("indices",n,e,t),i=F("values",n,e,t),o=F("shape",n,e,t);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=F("x",n,e,t),i=F("indices",n,e,t);return[r.gatherND(s,i)]}case"SparseToDense":{const s=F("sparseIndices",n,e,t),i=F("outputShape",n,e,t),o=F("sparseValues",n,e,t),a=F("defaultValue",n,e,t);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const s=F("indices",n,e,t),i=F("values",n,e,t),o=F("tensor",n,e,t);return[r.tensorScatterUpdate(o,s,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QJe=(n,e,t,r=fo)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(F("indices",n,e,t),F("values",n,e,t),F("denseShape",n,e,t),F("defaultValue",n,e,t));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(F("inputIndices",n,e,t),F("inputShape",n,e,t),F("newShape",n,e,t));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(F("data",n,e,t),F("indices",n,e,t),F("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eQe=(n,e,t,r=fo)=>{switch(n.op){case"FFT":return[r.fft(F("x",n,e,t))];case"IFFT":return[r.ifft(F("x",n,e,t))];case"RFFT":return[r.rfft(F("x",n,e,t))];case"IRFFT":return[r.irfft(F("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tQe=(n,e,t,r=fo)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(F("input",n,e,t),F("pattern",n,e,t),F("rewrite",n,e,t),F("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(F("data",n,e,t),F("dataSplits",n,e,t),F("separator",n,e,t),F("nGramWidths",n,e,t),F("leftPad",n,e,t),F("rightPad",n,e,t),F("padWidth",n,e,t),F("preserveShortSequences",n,e,t));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(F("input",n,e,t),F("delimiter",n,e,t),F("skipEmpty",n,e,t));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(F("input",n,e,t),F("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nQe=(n,e,t,r=fo)=>{switch(n.op){case"Cast":return[r.cast(F("x",n,e,t),F("dtype",n,e,t))];case"ExpandDims":{const s=F("axis",n,e,t);return[r.expandDims(F("x",n,e,t),s)]}case"Squeeze":{const s=F("axis",n,e,t);return[r.squeeze(F("x",n,e,t),s)]}case"Reshape":return[r.reshape(F("x",n,e,t),F("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(F("x",n,e,t),F("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(F("x",n,e,t),F("padding",n,e,t),F("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(F("x",n,e,t),F("padding",n,e,t),F("constantValue",n,e,t))];case"SpaceToBatchND":{const s=F("blockShape",n,e,t),i=F("paddings",n,e,t);return[r.spaceToBatchND(F("x",n,e,t),s,i)]}case"BatchToSpaceND":{const s=F("blockShape",n,e,t),i=F("crops",n,e,t);return[r.batchToSpaceND(F("x",n,e,t),s,i)]}case"DepthToSpace":{const s=F("blockSize",n,e,t),i=F("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(F("x",n,e,t),s,i)]}case"BroadcastTo":return[r.broadcastTo(F("x",n,e,t),F("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(F("s0",n,e,t),F("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZH(n,e,t,r,s=Se){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>NJe(o,a,l));case"basic_math":return s(()=>$Je(o,a,l));case"control":return LJe(o,a,l);case"convolution":return s(()=>zJe(o,a,l));case"creation":return s(()=>BJe(o,a,l));case"dynamic":return VJe(o,a,l);case"evaluation":return s(()=>UJe(o,a,l));case"image":return s(()=>jJe(o,a,l));case"graph":return s(()=>WJe(o,a,l));case"logical":return s(()=>qJe(o,a,l));case"matrices":return s(()=>XJe(o,a,l));case"normalization":return s(()=>KJe(o,a,l));case"ragged":return s(()=>YJe(o,a,l));case"reduction":return s(()=>ZJe(o,a,l));case"slice_join":return s(()=>JJe(o,a,l));case"sparse":return s(()=>QJe(o,a,l));case"spectral":return s(()=>eQe(o,a,l));case"string":return s(()=>tQe(o,a,l));case"transformation":return s(()=>nQe(o,a,l));case"hash_table":return HJe(o,a,l,r);case"custom":const c=Nte(o.op);if(c&&c.customExecutor)return c.customExecutor(new MJe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return np(i)?i.then(o=>[].concat(o)):[].concat(i)}class JH{constructor(e={},t={},r={},s={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QH(n,e,t,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,c=new Set(Object.keys(n).map(f=>Ba(f)[0]));r=r||[];const u=new Set(r.map(f=>Ba(f.name)[0])),h=[...e];for(;h.length>0;){const f=h.pop();if((Pm(f)||uQe(f)||hQe(f))&&o==null&&(o=f,a=o.children.map(d=>d.name).filter(d=>s.has(d))),s.add(f.name),t[f.name]==null&&!c.has(f.name)&&!u.has(f.name)){if(f.inputs.length===0){i.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),h.push(d))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}function rQe(n,e){const{usedNodes:t,inputs:r}=e,s=Object.keys(r).map(g=>Ba(g)[0]).map(g=>n.nodes[g]),i=n.initNodes||[],o=g=>t.has(typeof g=="string"?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...s,...n.weights,...i]).filter(o),c=a([...l,...Object.values(n.nodes)]).filter(o),u=new Map(c.map(g=>[g.name,g])),h={};for(const g of c){h[g.name]=h[g.name]||0;for(const y of g.children)o(y)||(h[y.name]=Number.POSITIVE_INFINITY),h[y.name]=(h[y.name]||0)+1}const f=Object.entries(h).filter(([,g])=>g===0).map(([g])=>g),d=[...f];for(;f.length>0;){const g=f.pop(),y=u.get(g);for(const b of y.children.filter(o))--h[b.name]===0&&(d.push(b.name),f.push(b.name))}const p=d.map(g=>u.get(g)),m=sQe(p,l);return iQe(m,l),m}function sQe(n,e){const t=new Map(n.map(o=>[o.name,o])),r=e.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return n.filter(o=>s.has(o.name))}class iT extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function iQe(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new iT(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new iT(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!t.has(l.name))throw new iT(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new iT(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function oQe(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>Pm(a)?t:l),s=a=>{const l=r[e.get(a.name)];return l??-1},i=n.map((a,l)=>a.children.map(s).reduce((c,u)=>Math.max(c,u),r[l])),o=new Map;for(let a=0;a<n.length;++a){const l=i[a];if(l===t)continue;const c=n[a],u=n[l];o.has(u.name)||o.set(u.name,[]),o.get(u.name).push(c)}return o}const aQe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),lQe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),cQe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Pm(n){return aQe.has(n.op)}function uQe(n){return lQe.has(n.op)}function hQe(n){return cQe.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZI{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new ZI(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(i=>i.name).sort(),s=t.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,t){const r=QH(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const c=t.map(h=>h.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}const a=rQe(this.graph,r),l=oQe(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Xs(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(f=>this.graph.nodes[Ba(f)[0]]),i=t.map(f=>Ba(f)[0]),o=new Set(i);let a=i.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const u={},h={};return Se(()=>{const f=new JH(this.weightMap,u,h,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[b,x]=Ba(y,f),w=[];w[x]=e[y],d[b]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(w))});const p=this.getFrozenTensorIds(d),{orderedNodes:m,nodeLiveUntilMap:g}=c;for(const y of m){if(d[y.name])continue;const b=ZH(y,d,f,this._resourceManager);if(np(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,p,o,g.get(y.name))}return this.parent==null&&f.dispose(p),t.map(y=>ao(y,d,f))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,i,o,a){if(!(Pm(t)||o.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(Pm(l))continue;const c=jH(l.name,r,s);if(c!=null)for(const u of c){if(!u||u.kept||i.has(u.id))continue;const h=a[u.id];h===1?(u.dispose(),delete a[u.id]):h!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,s,i,o){function a(l){return Pm(l)||i.has(l.name)}if(!(Pm(e)||o==null))for(const l of o){if(a(l))continue;const c=jH(l.name,t,r);for(const u of c)!u||u.kept||s.has(u.id)||u.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,s={},i={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new JH(this.weightMap,s,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,r),l=t.map(f=>ao(f,a,o)),c=l.map(f=>f.id),u=Object.keys(e).map(f=>e[f].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(a).forEach(f=>{f.forEach(d=>{d&&!d.isDisposed&&!h.has(d.id)&&d.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,r){const s=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const i=Object.keys(e),o=i.map(w=>this.graph.nodes[Ba(w)[0]]),a=r.map(w=>Ba(w)[0]),l=new Set(a);let c=a.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);const{usedNodes:u,missingInputs:h,dynamicNode:f,syncInputs:d}=QH(e,c,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),m=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[S,C]=Ba(w),k=[];k[C]=e[w],m[S]=k});const g={},y=this.getFrozenTensorIds(m),b={};for(;p.length>0;){const w=this.processStack(o,p,t,m,b,y,l,g,u);await Promise.all(w)}f==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=c.filter(w=>!Pm(w)&&!ao(w.name,m,t)).map(w=>w.name);if(x.length>0){let w="";throw f!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${w}`)}return m}processStack(e,t,r,s,i,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let f="";if(h.node.op==="Enter"&&F("isConstant",h.node,s,r)&&([f]=pf(h.node.name,r)),s[h.node.name]==null){const d=ZH(h.node,s,r,this._resourceManager);f||([f]=pf(h.node.name,r));const p=r.currentContext;np(d)?u.push(d.then(m=>(s[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(f,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,c),m))):(s[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,c))}else this.processChildNodes(h.node,t,r,s,i,c)}return u}processChildNodes(e,t,r,s,i,o){e.children.forEach(a=>{const[l]=pf(a.name,r);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!ao(c,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!ao(c,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=Ba(t),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,c)=>o[c]===-1||o[c]===l);U(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&U(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const s={};for(const i in e){const o=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[i];o!=null?s[o.name]=e[i]:s[i]=e[i]}return s}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=Ba(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,s;const i=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=Ba(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class fQe{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dQe="?tfjs-format=file",pQe="model.json";class QB{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=jz){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new fQe}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return np(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(r=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ZI(qH.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=qH.Instance.transformGraph(e.modelInitializer);this.initializer=new ZI(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof jn?[e]:e,r={};return t.forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof jn)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||c===void 0?void 0:c.resourceId;return u!=null?i[o]=this.resourceIdToCapturedInput[u]:i[o]=e[s++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++){const i=r[s],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[s]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nn(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Nl(n,e={},t=jz){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=gQe(n));const r=new QB(n,e,t);return await r.load(),r}function mQe(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[r,s]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const i=FL(r.weightsManifest),o=DL(r,i,s);e=AI(o)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=AI(n);else throw new Error("Unknown model format");const t=new QB(e);return t.load(),t}function gQe(n){return n.endsWith("/")||(n=n+"/"),`${n}${pQe}${dQe}`}/** @license See the LICENSE file. */const yQe="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bQe=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:QB,deregisterOp:GZe,loadGraphModel:Nl,loadGraphModelSync:mQe,registerOp:WZe,version_converter:yQe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class sh extends Error{constructor(e){super(e),Object.setPrototypeOf(this,sh.prototype)}}class pc extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pc.prototype)}}class _e extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_e.prototype)}}class Fn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Fn.prototype)}}class e4 extends Error{constructor(e){super(e),Object.setPrototypeOf(this,e4.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Pte{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mg(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ih(n,e){if(!n)throw new e4(e)}function e6(n,e){let t=0;for(const r of n)r===e&&t++;return t}function fa(n){return n.length===1?n[0]:n}function Gr(n){return Array.isArray(n)?n:[n]}function gf(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Dm(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Zl={};function t4(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function zO(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>zO(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:zO(r))}}}function _C(n,e={},t={},r="object",s=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in Zl)o=Zl[i];else if(o=e[i],o==null)throw new _e(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new _e(`${r}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in t?[a,l]=t[o]:o in Zl?[a,l]=Zl.className:o in e&&([a,l]=e[o]),a==null)throw new _e(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const d of Object.keys(Zl))c[d]=Zl[d];for(const d of Object.keys(t))c[d]=t[d];const u=i.config;u.customObjects=c;const h=Object.assign({},Zl);for(const d of Object.keys(t))Zl[d]=t[d];zO(i.config);const f=l(a,i.config,t,s);return Zl=Object.assign({},h),f}else{const c=Object.assign({},Zl);for(const h of Object.keys(t))Zl[h]=t[h];const u=new a(i.config);return Zl=Object.assign({},c),u}}}function vQe(n,e){return n<e?-1:n>e?1:0}function oT(n,e){return-1*vQe(n,e)}function Wd(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function wQe(n){if(n==null)throw new _e(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function qy(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new _e(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function n4(n,e,t=0,r=1/0){return ih(t>=0),ih(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(s=>typeof s===e)}function Wi(n,e){Array.isArray(n)?(U(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Wi(t,`element ${r+1} of ${e}`))):U(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Dte(n)}.`)}function Dte(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Dte(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function xQe(n,e,t){let r=t!=null?t():so(),s;return(...o)=>{const a=t!=null?t():so();return a-r<e||(r=a,s=n(...o)),s}}function Ote(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let _Qe=0;function Fte(){return _Qe++}const aT={};function s$(n=""){return n in aT||(aT[n]=0),aT[n]+=1,n+aT[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const SQe=["channelsFirst","channelsLast"],CQe=["nearest","bilinear"],kQe=["valid","same","causal"],TQe=["max","avg"],EQe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const D0=new Map;function ti(n){qy(SQe,"DataFormat",n)}function IQe(n){qy(CQe,"InterpolationFormat",n)}function Ll(n){qy(kQe,"PaddingMode",n)}function Lte(n){qy(TQe,"PoolMode",n)}const J1=[],t6="/";function qm(n,e){J1.push(n);try{const t=e();return J1.pop(),t}catch(t){throw J1.pop(),t}}function AQe(){return J1.length===0?"":J1.join(t6)+t6}function zte(n){if(!Vte(n))throw new Error("Not a valid tensor name: '"+n+"'");return AQe()+n}function Bte(n){if(!Vte(n))throw new Error("Not a valid tensor name: '"+n+"'");D0.has(n)||D0.set(n,0);const e=D0.get(n);if(D0.set(n,D0.get(n)+1),e>0){const t=`${n}_${e}`;return D0.set(t,1),t}else return n}const MQe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Vte(n){return!!n.match(MQe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function NQe(n){return n===parseInt(n.toString(),10)}function Gd(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let s=e;s<t;++s)r*=n[s];return r}function sv(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function cp(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function Su(n,e){if(e<n)throw new _e(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let C3;function ki(){return C3==null&&(C3=sg().epsilon()),C3}function Cu(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ph(n,e){return wt(n,e)}function SC(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),ve(n,t)}function $Qe(n,e){return Se(()=>{if(n.shape.length!==2)throw new _e(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=SC(n,1);return BO(t,[1,e,1])})}function RQe(n){const e=[Gd(n.shape)];return ve(n,e)}function PQe(n){if(n.rank<=1)throw new _e(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Gd(n.shape,1)];return ve(n,e)}function Xm(n,e,t){return Se(()=>{switch(n.rank){case 1:return eC(n,e,t);case 2:return qM(n,[e,0],[t,n.shape[1]]);case 3:return tC(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Yb(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return dn(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return dn(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new _e(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function k3(n,e,t){return Se(()=>{switch(n.rank){case 1:return eC(n,e,t);case 2:return qM(n,[0,e],[n.shape[0],t]);case 3:return tC(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Yb(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function lT(n,e,t,r){return Se(()=>{switch(n.rank){case 1:return eC(n,e,t);case 2:switch(r){case 1:return Xm(n,e,t);case 2:return k3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Xm(n,e,t);case 2:return tC(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return k3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Xm(n,e,t);case 2:return Yb(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Yb(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return k3(n,e,t);default:throw new _e(`The axis is not within the rank of the tensor ${r}`)}default:throw new _e(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function r4(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),cs(n,e)}function n6(n,e){switch(n.rank){case 1:return KL([n,e]);case 2:return YL([n,e],0);case 3:return ZL([n,e],0);case 4:return JL([n,e],0);default:throw new _e(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function BO(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new _e(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return fc(n,e)}function i$(n,e=0,t=1,r,s){return jM(n,e,t,r,s)}function mh(n,e,t,r){if(n.rank<2||e.rank<2)throw new Fn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const s=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(s!==i)throw new Fn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return SD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?VO(n.rank,r,Cu()):null,activation:t});{const s=n.shape.slice(),i=s.pop();n=ve(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(p,m)=>m===0?e.rank-2:m<=e.rank-2?m-1:m);e=ve(rr(e,u),[l,-1]);const h=[...s,...c];return ve(SD({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?VO(n.rank,r,Cu()):null,activation:t}),h)}}function Ute(n,e,t){return Se(()=>(Array.isArray(e)?e=Ks(e,"int32"):e=wt(e,"int32"),Z2(n,e,t)))}function CC(n){return fe(n,n)}function VO(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new _e(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1,1]):ve(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1,1]):ve(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,1,r[0]]):ve(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?ve(e,[1,r[0],1]):ve(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?ve(e,[1,1,r[0]]):ve(e,[1].concat(r))}else if(n<3)return e;throw new _e(`Unsupported input rank by biasAdd: ${e.rank}`)}function Vu(n,e,t){return Se(()=>(t==null&&(t=Cu()),ti(t),qe(n,VO(n.rank,e,t))))}function DQe(n,e=1){if(e!==1)throw new Fn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return K2(n)}function OQe(n){return Se(()=>Lt(n,qe(wi(n),1)))}function Wte(n,e,t,r){return Se(()=>Pz(n,e,t,r))}function FQe(n){return Se(()=>{const e=qe(.5,fe(.2,n));return wa(e,0,1)})}function kC(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const LQe=["fanIn","fanOut","fanAvg"],zQe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function BQe(n){qy(LQe,"FanMode",n)}function VQe(n){qy(zQe,"Distribution",n)}class Rc extends Dy{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Gte extends Rc{apply(e,t){return ms(e,t)}}Gte.className="Zeros";ot(Gte);class s4 extends Rc{apply(e,t){return pa(e,t)}}s4.className="Ones";ot(s4);class Hte extends Rc{constructor(e){if(super(),typeof e!="object")throw new _e(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new _e(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Se(()=>fe(en(this.value),pa(e,t)))}getConfig(){return{value:this.value}}}Hte.className="Constant";ot(Hte);class jte extends Rc{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Np(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}jte.className="RandomUniform";ot(jte);class qte extends Rc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`randomNormal does not support dType ${t}.`);return i$(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qte.className="RandomNormal";ot(qte);class Xte extends Rc{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`truncatedNormal does not support dType ${t}.`);return ZM(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Xte.className="TruncatedNormal";ot(Xte);let Kte=class extends Rc{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return Se(()=>{if(e.length!==2||e[0]!==e[1])throw new _e("Identity matrix initializer can only be used for 2D square matrices.");return fe(this.gain,OM(e[0]))})}getConfig(){return{gain:this.gain}}};Kte.className="Identity";ot(Kte);function UQe(n,e="channelsLast"){let t,r;if(ti(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const s=Gd(n,2);t=n[1]*s,r=n[0]*s}else if(e==="channelsLast"){const s=Gd(n,0,n.length-2);t=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=Gd(n);t=Math.sqrt(s),r=Math.sqrt(s)}return[t,r]}class Ya extends Rc{constructor(e){if(super(),e.scale<0)throw new _e(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,BQe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,VQe(this.distribution),this.seed=e.seed}apply(e,t){const r=UQe(e),s=r[0],i=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,s):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(s+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`${this.getClassName()} does not support dType ${t}.`);return ZM(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return Np(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ya.className="VarianceScaling";ot(Ya);class i4 extends Ya{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ya.className}}i4.className="GlorotUniform";ot(i4);class o4 extends Ya{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ya.className}}o4.className="GlorotNormal";ot(o4);class a4 extends Ya{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ya.className}}a4.className="HeNormal";ot(a4);class l4 extends Ya{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ya.className}}l4.className="HeUniform";ot(l4);class c4 extends Ya{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ya.className}}c4.className="LeCunNormal";ot(c4);class u4 extends Ya{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ya.className}}u4.className="LeCunUniform";ot(u4);class Yte extends Rc{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Se(()=>{if(e.length<2)throw new Fn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const r=Te(e.slice(0,-1)),s=e[e.length-1],i=r*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(s,r),Math.min(s,r)],a=i$(o,0,1,t,this.seed),l=Lz.qr(a,!1);let c=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return c=fe(c,h.sign()),r<s&&(c=c.transpose()),fe(en(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}Yte.className="Orthogonal";ot(Yte);const r6={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function s6(n,e={}){return _C(n,vl.getMap().classNameMap,e,"initializer")}function Cs(n){return t4(n)}function ys(n){if(typeof n=="string"){const e=n in r6?r6[n]:n;if(e==="GlorotNormal")return new o4;if(e==="GlorotUniform")return new i4;if(e==="HeNormal")return new a4;if(e==="HeUniform")return new l4;if(e==="LeCunNormal")return new c4;if(e==="LeCunUniform")return new u4;{const t={};return t.className=e,t.config={},s6(t)}}else return n instanceof Rc?n:s6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function UO(n){return Array.isArray(n)&&Array.isArray(n[0])}function JI(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function vn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new _e(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function wr(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new _e(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function QI(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,s)=>r*s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const i6="Variable";class WQe{constructor(e,t="float32",r=i6,s=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Fte(),r=r??i6,this.originalName=zte(r),this.name=Bte(this.originalName),this.trainable_=s,this.constraint=i,this.val=$z(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),GQe(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function GQe(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function WO(n){return n.map(e=>e.read())}function h4(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ti{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Sh{constructor(e,t,r,s,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=Fte(),o!=null&&(this.originalName=zte(o),this.name=Bte(this.originalName)),this.rank=t.length}}let HQe=0,o$=class{constructor(e,t){this.callArgs=t,this.id=HQe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},jQe=0;class Kn extends Dy{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=jQe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=gf(r)+"_"+s$(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),r=[i].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new pc(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new _e(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return fa(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return fa(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new sh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new sh(`Layer ${this.name} is not connected, no input to return.`);return fa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new sh(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new sh(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return fa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Gr(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Gr(this.inputSpec);if(t.length!==r.length)throw new _e(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let s=0;s<t.length;s++){const i=t[s],o=r[s];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new _e(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const c in o.axes){const u=Number(c),h=o.axes[c],f=u>=0?l[u]:l[l.length+u];if(h!=null&&[h,null].indexOf(f)===-1)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=i.shape[l];if(c!=null&&u!=null&&c!==u)throw new _e(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Gr(e),s=KQe(e),i=YQe(e);if(s===i)throw new _e("Arguments to apply() must be all SymbolicTensors or all Tensors");return qm(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Gr(e))o.push(a.shape);this.build(fa(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Gr(o),l=[];for(let c of a)r.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=fa(l),this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=qQe(e),a=this.computeOutputShape(o);let l;const c=XQe(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,h)=>new Sh(c,u,this,Gr(e),t,this.name,h)):l=new Sh(c,a,this,Gr(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new sh(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new sh(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new pc(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return QI(this.weights)}build(e){this.built=!0}getWeights(e=!1){return WO(e?this.trainableWeights:this.weights)}setWeights(e){Se(()=>{const t=this.weights;if(t.length!==e.length)throw new _e(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],s=WO(t);for(let i=0;i<s.length;++i){const o=s[i],a=t[i],l=e[i];if(!Rn(o.shape,l.shape))throw new _e(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}h4(r)})}addWeight(e,t,r,s,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new _e(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():ys("zeros"));const c=s.apply(t,r),u=new WQe(c,r,e,o,a);return c.dispose(),i!=null&&this.addLoss(()=>i.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Gr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;const s=this.computeMask(e,r);if(t instanceof Array&&s instanceof Array){if(t.length!==s.length)throw new Error(`${this.name} outputs ${t.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<t.length;i++)t[i].kerasMask=s[i]}else{if(s instanceof Array)throw new Error(`{this.name} outputs a single tensor but ${s.length} masks`);if(t instanceof Array)throw new Error(`{this.name} outputs ${t.length} tensors but only one mask`);t.kerasMask=s}}addInboundNode(e,t,r,s,i,o,a=null){const l=Gr(e);t=Gr(t),r=Gr(r),s=Gr(s),i=JI(i),o=JI(o);const c=[],u=[],h=[];for(const f of l)c.push(f.sourceLayer),u.push(f.nodeIndex),h.push(f.tensorIndex);new o$({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function qQe(n){n=Gr(n);const e=[];for(const t of n)e.push(t.shape);return fa(e)}function XQe(n){return"float32"}function Zte(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const o=r.inputTensors[i],a=r.inboundLayers[i],l=r.nodeIndices[i],c=Zte(o,a,l);for(const u of c)s.indexOf(u)===-1&&s.push(u)}return s}}}function KQe(n){let e=!0;for(const t of Gr(n))if(!(t instanceof Sh)){e=!1;break}return e}function YQe(n){let e=!0;for(const t of Gr(n))if(t instanceof Sh){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class TC extends Kn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:s$("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new _e("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new _e("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new _e("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const s=new Sh(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new o$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new _e(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}TC.className="InputLayer";ot(TC);function ZQe(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new _e("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new TC({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function JQe(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return wt(e,n.dtype)}catch{throw new _e(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Rd{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Rd)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=JQe(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new _e(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Sh){if(this.id2Value[e.id]==null)throw new _e(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Sh){if(this.id2Value[e.id]==null)throw new _e(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _e(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&nn(this.id2Mask)}}const eA=new Pte,tA=new Pte;function QQe(n){eA!=null&&eA.setMaxEntries(n),tA!=null&&tA.setMaxEntries(n)}function I1(n,e,t,r){const s=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=e.names();for(const p of a)c.indexOf(p)!==-1?l.push(e.getValue(p)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+e.names().sort().join(",");let h=eA.get(u),f;if(h==null){const p=eet(o,e);h=p.sorted,f=p.recipientCounts,eA.put(u,h),tA.put(u,f)}f={},s||Object.assign(f,tA.get(u));const d=new Rd(e);for(let p=0;p<h.length;++p){if(r!=null){const M=kI().numTensors;M>r.maxNumTensors&&(r.maxNumTensors=M),M<r.minNumTensors&&(r.minNumTensors=M)}const m=h[p],g=m.sourceLayer;if(g instanceof TC)continue;const y=[],b=[],x=[];let w=!1;for(const M of m.inputs){const E=d.getValue(M),N=d.getMask(M);y.push(E),b.push(N),N!=null&&(w=!0),s||(f[M.name]--,f[M.name]===0&&!e.hasKey(M)&&a.indexOf(M.name)===-1&&!E.isDisposed&&M.sourceLayer.stateful!==!0&&x.push(E))}w&&(t=t||{},t.mask=b[0]);const S=Gr(g.apply(y,t));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const k=net(m),A=Array.isArray(k)?k:[k];for(let M=0;M<A.length;++M){d.hasKey(A[M])||d.add(A[M],S[M],Array.isArray(C)?C[0]:C);const E=a.indexOf(A[M].name);E!==-1&&(l[E]=S[M])}s||nn(x)}return d.disposeMasks(),i?l:l[0]}function eet(n,e){U(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const s=o6(n[0],e);t=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=o6(i,e);for(const l of o)s.has(l.name)||(t.push(l),s.add(l.name));for(const l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:t,recipientCounts:tet(r)}}function tet(n){const e={};for(const t in n)e[t]=n[t].size;return e}function o6(n,e){const t=new Set,r=[],s={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),r.push(a),t.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)s[c.name]==null&&(s[c.name]=new Set),s[c.name].add(a.name),!t.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function net(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ret=Ee();ret.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,QQe);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jte={kernelName:Tv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Mw(wt(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const set={kernelName:Og,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Or(wt(t,"float32")),s=So(Dt(en(1),r));return us(Lt(n,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iet={kernelName:Fg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=So(Dt(Or(wt(t,"float32")),1));return Lt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oet={kernelName:kp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=ui(t.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=ui(r.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aet={kernelName:Ev,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,s)=>{t[s]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cet={kernelName:Iv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>lr(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uet={kernelName:Av,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>lr(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const het={kernelName:Lg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,So(Dt(en(1),Or(wt(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fet={kernelName:zg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=So(qe(en(1),Or(wt(t,"float32"))));return Lt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const det={kernelName:Ug,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=qe(Or(t),Or(r));let l=fe(n,Lt(r,a));const c=ui(t.shape,s);return c.length>0&&(l=Yt(l,c)),ve(l,t.shape)},b:()=>{const a=qe(Or(t),Or(r));let l=us(fe(n,Lt(t,a)));const c=ui(r.shape,s);return c.length>0&&(l=Yt(l,c)),ve(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pet={kernelName:Bg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,qe(Or(wt(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const met={kernelName:Vg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Dt(en(1),Or(wt(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function get(n,e,t,r,s,i){const o=j(n,"dy","avgPool3dGrad"),a=j(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=ve(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),U(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),U(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),ta("avgPool3dGrad",s,i);const h={dy:l,input:c},f={filterSize:t,strides:r,pad:s,dimRoundingMode:i},d=ue.runKernel(qS,h,f);return u?ve(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const yet=he({avgPool3dGrad_:get});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bet={kernelName:Nv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>yet(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vet(n,e,t,r,s){const i=j(n,"dy","avgPoolGrad"),o=j(e,"input","avgPoolGrad");U(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;o.rank===3&&(c=!0,a=ve(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=ve(i,[1,i.shape[0],i.shape[1],i.shape[2]])),U(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),U(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},h={filterSize:t,strides:r,pad:s},f=ue.runKernel(jS,u,h);return c?ve(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const wet=he({avgPoolGrad_:vet});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xet={kernelName:Mv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=t;return{x:()=>wet(n,r,s,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _et={kernelName:$v,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,s]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>Hn(n,s,!1,!0),b:()=>Hn(r,n,!0,!1)}:!i&&o?{a:()=>Hn(n,s,!1,!1),b:()=>Hn(n,r,!0,!1)}:i&&!o?{a:()=>Hn(s,n,!1,!0),b:()=>Hn(r,n,!1,!1)}:{a:()=>Hn(s,n,!0,!0),b:()=>Hn(n,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cet={kernelName:Rv,gradFunc:(n,e,t)=>{const{blockShape:r,crops:s}=t;return{x:()=>GM(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ket={kernelName:aX,gradFunc:(n,e,t)=>{const r=t,s=r.inputShape,i=r.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Yt(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tet={kernelName:Wg,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eet={kernelName:Gg,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iet={kernelName:Hg,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=t;return{x:()=>_o(wh(Mp(r,s),Ry(r,i)),n,lr(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aet={kernelName:Pv,inputsToSave:["x"],gradFunc:Jte.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Met={kernelName:Dv,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(l=>l.shape),{axis:s}=t,i=An(s,e[0].shape)[0],o=r.map(l=>l[i]);return ja(n,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Net={kernelName:Ov,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=t;return U(rp(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>ez(r.shape,n,s,o,a,l),filter:()=>Oz(r,n,s.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $et={kernelName:Fv,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>sp(n,s,i,o,a,1,l),filter:()=>Oz(n,r,s.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ret(n,e,t,r,s){let i=n;n.rank===4&&(i=ve(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=ve(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),U(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),U(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),U(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),U(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),U(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},l={strides:r,pad:s,filterShape:t};return ue.runKernel(QS,a,l)}const Pet=he({conv3DBackpropFilter_:Ret});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Det={kernelName:Lv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i}=t;U(rp(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>ZX(o.shape,n,a,s,i),filter:()=>Pet(o,n,a.shape,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oet={kernelName:jg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(us(kz(wt(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fet={kernelName:qg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(Tz(wt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Let={kernelName:zv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=t;return{x:()=>{const a=Lr([s],r.rank);let l=iz(n,s,i,!o);return a!=null&&(l=rr(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zet={kernelName:Bv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=t,a=r??[1,1];U(rp(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return U(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),U(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),U(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),U(Ri(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),ta("depthwiseConv2d",i,o),{x:()=>hY(l.shape,n,c,s,i,a,o),filter:()=>uY(l,n,c.shape,s,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bet={kernelName:Vv,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>ue.runKernel(p_,i,t),filter:()=>ue.runKernel(m_,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vet={kernelName:Kg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>ue.runKernel(u2,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uet={kernelName:Yg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Yo(us(Or(t))),2/Math.sqrt(Math.PI));return{x:()=>fe(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wet={kernelName:Zg,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Get={kernelName:Wv,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Het={kernelName:Jg,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,Yo(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jet={kernelName:Qg,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qet={kernelName:ey,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=Lt(n,wt(r,"float32")),l=ui(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{let a=fe(n,wt(t,"float32"));const l=ui(r.shape,s);l.length>0&&(a=ve(Yt(a,l),r.shape));const c=Or(r);return us(Lt(a,wt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xet={kernelName:Gv,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[s,i,o,a]=e,l=a??en(1),c=ui(i.shape,s.shape),u=[];if(i.rank===1){for(let w=0;w<s.shape.length-1;++w)u.push(s.shape[w]);u.push(1)}const h=Dt(s,i),f=fe(n,l),d=_z(qe(o,en(r))),p=fe(fe(fe(d,d),d),en(-.5));return{x:()=>i.rank===1?ve(fe(fe(n,fc(ve(d,[1,1,1,i.shape[0]]),u)),l),s.shape):ve(fe(fe(n,d),l),s.shape),mean:()=>{let w=fe(fe(d,en(-1)),f);return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)},variance:()=>{let w=fe(fe(p,h),f);return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)},scale:()=>{const w=fe(h,d);let S=fe(n,w);return i.rank===1&&(S=Yt(S,c)),ve(S,i.shape)},offset:()=>{let w=n;return i.rank===1&&(w=Yt(w,c)),ve(w,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ket={kernelName:Hv,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,s]=e,{axis:i,batchDims:o}=t,a=An(i,r.shape)[0],l=(c,u,h)=>()=>{const f=c.shape,d=u.size,p=f.slice(0,a),m=p.length,g=f.slice(i,f.length).slice(1),y=g.length,b=a6(0,m),x=a6(m+1,m+1+y),w=l6([p,[d],g]),S=ve(h,w),C=ve(u,[d]),k=l6([[m],b,x]),A=rr(S,k);let M=Nz(A,C,c.shape[a]);const E=Mh(k);return M=rr(M,E),M};if(o===1){const c=r.shape[0],u=r.split(c,0);return{x:()=>xa(u.map((d,p)=>l(d,s.slice(p,1),n.slice(p,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,n),indices:()=>s}}};function a6(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function l6(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yet={kernelName:ty,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>lr(t),b:()=>lr(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zet={kernelName:ny,gradFunc:n=>({x:()=>wt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jet={kernelName:ry,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qet={kernelName:sy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ett={kernelName:iy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ttt={kernelName:qv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:s}=t,i=tl(r,0);return{x:()=>_o(i,n,fe(n,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ntt={kernelName:ay,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,qe(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rtt={kernelName:oy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,wt(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const stt={kernelName:lX,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;return{logits:()=>{const o=Yo(r);return Dt(n,fe(Yt(n,s,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function itt(n,e,t,r=5,s=1,i=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:r,bias:s,alpha:i,beta:o};return ue.runKernel(b2,a,l)}const ott=he({localResponseNormalizationBackprop_:itt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const att={kernelName:Qv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=t;return{x:()=>ott(r,s,n,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(n,e,t,r){return e.rank<t.rank&&(e=ve(e,Ls(e.shape,r))),n.rank<t.rank&&(n=ve(n,Ls(n.shape,r))),{x:()=>fe(n,wt(bu(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c6={kernelName:ew,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:s}=r,i=e[0],o=e[1],a=An(s,i.shape),l=Qte(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ltt={kernelName:ly,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,wt(Mp(t,r),"float32")),b:()=>fe(n,wt(k_(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ctt(n,e,t,r,s,i,o){const a=j(n,"dy","maxPool3dGrad"),l=j(e,"input","maxPool3dGrad"),c=j(t,"output","maxPool3dGrad");let u=a,h=l,f=c,d=!1;l.rank===4&&(d=!0,u=ve(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ve(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=ve(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),U(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),U(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),ta("maxPool3dGrad",i,o);const p={dy:u,input:h,output:f},m={filterSize:r,strides:s,pad:i,dimRoundingMode:o},g=ue.runKernel(w2,p,m);return d?ve(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const utt=he({maxPool3dGrad_:ctt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const htt={kernelName:nw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>utt(n,r,s,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ftt(n,e,t,r,s,i,o){const a=j(n,"dy","maxPoolGrad"),l=j(e,"input","maxPoolGrad"),c=j(t,"output","maxPoolGrad");U(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),U(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),U(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ta("maxPoolGrad",i,o);const u={dy:a,input:l,output:c},h={filterSize:r,strides:s,pad:i,dimRoundingMode:o};return ue.runKernel(v2,u,h)}const dtt=he({maxPoolGrad_:ftt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ptt={kernelName:tw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>dtt(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mtt={kernelName:rw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t,i=An(s,r.shape),a=Qs(r.shape,i)[1],l=Te(a);return{x:()=>{const u=r.shape.slice();i.forEach(d=>{u[d]=1});const h=ve(n,u);return Lt(fe(h,pa(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gtt={kernelName:sw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:s}=r,[i,o]=e,a=An(s,i.shape),l=Qte(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ytt={kernelName:cy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>fe(n,wt(Ry(t,r),"float32")),b:()=>fe(n,wt(tl(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const btt={kernelName:iw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>dn(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vtt={kernelName:uy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=ui(t.shape,s);return a.length>0?ve(Yt(n,a),t.shape):n},b:()=>{const a=fe(n,us(Y2(Lt(t,r)))),l=ui(r.shape,s);return l.length>0?ve(Yt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wtt={kernelName:hy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=fe(n,wt(r,"float32")),l=ui(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{const a=fe(n,wt(t,"float32")),l=ui(r.shape,s);return l.length>0?ve(Yt(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xtt={kernelName:ow,gradFunc:n=>({x:()=>us(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _tt={kernelName:cw,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>ms(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Stt={kernelName:lw,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ctt={kernelName:uw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return kc(n,r).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u6={kernelName:hw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>dn(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ktt={kernelName:fy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,s]=e,i=t,o=r,a=ln(i.shape,o.shape);return{a:()=>{const u=wt(o,"float32");let h=fe(n,fe(u,ip(i,Dt(u,en(1)))));const f=ui(i.shape,a);return f.length>0&&(h=Yt(h,f)),ve(h,i.shape)},b:()=>{const u=tl(i,0),h=_o(u,Al(i),lr(i));let f=fe(n,fe(s,h));const d=ui(o.shape,a);return d.length>0&&(f=Yt(f,d)),ve(f,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ttt={kernelName:fw,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,s=tl(t,0);return{x:()=>_o(s,n,fe(n,r)),alpha:()=>{let i=_o(s,lr(n),fe(n,t));const o=ui(r.shape,n.shape);return o.length>0&&(i=Yt(i,o)),ve(i,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ett(n,e,t){const r=n.shape.slice();r[t]=1;const s=ve(e,r),i=EI(n,t,!0,!1),o=EI(n,t,!0,!0),a=fe(i,o);return fe(s,a)}function Itt(n,e,t){const r=n.shape.length,s=r-t.length,i=Lr(t,r);let o=n;i!=null&&(o=rr(n,i));const a=o.shape.slice(),c=a.splice(r-t.length,t.length).reduce((f,d)=>f*d,1);a.push(c);const u=o.reshape(a);let h=Ett(u,e,s);if(h=h.reshape(o.shape),i!=null){const f=Mh(i);h=rr(h,f)}return h}const Att={kernelName:dw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;let i=[];return s==null?i=r.shape.map((o,a)=>a):typeof s=="number"?i=[s]:i=s,{x:()=>Itt(r,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mtt={kernelName:Xg,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{const a=Lt(n,wt(r,"float32")),l=ui(t.shape,s);return l.length>0?ve(Yt(a,l),t.shape):a},b:()=>{let a=fe(n,wt(t,"float32"));const l=ui(r.shape,s);l.length>0&&(a=ve(Yt(a,l),r.shape));const c=Or(r);return us(Lt(a,wt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ntt={kernelName:dy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,us(Or(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $tt={kernelName:my,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=fe(Ry(t,6),Mw(t));return{x:()=>fe(n,wt(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rtt={kernelName:py,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,wt(Mw(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ptt={kernelName:pw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ve(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dtt={kernelName:gw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>ue.runKernel(I2,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ott={kernelName:mw,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>ue.runKernel(E2,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ftt={kernelName:yw,gradFunc:(n,e,t)=>{const{dims:r}=t,s=An(r,n.shape);return{x:()=>Cc(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ltt={kernelName:gy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ztt={kernelName:yy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>us(Lt(n,fe(ip(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Btt={kernelName:bw,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>wt(lr(t),"float32"),t:()=>fe(n,wt(t,n.dtype)),e:()=>fe(n,wt(VM(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vtt={kernelName:by,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=tl(t,en(0)),s=en(cC),i=en(uC),o=fe(n,i),a=fe(fe(n,s),Yo(wt(t,"float32")));return _o(r,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Utt={kernelName:_y,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(t,Dt(en(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wtt={kernelName:xy,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gtt={kernelName:vy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(DM(wt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Htt={kernelName:wy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(sz(wt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jtt={kernelName:vw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:s,size:i}=t,o=r.shape,[a,l]=lC(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>vu(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qtt={kernelName:Sw,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:s}=t,i=!0,o=fe(n,r);return{logits:()=>Dt(o,fe(Yt(o,[s],i),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xtt={kernelName:Sy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,kl(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h6={kernelName:xw,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:s}=t;return{x:()=>PM(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f6={kernelName:_w,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>cs(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ktt={kernelName:Cy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,fe(So(wt(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ytt={kernelName:D2,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(n,fe(wt(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ztt={kernelName:ky,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=en(2);return{a:()=>fe(n,fe(s,Dt(t,r))),b:()=>fe(n,fe(s,Dt(r,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jtt={kernelName:My,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qtt={kernelName:Ty,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=ln(t.shape,r.shape);return{a:()=>{let a=n;const l=ui(t.shape,s);return l.length>0&&(a=Yt(a,l)),ve(a,t.shape)},b:()=>{let a=n;const l=ui(r.shape,s);return l.length>0&&(a=Yt(a,l)),ve(us(a),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ent={kernelName:ww,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,s=r.shape.slice(),{axis:i}=t;An(i,r.shape).forEach(c=>{s[c]=1});const a=ve(n,s),l=fe(a,pa(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tnt={kernelName:Ey,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Lt(n,Or(DM(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nnt={kernelName:Iy,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>fe(Dt(en(1),Or(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rnt={kernelName:Ay,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:s}=t;return{x:()=>{let o=lr(r);if(r.rank===1)for(let a=0;a<s[0];++a)o=qe(o,dn(n,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=qe(o,dn(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=qe(o,dn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=qe(o,dn(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const snt={kernelName:Vd,gradFunc:(n,e,t)=>{const r=t,{perm:s}=r,i=Mh(s);return{x:()=>rr(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const int={kernelName:Cw,gradFunc:(n,e,t)=>{const r=t,{axis:s}=r;return{value:()=>xa(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ont={kernelName:kw,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ant(n,t)}}};function ant(n,e){const t=Vf(e,lr(e)),r=Z2(n,t);let s=Mp(e,en(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=oi(s,a+1);s=wh(s,pa(r.shape,"bool"));const o=lr(r);return _o(s,r,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lnt={kernelName:Tw,gradFunc:n=>({x:()=>lr(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cnt=[Jte,set,iet,oet,aet,cet,uet,het,fet,det,pet,met,bet,xet,_et,Cet,ket,Tet,Eet,Iet,Aet,Met,$et,Net,Det,Oet,Fet,Let,zet,Bet,Mtt,Vet,Uet,Wet,Get,Het,qet,jet,Xet,Ket,Yet,Zet,Jet,Qet,ett,ttt,ntt,rtt,stt,att,c6,c6,ltt,htt,ptt,mtt,gtt,ytt,btt,vtt,wtt,xtt,_tt,Stt,Ctt,u6,u6,ktt,Ttt,Att,Ntt,$tt,Rtt,Ptt,Dtt,Ott,Ftt,Ltt,ztt,Btt,Vtt,Utt,Wtt,Gtt,Htt,jtt,qtt,Xtt,h6,h6,f6,f6,Ktt,Ztt,Ytt,Jtt,Qtt,ent,tnt,nnt,rnt,snt,int,ont,lnt];for(const n of cnt)cX(n);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function f4(n,e){return Se(()=>So(Yt(fe(n,n),e,!0)))}class EC extends Dy{getConfig(){return{}}}class ene extends EC{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=f4(e,this.axis),r=wa(t,0,this.maxValue);return fe(e,Lt(r,qe(ki(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}ene.className="MaxNorm";ot(ene);class tne extends EC{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>Lt(e,qe(ki(),f4(e,this.axis))))}getConfig(){return{axis:this.axis}}}tne.className="UnitNorm";ot(tne);class nne extends EC{apply(e){return Nh(e)}}nne.className="NonNeg";ot(nne);class rne extends EC{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Se(()=>{const t=f4(e,this.axis),r=qe(fe(this.rate,wa(t,this.minValue,this.maxValue)),fe(1-this.rate,t));return fe(e,Lt(r,qe(ki(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}rne.className="MinMaxNorm";ot(rne);const d6={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ii(n){return t4(n)}function p6(n,e={}){return _C(n,vl.getMap().classNameMap,e,"constraint")}function Ai(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in d6?d6[n]:n,config:{}};return p6(t)}else return n instanceof EC?n:p6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function sm(n){if(n==null)return;const e=[],t=[],r=[];for(const s in n){const i=n[s];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(s),r.push(o)}}if(e.length>0){const s=await Promise.all(e);for(let i=0;i<s.length;++i)n[t[i]]=s[i][0];nn(r)}}function sne(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var m6;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(m6||(m6={}));const unt=125;class q_{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class hnt{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class fnt extends q_{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const s in t){const i=t[s];if(typeof i=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+i*r;else{let o;s in this.totals?o=this.totals[s]:this.totals[s]=0;const a=Se(()=>qe(this.totals[s],fe(i,r)));this.totals[s]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:Se(()=>{const s=fe(Lt(1,this.seen),this.totals[r]);t[r]=s,this.totals[r].dispose(),Xs(t[r])}))}}class dnt extends q_{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(i),r.push(a)}}const s=await Promise.all(e);for(let i=0;i<s.length;++i)this.history[t[i]][r[i]].dispose(),this.history[t[i]][r[i]]=s[i][0]}}class pnt extends q_{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Kz,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=unt),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");wI(this.yieldEvery)&&(this.maybeWait=xQe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const s=[];this.yield!=null&&(await sm(r),s.push(this.yield(e,t,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await sm(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await sm(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await sm(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await sm(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):wI(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await sm(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await sm(e),await this.trainEnd(e))}}function ine(n,e){return n==null&&(n={}),n instanceof q_?[n]:Array.isArray(n)&&n[0]instanceof q_?n:Gr(n).map(r=>new pnt(r,e))}class nc{constructor(){}static registerCallbackConstructor(e,t){U(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),nc.checkForDuplicate(t),nc.constructors[e]==null&&(nc.constructors[e]=[]),nc.constructors[e].push(t)}static checkForDuplicate(e){for(const t in nc.constructors)nc.constructors[+t].forEach(s=>{if(s===e)throw new _e("Duplicate callback constructor.")})}static clear(){nc.constructors={}}static createCallbacks(e){const t=[];for(const r in nc.constructors){const s=+r;e>=s&&t.push(...nc.constructors[s])}return t.map(r=>new r)}}nc.constructors={};function one(n,e,t,r,s,i,o,a,l){const c=new dnt,u=[new fnt,...nc.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new hnt(u);return h.setParams({epochs:t,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gh(n,e={},t=!1){return _C(n,vl.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function nA(n,e){return Se(()=>{n.dtype!=="float32"&&(n=wt(n,"float32"));const t=Yt(CC(n),e,!0),r=$y(t.shape,ki()),s=So(Vf(t,r));return Lt(n,s)})}function a$(n,e){return Se(()=>Ds(CC(Dt(e,n)),-1))}function d4(n,e){return Se(()=>Ds(wi(Dt(e,n)),-1))}function p4(n,e){return Se(()=>{const t=Dt(n,e),r=wa(wi(n),ki(),Number.MAX_VALUE),s=wi(Lt(t,r));return fe(100,Ds(s,-1))})}function mnt(n,e){return Se(()=>{const t=wa(e,ki(),Number.MAX_VALUE),r=Al(qe(1,t)),s=wa(n,ki(),Number.MAX_VALUE),i=Al(qe(1,s));return Ds(CC(Dt(r,i)),-1)})}function gnt(n,e){return Se(()=>{const t=Vf(0,Dt(1,fe(n,e)));return Ds(CC(t),-1)})}function ynt(n,e){return Se(()=>{const t=Vf(0,Dt(1,fe(n,e)));return Ds(t,-1)})}function bnt(n,e){return Se(()=>{const t=Yt(fe(n,e),-1),r=bc(fe(Dt(1,n),e),-1);return Vf(0,qe(1,Dt(r,t)))})}function vnt(n,e){return Se(()=>{const t=Math.log(2),r=Dt(e,n),s=Dt(qe(r,Iw(fe(-2,r))),t);return Ds(s,-1)})}function X_(n,e,t=!1){return Se(()=>{if(t)e=nC(e);else{const r=Yt(e,e.shape.length-1,!0);e=Lt(e,r)}return e=wa(e,ki(),1-ki()),us(Yt(fe(wt(n,"float32"),Al(e)),e.shape.length-1))})}function rA(n,e,t=!1){return Se(()=>{const r=wt(Y2(RQe(n)),"int32");e=wa(e,ki(),1-ki());const s=e.shape,i=ve(Xb(r,s[s.length-1]),s);return X_(i,e,t)})}function wnt(n,e){if(!Rn(n.shape,e.shape))throw new _e(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return Se(()=>{const t=Nh(e),r=us(wi(e));return qe(Dt(t,fe(e,n)),LM(Yo(r)))})}function l$(n,e){return Se(()=>{let t;return t=wa(e,ki(),1-ki()),t=Al(Lt(t,Dt(1,t))),Ds(wnt(n,t),-1)})}function xnt(n,e){return Se(()=>{const t=wa(n,ki(),1),r=wa(e,ki(),1);return Yt(fe(n,Al(Lt(t,r))),-1)})}function _nt(n,e){return Se(()=>{const t=Al(qe(ki(),e));return Ds(Dt(e,fe(n,t)),-1)})}function ane(n,e){return Se(()=>{const t=nA(n,-1),r=nA(e,-1),s=fe(t,r);return us(Yt(s,-1))})}const sA={meanSquaredError:a$,meanAbsoluteError:d4,meanAbsolutePercentageError:p4,meanSquaredLogarithmicError:mnt,squaredHinge:gnt,hinge:ynt,categoricalHinge:bnt,logcosh:vnt,categoricalCrossentropy:X_,sparseCategoricalCrossentropy:rA,binaryCrossentropy:l$,kullbackLeiblerDivergence:xnt,poisson:_nt,cosineProximity:ane};function T3(n){if(typeof n=="string"){if(n in sA)return sA[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new _e(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lne(n,e){return Se(()=>{const t=fe(.5,Ml(e)),r=ph(tl(e,t),n.dtype);return Ds(bu(n,r),-1)})}function cne(n,e){return Se(()=>ph(bu(ig(n,-1),ig(e,-1)),"float32"))}function Snt(n,e){return Se(()=>wt(Yt(wh(bu(n,1),bu(e,1))),"float32"))}function Cnt(n,e){return Se(()=>wt(Yt(wh(bu(n,0),bu(e,1))),"float32"))}function knt(n,e){return Se(()=>{const t=Snt(n,e),r=Cnt(n,e),s=qe(t,r);return wt(_o(tl(s,0),Lt(t,s),0),"float32")})}function Tnt(n,e){return l$(n,e)}function Ent(n,e){return n.rank===e.rank&&(n=vr(n,[n.rank-1])),e=ig(e,-1),e.dtype!==n.dtype&&(e=wt(e,n.dtype)),wt(bu(n,e),"float32")}const Int=a$,Ant=a$,Mnt=d4,Nnt=d4,$nt=p4,Rnt=p4,une=X_,Pnt=ane,hne=rA,iA={binaryAccuracy:lne,categoricalAccuracy:cne,precision:knt,categoricalCrossentropy:une,sparseCategoricalCrossentropy:hne,mse:Int,MSE:Ant,mae:Mnt,MAE:Nnt,mape:$nt,MAPE:Rnt,cosine:Pnt};function Dnt(n){if(typeof n=="string"&&n in iA)return iA[n];if(typeof n!="string"&&n!=null)return n;throw new _e(`Unknown metric ${n}`)}function cT(n){if(ih(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(sA))if(sA[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(iA))if(iA[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ont(n){const e={Adagrad:()=>Sd.adagrad(.01),Adadelta:()=>Sd.adadelta(1,.95,ki()),Adam:()=>Sd.adam(.001,.9,.999,ki()),Adamax:()=>Sd.adamax(.002,.9,.999,ki(),0),RMSProp:()=>Sd.rmsprop(.001,.9,0,ki()),SGD:()=>Sd.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new _e(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const g6=1*1024*1024;function y6(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!GO(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>g6&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${g6}.`)}}function GO(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!GO(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!GO(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fnt(n,e,t,r=console.log){const s=znt(n),i=["Layer (type)","Input Shape","Output shape","Param #"];s?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(e)),oA(i,t,r),r("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)s?Bnt(a[u],t,r):Vnt(a[u],t,o,r),r((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Lnt(n),c=QI(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(e))}function Lnt(n){let e;return n.collectedTrainableWeights!=null?e=QI(n.collectedTrainableWeights):e=QI(n.trainableWeights),e}function znt(n){let e=!0;const t=[],r=[];for(const s in n.nodesByDepth)t.push(n.nodesByDepth[s]);for(const s of t){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(r.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function oA(n,e,t=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);t(r)}function Bnt(n,e,t){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,s,r,n.countParams().toString()];oA(a,e,t)}function Vnt(n,e,t,r){let s,i;try{i=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let f=0;f<h.inboundLayers.length;++f){const d=h.inboundLayers[f].name,p=h.nodeIndices[f],m=h.tensorIndices[f];o.push(`${d}[${p}][${m}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,i,s,n.countParams().toString(),c];oA(u,e,r);for(let h=1;h<o.length;++h)oA(["","","","",o[h]],e,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fne(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function aA(n,e){if(n===null)return null;if(typeof n=="string")return Dm(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];fne(e,s,i)?t.push(i):t.push(aA(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r];if(r==="name"&&typeof s=="string")t[r]=s;else{const i=Dm(r);t[i]=aA(s,i)}}return t}}function HO(n,e){if(n==null)return null;if(typeof n=="string")return gf(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];fne(e,s,i)?t.push(i):t.push(HO(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r],i=gf(r);(r==="name"||r==="className")&&typeof s=="string"?t[i]=s:t[i]=HO(s,r)}return t}}/** @license See the LICENSE file. */const dne="4.12.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Unt=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class tu extends Kn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=s$(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Wd(this.inputs).length!==this.inputs.length)throw new _e(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Wd(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.sourceLayer,w=b.nodeIndex,S=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(S)}for(const b of this.inputs){const x=b.sourceLayer,w=b.nodeIndex,S=b.tensorIndex;ih(w===0,"input layer has >1 nodes"),ih(S===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const x=this.inputLayers[b];if(!(x instanceof TC))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},r={},s={},i={},o={},a=[],l=(b,x,w,S,C,k)=>{(S==null||C==null||k==null)&&(S=b.sourceLayer,C=b.nodeIndex,k=b.tensorIndex);const A=S.inboundNodes[C];if(w.indexOf(A)!==-1)throw new pc(`The tensor ${b.name} at layer "${S.name}" is part of a cycle.`);if(x.indexOf(A)!==-1)return;this.containerNodes.add(tu.nodeKey(S,C)),S.id in o||(o[S.id]=Object.keys(o).length),w.indexOf(A)===-1&&w.push(A);const M=A.inboundLayers.length;for(let E=0;E<M;E++){const N=A.inputTensors[E],O=A.inboundLayers[E],R=A.nodeIndices[E],D=A.tensorIndices[E];l(N,x,w,O,R,D)}for(x.push(A);w.indexOf(A)>=0;)w.splice(w.indexOf(A),1);a.push(A)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const h=a.slice().reverse();for(const b of h){r[b.id]=b,b.id in t||(t[b.id]=0);let x=t[b.id];const w=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];x=Math.max(x,w),s[b.outboundLayer.id]=x,i[b.outboundLayer.id]=b.outboundLayer,t[b.id]=x;for(let S=0;S<b.inboundLayers.length;S++){const C=b.inboundLayers[S],k=b.nodeIndices[S],A=C.inboundNodes[k],M=t[A.id]==null?0:t[A.id];t[A.id]=Math.max(x+1,M),r[A.id]=A}}const f={};for(const b in t){const x=t[b];x in f||(f[x]=[]),f[x].push(r[b])}const d={};for(const b in s){const x=s[b];x in d||(d[x]=[]),d[x].push(i[b])}let p=Object.keys(d).map(b=>parseInt(b,10)).sort(oT);this.layers=[];for(const b of p){const x=d[b];x.sort((w,S)=>{const C=o[w.id],k=o[S.id];return C<k?-1:C>k?1:0});for(const w of x)w instanceof tu&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=d,p=Object.keys(f).map(b=>parseInt(b,10)).sort(oT);const m=this.inputs.slice(),g=[];for(const b of p)for(const x of f[b]){const w=x.outboundLayer;if(w!=null){for(const S of x.inputTensors)if(m.indexOf(S)===-1)throw new pc(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const S of x.outputTensors)m.push(S);g.push(w.name)}}this.nodesByDepth=f;const y=this.layers.map(b=>b.name);for(const b of y){const x=y.filter(w=>w===b).length;if(x!==1)throw new pc(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new o$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new _e("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let s=0;const i=Unt(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=i?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(r[u]!=null)throw new _e(`Duplicate weight name: ${u}`);r[u]=c,s++}const o=[];for(const a in e){let l=a;if(r[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[l]!=null)o.push([r[l],e[a]]);else if(t)throw new _e(`Provided weight data has no target variable: ${a}`);delete r[l]}if(t){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new _e(`${a.length} of ${s} weights are not set: ${a}`)}h4(o)}parseWeights(e){for(const t in Object.keys(e)){const r=t.split("/"),s=["vars","layer_checkpoint_dependencies"],i=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!s.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${dne}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=HO(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return Se(()=>{e=Gr(e);const r=new Rd;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return I1(this.outputs,r,t)})}computeMask(e,t){return Se(()=>{e=Gr(e);let r;return t==null?r=mg(null,e.length):r=Gr(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=JI(e);if(t.length!==this.inputLayers.length)throw new _e(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";r[u]=c}const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(oT);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(u.id)!==-1)continue;const h=[];for(let m=0;m<c.inboundLayers.length;m++){const g=c.inboundLayers[m],y=c.nodeIndices[m],b=c.tensorIndices[m],x=`${g.name}_${y}_${b}`,w=r[x];h.push(w)}const f=u.computeOutputShape(fa(h)),d=JI(f),p=u.inboundNodes.indexOf(c);for(let m=0;m<d.length;m++){const g=`${u.name}_${p}_${m}`;r[g]=d[m]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],h=`${l.name}_${c}_${u}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];ih(l in r),i.push(r[l])}return fa(i)}runInternalGraph(e,t){t==null&&(t=mg(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];r[c.id]=[u,h]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(oT);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,f=u.inputTensors,d=u.outputTensors,p=new Array;for(const m of f)m.id in r&&p.push(r[m.id]);if(p.length===f.length){let m={},g,y,b,x;if(u.callArgs!=null&&(m=u.callArgs),p.length===1){const[w,S]=p[0];m.mask==null&&(m.mask=S),b=Gr(h.call(w,m)),x=Gr(h.computeMask(w,S)),g=[w],y=[S]}else g=p.map(w=>w[0]),y=p.map(w=>w[1]),m.mask==null&&(m.mask=y),b=Gr(h.call(g,m)),x=Gr(h.computeMask(g,y));if(h.activityRegularizer)throw new Fn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<d.length;++w){const S=d[w],C=b[w],k=x[w];r[S.id]=[C,k]}}}}const i=[],o=[],a=[];for(const l of this.outputs){ih(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(e){const t={};let r;for(const s of this.layers){r=s instanceof tu?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=tu.nodeKey(s,i);this.containerNodes.has(o)&&(t[o]=r,r+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new _e("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new _e(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new _e(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Se(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const s=tu.nodeKey(t,r);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let h=0;h<o.inboundNodes.length;h++){const f=o.inboundNodes[h],d=tu.nodeKey(o,h);let p={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),p=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(f.inboundLayers.length>0){const m=[];for(let g=0;g<f.inboundLayers.length;g++){const y=f.inboundLayers[g],b=f.nodeIndices[g],x=f.tensorIndices[g],w=tu.nodeKey(y,b);let S=t[w];S==null&&(S=0),m.push([y.name,S,x,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}e.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=tu.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[o];s.push([a.name,u,h])}e.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=tu.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,u,h])}return e.outputLayers=i,e}static fromConfig(e,t,r={},s=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let x;for(const w of y){const S=w[0],C=w[1],k=w[2];if(x=w[3]==null?{}:w[3],!(S in i)){a(g,y);return}const A=i[S];if(A.inboundNodes.length<=C){a(g,y);return}const M=A.inboundNodes[C];b.push(M.outputTensors[k])}b.length>0&&g.apply(fa(b),x)}function c(g){const y=g.name,b=gh(g,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(s),i[y]=b,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new _e(`Corrupted configuration, expected array for nodeData: ${w}`);a(b,w)})}const u=t.name,h=t.layers;for(const g of h)c(g);for(;!wQe(o);)for(const g of h){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const x of b)l(y,x)}}const f=[],d=[],p=t.inputLayers;for(const g of p){const y=g[0],b=g[1],x=g[2];ih(y in i);const S=i[y].inboundNodes[b].outputTensors;f.push(S[x])}const m=t.outputLayers;for(const g of m){const y=g[0],b=g[1],x=g[2];ih(y in i);const S=i[y].inboundNodes[b].outputTensors;d.push(S[x])}return new e({inputs:f,outputs:d,name:u})}get stateful(){if(this._stateful)throw new _e("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Se(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Wnt(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const s=[];return e.forEach(i=>{i in n?s.push(n[i]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function pne(n,e){return Wnt(n,e,"classWeight")}async function mne(n,e,t,r){if(e!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const s=Se(()=>{if(n.shape.length===1)return dh(n);if(n.shape.length===2){if(n.shape[1]>1)return ig(n,1);if(n.shape[1]===1)return ve(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await s.data());nn(s);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),Ks(o,"float32")}else return null}function Gnt(n,e){return fe(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Hnt=32;function gne(n,e){let t,r;const s=e;t=s.xs,r=s.ys,U(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=b6("input",n.inputNames,t),o=b6("output",n.outputNames,r),a=i[0].shape[0];U(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),U(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)U(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)U(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function b6(n,e,t){if(t instanceof jn)return[t];if(Array.isArray(t))return U(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const s of e){if(t[s]==null)throw new _e(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(t[s])}return r}}function jnt(n){if(n.length===3)throw new Fn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function qnt(n,e,t){const r=t.batchesPerEpoch!=null;if(U(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),U(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),U(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),U(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),U(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=t.validationData!=null;let i,o;if(s)if(v6(t.validationData))U(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=jnt(t.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;s?c=l.slice().concat(l.map(g=>"val_"+g)):c=l.slice();const u=ine(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:f,history:d}=one(u,h,t.epochs,null,null,Xnt(e,t),null,s,c);f.setModel(n),n.history=d,await f.onTrainBegin(),n.stopTraining_=!1;let p=t.initialEpoch==null?0:t.initialEpoch,m=await e.iterator();for(;p<t.epochs;){const g={};await f.onEpochBegin(p);let y=0,b=0;for(r||(m=await e.iterator());!r||y<t.batchesPerEpoch;){const x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:w,ys:S}=gne(n,x.value),C={};C.batch=b,C.size=w[0].shape[0],await f.onBatchBegin(b,C);const k=[];if(t.classWeight!=null){const E=pne(t.classWeight,n.outputNames);for(let N=0;N<E.length;++N)k.push(await mne(S[N],null,E[N]))}const A=w.concat(S).concat(k),M=a(A);nn(A);for(let E=0;E<l.length;++E){const N=l[E],O=M[E];C[N]=O,Xs(O)}await f.onBatchEnd(b,C),sne(C),b++,y++}if(r?y>=t.batchesPerEpoch:x.done){if(s){let w;v6(t.validationData)?w=Gr(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):w=Gr(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?Hnt:t.validationBatchSize,verbose:0}));for(let S=0;S<n.metricsNames.length;++S)g[`val_${n.metricsNames[S]}`]=w[S]}break}if(n.stopTraining_)break}if(await f.onEpochEnd(p,g),p++,n.stopTraining_)break}return await f.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function Xnt(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function v6(n){return typeof n.iterator=="function"}function Knt(n){return typeof n.next=="function"}async function Ynt(n,e,t){t=t||{};const r=t.batches!=null,s=n.testFunction;let i=[];if(t.verbose>0)throw new Fn("Verbose mode is not implemented yet.");U(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=Knt(e)?e:await e.iterator();let a=0,l=0;for(;!r||l<t.batches;){const c=await o.next();if(i=Se(()=>{if(c.value){const{xs:u,ys:h}=gne(n,c.value),f=u.concat(h),d=Se(()=>s(f));if(nn(f),l===0)for(let m=0;m<d.length;++m)i.push(en(0));const p=f[0].shape[0];for(let m=0;m<d.length;++m){const g=d[m],y=i[m];i[m]=Se(()=>qe(i[m],fe(p,g))),l>0&&nn(y)}nn(d),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=Lt(i[c],a),nn(u)}return fa(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function E3(n){U(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function jx(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>Xm(r,e,t-e)):Xm(n,e,t-e)}function jO(n,e){return Se(()=>n==null?null:Array.isArray(n)?n.map(t=>jO(t,e)):Ute(n,e.dtype==="int32"?e:wt(e,"int32")))}function I3(n,e){const t=[];let r=0,s=null;for(;r<n;)s=r+e,s>=n&&(s=n),t.push([r,s]),r=s;return t}function yne(n){const e=[];n instanceof jn&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(SC(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function qc(n,e){if(n==null)return;const t=[];if(e instanceof jn)t.push(e.id);else if(Array.isArray(e))e.forEach(s=>t.push(s.id));else if(e!=null)for(const s in e){const i=e[s];t.push(i.id)}const r=[];if(n instanceof jn)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{t.indexOf(s.id)===-1&&r.push(s)});else if(n!=null)for(const s in n){const i=n[s];t.indexOf(i.id)===-1&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Znt(n){return n instanceof jn}function qO(n){return Array.isArray(n)}function w6(n){return!Znt(n)&&!qO(n)}function x6(n,e,t,r=!0,s=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(qO(n)&&n.length>0)o=!0;else if(w6(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new _e(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(w6(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new _e(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if(qO(n)){if(n=n,n.length!==e.length)throw new _e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new _e(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=yne(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new _e(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new _e(`${s} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function Jnt(n,e,t){const r=Wd(n.map(i=>i.shape[0]));r.sort();const s=Wd(e.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new _e(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new _e(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!Rn(r,s))throw new _e(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function Qnt(n,e,t){const r=[a$,l$,X_];for(let s=0;s<n.length;++s){const i=n[s],o=e[s],a=t[s];if(o!=null){if(o===X_&&i.shape[i.shape.length-1]===1)throw new _e(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const h=l[u],f=c[u];if(f!=null&&h!==f)throw new _e(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function _6(n,e,t,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new _e(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new _e(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new _e(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new _e(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function ert(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const s of e){let i=t.hasOwnProperty(s)?t[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}const trt="layers-model";class Hd extends tu{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new _e("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");Fnt(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Ont(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Wf))throw new _e("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new _e(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(T3(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new _e(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>T3(a))}else{const o=T3(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],qm("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const s=ert(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};qm("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=s[o];(c=>{const u="";let h,f,d;for(const p of c){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const g=this.internalOutputShapes[o];g[g.length-1]===1||this.lossFunctions[o]===l$?["accuracy","acc"].indexOf(p)!==-1?f=lne:["crossentropy","ce"].indexOf(p)!==-1&&(f=Tnt):this.lossFunctions[o]===rA?["accuracy","acc"].indexOf(p)!==-1?f=Ent:["crossentropy","ce"].indexOf(p)!==-1&&(f=hne):["accuracy","acc"].indexOf(p)!==-1?f=cne:["crossentropy","ce"].indexOf(p)!==-1&&(f=une);let y;["accuracy","acc"].indexOf(p)!==-1?y="acc":["crossentropy","ce"].indexOf(p)!==-1&&(y="ce"),d=f,h=u+y}else d=Dnt(p),h=u+cT(p);let m;qm(h,()=>{m=d}),i(o,h,m)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const s=r.batchSize==null?32:r.batchSize;E3(s);const i=!0,o=this.standardizeUserDataXY(e,t,i,s);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,s,r.verbose,r.steps);return fa(c)}finally{qc(o[0],e),qc(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Ynt(this,e,t)}checkNumSamples(e,t,r,s="steps"){let i;if(r!=null){if(i=null,t!=null)throw new _e(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new _e(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new _e("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),s=r?t:[t],i=this.retrieveSymbolicTensors(s),o=new Rd;if(e instanceof jn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new _e(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new _e(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=I1(i,o);return r?a:a[0]}retrieveSymbolicTensors(e){const t=mg(null,e.length);let r=e.length;for(const s of this.layers){const i=Array.isArray(s.output)?s.output:[s.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=i[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw t.forEach((i,o)=>{i==null&&s.push(e[o])}),new _e(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return t}predictLoop(e,t=32,r=!1){return Se(()=>{const s=this.checkNumSamples(e);if(r)throw new Fn("Verbose predictLoop() is not implemented yet.");const i=I3(s,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)Se(()=>{const c=i[a][0],u=i[a][1],h=jx(e,c,u),f=[];if(Array.isArray(h))for(let p=0;p<h.length;++p)f.push({key:this.inputs[p],value:h[p]});else f.push({key:this.inputs[0],value:h});const d=new Rd(f);return I1(this.outputs,d)}).forEach((c,u)=>o[u].push(c));return fa(o.map(a=>cs(a,0)))})}predict(e,t={}){const r=yne(e);_6(r,this.inputNames,this.feedInputShapes,!1);try{const s=t.batchSize==null?32:t.batchSize;return E3(s),this.predictLoop(r,s)}finally{qc(r,e)}}predictOnBatch(e){_6(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,s){if(this.optimizer_==null)throw new pc("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===rA?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=x6(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=x6(t,this.feedOutputNames,i,!1,"target"),Jnt(e,t),Qnt(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new _e(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,s,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,i,o);if(r!=null)throw new Error("sample weight is not supported yet.");let c=null;if(s!=null){const u=pne(s,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await mne(l[h],null,u[h]))}return[a,l,c]}testLoop(e,t,r,s=0,i){return Se(()=>{const o=this.checkNumSamples(t,r,i,"steps"),a=[];if(s>0)throw new Fn("Verbose mode is not implemented yet.");if(i!=null)throw new Fn("steps mode in testLoop() is not implemented yet");{const l=I3(o,r),c=Ks(Su(0,o));for(let u=0;u<l.length;++u){const h=l[u][0],f=l[u][1],d=Xm(c,h,f-h),p=jO(t,d),m=e(p);if(u===0)for(let g=0;g<m.length;++g)a.push(en(0));for(let g=0;g<m.length;++g){const y=m[g];a[g]=qe(a[g],fe(f-h,y))}}for(let u=0;u<a.length;++u)a[u]=Lt(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const s=e[r];let i=s;if(e6(e,s)>1){const o=e6(e.slice(0,r),s);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const f=new Rd(h),d=I1(this.outputs,f,{training:!0});let p;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(s[m],d[m]);i[m]!=null&&(y=Gnt(y,i[m]));const b=Ds(y);t.push(b),m===0?p=y:p=qe(p,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Ds(y(s[b],d[b]))}Xs(g),o.push(g)}return p=Ds(p),this.calculateLosses().forEach(m=>{p=qe(p,m)}),p},l=this.collectedTrainableWeights.map(h=>h.read()),c=!0;return[this.optimizer_.minimize(a,c,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>Se(()=>{const t=[];let r;const s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:s[c]});const a=new Rd(o),l=I1(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=Ds(u(i[c],l[c]));c===0?r=h:r=qe(r,h),t.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],f=Ds(u(i[h],l[h]));t.push(f)}return t})}async fit(e,t,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,i,o,a,l,c,u,h,f;try{const d=r.batchSize==null?32:r.batchSize;E3(d);const p=!1,m=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,p,d);s=m[0],i=m[1],f=m[2];let g=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)l=r.validationData[0],c=r.validationData[1];else throw r.validationData.length===3?new Fn("validationData including sample weights is not supported yet."):new _e(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const M=!0,E=await this.standardizeUserData(l,c,null,null,M,d);u=E[0],h=E[1],y=u.concat(h)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const M=Math.floor(s[0].shape[0]*(1-r.validationSplit)),E=s[0].shape[0];u=jx(s,M,E),o=s,s=jx(s,0,M),h=jx(i,M,E),a=i,i=jx(i,0,M),y=u.concat(h)}else r.validationSteps!=null&&(g=!0);const b=s.concat(i).concat(f);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();let S,C;g?(this.makeTestFunction(),S=this.testFunction,C=w.slice().concat(w.map(M=>"val_"+M))):(S=null,y=[],C=w.slice());const k=ine(r.callbacks,r.yieldEvery);return await this.fitLoop(x,b,w,d,r.epochs,r.verbose,k,S,y,r.shuffle,C,r.initialEpoch,null,null)}finally{this.isTraining=!1,qc(s,e),qc(i,t),qc(o,e),qc(a,t),qc(u,l),qc(h,c),f!=null&&nn(f)}}async fitLoop(e,t,r,s,i,o,a,l,c,u,h,f,d,p){s==null&&(s=32),i==null&&(i=1),u==null&&(u=!0),f==null&&(f=0);let m=!1;if(l!=null&&c!=null&&(m=!0),p!=null&&(m=!0,d==null))throw new _e("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,s,d,"steps_per_epoch");let y;g!=null&&(y=Su(0,g)),o==null&&(o=1);const{callbackList:b,history:x}=one(a,o,i,f,g,d,s,m,h);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let w=f;w<i;++w){await b.onEpochBegin(w);const S={};if(d!=null)throw new Fn("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Fn("batch shuffling is not implemneted yet");u&&_L(y);const C=Ks(y),k=I3(g,s);for(let A=0;A<k.length;++A){const M={};if(await b.onBatchBegin(A,M),Se(()=>{const E=k[A][0],N=k[A][1],O=Xm(C,E,N-E);M.batch=A,M.size=N-E;const R=jO(t,O),D=e(R);for(let z=0;z<r.length;++z){const B=r[z],X=D[z];M[B]=X,Xs(X)}if(A===k.length-1&&m){const z=this.testLoop(l,c,s);for(let B=0;B<r.length;++B){const X=r[B],G=z[B];Xs(G),S["val_"+X]=G}}}),await b.onBatchEnd(A,M),sne(M),this.stopTraining_)break}C.dispose()}if(await b.onEpochEnd(w,S),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return qnt(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),s=r[0],i=r[1],a=this.makeTrainFunction()(s.concat(i)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return nn(a),qc(r[0],e),qc(r[1],t),fa(l)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,i=this.getWeights(r);for(let o=0;o<s.length;++o)r&&!s[o].trainable||t.push({name:s[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=kI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-kI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=gf(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>gf(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const s of t)if(typeof r[s]=="string")e[s]=gf(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[gf(cT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>gf(cT(e)));{const e={};for(const t in this.metrics)e[t]=gf(cT(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=aA(e.optimizer_config),r=gh(t);let s;if(typeof e.loss=="string")s=Dm(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(o=>Dm(o));else if(e.loss!=null){s={};for(const o in e.loss)s[o]=Dm(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>Dm(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=Dm(e.metrics[o])}this.compile({loss:s,metrics:i,optimizer:r})}async save(e,t){if(typeof e=="string"){const c=AX(e);if(c.length===0)throw new _e(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new _e(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new _e("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await yD(this.getNamedWeights(t)),s=!1,i=null,a={modelTopology:this.toJSON(i,s),format:trt,generatedBy:`TensorFlow.js tfjs-layers v${dne}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:h}=await yD(await this.optimizer.getWeights(),c);r.specs.push(...h),r.data=EX([r.data,u])}return this.userDefinedMetadata!=null&&(y6(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){y6(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Hd.className="Model";ot(Hd);class bne extends Hd{}bne.className="Functional";ot(bne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function K_(n,e){if(e==null&&(e={}),typeof n=="string"){const t=MX(n,e);if(t.length===0)t.push(CY(n,e));else if(t.length>1)throw new _e(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return nrt(n,void 0,e)}async function nrt(n,e,t){if(t==null&&(t={}),n.load==null)throw new _e("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await n.load();let s=r.modelTopology;s.model_config!=null&&(s=s.model_config);const i=t.strict==null?!0:t.strict,o=r.weightData!=null&&r.weightSpecs!=null&&i,a=gh(aA(s),e,o),l=r.trainingConfig;if(l!=null&&a.loadTrainingConfig(l),r.userDefinedMetadata!=null&&a.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new _e("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=rrt(r.weightData,r.weightSpecs);a.loadWeights(c,i),a.optimizer!=null&&u.length>0&&await a.optimizer.setWeights(u),nn(c),nn(u.map(h=>h.tensor))}return a}function rrt(n,e){const t=RL(n,e),r={},s=[];return e.forEach(i=>{i.group==="optimizer"?s.push({name:i.name,tensor:t[i.name]}):r[i.name]=t[i.name]}),{modelWeights:r,optimizerWeights:s}}class iv extends Hd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:s$("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new _e(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof iv||e instanceof Hd;let r;if(t){if(r=e,r.outputs.length!==1)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new _e("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new _e("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=ZQe({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new _e(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new _e("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Zte(this.outputs[0])}this.inboundNodes=[],new o$({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:mg(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(wr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Hd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new pc("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new pc("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new pc("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new pc("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},s=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new _e("Legacy serialization format not supported yet.");i=t}else U(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof iv))throw new Fn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const u=gh(l,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new _e("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new _e("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}iv.className="Sequential";ot(iv);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function srt(n){return new iv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ea=class extends Dy{getConfig(){return{}}};class vne extends Ea{apply(e,t=1){return DQe(e,t)}}vne.className="elu";ot(vne);class wne extends Ea{apply(e){return Sz(e)}}wne.className="selu";ot(wne);class xne extends Ea{apply(e){return Nh(e)}}xne.className="relu";ot(xne);class _ne extends Ea{apply(e){return Se(()=>op(6,Nh(e)))}}_ne.className="relu6";ot(_ne);class Sne extends Ea{apply(e){return e}}Sne.className="linear";ot(Sne);class Cne extends Ea{apply(e){return kl(e)}}Cne.className="sigmoid";ot(Cne);class kne extends Ea{apply(e){return FQe(e)}}kne.className="hardSigmoid";ot(kne);class Tne extends Ea{apply(e){return Iw(e)}}Tne.className="softplus";ot(Tne);class Ene extends Ea{apply(e){return OQe(e)}}Ene.className="softsign";ot(Ene);class Ine extends Ea{apply(e){return jb(e)}}Ine.className="tanh";ot(Ine);let m4=class extends Ea{apply(e,t=-1){return nC(e,t)}};m4.className="softmax";ot(m4);class Ane extends Ea{apply(e,t=-1){return az(e,t)}}Ane.className="logSoftmax";ot(Ane);class Mne extends Ea{apply(e,t=1){return Se(()=>fe(kl(fe(e,t)),e))}}Mne.className="swish";ot(Mne);class Nne extends Ea{apply(e){return Se(()=>fe(e,jb(Iw(e))))}}Nne.className="mish";ot(Nne);function up(n){return n.getClassName()}function A3(n,e={}){return _C(n,vl.getMap().classNameMap,e,"activation")}function hp(n){if(n==null){const e={};return e.className="linear",e.config={},A3(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},A3(e)}else return n instanceof Ea?n:A3(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function irt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class $ne extends Dy{}class Rne extends $ne{constructor(e){super(),irt(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Se(()=>{let t=ms([1]);return this.hasL1&&(t=qe(t,Yt(fe(this.l1,wi(e))))),this.hasL2&&(t=qe(t,Yt(fe(this.l2,CC(e))))),ve(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Rne.className="L1L2";ot(Rne);const S6={l1l2:"L1L2"};function jr(n){return t4(n)}function C6(n,e={}){return _C(n,vl.getMap().classNameMap,e,"regularizer")}function vs(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in S6?S6[n]:n,config:{}};return C6(t)}else return n instanceof $ne?n:C6(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Pne extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=vn(e);let r=Nh(e);return this.maxValue!=null&&(r=wa(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Pne.className="ReLU";ot(Pne);class Dne extends Kn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=vn(e);return FM(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Dne.className="LeakyReLU";ot(Dne);class One extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ys(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vs(e.alphaRegularizer),this.alphaConstraint=Ai(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new _e(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=wr(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new Ti({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=vn(e),HM(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Cs(this.alphaInitializer),alphaRegularizer:jr(this.alphaRegularizer),alphaConstraint:Ii(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}One.className="PReLU";ot(One);class Fne extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Fn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=vn(e);return K2(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Fne.className="ELU";ot(Fne);class Lne extends Kn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=vn(e);return fe(r,wt(tl(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Lne.className="ThresholdedReLU";ot(Lne);class zne extends Kn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new m4().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return Se(()=>{let r=vn(e);const s=t.mask;if(s!=null){const i=fe(Dt(pa(r.shape),wt(s,r.dtype)),en(-1e9));r=qe(r,i)}return this.axis instanceof Array?this.axis.length>1?Yo(Dt(r,BM(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}zne.className="Softmax";ot(zne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Nb(n,e,t){if(typeof n=="number")return mg(n,e);if(n.length!==e)throw new _e(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const s=n[r];if(!NQe(s))throw new _e(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function yu(n,e,t,r,s=1){if(n==null)return n;const i=e+(e-1)*(s-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+r-1)/r)}function oh(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+cp([t-e,0]);else if(r==="same")n=n*e;else throw new _e(`Unsupport padding mode: ${r}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function g4(n,e){return Se(()=>(ti(e),e==="channelsFirst"?rr(n,[0,2,3,1]):n))}function Bne(n,e){return Se(()=>(ti(e),e==="channelsFirst"?rr(n,[0,2,3,4,1]):n))}function art(n,e,t,r=1,s="valid",i,o=1){return Se(()=>{if(i==null&&(i=Cu()),ti(i),n.shape.length!==3)throw new _e(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new _e(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new _e(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=rr(n,[0,2,1])),s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=QL(n,e,r,s==="same"?"same":"valid","NWC",o);return t!=null&&(a=Vu(a,t)),a})}function k6(n,e,t,r=[1,1],s="valid",i,o,a=null){return Se(()=>{if(i==null&&(i=Cu()),ti(i),n.rank!==3&&n.rank!==4)throw new _e(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new _e(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=g4(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=cY({x:l,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(l=rr(l,[0,3,1,2])),l})}function lrt(n,e,t,r=[1,1,1],s="valid",i,o){return Se(()=>{if(i==null&&(i=Cu()),ti(i),n.rank!==4&&n.rank!==5)throw new _e(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new _e(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Bne(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=nz(a,e,r,s==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Vu(a,t)),i==="channelsFirst"&&(a=rr(a,[0,4,1,2,3])),a})}class c$ extends Kn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",c$.verifyArgs(t),this.rank=e,Wi(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Fn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Nb(t.kernelSize,e,"kernelSize"),this.strides=Nb(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Ll(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ti(this.dataFormat),this.activation=hp(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=ys(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ai(t.biasConstraint),this.biasRegularizer=vs(t.biasRegularizer),this.activityRegularizer=vs(t.activityRegularizer),this.dilationRate=Nb(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new _e(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new _e(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new _e(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ih("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!n4(e.kernelSize,"number",1,3))throw new _e(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:up(this.activation),useBias:this.useBias,biasInitializer:Cs(this.biasInitializer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),biasConstraint:Ii(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Zw extends c${constructor(e,t){super(e,t),this.kernel=null,Zw.verifyArgs(t),this.filters=t.filters,Wi(this.filters,"filters"),this.kernelInitializer=ys(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ai(t.kernelConstraint),this.kernelRegularizer=vs(t.kernelRegularizer)}build(e){e=wr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return Se(()=>{e=vn(e);let r;const s=this.bias==null?null:this.bias.read(),i=Ote(this.activation.getClassName());if(i!=null&&this.rank===2)r=k6(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)r=art(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=k6(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=lrt(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Fn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=wr(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<r.length;++i){const o=yu(r[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:Cs(this.kernelInitializer),kernelRegularizer:jr(this.kernelRegularizer),kernelConstraint:Ii(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new _e(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class IC extends Zw{constructor(e){super(2,e),IC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!n4(e.kernelSize,"number",1,2))throw new _e(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}IC.className="Conv2D";ot(IC);class AC extends Zw{constructor(e){super(3,e),AC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new _e(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}AC.className="Conv3D";ot(AC);class Vne extends IC{constructor(e){if(super(e),this.inputSpec=[new Ti({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new _e(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wr(e),e.length!==4)throw new _e("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ti({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=vn(e);if(r.shape.length!==4)throw new _e(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=s[o],c=s[a],u=this.kernelSize[0],h=this.kernelSize[1],f=this.strides[0],d=this.strides[1],p=oh(l,f,u,this.padding),m=oh(c,d,h,this.padding),g=[i,p,m,this.filters];this.dataFormat!=="channelsLast"&&(r=rr(r,[0,2,3,1]));let y=tz(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=rr(y,[0,3,1,2])),this.bias!=null&&(y=Vu(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=wr(e);const t=e.slice();let r,s,i;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3):(r=3,s=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[r]=this.filters,t[s]=oh(t[s],l,o,this.padding),t[i]=oh(t[i],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Vne.className="Conv2DTranspose";ot(Vne);class Une extends AC{constructor(e){if(super(e),this.inputSpec=[new Ti({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new _e(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=wr(e),e.length!==5)throw new _e("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _e("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ti({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{let r=vn(e);if(r.shape.length!==5)throw new _e(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=s[l],u=s[o],h=s[a],f=this.kernelSize[0],d=this.kernelSize[1],p=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=oh(c,m,f,this.padding),x=oh(u,g,d,this.padding),w=oh(h,y,p,this.padding),S=[i,b,x,w,this.filters];this.dataFormat!=="channelsLast"&&(r=rr(r,[0,2,3,4,1]));let C=rz(r,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(C=rr(C,[0,4,1,2,3])),this.bias!==null&&(C=Vu(C,this.bias.read(),this.dataFormat)),this.activation!==null&&(C=this.activation.apply(C)),C})}computeOutputShape(e){e=wr(e);const t=e.slice();let r,s,i,o;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3,o=4):(r=4,s=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],f=this.strides[2];return t[r]=this.filters,t[s]=oh(t[s],u,a,this.padding),t[i]=oh(t[i],h,l,this.padding),t[o]=oh(t[o],f,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Une.className="Conv3DTranspose";ot(Une);class Wne extends Zw{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new _e("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new _e("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new _e(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ys(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vs(t.depthwiseRegularizer),this.depthwiseConstraint=Ai(t.depthwiseConstraint),this.pointwiseInitializer=ys(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vs(t.pointwiseRegularizer),this.pointwiseConstraint=Ai(t.pointwiseConstraint)}build(e){if(e=wr(e),e.length<this.rank+2)throw new _e(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new _e(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],s=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Ti({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return Se(()=>{e=vn(e);let r;if(this.rank===1)throw new Fn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=rr(e,[0,2,3,1])),r=Cz(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Vu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=rr(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Cs(this.depthwiseInitializer),e.pointwiseInitializer=Cs(this.pointwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.pointwiseRegularizer=jr(this.pointwiseRegularizer),e.depthwiseConstraint=Ii(this.depthwiseConstraint),e.pointwiseConstraint=Ii(this.pointwiseConstraint),e}}Wne.className="SeparableConv";class Gne extends Wne{constructor(e){super(2,e)}}Gne.className="SeparableConv2D";ot(Gne);class u$ extends Zw{constructor(e){super(1,e),u$.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!n4(e.kernelSize,"number",1,1))throw new _e(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}u$.className="Conv1D";ot(u$);class Hne extends Kn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Se(()=>{if(e=vn(e),this.dataFormat==="channelsLast"){const r=lT(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return lT(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=lT(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return lT(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Hne.className="Cropping2D";ot(Hne);class jne extends Kn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,IQe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return Se(()=>{let r=vn(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=rr(r,[0,2,3,1]);const i=this.size[0]*s[2],o=this.size[1]*s[3],a=this.interpolation==="nearest"?Ci.resizeNearestNeighbor(r,[i,o]):Ci.resizeBilinear(r,[i,o]);return rr(a,[0,3,1,2])}else{const i=this.size[0]*s[1],o=this.size[1]*s[2];return this.interpolation==="nearest"?Ci.resizeNearestNeighbor(r,[i,o]):Ci.resizeBilinear(r,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}jne.className="UpSampling2D";ot(jne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function crt(n,e,t=[1,1],r="valid",s,i){return Se(()=>{s==null&&(s=Cu()),ti(s);let o=g4(n,s);if(n.rank!==4)throw new _e(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new _e(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=X2(o,e,t,r==="same"?"same":"valid","NHWC",i),s==="channelsFirst"&&(o=rr(o,[0,3,1,2])),o})}class qne extends c${constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ys(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ai(e.depthwiseConstraint),this.depthwiseRegularizer=vs(e.depthwiseRegularizer)}build(e){if(e=wr(e),e.length<4)throw new _e(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new _e(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{e=vn(e);let r=crt(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Vu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=wr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=yu(t,this.kernelSize[0],this.padding,this.strides[0]),o=yu(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,o]:[e[0],i,o,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Cs(this.depthwiseInitializer),e.depthwiseRegularizer=jr(this.depthwiseRegularizer),e.depthwiseConstraint=Ii(this.depthwiseRegularizer),e}}qne.className="DepthwiseConv2D";ot(qne);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Xne(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new _e("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function s(i){return i==null||Array.isArray(i)?i:[i]}return e=s(e),t=s(t),{inputs:n,initialState:e,constants:t}}function Kne(n,e,t,r=!1,s,i,o=!1,a=!1){return Se(()=>{const l=e.shape.length;if(l<3)throw new _e(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Su(2,l));if(e=rr(e,c),i!=null)throw new Fn("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=wt(wt(s,"bool"),"float32"),s.rank===l-1&&(s=oi(s,-1)),s=rr(s,c)),r&&(e=Cc(e,0),s!=null&&(s=Cc(s,0)));const u=[];let h,f=t;const d=e.shape[0],p=kc(e);let m;s!=null&&(m=kc(s));for(let y=0;y<d;++y){const b=p[y],x=Se(()=>n(b,f));if(s==null)h=x[0],f=x[1];else{const w=Se(()=>{const S=m[y],C=Dt(Ml(S),S),k=qe(fe(x[0],S),fe(f[0],C)),A=f.map((M,E)=>qe(fe(x[1][E],S),fe(M,C)));return{output:k,newStates:A}});h=w.output,f=w.newStates}a&&u.push(h)}let g;return a&&(g=xa(u,1)),[h,g,f]})}class Fp extends Kn{constructor(e){super(e);let t;if(e.cell==null)throw new _e("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new v4({cells:e.cell}):t=e.cell,t.stateSize==null)throw new _e("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ti({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Su(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){UO(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let s;if(this.returnSequences?s=[e[0],e[1],r]:s=[e[0],r],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[s].concat(i)}else return s}computeMask(e,t){return Se(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const s=this.states.map(i=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Fn("Constants support is not implemented in RNN yet.");UO(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Ti({shape:[t,null,...r]});const s=[e[0]].concat(e.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!Rn(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new _e(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new Ti({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new sh("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ms([r,s])):this.states_=[ms([r,this.cell.stateSize])];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>ms([r,s])):this.states_[0]=ms([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let s=0;s<this.states_.length;++s){const i=e[s],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,a=[r,o];if(!Rn(i.shape,a))throw new _e(`State ${s} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Xs(s.clone()))})}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=Xne(e,r,s,this.numConstants);e=i.inputs,r=i.initialState,s=i.constants;let o=[],a=[];if(r!=null){t.initialState=r,o=o.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new Ti({shape:c.shape}));a=a.concat(this.stateSpec)}if(s!=null&&(t.constants=s,o=o.concat(s),this.numConstants=s.length),o[0]instanceof Sh){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t==null?null:t.mask,s=t==null?null:t.training;let i=t==null?null:t.initialState;e=vn(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new _e(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},c=Kne((p,m)=>{const g=this.cell.call([p].concat(m),a);return[g[0],g.slice(1)]},e,i,this.goBackwards,r,null,this.unroll,this.returnSequences),u=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,s);const d=this.returnSequences?h:u;return this.returnState?[d].concat(f):d})}getInitialState(e){return Se(()=>{let t=ms(e.shape);return t=Yt(t,[1,2]),t=SC(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?BO(t,[1,r]):t):this.cell.stateSize>1?[BO(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===Fp.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){const s=t.cell,i=gh(s,r);return new e(Object.assign(t,{cell:i}))}}Fp.className="RNN";ot(Fp);class h$ extends Kn{}class y4 extends h${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Wi(this.units,"units"),this.activation=hp(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vs(e.kernelRegularizer),this.recurrentRegularizer=vs(e.recurrentRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.kernelConstraint=Ai(e.kernelConstraint),this.recurrentConstraint=Ai(e.recurrentConstraint),this.biasConstraint=Ai(e.biasConstraint),this.dropout=sv([1,cp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=sv([1,cp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new _e(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fp({ones:()=>Ml(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fp({ones:()=>Ml(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=mh(fe(e,o),this.kernel.read()):i=mh(e,this.kernel.read()),this.bias!=null&&(i=Vu(i,this.bias.read())),a!=null&&(r=fe(r,a));let l=qe(i,mh(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:up(this.activation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),recurrentInitializer:Cs(this.recurrentInitializer),biasInitializer:Cs(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),recurrentConstraint:Ii(this.recurrentConstraint),biasConstraint:Ii(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}y4.className="SimpleRNNCell";ot(y4);class Yne extends Fp{constructor(e){e.cell=new y4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return new e(t)}}Yne.className="SimpleRNN";ot(Yne);class b4 extends h${constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new _e("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Wi(this.units,"units"),this.activation=hp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=hp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vs(e.kernelRegularizer),this.recurrentRegularizer=vs(e.recurrentRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.kernelConstraint=Ai(e.kernelConstraint),this.recurrentConstraint=Ai(e.recurrentConstraint),this.biasConstraint=Ai(e.biasConstraint),this.dropout=sv([1,cp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=sv([1,cp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=wr(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Se(()=>{if(e=e,e.length!==2)throw new _e(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fp({ones:()=>Ml(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fp({ones:()=>Ml(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=fe(e,i[0]));let u=mh(e,this.kernel.read());this.useBias&&(u=Vu(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,o[0]));const h=this.recurrentKernel.read(),[f,d]=ja(h,[2*this.units,this.units],h.rank-1),p=mh(s,f),[m,g,y]=ja(u,3,u.rank-1),[b,x]=ja(p,2,p.rank-1);a=this.recurrentActivation.apply(qe(m,b)),l=this.recurrentActivation.apply(qe(g,x));const w=mh(fe(l,s),d);c=this.activation.apply(qe(y,w));const S=qe(fe(a,s),fe(qe(1,us(a)),c));return[S,S]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:up(this.activation),recurrentActivation:up(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),recurrentInitializer:Cs(this.recurrentInitializer),biasInitializer:Cs(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),recurrentConstraint:Ii(this.recurrentConstraint),biasConstraint:Ii(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}b4.className="GRUCell";ot(b4);class Zne extends Fp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new b4(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Zne.className="GRU";ot(Zne);class f$ extends h${constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Wi(this.units,"units"),this.activation=hp(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=hp(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ys(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=vs(e.kernelRegularizer),this.recurrentRegularizer=vs(e.recurrentRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.kernelConstraint=Ai(e.kernelConstraint),this.recurrentConstraint=Ai(e.recurrentConstraint),this.biasConstraint=Ai(e.biasConstraint),this.dropout=sv([1,cp([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=sv([1,cp([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=wr(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;s=new(t=class extends Rc{apply(l,c){const u=i.apply([o]),h=new s4().apply([o]),f=i.apply([o*2]);return n6(n6(u,h),f)}},t.className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new _e(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fp({ones:()=>Ml(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fp({ones:()=>Ml(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=fe(e,o[0]));let f=mh(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=fe(s,a[0])),f=qe(f,mh(s,this.recurrentKernel.read())),this.useBias&&(f=Vu(f,this.bias.read()));const[d,p,m,g]=ja(f,4,f.rank-1);l=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),u=qe(fe(c,i),fe(l,this.activation.apply(m))),h=this.recurrentActivation.apply(g);const y=fe(h,this.activation.apply(u));return[y,y,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:up(this.activation),recurrentActivation:up(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),recurrentInitializer:Cs(this.recurrentInitializer),biasInitializer:Cs(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:jr(this.kernelRegularizer),recurrentRegularizer:jr(this.recurrentRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),recurrentConstraint:Ii(this.recurrentConstraint),biasConstraint:Ii(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}f$.className="LSTMCell";ot(f$);class Jne extends Fp{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new f$(e),super(e)}call(e,t){return Se(()=>{this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Jne.className="LSTM";ot(Jne);class v4 extends h${constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Se(()=>{e=e;let r=e.slice(1);const s=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?s.push(r.splice(0,a.stateSize.length)):s.push(r.splice(0,1));s.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];r=s[a],a===0?o=[e[0]].concat(r):o=[o[0]].concat(r),o=l.call(o,t),i.push(o.slice(1))}r=[];for(const a of i.slice().reverse())r.push(...a);return[o[0]].concat(r)})}build(e){UO(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,s)=>{qm(`RNNCell_${s}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,t,r={}){const s=[];for(const i of t.cells)s.push(gh(i,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return WO(e)}setWeights(e){const t=[];for(const r of this.cells){const s=r.weights.length,i=e.splice(s);for(let o=0;o<r.weights.length;++o)t.push([r.weights[o],i[o]])}h4(t)}}v4.className="StackedRNNCells";ot(v4);function fp(n){const{ones:e,rate:t,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):Wte(e(),t),a=()=>kC(o,e,r);return!s||s<=1?Xs(a().clone()):Array(s).fill(void 0).map(a).map(c=>Xs(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var urt=globalThis&&globalThis.__rest||function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(n);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(t[r[s]]=n[r[s]]);return t};class Qne extends Fp{constructor(e){if(e.unroll)throw new Fn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Fn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ti({ndim:5})]}call(e,t){return Se(()=>{if(this.cell.dropoutMask!=null&&(nn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new _e("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Se(()=>{const{stateSize:t}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)],o=ms(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){Se(()=>{if(!this.stateful)throw new sh("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)];if(r[0]==null)throw new _e("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ms(i)):this.states_=[ms(i)];else if(e==null)nn(this.states_),this.keptStates!=null&&(nn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ms(i)):this.states_[0]=ms(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _e(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nn(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=i;if(!Rn(l.shape,c))throw new _e(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>Xs(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:s,padding:i,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=yu(c,s[0],i,o[0],a[0]),f=yu(u,s[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[r,h,f]:[h,f,r]]}}Qne.className="ConvRNN2D";class w4 extends f${constructor(e){const{filters:t,kernelSize:r,strides:s,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Wi(this.filters,"filters"),this.kernelSize=Nb(r,2,"kernelSize"),this.kernelSize.forEach(l=>Wi(l,"kernelSize")),this.strides=Nb(s||1,2,"strides"),this.strides.forEach(l=>Wi(l,"strides")),this.padding=i||"valid",Ll(this.padding),this.dataFormat=o||"channelsLast",ti(this.dataFormat),this.dilationRate=Nb(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Wi(l,"dilationRate"))}build(e){var t;e=wr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new _e(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],i=4,o=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends Rc{apply(f,d){const p=c.apply([u]),m=pa([u]),g=c.apply([u*2]);return r4([p,m,g])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Se(()=>{if(e.length!==3)throw new _e(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,s=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=fp({ones:()=>Ml(s),rate:this.dropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(ge,ae,Ne)=>!ae||!ae[Ne]?ge:fe(ae[Ne],ge);let u=c(s,l,0),h=c(s,l,1),f=c(s,l,2),d=c(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=fp({ones:()=>Ml(i),rate:this.recurrentDropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let m=c(i,p,0),g=c(i,p,1),y=c(i,p,2),b=c(i,p,3);const x=3,[w,S,C,k]=ja(this.kernel.read(),a,x),[A,M,E,N]=this.useBias?ja(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,w,A,this.padding),h=this.inputConv(h,S,M,this.padding),f=this.inputConv(f,C,E,this.padding),d=this.inputConv(d,k,N,this.padding);const[O,R,D,z]=ja(this.recurrentKernel.read(),a,x);m=this.recurrentConv(m,O),g=this.recurrentConv(g,R),y=this.recurrentConv(y,D),b=this.recurrentConv(b,z);const B=this.recurrentActivation.apply(qe(u,m)),X=this.recurrentActivation.apply(qe(h,g)),G=qe(fe(X,o),fe(B,this.activation.apply(qe(f,y)))),te=fe(this.recurrentActivation.apply(qe(d,b)),this.activation.apply(G));return[te,te,G]})}getConfig(){const e=super.getConfig(),t=urt(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),r)}inputConv(e,t,r,s){const i=sp(e,t,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Vu(i,r,this.dataFormat):i}recurrentConv(e,t){return sp(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}w4.className="ConvLSTM2DCell";ot(w4);class ere extends Qne{constructor(e){const t=new w4(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}ere.className="ConvLSTM2D";ot(ere);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class x4 extends Kn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?t[s]:this.noiseShape[s]);return r}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);if(0<this.rate&&this.rate<1){const s=t.training==null?!1:t.training,i=this.getNoiseShape(r);return kC(()=>Wte(r,this.rate,i,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}x4.className="Dropout";ot(x4);class tre extends x4{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}tre.className="SpatialDropout1D";ot(tre);class _4 extends Kn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Wi(this.units,"units"),this.activation=hp(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ys(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ys(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ai(e.kernelConstraint),this.biasConstraint=Ai(e.biasConstraint),this.kernelRegularizer=vs(e.kernelRegularizer),this.biasRegularizer=vs(e.biasRegularizer),this.activityRegularizer=vs(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=wr(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=wr(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e),s=Ote(this.activation.getClassName());let i;return s!=null?i=mh(r,this.kernel.read(),s,this.bias?this.bias.read():null):(i=mh(r,this.kernel.read()),this.bias!=null&&(i=Vu(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:up(this.activation),useBias:this.useBias,kernelInitializer:Cs(this.kernelInitializer),biasInitializer:Cs(this.biasInitializer),kernelRegularizer:jr(this.kernelRegularizer),biasRegularizer:jr(this.biasRegularizer),activityRegularizer:jr(this.activityRegularizer),kernelConstraint:Ii(this.kernelConstraint),biasConstraint:Ii(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}_4.className="Dense";ot(_4);class nre extends Kn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=wr(e);for(const t of e.slice(1))if(t==null)throw new _e(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Gd(e,1)]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=vn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let i=2;i<r.rank;++i)s.push(i);s.push(1),r=rr(r,s)}return PQe(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}nre.className="Flatten";ot(nre);class rre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.activation=hp(e.activation)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);return this.activation.apply(r)})}getConfig(){const e={activation:up(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}rre.className="Activation";ot(rre);class sre extends Kn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Se(()=>(e=vn(e),$Qe(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}sre.className="RepeatVector";ot(sre);let ire=class extends Kn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",s=t.slice();let i=1,o=null;for(let l=0;l<s.length;++l){const c=s[l];if(this.isUnknown(c))if(o===null)o=l;else throw new _e("Can only specifiy one unknown dimension.");else i*=c}const a=Gd(e);if(o!==null){if(i===0||a%i!==0)throw new _e(r);s[o]=a/i}else if(a!==i)throw new _e(r);return s}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e),s=r.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return ve(r,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};ire.className="Reshape";ot(ire);class ore extends Kn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Su(1,e.dims.length+1);if(!Rn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ti({ndim:this.dims.length+1})]}computeOutputShape(e){e=wr(e);const t=e.slice();return this.dims.forEach((r,s)=>{t[s+1]=e[r]}),t}call(e,t){return rr(vn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}ore.className="Permute";ot(ore);class are extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=vn(e),s=-1;return TI(qb(r,this.maskValue),s)}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e),s=-1,i=!0,o=TI(qb(r,this.maskValue),s,i);return fe(r,wt(o,r.dtype))})}}are.className="Masking";ot(are);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class lre extends Kn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Gr(e.inputLength))}this.inputDim=e.inputDim,Wi(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Wi(this.outputDim,"outputDim"),this.embeddingsInitializer=ys(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vs(e.embeddingsRegularizer),this.activityRegularizer=vs(e.activityRegularizer),this.embeddingsConstraint=Ai(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Se(()=>this.maskZero?(e=vn(e),qb(e,lr(e))):null)}computeOutputShape(e){if(e=wr(e),this.inputLength==null)return[...e,this.outputDim];const t=Gr(this.inputLength);if(t.length!==e.length-1)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<t.length;++s){const i=t[s],o=e[s+1];if(i!=null&&o!=null&&i!==o)throw new _e(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[r]=o),r++}}return[e[0],...t,this.outputDim]}call(e,t){return Se(()=>{this.invokeCallHook(e,t);let r=vn(e);r.dtype!=="int32"&&(r=ph(r,"int32"));const s=Ute(this.embeddings.read(),ve(r,[r.size]));return ve(s,wr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Cs(this.embeddingsInitializer),embeddingsRegularizer:jr(this.embeddingsRegularizer),activityRegularizer:jr(this.activityRegularizer),embeddingsConstraint:Ii(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}lre.className="Embedding";ot(lre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Xy extends Kn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Fn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const i=e[e.length-t.length+s],o=t[s];if(i==null||o==null||i<0||o<0)r.push(null);else if(i===1)r.push(o);else if(o===1)r.push(i);else{if(i!==o)throw new _e("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(i)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[wr(e)]),e=e,e.length<2)throw new _e(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Wd(t),t.length>1)throw new _e(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=e.map(i=>i.length);e.indexOf(null)===-1&&Wd(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Se(()=>{if(e=e,this.reshapeRequired){const r=[],s=e.map(i=>i.rank);if(s.indexOf(null)===-1){const i=cp(s);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=SC(o,1);r.push(o)}return this.mergeFunction(r)}else{let i=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],f=u.slice(1).concat([h]);let d=ve(l,[h].concat(Gd(u.slice(1))));d=rr(d,[1,0]),d=ve(d,f),r.push(d),i=!0}else if(c>1){const u=Su(1,c).concat([0]);r.push(rr(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i){if(a==null){const l=o.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));o=ve(rr(ve(o,[-1,u]),[1,0]),h)}else if(a>1){const l=[a-1].concat(Su(0,a-1));o=rr(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let s=1;s<e.length;++s){const i=e[s]==null?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=Wd(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return Se(()=>{if(t==null)return null;if(!Array.isArray(t))throw new _e("`mask` should be an Array");if(!Array.isArray(e))throw new _e("`inputs` should be an Array");if(t.length!==e.length)throw new _e(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(s=>s==null))return null;t=t.map(s=>s==null?s:oi(s,0));let r=t[0];for(let s=1;s<t.length-1;++s)r=wh(r,t[s]);return r})}}let cre=class extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=qe(t,e[r]);return t})}};cre.className="Add";ot(cre);let ure=class extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=fe(t,e[r]);return t})}};ure.className="Multiply";ot(ure);class hre extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=qe(t,e[r]);return fe(1/e.length,t)})}}hre.className="Average";ot(hre);class fre extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Vf(t,e[r]);return t})}}fre.className="Maximum";ot(fre);class dre extends Xy{constructor(e){super(e)}mergeFunction(e){return Se(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=op(t,e[r]);return t})}}dre.className="Minimum";ot(dre);class pre extends Xy{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new _e("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const s of e)if(s!=null){t=!1;break}if(t)return;const r=[];for(let s=0;s<e.length;++s){const i=e[s].slice();i.splice(this.axis,1);let o=!1;for(const a of r)if(Rn(a,i)){o=!0;break}o||r.push(i)}if(r.length>1)throw new _e("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Se(()=>r4(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new _e("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const i of t.slice(1)){if(r[s]==null||i[s]==null){r[s]=null;break}r[s]+=i[s]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new _e("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new _e("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new _e(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Se(()=>{let r=!0;if(t.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const s=[];for(let o=0;o<e.length;++o)t[o]==null?s.push(wt(Ml(e[o]),"bool")):t[o].rank<e[o].rank?s.push(oi(t[o],-1)):s.push(t[o]);const i=cs(s,this.axis);return UL(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}pre.className="Concatenate";ot(pre);function qx(n,e){for(;n<0;)n+=e;return n}function hrt(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Fn("batchDot is not implemented for tensors of 4D or higher rank yet");if(U(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),U(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Fn("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=e.shape.length;t==null&&(t=[r-1,s-2]);const i=t;return Se(()=>{let o;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);e=ve(e,e.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=ve(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=Yt(fe(n,e),i[0]):a=Yt(fe(rr(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,c=i[1]===e.shape.length-1;a=Hn(n,e,l,c)}if(o>0){let l;r>s?l=r+s-3:l=r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=vr(a,c)}return a.shape.length===1&&(a=oi(a,1)),a})}class mre extends Xy{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);if(t[s[0]]!==r[s[1]])throw new _e(`Dimension incompatibility: ${t[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new _e(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,o)=>qx(i,e[o].shape.length)):s=[qx(this.axes,t.shape.length),qx(this.axes,r.shape.length)],this.normalize&&(t=nA(t,s[0]),r=nA(r,s[1])),hrt(t,r,s)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[qx(this.axes,e.length),qx(this.axes,t.length)],r}computeOutputShape(e){U(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);t.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const i=t.concat(r);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}mre.className="Dot";ot(mre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class gre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);return kC(()=>qe(i$(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}gre.className="GaussianNoise";ot(gre);class yre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{this.invokeCallHook(e,t);const r=vn(e);return this.rate>0&&this.rate<1?kC(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return fe(r,i$(r.shape,1,i))},()=>r,t.training||!1):r})}}yre.className="GaussianDropout";ot(yre);class bre extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||vn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Se(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return kC(()=>{const i=vn(e),o=1.6732632423543772,a=1.0507009873554805,l=-o*a;let c=Mp(Np(r),this.rate);c=ph(c,"float32");const u=((1-this.rate)*(1+this.rate*l**2))**-.5,h=-u*l*this.rate,f=qe(fe(i,c),fe(qe(c,-1),l));return qe(fe(f,u),h)},()=>vn(e),t.training||!1)}return e})}}bre.className="AlphaDropout";ot(bre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Y_(n,e,t,r,s,i=.001){let o;if(n.rank===2)o=HL(n,e,t,r,s,i);else if(n.rank===3)o=jL(n,e,t,r,s,i);else if(n.rank===4)o=qL(n,e,t,r,s,i);else throw new Fn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function frt(n,e,t,r,s=.001){return Se(()=>{const i=Q2(n,r),o=i.mean,a=i.variance;return[Y_(n,o,a,t,e,s),o,a]})}function drt(n,e,t,r,s=.001){return Se(()=>{const i=Q2(n,r),o=i.mean,a=i.variance,l=[];for(const p of Su(0,n.rank))r.indexOf(p)!==-1?l.push(1):l.push(n.shape[p]);const c=ve(o,l),u=ve(a,l),h=e==null?null:ve(e,l),f=t==null?null:ve(t,l);return[Y_(n,c,u,f,h,s),o,a]})}function prt(n,e,t,r,s=.001){return Rn(r.slice().sort(),Su(0,n.rank-1))?frt(n,e,t,r,s):drt(n,e,t,r,s)}class vre extends Kn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ys(e.betaInitializer||"zeros"),this.gammaInitializer=ys(e.gammaInitializer||"ones"),this.movingMeanInitializer=ys(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ys(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ai(e.betaConstraint),this.gammaConstraint=Ai(e.gammaConstraint),this.betaRegularizer=vs(e.betaRegularizer),this.gammaRegularizer=vs(e.gammaRegularizer)}build(e){e=wr(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new _e(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ti({ndim:e.length,axes:{[t]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Se(()=>{const r=t.training==null?!1:t.training,s=vn(e),i=s.shape,o=i.length,a=Su(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=mg(1,o);c[l]=i[l];const u=a.slice();u.sort();const h=!Rn(u,Su(0,o).slice(0,o-1)),f=()=>{if(h){const b=ve(this.movingMean.read(),c),x=ve(this.movingVariance.read(),c),w=this.center?ve(this.beta.read(),c):null,S=this.scale?ve(this.gamma.read(),c):null;return Y_(s,b,x,w,S,this.epsilon)}else return Y_(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return f();const[d,p,m]=prt(s,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,x,w)=>{Se(()=>{const S=1-w,C=b.read(),k=fe(Dt(C,x),S);b.write(Dt(C,k))})};return(()=>{g(this.movingMean,p,this.momentum),g(this.movingVariance,m,this.momentum)})(),d})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Cs(this.betaInitializer),gammaInitializer:Cs(this.gammaInitializer),movingMeanInitializer:Cs(this.movingMeanInitializer),movingVarianceInitializer:Cs(this.movingVarianceInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer),betaConstraint:Ii(this.betaConstraint),gammaConstraint:Ii(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}vre.className="BatchNormalization";ot(vre);class wre extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ys(e.betaInitializer||"zeros"),this.gammaInitializer=ys(e.gammaInitializer||"ones"),this.betaRegularizer=vs(e.betaRegularizer),this.gammaRegularizer=vs(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=wr(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Wd(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,t){const r=vn(e),s=r.shape,i=s.length;return Se(()=>{let{mean:a,variance:l}=Q2(r,this.axis,!0);const c=mg(1,i);for(const m of this.axis)c[m]=s[m];const u=m=>m!=null&&m.shape.length!==i?ve(m,c):m;let h=this.scale?u(this.gamma.read()):null,f=this.center?u(this.beta.read()):null;const d=[],p=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(d.push(s[m]),p.push(1)):(d.push(1),p.push(s[m]));return a=fc(a,d),l=fc(l,d),h!=null&&(h=fc(h,p)),f!=null&&(f=fc(f,p)),Y_(r,a,l,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Cs(this.betaInitializer),gammaInitializer:Cs(this.gammaInitializer),betaRegularizer:jr(this.betaRegularizer),gammaRegularizer:jr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}wre.className="LayerNormalization";ot(wre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function mrt(n,e,t){return Se(()=>{if(n.rank!==4)throw new _e(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new _e("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Cu()),t!=="channelsLast"&&t!=="channelsFirst")throw new _e(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],vu(n,r)})}class xre extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Cu():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new _e(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new _e(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new _e(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new Ti({ndim:4})]}computeOutputShape(e){e=wr(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return Se(()=>mrt(vn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}xre.className="ZeroPadding2D";ot(xre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function d$(n,e,t,r,s,i){return Se(()=>{ti(s),Lte(i),Ll(r),t==null&&(t=[1,1]),r==null&&(r="valid"),s==null&&(s=Cu()),i==null&&(i="max"),n=g4(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=WM(n,e,t,a):o=RM(n,e,t,a),s==="channelsFirst"&&(o=rr(o,[0,3,1,2])),o})}function _re(n,e,t,r,s,i){return Se(()=>{ti(s),Lte(i),Ll(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Cu()),i==null&&(i="max"),n=Bne(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=cz(n,e,t,a):o=GL(n,e,t,a),s==="channelsFirst"&&(o=rr(o,[0,4,1,2,3])),o})}class Sre extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new _e(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Wi(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new _e(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Wi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Ll(this.padding),this.inputSpec=[new Ti({ndim:3})]}computeOutputShape(e){e=wr(e);const t=yu(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Se(()=>{this.invokeCallHook(e,t),e=SC(vn(e),2);const r=this.poolingFunction(vn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return vr(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Cre extends Sre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Ll(s),d$(e,t,r,s,i,"max")}}Cre.className="MaxPooling1D";ot(Cre);class kre extends Sre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Ll(s),d$(e,t,r,s,i,"avg")}}kre.className="AveragePooling1D";ot(kre);class Tre extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new _e(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Wi(this.poolSize,"poolSize"),Wi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),Ll(this.padding),this.inputSpec=[new Ti({ndim:4})]}computeOutputShape(e){e=wr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=yu(t,this.poolSize[0],this.padding,this.strides[0]),r=yu(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(vn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Ere extends Tre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Ll(s),d$(e,t,r,s,i,"max")}}Ere.className="MaxPooling2D";ot(Ere);class Ire extends Tre{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Ll(s),d$(e,t,r,s,i,"avg")}}Ire.className="AveragePooling2D";ot(Ire);class Are extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new _e(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Wi(this.poolSize,"poolSize"),Wi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),Ll(this.padding),this.inputSpec=[new Ti({ndim:5})]}computeOutputShape(e){e=wr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=yu(t,this.poolSize[0],this.padding,this.strides[0]),r=yu(r,this.poolSize[1],this.padding,this.strides[1]),s=yu(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,s]:[e[0],t,r,s,e[4]]}call(e,t){return Se(()=>(this.invokeCallHook(e,t),this.poolingFunction(vn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Mre extends Are{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Ll(s),_re(e,t,r,s,i,"max")}}Mre.className="MaxPooling3D";ot(Mre);class Nre extends Are{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ti(i),Ll(s),_re(e,t,r,s,i,"avg")}}Nre.className="AveragePooling3D";ot(Nre);class $re extends Kn{constructor(e){super(e),this.inputSpec=[new Ti({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Fn}}class Rre extends $re{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=vn(e);return Ds(r,1)})}}Rre.className="GlobalAveragePooling1D";ot(Rre);class Pre extends $re{constructor(e){super(e||{})}call(e,t){return Se(()=>{const r=vn(e);return bc(r,1)})}}Pre.className="GlobalMaxPooling1D";ot(Pre);class Dre extends Kn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ti(this.dataFormat),this.inputSpec=[new Ti({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Fn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Ore extends Dre{call(e,t){return Se(()=>{const r=vn(e);return this.dataFormat==="channelsLast"?Ds(r,[1,2]):Ds(r,[2,3])})}}Ore.className="GlobalAveragePooling2D";ot(Ore);class Fre extends Dre{call(e,t){return Se(()=>{const r=vn(e);return this.dataFormat==="channelsLast"?bc(r,[1,2]):bc(r,[2,3])})}}Fre.className="GlobalMaxPooling2D";ot(Fre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Lre extends Kn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const s=t.layer,i=gh(s,r);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class zre extends Lre{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=wr(e),e.length<3)throw new _e(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=wr(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,t){return Se(()=>(e=vn(e),Kne((o,a)=>[vn(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}zre.className="TimeDistributed";ot(zre);function grt(n){qy(EQe,"BidirectionalMergeMode",n)}const yrt="concat";class Bre extends Lre{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=gh(r),t.goBackwards=t.goBackwards!==!0;const s={};if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=gh(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?yrt:e.mergeMode,grt(this.mergeMode),e.weights)throw new Fn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,s,i;return this.returnState&&(i=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[r].concat(i).concat(i.slice()):fa(s)}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=Xne(e,r,s,this.numConstants);if(e=i.inputs,r=i.initialState,s=i.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,t);const o=[],a=[];if(r!=null){const c=r.length;if(c%2>0)throw new _e("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,o.push(...r);const u=r.map(h=>new Ti({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(s!=null)throw new Fn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof Sh;for(const c of o)if(c instanceof Sh!==l)throw new _e("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=u;const f=super.apply(c,t);return this.inputSpec=h,f}else return super.apply(e,t)}call(e,t){return Se(()=>{const r=t.initialState;let s,i;if(r==null)s=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=r.slice(0,r.length/2),c=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(s)&&(o=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=Cc(i,1));let a;return this.mergeMode==="concat"?a=r4([s,i]):this.mergeMode==="sum"?a=qe(s,i):this.mergeMode==="ave"?a=fe(.5,qe(s,i)):this.mergeMode==="mul"?a=fe(s,i):this.mergeMode==null&&(a=[s,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){qm(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),qm(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(i).concat(i):[r].concat(i).concat(i)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=gh(t.layer);if(delete t.layer,t.numConstants!=null)throw new Fn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=r,new e(s)}}Bre.className="Bidirectional";ot(Bre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Vre extends Kn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>(e=vn(e),e.dtype!=="float32"&&(e=ph(e,"float32")),qe(fe(e,this.scale),this.offset)))}}Vre.className="Rescaling";ot(Vre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:brt,cropAndResize:vrt}=Ci;class Ure extends Kn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,s,i,o,a,l){return Se(()=>{let c,u=!1;const h=t/o,f=r/a,d=(s+t)/o,p=(i+r)/a,m=[h,f,d,p],g=[];e.rank===3?(u=!0,c=xa([e])):c=e;for(let S=0;S<c.shape[0];S++)g.push(m);const y=Ei(g,[g.length,4]),b=ag(0,g.length,1,"int32"),w=vrt(c,y,b,[s,i],"nearest");return ph(u?vn(kc(w)):w,l)})}upsize(e,t,r,s){return Se(()=>{const i=brt(e,[t,r]);return ph(i,s)})}call(e,t){return Se(()=>{const r=vn(e),s=r.dtype,i=r.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(r,l,c,this.height,this.width,o,a,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wr(e);const t=e.length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}Ure.className="CenterCrop";ot(Ure);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wrt(n,e,t,r){let s=vn(n);if(s.dtype!=="int32"&&(s=ph(s,"int32")),e==="int")return s;const i=s.shape;if(s.rank===0&&(s=oi(s,-1)),e==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=oi(s,-1)),s.rank>2)throw new _e(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(e),a=s;let l;if(typeof r<"u"&&e==="count"?l=II(a,r,t,o):l=II(a,[],t,o),e!=="tfIdf")return l;if(r)return fe(l,r);throw new _e("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wre extends Kn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=wr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Se(()=>{e=vn(e),e.dtype!=="int32"&&(e=ph(e,"int32"));let r;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new _e(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=vn(t.countWeights)}const s=bc(e),i=C_(e),o=tl(this.numTokens,s).bufferSync().get(0),a=Mp(i,0).bufferSync().get(0);if(!(o&&a))throw new _e(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return wrt(e,this.outputMode,this.numTokens,r)})}}Wre.className="CategoryEncoding";ot(Wre);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const xrt=["bilinear","nearest"],T6=new Set(xrt);class Gre extends Kn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(T6.has(e.interpolation))this.interpolation=e.interpolation;else throw new _e(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=wr(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Se(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return Ci.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Ci.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...T6]} are supported`)})}}Gre.className="Resizing";ot(Gre);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Hre{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}Hre.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jre extends Kn{constructor(e){super(e),this.randomGenerator=new Hre(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}jre.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const _rt=["bilinear","nearest"],E6=new Set(_rt);class qre extends jre{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new _e(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new _e(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new _e(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(E6.has(r))this.interpolation=r;else throw new _e(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=wr(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return Se(()=>{const r=vn(e);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=Np([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return Ci.resizeBilinear(e,o);case"nearest":return Ci.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...E6]} are supported`)}})}}qre.className="RandomWidth";ot(qre);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function I6(n){return new _4(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Srt(n,e){return Xre(n,e)}function Xre(n,e,t=new Map,r=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const s=e(n);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(p$(n)){const i=Array.isArray(n)?[]:{};r.add(n);for(const o in n){const a=n[o],l=Xre(a,e,t,r);i[o]=l}return r.delete(n),n.__proto__&&(i.__proto__=n.__proto__),i}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,s.value),s.value}function Crt(n,e=Yre){return Kre(n,e)}function Kre(n,e,t=new Set){const r=n[0];if(t.has(r))throw new Error("Circular references are not supported.");const s=e(n);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(p$(r)){const i=Array.isArray(r)?[]:{};t.add(r);for(const o in r){const a=n.map(c=>c[o]),l=Kre(a,e,t);i[o]=l}return t.delete(r),i}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function Yre(n){return n===null?null:p$(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}function p$(n){let e=!1;if(Ee().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof jn)&&!(n instanceof Promise)&&!e)}function krt(n){return n==null||Trt(n)||Array.isArray(n)||typeof n=="object"&&n instanceof jn||_i(n)}function Trt(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Ert(n){return Srt(n,Irt)}function Irt(n){return n instanceof jn?{value:n.clone(),recurse:!1}:p$(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Zre{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),r=this.get(t);return this.set(t,this.pop()),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class m$ extends Zre{constructor(){super(m$.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),r=this.length();for(let s=0;s<r;s++)t[s]=this.get(this.wrap(this.begin+s));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}m$.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Art(n){return new Nrt(n)}function Jre(n){return new $rt(n)}function Mrt(n,e){return new Qre(n,e)}class zl{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let r=await e.next();for(;!r.done;)t.push(r.value),r=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),r=e(t.value);for(;!t.done&&r;)t=await this.next(),r=e(t.value)}handleErrors(e){return new zrt(this,e)}filter(e){return new Frt(this,e)}map(e){return new Lrt(this,e)}mapAsync(e){return new A6(this,e)}serialMapAsync(e){return new A6(this,e).serial()}flatmap(e){return new Vrt(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new Ort(this,e,t)}columnMajorBatch(e,t=!0,r=Yre){return this.rowMajorBatch(e,t).map(i=>Crt(i,r))}concatenate(e,t){return new Qre(Art([this,e]),t)}take(e){return e<0||e==null?this:new Drt(this,e)}skip(e){return e<0||e==null?this:new Prt(this,e)}prefetch(e){return new ese(this,e)}shuffle(e,t){return new Urt(this,e,t)}serial(){return new Rrt(this)}}class Nrt extends zl{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Ert(e),done:!1}}}class $rt extends zl{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class Rrt extends zl{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class Prt extends zl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;nn(e.value)}return this.upstream.next()}}class Drt extends zl{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class Ort extends zl{constructor(e,t,r=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class Frt extends zl{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nn(e.value)}}}class Lrt extends zl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Mf(e.value),r=this.transform(e.value),s=Mf(r);for(const i of t)NM(i,s)||i.dispose();return{value:r,done:!1}}}class zrt extends zl{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class A6 extends zl{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Mf(e.value),r=await this.transform(e.value),s=Mf(r);for(const i of t)NM(i,s)||i.dispose();return{value:r,done:!1}}}class Brt extends zl{constructor(){super(),this.outputQueue=new m$,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Vrt extends Brt{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Mf(e.value),r=this.transform(e.value),s=Mf(r);this.outputQueue.pushAll(r);for(const i of t)NM(i,s)||i.dispose();return!0}}class Qre extends zl{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var M6;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(M6||(M6={}));class ese extends zl{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Zre(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Urt extends ese{constructor(e,t,r){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Aw.alea(r||so().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let tse=class{constructor(){this.size=null}batch(e,t=!0){const r=this;U(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let s;return this.size===1/0||this.size==null?s=this.size:t?s=Math.ceil(this.size/e):s=Math.floor(this.size/e),eu(async()=>(await r.iterator()).columnMajorBatch(e,t,Wrt),s)}concatenate(e){const t=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,eu(async()=>(await t.iterator()).concatenate(await e.iterator()),r)}filter(e){const t=this;let r;return this.size===1/0?r=1/0:r=null,eu(async()=>(await t.iterator()).filter(s=>Se(()=>e(s))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return eu(async()=>(await t.iterator()).map(r=>Se(()=>e(r))),this.size)}mapAsync(e){const t=this;return eu(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return eu(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,eu(async()=>{const s=Jre(async()=>({value:await t.iterator(),done:!1}));return Mrt(s.take(e))},r)}skip(e){const t=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,eu(async()=>(await t.iterator()).skip(e),r)}shuffle(e,t,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,i=Aw.alea(t||so().toString());return eu(async()=>{let o=i.int32();return r&&(o+=i.int32()),(await s.iterator()).shuffle(e,o.toString())},this.size)}take(e){const t=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,eu(async()=>(await t.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};tse.MAX_BUFFER_SIZE=1e4;function eu(n,e=null){return new class extends tse{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function Wrt(n){if(n===null)return null;const e=n[0];return krt(e)?{value:Grt(n),recurse:!1}:{value:null,recurse:!0}}function Grt(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof jn?xa(n):Ei(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function Hrt(n){return eu(async()=>{const e=await n();return Jre(()=>e.next())})}var XO={exports:{}};const jrt=zf(bQe),qrt=zf(cZ);/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(n,e){(function(t,r){r(e,jrt,qrt)})(pt,function(t,r,s){const i={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(l,c){this.modelPath=c||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(l)}/model.json`}getPrefix(l){return l==="lite_mobilenet_v2"?`ssd${l}`:`ssd_${l}`}async load(){this.model=await r.loadGraphModel(this.modelPath);const l=s.zeros([1,300,300,3],"int32"),c=await this.model.executeAsync(l);await Promise.all(c.map(u=>u.data())),c.map(u=>u.dispose()),l.dispose()}async infer(l,c,u){const h=s.tidy(()=>(l instanceof s.Tensor||(l=s.browser.fromPixels(l)),s.expandDims(l))),f=h.shape[1],d=h.shape[2],p=await this.model.executeAsync(h),m=p[0].dataSync(),g=p[1].dataSync();h.dispose(),s.dispose(p);const[y,b]=this.calculateMaxScores(m,p[0].shape[1],p[0].shape[2]),x=s.getBackend();s.getBackend()==="webgl"&&s.setBackend("cpu");const w=s.tidy(()=>{const C=s.tensor2d(g,[p[1].shape[1],p[1].shape[3]]);return s.image.nonMaxSuppression(C,y,c,u,u)}),S=w.dataSync();return w.dispose(),x!==s.getBackend()&&s.setBackend(x),this.buildDetectedObjects(d,f,g,y,S,b)}buildDetectedObjects(l,c,u,h,f,d){const p=f.length,m=[];for(let g=0;g<p;g++){const y=[];for(let C=0;C<4;C++)y[C]=u[4*f[g]+C];const b=y[0]*c,x=y[1]*l,w=y[2]*c,S=y[3]*l;y[0]=x,y[1]=b,y[2]=S-x,y[3]=w-b,m.push({bbox:y,class:i[d[f[g]]+1].displayName,score:h[f[g]]})}return m}calculateMaxScores(l,c,u){const h=[],f=[];for(let d=0;d<c;d++){let p=Number.MIN_VALUE,m=-1;for(let g=0;g<u;g++)l[d*u+g]>p&&(p=l[d*u+g],m=g);h[d]=p,f[d]=m}return[h,f]}async detect(l,c=20,u=.5){return this.infer(l,c,u)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=o,t.load=async function(a={}){if(s==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const l=a.base||"lite_mobilenet_v2",c=a.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(l)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${l}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const u=new o(l,c);return await u.load(),u},t.version="2.2.3",Object.defineProperty(t,"__esModule",{value:!0})})})(XO,XO.exports);var N6=XO.exports;/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function MC(n){return n+.5|0}const Pd=(n,e,t)=>Math.max(Math.min(n,t),e);function A1(n){return Pd(MC(n*2.55),0,255)}function jd(n){return Pd(MC(n*255),0,255)}function yf(n){return Pd(MC(n/2.55)/100,0,1)}function $6(n){return Pd(MC(n*100),0,100)}const Jl={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},KO=[..."0123456789ABCDEF"],Xrt=n=>KO[n&15],Krt=n=>KO[(n&240)>>4]+KO[n&15],uT=n=>(n&240)>>4===(n&15),Yrt=n=>uT(n.r)&&uT(n.g)&&uT(n.b)&&uT(n.a);function Zrt(n){var e=n.length,t;return n[0]==="#"&&(e===4||e===5?t={r:255&Jl[n[1]]*17,g:255&Jl[n[2]]*17,b:255&Jl[n[3]]*17,a:e===5?Jl[n[4]]*17:255}:(e===7||e===9)&&(t={r:Jl[n[1]]<<4|Jl[n[2]],g:Jl[n[3]]<<4|Jl[n[4]],b:Jl[n[5]]<<4|Jl[n[6]],a:e===9?Jl[n[7]]<<4|Jl[n[8]]:255})),t}const Jrt=(n,e)=>n<255?e(n):"";function Qrt(n){var e=Yrt(n)?Xrt:Krt;return n?"#"+e(n.r)+e(n.g)+e(n.b)+Jrt(n.a,e):void 0}const est=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function nse(n,e,t){const r=e*Math.min(t,1-t),s=(i,o=(i+n/30)%12)=>t-r*Math.max(Math.min(o-3,9-o,1),-1);return[s(0),s(8),s(4)]}function tst(n,e,t){const r=(s,i=(s+n/60)%6)=>t-t*e*Math.max(Math.min(i,4-i,1),0);return[r(5),r(3),r(1)]}function nst(n,e,t){const r=nse(n,1,.5);let s;for(e+t>1&&(s=1/(e+t),e*=s,t*=s),s=0;s<3;s++)r[s]*=1-e-t,r[s]+=e;return r}function rst(n,e,t,r,s){return n===s?(e-t)/r+(e<t?6:0):e===s?(t-n)/r+2:(n-e)/r+4}function S4(n){const t=n.r/255,r=n.g/255,s=n.b/255,i=Math.max(t,r,s),o=Math.min(t,r,s),a=(i+o)/2;let l,c,u;return i!==o&&(u=i-o,c=a>.5?u/(2-i-o):u/(i+o),l=rst(t,r,s,u,i),l=l*60+.5),[l|0,c||0,a]}function C4(n,e,t,r){return(Array.isArray(e)?n(e[0],e[1],e[2]):n(e,t,r)).map(jd)}function k4(n,e,t){return C4(nse,n,e,t)}function sst(n,e,t){return C4(nst,n,e,t)}function ist(n,e,t){return C4(tst,n,e,t)}function rse(n){return(n%360+360)%360}function ost(n){const e=est.exec(n);let t=255,r;if(!e)return;e[5]!==r&&(t=e[6]?A1(+e[5]):jd(+e[5]));const s=rse(+e[2]),i=+e[3]/100,o=+e[4]/100;return e[1]==="hwb"?r=sst(s,i,o):e[1]==="hsv"?r=ist(s,i,o):r=k4(s,i,o),{r:r[0],g:r[1],b:r[2],a:t}}function ast(n,e){var t=S4(n);t[0]=rse(t[0]+e),t=k4(t),n.r=t[0],n.g=t[1],n.b=t[2]}function lst(n){if(!n)return;const e=S4(n),t=e[0],r=$6(e[1]),s=$6(e[2]);return n.a<255?`hsla(${t}, ${r}%, ${s}%, ${yf(n.a)})`:`hsl(${t}, ${r}%, ${s}%)`}const R6={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},P6={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function cst(){const n={},e=Object.keys(P6),t=Object.keys(R6);let r,s,i,o,a;for(r=0;r<e.length;r++){for(o=a=e[r],s=0;s<t.length;s++)i=t[s],a=a.replace(i,R6[i]);i=parseInt(P6[o],16),n[a]=[i>>16&255,i>>8&255,i&255]}return n}let hT;function ust(n){hT||(hT=cst(),hT.transparent=[0,0,0,0]);const e=hT[n.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:e.length===4?e[3]:255}}const hst=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function fst(n){const e=hst.exec(n);let t=255,r,s,i;if(e){if(e[7]!==r){const o=+e[7];t=e[8]?A1(o):Pd(o*255,0,255)}return r=+e[1],s=+e[3],i=+e[5],r=255&(e[2]?A1(r):Pd(r,0,255)),s=255&(e[4]?A1(s):Pd(s,0,255)),i=255&(e[6]?A1(i):Pd(i,0,255)),{r,g:s,b:i,a:t}}}function dst(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${yf(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}const M3=n=>n<=.0031308?n*12.92:Math.pow(n,1/2.4)*1.055-.055,O0=n=>n<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4);function pst(n,e,t){const r=O0(yf(n.r)),s=O0(yf(n.g)),i=O0(yf(n.b));return{r:jd(M3(r+t*(O0(yf(e.r))-r))),g:jd(M3(s+t*(O0(yf(e.g))-s))),b:jd(M3(i+t*(O0(yf(e.b))-i))),a:n.a+t*(e.a-n.a)}}function fT(n,e,t){if(n){let r=S4(n);r[e]=Math.max(0,Math.min(r[e]+r[e]*t,e===0?360:1)),r=k4(r),n.r=r[0],n.g=r[1],n.b=r[2]}}function sse(n,e){return n&&Object.assign(e||{},n)}function D6(n){var e={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(e={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(e.a=jd(n[3]))):(e=sse(n,{r:0,g:0,b:0,a:1}),e.a=jd(e.a)),e}function mst(n){return n.charAt(0)==="r"?fst(n):ost(n)}let ise=class YO{constructor(e){if(e instanceof YO)return e;const t=typeof e;let r;t==="object"?r=D6(e):t==="string"&&(r=Zrt(e)||ust(e)||mst(e)),this._rgb=r,this._valid=!!r}get valid(){return this._valid}get rgb(){var e=sse(this._rgb);return e&&(e.a=yf(e.a)),e}set rgb(e){this._rgb=D6(e)}rgbString(){return this._valid?dst(this._rgb):void 0}hexString(){return this._valid?Qrt(this._rgb):void 0}hslString(){return this._valid?lst(this._rgb):void 0}mix(e,t){if(e){const r=this.rgb,s=e.rgb;let i;const o=t===i?.5:t,a=2*o-1,l=r.a-s.a,c=((a*l===-1?a:(a+l)/(1+a*l))+1)/2;i=1-c,r.r=255&c*r.r+i*s.r+.5,r.g=255&c*r.g+i*s.g+.5,r.b=255&c*r.b+i*s.b+.5,r.a=o*r.a+(1-o)*s.a,this.rgb=r}return this}interpolate(e,t){return e&&(this._rgb=pst(this._rgb,e._rgb,t)),this}clone(){return new YO(this.rgb)}alpha(e){return this._rgb.a=jd(e),this}clearer(e){const t=this._rgb;return t.a*=1-e,this}greyscale(){const e=this._rgb,t=MC(e.r*.3+e.g*.59+e.b*.11);return e.r=e.g=e.b=t,this}opaquer(e){const t=this._rgb;return t.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return fT(this._rgb,2,e),this}darken(e){return fT(this._rgb,2,-e),this}saturate(e){return fT(this._rgb,1,e),this}desaturate(e){return fT(this._rgb,1,-e),this}rotate(e){return ast(this._rgb,e),this}};/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */function tf(){}const gst=(()=>{let n=0;return()=>n++})();function Nr(n){return n===null||typeof n>"u"}function gs(n){if(Array.isArray&&Array.isArray(n))return!0;const e=Object.prototype.toString.call(n);return e.slice(0,7)==="[object"&&e.slice(-6)==="Array]"}function nr(n){return n!==null&&Object.prototype.toString.call(n)==="[object Object]"}function Zs(n){return(typeof n=="number"||n instanceof Number)&&isFinite(+n)}function pl(n,e){return Zs(n)?n:e}function Un(n,e){return typeof n>"u"?e:n}const yst=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100:+n/e,ose=(n,e)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100*e:+n;function is(n,e,t){if(n&&typeof n.call=="function")return n.apply(t,e)}function Dr(n,e,t,r){let s,i,o;if(gs(n))if(i=n.length,r)for(s=i-1;s>=0;s--)e.call(t,n[s],s);else for(s=0;s<i;s++)e.call(t,n[s],s);else if(nr(n))for(o=Object.keys(n),i=o.length,s=0;s<i;s++)e.call(t,n[o[s]],o[s])}function lA(n,e){let t,r,s,i;if(!n||!e||n.length!==e.length)return!1;for(t=0,r=n.length;t<r;++t)if(s=n[t],i=e[t],s.datasetIndex!==i.datasetIndex||s.index!==i.index)return!1;return!0}function cA(n){if(gs(n))return n.map(cA);if(nr(n)){const e=Object.create(null),t=Object.keys(n),r=t.length;let s=0;for(;s<r;++s)e[t[s]]=cA(n[t[s]]);return e}return n}function ase(n){return["__proto__","prototype","constructor"].indexOf(n)===-1}function bst(n,e,t,r){if(!ase(n))return;const s=e[n],i=t[n];nr(s)&&nr(i)?Z_(s,i,r):e[n]=cA(i)}function Z_(n,e,t){const r=gs(e)?e:[e],s=r.length;if(!nr(n))return n;t=t||{};const i=t.merger||bst;let o;for(let a=0;a<s;++a){if(o=r[a],!nr(o))continue;const l=Object.keys(o);for(let c=0,u=l.length;c<u;++c)i(l[c],n,o,t)}return n}function Q1(n,e){return Z_(n,e,{merger:vst})}function vst(n,e,t){if(!ase(n))return;const r=e[n],s=t[n];nr(r)&&nr(s)?Q1(r,s):Object.prototype.hasOwnProperty.call(e,n)||(e[n]=cA(s))}const O6={"":n=>n,x:n=>n.x,y:n=>n.y};function wst(n){const e=n.split("."),t=[];let r="";for(const s of e)r+=s,r.endsWith("\\")?r=r.slice(0,-1)+".":(t.push(r),r="");return t}function xst(n){const e=wst(n);return t=>{for(const r of e){if(r==="")break;t=t&&t[r]}return t}}function dp(n,e){return(O6[e]||(O6[e]=xst(e)))(n)}function T4(n){return n.charAt(0).toUpperCase()+n.slice(1)}const Ec=n=>typeof n<"u",pp=n=>typeof n=="function",F6=(n,e)=>{if(n.size!==e.size)return!1;for(const t of n)if(!e.has(t))return!1;return!0};function _st(n){return n.type==="mouseup"||n.type==="click"||n.type==="contextmenu"}const Ts=Math.PI,bs=2*Ts,Sst=bs+Ts,uA=Number.POSITIVE_INFINITY,Cst=Ts/180,Js=Ts/2,im=Ts/4,L6=Ts*2/3,Dd=Math.log10,yh=Math.sign;function e_(n,e,t){return Math.abs(n-e)<t}function z6(n){const e=Math.round(n);n=e_(n,e,n/1e3)?e:n;const t=Math.pow(10,Math.floor(Dd(n))),r=n/t;return(r<=1?1:r<=2?2:r<=5?5:10)*t}function kst(n){const e=[],t=Math.sqrt(n);let r;for(r=1;r<t;r++)n%r===0&&(e.push(r),e.push(n/r));return t===(t|0)&&e.push(t),e.sort((s,i)=>s-i).pop(),e}function ov(n){return!isNaN(parseFloat(n))&&isFinite(n)}function Tst(n,e){const t=Math.round(n);return t-e<=n&&t+e>=n}function lse(n,e,t){let r,s,i;for(r=0,s=n.length;r<s;r++)i=n[r][t],isNaN(i)||(e.min=Math.min(e.min,i),e.max=Math.max(e.max,i))}function hu(n){return n*(Ts/180)}function E4(n){return n*(180/Ts)}function B6(n){if(!Zs(n))return;let e=1,t=0;for(;Math.round(n*e)/e!==n;)e*=10,t++;return t}function cse(n,e){const t=e.x-n.x,r=e.y-n.y,s=Math.sqrt(t*t+r*r);let i=Math.atan2(r,t);return i<-.5*Ts&&(i+=bs),{angle:i,distance:s}}function ZO(n,e){return Math.sqrt(Math.pow(e.x-n.x,2)+Math.pow(e.y-n.y,2))}function Est(n,e){return(n-e+Sst)%bs-Ts}function ml(n){return(n%bs+bs)%bs}function J_(n,e,t,r){const s=ml(n),i=ml(e),o=ml(t),a=ml(i-s),l=ml(o-s),c=ml(s-i),u=ml(s-o);return s===i||s===o||r&&i===o||a>l&&c<u}function Xo(n,e,t){return Math.max(e,Math.min(t,n))}function Ist(n){return Xo(n,-32768,32767)}function Cf(n,e,t,r=1e-6){return n>=Math.min(e,t)-r&&n<=Math.max(e,t)+r}function I4(n,e,t){t=t||(o=>n[o]<e);let r=n.length-1,s=0,i;for(;r-s>1;)i=s+r>>1,t(i)?s=i:r=i;return{lo:s,hi:r}}const Bm=(n,e,t,r)=>I4(n,t,r?s=>{const i=n[s][e];return i<t||i===t&&n[s+1][e]===t}:s=>n[s][e]<t),Ast=(n,e,t)=>I4(n,t,r=>n[r][e]>=t);function Mst(n,e,t){let r=0,s=n.length;for(;r<s&&n[r]<e;)r++;for(;s>r&&n[s-1]>t;)s--;return r>0||s<n.length?n.slice(r,s):n}const use=["push","pop","shift","splice","unshift"];function Nst(n,e){if(n._chartjs){n._chartjs.listeners.push(e);return}Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),use.forEach(t=>{const r="_onData"+T4(t),s=n[t];Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value(...i){const o=s.apply(this,i);return n._chartjs.listeners.forEach(a=>{typeof a[r]=="function"&&a[r](...i)}),o}})})}function V6(n,e){const t=n._chartjs;if(!t)return;const r=t.listeners,s=r.indexOf(e);s!==-1&&r.splice(s,1),!(r.length>0)&&(use.forEach(i=>{delete n[i]}),delete n._chartjs)}function hse(n){const e=new Set;let t,r;for(t=0,r=n.length;t<r;++t)e.add(n[t]);return e.size===r?n:Array.from(e)}const fse=function(){return typeof window>"u"?function(n){return n()}:window.requestAnimationFrame}();function dse(n,e){let t=[],r=!1;return function(...s){t=s,r||(r=!0,fse.call(window,()=>{r=!1,n.apply(e,t)}))}}function $st(n,e){let t;return function(...r){return e?(clearTimeout(t),t=setTimeout(n,e,r)):n.apply(this,r),e}}const A4=n=>n==="start"?"left":n==="end"?"right":"center",Lo=(n,e,t)=>n==="start"?e:n==="end"?t:(e+t)/2,Rst=(n,e,t,r)=>n===(r?"left":"right")?t:n==="center"?(e+t)/2:e;function pse(n,e,t){const r=e.length;let s=0,i=r;if(n._sorted){const{iScale:o,_parsed:a}=n,l=o.axis,{min:c,max:u,minDefined:h,maxDefined:f}=o.getUserBounds();h&&(s=Xo(Math.min(Bm(a,o.axis,c).lo,t?r:Bm(e,l,o.getPixelForValue(c)).lo),0,r-1)),f?i=Xo(Math.max(Bm(a,o.axis,u,!0).hi+1,t?0:Bm(e,l,o.getPixelForValue(u),!0).hi+1),s,r)-s:i=r-s}return{start:s,count:i}}function mse(n){const{xScale:e,yScale:t,_scaleRanges:r}=n,s={xmin:e.min,xmax:e.max,ymin:t.min,ymax:t.max};if(!r)return n._scaleRanges=s,!0;const i=r.xmin!==e.min||r.xmax!==e.max||r.ymin!==t.min||r.ymax!==t.max;return Object.assign(r,s),i}const dT=n=>n===0||n===1,U6=(n,e,t)=>-(Math.pow(2,10*(n-=1))*Math.sin((n-e)*bs/t)),W6=(n,e,t)=>Math.pow(2,-10*n)*Math.sin((n-e)*bs/t)+1,t_={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>-Math.cos(n*Js)+1,easeOutSine:n=>Math.sin(n*Js),easeInOutSine:n=>-.5*(Math.cos(Ts*n)-1),easeInExpo:n=>n===0?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>n===1?1:-Math.pow(2,-10*n)+1,easeInOutExpo:n=>dT(n)?n:n<.5?.5*Math.pow(2,10*(n*2-1)):.5*(-Math.pow(2,-10*(n*2-1))+2),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>dT(n)?n:U6(n,.075,.3),easeOutElastic:n=>dT(n)?n:W6(n,.075,.3),easeInOutElastic(n){return dT(n)?n:n<.5?.5*U6(n*2,.1125,.45):.5+.5*W6(n*2-1,.1125,.45)},easeInBack(n){return n*n*((1.70158+1)*n-1.70158)},easeOutBack(n){return(n-=1)*n*((1.70158+1)*n+1.70158)+1},easeInOutBack(n){let e=1.70158;return(n/=.5)<1?.5*(n*n*(((e*=1.525)+1)*n-e)):.5*((n-=2)*n*(((e*=1.525)+1)*n+e)+2)},easeInBounce:n=>1-t_.easeOutBounce(1-n),easeOutBounce(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},easeInOutBounce:n=>n<.5?t_.easeInBounce(n*2)*.5:t_.easeOutBounce(n*2-1)*.5+.5};function gse(n){if(n&&typeof n=="object"){const e=n.toString();return e==="[object CanvasPattern]"||e==="[object CanvasGradient]"}return!1}function G6(n){return gse(n)?n:new ise(n)}function N3(n){return gse(n)?n:new ise(n).saturate(.5).darken(.1).hexString()}const Pst=["x","y","borderWidth","radius","tension"],Dst=["color","borderColor","backgroundColor"];function Ost(n){n.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),n.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>e!=="onProgress"&&e!=="onComplete"&&e!=="fn"}),n.set("animations",{colors:{type:"color",properties:Dst},numbers:{type:"number",properties:Pst}}),n.describe("animations",{_fallback:"animation"}),n.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>e|0}}}})}function Fst(n){n.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}const H6=new Map;function Lst(n,e){e=e||{};const t=n+JSON.stringify(e);let r=H6.get(t);return r||(r=new Intl.NumberFormat(n,e),H6.set(t,r)),r}function NC(n,e,t){return Lst(e,t).format(n)}const yse={values(n){return gs(n)?n:""+n},numeric(n,e,t){if(n===0)return"0";const r=this.chart.options.locale;let s,i=n;if(t.length>1){const c=Math.max(Math.abs(t[0].value),Math.abs(t[t.length-1].value));(c<1e-4||c>1e15)&&(s="scientific"),i=zst(n,t)}const o=Dd(Math.abs(i)),a=Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:s,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),NC(n,r,l)},logarithmic(n,e,t){if(n===0)return"0";const r=t[e].significand||n/Math.pow(10,Math.floor(Dd(n)));return[1,2,3,5,10,15].includes(r)||e>.8*t.length?yse.numeric.call(this,n,e,t):""}};function zst(n,e){let t=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;return Math.abs(t)>=1&&n!==Math.floor(n)&&(t=n-Math.floor(n)),t}var g$={formatters:yse};function Bst(n){n.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:g$.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),n.route("scale.ticks","color","","color"),n.route("scale.grid","color","","borderColor"),n.route("scale.border","color","","borderColor"),n.route("scale.title","color","","color"),n.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&e!=="callback"&&e!=="parser",_indexable:e=>e!=="borderDash"&&e!=="tickBorderDash"&&e!=="dash"}),n.describe("scales",{_fallback:"scale"}),n.describe("scale.ticks",{_scriptable:e=>e!=="backdropPadding"&&e!=="callback",_indexable:e=>e!=="backdropPadding"})}const gg=Object.create(null),JO=Object.create(null);function n_(n,e){if(!e)return n;const t=e.split(".");for(let r=0,s=t.length;r<s;++r){const i=t[r];n=n[i]||(n[i]=Object.create(null))}return n}function $3(n,e,t){return typeof e=="string"?Z_(n_(n,e),t):Z_(n_(n,""),e)}class Vst{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=r=>r.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(r,s)=>N3(s.backgroundColor),this.hoverBorderColor=(r,s)=>N3(s.borderColor),this.hoverColor=(r,s)=>N3(s.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return $3(this,e,t)}get(e){return n_(this,e)}describe(e,t){return $3(JO,e,t)}override(e,t){return $3(gg,e,t)}route(e,t,r,s){const i=n_(this,e),o=n_(this,r),a="_"+t;Object.defineProperties(i,{[a]:{value:i[t],writable:!0},[t]:{enumerable:!0,get(){const l=this[a],c=o[s];return nr(l)?Object.assign({},c,l):Un(l,c)},set(l){this[a]=l}}})}apply(e){e.forEach(t=>t(this))}}var ai=new Vst({_scriptable:n=>!n.startsWith("on"),_indexable:n=>n!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[Ost,Fst,Bst]);function Ust(n){return!n||Nr(n.size)||Nr(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}function hA(n,e,t,r,s){let i=e[s];return i||(i=e[s]=n.measureText(s).width,t.push(s)),i>r&&(r=i),r}function Wst(n,e,t,r){r=r||{};let s=r.data=r.data||{},i=r.garbageCollect=r.garbageCollect||[];r.font!==e&&(s=r.data={},i=r.garbageCollect=[],r.font=e),n.save(),n.font=e;let o=0;const a=t.length;let l,c,u,h,f;for(l=0;l<a;l++)if(h=t[l],h!=null&&gs(h)!==!0)o=hA(n,s,i,o,h);else if(gs(h))for(c=0,u=h.length;c<u;c++)f=h[c],f!=null&&!gs(f)&&(o=hA(n,s,i,o,f));n.restore();const d=i.length/2;if(d>t.length){for(l=0;l<d;l++)delete s[i[l]];i.splice(0,d)}return o}function om(n,e,t){const r=n.currentDevicePixelRatio,s=t!==0?Math.max(t/2,.5):0;return Math.round((e-s)*r)/r+s}function j6(n,e){e=e||n.getContext("2d"),e.save(),e.resetTransform(),e.clearRect(0,0,n.width,n.height),e.restore()}function QO(n,e,t,r){bse(n,e,t,r,null)}function bse(n,e,t,r,s){let i,o,a,l,c,u,h,f;const d=e.pointStyle,p=e.rotation,m=e.radius;let g=(p||0)*Cst;if(d&&typeof d=="object"&&(i=d.toString(),i==="[object HTMLImageElement]"||i==="[object HTMLCanvasElement]")){n.save(),n.translate(t,r),n.rotate(g),n.drawImage(d,-d.width/2,-d.height/2,d.width,d.height),n.restore();return}if(!(isNaN(m)||m<=0)){switch(n.beginPath(),d){default:s?n.ellipse(t,r,s/2,m,0,0,bs):n.arc(t,r,m,0,bs),n.closePath();break;case"triangle":u=s?s/2:m,n.moveTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=L6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),g+=L6,n.lineTo(t+Math.sin(g)*u,r-Math.cos(g)*m),n.closePath();break;case"rectRounded":c=m*.516,l=m-c,o=Math.cos(g+im)*l,h=Math.cos(g+im)*(s?s/2-c:l),a=Math.sin(g+im)*l,f=Math.sin(g+im)*(s?s/2-c:l),n.arc(t-h,r-a,c,g-Ts,g-Js),n.arc(t+f,r-o,c,g-Js,g),n.arc(t+h,r+a,c,g,g+Js),n.arc(t-f,r+o,c,g+Js,g+Ts),n.closePath();break;case"rect":if(!p){l=Math.SQRT1_2*m,u=s?s/2:l,n.rect(t-u,r-l,2*u,2*l);break}g+=im;case"rectRot":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+f,r-o),n.lineTo(t+h,r+a),n.lineTo(t-f,r+o),n.closePath();break;case"crossRot":g+=im;case"cross":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"star":h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o),g+=im,h=Math.cos(g)*(s?s/2:m),o=Math.cos(g)*m,a=Math.sin(g)*m,f=Math.sin(g)*(s?s/2:m),n.moveTo(t-h,r-a),n.lineTo(t+h,r+a),n.moveTo(t+f,r-o),n.lineTo(t-f,r+o);break;case"line":o=s?s/2:Math.cos(g)*m,a=Math.sin(g)*m,n.moveTo(t-o,r-a),n.lineTo(t+o,r+a);break;case"dash":n.moveTo(t,r),n.lineTo(t+Math.cos(g)*(s?s/2:m),r+Math.sin(g)*m);break;case!1:n.closePath();break}n.fill(),e.borderWidth>0&&n.stroke()}}function Q_(n,e,t){return t=t||.5,!e||n&&n.x>e.left-t&&n.x<e.right+t&&n.y>e.top-t&&n.y<e.bottom+t}function y$(n,e){n.save(),n.beginPath(),n.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),n.clip()}function b$(n){n.restore()}function Gst(n,e,t,r,s){if(!e)return n.lineTo(t.x,t.y);if(s==="middle"){const i=(e.x+t.x)/2;n.lineTo(i,e.y),n.lineTo(i,t.y)}else s==="after"!=!!r?n.lineTo(e.x,t.y):n.lineTo(t.x,e.y);n.lineTo(t.x,t.y)}function Hst(n,e,t,r){if(!e)return n.lineTo(t.x,t.y);n.bezierCurveTo(r?e.cp1x:e.cp2x,r?e.cp1y:e.cp2y,r?t.cp2x:t.cp1x,r?t.cp2y:t.cp1y,t.x,t.y)}function yg(n,e,t,r,s,i={}){const o=gs(e)?e:[e],a=i.strokeWidth>0&&i.strokeColor!=="";let l,c;for(n.save(),n.font=s.string,jst(n,i),l=0;l<o.length;++l)c=o[l],i.backdrop&&Xst(n,i.backdrop),a&&(i.strokeColor&&(n.strokeStyle=i.strokeColor),Nr(i.strokeWidth)||(n.lineWidth=i.strokeWidth),n.strokeText(c,t,r,i.maxWidth)),n.fillText(c,t,r,i.maxWidth),qst(n,t,r,c,i),r+=s.lineHeight;n.restore()}function jst(n,e){e.translation&&n.translate(e.translation[0],e.translation[1]),Nr(e.rotation)||n.rotate(e.rotation),e.color&&(n.fillStyle=e.color),e.textAlign&&(n.textAlign=e.textAlign),e.textBaseline&&(n.textBaseline=e.textBaseline)}function qst(n,e,t,r,s){if(s.strikethrough||s.underline){const i=n.measureText(r),o=e-i.actualBoundingBoxLeft,a=e+i.actualBoundingBoxRight,l=t-i.actualBoundingBoxAscent,c=t+i.actualBoundingBoxDescent,u=s.strikethrough?(l+c)/2:c;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=s.decorationWidth||2,n.moveTo(o,u),n.lineTo(a,u),n.stroke()}}function Xst(n,e){const t=n.fillStyle;n.fillStyle=e.color,n.fillRect(e.left,e.top,e.width,e.height),n.fillStyle=t}function qd(n,e){const{x:t,y:r,w:s,h:i,radius:o}=e;n.arc(t+o.topLeft,r+o.topLeft,o.topLeft,-Js,Ts,!0),n.lineTo(t,r+i-o.bottomLeft),n.arc(t+o.bottomLeft,r+i-o.bottomLeft,o.bottomLeft,Ts,Js,!0),n.lineTo(t+s-o.bottomRight,r+i),n.arc(t+s-o.bottomRight,r+i-o.bottomRight,o.bottomRight,Js,0,!0),n.lineTo(t+s,r+o.topRight),n.arc(t+s-o.topRight,r+o.topRight,o.topRight,0,-Js,!0),n.lineTo(t+o.topLeft,r)}const Kst=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,Yst=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function Zst(n,e){const t=(""+n).match(Kst);if(!t||t[1]==="normal")return e*1.2;switch(n=+t[2],t[3]){case"px":return n;case"%":n/=100;break}return e*n}const Jst=n=>+n||0;function M4(n,e){const t={},r=nr(e),s=r?Object.keys(e):e,i=nr(n)?r?o=>Un(n[o],n[e[o]]):o=>n[o]:()=>n;for(const o of s)t[o]=Jst(i(o));return t}function vse(n){return M4(n,{top:"y",right:"x",bottom:"y",left:"x"})}function Xd(n){return M4(n,["topLeft","topRight","bottomLeft","bottomRight"])}function Jo(n){const e=vse(n);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Gi(n,e){n=n||{},e=e||ai.font;let t=Un(n.size,e.size);typeof t=="string"&&(t=parseInt(t,10));let r=Un(n.style,e.style);r&&!(""+r).match(Yst)&&(console.warn('Invalid font style specified: "'+r+'"'),r=void 0);const s={family:Un(n.family,e.family),lineHeight:Zst(Un(n.lineHeight,e.lineHeight),t),size:t,style:r,weight:Un(n.weight,e.weight),string:""};return s.string=Ust(s),s}function pT(n,e,t,r){let s=!0,i,o,a;for(i=0,o=n.length;i<o;++i)if(a=n[i],a!==void 0&&(e!==void 0&&typeof a=="function"&&(a=a(e),s=!1),t!==void 0&&gs(a)&&(a=a[t%a.length],s=!1),a!==void 0))return r&&!s&&(r.cacheable=!1),a}function Qst(n,e,t){const{min:r,max:s}=n,i=ose(e,(s-r)/2),o=(a,l)=>t&&a===0?0:a+l;return{min:o(r,-Math.abs(i)),max:o(s,i)}}function Lp(n,e){return Object.assign(Object.create(n),e)}function N4(n,e=[""],t=n,r,s=()=>n[0]){Ec(r)||(r=Sse("_fallback",n));const i={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:t,_fallback:r,_getTarget:s,override:o=>N4([o,...n],e,t,r)};return new Proxy(i,{deleteProperty(o,a){return delete o[a],delete o._keys,delete n[0][a],!0},get(o,a){return xse(o,a,()=>ait(a,e,n,o))},getOwnPropertyDescriptor(o,a){return Reflect.getOwnPropertyDescriptor(o._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(n[0])},has(o,a){return X6(o).includes(a)},ownKeys(o){return X6(o)},set(o,a,l){const c=o._storage||(o._storage=s());return o[a]=c[a]=l,delete o._keys,!0}})}function av(n,e,t,r){const s={_cacheable:!1,_proxy:n,_context:e,_subProxy:t,_stack:new Set,_descriptors:wse(n,r),setContext:i=>av(n,i,t,r),override:i=>av(n.override(i),e,t,r)};return new Proxy(s,{deleteProperty(i,o){return delete i[o],delete n[o],!0},get(i,o,a){return xse(i,o,()=>tit(i,o,a))},getOwnPropertyDescriptor(i,o){return i._descriptors.allKeys?Reflect.has(n,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,o)},getPrototypeOf(){return Reflect.getPrototypeOf(n)},has(i,o){return Reflect.has(n,o)},ownKeys(){return Reflect.ownKeys(n)},set(i,o,a){return n[o]=a,delete i[o],!0}})}function wse(n,e={scriptable:!0,indexable:!0}){const{_scriptable:t=e.scriptable,_indexable:r=e.indexable,_allKeys:s=e.allKeys}=n;return{allKeys:s,scriptable:t,indexable:r,isScriptable:pp(t)?t:()=>t,isIndexable:pp(r)?r:()=>r}}const eit=(n,e)=>n?n+T4(e):e,$4=(n,e)=>nr(e)&&n!=="adapters"&&(Object.getPrototypeOf(e)===null||e.constructor===Object);function xse(n,e,t){if(Object.prototype.hasOwnProperty.call(n,e))return n[e];const r=t();return n[e]=r,r}function tit(n,e,t){const{_proxy:r,_context:s,_subProxy:i,_descriptors:o}=n;let a=r[e];return pp(a)&&o.isScriptable(e)&&(a=nit(e,a,n,t)),gs(a)&&a.length&&(a=rit(e,a,n,o.isIndexable)),$4(e,a)&&(a=av(a,s,i&&i[e],o)),a}function nit(n,e,t,r){const{_proxy:s,_context:i,_subProxy:o,_stack:a}=t;if(a.has(n))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+n);return a.add(n),e=e(i,o||r),a.delete(n),$4(n,e)&&(e=R4(s._scopes,s,n,e)),e}function rit(n,e,t,r){const{_proxy:s,_context:i,_subProxy:o,_descriptors:a}=t;if(Ec(i.index)&&r(n))e=e[i.index%e.length];else if(nr(e[0])){const l=e,c=s._scopes.filter(u=>u!==l);e=[];for(const u of l){const h=R4(c,s,n,u);e.push(av(h,i,o&&o[n],a))}}return e}function _se(n,e,t){return pp(n)?n(e,t):n}const sit=(n,e)=>n===!0?e:typeof n=="string"?dp(e,n):void 0;function iit(n,e,t,r,s){for(const i of e){const o=sit(t,i);if(o){n.add(o);const a=_se(o._fallback,t,s);if(Ec(a)&&a!==t&&a!==r)return a}else if(o===!1&&Ec(r)&&t!==r)return null}return!1}function R4(n,e,t,r){const s=e._rootScopes,i=_se(e._fallback,t,r),o=[...n,...s],a=new Set;a.add(r);let l=q6(a,o,t,i||t,r);return l===null||Ec(i)&&i!==t&&(l=q6(a,o,i,l,r),l===null)?!1:N4(Array.from(a),[""],s,i,()=>oit(e,t,r))}function q6(n,e,t,r,s){for(;t;)t=iit(n,e,t,r,s);return t}function oit(n,e,t){const r=n._getTarget();e in r||(r[e]={});const s=r[e];return gs(s)&&nr(t)?t:s||{}}function ait(n,e,t,r){let s;for(const i of e)if(s=Sse(eit(i,n),t),Ec(s))return $4(n,s)?R4(t,r,n,s):s}function Sse(n,e){for(const t of e){if(!t)continue;const r=t[n];if(Ec(r))return r}}function X6(n){let e=n._keys;return e||(e=n._keys=lit(n._scopes)),e}function lit(n){const e=new Set;for(const t of n)for(const r of Object.keys(t).filter(s=>!s.startsWith("_")))e.add(r);return Array.from(e)}function Cse(n,e,t,r){const{iScale:s}=n,{key:i="r"}=this._parsing,o=new Array(r);let a,l,c,u;for(a=0,l=r;a<l;++a)c=a+t,u=e[c],o[a]={r:s.parse(dp(u,i),c)};return o}const cit=Number.EPSILON||1e-14,lv=(n,e)=>e<n.length&&!n[e].skip&&n[e],kse=n=>n==="x"?"y":"x";function uit(n,e,t,r){const s=n.skip?e:n,i=e,o=t.skip?e:t,a=ZO(i,s),l=ZO(o,i);let c=a/(a+l),u=l/(a+l);c=isNaN(c)?0:c,u=isNaN(u)?0:u;const h=r*c,f=r*u;return{previous:{x:i.x-h*(o.x-s.x),y:i.y-h*(o.y-s.y)},next:{x:i.x+f*(o.x-s.x),y:i.y+f*(o.y-s.y)}}}function hit(n,e,t){const r=n.length;let s,i,o,a,l,c=lv(n,0);for(let u=0;u<r-1;++u)if(l=c,c=lv(n,u+1),!(!l||!c)){if(e_(e[u],0,cit)){t[u]=t[u+1]=0;continue}s=t[u]/e[u],i=t[u+1]/e[u],a=Math.pow(s,2)+Math.pow(i,2),!(a<=9)&&(o=3/Math.sqrt(a),t[u]=s*o*e[u],t[u+1]=i*o*e[u])}}function fit(n,e,t="x"){const r=kse(t),s=n.length;let i,o,a,l=lv(n,0);for(let c=0;c<s;++c){if(o=a,a=l,l=lv(n,c+1),!a)continue;const u=a[t],h=a[r];o&&(i=(u-o[t])/3,a[`cp1${t}`]=u-i,a[`cp1${r}`]=h-i*e[c]),l&&(i=(l[t]-u)/3,a[`cp2${t}`]=u+i,a[`cp2${r}`]=h+i*e[c])}}function dit(n,e="x"){const t=kse(e),r=n.length,s=Array(r).fill(0),i=Array(r);let o,a,l,c=lv(n,0);for(o=0;o<r;++o)if(a=l,l=c,c=lv(n,o+1),!!l){if(c){const u=c[e]-l[e];s[o]=u!==0?(c[t]-l[t])/u:0}i[o]=a?c?yh(s[o-1])!==yh(s[o])?0:(s[o-1]+s[o])/2:s[o-1]:s[o]}hit(n,s,i),fit(n,i,e)}function mT(n,e,t){return Math.max(Math.min(n,t),e)}function pit(n,e){let t,r,s,i,o,a=Q_(n[0],e);for(t=0,r=n.length;t<r;++t)o=i,i=a,a=t<r-1&&Q_(n[t+1],e),i&&(s=n[t],o&&(s.cp1x=mT(s.cp1x,e.left,e.right),s.cp1y=mT(s.cp1y,e.top,e.bottom)),a&&(s.cp2x=mT(s.cp2x,e.left,e.right),s.cp2y=mT(s.cp2y,e.top,e.bottom)))}function mit(n,e,t,r,s){let i,o,a,l;if(e.spanGaps&&(n=n.filter(c=>!c.skip)),e.cubicInterpolationMode==="monotone")dit(n,s);else{let c=r?n[n.length-1]:n[0];for(i=0,o=n.length;i<o;++i)a=n[i],l=uit(c,a,n[Math.min(i+1,o-(r?0:1))%o],e.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}e.capBezierPoints&&pit(n,t)}function Tse(){return typeof window<"u"&&typeof document<"u"}function P4(n){let e=n.parentNode;return e&&e.toString()==="[object ShadowRoot]"&&(e=e.host),e}function fA(n,e,t){let r;return typeof n=="string"?(r=parseInt(n,10),n.indexOf("%")!==-1&&(r=r/100*e.parentNode[t])):r=n,r}const v$=n=>n.ownerDocument.defaultView.getComputedStyle(n,null);function git(n,e){return v$(n).getPropertyValue(e)}const yit=["top","right","bottom","left"];function Km(n,e,t){const r={};t=t?"-"+t:"";for(let s=0;s<4;s++){const i=yit[s];r[i]=parseFloat(n[e+"-"+i+t])||0}return r.width=r.left+r.right,r.height=r.top+r.bottom,r}const bit=(n,e,t)=>(n>0||e>0)&&(!t||!t.shadowRoot);function vit(n,e){const t=n.touches,r=t&&t.length?t[0]:n,{offsetX:s,offsetY:i}=r;let o=!1,a,l;if(bit(s,i,n.target))a=s,l=i;else{const c=e.getBoundingClientRect();a=r.clientX-c.left,l=r.clientY-c.top,o=!0}return{x:a,y:l,box:o}}function _m(n,e){if("native"in n)return n;const{canvas:t,currentDevicePixelRatio:r}=e,s=v$(t),i=s.boxSizing==="border-box",o=Km(s,"padding"),a=Km(s,"border","width"),{x:l,y:c,box:u}=vit(n,t),h=o.left+(u&&a.left),f=o.top+(u&&a.top);let{width:d,height:p}=e;return i&&(d-=o.width+a.width,p-=o.height+a.height),{x:Math.round((l-h)/d*t.width/r),y:Math.round((c-f)/p*t.height/r)}}function wit(n,e,t){let r,s;if(e===void 0||t===void 0){const i=P4(n);if(!i)e=n.clientWidth,t=n.clientHeight;else{const o=i.getBoundingClientRect(),a=v$(i),l=Km(a,"border","width"),c=Km(a,"padding");e=o.width-c.width-l.width,t=o.height-c.height-l.height,r=fA(a.maxWidth,i,"clientWidth"),s=fA(a.maxHeight,i,"clientHeight")}}return{width:e,height:t,maxWidth:r||uA,maxHeight:s||uA}}const gT=n=>Math.round(n*10)/10;function xit(n,e,t,r){const s=v$(n),i=Km(s,"margin"),o=fA(s.maxWidth,n,"clientWidth")||uA,a=fA(s.maxHeight,n,"clientHeight")||uA,l=wit(n,e,t);let{width:c,height:u}=l;if(s.boxSizing==="content-box"){const f=Km(s,"border","width"),d=Km(s,"padding");c-=d.width+f.width,u-=d.height+f.height}return c=Math.max(0,c-i.width),u=Math.max(0,r?c/r:u-i.height),c=gT(Math.min(c,o,l.maxWidth)),u=gT(Math.min(u,a,l.maxHeight)),c&&!u&&(u=gT(c/2)),(e!==void 0||t!==void 0)&&r&&l.height&&u>l.height&&(u=l.height,c=gT(Math.floor(u*r))),{width:c,height:u}}function K6(n,e,t){const r=e||1,s=Math.floor(n.height*r),i=Math.floor(n.width*r);n.height=Math.floor(n.height),n.width=Math.floor(n.width);const o=n.canvas;return o.style&&(t||!o.style.height&&!o.style.width)&&(o.style.height=`${n.height}px`,o.style.width=`${n.width}px`),n.currentDevicePixelRatio!==r||o.height!==s||o.width!==i?(n.currentDevicePixelRatio=r,o.height=s,o.width=i,n.ctx.setTransform(r,0,0,r,0,0),!0):!1}const _it=function(){let n=!1;try{const e={get passive(){return n=!0,!1}};window.addEventListener("test",null,e),window.removeEventListener("test",null,e)}catch{}return n}();function Y6(n,e){const t=git(n,e),r=t&&t.match(/^(\d+)(\.\d+)?px$/);return r?+r[1]:void 0}function Sm(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:n.y+t*(e.y-n.y)}}function Sit(n,e,t,r){return{x:n.x+t*(e.x-n.x),y:r==="middle"?t<.5?n.y:e.y:r==="after"?t<1?n.y:e.y:t>0?e.y:n.y}}function Cit(n,e,t,r){const s={x:n.cp2x,y:n.cp2y},i={x:e.cp1x,y:e.cp1y},o=Sm(n,s,t),a=Sm(s,i,t),l=Sm(i,e,t),c=Sm(o,a,t),u=Sm(a,l,t);return Sm(c,u,t)}const kit=function(n,e){return{x(t){return n+n+e-t},setWidth(t){e=t},textAlign(t){return t==="center"?t:t==="right"?"left":"right"},xPlus(t,r){return t-r},leftForLtr(t,r){return t-r}}},Tit=function(){return{x(n){return n},setWidth(n){},textAlign(n){return n},xPlus(n,e){return n+e},leftForLtr(n,e){return n}}};function $b(n,e,t){return n?kit(e,t):Tit()}function Ese(n,e){let t,r;(e==="ltr"||e==="rtl")&&(t=n.canvas.style,r=[t.getPropertyValue("direction"),t.getPropertyPriority("direction")],t.setProperty("direction",e,"important"),n.prevTextDirection=r)}function Ise(n,e){e!==void 0&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",e[0],e[1]))}function Ase(n){return n==="angle"?{between:J_,compare:Est,normalize:ml}:{between:Cf,compare:(e,t)=>e-t,normalize:e=>e}}function Z6({start:n,end:e,count:t,loop:r,style:s}){return{start:n%t,end:e%t,loop:r&&(e-n+1)%t===0,style:s}}function Eit(n,e,t){const{property:r,start:s,end:i}=t,{between:o,normalize:a}=Ase(r),l=e.length;let{start:c,end:u,loop:h}=n,f,d;if(h){for(c+=l,u+=l,f=0,d=l;f<d&&o(a(e[c%l][r]),s,i);++f)c--,u--;c%=l,u%=l}return u<c&&(u+=l),{start:c,end:u,loop:h,style:n.style}}function Mse(n,e,t){if(!t)return[n];const{property:r,start:s,end:i}=t,o=e.length,{compare:a,between:l,normalize:c}=Ase(r),{start:u,end:h,loop:f,style:d}=Eit(n,e,t),p=[];let m=!1,g=null,y,b,x;const w=()=>l(s,x,y)&&a(s,x)!==0,S=()=>a(i,y)===0||l(i,x,y),C=()=>m||w(),k=()=>!m||S();for(let A=u,M=u;A<=h;++A)b=e[A%o],!b.skip&&(y=c(b[r]),y!==x&&(m=l(y,s,i),g===null&&C()&&(g=a(y,s)===0?A:M),g!==null&&k()&&(p.push(Z6({start:g,end:A,loop:f,count:o,style:d})),g=null),M=A,x=y));return g!==null&&p.push(Z6({start:g,end:h,loop:f,count:o,style:d})),p}function Nse(n,e){const t=[],r=n.segments;for(let s=0;s<r.length;s++){const i=Mse(r[s],n.points,e);i.length&&t.push(...i)}return t}function Iit(n,e,t,r){let s=0,i=e-1;if(t&&!r)for(;s<e&&!n[s].skip;)s++;for(;s<e&&n[s].skip;)s++;for(s%=e,t&&(i+=s);i>s&&n[i%e].skip;)i--;return i%=e,{start:s,end:i}}function Ait(n,e,t,r){const s=n.length,i=[];let o=e,a=n[e],l;for(l=e+1;l<=t;++l){const c=n[l%s];c.skip||c.stop?a.skip||(r=!1,i.push({start:e%s,end:(l-1)%s,loop:r}),e=o=c.stop?l:null):(o=l,a.skip&&(e=l)),a=c}return o!==null&&i.push({start:e%s,end:o%s,loop:r}),i}function Mit(n,e){const t=n.points,r=n.options.spanGaps,s=t.length;if(!s)return[];const i=!!n._loop,{start:o,end:a}=Iit(t,s,i,r);if(r===!0)return J6(n,[{start:o,end:a,loop:i}],t,e);const l=a<o?a+s:a,c=!!n._fullLoop&&o===0&&a===s-1;return J6(n,Ait(t,o,l,c),t,e)}function J6(n,e,t,r){return!r||!r.setContext||!t?e:Nit(n,e,t,r)}function Nit(n,e,t,r){const s=n._chart.getContext(),i=Q6(n.options),{_datasetIndex:o,options:{spanGaps:a}}=n,l=t.length,c=[];let u=i,h=e[0].start,f=h;function d(p,m,g,y){const b=a?-1:1;if(p!==m){for(p+=l;t[p%l].skip;)p-=b;for(;t[m%l].skip;)m+=b;p%l!==m%l&&(c.push({start:p%l,end:m%l,loop:g,style:y}),u=y,h=m%l)}}for(const p of e){h=a?h:p.start;let m=t[h%l],g;for(f=h+1;f<=p.end;f++){const y=t[f%l];g=Q6(r.setContext(Lp(s,{type:"segment",p0:m,p1:y,p0DataIndex:(f-1)%l,p1DataIndex:f%l,datasetIndex:o}))),$it(g,u)&&d(h,f-1,p.loop,u),m=y,u=g}h<f-1&&d(h,f-1,p.loop,u)}return c}function Q6(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function $it(n,e){return e&&JSON.stringify(n)!==JSON.stringify(e)}/*!
 * Chart.js v4.2.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */class Rit{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,r,s){const i=t.listeners[s],o=t.duration;i.forEach(a=>a({chart:e,initial:t.initial,numSteps:o,currentStep:Math.min(r-t.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=fse.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(e=Date.now()){let t=0;this._charts.forEach((r,s)=>{if(!r.running||!r.items.length)return;const i=r.items;let o=i.length-1,a=!1,l;for(;o>=0;--o)l=i[o],l._active?(l._total>r.duration&&(r.duration=l._total),l.tick(e),a=!0):(i[o]=i[i.length-1],i.pop());a&&(s.draw(),this._notify(s,r,e,"progress")),i.length||(r.running=!1,this._notify(s,r,e,"complete"),r.initial=!1),t+=i.length}),this._lastDate=e,t===0&&(this._running=!1)}_getAnims(e){const t=this._charts;let r=t.get(e);return r||(r={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,r)),r}listen(e,t,r){this._getAnims(e).listeners[t].push(r)}add(e,t){!t||!t.length||this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce((r,s)=>Math.max(r,s._duration),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!(!t||!t.running||!t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const r=t.items;let s=r.length-1;for(;s>=0;--s)r[s].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var cf=new Rit;const e5="transparent",Pit={boolean(n,e,t){return t>.5?e:n},color(n,e,t){const r=G6(n||e5),s=r.valid&&G6(e||e5);return s&&s.valid?s.mix(r,t).hexString():e},number(n,e,t){return n+(e-n)*t}};class Dit{constructor(e,t,r,s){const i=t[r];s=pT([e.to,s,i,e.from]);const o=pT([e.from,i,s]);this._active=!0,this._fn=e.fn||Pit[e.type||typeof o],this._easing=t_[e.easing]||t_.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=r,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(e,t,r){if(this._active){this._notify(!1);const s=this._target[this._prop],i=r-this._start,o=this._duration-i;this._start=r,this._duration=Math.floor(Math.max(o,e.duration)),this._total+=i,this._loop=!!e.loop,this._to=pT([e.to,t,s,e.from]),this._from=pT([e.from,s,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,r=this._duration,s=this._prop,i=this._from,o=this._loop,a=this._to;let l;if(this._active=i!==a&&(o||t<r),!this._active){this._target[s]=a,this._notify(!0);return}if(t<0){this._target[s]=i;return}l=t/r%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[s]=this._fn(i,a,l)}wait(){const e=this._promises||(this._promises=[]);return new Promise((t,r)=>{e.push({res:t,rej:r})})}_notify(e){const t=e?"res":"rej",r=this._promises||[];for(let s=0;s<r.length;s++)r[s][t]()}}class $se{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!nr(e))return;const t=Object.keys(ai.animation),r=this._properties;Object.getOwnPropertyNames(e).forEach(s=>{const i=e[s];if(!nr(i))return;const o={};for(const a of t)o[a]=i[a];(gs(i.properties)&&i.properties||[s]).forEach(a=>{(a===s||!r.has(a))&&r.set(a,o)})})}_animateOptions(e,t){const r=t.options,s=Fit(e,r);if(!s)return[];const i=this._createAnimations(s,r);return r.$shared&&Oit(e.options.$animations,r).then(()=>{e.options=r},()=>{}),i}_createAnimations(e,t){const r=this._properties,s=[],i=e.$animations||(e.$animations={}),o=Object.keys(t),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if(c.charAt(0)==="$")continue;if(c==="options"){s.push(...this._animateOptions(e,t));continue}const u=t[c];let h=i[c];const f=r.get(c);if(h)if(f&&h.active()){h.update(f,u,a);continue}else h.cancel();if(!f||!f.duration){e[c]=u;continue}i[c]=h=new Dit(f,e,c,u),s.push(h)}return s}update(e,t){if(this._properties.size===0){Object.assign(e,t);return}const r=this._createAnimations(e,t);if(r.length)return cf.add(this._chart,r),!0}}function Oit(n,e){const t=[],r=Object.keys(e);for(let s=0;s<r.length;s++){const i=n[r[s]];i&&i.active()&&t.push(i.wait())}return Promise.all(t)}function Fit(n,e){if(!e)return;let t=n.options;if(!t){n.options=e;return}return t.$shared&&(n.options=t=Object.assign({},t,{$shared:!1,$animations:{}})),t}function t5(n,e){const t=n&&n.options||{},r=t.reverse,s=t.min===void 0?e:0,i=t.max===void 0?e:0;return{start:r?i:s,end:r?s:i}}function Lit(n,e,t){if(t===!1)return!1;const r=t5(n,t),s=t5(e,t);return{top:s.end,right:r.end,bottom:s.start,left:r.start}}function zit(n){let e,t,r,s;return nr(n)?(e=n.top,t=n.right,r=n.bottom,s=n.left):e=t=r=s=n,{top:e,right:t,bottom:r,left:s,disabled:n===!1}}function Rse(n,e){const t=[],r=n._getSortedDatasetMetas(e);let s,i;for(s=0,i=r.length;s<i;++s)t.push(r[s].index);return t}function n5(n,e,t,r={}){const s=n.keys,i=r.mode==="single";let o,a,l,c;if(e!==null){for(o=0,a=s.length;o<a;++o){if(l=+s[o],l===t){if(r.all)continue;break}c=n.values[l],Zs(c)&&(i||e===0||yh(e)===yh(c))&&(e+=c)}return e}}function Bit(n){const e=Object.keys(n),t=new Array(e.length);let r,s,i;for(r=0,s=e.length;r<s;++r)i=e[r],t[r]={x:i,y:n[i]};return t}function r5(n,e){const t=n&&n.options.stacked;return t||t===void 0&&e.stack!==void 0}function Vit(n,e,t){return`${n.id}.${e.id}.${t.stack||t.type}`}function Uit(n){const{min:e,max:t,minDefined:r,maxDefined:s}=n.getUserBounds();return{min:r?e:Number.NEGATIVE_INFINITY,max:s?t:Number.POSITIVE_INFINITY}}function Wit(n,e,t){const r=n[e]||(n[e]={});return r[t]||(r[t]={})}function s5(n,e,t,r){for(const s of e.getMatchingVisibleMetas(r).reverse()){const i=n[s.index];if(t&&i>0||!t&&i<0)return s.index}return null}function i5(n,e){const{chart:t,_cachedMeta:r}=n,s=t._stacks||(t._stacks={}),{iScale:i,vScale:o,index:a}=r,l=i.axis,c=o.axis,u=Vit(i,o,r),h=e.length;let f;for(let d=0;d<h;++d){const p=e[d],{[l]:m,[c]:g}=p,y=p._stacks||(p._stacks={});f=y[c]=Wit(s,u,m),f[a]=g,f._top=s5(f,o,!0,r.type),f._bottom=s5(f,o,!1,r.type);const b=f._visualValues||(f._visualValues={});b[a]=g}}function R3(n,e){const t=n.scales;return Object.keys(t).filter(r=>t[r].axis===e).shift()}function Git(n,e){return Lp(n,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}function Hit(n,e,t){return Lp(n,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:t,index:e,mode:"default",type:"data"})}function Xx(n,e){const t=n.controller.index,r=n.vScale&&n.vScale.axis;if(r){e=e||n._parsed;for(const s of e){const i=s._stacks;if(!i||i[r]===void 0||i[r][t]===void 0)return;delete i[r][t],i[r]._visualValues!==void 0&&i[r]._visualValues[t]!==void 0&&delete i[r]._visualValues[t]}}}const P3=n=>n==="reset"||n==="none",o5=(n,e)=>e?n:Object.assign({},n),jit=(n,e,t)=>n&&!e.hidden&&e._stacked&&{keys:Rse(t,!0),values:null};class wc{constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=r5(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&Xx(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,r=this.getDataset(),s=(h,f,d,p)=>h==="x"?f:h==="r"?p:d,i=t.xAxisID=Un(r.xAxisID,R3(e,"x")),o=t.yAxisID=Un(r.yAxisID,R3(e,"y")),a=t.rAxisID=Un(r.rAxisID,R3(e,"r")),l=t.indexAxis,c=t.iAxisID=s(l,i,o,a),u=t.vAxisID=s(l,o,i,a);t.xScale=this.getScaleForId(i),t.yScale=this.getScaleForId(o),t.rScale=this.getScaleForId(a),t.iScale=this.getScaleForId(c),t.vScale=this.getScaleForId(u)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&V6(this._data,this),e._stacked&&Xx(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),r=this._data;if(nr(t))this._data=Bit(t);else if(r!==t){if(r){V6(r,this);const s=this._cachedMeta;Xx(s),s._parsed=[]}t&&Object.isExtensible(t)&&Nst(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,r=this.getDataset();let s=!1;this._dataCheck();const i=t._stacked;t._stacked=r5(t.vScale,t),t.stack!==r.stack&&(s=!0,Xx(t),t.stack=r.stack),this._resyncElements(e),(s||i!==t._stacked)&&i5(this,t._parsed)}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),r=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(r,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:r,_data:s}=this,{iScale:i,_stacked:o}=r,a=i.axis;let l=e===0&&t===s.length?!0:r._sorted,c=e>0&&r._parsed[e-1],u,h,f;if(this._parsing===!1)r._parsed=s,r._sorted=!0,f=s;else{gs(s[e])?f=this.parseArrayData(r,s,e,t):nr(s[e])?f=this.parseObjectData(r,s,e,t):f=this.parsePrimitiveData(r,s,e,t);const d=()=>h[a]===null||c&&h[a]<c[a];for(u=0;u<t;++u)r._parsed[u+e]=h=f[u],l&&(d()&&(l=!1),c=h);r._sorted=l}o&&i5(this,f)}parsePrimitiveData(e,t,r,s){const{iScale:i,vScale:o}=e,a=i.axis,l=o.axis,c=i.getLabels(),u=i===o,h=new Array(s);let f,d,p;for(f=0,d=s;f<d;++f)p=f+r,h[f]={[a]:u||i.parse(c[p],p),[l]:o.parse(t[p],p)};return h}parseArrayData(e,t,r,s){const{xScale:i,yScale:o}=e,a=new Array(s);let l,c,u,h;for(l=0,c=s;l<c;++l)u=l+r,h=t[u],a[l]={x:i.parse(h[0],u),y:o.parse(h[1],u)};return a}parseObjectData(e,t,r,s){const{xScale:i,yScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=new Array(s);let u,h,f,d;for(u=0,h=s;u<h;++u)f=u+r,d=t[f],c[u]={x:i.parse(dp(d,a),f),y:o.parse(dp(d,l),f)};return c}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,r){const s=this.chart,i=this._cachedMeta,o=t[e.axis],a={keys:Rse(s,!0),values:t._stacks[e.axis]._visualValues};return n5(a,o,i.index,{mode:r})}updateRangeFromParsed(e,t,r,s){const i=r[t.axis];let o=i===null?NaN:i;const a=s&&r._stacks[t.axis];s&&a&&(s.values=a,o=n5(s,i,this._cachedMeta.index)),e.min=Math.min(e.min,o),e.max=Math.max(e.max,o)}getMinMax(e,t){const r=this._cachedMeta,s=r._parsed,i=r._sorted&&e===r.iScale,o=s.length,a=this._getOtherScale(e),l=jit(t,r,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:u,max:h}=Uit(a);let f,d;function p(){d=s[f];const m=d[a.axis];return!Zs(d[e.axis])||u>m||h<m}for(f=0;f<o&&!(!p()&&(this.updateRangeFromParsed(c,e,d,l),i));++f);if(i){for(f=o-1;f>=0;--f)if(!p()){this.updateRangeFromParsed(c,e,d,l);break}}return c}getAllParsedValues(e){const t=this._cachedMeta._parsed,r=[];let s,i,o;for(s=0,i=t.length;s<i;++s)o=t[s][e.axis],Zs(o)&&r.push(o);return r}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,r=t.iScale,s=t.vScale,i=this.getParsed(e);return{label:r?""+r.getLabelForValue(i[r.axis]):"",value:s?""+s.getLabelForValue(i[s.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=zit(Un(this.options.clip,Lit(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,r=this._cachedMeta,s=r.data||[],i=t.chartArea,o=[],a=this._drawStart||0,l=this._drawCount||s.length-a,c=this.options.drawActiveElementsOnTop;let u;for(r.dataset&&r.dataset.draw(e,i,a,l),u=a;u<a+l;++u){const h=s[u];h.hidden||(h.active&&c?o.push(h):h.draw(e,i))}for(u=0;u<o.length;++u)o[u].draw(e,i)}getStyle(e,t){const r=t?"active":"default";return e===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(r):this.resolveDataElementOptions(e||0,r)}getContext(e,t,r){const s=this.getDataset();let i;if(e>=0&&e<this._cachedMeta.data.length){const o=this._cachedMeta.data[e];i=o.$context||(o.$context=Hit(this.getContext(),e,o)),i.parsed=this.getParsed(e),i.raw=s.data[e],i.index=i.dataIndex=e}else i=this.$context||(this.$context=Git(this.chart.getContext(),this.index)),i.dataset=s,i.index=i.datasetIndex=this.index;return i.active=!!t,i.mode=r,i}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e,t="default",r){const s=t==="active",i=this._cachedDataOpts,o=e+"-"+t,a=i[o],l=this.enableOptionSharing&&Ec(r);if(a)return o5(a,l);const c=this.chart.config,u=c.datasetElementScopeKeys(this._type,e),h=s?[`${e}Hover`,"hover",e,""]:[e,""],f=c.getOptionScopes(this.getDataset(),u),d=Object.keys(ai.elements[e]),p=()=>this.getContext(r,s,t),m=c.resolveNamedOptions(f,d,p,h);return m.$shared&&(m.$shared=l,i[o]=Object.freeze(o5(m,l))),m}_resolveAnimations(e,t,r){const s=this.chart,i=this._cachedDataOpts,o=`animation-${t}`,a=i[o];if(a)return a;let l;if(s.options.animation!==!1){const u=this.chart.config,h=u.datasetAnimationScopeKeys(this._type,t),f=u.getOptionScopes(this.getDataset(),h);l=u.createResolver(f,this.getContext(e,r,t))}const c=new $se(s,l&&l.animations);return l&&l._cacheable&&(i[o]=Object.freeze(c)),c}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||P3(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const r=this.resolveDataElementOptions(e,t),s=this._sharedOptions,i=this.getSharedOptions(r),o=this.includeOptions(t,i)||i!==s;return this.updateSharedOptions(i,t,r),{sharedOptions:i,includeOptions:o}}updateElement(e,t,r,s){P3(s)?Object.assign(e,r):this._resolveAnimations(t,s).update(e,r)}updateSharedOptions(e,t,r){e&&!P3(t)&&this._resolveAnimations(void 0,t).update(e,r)}_setStyle(e,t,r,s){e.active=s;const i=this.getStyle(t,s);this._resolveAnimations(t,r,s).update(e,{options:!s&&this.getSharedOptions(i)||i})}removeHoverStyle(e,t,r){this._setStyle(e,r,"active",!1)}setHoverStyle(e,t,r){this._setStyle(e,r,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,r=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const s=r.length,i=t.length,o=Math.min(i,s);o&&this.parse(0,o),i>s?this._insertElements(s,i-s,e):i<s&&this._removeElements(i,s-i)}_insertElements(e,t,r=!0){const s=this._cachedMeta,i=s.data,o=e+t;let a;const l=c=>{for(c.length+=t,a=c.length-1;a>=o;a--)c[a]=c[a-t]};for(l(i),a=e;a<o;++a)i[a]=new this.dataElementType;this._parsing&&l(s._parsed),this.parse(e,t),r&&this.updateElements(i,e,t,"reset")}updateElements(e,t,r,s){}_removeElements(e,t){const r=this._cachedMeta;if(this._parsing){const s=r._parsed.splice(e,t);r._stacked&&Xx(r,s)}r.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,r,s]=e;this[t](r,s)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const r=arguments.length-2;r&&this._sync(["_insertElements",e,r])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}Mt(wc,"defaults",{}),Mt(wc,"datasetElementType",null),Mt(wc,"dataElementType",null);function qit(n,e){if(!n._cache.$bar){const t=n.getMatchingVisibleMetas(e);let r=[];for(let s=0,i=t.length;s<i;s++)r=r.concat(t[s].controller.getAllParsedValues(n));n._cache.$bar=hse(r.sort((s,i)=>s-i))}return n._cache.$bar}function Xit(n){const e=n.iScale,t=qit(e,n.type);let r=e._length,s,i,o,a;const l=()=>{o===32767||o===-32768||(Ec(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,i=t.length;s<i;++s)o=e.getPixelForValue(t[s]),l();for(a=void 0,s=0,i=e.ticks.length;s<i;++s)o=e.getPixelForTick(s),l();return r}function Kit(n,e,t,r){const s=t.barThickness;let i,o;return Nr(s)?(i=e.min*t.categoryPercentage,o=t.barPercentage):(i=s*r,o=1),{chunk:i/r,ratio:o,start:e.pixels[n]-i/2}}function Yit(n,e,t,r){const s=e.pixels,i=s[n];let o=n>0?s[n-1]:null,a=n<s.length-1?s[n+1]:null;const l=t.categoryPercentage;o===null&&(o=i-(a===null?e.end-e.start:a-i)),a===null&&(a=i+i-o);const c=i-(i-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/r,ratio:t.barPercentage,start:c}}function Zit(n,e,t,r){const s=t.parse(n[0],r),i=t.parse(n[1],r),o=Math.min(s,i),a=Math.max(s,i);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),e[t.axis]=c,e._custom={barStart:l,barEnd:c,start:s,end:i,min:o,max:a}}function Pse(n,e,t,r){return gs(n)?Zit(n,e,t,r):e[t.axis]=t.parse(n,r),e}function a5(n,e,t,r){const s=n.iScale,i=n.vScale,o=s.getLabels(),a=s===i,l=[];let c,u,h,f;for(c=t,u=t+r;c<u;++c)f=e[c],h={},h[s.axis]=a||s.parse(o[c],c),l.push(Pse(f,h,i,c));return l}function D3(n){return n&&n.barStart!==void 0&&n.barEnd!==void 0}function Jit(n,e,t){return n!==0?yh(n):(e.isHorizontal()?1:-1)*(e.min>=t?1:-1)}function Qit(n){let e,t,r,s,i;return n.horizontal?(e=n.base>n.x,t="left",r="right"):(e=n.base<n.y,t="bottom",r="top"),e?(s="end",i="start"):(s="start",i="end"),{start:t,end:r,reverse:e,top:s,bottom:i}}function eot(n,e,t,r){let s=e.borderSkipped;const i={};if(!s){n.borderSkipped=i;return}if(s===!0){n.borderSkipped={top:!0,right:!0,bottom:!0,left:!0};return}const{start:o,end:a,reverse:l,top:c,bottom:u}=Qit(n);s==="middle"&&t&&(n.enableBorderRadius=!0,(t._top||0)===r?s=c:(t._bottom||0)===r?s=u:(i[l5(u,o,a,l)]=!0,s=c)),i[l5(s,o,a,l)]=!0,n.borderSkipped=i}function l5(n,e,t,r){return r?(n=tot(n,e,t),n=c5(n,t,e)):n=c5(n,e,t),n}function tot(n,e,t){return n===e?t:n===t?e:n}function c5(n,e,t){return n==="start"?e:n==="end"?t:n}function not(n,{inflateAmount:e},t){n.inflateAmount=e==="auto"?t===1?.33:0:e}class VE extends wc{parsePrimitiveData(e,t,r,s){return a5(e,t,r,s)}parseArrayData(e,t,r,s){return a5(e,t,r,s)}parseObjectData(e,t,r,s){const{iScale:i,vScale:o}=e,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=i.axis==="x"?a:l,u=o.axis==="x"?a:l,h=[];let f,d,p,m;for(f=r,d=r+s;f<d;++f)m=t[f],p={},p[i.axis]=i.parse(dp(m,c),f),h.push(Pse(dp(m,u),p,o,f));return h}updateRangeFromParsed(e,t,r,s){super.updateRangeFromParsed(e,t,r,s);const i=r._custom;i&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,i.min),e.max=Math.max(e.max,i.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:r,vScale:s}=t,i=this.getParsed(e),o=i._custom,a=D3(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(i[s.axis]);return{label:""+r.getLabelForValue(i[r.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const e=this._cachedMeta;e.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,r,s){const i=s==="reset",{index:o,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),u=this._getRuler(),{sharedOptions:h,includeOptions:f}=this._getSharedOptions(t,s);for(let d=t;d<t+r;d++){const p=this.getParsed(d),m=i||Nr(p[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(d),g=this._calculateBarIndexPixels(d,u),y=(p._stacks||{})[a.axis],b={horizontal:c,base:m.base,enableBorderRadius:!y||D3(p._custom)||o===y._top||o===y._bottom,x:c?m.head:g.center,y:c?g.center:m.head,height:c?g.size:Math.abs(m.size),width:c?Math.abs(m.size):g.size};f&&(b.options=h||this.resolveDataElementOptions(d,e[d].active?"active":s));const x=b.options||e[d].options;eot(b,x,y,o),not(b,x,u.ratio),this.updateElement(e[d],d,b,s)}}_getStacks(e,t){const{iScale:r}=this._cachedMeta,s=r.getMatchingVisibleMetas(this._type).filter(l=>l.controller.options.grouped),i=r.options.stacked,o=[],a=l=>{const c=l.controller.getParsed(t),u=c&&c[l.vScale.axis];if(Nr(u)||isNaN(u))return!0};for(const l of s)if(!(t!==void 0&&a(l))&&((i===!1||o.indexOf(l.stack)===-1||i===void 0&&l.stack===void 0)&&o.push(l.stack),l.index===e))break;return o.length||o.push(void 0),o}_getStackCount(e){return this._getStacks(void 0,e).length}_getStackIndex(e,t,r){const s=this._getStacks(e,r),i=t!==void 0?s.indexOf(t):-1;return i===-1?s.length-1:i}_getRuler(){const e=this.options,t=this._cachedMeta,r=t.iScale,s=[];let i,o;for(i=0,o=t.data.length;i<o;++i)s.push(r.getPixelForValue(this.getParsed(i)[r.axis],i));const a=e.barThickness;return{min:a||Xit(t),pixels:s,start:r._startPixel,end:r._endPixel,stackCount:this._getStackCount(),scale:r,grouped:e.grouped,ratio:a?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:r,index:s},options:{base:i,minBarLength:o}}=this,a=i||0,l=this.getParsed(e),c=l._custom,u=D3(c);let h=l[t.axis],f=0,d=r?this.applyStack(t,l,r):h,p,m;d!==h&&(f=d-h,d=h),u&&(h=c.barStart,d=c.barEnd-c.barStart,h!==0&&yh(h)!==yh(c.barEnd)&&(f=0),f+=h);const g=!Nr(i)&&!u?i:f;let y=t.getPixelForValue(g);if(this.chart.getDataVisibility(e)?p=t.getPixelForValue(f+d):p=y,m=p-y,Math.abs(m)<o){m=Jit(m,t,a)*o,h===a&&(y-=m/2);const b=t.getPixelForDecimal(0),x=t.getPixelForDecimal(1),w=Math.min(b,x),S=Math.max(b,x);y=Math.max(Math.min(y,S),w),p=y+m,r&&!u&&(l._stacks[t.axis]._visualValues[s]=t.getValueForPixel(p)-t.getValueForPixel(y))}if(y===t.getPixelForValue(a)){const b=yh(m)*t.getLineWidthForValue(a)/2;y+=b,m-=b}return{size:m,base:y,head:p,center:p+m/2}}_calculateBarIndexPixels(e,t){const r=t.scale,s=this.options,i=s.skipNull,o=Un(s.maxBarThickness,1/0);let a,l;if(t.grouped){const c=i?this._getStackCount(e):t.stackCount,u=s.barThickness==="flex"?Yit(e,t,s,c):Kit(e,t,s,c),h=this._getStackIndex(this.index,this._cachedMeta.stack,i?e:void 0);a=u.start+u.chunk*h+u.chunk/2,l=Math.min(o,u.chunk*u.ratio)}else a=r.getPixelForValue(this.getParsed(e)[r.axis],e),l=Math.min(o,t.min*t.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const e=this._cachedMeta,t=e.vScale,r=e.data,s=r.length;let i=0;for(;i<s;++i)this.getParsed(i)[t.axis]!==null&&r[i].draw(this._ctx)}}Mt(VE,"id","bar"),Mt(VE,"defaults",{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}}),Mt(VE,"overrides",{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}});class UE extends wc{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,r,s){const i=super.parsePrimitiveData(e,t,r,s);for(let o=0;o<i.length;o++)i[o]._custom=this.resolveDataElementOptions(o+r).radius;return i}parseArrayData(e,t,r,s){const i=super.parseArrayData(e,t,r,s);for(let o=0;o<i.length;o++){const a=t[r+o];i[o]._custom=Un(a[2],this.resolveDataElementOptions(o+r).radius)}return i}parseObjectData(e,t,r,s){const i=super.parseObjectData(e,t,r,s);for(let o=0;o<i.length;o++){const a=t[r+o];i[o]._custom=Un(a&&a.r&&+a.r,this.resolveDataElementOptions(o+r).radius)}return i}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let r=e.length-1;r>=0;--r)t=Math.max(t,e[r].size(this.resolveDataElementOptions(r))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:s,yScale:i}=t,o=this.getParsed(e),a=s.getLabelForValue(o.x),l=i.getLabelForValue(o.y),c=o._custom;return{label:r[e]||"",value:"("+a+", "+l+(c?", "+c:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:l,includeOptions:c}=this._getSharedOptions(t,s),u=o.axis,h=a.axis;for(let f=t;f<t+r;f++){const d=e[f],p=!i&&this.getParsed(f),m={},g=m[u]=i?o.getPixelForDecimal(.5):o.getPixelForValue(p[u]),y=m[h]=i?a.getBasePixel():a.getPixelForValue(p[h]);m.skip=isNaN(g)||isNaN(y),c&&(m.options=l||this.resolveDataElementOptions(f,d.active?"active":s),i&&(m.options.radius=0)),this.updateElement(d,f,m,s)}}resolveDataElementOptions(e,t){const r=this.getParsed(e);let s=super.resolveDataElementOptions(e,t);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const i=s.radius;return t!=="active"&&(s.radius=0),s.radius+=Un(r&&r._custom,i),s}}Mt(UE,"id","bubble"),Mt(UE,"defaults",{datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}}),Mt(UE,"overrides",{scales:{x:{type:"linear"},y:{type:"linear"}}});function rot(n,e,t){let r=1,s=1,i=0,o=0;if(e<bs){const a=n,l=a+e,c=Math.cos(a),u=Math.sin(a),h=Math.cos(l),f=Math.sin(l),d=(x,w,S)=>J_(x,a,l,!0)?1:Math.max(w,w*t,S,S*t),p=(x,w,S)=>J_(x,a,l,!0)?-1:Math.min(w,w*t,S,S*t),m=d(0,c,h),g=d(Js,u,f),y=p(Ts,c,h),b=p(Ts+Js,u,f);r=(m-y)/2,s=(g-b)/2,i=-(m+y)/2,o=-(g+b)/2}return{ratioX:r,ratioY:s,offsetX:i,offsetY:o}}class xb extends wc{constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const r=this.getDataset().data,s=this._cachedMeta;if(this._parsing===!1)s._parsed=r;else{let i=l=>+r[l];if(nr(r[e])){const{key:l="value"}=this._parsing;i=c=>+dp(r[c],l)}let o,a;for(o=e,a=e+t;o<a;++o)s._parsed[o]=i(o)}}_getRotation(){return hu(this.options.rotation-90)}_getCircumference(){return hu(this.options.circumference)}_getRotationExtents(){let e=bs,t=-bs;for(let r=0;r<this.chart.data.datasets.length;++r)if(this.chart.isDatasetVisible(r)&&this.chart.getDatasetMeta(r).type===this._type){const s=this.chart.getDatasetMeta(r).controller,i=s._getRotation(),o=s._getCircumference();e=Math.min(e,i),t=Math.max(t,i+o)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:r}=t,s=this._cachedMeta,i=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(i)+this.options.spacing,a=Math.max((Math.min(r.width,r.height)-o)/2,0),l=Math.min(yst(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:u,rotation:h}=this._getRotationExtents(),{ratioX:f,ratioY:d,offsetX:p,offsetY:m}=rot(h,u,l),g=(r.width-o)/f,y=(r.height-o)/d,b=Math.max(Math.min(g,y)/2,0),x=ose(this.options.radius,b),w=Math.max(x*l,0),S=(x-w)/this._getVisibleDatasetWeightTotal();this.offsetX=p*x,this.offsetY=m*x,s.total=this.calculateTotal(),this.outerRadius=x-S*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-S*c,0),this.updateElements(i,0,i.length,e)}_circumference(e,t){const r=this.options,s=this._cachedMeta,i=this._getCircumference();return t&&r.animation.animateRotate||!this.chart.getDataVisibility(e)||s._parsed[e]===null||s.data[e].hidden?0:this.calculateCircumference(s._parsed[e]*i/bs)}updateElements(e,t,r,s){const i=s==="reset",o=this.chart,a=o.chartArea,c=o.options.animation,u=(a.left+a.right)/2,h=(a.top+a.bottom)/2,f=i&&c.animateScale,d=f?0:this.innerRadius,p=f?0:this.outerRadius,{sharedOptions:m,includeOptions:g}=this._getSharedOptions(t,s);let y=this._getRotation(),b;for(b=0;b<t;++b)y+=this._circumference(b,i);for(b=t;b<t+r;++b){const x=this._circumference(b,i),w=e[b],S={x:u+this.offsetX,y:h+this.offsetY,startAngle:y,endAngle:y+x,circumference:x,outerRadius:p,innerRadius:d};g&&(S.options=m||this.resolveDataElementOptions(b,w.active?"active":s)),y+=x,this.updateElement(w,b,S,s)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let r=0,s;for(s=0;s<t.length;s++){const i=e._parsed[s];i!==null&&!isNaN(i)&&this.chart.getDataVisibility(s)&&!t[s].hidden&&(r+=Math.abs(i))}return r}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?bs*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,s=r.data.labels||[],i=NC(t._parsed[e],r.options.locale);return{label:s[e]||"",value:i}}getMaxBorderWidth(e){let t=0;const r=this.chart;let s,i,o,a,l;if(!e){for(s=0,i=r.data.datasets.length;s<i;++s)if(r.isDatasetVisible(s)){o=r.getDatasetMeta(s),e=o.data,a=o.controller;break}}if(!e)return 0;for(s=0,i=e.length;s<i;++s)l=a.resolveDataElementOptions(s),l.borderAlign!=="inner"&&(t=Math.max(t,l.borderWidth||0,l.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let r=0,s=e.length;r<s;++r){const i=this.resolveDataElementOptions(r);t=Math.max(t,i.offset||0,i.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let r=0;r<e;++r)this.chart.isDatasetVisible(r)&&(t+=this._getRingWeight(r));return t}_getRingWeight(e){return Math.max(Un(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}Mt(xb,"id","doughnut"),Mt(xb,"defaults",{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"}),Mt(xb,"descriptors",{_scriptable:e=>e!=="spacing",_indexable:e=>e!=="spacing"}),Mt(xb,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:s}}=e.legend.options;return t.labels.map((i,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:i,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:s,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}}});class WE extends wc{initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:r,data:s=[],_dataset:i}=t,o=this.chart._animationsDisabled;let{start:a,count:l}=pse(t,s,o);this._drawStart=a,this._drawCount=l,mse(t)&&(a=0,l=s.length),r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!i._decimated,r.points=s;const c=this.resolveDatasetElementOptions(e);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(r,void 0,{animated:!o,options:c},e),this.updateElements(s,a,l,e)}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,{sharedOptions:u,includeOptions:h}=this._getSharedOptions(t,s),f=o.axis,d=a.axis,{spanGaps:p,segment:m}=this.options,g=ov(p)?p:Number.POSITIVE_INFINITY,y=this.chart._animationsDisabled||i||s==="none",b=t+r,x=e.length;let w=t>0&&this.getParsed(t-1);for(let S=0;S<x;++S){const C=e[S],k=y?C:{};if(S<t||S>=b){k.skip=!0;continue}const A=this.getParsed(S),M=Nr(A[d]),E=k[f]=o.getPixelForValue(A[f],S),N=k[d]=i||M?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,A,l):A[d],S);k.skip=isNaN(E)||isNaN(N)||M,k.stop=S>0&&Math.abs(A[f]-w[f])>g,m&&(k.parsed=A,k.raw=c.data[S]),h&&(k.options=u||this.resolveDataElementOptions(S,C.active?"active":s)),y||this.updateElement(C,S,k,s),w=A}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,r=t.options&&t.options.borderWidth||0,s=e.data||[];if(!s.length)return r;const i=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(r,i,o)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}Mt(WE,"id","line"),Mt(WE,"defaults",{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1}),Mt(WE,"overrides",{scales:{_index_:{type:"category"},_value_:{type:"linear"}}});class GE extends wc{constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,r=this.chart,s=r.data.labels||[],i=NC(t._parsed[e].r,r.options.locale);return{label:s[e]||"",value:i}}parseObjectData(e,t,r,s){return Cse.bind(this)(e,t,r,s)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach((r,s)=>{const i=this.getParsed(s).r;!isNaN(i)&&this.chart.getDataVisibility(s)&&(i<t.min&&(t.min=i),i>t.max&&(t.max=i))}),t}_updateRadius(){const e=this.chart,t=e.chartArea,r=e.options,s=Math.min(t.right-t.left,t.bottom-t.top),i=Math.max(s/2,0),o=Math.max(r.cutoutPercentage?i/100*r.cutoutPercentage:1,0),a=(i-o)/e.getVisibleDatasetCount();this.outerRadius=i-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(e,t,r,s){const i=s==="reset",o=this.chart,l=o.options.animation,c=this._cachedMeta.rScale,u=c.xCenter,h=c.yCenter,f=c.getIndexAngle(0)-.5*Ts;let d=f,p;const m=360/this.countVisibleElements();for(p=0;p<t;++p)d+=this._computeAngle(p,s,m);for(p=t;p<t+r;p++){const g=e[p];let y=d,b=d+this._computeAngle(p,s,m),x=o.getDataVisibility(p)?c.getDistanceFromCenterForValue(this.getParsed(p).r):0;d=b,i&&(l.animateScale&&(x=0),l.animateRotate&&(y=b=f));const w={x:u,y:h,innerRadius:0,outerRadius:x,startAngle:y,endAngle:b,options:this.resolveDataElementOptions(p,g.active?"active":s)};this.updateElement(g,p,w,s)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach((r,s)=>{!isNaN(this.getParsed(s).r)&&this.chart.getDataVisibility(s)&&t++}),t}_computeAngle(e,t,r){return this.chart.getDataVisibility(e)?hu(this.resolveDataElementOptions(e,t).angle||r):0}}Mt(GE,"id","polarArea"),Mt(GE,"defaults",{dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0}),Mt(GE,"overrides",{aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:r,color:s}}=e.legend.options;return t.labels.map((i,o)=>{const l=e.getDatasetMeta(0).controller.getStyle(o);return{text:i,fillStyle:l.backgroundColor,strokeStyle:l.borderColor,fontColor:s,lineWidth:l.borderWidth,pointStyle:r,hidden:!e.getDataVisibility(o),index:o}})}return[]}},onClick(e,t,r){r.chart.toggleDataVisibility(t.index),r.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}});class eF extends xb{}Mt(eF,"id","pie"),Mt(eF,"defaults",{cutout:0,rotation:0,circumference:360,radius:"100%"});class HE extends wc{getLabelAndValue(e){const t=this._cachedMeta.vScale,r=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(r[t.axis])}}parseObjectData(e,t,r,s){return Cse.bind(this)(e,t,r,s)}update(e){const t=this._cachedMeta,r=t.dataset,s=t.data||[],i=t.iScale.getLabels();if(r.points=s,e!=="resize"){const o=this.resolveDatasetElementOptions(e);this.options.showLine||(o.borderWidth=0);const a={_loop:!0,_fullLoop:i.length===s.length,options:o};this.updateElement(r,void 0,a,e)}this.updateElements(s,0,s.length,e)}updateElements(e,t,r,s){const i=this._cachedMeta.rScale,o=s==="reset";for(let a=t;a<t+r;a++){const l=e[a],c=this.resolveDataElementOptions(a,l.active?"active":s),u=i.getPointPositionForValue(a,this.getParsed(a).r),h=o?i.xCenter:u.x,f=o?i.yCenter:u.y,d={x:h,y:f,angle:u.angle,skip:isNaN(h)||isNaN(f),options:c};this.updateElement(l,a,d,s)}}}Mt(HE,"id","radar"),Mt(HE,"defaults",{datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}}),Mt(HE,"overrides",{aspectRatio:1,scales:{r:{type:"radialLinear"}}});class jE extends wc{getLabelAndValue(e){const t=this._cachedMeta,r=this.chart.data.labels||[],{xScale:s,yScale:i}=t,o=this.getParsed(e),a=s.getLabelForValue(o.x),l=i.getLabelForValue(o.y);return{label:r[e]||"",value:"("+a+", "+l+")"}}update(e){const t=this._cachedMeta,{data:r=[]}=t,s=this.chart._animationsDisabled;let{start:i,count:o}=pse(t,r,s);if(this._drawStart=i,this._drawCount=o,mse(t)&&(i=0,o=r.length),this.options.showLine){const{dataset:a,_dataset:l}=t;a._chart=this.chart,a._datasetIndex=this.index,a._decimated=!!l._decimated,a.points=r;const c=this.resolveDatasetElementOptions(e);c.segment=this.options.segment,this.updateElement(a,void 0,{animated:!s,options:c},e)}this.updateElements(r,i,o,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,r,s){const i=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,u=this.resolveDataElementOptions(t,s),h=this.getSharedOptions(u),f=this.includeOptions(s,h),d=o.axis,p=a.axis,{spanGaps:m,segment:g}=this.options,y=ov(m)?m:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||i||s==="none";let x=t>0&&this.getParsed(t-1);for(let w=t;w<t+r;++w){const S=e[w],C=this.getParsed(w),k=b?S:{},A=Nr(C[p]),M=k[d]=o.getPixelForValue(C[d],w),E=k[p]=i||A?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,C,l):C[p],w);k.skip=isNaN(M)||isNaN(E)||A,k.stop=w>0&&Math.abs(C[d]-x[d])>y,g&&(k.parsed=C,k.raw=c.data[w]),f&&(k.options=h||this.resolveDataElementOptions(w,S.active?"active":s)),b||this.updateElement(S,w,k,s),x=C}this.updateSharedOptions(h,s,u)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let a=0;for(let l=t.length-1;l>=0;--l)a=Math.max(a,t[l].size(this.resolveDataElementOptions(l))/2);return a>0&&a}const r=e.dataset,s=r.options&&r.options.borderWidth||0;if(!t.length)return s;const i=t[0].size(this.resolveDataElementOptions(0)),o=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(s,i,o)/2}}Mt(jE,"id","scatter"),Mt(jE,"defaults",{datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1}),Mt(jE,"overrides",{interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}});function am(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class D4{static override(e){Object.assign(D4.prototype,e)}constructor(e){this.options=e||{}}init(){}formats(){return am()}parse(){return am()}format(){return am()}add(){return am()}diff(){return am()}startOf(){return am()}endOf(){return am()}}var Dse={_date:D4};function sot(n,e,t,r){const{controller:s,data:i,_sorted:o}=n,a=s._cachedMeta.iScale;if(a&&e===a.axis&&e!=="r"&&o&&i.length){const l=a._reversePixels?Ast:Bm;if(r){if(s._sharedOptions){const c=i[0],u=typeof c.getRange=="function"&&c.getRange(e);if(u){const h=l(i,e,t-u),f=l(i,e,t+u);return{lo:h.lo,hi:f.hi}}}}else return l(i,e,t)}return{lo:0,hi:i.length-1}}function $C(n,e,t,r,s){const i=n.getSortedVisibleDatasetMetas(),o=t[e];for(let a=0,l=i.length;a<l;++a){const{index:c,data:u}=i[a],{lo:h,hi:f}=sot(i[a],e,o,s);for(let d=h;d<=f;++d){const p=u[d];p.skip||r(p,c,d)}}}function iot(n){const e=n.indexOf("x")!==-1,t=n.indexOf("y")!==-1;return function(r,s){const i=e?Math.abs(r.x-s.x):0,o=t?Math.abs(r.y-s.y):0;return Math.sqrt(Math.pow(i,2)+Math.pow(o,2))}}function O3(n,e,t,r,s){const i=[];return!s&&!n.isPointInArea(e)||$C(n,t,e,function(a,l,c){!s&&!Q_(a,n.chartArea,0)||a.inRange(e.x,e.y,r)&&i.push({element:a,datasetIndex:l,index:c})},!0),i}function oot(n,e,t,r){let s=[];function i(o,a,l){const{startAngle:c,endAngle:u}=o.getProps(["startAngle","endAngle"],r),{angle:h}=cse(o,{x:e.x,y:e.y});J_(h,c,u)&&s.push({element:o,datasetIndex:a,index:l})}return $C(n,t,e,i),s}function aot(n,e,t,r,s,i){let o=[];const a=iot(t);let l=Number.POSITIVE_INFINITY;function c(u,h,f){const d=u.inRange(e.x,e.y,s);if(r&&!d)return;const p=u.getCenterPoint(s);if(!(!!i||n.isPointInArea(p))&&!d)return;const g=a(e,p);g<l?(o=[{element:u,datasetIndex:h,index:f}],l=g):g===l&&o.push({element:u,datasetIndex:h,index:f})}return $C(n,t,e,c),o}function F3(n,e,t,r,s,i){return!i&&!n.isPointInArea(e)?[]:t==="r"&&!r?oot(n,e,t,s):aot(n,e,t,r,s,i)}function u5(n,e,t,r,s){const i=[],o=t==="x"?"inXRange":"inYRange";let a=!1;return $C(n,t,e,(l,c,u)=>{l[o](e[t],s)&&(i.push({element:l,datasetIndex:c,index:u}),a=a||l.inRange(e.x,e.y,s))}),r&&!a?[]:i}var lot={evaluateInteractionItems:$C,modes:{index(n,e,t,r){const s=_m(e,n),i=t.axis||"x",o=t.includeInvisible||!1,a=t.intersect?O3(n,s,i,r,o):F3(n,s,i,!1,r,o),l=[];return a.length?(n.getSortedVisibleDatasetMetas().forEach(c=>{const u=a[0].index,h=c.data[u];h&&!h.skip&&l.push({element:h,datasetIndex:c.index,index:u})}),l):[]},dataset(n,e,t,r){const s=_m(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;let a=t.intersect?O3(n,s,i,r,o):F3(n,s,i,!1,r,o);if(a.length>0){const l=a[0].datasetIndex,c=n.getDatasetMeta(l).data;a=[];for(let u=0;u<c.length;++u)a.push({element:c[u],datasetIndex:l,index:u})}return a},point(n,e,t,r){const s=_m(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;return O3(n,s,i,r,o)},nearest(n,e,t,r){const s=_m(e,n),i=t.axis||"xy",o=t.includeInvisible||!1;return F3(n,s,i,t.intersect,r,o)},x(n,e,t,r){const s=_m(e,n);return u5(n,s,"x",t.intersect,r)},y(n,e,t,r){const s=_m(e,n);return u5(n,s,"y",t.intersect,r)}}};const Ose=["left","top","right","bottom"];function Kx(n,e){return n.filter(t=>t.pos===e)}function h5(n,e){return n.filter(t=>Ose.indexOf(t.pos)===-1&&t.box.axis===e)}function Yx(n,e){return n.sort((t,r)=>{const s=e?r:t,i=e?t:r;return s.weight===i.weight?s.index-i.index:s.weight-i.weight})}function cot(n){const e=[];let t,r,s,i,o,a;for(t=0,r=(n||[]).length;t<r;++t)s=n[t],{position:i,options:{stack:o,stackWeight:a=1}}=s,e.push({index:t,box:s,pos:i,horizontal:s.isHorizontal(),weight:s.weight,stack:o&&i+o,stackWeight:a});return e}function uot(n){const e={};for(const t of n){const{stack:r,pos:s,stackWeight:i}=t;if(!r||!Ose.includes(s))continue;const o=e[r]||(e[r]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=i}return e}function hot(n,e){const t=uot(n),{vBoxMaxWidth:r,hBoxMaxHeight:s}=e;let i,o,a;for(i=0,o=n.length;i<o;++i){a=n[i];const{fullSize:l}=a.box,c=t[a.stack],u=c&&a.stackWeight/c.weight;a.horizontal?(a.width=u?u*r:l&&e.availableWidth,a.height=s):(a.width=r,a.height=u?u*s:l&&e.availableHeight)}return t}function fot(n){const e=cot(n),t=Yx(e.filter(c=>c.box.fullSize),!0),r=Yx(Kx(e,"left"),!0),s=Yx(Kx(e,"right")),i=Yx(Kx(e,"top"),!0),o=Yx(Kx(e,"bottom")),a=h5(e,"x"),l=h5(e,"y");return{fullSize:t,leftAndTop:r.concat(i),rightAndBottom:s.concat(l).concat(o).concat(a),chartArea:Kx(e,"chartArea"),vertical:r.concat(s).concat(l),horizontal:i.concat(o).concat(a)}}function f5(n,e,t,r){return Math.max(n[t],e[t])+Math.max(n[r],e[r])}function Fse(n,e){n.top=Math.max(n.top,e.top),n.left=Math.max(n.left,e.left),n.bottom=Math.max(n.bottom,e.bottom),n.right=Math.max(n.right,e.right)}function dot(n,e,t,r){const{pos:s,box:i}=t,o=n.maxPadding;if(!nr(s)){t.size&&(n[s]-=t.size);const h=r[t.stack]||{size:0,count:1};h.size=Math.max(h.size,t.horizontal?i.height:i.width),t.size=h.size/h.count,n[s]+=t.size}i.getPadding&&Fse(o,i.getPadding());const a=Math.max(0,e.outerWidth-f5(o,n,"left","right")),l=Math.max(0,e.outerHeight-f5(o,n,"top","bottom")),c=a!==n.w,u=l!==n.h;return n.w=a,n.h=l,t.horizontal?{same:c,other:u}:{same:u,other:c}}function pot(n){const e=n.maxPadding;function t(r){const s=Math.max(e[r]-n[r],0);return n[r]+=s,s}n.y+=t("top"),n.x+=t("left"),t("right"),t("bottom")}function mot(n,e){const t=e.maxPadding;function r(s){const i={left:0,top:0,right:0,bottom:0};return s.forEach(o=>{i[o]=Math.max(e[o],t[o])}),i}return r(n?["left","right"]:["top","bottom"])}function M1(n,e,t,r){const s=[];let i,o,a,l,c,u;for(i=0,o=n.length,c=0;i<o;++i){a=n[i],l=a.box,l.update(a.width||e.w,a.height||e.h,mot(a.horizontal,e));const{same:h,other:f}=dot(e,t,a,r);c|=h&&s.length,u=u||f,l.fullSize||s.push(a)}return c&&M1(s,e,t,r)||u}function yT(n,e,t,r,s){n.top=t,n.left=e,n.right=e+r,n.bottom=t+s,n.width=r,n.height=s}function d5(n,e,t,r){const s=t.padding;let{x:i,y:o}=e;for(const a of n){const l=a.box,c=r[a.stack]||{count:1,placed:0,weight:1},u=a.stackWeight/c.weight||1;if(a.horizontal){const h=e.w*u,f=c.size||l.height;Ec(c.start)&&(o=c.start),l.fullSize?yT(l,s.left,o,t.outerWidth-s.right-s.left,f):yT(l,e.left+c.placed,o,h,f),c.start=o,c.placed+=h,o=l.bottom}else{const h=e.h*u,f=c.size||l.width;Ec(c.start)&&(i=c.start),l.fullSize?yT(l,i,s.top,f,t.outerHeight-s.bottom-s.top):yT(l,i,e.top+c.placed,f,h),c.start=i,c.placed+=h,i=l.right}}e.x=i,e.y=o}var mc={addBox(n,e){n.boxes||(n.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},n.boxes.push(e)},removeBox(n,e){const t=n.boxes?n.boxes.indexOf(e):-1;t!==-1&&n.boxes.splice(t,1)},configure(n,e,t){e.fullSize=t.fullSize,e.position=t.position,e.weight=t.weight},update(n,e,t,r){if(!n)return;const s=Jo(n.options.layout.padding),i=Math.max(e-s.width,0),o=Math.max(t-s.height,0),a=fot(n.boxes),l=a.vertical,c=a.horizontal;Dr(n.boxes,m=>{typeof m.beforeLayout=="function"&&m.beforeLayout()});const u=l.reduce((m,g)=>g.box.options&&g.box.options.display===!1?m:m+1,0)||1,h=Object.freeze({outerWidth:e,outerHeight:t,padding:s,availableWidth:i,availableHeight:o,vBoxMaxWidth:i/2/u,hBoxMaxHeight:o/2}),f=Object.assign({},s);Fse(f,Jo(r));const d=Object.assign({maxPadding:f,w:i,h:o,x:s.left,y:s.top},s),p=hot(l.concat(c),h);M1(a.fullSize,d,h,p),M1(l,d,h,p),M1(c,d,h,p)&&M1(l,d,h,p),pot(d),d5(a.leftAndTop,d,h,p),d.x+=d.w,d.y+=d.h,d5(a.rightAndBottom,d,h,p),n.chartArea={left:d.left,top:d.top,right:d.left+d.w,bottom:d.top+d.h,height:d.h,width:d.w},Dr(a.chartArea,m=>{const g=m.box;Object.assign(g,n.chartArea),g.update(d.w,d.h,{left:0,top:0,right:0,bottom:0})})}};class Lse{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,r){}removeEventListener(e,t,r){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,r,s){return t=Math.max(0,t||e.width),r=r||e.height,{width:t,height:Math.max(0,s?Math.floor(t/s):r)}}isAttached(e){return!0}updateConfig(e){}}class got extends Lse{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const qE="$chartjs",yot={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},p5=n=>n===null||n==="";function bot(n,e){const t=n.style,r=n.getAttribute("height"),s=n.getAttribute("width");if(n[qE]={initial:{height:r,width:s,style:{display:t.display,height:t.height,width:t.width}}},t.display=t.display||"block",t.boxSizing=t.boxSizing||"border-box",p5(s)){const i=Y6(n,"width");i!==void 0&&(n.width=i)}if(p5(r))if(n.style.height==="")n.height=n.width/(e||2);else{const i=Y6(n,"height");i!==void 0&&(n.height=i)}return n}const zse=_it?{passive:!0}:!1;function vot(n,e,t){n.addEventListener(e,t,zse)}function wot(n,e,t){n.canvas.removeEventListener(e,t,zse)}function xot(n,e){const t=yot[n.type]||n.type,{x:r,y:s}=_m(n,e);return{type:t,chart:e,native:n,x:r!==void 0?r:null,y:s!==void 0?s:null}}function dA(n,e){for(const t of n)if(t===e||t.contains(e))return!0}function _ot(n,e,t){const r=n.canvas,s=new MutationObserver(i=>{let o=!1;for(const a of i)o=o||dA(a.addedNodes,r),o=o&&!dA(a.removedNodes,r);o&&t()});return s.observe(document,{childList:!0,subtree:!0}),s}function Sot(n,e,t){const r=n.canvas,s=new MutationObserver(i=>{let o=!1;for(const a of i)o=o||dA(a.removedNodes,r),o=o&&!dA(a.addedNodes,r);o&&t()});return s.observe(document,{childList:!0,subtree:!0}),s}const eS=new Map;let m5=0;function Bse(){const n=window.devicePixelRatio;n!==m5&&(m5=n,eS.forEach((e,t)=>{t.currentDevicePixelRatio!==n&&e()}))}function Cot(n,e){eS.size||window.addEventListener("resize",Bse),eS.set(n,e)}function kot(n){eS.delete(n),eS.size||window.removeEventListener("resize",Bse)}function Tot(n,e,t){const r=n.canvas,s=r&&P4(r);if(!s)return;const i=dse((a,l)=>{const c=s.clientWidth;t(a,l),c<s.clientWidth&&t()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,u=l.contentRect.height;c===0&&u===0||i(c,u)});return o.observe(s),Cot(n,i),o}function L3(n,e,t){t&&t.disconnect(),e==="resize"&&kot(n)}function Eot(n,e,t){const r=n.canvas,s=dse(i=>{n.ctx!==null&&t(xot(i,n))},n);return vot(r,e,s),s}class Iot extends Lse{acquireContext(e,t){const r=e&&e.getContext&&e.getContext("2d");return r&&r.canvas===e?(bot(e,t),r):null}releaseContext(e){const t=e.canvas;if(!t[qE])return!1;const r=t[qE].initial;["height","width"].forEach(i=>{const o=r[i];Nr(o)?t.removeAttribute(i):t.setAttribute(i,o)});const s=r.style||{};return Object.keys(s).forEach(i=>{t.style[i]=s[i]}),t.width=t.width,delete t[qE],!0}addEventListener(e,t,r){this.removeEventListener(e,t);const s=e.$proxies||(e.$proxies={}),o={attach:_ot,detach:Sot,resize:Tot}[t]||Eot;s[t]=o(e,t,r)}removeEventListener(e,t){const r=e.$proxies||(e.$proxies={}),s=r[t];if(!s)return;({attach:L3,detach:L3,resize:L3}[t]||wot)(e,t,s),r[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,r,s){return xit(e,t,r,s)}isAttached(e){const t=P4(e);return!!(t&&t.isConnected)}}function Aot(n){return!Tse()||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas?got:Iot}class Ic{constructor(){Mt(this,"active",!1)}tooltipPosition(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}hasValue(){return ov(this.x)&&ov(this.y)}getProps(e,t){const r=this.$animations;if(!t||!r)return this;const s={};return e.forEach(i=>{s[i]=r[i]&&r[i].active()?r[i]._to:this[i]}),s}}Mt(Ic,"defaults",{}),Mt(Ic,"defaultRoutes");function Mot(n,e){const t=n.options.ticks,r=Not(n),s=Math.min(t.maxTicksLimit||r,r),i=t.major.enabled?Rot(e):[],o=i.length,a=i[0],l=i[o-1],c=[];if(o>s)return Pot(e,c,i,o/s),c;const u=$ot(i,e,s);if(o>0){let h,f;const d=o>1?Math.round((l-a)/(o-1)):null;for(bT(e,c,u,Nr(d)?0:a-d,a),h=0,f=o-1;h<f;h++)bT(e,c,u,i[h],i[h+1]);return bT(e,c,u,l,Nr(d)?e.length:l+d),c}return bT(e,c,u),c}function Not(n){const e=n.options.offset,t=n._tickSize(),r=n._length/t+(e?0:1),s=n._maxLength/t;return Math.floor(Math.min(r,s))}function $ot(n,e,t){const r=Dot(n),s=e.length/t;if(!r)return Math.max(s,1);const i=kst(r);for(let o=0,a=i.length-1;o<a;o++){const l=i[o];if(l>s)return l}return Math.max(s,1)}function Rot(n){const e=[];let t,r;for(t=0,r=n.length;t<r;t++)n[t].major&&e.push(t);return e}function Pot(n,e,t,r){let s=0,i=t[0],o;for(r=Math.ceil(r),o=0;o<n.length;o++)o===i&&(e.push(n[o]),s++,i=t[s*r])}function bT(n,e,t,r,s){const i=Un(r,0),o=Math.min(Un(s,n.length),n.length);let a=0,l,c,u;for(t=Math.ceil(t),s&&(l=s-r,t=l/Math.floor(l/t)),u=i;u<0;)a++,u=Math.round(i+a*t);for(c=Math.max(i,0);c<o;c++)c===u&&(e.push(n[c]),a++,u=Math.round(i+a*t))}function Dot(n){const e=n.length;let t,r;if(e<2)return!1;for(r=n[0],t=1;t<e;++t)if(n[t]-n[t-1]!==r)return!1;return r}const Oot=n=>n==="left"?"right":n==="right"?"left":n,g5=(n,e,t)=>e==="top"||e==="left"?n[e]+t:n[e]-t,y5=(n,e)=>Math.min(e||n,n);function b5(n,e){const t=[],r=n.length/e,s=n.length;let i=0;for(;i<s;i+=r)t.push(n[Math.floor(i)]);return t}function Fot(n,e,t){const r=n.ticks.length,s=Math.min(e,r-1),i=n._startPixel,o=n._endPixel,a=1e-6;let l=n.getPixelForTick(s),c;if(!(t&&(r===1?c=Math.max(l-i,o-l):e===0?c=(n.getPixelForTick(1)-l)/2:c=(l-n.getPixelForTick(s-1))/2,l+=s<e?c:-c,l<i-a||l>o+a)))return l}function Lot(n,e){Dr(n,t=>{const r=t.gc,s=r.length/2;let i;if(s>e){for(i=0;i<s;++i)delete t.data[r[i]];r.splice(0,s)}})}function Zx(n){return n.drawTicks?n.tickLength:0}function v5(n,e){if(!n.display)return 0;const t=Gi(n.font,e),r=Jo(n.padding);return(gs(n.text)?n.text.length:1)*t.lineHeight+r.height}function zot(n,e){return Lp(n,{scale:e,type:"scale"})}function Bot(n,e,t){return Lp(n,{tick:t,index:e,type:"tick"})}function Vot(n,e,t){let r=A4(n);return(t&&e!=="right"||!t&&e==="right")&&(r=Oot(r)),r}function Uot(n,e,t,r){const{top:s,left:i,bottom:o,right:a,chart:l}=n,{chartArea:c,scales:u}=l;let h=0,f,d,p;const m=o-s,g=a-i;if(n.isHorizontal()){if(d=Lo(r,i,a),nr(t)){const y=Object.keys(t)[0],b=t[y];p=u[y].getPixelForValue(b)+m-e}else t==="center"?p=(c.bottom+c.top)/2+m-e:p=g5(n,t,e);f=a-i}else{if(nr(t)){const y=Object.keys(t)[0],b=t[y];d=u[y].getPixelForValue(b)-g+e}else t==="center"?d=(c.left+c.right)/2-g+e:d=g5(n,t,e);p=Lo(r,o,s),h=t==="left"?-Js:Js}return{titleX:d,titleY:p,maxWidth:f,rotation:h}}class Ky extends Ic{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:r,_suggestedMax:s}=this;return e=pl(e,Number.POSITIVE_INFINITY),t=pl(t,Number.NEGATIVE_INFINITY),r=pl(r,Number.POSITIVE_INFINITY),s=pl(s,Number.NEGATIVE_INFINITY),{min:pl(e,r),max:pl(t,s),minDefined:Zs(e),maxDefined:Zs(t)}}getMinMax(e){let{min:t,max:r,minDefined:s,maxDefined:i}=this.getUserBounds(),o;if(s&&i)return{min:t,max:r};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,e),s||(t=Math.min(t,o.min)),i||(r=Math.max(r,o.max));return t=i&&t>r?r:t,r=s&&t>r?t:r,{min:pl(t,pl(r,t)),max:pl(r,pl(t,r))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(e=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){is(this.options.beforeUpdate,[this])}update(e,t,r){const{beginAtZero:s,grace:i,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=r=Object.assign({left:0,right:0,top:0,bottom:0},r),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+r.left+r.right:this.height+r.top+r.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Qst(this,i,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?b5(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||o.source==="auto")&&(this.ticks=Mot(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e=this.options.reverse,t,r;this.isHorizontal()?(t=this.left,r=this.right):(t=this.top,r=this.bottom,e=!e),this._startPixel=t,this._endPixel=r,this._reversePixels=e,this._length=r-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){is(this.options.afterUpdate,[this])}beforeSetDimensions(){is(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){is(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),is(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){is(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let r,s,i;for(r=0,s=e.length;r<s;r++)i=e[r],i.label=is(t.callback,[i.value,r,e],this)}afterTickToLabelConversion(){is(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){is(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,r=y5(this.ticks.length,e.ticks.maxTicksLimit),s=t.minRotation||0,i=t.maxRotation;let o=s,a,l,c;if(!this._isVisible()||!t.display||s>=i||r<=1||!this.isHorizontal()){this.labelRotation=s;return}const u=this._getLabelSizes(),h=u.widest.width,f=u.highest.height,d=Xo(this.chart.width-h,0,this.maxWidth);a=e.offset?this.maxWidth/r:d/(r-1),h+6>a&&(a=d/(r-(e.offset?.5:1)),l=this.maxHeight-Zx(e.grid)-t.padding-v5(e.title,this.chart.options.font),c=Math.sqrt(h*h+f*f),o=E4(Math.min(Math.asin(Xo((u.highest.height+6)/a,-1,1)),Math.asin(Xo(l/c,-1,1))-Math.asin(Xo(f/c,-1,1)))),o=Math.max(s,Math.min(i,o))),this.labelRotation=o}afterCalculateLabelRotation(){is(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){is(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:r,title:s,grid:i}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=v5(s,t.options.font);if(a?(e.width=this.maxWidth,e.height=Zx(i)+l):(e.height=this.maxHeight,e.width=Zx(i)+l),r.display&&this.ticks.length){const{first:c,last:u,widest:h,highest:f}=this._getLabelSizes(),d=r.padding*2,p=hu(this.labelRotation),m=Math.cos(p),g=Math.sin(p);if(a){const y=r.mirror?0:g*h.width+m*f.height;e.height=Math.min(this.maxHeight,e.height+y+d)}else{const y=r.mirror?0:m*h.width+g*f.height;e.width=Math.min(this.maxWidth,e.width+y+d)}this._calculatePadding(c,u,g,m)}}this._handleMargins(),a?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,r,s){const{ticks:{align:i,padding:o},position:a}=this.options,l=this.labelRotation!==0,c=a!=="top"&&this.axis==="x";if(this.isHorizontal()){const u=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let f=0,d=0;l?c?(f=s*e.width,d=r*t.height):(f=r*e.height,d=s*t.width):i==="start"?d=t.width:i==="end"?f=e.width:i!=="inner"&&(f=e.width/2,d=t.width/2),this.paddingLeft=Math.max((f-u+o)*this.width/(this.width-u),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let u=t.height/2,h=e.height/2;i==="start"?(u=0,h=e.height):i==="end"&&(u=t.height,h=0),this.paddingTop=u+o,this.paddingBottom=h+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){is(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return t==="top"||t==="bottom"||e==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){this.beforeTickToLabelConversion(),this.generateTickLabels(e);let t,r;for(t=0,r=e.length;t<r;t++)Nr(e[t].label)&&(e.splice(t,1),r--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let r=this.ticks;t<r.length&&(r=b5(r,t)),this._labelSizes=e=this._computeLabelSizes(r,r.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,r){const{ctx:s,_longestTextCache:i}=this,o=[],a=[],l=Math.floor(t/y5(t,r));let c=0,u=0,h,f,d,p,m,g,y,b,x,w,S;for(h=0;h<t;h+=l){if(p=e[h].label,m=this._resolveTickFontOptions(h),s.font=g=m.string,y=i[g]=i[g]||{data:{},gc:[]},b=m.lineHeight,x=w=0,!Nr(p)&&!gs(p))x=hA(s,y.data,y.gc,x,p),w=b;else if(gs(p))for(f=0,d=p.length;f<d;++f)S=p[f],!Nr(S)&&!gs(S)&&(x=hA(s,y.data,y.gc,x,S),w+=b);o.push(x),a.push(w),c=Math.max(x,c),u=Math.max(w,u)}Lot(i,t);const C=o.indexOf(c),k=a.indexOf(u),A=M=>({width:o[M]||0,height:a[M]||0});return{first:A(0),last:A(t-1),widest:A(C),highest:A(k),widths:o,heights:a}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return Ist(this._alignToPixels?om(this.chart,t,0):t)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const r=t[e];return r.$context||(r.$context=Bot(this.getContext(),e,r))}return this.$context||(this.$context=zot(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=hu(this.labelRotation),r=Math.abs(Math.cos(t)),s=Math.abs(Math.sin(t)),i=this._getLabelSizes(),o=e.autoSkipPadding||0,a=i?i.widest.width+o:0,l=i?i.highest.height+o:0;return this.isHorizontal()?l*r>a*s?a/r:l/s:l*s<a*r?l/r:a/s}_isVisible(){const e=this.options.display;return e!=="auto"?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,r=this.chart,s=this.options,{grid:i,position:o,border:a}=s,l=i.offset,c=this.isHorizontal(),h=this.ticks.length+(l?1:0),f=Zx(i),d=[],p=a.setContext(this.getContext()),m=p.display?p.width:0,g=m/2,y=function(B){return om(r,B,m)};let b,x,w,S,C,k,A,M,E,N,O,R;if(o==="top")b=y(this.bottom),k=this.bottom-f,M=b-g,N=y(e.top)+g,R=e.bottom;else if(o==="bottom")b=y(this.top),N=e.top,R=y(e.bottom)-g,k=b+g,M=this.top+f;else if(o==="left")b=y(this.right),C=this.right-f,A=b-g,E=y(e.left)+g,O=e.right;else if(o==="right")b=y(this.left),E=e.left,O=y(e.right)-g,C=b+g,A=this.left+f;else if(t==="x"){if(o==="center")b=y((e.top+e.bottom)/2+.5);else if(nr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}N=e.top,R=e.bottom,k=b+g,M=k+f}else if(t==="y"){if(o==="center")b=y((e.left+e.right)/2);else if(nr(o)){const B=Object.keys(o)[0],X=o[B];b=y(this.chart.scales[B].getPixelForValue(X))}C=b-g,A=C-f,E=e.left,O=e.right}const D=Un(s.ticks.maxTicksLimit,h),z=Math.max(1,Math.ceil(h/D));for(x=0;x<h;x+=z){const B=this.getContext(x),X=i.setContext(B),G=a.setContext(B),te=X.lineWidth,ge=X.color,ae=G.dash||[],Ne=G.dashOffset,ke=X.tickWidth,De=X.tickColor,be=X.tickBorderDash||[],Xe=X.tickBorderDashOffset;w=Fot(this,x,l),w!==void 0&&(S=om(r,w,te),c?C=A=E=O=S:k=M=N=R=S,d.push({tx1:C,ty1:k,tx2:A,ty2:M,x1:E,y1:N,x2:O,y2:R,width:te,color:ge,borderDash:ae,borderDashOffset:Ne,tickWidth:ke,tickColor:De,tickBorderDash:be,tickBorderDashOffset:Xe}))}return this._ticksLength=h,this._borderValue=b,d}_computeLabelItems(e){const t=this.axis,r=this.options,{position:s,ticks:i}=r,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:u,mirror:h}=i,f=Zx(r.grid),d=f+u,p=h?-u:d,m=-hu(this.labelRotation),g=[];let y,b,x,w,S,C,k,A,M,E,N,O,R="middle";if(s==="top")C=this.bottom-p,k=this._getXAxisLabelAlignment();else if(s==="bottom")C=this.top+p,k=this._getXAxisLabelAlignment();else if(s==="left"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,S=z.x}else if(s==="right"){const z=this._getYAxisLabelAlignment(f);k=z.textAlign,S=z.x}else if(t==="x"){if(s==="center")C=(e.top+e.bottom)/2+d;else if(nr(s)){const z=Object.keys(s)[0],B=s[z];C=this.chart.scales[z].getPixelForValue(B)+d}k=this._getXAxisLabelAlignment()}else if(t==="y"){if(s==="center")S=(e.left+e.right)/2-d;else if(nr(s)){const z=Object.keys(s)[0],B=s[z];S=this.chart.scales[z].getPixelForValue(B)}k=this._getYAxisLabelAlignment(f).textAlign}t==="y"&&(l==="start"?R="top":l==="end"&&(R="bottom"));const D=this._getLabelSizes();for(y=0,b=a.length;y<b;++y){x=a[y],w=x.label;const z=i.setContext(this.getContext(y));A=this.getPixelForTick(y)+i.labelOffset,M=this._resolveTickFontOptions(y),E=M.lineHeight,N=gs(w)?w.length:1;const B=N/2,X=z.color,G=z.textStrokeColor,te=z.textStrokeWidth;let ge=k;o?(S=A,k==="inner"&&(y===b-1?ge=this.options.reverse?"left":"right":y===0?ge=this.options.reverse?"right":"left":ge="center"),s==="top"?c==="near"||m!==0?O=-N*E+E/2:c==="center"?O=-D.highest.height/2-B*E+E:O=-D.highest.height+E/2:c==="near"||m!==0?O=E/2:c==="center"?O=D.highest.height/2-B*E:O=D.highest.height-N*E,h&&(O*=-1),m!==0&&!z.showLabelBackdrop&&(S+=E/2*Math.sin(m))):(C=A,O=(1-N)*E/2);let ae;if(z.showLabelBackdrop){const Ne=Jo(z.backdropPadding),ke=D.heights[y],De=D.widths[y];let be=O-Ne.top,Xe=0-Ne.left;switch(R){case"middle":be-=ke/2;break;case"bottom":be-=ke;break}switch(k){case"center":Xe-=De/2;break;case"right":Xe-=De;break}ae={left:Xe,top:be,width:De+Ne.width,height:ke+Ne.height,color:z.backdropColor}}g.push({label:w,font:M,textOffset:O,options:{rotation:m,color:X,strokeColor:G,strokeWidth:te,textAlign:ge,textBaseline:R,translation:[S,C],backdrop:ae}})}return g}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-hu(this.labelRotation))return e==="top"?"left":"right";let s="center";return t.align==="start"?s="left":t.align==="end"?s="right":t.align==="inner"&&(s="inner"),s}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:r,mirror:s,padding:i}}=this.options,o=this._getLabelSizes(),a=e+i,l=o.widest.width;let c,u;return t==="left"?s?(u=this.right+i,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u+=l)):(u=this.right-a,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u=this.left)):t==="right"?s?(u=this.left+i,r==="near"?c="right":r==="center"?(c="center",u-=l/2):(c="left",u-=l)):(u=this.left+a,r==="near"?c="left":r==="center"?(c="center",u+=l/2):(c="right",u=this.right)):c="right",{textAlign:c,x:u}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;if(t==="left"||t==="right")return{top:0,left:this.left,bottom:e.height,right:this.right};if(t==="top"||t==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:e.width}}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:r,top:s,width:i,height:o}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(r,s,i,o),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const s=this.ticks.findIndex(i=>i.value===e);return s>=0?t.setContext(this.getContext(s)).lineWidth:0}drawGrid(e){const t=this.options.grid,r=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let i,o;const a=(l,c,u)=>{!u.width||!u.color||(r.save(),r.lineWidth=u.width,r.strokeStyle=u.color,r.setLineDash(u.borderDash||[]),r.lineDashOffset=u.borderDashOffset,r.beginPath(),r.moveTo(l.x,l.y),r.lineTo(c.x,c.y),r.stroke(),r.restore())};if(t.display)for(i=0,o=s.length;i<o;++i){const l=s[i];t.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),t.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:r,grid:s}}=this,i=r.setContext(this.getContext()),o=r.display?i.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,l=this._borderValue;let c,u,h,f;this.isHorizontal()?(c=om(e,this.left,o)-o/2,u=om(e,this.right,a)+a/2,h=f=l):(h=om(e,this.top,o)-o/2,f=om(e,this.bottom,a)+a/2,c=u=l),t.save(),t.lineWidth=i.width,t.strokeStyle=i.color,t.beginPath(),t.moveTo(c,h),t.lineTo(u,f),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const r=this.ctx,s=this._computeLabelArea();s&&y$(r,s);const i=this.getLabelItems(e);for(const o of i){const a=o.options,l=o.font,c=o.label,u=o.textOffset;yg(r,c,0,u,l,a)}s&&b$(r)}drawTitle(){const{ctx:e,options:{position:t,title:r,reverse:s}}=this;if(!r.display)return;const i=Gi(r.font),o=Jo(r.padding),a=r.align;let l=i.lineHeight/2;t==="bottom"||t==="center"||nr(t)?(l+=o.bottom,gs(r.text)&&(l+=i.lineHeight*(r.text.length-1))):l+=o.top;const{titleX:c,titleY:u,maxWidth:h,rotation:f}=Uot(this,l,t,a);yg(e,r.text,0,0,i,{color:r.color,maxWidth:h,rotation:f,textAlign:Vot(a,t,s),textBaseline:"middle",translation:[c,u]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,r=Un(e.grid&&e.grid.z,-1),s=Un(e.border&&e.border.z,0);return!this._isVisible()||this.draw!==Ky.prototype.draw?[{z:t,draw:i=>{this.draw(i)}}]:[{z:r,draw:i=>{this.drawBackground(),this.drawGrid(i),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:t,draw:i=>{this.drawLabels(i)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),r=this.axis+"AxisID",s=[];let i,o;for(i=0,o=t.length;i<o;++i){const a=t[i];a[r]===this.id&&(!e||a.type===e)&&s.push(a)}return s}_resolveTickFontOptions(e){const t=this.options.ticks.setContext(this.getContext(e));return Gi(t.font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class vT{constructor(e,t,r){this.type=e,this.scope=t,this.override=r,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let r;Hot(t)&&(r=this.register(t));const s=this.items,i=e.id,o=this.scope+"."+i;if(!i)throw new Error("class does not have id: "+e);return i in s||(s[i]=e,Wot(e,o,r),this.override&&ai.override(e.id,e.overrides)),o}get(e){return this.items[e]}unregister(e){const t=this.items,r=e.id,s=this.scope;r in t&&delete t[r],s&&r in ai[s]&&(delete ai[s][r],this.override&&delete gg[r])}}function Wot(n,e,t){const r=Z_(Object.create(null),[t?ai.get(t):{},ai.get(e),n.defaults]);ai.set(e,r),n.defaultRoutes&&Got(e,n.defaultRoutes),n.descriptors&&ai.describe(e,n.descriptors)}function Got(n,e){Object.keys(e).forEach(t=>{const r=t.split("."),s=r.pop(),i=[n].concat(r).join("."),o=e[t].split("."),a=o.pop(),l=o.join(".");ai.route(i,s,l,a)})}function Hot(n){return"id"in n&&"defaults"in n}class jot{constructor(){this.controllers=new vT(wc,"datasets",!0),this.elements=new vT(Ic,"elements"),this.plugins=new vT(Object,"plugins"),this.scales=new vT(Ky,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...e){this._each("register",e)}remove(...e){this._each("unregister",e)}addControllers(...e){this._each("register",e,this.controllers)}addElements(...e){this._each("register",e,this.elements)}addPlugins(...e){this._each("register",e,this.plugins)}addScales(...e){this._each("register",e,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(...e){this._each("unregister",e,this.controllers)}removeElements(...e){this._each("unregister",e,this.elements)}removePlugins(...e){this._each("unregister",e,this.plugins)}removeScales(...e){this._each("unregister",e,this.scales)}_each(e,t,r){[...t].forEach(s=>{const i=r||this._getRegistryForType(s);r||i.isForType(s)||i===this.plugins&&s.id?this._exec(e,i,s):Dr(s,o=>{const a=r||this._getRegistryForType(o);this._exec(e,a,o)})})}_exec(e,t,r){const s=T4(e);is(r["before"+s],[],r),t[e](r),is(r["after"+s],[],r)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const r=this._typedRegistries[t];if(r.isForType(e))return r}return this.plugins}_get(e,t,r){const s=t.get(e);if(s===void 0)throw new Error('"'+e+'" is not a registered '+r+".");return s}}var nh=new jot;class qot{constructor(){this._init=[]}notify(e,t,r,s){t==="beforeInit"&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install"));const i=s?this._descriptors(e).filter(s):this._descriptors(e),o=this._notify(i,e,t,r);return t==="afterDestroy"&&(this._notify(i,e,"stop"),this._notify(this._init,e,"uninstall")),o}_notify(e,t,r,s){s=s||{};for(const i of e){const o=i.plugin,a=o[r],l=[t,s,i.options];if(is(a,l,o)===!1&&s.cancelable)return!1}return!0}invalidate(){Nr(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const r=e&&e.config,s=Un(r.options&&r.options.plugins,{}),i=Xot(r);return s===!1&&!t?[]:Yot(e,i,s,t)}_notifyStateChanges(e){const t=this._oldCache||[],r=this._cache,s=(i,o)=>i.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(s(t,r),e,"stop"),this._notify(s(r,t),e,"start")}}function Xot(n){const e={},t=[],r=Object.keys(nh.plugins.items);for(let i=0;i<r.length;i++)t.push(nh.getPlugin(r[i]));const s=n.plugins||[];for(let i=0;i<s.length;i++){const o=s[i];t.indexOf(o)===-1&&(t.push(o),e[o.id]=!0)}return{plugins:t,localIds:e}}function Kot(n,e){return!e&&n===!1?null:n===!0?{}:n}function Yot(n,{plugins:e,localIds:t},r,s){const i=[],o=n.getContext();for(const a of e){const l=a.id,c=Kot(r[l],s);c!==null&&i.push({plugin:a,options:Zot(n.config,{plugin:a,local:t[l]},c,o)})}return i}function Zot(n,{plugin:e,local:t},r,s){const i=n.pluginScopeKeys(e),o=n.getOptionScopes(r,i);return t&&e.defaults&&o.push(e.defaults),n.createResolver(o,s,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function tF(n,e){const t=ai.datasets[n]||{};return((e.datasets||{})[n]||{}).indexAxis||e.indexAxis||t.indexAxis||"x"}function Jot(n,e){let t=n;return n==="_index_"?t=e:n==="_value_"&&(t=e==="x"?"y":"x"),t}function Qot(n,e){return n===e?"_index_":"_value_"}function eat(n){if(n==="top"||n==="bottom")return"x";if(n==="left"||n==="right")return"y"}function pA(n,e){if(n==="x"||n==="y"||n==="r"||(n=e.axis||eat(e.position)||n.length>1&&pA(n[0].toLowerCase(),e),n))return n;throw new Error(`Cannot determine type of '${name}' axis. Please provide 'axis' or 'position' option.`)}function tat(n,e){const t=gg[n.type]||{scales:{}},r=e.scales||{},s=tF(n.type,e),i=Object.create(null);return Object.keys(r).forEach(o=>{const a=r[o];if(!nr(a))return console.error(`Invalid scale configuration for scale: ${o}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${o}`);const l=pA(o,a),c=Qot(l,s),u=t.scales||{};i[o]=Q1(Object.create(null),[{axis:l},a,u[l],u[c]])}),n.data.datasets.forEach(o=>{const a=o.type||n.type,l=o.indexAxis||tF(a,e),u=(gg[a]||{}).scales||{};Object.keys(u).forEach(h=>{const f=Jot(h,l),d=o[f+"AxisID"]||f;i[d]=i[d]||Object.create(null),Q1(i[d],[{axis:f},r[d],u[h]])})}),Object.keys(i).forEach(o=>{const a=i[o];Q1(a,[ai.scales[a.type],ai.scale])}),i}function Vse(n){const e=n.options||(n.options={});e.plugins=Un(e.plugins,{}),e.scales=tat(n,e)}function Use(n){return n=n||{},n.datasets=n.datasets||[],n.labels=n.labels||[],n}function nat(n){return n=n||{},n.data=Use(n.data),Vse(n),n}const w5=new Map,Wse=new Set;function wT(n,e){let t=w5.get(n);return t||(t=e(),w5.set(n,t),Wse.add(t)),t}const Jx=(n,e,t)=>{const r=dp(e,t);r!==void 0&&n.add(r)};class rat{constructor(e){this._config=nat(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=Use(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),Vse(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return wT(e,()=>[[`datasets.${e}`,""]])}datasetAnimationScopeKeys(e,t){return wT(`${e}.transition.${t}`,()=>[[`datasets.${e}.transitions.${t}`,`transitions.${t}`],[`datasets.${e}`,""]])}datasetElementScopeKeys(e,t){return wT(`${e}-${t}`,()=>[[`datasets.${e}.elements.${t}`,`datasets.${e}`,`elements.${t}`,""]])}pluginScopeKeys(e){const t=e.id,r=this.type;return wT(`${r}-plugin-${t}`,()=>[[`plugins.${t}`,...e.additionalOptionScopes||[]]])}_cachedScopes(e,t){const r=this._scopeCache;let s=r.get(e);return(!s||t)&&(s=new Map,r.set(e,s)),s}getOptionScopes(e,t,r){const{options:s,type:i}=this,o=this._cachedScopes(e,r),a=o.get(t);if(a)return a;const l=new Set;t.forEach(u=>{e&&(l.add(e),u.forEach(h=>Jx(l,e,h))),u.forEach(h=>Jx(l,s,h)),u.forEach(h=>Jx(l,gg[i]||{},h)),u.forEach(h=>Jx(l,ai,h)),u.forEach(h=>Jx(l,JO,h))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Wse.has(t)&&o.set(t,c),c}chartOptionScopes(){const{options:e,type:t}=this;return[e,gg[t]||{},ai.datasets[t]||{},{type:t},ai,JO]}resolveNamedOptions(e,t,r,s=[""]){const i={$shared:!0},{resolver:o,subPrefixes:a}=x5(this._resolverCache,e,s);let l=o;if(iat(o,t)){i.$shared=!1,r=pp(r)?r():r;const c=this.createResolver(e,r,a);l=av(o,r,c)}for(const c of t)i[c]=l[c];return i}createResolver(e,t,r=[""],s){const{resolver:i}=x5(this._resolverCache,e,r);return nr(t)?av(i,t,void 0,s):i}}function x5(n,e,t){let r=n.get(e);r||(r=new Map,n.set(e,r));const s=t.join();let i=r.get(s);return i||(i={resolver:N4(e,t),subPrefixes:t.filter(a=>!a.toLowerCase().includes("hover"))},r.set(s,i)),i}const sat=n=>nr(n)&&Object.getOwnPropertyNames(n).reduce((e,t)=>e||pp(n[t]),!1);function iat(n,e){const{isScriptable:t,isIndexable:r}=wse(n);for(const s of e){const i=t(s),o=r(s),a=(o||i)&&n[s];if(i&&(pp(a)||sat(a))||o&&gs(a))return!0}return!1}var oat="4.2.1";const aat=["top","bottom","left","right","chartArea"];function _5(n,e){return n==="top"||n==="bottom"||aat.indexOf(n)===-1&&e==="x"}function S5(n,e){return function(t,r){return t[n]===r[n]?t[e]-r[e]:t[n]-r[n]}}function C5(n){const e=n.chart,t=e.options.animation;e.notifyPlugins("afterRender"),is(t&&t.onComplete,[n],e)}function lat(n){const e=n.chart,t=e.options.animation;is(t&&t.onProgress,[n],e)}function Gse(n){return Tse()&&typeof n=="string"?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const XE={},k5=n=>{const e=Gse(n);return Object.values(XE).filter(t=>t.canvas===e).pop()};function cat(n,e,t){const r=Object.keys(n);for(const s of r){const i=+s;if(i>=e){const o=n[s];delete n[s],(t>0||i>e)&&(n[i+t]=o)}}}function uat(n,e,t,r){return!t||n.type==="mouseout"?null:r?e:n}function hat(n){const{xScale:e,yScale:t}=n;if(e&&t)return{left:e.left,right:e.right,top:t.top,bottom:t.bottom}}class su{static register(...e){nh.add(...e),T5()}static unregister(...e){nh.remove(...e),T5()}constructor(e,t){const r=this.config=new rat(t),s=Gse(e),i=k5(s);if(i)throw new Error("Canvas is already in use. Chart with ID '"+i.id+"' must be destroyed before the canvas with ID '"+i.canvas.id+"' can be reused.");const o=r.createResolver(r.chartOptionScopes(),this.getContext());this.platform=new(r.platform||Aot(s)),this.platform.updateConfig(r);const a=this.platform.acquireContext(s,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,u=l&&l.width;if(this.id=gst(),this.ctx=a,this.canvas=l,this.width=u,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new qot,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=$st(h=>this.update(h),o.resizeDelay||0),this._dataChanges=[],XE[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}cf.listen(this,"complete",C5),cf.listen(this,"progress",lat),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:r,height:s,_aspectRatio:i}=this;return Nr(e)?t&&i?i:s?r/s:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return nh}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():K6(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return j6(this.canvas,this.ctx),this}stop(){return cf.stop(this),this}resize(e,t){cf.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const r=this.options,s=this.canvas,i=r.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,e,t,i),a=r.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,K6(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),is(r.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const t=this.options.scales||{};Dr(t,(r,s)=>{r.id=s})}buildOrUpdateScales(){const e=this.options,t=e.scales,r=this.scales,s=Object.keys(r).reduce((o,a)=>(o[a]=!1,o),{});let i=[];t&&(i=i.concat(Object.keys(t).map(o=>{const a=t[o],l=pA(o,a),c=l==="r",u=l==="x";return{options:a,dposition:c?"chartArea":u?"bottom":"left",dtype:c?"radialLinear":u?"category":"linear"}}))),Dr(i,o=>{const a=o.options,l=a.id,c=pA(l,a),u=Un(a.type,o.dtype);(a.position===void 0||_5(a.position,c)!==_5(o.dposition))&&(a.position=o.dposition),s[l]=!0;let h=null;if(l in r&&r[l].type===u)h=r[l];else{const f=nh.getScale(u);h=new f({id:l,type:u,ctx:this.ctx,chart:this}),r[h.id]=h}h.init(a,e)}),Dr(s,(o,a)=>{o||delete r[a]}),Dr(r,o=>{mc.configure(this,o,o.options),mc.addBox(this,o)})}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,r=e.length;if(e.sort((s,i)=>s.index-i.index),r>t){for(let s=t;s<r;++s)this._destroyDatasetMeta(s);e.splice(t,r-t)}this._sortedMetasets=e.slice(0).sort(S5("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach((r,s)=>{t.filter(i=>i===r._dataset).length===0&&this._destroyDatasetMeta(s)})}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let r,s;for(this._removeUnreferencedMetasets(),r=0,s=t.length;r<s;r++){const i=t[r];let o=this.getDatasetMeta(r);const a=i.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(r),o=this.getDatasetMeta(r)),o.type=a,o.indexAxis=i.indexAxis||tF(a,this.options),o.order=i.order||0,o.index=r,o.label=""+i.label,o.visible=this.isDatasetVisible(r),o.controller)o.controller.updateIndex(r),o.controller.linkScales();else{const l=nh.getController(a),{datasetElementType:c,dataElementType:u}=ai.datasets[a];Object.assign(l,{dataElementType:nh.getElement(u),datasetElementType:c&&nh.getElement(c)}),o.controller=new l(this,r),e.push(o.controller)}}return this._updateMetasets(),e}_resetElements(){Dr(this.data.datasets,(e,t)=>{this.getDatasetMeta(t).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const r=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!r.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0})===!1)return;const i=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,u=this.data.datasets.length;c<u;c++){const{controller:h}=this.getDatasetMeta(c),f=!s&&i.indexOf(h)===-1;h.buildOrUpdateElements(f),o=Math.max(+h.getMaxOverflow(),o)}o=this._minPadding=r.layout.autoPadding?o:0,this._updateLayout(o),s||Dr(i,c=>{c.reset()}),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(S5("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){Dr(this.scales,e=>{mc.removeBox(this,e)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),r=new Set(e.events);(!F6(t,r)||!!this._responsiveListeners!==e.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:r,start:s,count:i}of t){const o=r==="_removeElements"?-i:i;cat(e,s,o)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,r=i=>new Set(e.filter(o=>o[0]===i).map((o,a)=>a+","+o.splice(1).join(","))),s=r(0);for(let i=1;i<t;i++)if(!F6(s,r(i)))return;return Array.from(s).map(i=>i.split(",")).map(i=>({method:i[1],start:+i[2],count:+i[3]}))}_updateLayout(e){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;mc.update(this,this.width,this.height,e);const t=this.chartArea,r=t.width<=0||t.height<=0;this._layers=[],Dr(this.boxes,s=>{r&&s.position==="chartArea"||(s.configure&&s.configure(),this._layers.push(...s._layers()))},this),this._layers.forEach((s,i)=>{s._idx=i}),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})!==!1){for(let t=0,r=this.data.datasets.length;t<r;++t)this.getDatasetMeta(t).controller.configure();for(let t=0,r=this.data.datasets.length;t<r;++t)this._updateDataset(t,pp(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const r=this.getDatasetMeta(e),s={meta:r,index:e,mode:t,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",s)!==!1&&(r.controller._update(t),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(cf.has(this)?this.attached&&!cf.running(this)&&cf.start(this):(this.draw(),C5({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:r,height:s}=this._resizeBeforeDraw;this._resize(r,s),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,r=[];let s,i;for(s=0,i=t.length;s<i;++s){const o=t[s];(!e||o.visible)&&r.push(o)}return r}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,r=e._clip,s=!r.disabled,i=hat(e)||this.chartArea,o={meta:e,index:e.index,cancelable:!0};this.notifyPlugins("beforeDatasetDraw",o)!==!1&&(s&&y$(t,{left:r.left===!1?0:i.left-r.left,right:r.right===!1?this.width:i.right+r.right,top:r.top===!1?0:i.top-r.top,bottom:r.bottom===!1?this.height:i.bottom+r.bottom}),e.controller.draw(),s&&b$(t),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}isPointInArea(e){return Q_(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,r,s){const i=lot.modes[t];return typeof i=="function"?i(this,e,r,s):[]}getDatasetMeta(e){const t=this.data.datasets[e],r=this._metasets;let s=r.filter(i=>i&&i._dataset===t).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},r.push(s)),s}getContext(){return this.$context||(this.$context=Lp(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const r=this.getDatasetMeta(e);return typeof r.hidden=="boolean"?!r.hidden:!t.hidden}setDatasetVisibility(e,t){const r=this.getDatasetMeta(e);r.hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,r){const s=r?"show":"hide",i=this.getDatasetMeta(e),o=i.controller._resolveAnimations(void 0,s);Ec(t)?(i.data[t].hidden=!r,this.update()):(this.setDatasetVisibility(e,r),o.update(i,{visible:r}),this.update(a=>a.datasetIndex===e?s:void 0))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),cf.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),j6(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete XE[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...e){return this.canvas.toDataURL(...e)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,r=(i,o)=>{t.addEventListener(this,i,o),e[i]=o},s=(i,o,a)=>{i.offsetX=o,i.offsetY=a,this._eventHandler(i)};Dr(this.options.events,i=>r(i,s))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,r=(l,c)=>{t.addEventListener(this,l,c),e[l]=c},s=(l,c)=>{e[l]&&(t.removeEventListener(this,l,c),delete e[l])},i=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{s("attach",a),this.attached=!0,this.resize(),r("resize",i),r("detach",o)};o=()=>{this.attached=!1,s("resize",i),this._stop(),this._resize(0,0),r("attach",a)},t.isAttached(this.canvas)?a():o()}unbindEvents(){Dr(this._listeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._listeners={},Dr(this._responsiveListeners,(e,t)=>{this.platform.removeEventListener(this,t,e)}),this._responsiveListeners=void 0}updateHoverStyle(e,t,r){const s=r?"set":"remove";let i,o,a,l;for(t==="dataset"&&(i=this.getDatasetMeta(e[0].datasetIndex),i.controller["_"+s+"DatasetHoverStyle"]()),a=0,l=e.length;a<l;++a){o=e[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],r=e.map(({datasetIndex:i,index:o})=>{const a=this.getDatasetMeta(i);if(!a)throw new Error("No dataset found at index "+i);return{datasetIndex:i,element:a.data[o],index:o}});!lA(r,t)&&(this._active=r,this._lastEvent=null,this._updateHoverStyles(r,t))}notifyPlugins(e,t,r){return this._plugins.notify(this,e,t,r)}isPluginEnabled(e){return this._plugins._cache.filter(t=>t.plugin.id===e).length===1}_updateHoverStyles(e,t,r){const s=this.options.hover,i=(l,c)=>l.filter(u=>!c.some(h=>u.datasetIndex===h.datasetIndex&&u.index===h.index)),o=i(t,e),a=r?e:i(e,t);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(e,t){const r={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},s=o=>(o.options.events||this.options.events).includes(e.native.type);if(this.notifyPlugins("beforeEvent",r,s)===!1)return;const i=this._handleEvent(e,t,r.inChartArea);return r.cancelable=!1,this.notifyPlugins("afterEvent",r,s),(i||r.changed)&&this.render(),this}_handleEvent(e,t,r){const{_active:s=[],options:i}=this,o=t,a=this._getActiveElements(e,s,r,o),l=_st(e),c=uat(e,this._lastEvent,r,l);r&&(this._lastEvent=null,is(i.onHover,[e,a,this],this),l&&is(i.onClick,[e,a,this],this));const u=!lA(a,s);return(u||t)&&(this._active=a,this._updateHoverStyles(a,s,t)),this._lastEvent=c,u}_getActiveElements(e,t,r,s){if(e.type==="mouseout")return[];if(!r)return t;const i=this.options.hover;return this.getElementsAtEventForMode(e,i.mode,i,s)}}Mt(su,"defaults",ai),Mt(su,"instances",XE),Mt(su,"overrides",gg),Mt(su,"registry",nh),Mt(su,"version",oat),Mt(su,"getChart",k5);function T5(){return Dr(su.instances,n=>n._plugins.invalidate())}function fat(n,e,t){const{startAngle:r,pixelMargin:s,x:i,y:o,outerRadius:a,innerRadius:l}=e;let c=s/a;n.beginPath(),n.arc(i,o,a,r-c,t+c),l>s?(c=s/l,n.arc(i,o,l,t+c,r-c,!0)):n.arc(i,o,s,t+Js,r-Js),n.closePath(),n.clip()}function dat(n){return M4(n,["outerStart","outerEnd","innerStart","innerEnd"])}function pat(n,e,t,r){const s=dat(n.options.borderRadius),i=(t-e)/2,o=Math.min(i,r*e/2),a=l=>{const c=(t-Math.min(i,l))*r/2;return Xo(l,0,Math.min(i,c))};return{outerStart:a(s.outerStart),outerEnd:a(s.outerEnd),innerStart:Xo(s.innerStart,0,o),innerEnd:Xo(s.innerEnd,0,o)}}function F0(n,e,t,r){return{x:t+n*Math.cos(e),y:r+n*Math.sin(e)}}function mA(n,e,t,r,s,i){const{x:o,y:a,startAngle:l,pixelMargin:c,innerRadius:u}=e,h=Math.max(e.outerRadius+r+t-c,0),f=u>0?u+r+t+c:0;let d=0;const p=s-l;if(r){const z=u>0?u-r:0,B=h>0?h-r:0,X=(z+B)/2,G=X!==0?p*X/(X+r):p;d=(p-G)/2}const m=Math.max(.001,p*h-t/Ts)/h,g=(p-m)/2,y=l+g+d,b=s-g-d,{outerStart:x,outerEnd:w,innerStart:S,innerEnd:C}=pat(e,f,h,b-y),k=h-x,A=h-w,M=y+x/k,E=b-w/A,N=f+S,O=f+C,R=y+S/N,D=b-C/O;if(n.beginPath(),i){const z=(M+E)/2;if(n.arc(o,a,h,M,z),n.arc(o,a,h,z,E),w>0){const te=F0(A,E,o,a);n.arc(te.x,te.y,w,E,b+Js)}const B=F0(O,b,o,a);if(n.lineTo(B.x,B.y),C>0){const te=F0(O,D,o,a);n.arc(te.x,te.y,C,b+Js,D+Math.PI)}const X=(b-C/f+(y+S/f))/2;if(n.arc(o,a,f,b-C/f,X,!0),n.arc(o,a,f,X,y+S/f,!0),S>0){const te=F0(N,R,o,a);n.arc(te.x,te.y,S,R+Math.PI,y-Js)}const G=F0(k,y,o,a);if(n.lineTo(G.x,G.y),x>0){const te=F0(k,M,o,a);n.arc(te.x,te.y,x,y-Js,M)}}else{n.moveTo(o,a);const z=Math.cos(M)*h+o,B=Math.sin(M)*h+a;n.lineTo(z,B);const X=Math.cos(E)*h+o,G=Math.sin(E)*h+a;n.lineTo(X,G)}n.closePath()}function mat(n,e,t,r,s){const{fullCircles:i,startAngle:o,circumference:a}=e;let l=e.endAngle;if(i){mA(n,e,t,r,l,s);for(let c=0;c<i;++c)n.fill();isNaN(a)||(l=o+(a%bs||bs))}return mA(n,e,t,r,l,s),n.fill(),l}function gat(n,e,t,r,s){const{fullCircles:i,startAngle:o,circumference:a,options:l}=e,{borderWidth:c,borderJoinStyle:u}=l,h=l.borderAlign==="inner";if(!c)return;h?(n.lineWidth=c*2,n.lineJoin=u||"round"):(n.lineWidth=c,n.lineJoin=u||"bevel");let f=e.endAngle;if(i){mA(n,e,t,r,f,s);for(let d=0;d<i;++d)n.stroke();isNaN(a)||(f=o+(a%bs||bs))}h&&fat(n,e,f),i||(mA(n,e,t,r,f,s),n.stroke())}class KE extends Ic{constructor(e){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,r){const s=this.getProps(["x","y"],r),{angle:i,distance:o}=cse(s,{x:e,y:t}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:u,circumference:h}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],r),f=this.options.spacing/2,p=Un(h,l-a)>=bs||J_(i,a,l),m=Cf(o,c+f,u+f);return p&&m}getCenterPoint(e){const{x:t,y:r,startAngle:s,endAngle:i,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:l,spacing:c}=this.options,u=(s+i)/2,h=(o+a+c+l)/2;return{x:t+Math.cos(u)*h,y:r+Math.sin(u)*h}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:r}=this,s=(t.offset||0)/4,i=(t.spacing||0)/2,o=t.circular;if(this.pixelMargin=t.borderAlign==="inner"?.33:0,this.fullCircles=r>bs?Math.floor(r/bs):0,r===0||this.innerRadius<0||this.outerRadius<0)return;e.save();const a=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(a)*s,Math.sin(a)*s);const l=1-Math.sin(Math.min(Ts,r||0)),c=s*l;e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,mat(e,this,c,i,o),gat(e,this,c,i,o),e.restore()}}Mt(KE,"id","arc"),Mt(KE,"defaults",{borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0}),Mt(KE,"defaultRoutes",{backgroundColor:"backgroundColor"});function Hse(n,e,t=e){n.lineCap=Un(t.borderCapStyle,e.borderCapStyle),n.setLineDash(Un(t.borderDash,e.borderDash)),n.lineDashOffset=Un(t.borderDashOffset,e.borderDashOffset),n.lineJoin=Un(t.borderJoinStyle,e.borderJoinStyle),n.lineWidth=Un(t.borderWidth,e.borderWidth),n.strokeStyle=Un(t.borderColor,e.borderColor)}function yat(n,e,t){n.lineTo(t.x,t.y)}function bat(n){return n.stepped?Gst:n.tension||n.cubicInterpolationMode==="monotone"?Hst:yat}function jse(n,e,t={}){const r=n.length,{start:s=0,end:i=r-1}=t,{start:o,end:a}=e,l=Math.max(s,o),c=Math.min(i,a),u=s<o&&i<o||s>a&&i>a;return{count:r,start:l,loop:e.loop,ilen:c<l&&!u?r+c-l:c-l}}function vat(n,e,t,r){const{points:s,options:i}=e,{count:o,start:a,loop:l,ilen:c}=jse(s,t,r),u=bat(i);let{move:h=!0,reverse:f}=r||{},d,p,m;for(d=0;d<=c;++d)p=s[(a+(f?c-d:d))%o],!p.skip&&(h?(n.moveTo(p.x,p.y),h=!1):u(n,m,p,f,i.stepped),m=p);return l&&(p=s[(a+(f?c:0))%o],u(n,m,p,f,i.stepped)),!!l}function wat(n,e,t,r){const s=e.points,{count:i,start:o,ilen:a}=jse(s,t,r),{move:l=!0,reverse:c}=r||{};let u=0,h=0,f,d,p,m,g,y;const b=w=>(o+(c?a-w:w))%i,x=()=>{m!==g&&(n.lineTo(u,g),n.lineTo(u,m),n.lineTo(u,y))};for(l&&(d=s[b(0)],n.moveTo(d.x,d.y)),f=0;f<=a;++f){if(d=s[b(f)],d.skip)continue;const w=d.x,S=d.y,C=w|0;C===p?(S<m?m=S:S>g&&(g=S),u=(h*u+w)/++h):(x(),n.lineTo(w,S),p=C,h=0,m=g=S),y=S}x()}function nF(n){const e=n.options,t=e.borderDash&&e.borderDash.length;return!n._decimated&&!n._loop&&!e.tension&&e.cubicInterpolationMode!=="monotone"&&!e.stepped&&!t?wat:vat}function xat(n){return n.stepped?Sit:n.tension||n.cubicInterpolationMode==="monotone"?Cit:Sm}function _at(n,e,t,r){let s=e._path;s||(s=e._path=new Path2D,e.path(s,t,r)&&s.closePath()),Hse(n,e.options),n.stroke(s)}function Sat(n,e,t,r){const{segments:s,options:i}=e,o=nF(e);for(const a of s)Hse(n,i,a.style),n.beginPath(),o(n,e,a,{start:t,end:t+r-1})&&n.closePath(),n.stroke()}const Cat=typeof Path2D=="function";function kat(n,e,t,r){Cat&&!e.options.segment?_at(n,e,t,r):Sat(n,e,t,r)}class Od extends Ic{constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const r=this.options;if((r.tension||r.cubicInterpolationMode==="monotone")&&!r.stepped&&!this._pointsUpdated){const s=r.spanGaps?this._loop:this._fullLoop;mit(this._points,r,e,s,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=Mit(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,r=e.length;return r&&t[e[r-1].end]}interpolate(e,t){const r=this.options,s=e[t],i=this.points,o=Nse(this,{property:t,start:s,end:s});if(!o.length)return;const a=[],l=xat(r);let c,u;for(c=0,u=o.length;c<u;++c){const{start:h,end:f}=o[c],d=i[h],p=i[f];if(d===p){a.push(d);continue}const m=Math.abs((s-d[t])/(p[t]-d[t])),g=l(d,p,m,r.stepped);g[t]=e[t],a.push(g)}return a.length===1?a[0]:a}pathSegment(e,t,r){return nF(this)(e,this,t,r)}path(e,t,r){const s=this.segments,i=nF(this);let o=this._loop;t=t||0,r=r||this.points.length-t;for(const a of s)o&=i(e,this,a,{start:t,end:t+r-1});return!!o}draw(e,t,r,s){const i=this.options||{};(this.points||[]).length&&i.borderWidth&&(e.save(),kat(e,this,r,s),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}Mt(Od,"id","line"),Mt(Od,"defaults",{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0}),Mt(Od,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"}),Mt(Od,"descriptors",{_scriptable:!0,_indexable:e=>e!=="borderDash"&&e!=="fill"});function E5(n,e,t,r){const s=n.options,{[t]:i}=n.getProps([t],r);return Math.abs(e-i)<s.radius+s.hitRadius}class YE extends Ic{constructor(e){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,r){const s=this.options,{x:i,y:o}=this.getProps(["x","y"],r);return Math.pow(e-i,2)+Math.pow(t-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(e,t){return E5(this,e,"x",t)}inYRange(e,t){return E5(this,e,"y",t)}getCenterPoint(e){const{x:t,y:r}=this.getProps(["x","y"],e);return{x:t,y:r}}size(e){e=e||this.options||{};let t=e.radius||0;t=Math.max(t,t&&e.hoverRadius||0);const r=t&&e.borderWidth||0;return(t+r)*2}draw(e,t){const r=this.options;this.skip||r.radius<.1||!Q_(this,t,this.size(r)/2)||(e.strokeStyle=r.borderColor,e.lineWidth=r.borderWidth,e.fillStyle=r.backgroundColor,QO(e,r,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}Mt(YE,"id","point"),Mt(YE,"defaults",{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0}),Mt(YE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function qse(n,e){const{x:t,y:r,base:s,width:i,height:o}=n.getProps(["x","y","base","width","height"],e);let a,l,c,u,h;return n.horizontal?(h=o/2,a=Math.min(t,s),l=Math.max(t,s),c=r-h,u=r+h):(h=i/2,a=t-h,l=t+h,c=Math.min(r,s),u=Math.max(r,s)),{left:a,top:c,right:l,bottom:u}}function Fd(n,e,t,r){return n?0:Xo(e,t,r)}function Tat(n,e,t){const r=n.options.borderWidth,s=n.borderSkipped,i=vse(r);return{t:Fd(s.top,i.top,0,t),r:Fd(s.right,i.right,0,e),b:Fd(s.bottom,i.bottom,0,t),l:Fd(s.left,i.left,0,e)}}function Eat(n,e,t){const{enableBorderRadius:r}=n.getProps(["enableBorderRadius"]),s=n.options.borderRadius,i=Xd(s),o=Math.min(e,t),a=n.borderSkipped,l=r||nr(s);return{topLeft:Fd(!l||a.top||a.left,i.topLeft,0,o),topRight:Fd(!l||a.top||a.right,i.topRight,0,o),bottomLeft:Fd(!l||a.bottom||a.left,i.bottomLeft,0,o),bottomRight:Fd(!l||a.bottom||a.right,i.bottomRight,0,o)}}function Iat(n){const e=qse(n),t=e.right-e.left,r=e.bottom-e.top,s=Tat(n,t/2,r/2),i=Eat(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r,radius:i},inner:{x:e.left+s.l,y:e.top+s.t,w:t-s.l-s.r,h:r-s.t-s.b,radius:{topLeft:Math.max(0,i.topLeft-Math.max(s.t,s.l)),topRight:Math.max(0,i.topRight-Math.max(s.t,s.r)),bottomLeft:Math.max(0,i.bottomLeft-Math.max(s.b,s.l)),bottomRight:Math.max(0,i.bottomRight-Math.max(s.b,s.r))}}}}function z3(n,e,t,r){const s=e===null,i=t===null,a=n&&!(s&&i)&&qse(n,r);return a&&(s||Cf(e,a.left,a.right))&&(i||Cf(t,a.top,a.bottom))}function Aat(n){return n.topLeft||n.topRight||n.bottomLeft||n.bottomRight}function Mat(n,e){n.rect(e.x,e.y,e.w,e.h)}function B3(n,e,t={}){const r=n.x!==t.x?-e:0,s=n.y!==t.y?-e:0,i=(n.x+n.w!==t.x+t.w?e:0)-r,o=(n.y+n.h!==t.y+t.h?e:0)-s;return{x:n.x+r,y:n.y+s,w:n.w+i,h:n.h+o,radius:n.radius}}class ZE extends Ic{constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:r,backgroundColor:s}}=this,{inner:i,outer:o}=Iat(this),a=Aat(o.radius)?qd:Mat;e.save(),(o.w!==i.w||o.h!==i.h)&&(e.beginPath(),a(e,B3(o,t,i)),e.clip(),a(e,B3(i,-t,o)),e.fillStyle=r,e.fill("evenodd")),e.beginPath(),a(e,B3(i,t)),e.fillStyle=s,e.fill(),e.restore()}inRange(e,t,r){return z3(this,e,t,r)}inXRange(e,t){return z3(this,e,null,t)}inYRange(e,t){return z3(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,base:s,horizontal:i}=this.getProps(["x","y","base","horizontal"],e);return{x:i?(t+s)/2:t,y:i?r:(r+s)/2}}getRange(e){return e==="x"?this.width/2:this.height/2}}Mt(ZE,"id","bar"),Mt(ZE,"defaults",{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0}),Mt(ZE,"defaultRoutes",{backgroundColor:"backgroundColor",borderColor:"borderColor"});function Nat(n,e,t){const r=n.segments,s=n.points,i=e.points,o=[];for(const a of r){let{start:l,end:c}=a;c=O4(l,c,s);const u=rF(t,s[l],s[c],a.loop);if(!e.segments){o.push({source:a,target:u,start:s[l],end:s[c]});continue}const h=Nse(e,u);for(const f of h){const d=rF(t,i[f.start],i[f.end],f.loop),p=Mse(a,s,d);for(const m of p)o.push({source:m,target:f,start:{[t]:I5(u,d,"start",Math.max)},end:{[t]:I5(u,d,"end",Math.min)}})}}return o}function rF(n,e,t,r){if(r)return;let s=e[n],i=t[n];return n==="angle"&&(s=ml(s),i=ml(i)),{property:n,start:s,end:i}}function $at(n,e){const{x:t=null,y:r=null}=n||{},s=e.points,i=[];return e.segments.forEach(({start:o,end:a})=>{a=O4(o,a,s);const l=s[o],c=s[a];r!==null?(i.push({x:l.x,y:r}),i.push({x:c.x,y:r})):t!==null&&(i.push({x:t,y:l.y}),i.push({x:t,y:c.y}))}),i}function O4(n,e,t){for(;e>n;e--){const r=t[e];if(!isNaN(r.x)&&!isNaN(r.y))break}return e}function I5(n,e,t,r){return n&&e?r(n[t],e[t]):n?n[t]:e?e[t]:0}function Xse(n,e){let t=[],r=!1;return gs(n)?(r=!0,t=n):t=$at(n,e),t.length?new Od({points:t,options:{tension:0},_loop:r,_fullLoop:r}):null}function A5(n){return n&&n.fill!==!1}function Rat(n,e,t){let s=n[e].fill;const i=[e];let o;if(!t)return s;for(;s!==!1&&i.indexOf(s)===-1;){if(!Zs(s))return s;if(o=n[s],!o)return!1;if(o.visible)return s;i.push(s),s=o.fill}return!1}function Pat(n,e,t){const r=Lat(n);if(nr(r))return isNaN(r.value)?!1:r;let s=parseFloat(r);return Zs(s)&&Math.floor(s)===s?Dat(r[0],e,s,t):["origin","start","end","stack","shape"].indexOf(r)>=0&&r}function Dat(n,e,t,r){return(n==="-"||n==="+")&&(t=e+t),t===e||t<0||t>=r?!1:t}function Oat(n,e){let t=null;return n==="start"?t=e.bottom:n==="end"?t=e.top:nr(n)?t=e.getPixelForValue(n.value):e.getBasePixel&&(t=e.getBasePixel()),t}function Fat(n,e,t){let r;return n==="start"?r=t:n==="end"?r=e.options.reverse?e.min:e.max:nr(n)?r=n.value:r=e.getBaseValue(),r}function Lat(n){const e=n.options,t=e.fill;let r=Un(t&&t.target,t);return r===void 0&&(r=!!e.backgroundColor),r===!1||r===null?!1:r===!0?"origin":r}function zat(n){const{scale:e,index:t,line:r}=n,s=[],i=r.segments,o=r.points,a=Bat(e,t);a.push(Xse({x:null,y:e.bottom},r));for(let l=0;l<i.length;l++){const c=i[l];for(let u=c.start;u<=c.end;u++)Vat(s,o[u],a)}return new Od({points:s,options:{}})}function Bat(n,e){const t=[],r=n.getMatchingVisibleMetas("line");for(let s=0;s<r.length;s++){const i=r[s];if(i.index===e)break;i.hidden||t.unshift(i.dataset)}return t}function Vat(n,e,t){const r=[];for(let s=0;s<t.length;s++){const i=t[s],{first:o,last:a,point:l}=Uat(i,e,"x");if(!(!l||o&&a)){if(o)r.unshift(l);else if(n.push(l),!a)break}}n.push(...r)}function Uat(n,e,t){const r=n.interpolate(e,t);if(!r)return{};const s=r[t],i=n.segments,o=n.points;let a=!1,l=!1;for(let c=0;c<i.length;c++){const u=i[c],h=o[u.start][t],f=o[u.end][t];if(Cf(s,h,f)){a=s===h,l=s===f;break}}return{first:a,last:l,point:r}}class Kse{constructor(e){this.x=e.x,this.y=e.y,this.radius=e.radius}pathSegment(e,t,r){const{x:s,y:i,radius:o}=this;return t=t||{start:0,end:bs},e.arc(s,i,o,t.end,t.start,!0),!r.bounds}interpolate(e){const{x:t,y:r,radius:s}=this,i=e.angle;return{x:t+Math.cos(i)*s,y:r+Math.sin(i)*s,angle:i}}}function Wat(n){const{chart:e,fill:t,line:r}=n;if(Zs(t))return Gat(e,t);if(t==="stack")return zat(n);if(t==="shape")return!0;const s=Hat(n);return s instanceof Kse?s:Xse(s,r)}function Gat(n,e){const t=n.getDatasetMeta(e);return t&&n.isDatasetVisible(e)?t.dataset:null}function Hat(n){return(n.scale||{}).getPointPositionForValue?qat(n):jat(n)}function jat(n){const{scale:e={},fill:t}=n,r=Oat(t,e);if(Zs(r)){const s=e.isHorizontal();return{x:s?r:null,y:s?null:r}}return null}function qat(n){const{scale:e,fill:t}=n,r=e.options,s=e.getLabels().length,i=r.reverse?e.max:e.min,o=Fat(t,e,i),a=[];if(r.grid.circular){const l=e.getPointPositionForValue(0,i);return new Kse({x:l.x,y:l.y,radius:e.getDistanceFromCenterForValue(o)})}for(let l=0;l<s;++l)a.push(e.getPointPositionForValue(l,o));return a}function V3(n,e,t){const r=Wat(e),{line:s,scale:i,axis:o}=e,a=s.options,l=a.fill,c=a.backgroundColor,{above:u=c,below:h=c}=l||{};r&&s.points.length&&(y$(n,t),Xat(n,{line:s,target:r,above:u,below:h,area:t,scale:i,axis:o}),b$(n))}function Xat(n,e){const{line:t,target:r,above:s,below:i,area:o,scale:a}=e,l=t._loop?"angle":e.axis;n.save(),l==="x"&&i!==s&&(M5(n,r,o.top),N5(n,{line:t,target:r,color:s,scale:a,property:l}),n.restore(),n.save(),M5(n,r,o.bottom)),N5(n,{line:t,target:r,color:i,scale:a,property:l}),n.restore()}function M5(n,e,t){const{segments:r,points:s}=e;let i=!0,o=!1;n.beginPath();for(const a of r){const{start:l,end:c}=a,u=s[l],h=s[O4(l,c,s)];i?(n.moveTo(u.x,u.y),i=!1):(n.lineTo(u.x,t),n.lineTo(u.x,u.y)),o=!!e.pathSegment(n,a,{move:o}),o?n.closePath():n.lineTo(h.x,t)}n.lineTo(e.first().x,t),n.closePath(),n.clip()}function N5(n,e){const{line:t,target:r,property:s,color:i,scale:o}=e,a=Nat(t,r,s);for(const{source:l,target:c,start:u,end:h}of a){const{style:{backgroundColor:f=i}={}}=l,d=r!==!0;n.save(),n.fillStyle=f,Kat(n,o,d&&rF(s,u,h)),n.beginPath();const p=!!t.pathSegment(n,l);let m;if(d){p?n.closePath():$5(n,r,h,s);const g=!!r.pathSegment(n,c,{move:p,reverse:!0});m=p&&g,m||$5(n,r,u,s)}n.closePath(),n.fill(m?"evenodd":"nonzero"),n.restore()}}function Kat(n,e,t){const{top:r,bottom:s}=e.chart.chartArea,{property:i,start:o,end:a}=t||{};i==="x"&&(n.beginPath(),n.rect(o,r,a-o,s-r),n.clip())}function $5(n,e,t,r){const s=e.interpolate(t,r);s&&n.lineTo(s.x,s.y)}var Yat={id:"filler",afterDatasetsUpdate(n,e,t){const r=(n.data.datasets||[]).length,s=[];let i,o,a,l;for(o=0;o<r;++o)i=n.getDatasetMeta(o),a=i.dataset,l=null,a&&a.options&&a instanceof Od&&(l={visible:n.isDatasetVisible(o),index:o,fill:Pat(a,o,r),chart:n,axis:i.controller.options.indexAxis,scale:i.vScale,line:a}),i.$filler=l,s.push(l);for(o=0;o<r;++o)l=s[o],!(!l||l.fill===!1)&&(l.fill=Rat(s,o,t.propagate))},beforeDraw(n,e,t){const r=t.drawTime==="beforeDraw",s=n.getSortedVisibleDatasetMetas(),i=n.chartArea;for(let o=s.length-1;o>=0;--o){const a=s[o].$filler;a&&(a.line.updateControlPoints(i,a.axis),r&&a.fill&&V3(n.ctx,a,i))}},beforeDatasetsDraw(n,e,t){if(t.drawTime!=="beforeDatasetsDraw")return;const r=n.getSortedVisibleDatasetMetas();for(let s=r.length-1;s>=0;--s){const i=r[s].$filler;A5(i)&&V3(n.ctx,i,n.chartArea)}},beforeDatasetDraw(n,e,t){const r=e.meta.$filler;!A5(r)||t.drawTime!=="beforeDatasetDraw"||V3(n.ctx,r,n.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const R5=(n,e)=>{let{boxHeight:t=e,boxWidth:r=e}=n;return n.usePointStyle&&(t=Math.min(t,e),r=n.pointStyleWidth||Math.min(r,e)),{boxWidth:r,boxHeight:t,itemHeight:Math.max(e,t)}},Zat=(n,e)=>n!==null&&e!==null&&n.datasetIndex===e.datasetIndex&&n.index===e.index;class P5 extends Ic{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,r){this.maxWidth=e,this.maxHeight=t,this._margins=r,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=is(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter(r=>e.filter(r,this.chart.data))),e.sort&&(t=t.sort((r,s)=>e.sort(r,s,this.chart.data))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display){this.width=this.height=0;return}const r=e.labels,s=Gi(r.font),i=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=R5(r,i);let c,u;t.font=s.string,this.isHorizontal()?(c=this.maxWidth,u=this._fitRows(o,i,a,l)+10):(u=this.maxHeight,c=this._fitCols(o,s,a,l)+10),this.width=Math.min(c,e.maxWidth||this.maxWidth),this.height=Math.min(u,e.maxHeight||this.maxHeight)}_fitRows(e,t,r,s){const{ctx:i,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],u=s+a;let h=e;i.textAlign="left",i.textBaseline="middle";let f=-1,d=-u;return this.legendItems.forEach((p,m)=>{const g=r+t/2+i.measureText(p.text).width;(m===0||c[c.length-1]+g+2*a>o)&&(h+=u,c[c.length-(m>0?0:1)]=0,d+=u,f++),l[m]={left:0,top:d,row:f,width:g,height:s},c[c.length-1]+=g+a}),h}_fitCols(e,t,r,s){const{ctx:i,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],u=o-e;let h=a,f=0,d=0,p=0,m=0;return this.legendItems.forEach((g,y)=>{const{itemWidth:b,itemHeight:x}=Jat(r,t,i,g,s);y>0&&d+x+2*a>u&&(h+=f+a,c.push({width:f,height:d}),p+=f+a,m++,f=d=0),l[y]={left:p,top:d,col:m,width:b,height:x},f=Math.max(f,b),d+=x+a}),h+=f,c.push({width:f,height:d}),h}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:r,labels:{padding:s},rtl:i}}=this,o=$b(i,this.left,this.width);if(this.isHorizontal()){let a=0,l=Lo(r,this.left+s,this.right-this.lineWidths[a]);for(const c of t)a!==c.row&&(a=c.row,l=Lo(r,this.left+s,this.right-this.lineWidths[a])),c.top+=this.top+e+s,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+s}else{let a=0,l=Lo(r,this.top+e+s,this.bottom-this.columnSizes[a].height);for(const c of t)c.col!==a&&(a=c.col,l=Lo(r,this.top+e+s,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+s,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+s}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const e=this.ctx;y$(e,this),this._draw(),b$(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:r,ctx:s}=this,{align:i,labels:o}=e,a=ai.color,l=$b(e.rtl,this.left,this.width),c=Gi(o.font),{padding:u}=o,h=c.size,f=h/2;let d;this.drawTitle(),s.textAlign=l.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=c.string;const{boxWidth:p,boxHeight:m,itemHeight:g}=R5(o,h),y=function(C,k,A){if(isNaN(p)||p<=0||isNaN(m)||m<0)return;s.save();const M=Un(A.lineWidth,1);if(s.fillStyle=Un(A.fillStyle,a),s.lineCap=Un(A.lineCap,"butt"),s.lineDashOffset=Un(A.lineDashOffset,0),s.lineJoin=Un(A.lineJoin,"miter"),s.lineWidth=M,s.strokeStyle=Un(A.strokeStyle,a),s.setLineDash(Un(A.lineDash,[])),o.usePointStyle){const E={radius:m*Math.SQRT2/2,pointStyle:A.pointStyle,rotation:A.rotation,borderWidth:M},N=l.xPlus(C,p/2),O=k+f;bse(s,E,N,O,o.pointStyleWidth&&p)}else{const E=k+Math.max((h-m)/2,0),N=l.leftForLtr(C,p),O=Xd(A.borderRadius);s.beginPath(),Object.values(O).some(R=>R!==0)?qd(s,{x:N,y:E,w:p,h:m,radius:O}):s.rect(N,E,p,m),s.fill(),M!==0&&s.stroke()}s.restore()},b=function(C,k,A){yg(s,A.text,C,k+g/2,c,{strikethrough:A.hidden,textAlign:l.textAlign(A.textAlign)})},x=this.isHorizontal(),w=this._computeTitleHeight();x?d={x:Lo(i,this.left+u,this.right-r[0]),y:this.top+u+w,line:0}:d={x:this.left+u,y:Lo(i,this.top+w+u,this.bottom-t[0].height),line:0},Ese(this.ctx,e.textDirection);const S=g+u;this.legendItems.forEach((C,k)=>{s.strokeStyle=C.fontColor,s.fillStyle=C.fontColor;const A=s.measureText(C.text).width,M=l.textAlign(C.textAlign||(C.textAlign=o.textAlign)),E=p+f+A;let N=d.x,O=d.y;l.setWidth(this.width),x?k>0&&N+E+u>this.right&&(O=d.y+=S,d.line++,N=d.x=Lo(i,this.left+u,this.right-r[d.line])):k>0&&O+S>this.bottom&&(N=d.x=N+t[d.line].width+u,d.line++,O=d.y=Lo(i,this.top+w+u,this.bottom-t[d.line].height));const R=l.x(N);if(y(R,O,C),N=Rst(M,N+p+f,x?N+E:this.right,e.rtl),b(l.x(N),O,C),x)d.x+=E+u;else if(typeof C.text!="string"){const D=c.lineHeight;d.y+=Yse(C,D)}else d.y+=S}),Ise(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,r=Gi(t.font),s=Jo(t.padding);if(!t.display)return;const i=$b(e.rtl,this.left,this.width),o=this.ctx,a=t.position,l=r.size/2,c=s.top+l;let u,h=this.left,f=this.width;if(this.isHorizontal())f=Math.max(...this.lineWidths),u=this.top+c,h=Lo(e.align,h,this.right-f);else{const p=this.columnSizes.reduce((m,g)=>Math.max(m,g.height),0);u=c+Lo(e.align,this.top,this.bottom-p-e.labels.padding-this._computeTitleHeight())}const d=Lo(a,h,h+f);o.textAlign=i.textAlign(A4(a)),o.textBaseline="middle",o.strokeStyle=t.color,o.fillStyle=t.color,o.font=r.string,yg(o,t.text,d,u,r)}_computeTitleHeight(){const e=this.options.title,t=Gi(e.font),r=Jo(e.padding);return e.display?t.lineHeight+r.height:0}_getLegendItemAt(e,t){let r,s,i;if(Cf(e,this.left,this.right)&&Cf(t,this.top,this.bottom)){for(i=this.legendHitBoxes,r=0;r<i.length;++r)if(s=i[r],Cf(e,s.left,s.left+s.width)&&Cf(t,s.top,s.top+s.height))return this.legendItems[r]}return null}handleEvent(e){const t=this.options;if(!tlt(e.type,t))return;const r=this._getLegendItemAt(e.x,e.y);if(e.type==="mousemove"||e.type==="mouseout"){const s=this._hoveredItem,i=Zat(s,r);s&&!i&&is(t.onLeave,[e,s,this],this),this._hoveredItem=r,r&&!i&&is(t.onHover,[e,r,this],this)}else r&&is(t.onClick,[e,r,this],this)}}function Jat(n,e,t,r,s){const i=Qat(r,n,e,t),o=elt(s,r,e.lineHeight);return{itemWidth:i,itemHeight:o}}function Qat(n,e,t,r){let s=n.text;return s&&typeof s!="string"&&(s=s.reduce((i,o)=>i.length>o.length?i:o)),e+t.size/2+r.measureText(s).width}function elt(n,e,t){let r=n;return typeof e.text!="string"&&(r=Yse(e,t)),r}function Yse(n,e){const t=n.text?n.text.length+.5:0;return e*t}function tlt(n,e){return!!((n==="mousemove"||n==="mouseout")&&(e.onHover||e.onLeave)||e.onClick&&(n==="click"||n==="mouseup"))}var nlt={id:"legend",_element:P5,start(n,e,t){const r=n.legend=new P5({ctx:n.ctx,options:t,chart:n});mc.configure(n,r,t),mc.addBox(n,r)},stop(n){mc.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,e,t){const r=n.legend;mc.configure(n,r,t),r.options=t},afterUpdate(n){const e=n.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(n,e){e.replay||n.legend.handleEvent(e.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,e,t){const r=e.datasetIndex,s=t.chart;s.isDatasetVisible(r)?(s.hide(r),e.hidden=!0):(s.show(r),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const e=n.data.datasets,{labels:{usePointStyle:t,pointStyle:r,textAlign:s,color:i,useBorderRadius:o,borderRadius:a}}=n.legend.options;return n._getSortedDatasetMetas().map(l=>{const c=l.controller.getStyle(t?0:void 0),u=Jo(c.borderWidth);return{text:e[l.index].label,fillStyle:c.backgroundColor,fontColor:i,hidden:!l.visible,lineCap:c.borderCapStyle,lineDash:c.borderDash,lineDashOffset:c.borderDashOffset,lineJoin:c.borderJoinStyle,lineWidth:(u.width+u.height)/4,strokeStyle:c.borderColor,pointStyle:r||c.pointStyle,rotation:c.rotation,textAlign:s||c.textAlign,borderRadius:o&&(a||c.borderRadius),datasetIndex:l.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};class Zse extends Ic{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const r=this.options;if(this.left=0,this.top=0,!r.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=e,this.height=this.bottom=t;const s=gs(r.text)?r.text.length:1;this._padding=Jo(r.padding);const i=s*Gi(r.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=i:this.width=i}isHorizontal(){const e=this.options.position;return e==="top"||e==="bottom"}_drawArgs(e){const{top:t,left:r,bottom:s,right:i,options:o}=this,a=o.align;let l=0,c,u,h;return this.isHorizontal()?(u=Lo(a,r,i),h=t+e,c=i-r):(o.position==="left"?(u=r+e,h=Lo(a,s,t),l=Ts*-.5):(u=i-e,h=Lo(a,t,s),l=Ts*.5),c=s-t),{titleX:u,titleY:h,maxWidth:c,rotation:l}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const r=Gi(t.font),i=r.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(i);yg(e,t.text,0,0,r,{color:t.color,maxWidth:l,rotation:c,textAlign:A4(t.align),textBaseline:"middle",translation:[o,a]})}}function rlt(n,e){const t=new Zse({ctx:n.ctx,options:e,chart:n});mc.configure(n,t,e),mc.addBox(n,t),n.titleBlock=t}var Jse={id:"title",_element:Zse,start(n,e,t){rlt(n,t)},stop(n){const e=n.titleBlock;mc.removeBox(n,e),delete n.titleBlock},beforeUpdate(n,e,t){const r=n.titleBlock;mc.configure(n,r,t),r.options=t},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const N1={average(n){if(!n.length)return!1;let e,t,r=0,s=0,i=0;for(e=0,t=n.length;e<t;++e){const o=n[e].element;if(o&&o.hasValue()){const a=o.tooltipPosition();r+=a.x,s+=a.y,++i}}return{x:r/i,y:s/i}},nearest(n,e){if(!n.length)return!1;let t=e.x,r=e.y,s=Number.POSITIVE_INFINITY,i,o,a;for(i=0,o=n.length;i<o;++i){const l=n[i].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),u=ZO(e,c);u<s&&(s=u,a=l)}}if(a){const l=a.tooltipPosition();t=l.x,r=l.y}return{x:t,y:r}}};function Qu(n,e){return e&&(gs(e)?Array.prototype.push.apply(n,e):n.push(e)),n}function uf(n){return(typeof n=="string"||n instanceof String)&&n.indexOf(`
`)>-1?n.split(`
`):n}function slt(n,e){const{element:t,datasetIndex:r,index:s}=e,i=n.getDatasetMeta(r).controller,{label:o,value:a}=i.getLabelAndValue(s);return{chart:n,label:o,parsed:i.getParsed(s),raw:n.data.datasets[r].data[s],formattedValue:a,dataset:i.getDataset(),dataIndex:s,datasetIndex:r,element:t}}function D5(n,e){const t=n.chart.ctx,{body:r,footer:s,title:i}=n,{boxWidth:o,boxHeight:a}=e,l=Gi(e.bodyFont),c=Gi(e.titleFont),u=Gi(e.footerFont),h=i.length,f=s.length,d=r.length,p=Jo(e.padding);let m=p.height,g=0,y=r.reduce((w,S)=>w+S.before.length+S.lines.length+S.after.length,0);if(y+=n.beforeBody.length+n.afterBody.length,h&&(m+=h*c.lineHeight+(h-1)*e.titleSpacing+e.titleMarginBottom),y){const w=e.displayColors?Math.max(a,l.lineHeight):l.lineHeight;m+=d*w+(y-d)*l.lineHeight+(y-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*u.lineHeight+(f-1)*e.footerSpacing);let b=0;const x=function(w){g=Math.max(g,t.measureText(w).width+b)};return t.save(),t.font=c.string,Dr(n.title,x),t.font=l.string,Dr(n.beforeBody.concat(n.afterBody),x),b=e.displayColors?o+2+e.boxPadding:0,Dr(r,w=>{Dr(w.before,x),Dr(w.lines,x),Dr(w.after,x)}),b=0,t.font=u.string,Dr(n.footer,x),t.restore(),g+=p.width,{width:g,height:m}}function ilt(n,e){const{y:t,height:r}=e;return t<r/2?"top":t>n.height-r/2?"bottom":"center"}function olt(n,e,t,r){const{x:s,width:i}=r,o=t.caretSize+t.caretPadding;if(n==="left"&&s+i+o>e.width||n==="right"&&s-i-o<0)return!0}function alt(n,e,t,r){const{x:s,width:i}=t,{width:o,chartArea:{left:a,right:l}}=n;let c="center";return r==="center"?c=s<=(a+l)/2?"left":"right":s<=i/2?c="left":s>=o-i/2&&(c="right"),olt(c,n,e,t)&&(c="center"),c}function O5(n,e,t){const r=t.yAlign||e.yAlign||ilt(n,t);return{xAlign:t.xAlign||e.xAlign||alt(n,e,t,r),yAlign:r}}function llt(n,e){let{x:t,width:r}=n;return e==="right"?t-=r:e==="center"&&(t-=r/2),t}function clt(n,e,t){let{y:r,height:s}=n;return e==="top"?r+=t:e==="bottom"?r-=s+t:r-=s/2,r}function F5(n,e,t,r){const{caretSize:s,caretPadding:i,cornerRadius:o}=n,{xAlign:a,yAlign:l}=t,c=s+i,{topLeft:u,topRight:h,bottomLeft:f,bottomRight:d}=Xd(o);let p=llt(e,a);const m=clt(e,l,c);return l==="center"?a==="left"?p+=c:a==="right"&&(p-=c):a==="left"?p-=Math.max(u,f)+s:a==="right"&&(p+=Math.max(h,d)+s),{x:Xo(p,0,r.width-e.width),y:Xo(m,0,r.height-e.height)}}function xT(n,e,t){const r=Jo(t.padding);return e==="center"?n.x+n.width/2:e==="right"?n.x+n.width-r.right:n.x+r.left}function L5(n){return Qu([],uf(n))}function ult(n,e,t){return Lp(n,{tooltip:e,tooltipItems:t,type:"tooltip"})}function z5(n,e){const t=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return t?n.override(t):n}const Qse={beforeTitle:tf,title(n){if(n.length>0){const e=n[0],t=e.chart.data.labels,r=t?t.length:0;if(this&&this.options&&this.options.mode==="dataset")return e.dataset.label||"";if(e.label)return e.label;if(r>0&&e.dataIndex<r)return t[e.dataIndex]}return""},afterTitle:tf,beforeBody:tf,beforeLabel:tf,label(n){if(this&&this.options&&this.options.mode==="dataset")return n.label+": "+n.formattedValue||n.formattedValue;let e=n.dataset.label||"";e&&(e+=": ");const t=n.formattedValue;return Nr(t)||(e+=t),e},labelColor(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const t=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:tf,afterBody:tf,beforeFooter:tf,footer:tf,afterFooter:tf};function La(n,e,t,r){const s=n[e].call(t,r);return typeof s>"u"?Qse[e].call(t,r):s}class sF extends Ic{constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,r=this.options.setContext(this.getContext()),s=r.enabled&&t.options.animation&&r.animations,i=new $se(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(i)),i}getContext(){return this.$context||(this.$context=ult(this.chart.getContext(),this,this._tooltipItems))}getTitle(e,t){const{callbacks:r}=t,s=La(r,"beforeTitle",this,e),i=La(r,"title",this,e),o=La(r,"afterTitle",this,e);let a=[];return a=Qu(a,uf(s)),a=Qu(a,uf(i)),a=Qu(a,uf(o)),a}getBeforeBody(e,t){return L5(La(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:r}=t,s=[];return Dr(e,i=>{const o={before:[],lines:[],after:[]},a=z5(r,i);Qu(o.before,uf(La(a,"beforeLabel",this,i))),Qu(o.lines,La(a,"label",this,i)),Qu(o.after,uf(La(a,"afterLabel",this,i))),s.push(o)}),s}getAfterBody(e,t){return L5(La(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:r}=t,s=La(r,"beforeFooter",this,e),i=La(r,"footer",this,e),o=La(r,"afterFooter",this,e);let a=[];return a=Qu(a,uf(s)),a=Qu(a,uf(i)),a=Qu(a,uf(o)),a}_createItems(e){const t=this._active,r=this.chart.data,s=[],i=[],o=[];let a=[],l,c;for(l=0,c=t.length;l<c;++l)a.push(slt(this.chart,t[l]));return e.filter&&(a=a.filter((u,h,f)=>e.filter(u,h,f,r))),e.itemSort&&(a=a.sort((u,h)=>e.itemSort(u,h,r))),Dr(a,u=>{const h=z5(e.callbacks,u);s.push(La(h,"labelColor",this,u)),i.push(La(h,"labelPointStyle",this,u)),o.push(La(h,"labelTextColor",this,u))}),this.labelColors=s,this.labelPointStyles=i,this.labelTextColors=o,this.dataPoints=a,a}update(e,t){const r=this.options.setContext(this.getContext()),s=this._active;let i,o=[];if(!s.length)this.opacity!==0&&(i={opacity:0});else{const a=N1[r.position].call(this,s,this._eventPosition);o=this._createItems(r),this.title=this.getTitle(o,r),this.beforeBody=this.getBeforeBody(o,r),this.body=this.getBody(o,r),this.afterBody=this.getAfterBody(o,r),this.footer=this.getFooter(o,r);const l=this._size=D5(this,r),c=Object.assign({},a,l),u=O5(this.chart,r,c),h=F5(r,c,u,this.chart);this.xAlign=u.xAlign,this.yAlign=u.yAlign,i={opacity:1,x:h.x,y:h.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=o,this.$context=void 0,i&&this._resolveAnimations().update(this,i),e&&r.external&&r.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,r,s){const i=this.getCaretPosition(e,r,s);t.lineTo(i.x1,i.y1),t.lineTo(i.x2,i.y2),t.lineTo(i.x3,i.y3)}getCaretPosition(e,t,r){const{xAlign:s,yAlign:i}=this,{caretSize:o,cornerRadius:a}=r,{topLeft:l,topRight:c,bottomLeft:u,bottomRight:h}=Xd(a),{x:f,y:d}=e,{width:p,height:m}=t;let g,y,b,x,w,S;return i==="center"?(w=d+m/2,s==="left"?(g=f,y=g-o,x=w+o,S=w-o):(g=f+p,y=g+o,x=w-o,S=w+o),b=g):(s==="left"?y=f+Math.max(l,u)+o:s==="right"?y=f+p-Math.max(c,h)-o:y=this.caretX,i==="top"?(x=d,w=x-o,g=y-o,b=y+o):(x=d+m,w=x+o,g=y+o,b=y-o),S=x),{x1:g,x2:y,x3:b,y1:x,y2:w,y3:S}}drawTitle(e,t,r){const s=this.title,i=s.length;let o,a,l;if(i){const c=$b(r.rtl,this.x,this.width);for(e.x=xT(this,r.titleAlign,r),t.textAlign=c.textAlign(r.titleAlign),t.textBaseline="middle",o=Gi(r.titleFont),a=r.titleSpacing,t.fillStyle=r.titleColor,t.font=o.string,l=0;l<i;++l)t.fillText(s[l],c.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+a,l+1===i&&(e.y+=r.titleMarginBottom-a)}}_drawColorBox(e,t,r,s,i){const o=this.labelColors[r],a=this.labelPointStyles[r],{boxHeight:l,boxWidth:c,boxPadding:u}=i,h=Gi(i.bodyFont),f=xT(this,"left",i),d=s.x(f),p=l<h.lineHeight?(h.lineHeight-l)/2:0,m=t.y+p;if(i.usePointStyle){const g={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},y=s.leftForLtr(d,c)+c/2,b=m+l/2;e.strokeStyle=i.multiKeyBackground,e.fillStyle=i.multiKeyBackground,QO(e,g,y,b),e.strokeStyle=o.borderColor,e.fillStyle=o.backgroundColor,QO(e,g,y,b)}else{e.lineWidth=nr(o.borderWidth)?Math.max(...Object.values(o.borderWidth)):o.borderWidth||1,e.strokeStyle=o.borderColor,e.setLineDash(o.borderDash||[]),e.lineDashOffset=o.borderDashOffset||0;const g=s.leftForLtr(d,c-u),y=s.leftForLtr(s.xPlus(d,1),c-u-2),b=Xd(o.borderRadius);Object.values(b).some(x=>x!==0)?(e.beginPath(),e.fillStyle=i.multiKeyBackground,qd(e,{x:g,y:m,w:c,h:l,radius:b}),e.fill(),e.stroke(),e.fillStyle=o.backgroundColor,e.beginPath(),qd(e,{x:y,y:m+1,w:c-2,h:l-2,radius:b}),e.fill()):(e.fillStyle=i.multiKeyBackground,e.fillRect(g,m,c,l),e.strokeRect(g,m,c,l),e.fillStyle=o.backgroundColor,e.fillRect(y,m+1,c-2,l-2))}e.fillStyle=this.labelTextColors[r]}drawBody(e,t,r){const{body:s}=this,{bodySpacing:i,bodyAlign:o,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:u}=r,h=Gi(r.bodyFont);let f=h.lineHeight,d=0;const p=$b(r.rtl,this.x,this.width),m=function(A){t.fillText(A,p.x(e.x+d),e.y+f/2),e.y+=f+i},g=p.textAlign(o);let y,b,x,w,S,C,k;for(t.textAlign=o,t.textBaseline="middle",t.font=h.string,e.x=xT(this,g,r),t.fillStyle=r.bodyColor,Dr(this.beforeBody,m),d=a&&g!=="right"?o==="center"?c/2+u:c+2+u:0,w=0,C=s.length;w<C;++w){for(y=s[w],b=this.labelTextColors[w],t.fillStyle=b,Dr(y.before,m),x=y.lines,a&&x.length&&(this._drawColorBox(t,e,w,p,r),f=Math.max(h.lineHeight,l)),S=0,k=x.length;S<k;++S)m(x[S]),f=h.lineHeight;Dr(y.after,m)}d=0,f=h.lineHeight,Dr(this.afterBody,m),e.y-=i}drawFooter(e,t,r){const s=this.footer,i=s.length;let o,a;if(i){const l=$b(r.rtl,this.x,this.width);for(e.x=xT(this,r.footerAlign,r),e.y+=r.footerMarginTop,t.textAlign=l.textAlign(r.footerAlign),t.textBaseline="middle",o=Gi(r.footerFont),t.fillStyle=r.footerColor,t.font=o.string,a=0;a<i;++a)t.fillText(s[a],l.x(e.x),e.y+o.lineHeight/2),e.y+=o.lineHeight+r.footerSpacing}}drawBackground(e,t,r,s){const{xAlign:i,yAlign:o}=this,{x:a,y:l}=e,{width:c,height:u}=r,{topLeft:h,topRight:f,bottomLeft:d,bottomRight:p}=Xd(s.cornerRadius);t.fillStyle=s.backgroundColor,t.strokeStyle=s.borderColor,t.lineWidth=s.borderWidth,t.beginPath(),t.moveTo(a+h,l),o==="top"&&this.drawCaret(e,t,r,s),t.lineTo(a+c-f,l),t.quadraticCurveTo(a+c,l,a+c,l+f),o==="center"&&i==="right"&&this.drawCaret(e,t,r,s),t.lineTo(a+c,l+u-p),t.quadraticCurveTo(a+c,l+u,a+c-p,l+u),o==="bottom"&&this.drawCaret(e,t,r,s),t.lineTo(a+d,l+u),t.quadraticCurveTo(a,l+u,a,l+u-d),o==="center"&&i==="left"&&this.drawCaret(e,t,r,s),t.lineTo(a,l+h),t.quadraticCurveTo(a,l,a+h,l),t.closePath(),t.fill(),s.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,r=this.$animations,s=r&&r.x,i=r&&r.y;if(s||i){const o=N1[e.position].call(this,this._active,this._eventPosition);if(!o)return;const a=this._size=D5(this,e),l=Object.assign({},o,this._size),c=O5(t,e,l),u=F5(e,l,c,t);(s._to!==u.x||i._to!==u.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=o.x,this.caretY=o.y,this._resolveAnimations().update(this,u))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let r=this.opacity;if(!r)return;this._updateAnimationTarget(t);const s={width:this.width,height:this.height},i={x:this.x,y:this.y};r=Math.abs(r)<.001?0:r;const o=Jo(t.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&a&&(e.save(),e.globalAlpha=r,this.drawBackground(i,e,s,t),Ese(e,t.textDirection),i.y+=o.top,this.drawTitle(i,e,t),this.drawBody(i,e,t),this.drawFooter(i,e,t),Ise(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const r=this._active,s=e.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:c.data[l],index:l}}),i=!lA(r,s),o=this._positionChanged(s,t);(i||o)&&(this._active=s,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t,r=!0){if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,i=this._active||[],o=this._getActiveElements(e,i,t,r),a=this._positionChanged(o,e),l=t||!lA(o,i)||a;return l&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),l}_getActiveElements(e,t,r,s){const i=this.options;if(e.type==="mouseout")return[];if(!s)return t;const o=this.chart.getElementsAtEventForMode(e,i.mode,i,r);return i.reverse&&o.reverse(),o}_positionChanged(e,t){const{caretX:r,caretY:s,options:i}=this,o=N1[i.position].call(this,e,t);return o!==!1&&(r!==o.x||s!==o.y)}}Mt(sF,"positioners",N1);var eie={id:"tooltip",_element:sF,positioners:N1,afterInit(n,e,t){t&&(n.tooltip=new sF({chart:n,options:t}))},beforeUpdate(n,e,t){n.tooltip&&n.tooltip.initialize(t)},reset(n,e,t){n.tooltip&&n.tooltip.initialize(t)},afterDraw(n){const e=n.tooltip;if(e&&e._willRender()){const t={tooltip:e};if(n.notifyPlugins("beforeTooltipDraw",{...t,cancelable:!0})===!1)return;e.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",t)}},afterEvent(n,e){if(n.tooltip){const t=e.replay;n.tooltip.handleEvent(e.event,t,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,e)=>e.bodyFont.size,boxWidth:(n,e)=>e.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Qse},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>n!=="filter"&&n!=="itemSort"&&n!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const hlt=(n,e,t,r)=>(typeof e=="string"?(t=n.push(e)-1,r.unshift({index:t,label:e})):isNaN(e)&&(t=null),t);function flt(n,e,t,r){const s=n.indexOf(e);if(s===-1)return hlt(n,e,t,r);const i=n.lastIndexOf(e);return s!==i?t:s}const dlt=(n,e)=>n===null?null:Xo(Math.round(n),0,e);function B5(n){const e=this.getLabels();return n>=0&&n<e.length?e[n]:n}class gA extends Ky{constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const r=this.getLabels();for(const{index:s,label:i}of t)r[s]===i&&r.splice(s,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(Nr(e))return null;const r=this.getLabels();return t=isFinite(t)&&r[t]===e?t:flt(r,e,Un(t,e),this._addedLabels),dlt(t,r.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:r,max:s}=this.getMinMax(!0);this.options.bounds==="ticks"&&(e||(r=0),t||(s=this.getLabels().length-1)),this.min=r,this.max=s}buildTicks(){const e=this.min,t=this.max,r=this.options.offset,s=[];let i=this.getLabels();i=e===0&&t===i.length-1?i:i.slice(e,t+1),this._valueRange=Math.max(i.length-(r?0:1),1),this._startValue=this.min-(r?.5:0);for(let o=e;o<=t;o++)s.push({value:o});return s}getLabelForValue(e){return B5.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return typeof e!="number"&&(e=this.parse(e)),e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}Mt(gA,"id","category"),Mt(gA,"defaults",{ticks:{callback:B5}});function plt(n,e){const t=[],{bounds:s,step:i,min:o,max:a,precision:l,count:c,maxTicks:u,maxDigits:h,includeBounds:f}=n,d=i||1,p=u-1,{min:m,max:g}=e,y=!Nr(o),b=!Nr(a),x=!Nr(c),w=(g-m)/(h+1);let S=z6((g-m)/p/d)*d,C,k,A,M;if(S<1e-14&&!y&&!b)return[{value:m},{value:g}];M=Math.ceil(g/S)-Math.floor(m/S),M>p&&(S=z6(M*S/p/d)*d),Nr(l)||(C=Math.pow(10,l),S=Math.ceil(S*C)/C),s==="ticks"?(k=Math.floor(m/S)*S,A=Math.ceil(g/S)*S):(k=m,A=g),y&&b&&i&&Tst((a-o)/i,S/1e3)?(M=Math.round(Math.min((a-o)/S,u)),S=(a-o)/M,k=o,A=a):x?(k=y?o:k,A=b?a:A,M=c-1,S=(A-k)/M):(M=(A-k)/S,e_(M,Math.round(M),S/1e3)?M=Math.round(M):M=Math.ceil(M));const E=Math.max(B6(S),B6(k));C=Math.pow(10,Nr(l)?E:l),k=Math.round(k*C)/C,A=Math.round(A*C)/C;let N=0;for(y&&(f&&k!==o?(t.push({value:o}),k<o&&N++,e_(Math.round((k+N*S)*C)/C,o,V5(o,w,n))&&N++):k<o&&N++);N<M;++N)t.push({value:Math.round((k+N*S)*C)/C});return b&&f&&A!==a?t.length&&e_(t[t.length-1].value,a,V5(a,w,n))?t[t.length-1].value=a:t.push({value:a}):(!b||A===a)&&t.push({value:A}),t}function V5(n,e,{horizontal:t,minRotation:r}){const s=hu(r),i=(t?Math.sin(s):Math.cos(s))||.001,o=.75*e*(""+n).length;return Math.min(e/i,o)}class yA extends Ky{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return Nr(e)||(typeof e=="number"||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:r}=this.getUserBounds();let{min:s,max:i}=this;const o=l=>s=t?s:l,a=l=>i=r?i:l;if(e){const l=yh(s),c=yh(i);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(s===i){let l=i===0?1:Math.abs(i*.05);a(i+l),e||o(s-l)}this.min=s,this.max=i}getTickLimit(){const e=this.options.ticks;let{maxTicksLimit:t,stepSize:r}=e,s;return r?(s=Math.ceil(this.max/r)-Math.floor(this.min/r)+1,s>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${r} would result generating up to ${s} ticks. Limiting to 1000.`),s=1e3)):(s=this.computeTickLimit(),t=t||11),t&&(s=Math.min(t,s)),s}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let r=this.getTickLimit();r=Math.max(2,r);const s={maxTicks:r,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:t.includeBounds!==!1},i=this._range||this,o=plt(s,i);return e.bounds==="ticks"&&lse(o,this,"value"),e.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const e=this.ticks;let t=this.min,r=this.max;if(super.configure(),this.options.offset&&e.length){const s=(r-t)/Math.max(e.length-1,1)/2;t-=s,r+=s}this._startValue=t,this._endValue=r,this._valueRange=r-t}getLabelForValue(e){return NC(e,this.chart.options.locale,this.options.ticks.format)}}class iF extends yA{determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Zs(e)?e:0,this.max=Zs(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,r=hu(this.options.ticks.minRotation),s=(e?Math.sin(r):Math.cos(r))||.001,i=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,i.lineHeight/s))}getPixelForValue(e){return e===null?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}Mt(iF,"id","linear"),Mt(iF,"defaults",{ticks:{callback:g$.formatters.numeric}});const tS=n=>Math.floor(Dd(n)),lm=(n,e)=>Math.pow(10,tS(n)+e);function U5(n){return n/Math.pow(10,tS(n))===1}function W5(n,e,t){const r=Math.pow(10,t),s=Math.floor(n/r);return Math.ceil(e/r)-s}function mlt(n,e){const t=e-n;let r=tS(t);for(;W5(n,e,r)>10;)r++;for(;W5(n,e,r)<10;)r--;return Math.min(r,tS(n))}function glt(n,{min:e,max:t}){e=pl(n.min,e);const r=[],s=tS(e);let i=mlt(e,t),o=i<0?Math.pow(10,Math.abs(i)):1;const a=Math.pow(10,i),l=s>i?Math.pow(10,s):0,c=Math.round((e-l)*o)/o,u=Math.floor((e-l)/a/10)*a*10;let h=Math.floor((c-u)/Math.pow(10,i)),f=pl(n.min,Math.round((l+u+h*Math.pow(10,i))*o)/o);for(;f<t;)r.push({value:f,major:U5(f),significand:h}),h>=10?h=h<15?15:20:h++,h>=20&&(i++,h=2,o=i>=0?1:o),f=Math.round((l+u+h*Math.pow(10,i))*o)/o;const d=pl(n.max,f);return r.push({value:d,major:U5(d),significand:h}),r}class oF extends Ky{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const r=yA.prototype.parse.apply(this,[e,t]);if(r===0){this._zero=!0;return}return Zs(r)&&r>0?r:null}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=Zs(e)?Math.max(0,e):null,this.max=Zs(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!Zs(this._userMin)&&(this.min=e===lm(this.min,0)?lm(this.min,-1):lm(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let r=this.min,s=this.max;const i=a=>r=e?r:a,o=a=>s=t?s:a;r===s&&(r<=0?(i(1),o(10)):(i(lm(r,-1)),o(lm(s,1)))),r<=0&&i(lm(s,-1)),s<=0&&o(lm(r,1)),this.min=r,this.max=s}buildTicks(){const e=this.options,t={min:this._userMin,max:this._userMax},r=glt(t,this);return e.bounds==="ticks"&&lse(r,this,"value"),e.reverse?(r.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),r}getLabelForValue(e){return e===void 0?"0":NC(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=Dd(e),this._valueRange=Dd(this.max)-Dd(e)}getPixelForValue(e){return(e===void 0||e===0)&&(e=this.min),e===null||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:(Dd(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}Mt(oF,"id","logarithmic"),Mt(oF,"defaults",{ticks:{callback:g$.formatters.logarithmic,major:{enabled:!0}}});function aF(n){const e=n.ticks;if(e.display&&n.display){const t=Jo(e.backdropPadding);return Un(e.font&&e.font.size,ai.font.size)+t.height}return 0}function ylt(n,e,t){return t=gs(t)?t:[t],{w:Wst(n,e.string,t),h:t.length*e.lineHeight}}function G5(n,e,t,r,s){return n===r||n===s?{start:e-t/2,end:e+t/2}:n<r||n>s?{start:e-t,end:e}:{start:e,end:e+t}}function blt(n){const e={l:n.left+n._padding.left,r:n.right-n._padding.right,t:n.top+n._padding.top,b:n.bottom-n._padding.bottom},t=Object.assign({},e),r=[],s=[],i=n._pointLabels.length,o=n.options.pointLabels,a=o.centerPointLabels?Ts/i:0;for(let l=0;l<i;l++){const c=o.setContext(n.getPointLabelContext(l));s[l]=c.padding;const u=n.getPointPosition(l,n.drawingArea+s[l],a),h=Gi(c.font),f=ylt(n.ctx,h,n._pointLabels[l]);r[l]=f;const d=ml(n.getIndexAngle(l)+a),p=Math.round(E4(d)),m=G5(p,u.x,f.w,0,180),g=G5(p,u.y,f.h,90,270);vlt(t,e,d,m,g)}n.setCenterPoint(e.l-t.l,t.r-e.r,e.t-t.t,t.b-e.b),n._pointLabelItems=wlt(n,r,s)}function vlt(n,e,t,r,s){const i=Math.abs(Math.sin(t)),o=Math.abs(Math.cos(t));let a=0,l=0;r.start<e.l?(a=(e.l-r.start)/i,n.l=Math.min(n.l,e.l-a)):r.end>e.r&&(a=(r.end-e.r)/i,n.r=Math.max(n.r,e.r+a)),s.start<e.t?(l=(e.t-s.start)/o,n.t=Math.min(n.t,e.t-l)):s.end>e.b&&(l=(s.end-e.b)/o,n.b=Math.max(n.b,e.b+l))}function wlt(n,e,t){const r=[],s=n._pointLabels.length,i=n.options,o=aF(i)/2,a=n.drawingArea,l=i.pointLabels.centerPointLabels?Ts/s:0;for(let c=0;c<s;c++){const u=n.getPointPosition(c,a+o+t[c],l),h=Math.round(E4(ml(u.angle+Js))),f=e[c],d=Slt(u.y,f.h,h),p=xlt(h),m=_lt(u.x,f.w,p);r.push({x:u.x,y:d,textAlign:p,left:m,top:d,right:m+f.w,bottom:d+f.h})}return r}function xlt(n){return n===0||n===180?"center":n<180?"left":"right"}function _lt(n,e,t){return t==="right"?n-=e:t==="center"&&(n-=e/2),n}function Slt(n,e,t){return t===90||t===270?n-=e/2:(t>270||t<90)&&(n-=e),n}function Clt(n,e){const{ctx:t,options:{pointLabels:r}}=n;for(let s=e-1;s>=0;s--){const i=r.setContext(n.getPointLabelContext(s)),o=Gi(i.font),{x:a,y:l,textAlign:c,left:u,top:h,right:f,bottom:d}=n._pointLabelItems[s],{backdropColor:p}=i;if(!Nr(p)){const m=Xd(i.borderRadius),g=Jo(i.backdropPadding);t.fillStyle=p;const y=u-g.left,b=h-g.top,x=f-u+g.width,w=d-h+g.height;Object.values(m).some(S=>S!==0)?(t.beginPath(),qd(t,{x:y,y:b,w:x,h:w,radius:m}),t.fill()):t.fillRect(y,b,x,w)}yg(t,n._pointLabels[s],a,l+o.lineHeight/2,o,{color:i.color,textAlign:c,textBaseline:"middle"})}}function tie(n,e,t,r){const{ctx:s}=n;if(t)s.arc(n.xCenter,n.yCenter,e,0,bs);else{let i=n.getPointPosition(0,e);s.moveTo(i.x,i.y);for(let o=1;o<r;o++)i=n.getPointPosition(o,e),s.lineTo(i.x,i.y)}}function klt(n,e,t,r,s){const i=n.ctx,o=e.circular,{color:a,lineWidth:l}=e;!o&&!r||!a||!l||t<0||(i.save(),i.strokeStyle=a,i.lineWidth=l,i.setLineDash(s.dash),i.lineDashOffset=s.dashOffset,i.beginPath(),tie(n,t,o,r),i.closePath(),i.stroke(),i.restore())}function Tlt(n,e,t){return Lp(n,{label:t,index:e,type:"pointLabel"})}class $1 extends yA{constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=Jo(aF(this.options)/2),t=this.width=this.maxWidth-e.width,r=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+r/2+e.top),this.drawingArea=Math.floor(Math.min(t,r)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=Zs(e)&&!isNaN(e)?e:0,this.max=Zs(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/aF(this.options))}generateTickLabels(e){yA.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map((t,r)=>{const s=is(this.options.pointLabels.callback,[t,r],this);return s||s===0?s:""}).filter((t,r)=>this.chart.getDataVisibility(r))}fit(){const e=this.options;e.display&&e.pointLabels.display?blt(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,r,s){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((r-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,r,s))}getIndexAngle(e){const t=bs/(this._pointLabels.length||1),r=this.options.startAngle||0;return ml(e*t+hu(r))}getDistanceFromCenterForValue(e){if(Nr(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(Nr(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const r=t[e];return Tlt(this.getContext(),e,r)}}getPointPosition(e,t,r=0){const s=this.getIndexAngle(e)-Js+r;return{x:Math.cos(s)*t+this.xCenter,y:Math.sin(s)*t+this.yCenter,angle:s}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:r,right:s,bottom:i}=this._pointLabelItems[e];return{left:t,top:r,right:s,bottom:i}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const r=this.ctx;r.save(),r.beginPath(),tie(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),r.closePath(),r.fillStyle=e,r.fill(),r.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:r,grid:s,border:i}=t,o=this._pointLabels.length;let a,l,c;if(t.pointLabels.display&&Clt(this,o),s.display&&this.ticks.forEach((u,h)=>{if(h!==0){l=this.getDistanceFromCenterForValue(u.value);const f=this.getContext(h),d=s.setContext(f),p=i.setContext(f);klt(this,d,l,o,p)}}),r.display){for(e.save(),a=o-1;a>=0;a--){const u=r.setContext(this.getPointLabelContext(a)),{color:h,lineWidth:f}=u;!f||!h||(e.lineWidth=f,e.strokeStyle=h,e.setLineDash(u.borderDash),e.lineDashOffset=u.borderDashOffset,l=this.getDistanceFromCenterForValue(t.ticks.reverse?this.min:this.max),c=this.getPointPosition(a,l),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(c.x,c.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,r=t.ticks;if(!r.display)return;const s=this.getIndexAngle(0);let i,o;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(s),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&!t.reverse)return;const c=r.setContext(this.getContext(l)),u=Gi(c.font);if(i=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){e.font=u.string,o=e.measureText(a.label).width,e.fillStyle=c.backdropColor;const h=Jo(c.backdropPadding);e.fillRect(-o/2-h.left,-i-u.size/2-h.top,o+h.width,u.size+h.height)}yg(e,a.label,0,-i,u,{color:c.color})}),e.restore()}drawTitle(){}}Mt($1,"id","radialLinear"),Mt($1,"defaults",{display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:g$.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(e){return e},padding:5,centerPointLabels:!1}}),Mt($1,"defaultRoutes",{"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"}),Mt($1,"descriptors",{angleLines:{_fallback:"grid"}});const w$={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Wa=Object.keys(w$);function Elt(n,e){return n-e}function H5(n,e){if(Nr(e))return null;const t=n._adapter,{parser:r,round:s,isoWeekday:i}=n._parseOpts;let o=e;return typeof r=="function"&&(o=r(o)),Zs(o)||(o=typeof r=="string"?t.parse(o,r):t.parse(o)),o===null?null:(s&&(o=s==="week"&&(ov(i)||i===!0)?t.startOf(o,"isoWeek",i):t.startOf(o,s)),+o)}function j5(n,e,t,r){const s=Wa.length;for(let i=Wa.indexOf(n);i<s-1;++i){const o=w$[Wa[i]],a=o.steps?o.steps:Number.MAX_SAFE_INTEGER;if(o.common&&Math.ceil((t-e)/(a*o.size))<=r)return Wa[i]}return Wa[s-1]}function Ilt(n,e,t,r,s){for(let i=Wa.length-1;i>=Wa.indexOf(t);i--){const o=Wa[i];if(w$[o].common&&n._adapter.diff(s,r,o)>=e-1)return o}return Wa[t?Wa.indexOf(t):0]}function Alt(n){for(let e=Wa.indexOf(n)+1,t=Wa.length;e<t;++e)if(w$[Wa[e]].common)return Wa[e]}function q5(n,e,t){if(!t)n[e]=!0;else if(t.length){const{lo:r,hi:s}=I4(t,e),i=t[r]>=e?t[r]:t[s];n[i]=!0}}function Mlt(n,e,t,r){const s=n._adapter,i=+s.startOf(e[0].value,r),o=e[e.length-1].value;let a,l;for(a=i;a<=o;a=+s.add(a,1,r))l=t[a],l>=0&&(e[l].major=!0);return e}function X5(n,e,t){const r=[],s={},i=e.length;let o,a;for(o=0;o<i;++o)a=e[o],s[a]=o,r.push({value:a,major:!1});return i===0||!t?r:Mlt(n,r,s,t)}class nS extends Ky{constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e,t={}){const r=e.time||(e.time={}),s=this._adapter=new Dse._date(e.adapters.date);s.init(t),Q1(r.displayFormats,s.formats()),this._parseOpts={parser:r.parser,round:r.round,isoWeekday:r.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return e===void 0?null:H5(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,r=e.time.unit||"day";let{min:s,max:i,minDefined:o,maxDefined:a}=this.getUserBounds();function l(c){!o&&!isNaN(c.min)&&(s=Math.min(s,c.min)),!a&&!isNaN(c.max)&&(i=Math.max(i,c.max))}(!o||!a)&&(l(this._getLabelBounds()),(e.bounds!=="ticks"||e.ticks.source!=="labels")&&l(this.getMinMax(!1))),s=Zs(s)&&!isNaN(s)?s:+t.startOf(Date.now(),r),i=Zs(i)&&!isNaN(i)?i:+t.endOf(Date.now(),r)+1,this.min=Math.min(s,i-1),this.max=Math.max(s+1,i)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],r=e[e.length-1]),{min:t,max:r}}buildTicks(){const e=this.options,t=e.time,r=e.ticks,s=r.source==="labels"?this.getLabelTimestamps():this._generate();e.bounds==="ticks"&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const i=this.min,o=this.max,a=Mst(s,i,o);return this._unit=t.unit||(r.autoSkip?j5(t.minUnit,this.min,this.max,this._getLabelCapacity(i)):Ilt(this,a.length,t.minUnit,this.min,this.max)),this._majorUnit=!r.major.enabled||this._unit==="year"?void 0:Alt(this._unit),this.initOffsets(s),e.reverse&&a.reverse(),X5(this,a,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map(e=>+e.value))}initOffsets(e=[]){let t=0,r=0,s,i;this.options.offset&&e.length&&(s=this.getDecimalForValue(e[0]),e.length===1?t=1-s:t=(this.getDecimalForValue(e[1])-s)/2,i=this.getDecimalForValue(e[e.length-1]),e.length===1?r=i:r=(i-this.getDecimalForValue(e[e.length-2]))/2);const o=e.length<3?.5:.25;t=Xo(t,0,o),r=Xo(r,0,o),this._offsets={start:t,end:r,factor:1/(t+1+r)}}_generate(){const e=this._adapter,t=this.min,r=this.max,s=this.options,i=s.time,o=i.unit||j5(i.minUnit,t,r,this._getLabelCapacity(t)),a=Un(s.ticks.stepSize,1),l=o==="week"?i.isoWeekday:!1,c=ov(l)||l===!0,u={};let h=t,f,d;if(c&&(h=+e.startOf(h,"isoWeek",l)),h=+e.startOf(h,c?"day":o),e.diff(r,t,o)>1e5*a)throw new Error(t+" and "+r+" are too far apart with stepSize of "+a+" "+o);const p=s.ticks.source==="data"&&this.getDataTimestamps();for(f=h,d=0;f<r;f=+e.add(f,a,o),d++)q5(u,f,p);return(f===r||s.bounds==="ticks"||d===1)&&q5(u,f,p),Object.keys(u).sort((m,g)=>m-g).map(m=>+m)}getLabelForValue(e){const t=this._adapter,r=this.options.time;return r.tooltipFormat?t.format(e,r.tooltipFormat):t.format(e,r.displayFormats.datetime)}format(e,t){const s=this.options.time.displayFormats,i=this._unit,o=t||s[i];return this._adapter.format(e,o)}_tickFormatFunction(e,t,r,s){const i=this.options,o=i.ticks.callback;if(o)return is(o,[e,t,r],this);const a=i.time.displayFormats,l=this._unit,c=this._majorUnit,u=l&&a[l],h=c&&a[c],f=r[t],d=c&&h&&f&&f.major;return this._adapter.format(e,s||(d?h:u))}generateTickLabels(e){let t,r,s;for(t=0,r=e.length;t<r;++t)s=e[t],s.label=this._tickFormatFunction(s.value,t,e)}getDecimalForValue(e){return e===null?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,r=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+r)*t.factor)}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+r*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,r=this.ctx.measureText(e).width,s=hu(this.isHorizontal()?t.maxRotation:t.minRotation),i=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:r*i+a*o,h:r*o+a*i}}_getLabelCapacity(e){const t=this.options.time,r=t.displayFormats,s=r[t.unit]||r.millisecond,i=this._tickFormatFunction(e,0,X5(this,[e],this._majorUnit),s),o=this._getLabelSize(i),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let e=this._cache.data||[],t,r;if(e.length)return e;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,r=s.length;t<r;++t)e=e.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(e)}getLabelTimestamps(){const e=this._cache.labels||[];let t,r;if(e.length)return e;const s=this.getLabels();for(t=0,r=s.length;t<r;++t)e.push(H5(this,s[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return hse(e.sort(Elt))}}Mt(nS,"id","time"),Mt(nS,"defaults",{bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}});function _T(n,e,t){let r=0,s=n.length-1,i,o,a,l;t?(e>=n[r].pos&&e<=n[s].pos&&({lo:r,hi:s}=Bm(n,"pos",e)),{pos:i,time:a}=n[r],{pos:o,time:l}=n[s]):(e>=n[r].time&&e<=n[s].time&&({lo:r,hi:s}=Bm(n,"time",e)),{time:i,pos:a}=n[r],{time:o,pos:l}=n[s]);const c=o-i;return c?a+(l-a)*(e-i)/c:a}class lF extends nS{constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=_T(t,this.min),this._tableRange=_T(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:r}=this,s=[],i=[];let o,a,l,c,u;for(o=0,a=e.length;o<a;++o)c=e[o],c>=t&&c<=r&&s.push(c);if(s.length<2)return[{time:t,pos:0},{time:r,pos:1}];for(o=0,a=s.length;o<a;++o)u=s[o+1],l=s[o-1],c=s[o],Math.round((u+l)/2)!==c&&i.push({time:c,pos:o/(a-1)});return i}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),r=this.getLabelTimestamps();return t.length&&r.length?e=this.normalize(t.concat(r)):e=t.length?t:r,e=this._cache.all=e,e}getDecimalForValue(e){return(_T(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,r=this.getDecimalForPixel(e)/t.factor-t.end;return _T(this._table,r*this._tableRange+this._minPos,!0)}}Mt(lF,"id","timeseries"),Mt(lF,"defaults",nS.defaults);class Yy extends Error{}class Nlt extends Yy{constructor(e){super(`Invalid DateTime: ${e.toMessage()}`)}}class $lt extends Yy{constructor(e){super(`Invalid Interval: ${e.toMessage()}`)}}class Rlt extends Yy{constructor(e){super(`Invalid Duration: ${e.toMessage()}`)}}class R1 extends Yy{}class nie extends Yy{constructor(e){super(`Invalid unit ${e}`)}}class ac extends Yy{}class ud extends Yy{constructor(){super("Zone is an abstract class")}}const zt="numeric",ku="short",Tl="long",bA={year:zt,month:zt,day:zt},rie={year:zt,month:ku,day:zt},Plt={year:zt,month:ku,day:zt,weekday:ku},sie={year:zt,month:Tl,day:zt},iie={year:zt,month:Tl,day:zt,weekday:Tl},oie={hour:zt,minute:zt},aie={hour:zt,minute:zt,second:zt},lie={hour:zt,minute:zt,second:zt,timeZoneName:ku},cie={hour:zt,minute:zt,second:zt,timeZoneName:Tl},uie={hour:zt,minute:zt,hourCycle:"h23"},hie={hour:zt,minute:zt,second:zt,hourCycle:"h23"},fie={hour:zt,minute:zt,second:zt,hourCycle:"h23",timeZoneName:ku},die={hour:zt,minute:zt,second:zt,hourCycle:"h23",timeZoneName:Tl},pie={year:zt,month:zt,day:zt,hour:zt,minute:zt},mie={year:zt,month:zt,day:zt,hour:zt,minute:zt,second:zt},gie={year:zt,month:ku,day:zt,hour:zt,minute:zt},yie={year:zt,month:ku,day:zt,hour:zt,minute:zt,second:zt},Dlt={year:zt,month:ku,day:zt,weekday:ku,hour:zt,minute:zt},bie={year:zt,month:Tl,day:zt,hour:zt,minute:zt,timeZoneName:ku},vie={year:zt,month:Tl,day:zt,hour:zt,minute:zt,second:zt,timeZoneName:ku},wie={year:zt,month:Tl,day:zt,weekday:Tl,hour:zt,minute:zt,timeZoneName:Tl},xie={year:zt,month:Tl,day:zt,weekday:Tl,hour:zt,minute:zt,second:zt,timeZoneName:Tl};class RC{get type(){throw new ud}get name(){throw new ud}get ianaName(){return this.name}get isUniversal(){throw new ud}offsetName(e,t){throw new ud}formatOffset(e,t){throw new ud}offset(e){throw new ud}equals(e){throw new ud}get isValid(){throw new ud}}let U3=null;class x$ extends RC{static get instance(){return U3===null&&(U3=new x$),U3}get type(){return"system"}get name(){return new Intl.DateTimeFormat().resolvedOptions().timeZone}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return Sie(e,t,r)}formatOffset(e,t){return s_(this.offset(e),t)}offset(e){return-new Date(e).getTimezoneOffset()}equals(e){return e.type==="system"}get isValid(){return!0}}let JE={};function Olt(n){return JE[n]||(JE[n]=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:n,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",era:"short"})),JE[n]}const Flt={year:0,month:1,day:2,era:3,hour:4,minute:5,second:6};function Llt(n,e){const t=n.format(e).replace(/\u200E/g,""),r=/(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t),[,s,i,o,a,l,c,u]=r;return[o,s,i,a,l,c,u]}function zlt(n,e){const t=n.formatToParts(e),r=[];for(let s=0;s<t.length;s++){const{type:i,value:o}=t[s],a=Flt[i];i==="era"?r[a]=o:fr(a)||(r[a]=parseInt(o,10))}return r}let ST={};class Rf extends RC{static create(e){return ST[e]||(ST[e]=new Rf(e)),ST[e]}static resetCache(){ST={},JE={}}static isValidSpecifier(e){return this.isValidZone(e)}static isValidZone(e){if(!e)return!1;try{return new Intl.DateTimeFormat("en-US",{timeZone:e}).format(),!0}catch{return!1}}constructor(e){super(),this.zoneName=e,this.valid=Rf.isValidZone(e)}get type(){return"iana"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(e,{format:t,locale:r}){return Sie(e,t,r,this.name)}formatOffset(e,t){return s_(this.offset(e),t)}offset(e){const t=new Date(e);if(isNaN(t))return NaN;const r=Olt(this.name);let[s,i,o,a,l,c,u]=r.formatToParts?zlt(r,t):Llt(r,t);a==="BC"&&(s=-Math.abs(s)+1);const f=S$({year:s,month:i,day:o,hour:l===24?0:l,minute:c,second:u,millisecond:0});let d=+t;const p=d%1e3;return d-=p>=0?p:1e3+p,(f-d)/(60*1e3)}equals(e){return e.type==="iana"&&e.name===this.name}get isValid(){return this.valid}}let K5={};function Blt(n,e={}){const t=JSON.stringify([n,e]);let r=K5[t];return r||(r=new Intl.ListFormat(n,e),K5[t]=r),r}let cF={};function uF(n,e={}){const t=JSON.stringify([n,e]);let r=cF[t];return r||(r=new Intl.DateTimeFormat(n,e),cF[t]=r),r}let hF={};function Vlt(n,e={}){const t=JSON.stringify([n,e]);let r=hF[t];return r||(r=new Intl.NumberFormat(n,e),hF[t]=r),r}let fF={};function Ult(n,e={}){const{base:t,...r}=e,s=JSON.stringify([n,r]);let i=fF[s];return i||(i=new Intl.RelativeTimeFormat(n,e),fF[s]=i),i}let P1=null;function Wlt(){return P1||(P1=new Intl.DateTimeFormat().resolvedOptions().locale,P1)}function Glt(n){const e=n.indexOf("-x-");e!==-1&&(n=n.substring(0,e));const t=n.indexOf("-u-");if(t===-1)return[n];{let r,s;try{r=uF(n).resolvedOptions(),s=n}catch{const l=n.substring(0,t);r=uF(l).resolvedOptions(),s=l}const{numberingSystem:i,calendar:o}=r;return[s,i,o]}}function Hlt(n,e,t){return(t||e)&&(n.includes("-u-")||(n+="-u"),t&&(n+=`-ca-${t}`),e&&(n+=`-nu-${e}`)),n}function jlt(n){const e=[];for(let t=1;t<=12;t++){const r=bn.utc(2009,t,1);e.push(n(r))}return e}function qlt(n){const e=[];for(let t=1;t<=7;t++){const r=bn.utc(2016,11,13+t);e.push(n(r))}return e}function CT(n,e,t,r){const s=n.listingMode();return s==="error"?null:s==="en"?t(e):r(e)}function Xlt(n){return n.numberingSystem&&n.numberingSystem!=="latn"?!1:n.numberingSystem==="latn"||!n.locale||n.locale.startsWith("en")||new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem==="latn"}class Klt{constructor(e,t,r){this.padTo=r.padTo||0,this.floor=r.floor||!1;const{padTo:s,floor:i,...o}=r;if(!t||Object.keys(o).length>0){const a={useGrouping:!1,...r};r.padTo>0&&(a.minimumIntegerDigits=r.padTo),this.inf=Vlt(e,a)}}format(e){if(this.inf){const t=this.floor?Math.floor(e):e;return this.inf.format(t)}else{const t=this.floor?Math.floor(e):L4(e,3);return vi(t,this.padTo)}}}class Ylt{constructor(e,t,r){this.opts=r,this.originalZone=void 0;let s;if(this.opts.timeZone)this.dt=e;else if(e.zone.type==="fixed"){const o=-1*(e.offset/60),a=o>=0?`Etc/GMT+${o}`:`Etc/GMT${o}`;e.offset!==0&&Rf.create(a).valid?(s=a,this.dt=e):(s="UTC",this.dt=e.offset===0?e:e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone)}else e.zone.type==="system"?this.dt=e:e.zone.type==="iana"?(this.dt=e,s=e.zone.name):(s="UTC",this.dt=e.setZone("UTC").plus({minutes:e.offset}),this.originalZone=e.zone);const i={...this.opts};i.timeZone=i.timeZone||s,this.dtf=uF(t,i)}format(){return this.originalZone?this.formatToParts().map(({value:e})=>e).join(""):this.dtf.format(this.dt.toJSDate())}formatToParts(){const e=this.dtf.formatToParts(this.dt.toJSDate());return this.originalZone?e.map(t=>{if(t.type==="timeZoneName"){const r=this.originalZone.offsetName(this.dt.ts,{locale:this.dt.locale,format:this.opts.timeZoneName});return{...t,value:r}}else return t}):e}resolvedOptions(){return this.dtf.resolvedOptions()}}class Zlt{constructor(e,t,r){this.opts={style:"long",...r},!t&&_ie()&&(this.rtf=Ult(e,r))}format(e,t){return this.rtf?this.rtf.format(e,t):pct(t,e,this.opts.numeric,this.opts.style!=="long")}formatToParts(e,t){return this.rtf?this.rtf.formatToParts(e,t):[]}}class ds{static fromOpts(e){return ds.create(e.locale,e.numberingSystem,e.outputCalendar,e.defaultToEN)}static create(e,t,r,s=!1){const i=e||yi.defaultLocale,o=i||(s?"en-US":Wlt()),a=t||yi.defaultNumberingSystem,l=r||yi.defaultOutputCalendar;return new ds(o,a,l,i)}static resetCache(){P1=null,cF={},hF={},fF={}}static fromObject({locale:e,numberingSystem:t,outputCalendar:r}={}){return ds.create(e,t,r)}constructor(e,t,r,s){const[i,o,a]=Glt(e);this.locale=i,this.numberingSystem=t||o||null,this.outputCalendar=r||a||null,this.intl=Hlt(this.locale,this.numberingSystem,this.outputCalendar),this.weekdaysCache={format:{},standalone:{}},this.monthsCache={format:{},standalone:{}},this.meridiemCache=null,this.eraCache={},this.specifiedLocale=s,this.fastNumbersCached=null}get fastNumbers(){return this.fastNumbersCached==null&&(this.fastNumbersCached=Xlt(this)),this.fastNumbersCached}listingMode(){const e=this.isEnglish(),t=(this.numberingSystem===null||this.numberingSystem==="latn")&&(this.outputCalendar===null||this.outputCalendar==="gregory");return e&&t?"en":"intl"}clone(e){return!e||Object.getOwnPropertyNames(e).length===0?this:ds.create(e.locale||this.specifiedLocale,e.numberingSystem||this.numberingSystem,e.outputCalendar||this.outputCalendar,e.defaultToEN||!1)}redefaultToEN(e={}){return this.clone({...e,defaultToEN:!0})}redefaultToSystem(e={}){return this.clone({...e,defaultToEN:!1})}months(e,t=!1){return CT(this,e,Tie,()=>{const r=t?{month:e,day:"numeric"}:{month:e},s=t?"format":"standalone";return this.monthsCache[s][e]||(this.monthsCache[s][e]=jlt(i=>this.extract(i,r,"month"))),this.monthsCache[s][e]})}weekdays(e,t=!1){return CT(this,e,Aie,()=>{const r=t?{weekday:e,year:"numeric",month:"long",day:"numeric"}:{weekday:e},s=t?"format":"standalone";return this.weekdaysCache[s][e]||(this.weekdaysCache[s][e]=qlt(i=>this.extract(i,r,"weekday"))),this.weekdaysCache[s][e]})}meridiems(){return CT(this,void 0,()=>Mie,()=>{if(!this.meridiemCache){const e={hour:"numeric",hourCycle:"h12"};this.meridiemCache=[bn.utc(2016,11,13,9),bn.utc(2016,11,13,19)].map(t=>this.extract(t,e,"dayperiod"))}return this.meridiemCache})}eras(e){return CT(this,e,Nie,()=>{const t={era:e};return this.eraCache[e]||(this.eraCache[e]=[bn.utc(-40,1,1),bn.utc(2017,1,1)].map(r=>this.extract(r,t,"era"))),this.eraCache[e]})}extract(e,t,r){const s=this.dtFormatter(e,t),i=s.formatToParts(),o=i.find(a=>a.type.toLowerCase()===r);return o?o.value:null}numberFormatter(e={}){return new Klt(this.intl,e.forceSimple||this.fastNumbers,e)}dtFormatter(e,t={}){return new Ylt(e,this.intl,t)}relFormatter(e={}){return new Zlt(this.intl,this.isEnglish(),e)}listFormatter(e={}){return Blt(this.intl,e)}isEnglish(){return this.locale==="en"||this.locale.toLowerCase()==="en-us"||new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")}equals(e){return this.locale===e.locale&&this.numberingSystem===e.numberingSystem&&this.outputCalendar===e.outputCalendar}}let W3=null;class ma extends RC{static get utcInstance(){return W3===null&&(W3=new ma(0)),W3}static instance(e){return e===0?ma.utcInstance:new ma(e)}static parseSpecifier(e){if(e){const t=e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);if(t)return new ma(C$(t[1],t[2]))}return null}constructor(e){super(),this.fixed=e}get type(){return"fixed"}get name(){return this.fixed===0?"UTC":`UTC${s_(this.fixed,"narrow")}`}get ianaName(){return this.fixed===0?"Etc/UTC":`Etc/GMT${s_(-this.fixed,"narrow")}`}offsetName(){return this.name}formatOffset(e,t){return s_(this.fixed,t)}get isUniversal(){return!0}offset(){return this.fixed}equals(e){return e.type==="fixed"&&e.fixed===this.fixed}get isValid(){return!0}}class Jlt extends RC{constructor(e){super(),this.zoneName=e}get type(){return"invalid"}get name(){return this.zoneName}get isUniversal(){return!1}offsetName(){return null}formatOffset(){return""}offset(){return NaN}equals(){return!1}get isValid(){return!1}}function Id(n,e){if(fr(n)||n===null)return e;if(n instanceof RC)return n;if(Qlt(n)){const t=n.toLowerCase();return t==="default"?e:t==="local"||t==="system"?x$.instance:t==="utc"||t==="gmt"?ma.utcInstance:ma.parseSpecifier(t)||Rf.create(n)}else return Ym(n)?ma.instance(n):typeof n=="object"&&"offset"in n&&typeof n.offset=="function"?n:new Jlt(n)}let Y5=()=>Date.now(),Z5="system",J5=null,Q5=null,ej=null,tj=60,nj;class yi{static get now(){return Y5}static set now(e){Y5=e}static set defaultZone(e){Z5=e}static get defaultZone(){return Id(Z5,x$.instance)}static get defaultLocale(){return J5}static set defaultLocale(e){J5=e}static get defaultNumberingSystem(){return Q5}static set defaultNumberingSystem(e){Q5=e}static get defaultOutputCalendar(){return ej}static set defaultOutputCalendar(e){ej=e}static get twoDigitCutoffYear(){return tj}static set twoDigitCutoffYear(e){tj=e%100}static get throwOnInvalid(){return nj}static set throwOnInvalid(e){nj=e}static resetCaches(){ds.resetCache(),Rf.resetCache()}}function fr(n){return typeof n>"u"}function Ym(n){return typeof n=="number"}function _$(n){return typeof n=="number"&&n%1===0}function Qlt(n){return typeof n=="string"}function ect(n){return Object.prototype.toString.call(n)==="[object Date]"}function _ie(){try{return typeof Intl<"u"&&!!Intl.RelativeTimeFormat}catch{return!1}}function tct(n){return Array.isArray(n)?n:[n]}function rj(n,e,t){if(n.length!==0)return n.reduce((r,s)=>{const i=[e(s),s];return r&&t(r[0],i[0])===r[0]?r:i},null)[1]}function nct(n,e){return e.reduce((t,r)=>(t[r]=n[r],t),{})}function cv(n,e){return Object.prototype.hasOwnProperty.call(n,e)}function kf(n,e,t){return _$(n)&&n>=e&&n<=t}function rct(n,e){return n-e*Math.floor(n/e)}function vi(n,e=2){const t=n<0;let r;return t?r="-"+(""+-n).padStart(e,"0"):r=(""+n).padStart(e,"0"),r}function Td(n){if(!(fr(n)||n===null||n===""))return parseInt(n,10)}function cm(n){if(!(fr(n)||n===null||n===""))return parseFloat(n)}function F4(n){if(!(fr(n)||n===null||n==="")){const e=parseFloat("0."+n)*1e3;return Math.floor(e)}}function L4(n,e,t=!1){const r=10**e;return(t?Math.trunc:Math.round)(n*r)/r}function PC(n){return n%4===0&&(n%100!==0||n%400===0)}function r_(n){return PC(n)?366:365}function vA(n,e){const t=rct(e-1,12)+1,r=n+(e-t)/12;return t===2?PC(r)?29:28:[31,null,31,30,31,30,31,31,30,31,30,31][t-1]}function S$(n){let e=Date.UTC(n.year,n.month-1,n.day,n.hour,n.minute,n.second,n.millisecond);return n.year<100&&n.year>=0&&(e=new Date(e),e.setUTCFullYear(n.year,n.month-1,n.day)),+e}function wA(n){const e=(n+Math.floor(n/4)-Math.floor(n/100)+Math.floor(n/400))%7,t=n-1,r=(t+Math.floor(t/4)-Math.floor(t/100)+Math.floor(t/400))%7;return e===4||r===3?53:52}function dF(n){return n>99?n:n>yi.twoDigitCutoffYear?1900+n:2e3+n}function Sie(n,e,t,r=null){const s=new Date(n),i={hourCycle:"h23",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit"};r&&(i.timeZone=r);const o={timeZoneName:e,...i},a=new Intl.DateTimeFormat(t,o).formatToParts(s).find(l=>l.type.toLowerCase()==="timezonename");return a?a.value:null}function C$(n,e){let t=parseInt(n,10);Number.isNaN(t)&&(t=0);const r=parseInt(e,10)||0,s=t<0||Object.is(t,-0)?-r:r;return t*60+s}function Cie(n){const e=Number(n);if(typeof n=="boolean"||n===""||Number.isNaN(e))throw new ac(`Invalid unit value ${n}`);return e}function xA(n,e){const t={};for(const r in n)if(cv(n,r)){const s=n[r];if(s==null)continue;t[e(r)]=Cie(s)}return t}function s_(n,e){const t=Math.trunc(Math.abs(n/60)),r=Math.trunc(Math.abs(n%60)),s=n>=0?"+":"-";switch(e){case"short":return`${s}${vi(t,2)}:${vi(r,2)}`;case"narrow":return`${s}${t}${r>0?`:${r}`:""}`;case"techie":return`${s}${vi(t,2)}${vi(r,2)}`;default:throw new RangeError(`Value format ${e} is out of range for property format`)}}function k$(n){return nct(n,["hour","minute","second","millisecond"])}const sct=["January","February","March","April","May","June","July","August","September","October","November","December"],kie=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],ict=["J","F","M","A","M","J","J","A","S","O","N","D"];function Tie(n){switch(n){case"narrow":return[...ict];case"short":return[...kie];case"long":return[...sct];case"numeric":return["1","2","3","4","5","6","7","8","9","10","11","12"];case"2-digit":return["01","02","03","04","05","06","07","08","09","10","11","12"];default:return null}}const Eie=["Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],Iie=["Mon","Tue","Wed","Thu","Fri","Sat","Sun"],oct=["M","T","W","T","F","S","S"];function Aie(n){switch(n){case"narrow":return[...oct];case"short":return[...Iie];case"long":return[...Eie];case"numeric":return["1","2","3","4","5","6","7"];default:return null}}const Mie=["AM","PM"],act=["Before Christ","Anno Domini"],lct=["BC","AD"],cct=["B","A"];function Nie(n){switch(n){case"narrow":return[...cct];case"short":return[...lct];case"long":return[...act];default:return null}}function uct(n){return Mie[n.hour<12?0:1]}function hct(n,e){return Aie(e)[n.weekday-1]}function fct(n,e){return Tie(e)[n.month-1]}function dct(n,e){return Nie(e)[n.year<0?0:1]}function pct(n,e,t="always",r=!1){const s={years:["year","yr."],quarters:["quarter","qtr."],months:["month","mo."],weeks:["week","wk."],days:["day","day","days"],hours:["hour","hr."],minutes:["minute","min."],seconds:["second","sec."]},i=["hours","minutes","seconds"].indexOf(n)===-1;if(t==="auto"&&i){const h=n==="days";switch(e){case 1:return h?"tomorrow":`next ${s[n][0]}`;case-1:return h?"yesterday":`last ${s[n][0]}`;case 0:return h?"today":`this ${s[n][0]}`}}const o=Object.is(e,-0)||e<0,a=Math.abs(e),l=a===1,c=s[n],u=r?l?c[1]:c[2]||c[1]:l?s[n][0]:n;return o?`${a} ${u} ago`:`in ${a} ${u}`}function sj(n,e){let t="";for(const r of n)r.literal?t+=r.val:t+=e(r.val);return t}const mct={D:bA,DD:rie,DDD:sie,DDDD:iie,t:oie,tt:aie,ttt:lie,tttt:cie,T:uie,TT:hie,TTT:fie,TTTT:die,f:pie,ff:gie,fff:bie,ffff:wie,F:mie,FF:yie,FFF:vie,FFFF:xie};class Ho{static create(e,t={}){return new Ho(e,t)}static parseFormat(e){let t=null,r="",s=!1;const i=[];for(let o=0;o<e.length;o++){const a=e.charAt(o);a==="'"?(r.length>0&&i.push({literal:s||/^\s+$/.test(r),val:r}),t=null,r="",s=!s):s||a===t?r+=a:(r.length>0&&i.push({literal:/^\s+$/.test(r),val:r}),r=a,t=a)}return r.length>0&&i.push({literal:s||/^\s+$/.test(r),val:r}),i}static macroTokenToFormatOpts(e){return mct[e]}constructor(e,t){this.opts=t,this.loc=e,this.systemLoc=null}formatWithSystemDefault(e,t){return this.systemLoc===null&&(this.systemLoc=this.loc.redefaultToSystem()),this.systemLoc.dtFormatter(e,{...this.opts,...t}).format()}dtFormatter(e,t={}){return this.loc.dtFormatter(e,{...this.opts,...t})}formatDateTime(e,t){return this.dtFormatter(e,t).format()}formatDateTimeParts(e,t){return this.dtFormatter(e,t).formatToParts()}formatInterval(e,t){return this.dtFormatter(e.start,t).dtf.formatRange(e.start.toJSDate(),e.end.toJSDate())}resolvedOptions(e,t){return this.dtFormatter(e,t).resolvedOptions()}num(e,t=0){if(this.opts.forceSimple)return vi(e,t);const r={...this.opts};return t>0&&(r.padTo=t),this.loc.numberFormatter(r).format(e)}formatDateTimeFromString(e,t){const r=this.loc.listingMode()==="en",s=this.loc.outputCalendar&&this.loc.outputCalendar!=="gregory",i=(d,p)=>this.loc.extract(e,d,p),o=d=>e.isOffsetFixed&&e.offset===0&&d.allowZ?"Z":e.isValid?e.zone.formatOffset(e.ts,d.format):"",a=()=>r?uct(e):i({hour:"numeric",hourCycle:"h12"},"dayperiod"),l=(d,p)=>r?fct(e,d):i(p?{month:d}:{month:d,day:"numeric"},"month"),c=(d,p)=>r?hct(e,d):i(p?{weekday:d}:{weekday:d,month:"long",day:"numeric"},"weekday"),u=d=>{const p=Ho.macroTokenToFormatOpts(d);return p?this.formatWithSystemDefault(e,p):d},h=d=>r?dct(e,d):i({era:d},"era"),f=d=>{switch(d){case"S":return this.num(e.millisecond);case"u":case"SSS":return this.num(e.millisecond,3);case"s":return this.num(e.second);case"ss":return this.num(e.second,2);case"uu":return this.num(Math.floor(e.millisecond/10),2);case"uuu":return this.num(Math.floor(e.millisecond/100));case"m":return this.num(e.minute);case"mm":return this.num(e.minute,2);case"h":return this.num(e.hour%12===0?12:e.hour%12);case"hh":return this.num(e.hour%12===0?12:e.hour%12,2);case"H":return this.num(e.hour);case"HH":return this.num(e.hour,2);case"Z":return o({format:"narrow",allowZ:this.opts.allowZ});case"ZZ":return o({format:"short",allowZ:this.opts.allowZ});case"ZZZ":return o({format:"techie",allowZ:this.opts.allowZ});case"ZZZZ":return e.zone.offsetName(e.ts,{format:"short",locale:this.loc.locale});case"ZZZZZ":return e.zone.offsetName(e.ts,{format:"long",locale:this.loc.locale});case"z":return e.zoneName;case"a":return a();case"d":return s?i({day:"numeric"},"day"):this.num(e.day);case"dd":return s?i({day:"2-digit"},"day"):this.num(e.day,2);case"c":return this.num(e.weekday);case"ccc":return c("short",!0);case"cccc":return c("long",!0);case"ccccc":return c("narrow",!0);case"E":return this.num(e.weekday);case"EEE":return c("short",!1);case"EEEE":return c("long",!1);case"EEEEE":return c("narrow",!1);case"L":return s?i({month:"numeric",day:"numeric"},"month"):this.num(e.month);case"LL":return s?i({month:"2-digit",day:"numeric"},"month"):this.num(e.month,2);case"LLL":return l("short",!0);case"LLLL":return l("long",!0);case"LLLLL":return l("narrow",!0);case"M":return s?i({month:"numeric"},"month"):this.num(e.month);case"MM":return s?i({month:"2-digit"},"month"):this.num(e.month,2);case"MMM":return l("short",!1);case"MMMM":return l("long",!1);case"MMMMM":return l("narrow",!1);case"y":return s?i({year:"numeric"},"year"):this.num(e.year);case"yy":return s?i({year:"2-digit"},"year"):this.num(e.year.toString().slice(-2),2);case"yyyy":return s?i({year:"numeric"},"year"):this.num(e.year,4);case"yyyyyy":return s?i({year:"numeric"},"year"):this.num(e.year,6);case"G":return h("short");case"GG":return h("long");case"GGGGG":return h("narrow");case"kk":return this.num(e.weekYear.toString().slice(-2),2);case"kkkk":return this.num(e.weekYear,4);case"W":return this.num(e.weekNumber);case"WW":return this.num(e.weekNumber,2);case"o":return this.num(e.ordinal);case"ooo":return this.num(e.ordinal,3);case"q":return this.num(e.quarter);case"qq":return this.num(e.quarter,2);case"X":return this.num(Math.floor(e.ts/1e3));case"x":return this.num(e.ts);default:return u(d)}};return sj(Ho.parseFormat(t),f)}formatDurationFromString(e,t){const r=l=>{switch(l[0]){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":return"hour";case"d":return"day";case"w":return"week";case"M":return"month";case"y":return"year";default:return null}},s=l=>c=>{const u=r(c);return u?this.num(l.get(u),c.length):c},i=Ho.parseFormat(t),o=i.reduce((l,{literal:c,val:u})=>c?l:l.concat(u),[]),a=e.shiftTo(...o.map(r).filter(l=>l));return sj(i,s(a))}}class fu{constructor(e,t){this.reason=e,this.explanation=t}toMessage(){return this.explanation?`${this.reason}: ${this.explanation}`:this.reason}}const $ie=/[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;function Jw(...n){const e=n.reduce((t,r)=>t+r.source,"");return RegExp(`^${e}$`)}function Qw(...n){return e=>n.reduce(([t,r,s],i)=>{const[o,a,l]=i(e,s);return[{...t,...o},a||r,l]},[{},null,1]).slice(0,2)}function ex(n,...e){if(n==null)return[null,null];for(const[t,r]of e){const s=t.exec(n);if(s)return r(s)}return[null,null]}function Rie(...n){return(e,t)=>{const r={};let s;for(s=0;s<n.length;s++)r[n[s]]=Td(e[t+s]);return[r,null,t+s]}}const Pie=/(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,gct=`(?:${Pie.source}?(?:\\[(${$ie.source})\\])?)?`,z4=/(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,Die=RegExp(`${z4.source}${gct}`),B4=RegExp(`(?:T${Die.source})?`),yct=/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,bct=/(\d{4})-?W(\d\d)(?:-?(\d))?/,vct=/(\d{4})-?(\d{3})/,wct=Rie("weekYear","weekNumber","weekDay"),xct=Rie("year","ordinal"),_ct=/(\d{4})-(\d\d)-(\d\d)/,Oie=RegExp(`${z4.source} ?(?:${Pie.source}|(${$ie.source}))?`),Sct=RegExp(`(?: ${Oie.source})?`);function Rb(n,e,t){const r=n[e];return fr(r)?t:Td(r)}function Cct(n,e){return[{year:Rb(n,e),month:Rb(n,e+1,1),day:Rb(n,e+2,1)},null,e+3]}function tx(n,e){return[{hours:Rb(n,e,0),minutes:Rb(n,e+1,0),seconds:Rb(n,e+2,0),milliseconds:F4(n[e+3])},null,e+4]}function DC(n,e){const t=!n[e]&&!n[e+1],r=C$(n[e+1],n[e+2]),s=t?null:ma.instance(r);return[{},s,e+3]}function OC(n,e){const t=n[e]?Rf.create(n[e]):null;return[{},t,e+1]}const kct=RegExp(`^T?${z4.source}$`),Tct=/^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;function Ect(n){const[e,t,r,s,i,o,a,l,c]=n,u=e[0]==="-",h=l&&l[0]==="-",f=(d,p=!1)=>d!==void 0&&(p||d&&u)?-d:d;return[{years:f(cm(t)),months:f(cm(r)),weeks:f(cm(s)),days:f(cm(i)),hours:f(cm(o)),minutes:f(cm(a)),seconds:f(cm(l),l==="-0"),milliseconds:f(F4(c),h)}]}const Ict={GMT:0,EDT:-4*60,EST:-5*60,CDT:-5*60,CST:-6*60,MDT:-6*60,MST:-7*60,PDT:-7*60,PST:-8*60};function V4(n,e,t,r,s,i,o){const a={year:e.length===2?dF(Td(e)):Td(e),month:kie.indexOf(t)+1,day:Td(r),hour:Td(s),minute:Td(i)};return o&&(a.second=Td(o)),n&&(a.weekday=n.length>3?Eie.indexOf(n)+1:Iie.indexOf(n)+1),a}const Act=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;function Mct(n){const[,e,t,r,s,i,o,a,l,c,u,h]=n,f=V4(e,s,r,t,i,o,a);let d;return l?d=Ict[l]:c?d=0:d=C$(u,h),[f,new ma(d)]}function Nct(n){return n.replace(/\([^()]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}const $ct=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,Rct=/^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,Pct=/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;function ij(n){const[,e,t,r,s,i,o,a]=n;return[V4(e,s,r,t,i,o,a),ma.utcInstance]}function Dct(n){const[,e,t,r,s,i,o,a]=n;return[V4(e,a,t,r,s,i,o),ma.utcInstance]}const Oct=Jw(yct,B4),Fct=Jw(bct,B4),Lct=Jw(vct,B4),zct=Jw(Die),Fie=Qw(Cct,tx,DC,OC),Bct=Qw(wct,tx,DC,OC),Vct=Qw(xct,tx,DC,OC),Uct=Qw(tx,DC,OC);function Wct(n){return ex(n,[Oct,Fie],[Fct,Bct],[Lct,Vct],[zct,Uct])}function Gct(n){return ex(Nct(n),[Act,Mct])}function Hct(n){return ex(n,[$ct,ij],[Rct,ij],[Pct,Dct])}function jct(n){return ex(n,[Tct,Ect])}const qct=Qw(tx);function Xct(n){return ex(n,[kct,qct])}const Kct=Jw(_ct,Sct),Yct=Jw(Oie),Zct=Qw(tx,DC,OC);function Jct(n){return ex(n,[Kct,Fie],[Yct,Zct])}const oj="Invalid Duration",Lie={weeks:{days:7,hours:7*24,minutes:7*24*60,seconds:7*24*60*60,milliseconds:7*24*60*60*1e3},days:{hours:24,minutes:24*60,seconds:24*60*60,milliseconds:24*60*60*1e3},hours:{minutes:60,seconds:60*60,milliseconds:60*60*1e3},minutes:{seconds:60,milliseconds:60*1e3},seconds:{milliseconds:1e3}},Qct={years:{quarters:4,months:12,weeks:52,days:365,hours:365*24,minutes:365*24*60,seconds:365*24*60*60,milliseconds:365*24*60*60*1e3},quarters:{months:3,weeks:13,days:91,hours:91*24,minutes:91*24*60,seconds:91*24*60*60,milliseconds:91*24*60*60*1e3},months:{weeks:4,days:30,hours:30*24,minutes:30*24*60,seconds:30*24*60*60,milliseconds:30*24*60*60*1e3},...Lie},Ql=146097/400,L0=146097/4800,eut={years:{quarters:4,months:12,weeks:Ql/7,days:Ql,hours:Ql*24,minutes:Ql*24*60,seconds:Ql*24*60*60,milliseconds:Ql*24*60*60*1e3},quarters:{months:3,weeks:Ql/28,days:Ql/4,hours:Ql*24/4,minutes:Ql*24*60/4,seconds:Ql*24*60*60/4,milliseconds:Ql*24*60*60*1e3/4},months:{weeks:L0/7,days:L0,hours:L0*24,minutes:L0*24*60,seconds:L0*24*60*60,milliseconds:L0*24*60*60*1e3},...Lie},Vm=["years","quarters","months","weeks","days","hours","minutes","seconds","milliseconds"],tut=Vm.slice(0).reverse();function hd(n,e,t=!1){const r={values:t?e.values:{...n.values,...e.values||{}},loc:n.loc.clone(e.loc),conversionAccuracy:e.conversionAccuracy||n.conversionAccuracy,matrix:e.matrix||n.matrix};return new Sr(r)}function zie(n,e){let t=e.milliseconds??0;for(const r of tut.slice(1))e[r]&&(t+=e[r]*n[r].milliseconds);return t}function aj(n,e){const t=zie(n,e)<0?-1:1;Vm.reduceRight((r,s)=>{if(fr(e[s]))return r;if(r){const i=e[r]*t,o=n[s][r],a=Math.floor(i/o);e[s]+=a*t,e[r]-=a*o*t}return s},null),Vm.reduce((r,s)=>{if(fr(e[s]))return r;if(r){const i=e[r]%1;e[r]-=i,e[s]+=i*n[r][s]}return s},null)}function nut(n){const e={};for(const[t,r]of Object.entries(n))r!==0&&(e[t]=r);return e}class Sr{constructor(e){const t=e.conversionAccuracy==="longterm"||!1;let r=t?eut:Qct;e.matrix&&(r=e.matrix),this.values=e.values,this.loc=e.loc||ds.create(),this.conversionAccuracy=t?"longterm":"casual",this.invalid=e.invalid||null,this.matrix=r,this.isLuxonDuration=!0}static fromMillis(e,t){return Sr.fromObject({milliseconds:e},t)}static fromObject(e,t={}){if(e==null||typeof e!="object")throw new ac(`Duration.fromObject: argument expected to be an object, got ${e===null?"null":typeof e}`);return new Sr({values:xA(e,Sr.normalizeUnit),loc:ds.fromObject(t),conversionAccuracy:t.conversionAccuracy,matrix:t.matrix})}static fromDurationLike(e){if(Ym(e))return Sr.fromMillis(e);if(Sr.isDuration(e))return e;if(typeof e=="object")return Sr.fromObject(e);throw new ac(`Unknown duration argument ${e} of type ${typeof e}`)}static fromISO(e,t){const[r]=jct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static fromISOTime(e,t){const[r]=Xct(e);return r?Sr.fromObject(r,t):Sr.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static invalid(e,t=null){if(!e)throw new ac("need to specify a reason the Duration is invalid");const r=e instanceof fu?e:new fu(e,t);if(yi.throwOnInvalid)throw new Rlt(r);return new Sr({invalid:r})}static normalizeUnit(e){const t={year:"years",years:"years",quarter:"quarters",quarters:"quarters",month:"months",months:"months",week:"weeks",weeks:"weeks",day:"days",days:"days",hour:"hours",hours:"hours",minute:"minutes",minutes:"minutes",second:"seconds",seconds:"seconds",millisecond:"milliseconds",milliseconds:"milliseconds"}[e&&e.toLowerCase()];if(!t)throw new nie(e);return t}static isDuration(e){return e&&e.isLuxonDuration||!1}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}toFormat(e,t={}){const r={...t,floor:t.round!==!1&&t.floor!==!1};return this.isValid?Ho.create(this.loc,r).formatDurationFromString(this,e):oj}toHuman(e={}){if(!this.isValid)return oj;const t=Vm.map(r=>{const s=this.values[r];return fr(s)?null:this.loc.numberFormatter({style:"unit",unitDisplay:"long",...e,unit:r.slice(0,-1)}).format(s)}).filter(r=>r);return this.loc.listFormatter({type:"conjunction",style:e.listStyle||"narrow",...e}).format(t)}toObject(){return this.isValid?{...this.values}:{}}toISO(){if(!this.isValid)return null;let e="P";return this.years!==0&&(e+=this.years+"Y"),(this.months!==0||this.quarters!==0)&&(e+=this.months+this.quarters*3+"M"),this.weeks!==0&&(e+=this.weeks+"W"),this.days!==0&&(e+=this.days+"D"),(this.hours!==0||this.minutes!==0||this.seconds!==0||this.milliseconds!==0)&&(e+="T"),this.hours!==0&&(e+=this.hours+"H"),this.minutes!==0&&(e+=this.minutes+"M"),(this.seconds!==0||this.milliseconds!==0)&&(e+=L4(this.seconds+this.milliseconds/1e3,3)+"S"),e==="P"&&(e+="T0S"),e}toISOTime(e={}){if(!this.isValid)return null;const t=this.toMillis();return t<0||t>=864e5?null:(e={suppressMilliseconds:!1,suppressSeconds:!1,includePrefix:!1,format:"extended",...e,includeOffset:!1},bn.fromMillis(t,{zone:"UTC"}).toISOTime(e))}toJSON(){return this.toISO()}toString(){return this.toISO()}toMillis(){return this.isValid?zie(this.matrix,this.values):NaN}valueOf(){return this.toMillis()}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e),r={};for(const s of Vm)(cv(t.values,s)||cv(this.values,s))&&(r[s]=t.get(s)+this.get(s));return hd(this,{values:r},!0)}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return this.plus(t.negate())}mapUnits(e){if(!this.isValid)return this;const t={};for(const r of Object.keys(this.values))t[r]=Cie(e(this.values[r],r));return hd(this,{values:t},!0)}get(e){return this[Sr.normalizeUnit(e)]}set(e){if(!this.isValid)return this;const t={...this.values,...xA(e,Sr.normalizeUnit)};return hd(this,{values:t})}reconfigure({locale:e,numberingSystem:t,conversionAccuracy:r,matrix:s}={}){const o={loc:this.loc.clone({locale:e,numberingSystem:t}),matrix:s,conversionAccuracy:r};return hd(this,o)}as(e){return this.isValid?this.shiftTo(e).get(e):NaN}normalize(){if(!this.isValid)return this;const e=this.toObject();return aj(this.matrix,e),hd(this,{values:e},!0)}rescale(){if(!this.isValid)return this;const e=nut(this.normalize().shiftToAll().toObject());return hd(this,{values:e},!0)}shiftTo(...e){if(!this.isValid)return this;if(e.length===0)return this;e=e.map(o=>Sr.normalizeUnit(o));const t={},r={},s=this.toObject();let i;for(const o of Vm)if(e.indexOf(o)>=0){i=o;let a=0;for(const c in r)a+=this.matrix[c][o]*r[c],r[c]=0;Ym(s[o])&&(a+=s[o]);const l=Math.trunc(a);t[o]=l,r[o]=(a*1e3-l*1e3)/1e3}else Ym(s[o])&&(r[o]=s[o]);for(const o in r)r[o]!==0&&(t[i]+=o===i?r[o]:r[o]/this.matrix[i][o]);return aj(this.matrix,t),hd(this,{values:t},!0)}shiftToAll(){return this.isValid?this.shiftTo("years","months","weeks","days","hours","minutes","seconds","milliseconds"):this}negate(){if(!this.isValid)return this;const e={};for(const t of Object.keys(this.values))e[t]=this.values[t]===0?0:-this.values[t];return hd(this,{values:e},!0)}get years(){return this.isValid?this.values.years||0:NaN}get quarters(){return this.isValid?this.values.quarters||0:NaN}get months(){return this.isValid?this.values.months||0:NaN}get weeks(){return this.isValid?this.values.weeks||0:NaN}get days(){return this.isValid?this.values.days||0:NaN}get hours(){return this.isValid?this.values.hours||0:NaN}get minutes(){return this.isValid?this.values.minutes||0:NaN}get seconds(){return this.isValid?this.values.seconds||0:NaN}get milliseconds(){return this.isValid?this.values.milliseconds||0:NaN}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}equals(e){if(!this.isValid||!e.isValid||!this.loc.equals(e.loc))return!1;function t(r,s){return r===void 0||r===0?s===void 0||s===0:r===s}for(const r of Vm)if(!t(this.values[r],e.values[r]))return!1;return!0}}const z0="Invalid Interval";function rut(n,e){return!n||!n.isValid?Hs.invalid("missing or invalid start"):!e||!e.isValid?Hs.invalid("missing or invalid end"):e<n?Hs.invalid("end before start",`The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`):null}class Hs{constructor(e){this.s=e.start,this.e=e.end,this.invalid=e.invalid||null,this.isLuxonInterval=!0}static invalid(e,t=null){if(!e)throw new ac("need to specify a reason the Interval is invalid");const r=e instanceof fu?e:new fu(e,t);if(yi.throwOnInvalid)throw new $lt(r);return new Hs({invalid:r})}static fromDateTimes(e,t){const r=e1(e),s=e1(t),i=rut(r,s);return i??new Hs({start:r,end:s})}static after(e,t){const r=Sr.fromDurationLike(t),s=e1(e);return Hs.fromDateTimes(s,s.plus(r))}static before(e,t){const r=Sr.fromDurationLike(t),s=e1(e);return Hs.fromDateTimes(s.minus(r),s)}static fromISO(e,t){const[r,s]=(e||"").split("/",2);if(r&&s){let i,o;try{i=bn.fromISO(r,t),o=i.isValid}catch{o=!1}let a,l;try{a=bn.fromISO(s,t),l=a.isValid}catch{l=!1}if(o&&l)return Hs.fromDateTimes(i,a);if(o){const c=Sr.fromISO(s,t);if(c.isValid)return Hs.after(i,c)}else if(l){const c=Sr.fromISO(r,t);if(c.isValid)return Hs.before(a,c)}}return Hs.invalid("unparsable",`the input "${e}" can't be parsed as ISO 8601`)}static isInterval(e){return e&&e.isLuxonInterval||!1}get start(){return this.isValid?this.s:null}get end(){return this.isValid?this.e:null}get isValid(){return this.invalidReason===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}length(e="milliseconds"){return this.isValid?this.toDuration(e).get(e):NaN}count(e="milliseconds"){if(!this.isValid)return NaN;const t=this.start.startOf(e),r=this.end.startOf(e);return Math.floor(r.diff(t,e).get(e))+(r.valueOf()!==this.end.valueOf())}hasSame(e){return this.isValid?this.isEmpty()||this.e.minus(1).hasSame(this.s,e):!1}isEmpty(){return this.s.valueOf()===this.e.valueOf()}isAfter(e){return this.isValid?this.s>e:!1}isBefore(e){return this.isValid?this.e<=e:!1}contains(e){return this.isValid?this.s<=e&&this.e>e:!1}set({start:e,end:t}={}){return this.isValid?Hs.fromDateTimes(e||this.s,t||this.e):this}splitAt(...e){if(!this.isValid)return[];const t=e.map(e1).filter(o=>this.contains(o)).sort(),r=[];let{s}=this,i=0;for(;s<this.e;){const o=t[i]||this.e,a=+o>+this.e?this.e:o;r.push(Hs.fromDateTimes(s,a)),s=a,i+=1}return r}splitBy(e){const t=Sr.fromDurationLike(e);if(!this.isValid||!t.isValid||t.as("milliseconds")===0)return[];let{s:r}=this,s=1,i;const o=[];for(;r<this.e;){const a=this.start.plus(t.mapUnits(l=>l*s));i=+a>+this.e?this.e:a,o.push(Hs.fromDateTimes(r,i)),r=i,s+=1}return o}divideEqually(e){return this.isValid?this.splitBy(this.length()/e).slice(0,e):[]}overlaps(e){return this.e>e.s&&this.s<e.e}abutsStart(e){return this.isValid?+this.e==+e.s:!1}abutsEnd(e){return this.isValid?+e.e==+this.s:!1}engulfs(e){return this.isValid?this.s<=e.s&&this.e>=e.e:!1}equals(e){return!this.isValid||!e.isValid?!1:this.s.equals(e.s)&&this.e.equals(e.e)}intersection(e){if(!this.isValid)return this;const t=this.s>e.s?this.s:e.s,r=this.e<e.e?this.e:e.e;return t>=r?null:Hs.fromDateTimes(t,r)}union(e){if(!this.isValid)return this;const t=this.s<e.s?this.s:e.s,r=this.e>e.e?this.e:e.e;return Hs.fromDateTimes(t,r)}static merge(e){const[t,r]=e.sort((s,i)=>s.s-i.s).reduce(([s,i],o)=>i?i.overlaps(o)||i.abutsStart(o)?[s,i.union(o)]:[s.concat([i]),o]:[s,o],[[],null]);return r&&t.push(r),t}static xor(e){let t=null,r=0;const s=[],i=e.map(l=>[{time:l.s,type:"s"},{time:l.e,type:"e"}]),o=Array.prototype.concat(...i),a=o.sort((l,c)=>l.time-c.time);for(const l of a)r+=l.type==="s"?1:-1,r===1?t=l.time:(t&&+t!=+l.time&&s.push(Hs.fromDateTimes(t,l.time)),t=null);return Hs.merge(s)}difference(...e){return Hs.xor([this].concat(e)).map(t=>this.intersection(t)).filter(t=>t&&!t.isEmpty())}toString(){return this.isValid?`[${this.s.toISO()} – ${this.e.toISO()})`:z0}toLocaleString(e=bA,t={}){return this.isValid?Ho.create(this.s.loc.clone(t),e).formatInterval(this):z0}toISO(e){return this.isValid?`${this.s.toISO(e)}/${this.e.toISO(e)}`:z0}toISODate(){return this.isValid?`${this.s.toISODate()}/${this.e.toISODate()}`:z0}toISOTime(e){return this.isValid?`${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`:z0}toFormat(e,{separator:t=" – "}={}){return this.isValid?`${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`:z0}toDuration(e,t){return this.isValid?this.e.diff(this.s,e,t):Sr.invalid(this.invalidReason)}mapEndpoints(e){return Hs.fromDateTimes(e(this.s),e(this.e))}}class kT{static hasDST(e=yi.defaultZone){const t=bn.now().setZone(e).set({month:12});return!e.isUniversal&&t.offset!==t.set({month:6}).offset}static isValidIANAZone(e){return Rf.isValidZone(e)}static normalizeZone(e){return Id(e,yi.defaultZone)}static months(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||ds.create(t,r,i)).months(e)}static monthsFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null,outputCalendar:i="gregory"}={}){return(s||ds.create(t,r,i)).months(e,!0)}static weekdays(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||ds.create(t,r,null)).weekdays(e)}static weekdaysFormat(e="long",{locale:t=null,numberingSystem:r=null,locObj:s=null}={}){return(s||ds.create(t,r,null)).weekdays(e,!0)}static meridiems({locale:e=null}={}){return ds.create(e).meridiems()}static eras(e="short",{locale:t=null}={}){return ds.create(t,null,"gregory").eras(e)}static features(){return{relative:_ie()}}}function lj(n,e){const t=s=>s.toUTC(0,{keepLocalTime:!0}).startOf("day").valueOf(),r=t(e)-t(n);return Math.floor(Sr.fromMillis(r).as("days"))}function sut(n,e,t){const r=[["years",(l,c)=>c.year-l.year],["quarters",(l,c)=>c.quarter-l.quarter+(c.year-l.year)*4],["months",(l,c)=>c.month-l.month+(c.year-l.year)*12],["weeks",(l,c)=>{const u=lj(l,c);return(u-u%7)/7}],["days",lj]],s={},i=n;let o,a;for(const[l,c]of r)t.indexOf(l)>=0&&(o=l,s[l]=c(n,e),a=i.plus(s),a>e?(s[l]--,n=i.plus(s),n>e&&(a=n,s[l]--,n=i.plus(s))):n=a);return[n,s,a,o]}function iut(n,e,t,r){let[s,i,o,a]=sut(n,e,t);const l=e-s,c=t.filter(h=>["hours","minutes","seconds","milliseconds"].indexOf(h)>=0);c.length===0&&(o<e&&(o=s.plus({[a]:1})),o!==s&&(i[a]=(i[a]||0)+l/(o-s)));const u=Sr.fromObject(i,r);return c.length>0?Sr.fromMillis(l,r).shiftTo(...c).plus(u):u}const U4={arab:"[٠-٩]",arabext:"[۰-۹]",bali:"[᭐-᭙]",beng:"[০-৯]",deva:"[०-९]",fullwide:"[０-９]",gujr:"[૦-૯]",hanidec:"[〇|一|二|三|四|五|六|七|八|九]",khmr:"[០-៩]",knda:"[೦-೯]",laoo:"[໐-໙]",limb:"[᥆-᥏]",mlym:"[൦-൯]",mong:"[᠐-᠙]",mymr:"[၀-၉]",orya:"[୦-୯]",tamldec:"[௦-௯]",telu:"[౦-౯]",thai:"[๐-๙]",tibt:"[༠-༩]",latn:"\\d"},cj={arab:[1632,1641],arabext:[1776,1785],bali:[6992,7001],beng:[2534,2543],deva:[2406,2415],fullwide:[65296,65303],gujr:[2790,2799],khmr:[6112,6121],knda:[3302,3311],laoo:[3792,3801],limb:[6470,6479],mlym:[3430,3439],mong:[6160,6169],mymr:[4160,4169],orya:[2918,2927],tamldec:[3046,3055],telu:[3174,3183],thai:[3664,3673],tibt:[3872,3881]},out=U4.hanidec.replace(/[\[|\]]/g,"").split("");function aut(n){let e=parseInt(n,10);if(isNaN(e)){e="";for(let t=0;t<n.length;t++){const r=n.charCodeAt(t);if(n[t].search(U4.hanidec)!==-1)e+=out.indexOf(n[t]);else for(const s in cj){const[i,o]=cj[s];r>=i&&r<=o&&(e+=r-i)}}return parseInt(e,10)}else return e}function Xc({numberingSystem:n},e=""){return new RegExp(`${U4[n||"latn"]}${e}`)}const lut="missing Intl.DateTimeFormat.formatToParts support";function Ir(n,e=t=>t){return{regex:n,deser:([t])=>e(aut(t))}}const cut=String.fromCharCode(160),Bie=`[ ${cut}]`,Vie=new RegExp(Bie,"g");function uut(n){return n.replace(/\./g,"\\.?").replace(Vie,Bie)}function uj(n){return n.replace(/\./g,"").replace(Vie," ").toLowerCase()}function Kc(n,e){return n===null?null:{regex:RegExp(n.map(uut).join("|")),deser:([t])=>n.findIndex(r=>uj(t)===uj(r))+e}}function hj(n,e){return{regex:n,deser:([,t,r])=>C$(t,r),groups:e}}function TT(n){return{regex:n,deser:([e])=>e}}function hut(n){return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}function fut(n,e){const t=Xc(e),r=Xc(e,"{2}"),s=Xc(e,"{3}"),i=Xc(e,"{4}"),o=Xc(e,"{6}"),a=Xc(e,"{1,2}"),l=Xc(e,"{1,3}"),c=Xc(e,"{1,6}"),u=Xc(e,"{1,9}"),h=Xc(e,"{2,4}"),f=Xc(e,"{4,6}"),d=g=>({regex:RegExp(hut(g.val)),deser:([y])=>y,literal:!0}),m=(g=>{if(n.literal)return d(g);switch(g.val){case"G":return Kc(e.eras("short"),0);case"GG":return Kc(e.eras("long"),0);case"y":return Ir(c);case"yy":return Ir(h,dF);case"yyyy":return Ir(i);case"yyyyy":return Ir(f);case"yyyyyy":return Ir(o);case"M":return Ir(a);case"MM":return Ir(r);case"MMM":return Kc(e.months("short",!0),1);case"MMMM":return Kc(e.months("long",!0),1);case"L":return Ir(a);case"LL":return Ir(r);case"LLL":return Kc(e.months("short",!1),1);case"LLLL":return Kc(e.months("long",!1),1);case"d":return Ir(a);case"dd":return Ir(r);case"o":return Ir(l);case"ooo":return Ir(s);case"HH":return Ir(r);case"H":return Ir(a);case"hh":return Ir(r);case"h":return Ir(a);case"mm":return Ir(r);case"m":return Ir(a);case"q":return Ir(a);case"qq":return Ir(r);case"s":return Ir(a);case"ss":return Ir(r);case"S":return Ir(l);case"SSS":return Ir(s);case"u":return TT(u);case"uu":return TT(a);case"uuu":return Ir(t);case"a":return Kc(e.meridiems(),0);case"kkkk":return Ir(i);case"kk":return Ir(h,dF);case"W":return Ir(a);case"WW":return Ir(r);case"E":case"c":return Ir(t);case"EEE":return Kc(e.weekdays("short",!1),1);case"EEEE":return Kc(e.weekdays("long",!1),1);case"ccc":return Kc(e.weekdays("short",!0),1);case"cccc":return Kc(e.weekdays("long",!0),1);case"Z":case"ZZ":return hj(new RegExp(`([+-]${a.source})(?::(${r.source}))?`),2);case"ZZZ":return hj(new RegExp(`([+-]${a.source})(${r.source})?`),2);case"z":return TT(/[a-z_+-/]{1,256}?/i);case" ":return TT(/[^\S\n\r]/);default:return d(g)}})(n)||{invalidReason:lut};return m.token=n,m}const dut={year:{"2-digit":"yy",numeric:"yyyyy"},month:{numeric:"M","2-digit":"MM",short:"MMM",long:"MMMM"},day:{numeric:"d","2-digit":"dd"},weekday:{short:"EEE",long:"EEEE"},dayperiod:"a",dayPeriod:"a",hour12:{numeric:"h","2-digit":"hh"},hour24:{numeric:"H","2-digit":"HH"},minute:{numeric:"m","2-digit":"mm"},second:{numeric:"s","2-digit":"ss"},timeZoneName:{long:"ZZZZZ",short:"ZZZ"}};function put(n,e,t){const{type:r,value:s}=n;if(r==="literal"){const l=/^\s+$/.test(s);return{literal:!l,val:l?" ":s}}const i=e[r];let o=r;r==="hour"&&(e.hour12!=null?o=e.hour12?"hour12":"hour24":e.hourCycle!=null?e.hourCycle==="h11"||e.hourCycle==="h12"?o="hour12":o="hour24":o=t.hour12?"hour12":"hour24");let a=dut[o];if(typeof a=="object"&&(a=a[i]),a)return{literal:!1,val:a}}function mut(n){return[`^${n.map(t=>t.regex).reduce((t,r)=>`${t}(${r.source})`,"")}$`,n]}function gut(n,e,t){const r=n.match(e);if(r){const s={};let i=1;for(const o in t)if(cv(t,o)){const a=t[o],l=a.groups?a.groups+1:1;!a.literal&&a.token&&(s[a.token.val[0]]=a.deser(r.slice(i,i+l))),i+=l}return[r,s]}else return[r,{}]}function yut(n){const e=i=>{switch(i){case"S":return"millisecond";case"s":return"second";case"m":return"minute";case"h":case"H":return"hour";case"d":return"day";case"o":return"ordinal";case"L":case"M":return"month";case"y":return"year";case"E":case"c":return"weekday";case"W":return"weekNumber";case"k":return"weekYear";case"q":return"quarter";default:return null}};let t=null,r;return fr(n.z)||(t=Rf.create(n.z)),fr(n.Z)||(t||(t=new ma(n.Z)),r=n.Z),fr(n.q)||(n.M=(n.q-1)*3+1),fr(n.h)||(n.h<12&&n.a===1?n.h+=12:n.h===12&&n.a===0&&(n.h=0)),n.G===0&&n.y&&(n.y=-n.y),fr(n.u)||(n.S=F4(n.u)),[Object.keys(n).reduce((i,o)=>{const a=e(o);return a&&(i[a]=n[o]),i},{}),t,r]}let G3=null;function but(){return G3||(G3=bn.fromMillis(1555555555555)),G3}function vut(n,e){if(n.literal)return n;const t=Ho.macroTokenToFormatOpts(n.val),r=Gie(t,e);return r==null||r.includes(void 0)?n:r}function Uie(n,e){return Array.prototype.concat(...n.map(t=>vut(t,e)))}function Wie(n,e,t){const r=Uie(Ho.parseFormat(t),n),s=r.map(o=>fut(o,n)),i=s.find(o=>o.invalidReason);if(i)return{input:e,tokens:r,invalidReason:i.invalidReason};{const[o,a]=mut(s),l=RegExp(o,"i"),[c,u]=gut(e,l,a),[h,f,d]=u?yut(u):[null,null,void 0];if(cv(u,"a")&&cv(u,"H"))throw new R1("Can't include meridiem when specifying 24-hour format");return{input:e,tokens:r,regex:l,rawMatches:c,matches:u,result:h,zone:f,specificOffset:d}}}function wut(n,e,t){const{result:r,zone:s,specificOffset:i,invalidReason:o}=Wie(n,e,t);return[r,s,i,o]}function Gie(n,e){if(!n)return null;const r=Ho.create(e,n).dtFormatter(but()),s=r.formatToParts(),i=r.resolvedOptions();return s.map(o=>put(o,n,i))}const Hie=[0,31,59,90,120,151,181,212,243,273,304,334],jie=[0,31,60,91,121,152,182,213,244,274,305,335];function gc(n,e){return new fu("unit out of range",`you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`)}function qie(n,e,t){const r=new Date(Date.UTC(n,e-1,t));n<100&&n>=0&&r.setUTCFullYear(r.getUTCFullYear()-1900);const s=r.getUTCDay();return s===0?7:s}function Xie(n,e,t){return t+(PC(n)?jie:Hie)[e-1]}function Kie(n,e){const t=PC(n)?jie:Hie,r=t.findIndex(i=>i<e),s=e-t[r];return{month:r+1,day:s}}function pF(n){const{year:e,month:t,day:r}=n,s=Xie(e,t,r),i=qie(e,t,r);let o=Math.floor((s-i+10)/7),a;return o<1?(a=e-1,o=wA(a)):o>wA(e)?(a=e+1,o=1):a=e,{weekYear:a,weekNumber:o,weekday:i,...k$(n)}}function fj(n){const{weekYear:e,weekNumber:t,weekday:r}=n,s=qie(e,1,4),i=r_(e);let o=t*7+r-s-3,a;o<1?(a=e-1,o+=r_(a)):o>i?(a=e+1,o-=r_(e)):a=e;const{month:l,day:c}=Kie(a,o);return{year:a,month:l,day:c,...k$(n)}}function H3(n){const{year:e,month:t,day:r}=n,s=Xie(e,t,r);return{year:e,ordinal:s,...k$(n)}}function dj(n){const{year:e,ordinal:t}=n,{month:r,day:s}=Kie(e,t);return{year:e,month:r,day:s,...k$(n)}}function xut(n){const e=_$(n.weekYear),t=kf(n.weekNumber,1,wA(n.weekYear)),r=kf(n.weekday,1,7);return e?t?r?!1:gc("weekday",n.weekday):gc("week",n.week):gc("weekYear",n.weekYear)}function _ut(n){const e=_$(n.year),t=kf(n.ordinal,1,r_(n.year));return e?t?!1:gc("ordinal",n.ordinal):gc("year",n.year)}function Yie(n){const e=_$(n.year),t=kf(n.month,1,12),r=kf(n.day,1,vA(n.year,n.month));return e?t?r?!1:gc("day",n.day):gc("month",n.month):gc("year",n.year)}function Zie(n){const{hour:e,minute:t,second:r,millisecond:s}=n,i=kf(e,0,23)||e===24&&t===0&&r===0&&s===0,o=kf(t,0,59),a=kf(r,0,59),l=kf(s,0,999);return i?o?a?l?!1:gc("millisecond",s):gc("second",r):gc("minute",t):gc("hour",e)}const j3="Invalid DateTime",pj=864e13;function ET(n){return new fu("unsupported zone",`the zone "${n.name}" is not supported`)}function q3(n){return n.weekData===null&&(n.weekData=pF(n.c)),n.weekData}function um(n,e){const t={ts:n.ts,zone:n.zone,c:n.c,o:n.o,loc:n.loc,invalid:n.invalid};return new bn({...t,...e,old:t})}function Jie(n,e,t){let r=n-e*60*1e3;const s=t.offset(r);if(e===s)return[r,e];r-=(s-e)*60*1e3;const i=t.offset(r);return s===i?[r,s]:[n-Math.min(s,i)*60*1e3,Math.max(s,i)]}function IT(n,e){n+=e*60*1e3;const t=new Date(n);return{year:t.getUTCFullYear(),month:t.getUTCMonth()+1,day:t.getUTCDate(),hour:t.getUTCHours(),minute:t.getUTCMinutes(),second:t.getUTCSeconds(),millisecond:t.getUTCMilliseconds()}}function QE(n,e,t){return Jie(S$(n),e,t)}function mj(n,e){const t=n.o,r=n.c.year+Math.trunc(e.years),s=n.c.month+Math.trunc(e.months)+Math.trunc(e.quarters)*3,i={...n.c,year:r,month:s,day:Math.min(n.c.day,vA(r,s))+Math.trunc(e.days)+Math.trunc(e.weeks)*7},o=Sr.fromObject({years:e.years-Math.trunc(e.years),quarters:e.quarters-Math.trunc(e.quarters),months:e.months-Math.trunc(e.months),weeks:e.weeks-Math.trunc(e.weeks),days:e.days-Math.trunc(e.days),hours:e.hours,minutes:e.minutes,seconds:e.seconds,milliseconds:e.milliseconds}).as("milliseconds"),a=S$(i);let[l,c]=Jie(a,t,n.zone);return o!==0&&(l+=o,c=n.zone.offset(l)),{ts:l,o:c}}function Qx(n,e,t,r,s,i){const{setZone:o,zone:a}=t;if(n&&Object.keys(n).length!==0||e){const l=e||a,c=bn.fromObject(n,{...t,zone:l,specificOffset:i});return o?c:c.setZone(a)}else return bn.invalid(new fu("unparsable",`the input "${s}" can't be parsed as ${r}`))}function AT(n,e,t=!0){return n.isValid?Ho.create(ds.create("en-US"),{allowZ:t,forceSimple:!0}).formatDateTimeFromString(n,e):null}function X3(n,e){const t=n.c.year>9999||n.c.year<0;let r="";return t&&n.c.year>=0&&(r+="+"),r+=vi(n.c.year,t?6:4),e?(r+="-",r+=vi(n.c.month),r+="-",r+=vi(n.c.day)):(r+=vi(n.c.month),r+=vi(n.c.day)),r}function gj(n,e,t,r,s,i){let o=vi(n.c.hour);return e?(o+=":",o+=vi(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=":")):o+=vi(n.c.minute),(n.c.millisecond!==0||n.c.second!==0||!t)&&(o+=vi(n.c.second),(n.c.millisecond!==0||!r)&&(o+=".",o+=vi(n.c.millisecond,3))),s&&(n.isOffsetFixed&&n.offset===0&&!i?o+="Z":n.o<0?(o+="-",o+=vi(Math.trunc(-n.o/60)),o+=":",o+=vi(Math.trunc(-n.o%60))):(o+="+",o+=vi(Math.trunc(n.o/60)),o+=":",o+=vi(Math.trunc(n.o%60)))),i&&(o+="["+n.zone.ianaName+"]"),o}const Qie={month:1,day:1,hour:0,minute:0,second:0,millisecond:0},Sut={weekNumber:1,weekday:1,hour:0,minute:0,second:0,millisecond:0},Cut={ordinal:1,hour:0,minute:0,second:0,millisecond:0},eoe=["year","month","day","hour","minute","second","millisecond"],kut=["weekYear","weekNumber","weekday","hour","minute","second","millisecond"],Tut=["year","ordinal","hour","minute","second","millisecond"];function yj(n){const e={year:"year",years:"year",month:"month",months:"month",day:"day",days:"day",hour:"hour",hours:"hour",minute:"minute",minutes:"minute",quarter:"quarter",quarters:"quarter",second:"second",seconds:"second",millisecond:"millisecond",milliseconds:"millisecond",weekday:"weekday",weekdays:"weekday",weeknumber:"weekNumber",weeksnumber:"weekNumber",weeknumbers:"weekNumber",weekyear:"weekYear",weekyears:"weekYear",ordinal:"ordinal"}[n.toLowerCase()];if(!e)throw new nie(n);return e}function bj(n,e){const t=Id(e.zone,yi.defaultZone),r=ds.fromObject(e),s=yi.now();let i,o;if(fr(n.year))i=s;else{for(const c of eoe)fr(n[c])&&(n[c]=Qie[c]);const a=Yie(n)||Zie(n);if(a)return bn.invalid(a);const l=t.offset(s);[i,o]=QE(n,l,t)}return new bn({ts:i,zone:t,loc:r,o})}function vj(n,e,t){const r=fr(t.round)?!0:t.round,s=(o,a)=>(o=L4(o,r||t.calendary?0:2,!0),e.loc.clone(t).relFormatter(t).format(o,a)),i=o=>t.calendary?e.hasSame(n,o)?0:e.startOf(o).diff(n.startOf(o),o).get(o):e.diff(n,o).get(o);if(t.unit)return s(i(t.unit),t.unit);for(const o of t.units){const a=i(o);if(Math.abs(a)>=1)return s(a,o)}return s(n>e?-0:0,t.units[t.units.length-1])}function wj(n){let e={},t;return n.length>0&&typeof n[n.length-1]=="object"?(e=n[n.length-1],t=Array.from(n).slice(0,n.length-1)):t=Array.from(n),[e,t]}class bn{constructor(e){const t=e.zone||yi.defaultZone;let r=e.invalid||(Number.isNaN(e.ts)?new fu("invalid input"):null)||(t.isValid?null:ET(t));this.ts=fr(e.ts)?yi.now():e.ts;let s=null,i=null;if(!r)if(e.old&&e.old.ts===this.ts&&e.old.zone.equals(t))[s,i]=[e.old.c,e.old.o];else{const a=t.offset(this.ts);s=IT(this.ts,a),r=Number.isNaN(s.year)?new fu("invalid input"):null,s=r?null:s,i=r?null:a}this._zone=t,this.loc=e.loc||ds.create(),this.invalid=r,this.weekData=null,this.c=s,this.o=i,this.isLuxonDateTime=!0}static now(){return new bn({})}static local(){const[e,t]=wj(arguments),[r,s,i,o,a,l,c]=t;return bj({year:r,month:s,day:i,hour:o,minute:a,second:l,millisecond:c},e)}static utc(){const[e,t]=wj(arguments),[r,s,i,o,a,l,c]=t;return e.zone=ma.utcInstance,bj({year:r,month:s,day:i,hour:o,minute:a,second:l,millisecond:c},e)}static fromJSDate(e,t={}){const r=ect(e)?e.valueOf():NaN;if(Number.isNaN(r))return bn.invalid("invalid input");const s=Id(t.zone,yi.defaultZone);return s.isValid?new bn({ts:r,zone:s,loc:ds.fromObject(t)}):bn.invalid(ET(s))}static fromMillis(e,t={}){if(Ym(e))return e<-pj||e>pj?bn.invalid("Timestamp out of range"):new bn({ts:e,zone:Id(t.zone,yi.defaultZone),loc:ds.fromObject(t)});throw new ac(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`)}static fromSeconds(e,t={}){if(Ym(e))return new bn({ts:e*1e3,zone:Id(t.zone,yi.defaultZone),loc:ds.fromObject(t)});throw new ac("fromSeconds requires a numerical input")}static fromObject(e,t={}){e=e||{};const r=Id(t.zone,yi.defaultZone);if(!r.isValid)return bn.invalid(ET(r));const s=yi.now(),i=fr(t.specificOffset)?r.offset(s):t.specificOffset,o=xA(e,yj),a=!fr(o.ordinal),l=!fr(o.year),c=!fr(o.month)||!fr(o.day),u=l||c,h=o.weekYear||o.weekNumber,f=ds.fromObject(t);if((u||a)&&h)throw new R1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(c&&a)throw new R1("Can't mix ordinal dates with month/day");const d=h||o.weekday&&!u;let p,m,g=IT(s,i);d?(p=kut,m=Sut,g=pF(g)):a?(p=Tut,m=Cut,g=H3(g)):(p=eoe,m=Qie);let y=!1;for(const A of p){const M=o[A];fr(M)?y?o[A]=m[A]:o[A]=g[A]:y=!0}const b=d?xut(o):a?_ut(o):Yie(o),x=b||Zie(o);if(x)return bn.invalid(x);const w=d?fj(o):a?dj(o):o,[S,C]=QE(w,i,r),k=new bn({ts:S,zone:r,o:C,loc:f});return o.weekday&&u&&e.weekday!==k.weekday?bn.invalid("mismatched weekday",`you can't specify both a weekday of ${o.weekday} and a date of ${k.toISO()}`):k}static fromISO(e,t={}){const[r,s]=Wct(e);return Qx(r,s,t,"ISO 8601",e)}static fromRFC2822(e,t={}){const[r,s]=Gct(e);return Qx(r,s,t,"RFC 2822",e)}static fromHTTP(e,t={}){const[r,s]=Hct(e);return Qx(r,s,t,"HTTP",t)}static fromFormat(e,t,r={}){if(fr(e)||fr(t))throw new ac("fromFormat requires an input string and a format");const{locale:s=null,numberingSystem:i=null}=r,o=ds.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0}),[a,l,c,u]=wut(o,e,t);return u?bn.invalid(u):Qx(a,l,r,`format ${t}`,e,c)}static fromString(e,t,r={}){return bn.fromFormat(e,t,r)}static fromSQL(e,t={}){const[r,s]=Jct(e);return Qx(r,s,t,"SQL",e)}static invalid(e,t=null){if(!e)throw new ac("need to specify a reason the DateTime is invalid");const r=e instanceof fu?e:new fu(e,t);if(yi.throwOnInvalid)throw new Nlt(r);return new bn({invalid:r})}static isDateTime(e){return e&&e.isLuxonDateTime||!1}static parseFormatForOpts(e,t={}){const r=Gie(e,ds.fromObject(t));return r?r.map(s=>s?s.val:null).join(""):null}static expandFormat(e,t={}){return Uie(Ho.parseFormat(e),ds.fromObject(t)).map(s=>s.val).join("")}get(e){return this[e]}get isValid(){return this.invalid===null}get invalidReason(){return this.invalid?this.invalid.reason:null}get invalidExplanation(){return this.invalid?this.invalid.explanation:null}get locale(){return this.isValid?this.loc.locale:null}get numberingSystem(){return this.isValid?this.loc.numberingSystem:null}get outputCalendar(){return this.isValid?this.loc.outputCalendar:null}get zone(){return this._zone}get zoneName(){return this.isValid?this.zone.name:null}get year(){return this.isValid?this.c.year:NaN}get quarter(){return this.isValid?Math.ceil(this.c.month/3):NaN}get month(){return this.isValid?this.c.month:NaN}get day(){return this.isValid?this.c.day:NaN}get hour(){return this.isValid?this.c.hour:NaN}get minute(){return this.isValid?this.c.minute:NaN}get second(){return this.isValid?this.c.second:NaN}get millisecond(){return this.isValid?this.c.millisecond:NaN}get weekYear(){return this.isValid?q3(this).weekYear:NaN}get weekNumber(){return this.isValid?q3(this).weekNumber:NaN}get weekday(){return this.isValid?q3(this).weekday:NaN}get ordinal(){return this.isValid?H3(this.c).ordinal:NaN}get monthShort(){return this.isValid?kT.months("short",{locObj:this.loc})[this.month-1]:null}get monthLong(){return this.isValid?kT.months("long",{locObj:this.loc})[this.month-1]:null}get weekdayShort(){return this.isValid?kT.weekdays("short",{locObj:this.loc})[this.weekday-1]:null}get weekdayLong(){return this.isValid?kT.weekdays("long",{locObj:this.loc})[this.weekday-1]:null}get offset(){return this.isValid?+this.o:NaN}get offsetNameShort(){return this.isValid?this.zone.offsetName(this.ts,{format:"short",locale:this.locale}):null}get offsetNameLong(){return this.isValid?this.zone.offsetName(this.ts,{format:"long",locale:this.locale}):null}get isOffsetFixed(){return this.isValid?this.zone.isUniversal:null}get isInDST(){return this.isOffsetFixed?!1:this.offset>this.set({month:1,day:1}).offset||this.offset>this.set({month:5}).offset}getPossibleOffsets(){if(!this.isValid||this.isOffsetFixed)return[this];const e=864e5,t=6e4,r=S$(this.c),s=this.zone.offset(r-e),i=this.zone.offset(r+e),o=this.zone.offset(r-s*t),a=this.zone.offset(r-i*t);if(o===a)return[this];const l=r-o*t,c=r-a*t,u=IT(l,o),h=IT(c,a);return u.hour===h.hour&&u.minute===h.minute&&u.second===h.second&&u.millisecond===h.millisecond?[um(this,{ts:l}),um(this,{ts:c})]:[this]}get isInLeapYear(){return PC(this.year)}get daysInMonth(){return vA(this.year,this.month)}get daysInYear(){return this.isValid?r_(this.year):NaN}get weeksInWeekYear(){return this.isValid?wA(this.weekYear):NaN}resolvedLocaleOptions(e={}){const{locale:t,numberingSystem:r,calendar:s}=Ho.create(this.loc.clone(e),e).resolvedOptions(this);return{locale:t,numberingSystem:r,outputCalendar:s}}toUTC(e=0,t={}){return this.setZone(ma.instance(e),t)}toLocal(){return this.setZone(yi.defaultZone)}setZone(e,{keepLocalTime:t=!1,keepCalendarTime:r=!1}={}){if(e=Id(e,yi.defaultZone),e.equals(this.zone))return this;if(e.isValid){let s=this.ts;if(t||r){const i=e.offset(this.ts),o=this.toObject();[s]=QE(o,i,e)}return um(this,{ts:s,zone:e})}else return bn.invalid(ET(e))}reconfigure({locale:e,numberingSystem:t,outputCalendar:r}={}){const s=this.loc.clone({locale:e,numberingSystem:t,outputCalendar:r});return um(this,{loc:s})}setLocale(e){return this.reconfigure({locale:e})}set(e){if(!this.isValid)return this;const t=xA(e,yj),r=!fr(t.weekYear)||!fr(t.weekNumber)||!fr(t.weekday),s=!fr(t.ordinal),i=!fr(t.year),o=!fr(t.month)||!fr(t.day),a=i||o,l=t.weekYear||t.weekNumber;if((a||s)&&l)throw new R1("Can't mix weekYear/weekNumber units with year/month/day or ordinals");if(o&&s)throw new R1("Can't mix ordinal dates with month/day");let c;r?c=fj({...pF(this.c),...t}):fr(t.ordinal)?(c={...this.toObject(),...t},fr(t.day)&&(c.day=Math.min(vA(c.year,c.month),c.day))):c=dj({...H3(this.c),...t});const[u,h]=QE(c,this.o,this.zone);return um(this,{ts:u,o:h})}plus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e);return um(this,mj(this,t))}minus(e){if(!this.isValid)return this;const t=Sr.fromDurationLike(e).negate();return um(this,mj(this,t))}startOf(e){if(!this.isValid)return this;const t={},r=Sr.normalizeUnit(e);switch(r){case"years":t.month=1;case"quarters":case"months":t.day=1;case"weeks":case"days":t.hour=0;case"hours":t.minute=0;case"minutes":t.second=0;case"seconds":t.millisecond=0;break}if(r==="weeks"&&(t.weekday=1),r==="quarters"){const s=Math.ceil(this.month/3);t.month=(s-1)*3+1}return this.set(t)}endOf(e){return this.isValid?this.plus({[e]:1}).startOf(e).minus(1):this}toFormat(e,t={}){return this.isValid?Ho.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this,e):j3}toLocaleString(e=bA,t={}){return this.isValid?Ho.create(this.loc.clone(t),e).formatDateTime(this):j3}toLocaleParts(e={}){return this.isValid?Ho.create(this.loc.clone(e),e).formatDateTimeParts(this):[]}toISO({format:e="extended",suppressSeconds:t=!1,suppressMilliseconds:r=!1,includeOffset:s=!0,extendedZone:i=!1}={}){if(!this.isValid)return null;const o=e==="extended";let a=X3(this,o);return a+="T",a+=gj(this,o,t,r,s,i),a}toISODate({format:e="extended"}={}){return this.isValid?X3(this,e==="extended"):null}toISOWeekDate(){return AT(this,"kkkk-'W'WW-c")}toISOTime({suppressMilliseconds:e=!1,suppressSeconds:t=!1,includeOffset:r=!0,includePrefix:s=!1,extendedZone:i=!1,format:o="extended"}={}){return this.isValid?(s?"T":"")+gj(this,o==="extended",t,e,r,i):null}toRFC2822(){return AT(this,"EEE, dd LLL yyyy HH:mm:ss ZZZ",!1)}toHTTP(){return AT(this.toUTC(),"EEE, dd LLL yyyy HH:mm:ss 'GMT'")}toSQLDate(){return this.isValid?X3(this,!0):null}toSQLTime({includeOffset:e=!0,includeZone:t=!1,includeOffsetSpace:r=!0}={}){let s="HH:mm:ss.SSS";return(t||e)&&(r&&(s+=" "),t?s+="z":e&&(s+="ZZ")),AT(this,s,!0)}toSQL(e={}){return this.isValid?`${this.toSQLDate()} ${this.toSQLTime(e)}`:null}toString(){return this.isValid?this.toISO():j3}valueOf(){return this.toMillis()}toMillis(){return this.isValid?this.ts:NaN}toSeconds(){return this.isValid?this.ts/1e3:NaN}toUnixInteger(){return this.isValid?Math.floor(this.ts/1e3):NaN}toJSON(){return this.toISO()}toBSON(){return this.toJSDate()}toObject(e={}){if(!this.isValid)return{};const t={...this.c};return e.includeConfig&&(t.outputCalendar=this.outputCalendar,t.numberingSystem=this.loc.numberingSystem,t.locale=this.loc.locale),t}toJSDate(){return new Date(this.isValid?this.ts:NaN)}diff(e,t="milliseconds",r={}){if(!this.isValid||!e.isValid)return Sr.invalid("created by diffing an invalid DateTime");const s={locale:this.locale,numberingSystem:this.numberingSystem,...r},i=tct(t).map(Sr.normalizeUnit),o=e.valueOf()>this.valueOf(),a=o?this:e,l=o?e:this,c=iut(a,l,i,s);return o?c.negate():c}diffNow(e="milliseconds",t={}){return this.diff(bn.now(),e,t)}until(e){return this.isValid?Hs.fromDateTimes(this,e):this}hasSame(e,t){if(!this.isValid)return!1;const r=e.valueOf(),s=this.setZone(e.zone,{keepLocalTime:!0});return s.startOf(t)<=r&&r<=s.endOf(t)}equals(e){return this.isValid&&e.isValid&&this.valueOf()===e.valueOf()&&this.zone.equals(e.zone)&&this.loc.equals(e.loc)}toRelative(e={}){if(!this.isValid)return null;const t=e.base||bn.fromObject({},{zone:this.zone}),r=e.padding?this<t?-e.padding:e.padding:0;let s=["years","months","days","hours","minutes","seconds"],i=e.unit;return Array.isArray(e.unit)&&(s=e.unit,i=void 0),vj(t,this.plus(r),{...e,numeric:"always",units:s,unit:i})}toRelativeCalendar(e={}){return this.isValid?vj(e.base||bn.fromObject({},{zone:this.zone}),this,{...e,numeric:"auto",units:["years","months","days"],calendary:!0}):null}static min(...e){if(!e.every(bn.isDateTime))throw new ac("min requires all arguments be DateTimes");return rj(e,t=>t.valueOf(),Math.min)}static max(...e){if(!e.every(bn.isDateTime))throw new ac("max requires all arguments be DateTimes");return rj(e,t=>t.valueOf(),Math.max)}static fromFormatExplain(e,t,r={}){const{locale:s=null,numberingSystem:i=null}=r,o=ds.fromOpts({locale:s,numberingSystem:i,defaultToEN:!0});return Wie(o,e,t)}static fromStringExplain(e,t,r={}){return bn.fromFormatExplain(e,t,r)}static get DATE_SHORT(){return bA}static get DATE_MED(){return rie}static get DATE_MED_WITH_WEEKDAY(){return Plt}static get DATE_FULL(){return sie}static get DATE_HUGE(){return iie}static get TIME_SIMPLE(){return oie}static get TIME_WITH_SECONDS(){return aie}static get TIME_WITH_SHORT_OFFSET(){return lie}static get TIME_WITH_LONG_OFFSET(){return cie}static get TIME_24_SIMPLE(){return uie}static get TIME_24_WITH_SECONDS(){return hie}static get TIME_24_WITH_SHORT_OFFSET(){return fie}static get TIME_24_WITH_LONG_OFFSET(){return die}static get DATETIME_SHORT(){return pie}static get DATETIME_SHORT_WITH_SECONDS(){return mie}static get DATETIME_MED(){return gie}static get DATETIME_MED_WITH_SECONDS(){return yie}static get DATETIME_MED_WITH_WEEKDAY(){return Dlt}static get DATETIME_FULL(){return bie}static get DATETIME_FULL_WITH_SECONDS(){return vie}static get DATETIME_HUGE(){return wie}static get DATETIME_HUGE_WITH_SECONDS(){return xie}}function e1(n){if(bn.isDateTime(n))return n;if(n&&n.valueOf&&Ym(n.valueOf()))return bn.fromJSDate(n);if(n&&typeof n=="object")return bn.fromObject(n);throw new ac(`Unknown datetime argument: ${n}, of type ${typeof n}`)}/*!
 * chartjs-adapter-luxon v1.3.1
 * https://www.chartjs.org
 * (c) 2023 chartjs-adapter-luxon Contributors
 * Released under the MIT license
 */const Eut={datetime:bn.DATETIME_MED_WITH_SECONDS,millisecond:"h:mm:ss.SSS a",second:bn.TIME_WITH_SECONDS,minute:bn.TIME_SIMPLE,hour:{hour:"numeric"},day:{day:"numeric",month:"short"},week:"DD",month:{month:"short",year:"numeric"},quarter:"'Q'q - yyyy",year:{year:"numeric"}};Dse._date.override({_id:"luxon",_create:function(n){return bn.fromMillis(n,this.options)},init(n){this.options.locale||(this.options.locale=n.locale)},formats:function(){return Eut},parse:function(n,e){const t=this.options,r=typeof n;return n===null||r==="undefined"?null:(r==="number"?n=this._create(n):r==="string"?typeof e=="string"?n=bn.fromFormat(n,e,t):n=bn.fromISO(n,t):n instanceof Date?n=bn.fromJSDate(n,t):r==="object"&&!(n instanceof bn)&&(n=bn.fromObject(n,t)),n.isValid?n.valueOf():null)},format:function(n,e){const t=this._create(n);return typeof e=="string"?t.toFormat(e):t.toLocaleString(e)},add:function(n,e,t){const r={};return r[t]=e,this._create(n).plus(r).valueOf()},diff:function(n,e,t){return this._create(n).diff(this._create(e)).as(t).valueOf()},startOf:function(n,e,t){if(e==="isoWeek"){t=Math.trunc(Math.min(Math.max(0,t),6));const r=this._create(n);return r.minus({days:(r.weekday-t+7)%7}).startOf("day").valueOf()}return e?this._create(n).startOf(e).valueOf():n},endOf:function(n,e){return this._create(n).endOf(e).valueOf()}});var xj=Object.prototype.hasOwnProperty;function _j(n,e,t){for(t of n.keys())if(i_(t,e))return t}function i_(n,e){var t,r,s;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((r=n.length)===e.length)for(;r--&&i_(n[r],e[r]););return r===-1}if(t===Set){if(n.size!==e.size)return!1;for(r of n)if(s=r,s&&typeof s=="object"&&(s=_j(e,s),!s)||!e.has(s))return!1;return!0}if(t===Map){if(n.size!==e.size)return!1;for(r of n)if(s=r[0],s&&typeof s=="object"&&(s=_j(e,s),!s)||!i_(r[1],e.get(s)))return!1;return!0}if(t===ArrayBuffer)n=new Uint8Array(n),e=new Uint8Array(e);else if(t===DataView){if((r=n.byteLength)===e.byteLength)for(;r--&&n.getInt8(r)===e.getInt8(r););return r===-1}if(ArrayBuffer.isView(n)){if((r=n.byteLength)===e.byteLength)for(;r--&&n[r]===e[r];);return r===-1}if(!t||typeof n=="object"){r=0;for(t in n)if(xj.call(n,t)&&++r&&!xj.call(e,t)||!(t in e)||!i_(n[t],e[t]))return!1;return Object.keys(e).length===r}}return n!==n&&e!==e}/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */var Iut="2.0.1";class D1 extends wc{initialize(){this.enableOptionSharing=!0,super.initialize()}update(e){const t=this,r=t._cachedMeta;t.updateElements(r.data,0,r.data.length,e)}updateElements(e,t,r,s){const i=this,o=s==="reset",{xScale:a,yScale:l}=i._cachedMeta,c=i.resolveDataElementOptions(t,s),u=i.getSharedOptions(s,e[t],c);for(let h=t;h<t+r;h++){const f=!o&&i.getParsed(h),d=o?a.getBasePixel():a.getPixelForValue(f.x),p=o?l.getBasePixel():l.getPixelForValue(f.y),m=i.resolveDataElementOptions(h,s),{width:g,height:y,anchorX:b,anchorY:x}=m,w={x:Aut(b,d,g),y:Mut(x,p,y),width:g,height:y,options:m};i.updateElement(e[h],h,w,s)}i.updateSharedOptions(u,s)}draw(){const e=this,t=e.getMeta().data||[];let r,s;for(r=0,s=t.length;r<s;++r)t[r].draw(e._ctx)}}Mt(D1,"id","matrix"),Mt(D1,"version",Iut),Mt(D1,"defaults",{dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}}),Mt(D1,"overrides",{interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}});function Aut(n,e,t){return n==="left"||n==="start"?e:n==="right"||n==="end"?e-t:e-t/2}function Mut(n,e,t){return n==="top"||n==="start"?e:n==="bottom"||n==="end"?e-t:e-t/2}function toe(n,e){const{x:t,y:r,width:s,height:i}=n.getProps(["x","y","width","height"],e);return{left:t,top:r,right:t+s,bottom:r+i}}function MT(n,e,t){return Math.max(Math.min(n,t),e)}function Nut(n,e,t){const r=n.options.borderWidth;let s,i,o,a;return nr(r)?(s=+r.top||0,i=+r.right||0,o=+r.bottom||0,a=+r.left||0):s=i=o=a=+r||0,{t:MT(s,0,t),r:MT(i,0,e),b:MT(o,0,t),l:MT(a,0,e)}}function $ut(n){const e=toe(n),t=e.right-e.left,r=e.bottom-e.top,s=Nut(n,t/2,r/2);return{outer:{x:e.left,y:e.top,w:t,h:r},inner:{x:e.left+s.l,y:e.top+s.t,w:t-s.l-s.r,h:r-s.t-s.b}}}function K3(n,e,t,r){const s=e===null,i=t===null,o=!n||s&&i?!1:toe(n,r);return o&&(s||e>=o.left&&e<=o.right)&&(i||t>=o.top&&t<=o.bottom)}class mF extends Ic{constructor(e){super(),this.options=void 0,this.width=void 0,this.height=void 0,e&&Object.assign(this,e)}draw(e){const t=this.options,{inner:r,outer:s}=$ut(this),i=Xd(t.borderRadius);e.save(),s.w!==r.w||s.h!==r.h?(e.beginPath(),qd(e,{x:s.x,y:s.y,w:s.w,h:s.h,radius:i}),qd(e,{x:r.x,y:r.y,w:r.w,h:r.h,radius:i}),e.fillStyle=t.backgroundColor,e.fill(),e.fillStyle=t.borderColor,e.fill("evenodd")):(e.beginPath(),qd(e,{x:r.x,y:r.y,w:r.w,h:r.h,radius:i}),e.fillStyle=t.backgroundColor,e.fill()),e.restore()}inRange(e,t,r){return K3(this,e,t,r)}inXRange(e,t){return K3(this,e,null,t)}inYRange(e,t){return K3(this,null,e,t)}getCenterPoint(e){const{x:t,y:r,width:s,height:i}=this.getProps(["x","y","width","height"],e);return{x:t+s/2,y:r+i/2}}tooltipPosition(){return this.getCenterPoint()}getRange(e){return e==="x"?this.width/2:this.height/2}}Mt(mF,"id","matrix"),Mt(mF,"defaults",{backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20});var Rut={exports:{}};/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */(function(n){(function(e,t,r,s){var i=["","webkit","Moz","MS","ms","o"],o=t.createElement("div"),a="function",l=Math.round,c=Math.abs,u=Date.now;function h(H,Y,pe){return setTimeout(x(H,pe),Y)}function f(H,Y,pe){return Array.isArray(H)?(d(H,pe[Y],pe),!0):!1}function d(H,Y,pe){var Re;if(H)if(H.forEach)H.forEach(Y,pe);else if(H.length!==s)for(Re=0;Re<H.length;)Y.call(pe,H[Re],Re,H),Re++;else for(Re in H)H.hasOwnProperty(Re)&&Y.call(pe,H[Re],Re,H)}function p(H,Y,pe){var Re="DEPRECATED METHOD: "+Y+`
`+pe+` AT 
`;return function(){var at=new Error("get-stack-trace"),Vt=at&&at.stack?at.stack.replace(/^[^\(]+?[\n$]/gm,"").replace(/^\s+at\s+/gm,"").replace(/^Object.<anonymous>\s*\(/gm,"{anonymous}()@"):"Unknown Stack Trace",$n=e.console&&(e.console.warn||e.console.log);return $n&&$n.call(e.console,Re,Vt),H.apply(this,arguments)}}var m;typeof Object.assign!="function"?m=function(Y){if(Y===s||Y===null)throw new TypeError("Cannot convert undefined or null to object");for(var pe=Object(Y),Re=1;Re<arguments.length;Re++){var at=arguments[Re];if(at!==s&&at!==null)for(var Vt in at)at.hasOwnProperty(Vt)&&(pe[Vt]=at[Vt])}return pe}:m=Object.assign;var g=p(function(Y,pe,Re){for(var at=Object.keys(pe),Vt=0;Vt<at.length;)(!Re||Re&&Y[at[Vt]]===s)&&(Y[at[Vt]]=pe[at[Vt]]),Vt++;return Y},"extend","Use `assign`."),y=p(function(Y,pe){return g(Y,pe,!0)},"merge","Use `assign`.");function b(H,Y,pe){var Re=Y.prototype,at;at=H.prototype=Object.create(Re),at.constructor=H,at._super=Re,pe&&m(at,pe)}function x(H,Y){return function(){return H.apply(Y,arguments)}}function w(H,Y){return typeof H==a?H.apply(Y&&Y[0]||s,Y):H}function S(H,Y){return H===s?Y:H}function C(H,Y,pe){d(E(Y),function(Re){H.addEventListener(Re,pe,!1)})}function k(H,Y,pe){d(E(Y),function(Re){H.removeEventListener(Re,pe,!1)})}function A(H,Y){for(;H;){if(H==Y)return!0;H=H.parentNode}return!1}function M(H,Y){return H.indexOf(Y)>-1}function E(H){return H.trim().split(/\s+/g)}function N(H,Y,pe){if(H.indexOf&&!pe)return H.indexOf(Y);for(var Re=0;Re<H.length;){if(pe&&H[Re][pe]==Y||!pe&&H[Re]===Y)return Re;Re++}return-1}function O(H){return Array.prototype.slice.call(H,0)}function R(H,Y,pe){for(var Re=[],at=[],Vt=0;Vt<H.length;){var $n=Y?H[Vt][Y]:H[Vt];N(at,$n)<0&&Re.push(H[Vt]),at[Vt]=$n,Vt++}return pe&&(Y?Re=Re.sort(function(Us,pi){return Us[Y]>pi[Y]}):Re=Re.sort()),Re}function D(H,Y){for(var pe,Re,at=Y[0].toUpperCase()+Y.slice(1),Vt=0;Vt<i.length;){if(pe=i[Vt],Re=pe?pe+at:Y,Re in H)return Re;Vt++}return s}var z=1;function B(){return z++}function X(H){var Y=H.ownerDocument||H;return Y.defaultView||Y.parentWindow||e}var G=/mobile|tablet|ip(ad|hone|od)|android/i,te="ontouchstart"in e,ge=D(e,"PointerEvent")!==s,ae=te&&G.test(navigator.userAgent),Ne="touch",ke="pen",De="mouse",be="kinect",Xe=25,Oe=1,it=2,We=4,dt=8,ct=1,Ve=2,ze=4,Be=8,ut=16,Ke=Ve|ze,ee=Be|ut,J=Ke|ee,rt=["x","y"],Ge=["clientX","clientY"];function ye(H,Y){var pe=this;this.manager=H,this.callback=Y,this.element=H.element,this.target=H.options.inputTarget,this.domHandler=function(Re){w(H.options.enable,[H])&&pe.handler(Re)},this.init()}ye.prototype={handler:function(){},init:function(){this.evEl&&C(this.element,this.evEl,this.domHandler),this.evTarget&&C(this.target,this.evTarget,this.domHandler),this.evWin&&C(X(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&k(this.element,this.evEl,this.domHandler),this.evTarget&&k(this.target,this.evTarget,this.domHandler),this.evWin&&k(X(this.element),this.evWin,this.domHandler)}};function Ze(H){var Y,pe=H.options.inputClass;return pe?Y=pe:ge?Y=Di:ae?Y=vt:te?Y=En:Y=Vl,new Y(H,yt)}function yt(H,Y,pe){var Re=pe.pointers.length,at=pe.changedPointers.length,Vt=Y&Oe&&Re-at===0,$n=Y&(We|dt)&&Re-at===0;pe.isFirst=!!Vt,pe.isFinal=!!$n,Vt&&(H.session={}),pe.eventType=Y,Ct(H,pe),H.emit("hammer.input",pe),H.recognize(pe),H.session.prevInput=pe}function Ct(H,Y){var pe=H.session,Re=Y.pointers,at=Re.length;pe.firstInput||(pe.firstInput=nt(Y)),at>1&&!pe.firstMultiple?pe.firstMultiple=nt(Y):at===1&&(pe.firstMultiple=!1);var Vt=pe.firstInput,$n=pe.firstMultiple,Rs=$n?$n.center:Vt.center,Us=Y.center=St(Re);Y.timeStamp=u(),Y.deltaTime=Y.timeStamp-Vt.timeStamp,Y.angle=Cr(Rs,Us),Y.distance=Mn(Rs,Us),ft(pe,Y),Y.offsetDirection=Gt(Y.deltaX,Y.deltaY);var pi=gt(Y.deltaTime,Y.deltaX,Y.deltaY);Y.overallVelocityX=pi.x,Y.overallVelocityY=pi.y,Y.overallVelocity=c(pi.x)>c(pi.y)?pi.x:pi.y,Y.scale=$n?As($n.pointers,Re):1,Y.rotation=$n?Bs($n.pointers,Re):0,Y.maxPointers=pe.prevInput?Y.pointers.length>pe.prevInput.maxPointers?Y.pointers.length:pe.prevInput.maxPointers:Y.pointers.length,ce(pe,Y);var Ma=H.element;A(Y.srcEvent.target,Ma)&&(Ma=Y.srcEvent.target),Y.target=Ma}function ft(H,Y){var pe=Y.center,Re=H.offsetDelta||{},at=H.prevDelta||{},Vt=H.prevInput||{};(Y.eventType===Oe||Vt.eventType===We)&&(at=H.prevDelta={x:Vt.deltaX||0,y:Vt.deltaY||0},Re=H.offsetDelta={x:pe.x,y:pe.y}),Y.deltaX=at.x+(pe.x-Re.x),Y.deltaY=at.y+(pe.y-Re.y)}function ce(H,Y){var pe=H.lastInterval||Y,Re=Y.timeStamp-pe.timeStamp,at,Vt,$n,Rs;if(Y.eventType!=dt&&(Re>Xe||pe.velocity===s)){var Us=Y.deltaX-pe.deltaX,pi=Y.deltaY-pe.deltaY,Ma=gt(Re,Us,pi);Vt=Ma.x,$n=Ma.y,at=c(Ma.x)>c(Ma.y)?Ma.x:Ma.y,Rs=Gt(Us,pi),H.lastInterval=Y}else at=pe.velocity,Vt=pe.velocityX,$n=pe.velocityY,Rs=pe.direction;Y.velocity=at,Y.velocityX=Vt,Y.velocityY=$n,Y.direction=Rs}function nt(H){for(var Y=[],pe=0;pe<H.pointers.length;)Y[pe]={clientX:l(H.pointers[pe].clientX),clientY:l(H.pointers[pe].clientY)},pe++;return{timeStamp:u(),pointers:Y,center:St(Y),deltaX:H.deltaX,deltaY:H.deltaY}}function St(H){var Y=H.length;if(Y===1)return{x:l(H[0].clientX),y:l(H[0].clientY)};for(var pe=0,Re=0,at=0;at<Y;)pe+=H[at].clientX,Re+=H[at].clientY,at++;return{x:l(pe/Y),y:l(Re/Y)}}function gt(H,Y,pe){return{x:Y/H||0,y:pe/H||0}}function Gt(H,Y){return H===Y?ct:c(H)>=c(Y)?H<0?Ve:ze:Y<0?Be:ut}function Mn(H,Y,pe){pe||(pe=rt);var Re=Y[pe[0]]-H[pe[0]],at=Y[pe[1]]-H[pe[1]];return Math.sqrt(Re*Re+at*at)}function Cr(H,Y,pe){pe||(pe=rt);var Re=Y[pe[0]]-H[pe[0]],at=Y[pe[1]]-H[pe[1]];return Math.atan2(at,Re)*180/Math.PI}function Bs(H,Y){return Cr(Y[1],Y[0],Ge)+Cr(H[1],H[0],Ge)}function As(H,Y){return Mn(Y[0],Y[1],Ge)/Mn(H[0],H[1],Ge)}var Ms={mousedown:Oe,mousemove:it,mouseup:We},Oh="mousedown",Bl="mousemove mouseup";function Vl(){this.evEl=Oh,this.evWin=Bl,this.pressed=!1,ye.apply(this,arguments)}b(Vl,ye,{handler:function(Y){var pe=Ms[Y.type];pe&Oe&&Y.button===0&&(this.pressed=!0),pe&it&&Y.which!==1&&(pe=We),this.pressed&&(pe&We&&(this.pressed=!1),this.callback(this.manager,pe,{pointers:[Y],changedPointers:[Y],pointerType:De,srcEvent:Y}))}});var go={pointerdown:Oe,pointermove:it,pointerup:We,pointercancel:dt,pointerout:dt},Ul={2:Ne,3:ke,4:De,5:be},Fc="pointerdown",Lc="pointermove pointerup pointercancel";e.MSPointerEvent&&!e.PointerEvent&&(Fc="MSPointerDown",Lc="MSPointerMove MSPointerUp MSPointerCancel");function Di(){this.evEl=Fc,this.evWin=Lc,ye.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}b(Di,ye,{handler:function(Y){var pe=this.store,Re=!1,at=Y.type.toLowerCase().replace("ms",""),Vt=go[at],$n=Ul[Y.pointerType]||Y.pointerType,Rs=$n==Ne,Us=N(pe,Y.pointerId,"pointerId");Vt&Oe&&(Y.button===0||Rs)?Us<0&&(pe.push(Y),Us=pe.length-1):Vt&(We|dt)&&(Re=!0),!(Us<0)&&(pe[Us]=Y,this.callback(this.manager,Vt,{pointers:pe,changedPointers:[Y],pointerType:$n,srcEvent:Y}),Re&&pe.splice(Us,1))}});var Fh={touchstart:Oe,touchmove:it,touchend:We,touchcancel:dt},rl="touchstart",Lh="touchstart touchmove touchend touchcancel";function re(){this.evTarget=rl,this.evWin=Lh,this.started=!1,ye.apply(this,arguments)}b(re,ye,{handler:function(Y){var pe=Fh[Y.type];if(pe===Oe&&(this.started=!0),!!this.started){var Re=Ue.call(this,Y,pe);pe&(We|dt)&&Re[0].length-Re[1].length===0&&(this.started=!1),this.callback(this.manager,pe,{pointers:Re[0],changedPointers:Re[1],pointerType:Ne,srcEvent:Y})}}});function Ue(H,Y){var pe=O(H.touches),Re=O(H.changedTouches);return Y&(We|dt)&&(pe=R(pe.concat(Re),"identifier",!0)),[pe,Re]}var Fe={touchstart:Oe,touchmove:it,touchend:We,touchcancel:dt},Je="touchstart touchmove touchend touchcancel";function vt(){this.evTarget=Je,this.targetIds={},ye.apply(this,arguments)}b(vt,ye,{handler:function(Y){var pe=Fe[Y.type],Re=zn.call(this,Y,pe);Re&&this.callback(this.manager,pe,{pointers:Re[0],changedPointers:Re[1],pointerType:Ne,srcEvent:Y})}});function zn(H,Y){var pe=O(H.touches),Re=this.targetIds;if(Y&(Oe|it)&&pe.length===1)return Re[pe[0].identifier]=!0,[pe,pe];var at,Vt,$n=O(H.changedTouches),Rs=[],Us=this.target;if(Vt=pe.filter(function(pi){return A(pi.target,Us)}),Y===Oe)for(at=0;at<Vt.length;)Re[Vt[at].identifier]=!0,at++;for(at=0;at<$n.length;)Re[$n[at].identifier]&&Rs.push($n[at]),Y&(We|dt)&&delete Re[$n[at].identifier],at++;if(Rs.length)return[R(Vt.concat(Rs),"identifier",!0),Rs]}var sn=2500,Tn=25;function En(){ye.apply(this,arguments);var H=x(this.handler,this);this.touch=new vt(this.manager,H),this.mouse=new Vl(this.manager,H),this.primaryTouch=null,this.lastTouches=[]}b(En,ye,{handler:function(Y,pe,Re){var at=Re.pointerType==Ne,Vt=Re.pointerType==De;if(!(Vt&&Re.sourceCapabilities&&Re.sourceCapabilities.firesTouchEvents)){if(at)Nn.call(this,pe,Re);else if(Vt&&_n.call(this,Re))return;this.callback(Y,pe,Re)}},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});function Nn(H,Y){H&Oe?(this.primaryTouch=Y.changedPointers[0].identifier,er.call(this,Y)):H&(We|dt)&&er.call(this,Y)}function er(H){var Y=H.changedPointers[0];if(Y.identifier===this.primaryTouch){var pe={x:Y.clientX,y:Y.clientY};this.lastTouches.push(pe);var Re=this.lastTouches,at=function(){var Vt=Re.indexOf(pe);Vt>-1&&Re.splice(Vt,1)};setTimeout(at,sn)}}function _n(H){for(var Y=H.srcEvent.clientX,pe=H.srcEvent.clientY,Re=0;Re<this.lastTouches.length;Re++){var at=this.lastTouches[Re],Vt=Math.abs(Y-at.x),$n=Math.abs(pe-at.y);if(Vt<=Tn&&$n<=Tn)return!0}return!1}var ur=D(o.style,"touchAction"),Oi=ur!==s,xr="compute",Zi="auto",Ar="manipulation",Io="none",rs="pan-x",yo="pan-y",Ao=zh();function Ns(H,Y){this.manager=H,this.set(Y)}Ns.prototype={set:function(H){H==xr&&(H=this.compute()),Oi&&this.manager.element.style&&Ao[H]&&(this.manager.element.style[ur]=H),this.actions=H.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var H=[];return d(this.manager.recognizers,function(Y){w(Y.options.enable,[Y])&&(H=H.concat(Y.getTouchAction()))}),bo(H.join(" "))},preventDefaults:function(H){var Y=H.srcEvent,pe=H.offsetDirection;if(this.manager.session.prevented){Y.preventDefault();return}var Re=this.actions,at=M(Re,Io)&&!Ao[Io],Vt=M(Re,yo)&&!Ao[yo],$n=M(Re,rs)&&!Ao[rs];if(at){var Rs=H.pointers.length===1,Us=H.distance<2,pi=H.deltaTime<250;if(Rs&&Us&&pi)return}if(!($n&&Vt)&&(at||Vt&&pe&Ke||$n&&pe&ee))return this.preventSrc(Y)},preventSrc:function(H){this.manager.session.prevented=!0,H.preventDefault()}};function bo(H){if(M(H,Io))return Io;var Y=M(H,rs),pe=M(H,yo);return Y&&pe?Io:Y||pe?Y?rs:yo:M(H,Ar)?Ar:Zi}function zh(){if(!Oi)return!1;var H={},Y=e.CSS&&e.CSS.supports;return["auto","manipulation","pan-y","pan-x","pan-x pan-y","none"].forEach(function(pe){H[pe]=Y?e.CSS.supports("touch-action",pe):!0}),H}var sl=1,Ji=2,zc=4,Aa=8,$s=Aa,Bc=16,Qi=32;function Vs(H){this.options=m({},this.defaults,H||{}),this.id=B(),this.manager=null,this.options.enable=S(this.options.enable,!0),this.state=sl,this.simultaneous={},this.requireFail=[]}Vs.prototype={defaults:{},set:function(H){return m(this.options,H),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(H){if(f(H,"recognizeWith",this))return this;var Y=this.simultaneous;return H=Vh(H,this),Y[H.id]||(Y[H.id]=H,H.recognizeWith(this)),this},dropRecognizeWith:function(H){return f(H,"dropRecognizeWith",this)?this:(H=Vh(H,this),delete this.simultaneous[H.id],this)},requireFailure:function(H){if(f(H,"requireFailure",this))return this;var Y=this.requireFail;return H=Vh(H,this),N(Y,H)===-1&&(Y.push(H),H.requireFailure(this)),this},dropRequireFailure:function(H){if(f(H,"dropRequireFailure",this))return this;H=Vh(H,this);var Y=N(this.requireFail,H);return Y>-1&&this.requireFail.splice(Y,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(H){return!!this.simultaneous[H.id]},emit:function(H){var Y=this,pe=this.state;function Re(at){Y.manager.emit(at,H)}pe<Aa&&Re(Y.options.event+Bh(pe)),Re(Y.options.event),H.additionalEvent&&Re(H.additionalEvent),pe>=Aa&&Re(Y.options.event+Bh(pe))},tryEmit:function(H){if(this.canEmit())return this.emit(H);this.state=Qi},canEmit:function(){for(var H=0;H<this.requireFail.length;){if(!(this.requireFail[H].state&(Qi|sl)))return!1;H++}return!0},recognize:function(H){var Y=m({},H);if(!w(this.options.enable,[this,Y])){this.reset(),this.state=Qi;return}this.state&($s|Bc|Qi)&&(this.state=sl),this.state=this.process(Y),this.state&(Ji|zc|Aa|Bc)&&this.tryEmit(Y)},process:function(H){},getTouchAction:function(){},reset:function(){}};function Bh(H){return H&Bc?"cancel":H&Aa?"end":H&zc?"move":H&Ji?"start":""}function o0(H){return H==ut?"down":H==Be?"up":H==Ve?"left":H==ze?"right":""}function Vh(H,Y){var pe=Y.manager;return pe?pe.get(H):H}function eo(){Vs.apply(this,arguments)}b(eo,Vs,{defaults:{pointers:1},attrTest:function(H){var Y=this.options.pointers;return Y===0||H.pointers.length===Y},process:function(H){var Y=this.state,pe=H.eventType,Re=Y&(Ji|zc),at=this.attrTest(H);return Re&&(pe&dt||!at)?Y|Bc:Re||at?pe&We?Y|Aa:Y&Ji?Y|zc:Ji:Qi}});function Uh(){eo.apply(this,arguments),this.pX=null,this.pY=null}b(Uh,eo,{defaults:{event:"pan",threshold:10,pointers:1,direction:J},getTouchAction:function(){var H=this.options.direction,Y=[];return H&Ke&&Y.push(yo),H&ee&&Y.push(rs),Y},directionTest:function(H){var Y=this.options,pe=!0,Re=H.distance,at=H.direction,Vt=H.deltaX,$n=H.deltaY;return at&Y.direction||(Y.direction&Ke?(at=Vt===0?ct:Vt<0?Ve:ze,pe=Vt!=this.pX,Re=Math.abs(H.deltaX)):(at=$n===0?ct:$n<0?Be:ut,pe=$n!=this.pY,Re=Math.abs(H.deltaY))),H.direction=at,pe&&Re>Y.threshold&&at&Y.direction},attrTest:function(H){return eo.prototype.attrTest.call(this,H)&&(this.state&Ji||!(this.state&Ji)&&this.directionTest(H))},emit:function(H){this.pX=H.deltaX,this.pY=H.deltaY;var Y=o0(H.direction);Y&&(H.additionalEvent=this.options.event+Y),this._super.emit.call(this,H)}});function Jf(){eo.apply(this,arguments)}b(Jf,eo,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[Io]},attrTest:function(H){return this._super.attrTest.call(this,H)&&(Math.abs(H.scale-1)>this.options.threshold||this.state&Ji)},emit:function(H){if(H.scale!==1){var Y=H.scale<1?"in":"out";H.additionalEvent=this.options.event+Y}this._super.emit.call(this,H)}});function Hu(){Vs.apply(this,arguments),this._timer=null,this._input=null}b(Hu,Vs,{defaults:{event:"press",pointers:1,time:251,threshold:9},getTouchAction:function(){return[Zi]},process:function(H){var Y=this.options,pe=H.pointers.length===Y.pointers,Re=H.distance<Y.threshold,at=H.deltaTime>Y.time;if(this._input=H,!Re||!pe||H.eventType&(We|dt)&&!at)this.reset();else if(H.eventType&Oe)this.reset(),this._timer=h(function(){this.state=$s,this.tryEmit()},Y.time,this);else if(H.eventType&We)return $s;return Qi},reset:function(){clearTimeout(this._timer)},emit:function(H){this.state===$s&&(H&&H.eventType&We?this.manager.emit(this.options.event+"up",H):(this._input.timeStamp=u(),this.manager.emit(this.options.event,this._input)))}});function Qf(){eo.apply(this,arguments)}b(Qf,eo,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[Io]},attrTest:function(H){return this._super.attrTest.call(this,H)&&(Math.abs(H.rotation)>this.options.threshold||this.state&Ji)}});function Wh(){eo.apply(this,arguments)}b(Wh,eo,{defaults:{event:"swipe",threshold:10,velocity:.3,direction:Ke|ee,pointers:1},getTouchAction:function(){return Uh.prototype.getTouchAction.call(this)},attrTest:function(H){var Y=this.options.direction,pe;return Y&(Ke|ee)?pe=H.overallVelocity:Y&Ke?pe=H.overallVelocityX:Y&ee&&(pe=H.overallVelocityY),this._super.attrTest.call(this,H)&&Y&H.offsetDirection&&H.distance>this.options.threshold&&H.maxPointers==this.options.pointers&&c(pe)>this.options.velocity&&H.eventType&We},emit:function(H){var Y=o0(H.offsetDirection);Y&&this.manager.emit(this.options.event+Y,H),this.manager.emit(this.options.event,H)}});function Wl(){Vs.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}b(Wl,Vs,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:9,posThreshold:10},getTouchAction:function(){return[Ar]},process:function(H){var Y=this.options,pe=H.pointers.length===Y.pointers,Re=H.distance<Y.threshold,at=H.deltaTime<Y.time;if(this.reset(),H.eventType&Oe&&this.count===0)return this.failTimeout();if(Re&&at&&pe){if(H.eventType!=We)return this.failTimeout();var Vt=this.pTime?H.timeStamp-this.pTime<Y.interval:!0,$n=!this.pCenter||Mn(this.pCenter,H.center)<Y.posThreshold;this.pTime=H.timeStamp,this.pCenter=H.center,!$n||!Vt?this.count=1:this.count+=1,this._input=H;var Rs=this.count%Y.taps;if(Rs===0)return this.hasRequireFailures()?(this._timer=h(function(){this.state=$s,this.tryEmit()},Y.interval,this),Ji):$s}return Qi},failTimeout:function(){return this._timer=h(function(){this.state=Qi},this.options.interval,this),Qi},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==$s&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}});function Zr(H,Y){return Y=Y||{},Y.recognizers=S(Y.recognizers,Zr.defaults.preset),new Vc(H,Y)}Zr.VERSION="2.0.7",Zr.defaults={domEvents:!1,touchAction:xr,enable:!0,inputTarget:null,inputClass:null,preset:[[Qf,{enable:!1}],[Jf,{enable:!1},["rotate"]],[Wh,{direction:Ke}],[Uh,{direction:Ke},["swipe"]],[Wl],[Wl,{event:"doubletap",taps:2},["tap"]],[Hu]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var a0=1,ed=2;function Vc(H,Y){this.options=m({},Zr.defaults,Y||{}),this.options.inputTarget=this.options.inputTarget||H,this.handlers={},this.session={},this.recognizers=[],this.oldCssProps={},this.element=H,this.input=Ze(this),this.touchAction=new Ns(this,this.options.touchAction),Gh(this,!0),d(this.options.recognizers,function(pe){var Re=this.add(new pe[0](pe[1]));pe[2]&&Re.recognizeWith(pe[2]),pe[3]&&Re.requireFailure(pe[3])},this)}Vc.prototype={set:function(H){return m(this.options,H),H.touchAction&&this.touchAction.update(),H.inputTarget&&(this.input.destroy(),this.input.target=H.inputTarget,this.input.init()),this},stop:function(H){this.session.stopped=H?ed:a0},recognize:function(H){var Y=this.session;if(!Y.stopped){this.touchAction.preventDefaults(H);var pe,Re=this.recognizers,at=Y.curRecognizer;(!at||at&&at.state&$s)&&(at=Y.curRecognizer=null);for(var Vt=0;Vt<Re.length;)pe=Re[Vt],Y.stopped!==ed&&(!at||pe==at||pe.canRecognizeWith(at))?pe.recognize(H):pe.reset(),!at&&pe.state&(Ji|zc|Aa)&&(at=Y.curRecognizer=pe),Vt++}},get:function(H){if(H instanceof Vs)return H;for(var Y=this.recognizers,pe=0;pe<Y.length;pe++)if(Y[pe].options.event==H)return Y[pe];return null},add:function(H){if(f(H,"add",this))return this;var Y=this.get(H.options.event);return Y&&this.remove(Y),this.recognizers.push(H),H.manager=this,this.touchAction.update(),H},remove:function(H){if(f(H,"remove",this))return this;if(H=this.get(H),H){var Y=this.recognizers,pe=N(Y,H);pe!==-1&&(Y.splice(pe,1),this.touchAction.update())}return this},on:function(H,Y){if(H!==s&&Y!==s){var pe=this.handlers;return d(E(H),function(Re){pe[Re]=pe[Re]||[],pe[Re].push(Y)}),this}},off:function(H,Y){if(H!==s){var pe=this.handlers;return d(E(H),function(Re){Y?pe[Re]&&pe[Re].splice(N(pe[Re],Y),1):delete pe[Re]}),this}},emit:function(H,Y){this.options.domEvents&&l0(H,Y);var pe=this.handlers[H]&&this.handlers[H].slice();if(!(!pe||!pe.length)){Y.type=H,Y.preventDefault=function(){Y.srcEvent.preventDefault()};for(var Re=0;Re<pe.length;)pe[Re](Y),Re++}},destroy:function(){this.element&&Gh(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}};function Gh(H,Y){var pe=H.element;if(pe.style){var Re;d(H.options.cssProps,function(at,Vt){Re=D(pe.style,Vt),Y?(H.oldCssProps[Re]=pe.style[Re],pe.style[Re]=at):pe.style[Re]=H.oldCssProps[Re]||""}),Y||(H.oldCssProps={})}}function l0(H,Y){var pe=t.createEvent("Event");pe.initEvent(H,!0,!0),pe.gesture=Y,Y.target.dispatchEvent(pe)}m(Zr,{INPUT_START:Oe,INPUT_MOVE:it,INPUT_END:We,INPUT_CANCEL:dt,STATE_POSSIBLE:sl,STATE_BEGAN:Ji,STATE_CHANGED:zc,STATE_ENDED:Aa,STATE_RECOGNIZED:$s,STATE_CANCELLED:Bc,STATE_FAILED:Qi,DIRECTION_NONE:ct,DIRECTION_LEFT:Ve,DIRECTION_RIGHT:ze,DIRECTION_UP:Be,DIRECTION_DOWN:ut,DIRECTION_HORIZONTAL:Ke,DIRECTION_VERTICAL:ee,DIRECTION_ALL:J,Manager:Vc,Input:ye,TouchAction:Ns,TouchInput:vt,MouseInput:Vl,PointerEventInput:Di,TouchMouseInput:En,SingleTouchInput:re,Recognizer:Vs,AttrRecognizer:eo,Tap:Wl,Pan:Uh,Swipe:Wh,Pinch:Jf,Rotate:Qf,Press:Hu,on:C,off:k,each:d,merge:y,extend:g,assign:m,inherit:b,bindFn:x,prefixed:D});var c0=typeof e<"u"?e:typeof self<"u"?self:{};c0.Hammer=Zr,typeof s=="function"&&s.amd?s(function(){return Zr}):n.exports?n.exports=Zr:e[r]=Zr})(window,document,"Hammer")})(Rut);var noe={exports:{}};(function(n){(function(e){var t=e.URL||e.webkitURL;function r(c){return t?t.createObjectURL(c):!1}function s(c){return t?t.revokeObjectURL(c):!1}function i(c,u){c&&c.slice(0,5)==="blob:"&&!(u&&u.noRevoke)&&s(c)}function o(c,u,h,f){if(!e.FileReader)return!1;var d=new FileReader;d.onload=function(){u.call(d,this.result)},h&&(d.onabort=d.onerror=function(){h.call(d,this.error)});var p=d[f||"readAsDataURL"];if(p)return p.call(d,c),d}function a(c,u){return Object.prototype.toString.call(u)==="[object "+c+"]"}function l(c,u,h){function f(d,p){var m=document.createElement("img"),g;function y(x,w){if(d===p){d&&d(x,w);return}else if(x instanceof Error){p(x);return}w=w||{},w.image=x,d(w)}function b(x,w){w&&e.console&&console.log(w),x&&a("Blob",x)?(c=x,g=r(c)):(g=c,h&&h.crossOrigin&&(m.crossOrigin=h.crossOrigin)),m.src=g}if(m.onerror=function(x){i(g,h),p&&p.call(m,x)},m.onload=function(){i(g,h);var x={originalWidth:m.naturalWidth||m.width,originalHeight:m.naturalHeight||m.height};try{l.transform(m,h,y,c,x)}catch(w){p&&p(w)}},typeof c=="string")return l.requiresMetaData(h)?l.fetchBlob(c,b,h):b(),m;if(a("Blob",c)||a("File",c))return g=r(c),g?(m.src=g,m):o(c,function(x){m.src=x},p)}return e.Promise&&typeof u!="function"?(h=u,new Promise(f)):f(u,u)}l.requiresMetaData=function(c){return c&&c.meta},l.fetchBlob=function(c,u){u()},l.transform=function(c,u,h,f,d){h(c,d)},l.global=e,l.readFile=o,l.isInstanceOf=a,l.createObjectURL=r,l.revokeObjectURL=s,n.exports?n.exports=l:e.loadImage=l})(typeof window<"u"&&window||pt)})(noe);var jf=noe.exports,roe={exports:{}};(function(n){(function(e){n.exports?e(jf):e(window.loadImage)})(function(e){var t=e.transform;e.createCanvas=function(r,s,i){if(i&&e.global.OffscreenCanvas)return new OffscreenCanvas(r,s);var o=document.createElement("canvas");return o.width=r,o.height=s,o},e.transform=function(r,s,i,o,a){t.call(e,e.scale(r,s,a),s,i,o,a)},e.transformCoordinates=function(){},e.getTransformedOptions=function(r,s){var i=s.aspectRatio,o,a,l,c;if(!i)return s;o={};for(a in s)Object.prototype.hasOwnProperty.call(s,a)&&(o[a]=s[a]);return o.crop=!0,l=r.naturalWidth||r.width,c=r.naturalHeight||r.height,l/c>i?(o.maxWidth=c*i,o.maxHeight=c):(o.maxWidth=l,o.maxHeight=l/i),o},e.drawImage=function(r,s,i,o,a,l,c,u,h){var f=s.getContext("2d");return h.imageSmoothingEnabled===!1?(f.msImageSmoothingEnabled=!1,f.imageSmoothingEnabled=!1):h.imageSmoothingQuality&&(f.imageSmoothingQuality=h.imageSmoothingQuality),f.drawImage(r,i,o,a,l,0,0,c,u),f},e.requiresCanvas=function(r){return r.canvas||r.crop||!!r.aspectRatio},e.scale=function(r,s,i){s=s||{},i=i||{};var o=r.getContext||e.requiresCanvas(s)&&!!e.global.HTMLCanvasElement,a=r.naturalWidth||r.width,l=r.naturalHeight||r.height,c=a,u=l,h,f,d,p,m,g,y,b,x,w,S,C;function k(){var M=Math.max((d||c)/c,(p||u)/u);M>1&&(c*=M,u*=M)}function A(){var M=Math.min((h||c)/c,(f||u)/u);M<1&&(c*=M,u*=M)}if(o&&(s=e.getTransformedOptions(r,s,i),y=s.left||0,b=s.top||0,s.sourceWidth?(m=s.sourceWidth,s.right!==void 0&&s.left===void 0&&(y=a-m-s.right)):m=a-y-(s.right||0),s.sourceHeight?(g=s.sourceHeight,s.bottom!==void 0&&s.top===void 0&&(b=l-g-s.bottom)):g=l-b-(s.bottom||0),c=m,u=g),h=s.maxWidth,f=s.maxHeight,d=s.minWidth,p=s.minHeight,o&&h&&f&&s.crop?(c=h,u=f,S=m/g-h/f,S<0?(g=f*m/h,s.top===void 0&&s.bottom===void 0&&(b=(l-g)/2)):S>0&&(m=h*g/f,s.left===void 0&&s.right===void 0&&(y=(a-m)/2))):((s.contain||s.cover)&&(d=h=h||d,p=f=f||p),s.cover?(A(),k()):(k(),A())),o){if(x=s.pixelRatio,x>1&&!(r.style.width&&Math.floor(parseFloat(r.style.width,10))===Math.floor(a/x))&&(c*=x,u*=x),e.orientationCropBug&&!r.getContext&&(y||b||m!==a||g!==l)&&(S=r,r=e.createCanvas(a,l,!0),e.drawImage(S,r,0,0,a,l,a,l,s)),w=s.downsamplingRatio,w>0&&w<1&&c<m&&u<g)for(;m*w>c;)C=e.createCanvas(m*w,g*w,!0),e.drawImage(r,C,y,b,m,g,C.width,C.height,s),y=0,b=0,m=C.width,g=C.height,r=C;return C=e.createCanvas(c,u),e.transformCoordinates(C,s,i),x>1&&(C.style.width=C.width/x+"px"),e.drawImage(r,C,y,b,m,g,c,u,s).setTransform(1,0,0,1,0,0),C}return r.width=c,r.height=u,r}})})(roe);var Put=roe.exports,soe={exports:{}};(function(n){(function(e){n.exports?e(jf):e(window.loadImage)})(function(e){var t=e.global,r=e.transform,s=t.Blob&&(Blob.prototype.slice||Blob.prototype.webkitSlice||Blob.prototype.mozSlice),i=t.ArrayBuffer&&ArrayBuffer.prototype.slice||function(u,h){h=h||this.byteLength-u;var f=new Uint8Array(this,u,h),d=new Uint8Array(h);return d.set(f),d.buffer},o={jpeg:{65505:[],65517:[]}};function a(u,h,f,d){var p=this;function m(g,y){if(!(t.DataView&&s&&u&&u.size>=12&&u.type==="image/jpeg"))return g(d);var b=f.maxMetaDataSize||262144;e.readFile(s.call(u,0,b),function(x){var w=new DataView(x);if(w.getUint16(0)!==65496)return y(new Error("Invalid JPEG file: Missing JPEG marker."));for(var S=2,C=w.byteLength-4,k=S,A,M,E,N;S<C&&(A=w.getUint16(S),A>=65504&&A<=65519||A===65534);){if(M=w.getUint16(S+2)+2,S+M>w.byteLength){console.log("Invalid JPEG metadata: Invalid segment size.");break}if(E=o.jpeg[A],E&&!f.disableMetaDataParsers)for(N=0;N<E.length;N+=1)E[N].call(p,w,S,M,d,f);S+=M,k=S}!f.disableImageHead&&k>6&&(d.imageHead=i.call(x,0,k)),g(d)},y,"readAsArrayBuffer")||g(d)}return f=f||{},t.Promise&&typeof h!="function"?(f=h||{},d=f,new Promise(m)):(d=d||{},m(h,h))}function l(u,h,f){return!u||!h||!f?null:new Blob([f,s.call(u,h.byteLength)],{type:"image/jpeg"})}function c(u,h,f){var d={maxMetaDataSize:1024,disableMetaDataParsers:!0};if(!f&&t.Promise)return a(u,d).then(function(p){return l(u,p.imageHead,h)});a(u,function(p){f(l(u,p.imageHead,h))},d)}e.transform=function(u,h,f,d,p){e.requiresMetaData(h)?(p=p||{},a(d,function(m){m!==p&&(t.console&&console.log(m),m=p),r.call(e,u,h,f,d,m)},h,p)):r.apply(e,arguments)},e.blobSlice=s,e.bufferSlice=i,e.replaceHead=c,e.parseMetaData=a,e.metaDataParsers=o})})(soe);var W4=soe.exports,Dut={exports:{}};(function(n){(function(e){n.exports?e(jf):e(window.loadImage)})(function(e){var t=e.global;t.fetch&&t.Request&&t.Response&&t.Response.prototype.blob?e.fetchBlob=function(r,s,i){function o(a){return a.blob()}if(t.Promise&&typeof s!="function")return fetch(new Request(r,s)).then(o);fetch(new Request(r,i)).then(o).then(s).catch(function(a){s(null,a)})}:t.XMLHttpRequest&&new XMLHttpRequest().responseType===""&&(e.fetchBlob=function(r,s,i){function o(a,l){i=i||{};var c=new XMLHttpRequest;c.open(i.method||"GET",r),i.headers&&Object.keys(i.headers).forEach(function(u){c.setRequestHeader(u,i.headers[u])}),c.withCredentials=i.credentials==="include",c.responseType="blob",c.onload=function(){a(c.response)},c.onerror=c.onabort=c.ontimeout=function(u){a===l?l(null,u):l(u)},c.send(i.body)}return t.Promise&&typeof s!="function"?(i=s,new Promise(o)):o(s,s)})})})(Dut);var ioe={exports:{}};(function(n){(function(e){n.exports?e(jf,W4):e(window.loadImage)})(function(e){function t(c){c&&(Object.defineProperty(this,"map",{value:this.ifds[c].map}),Object.defineProperty(this,"tags",{value:this.tags&&this.tags[c]||{}}))}t.prototype.map={Orientation:274,Thumbnail:"ifd1",Blob:513,Exif:34665,GPSInfo:34853,Interoperability:40965},t.prototype.ifds={ifd1:{name:"Thumbnail",map:t.prototype.map},34665:{name:"Exif",map:{}},34853:{name:"GPSInfo",map:{}},40965:{name:"Interoperability",map:{}}},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){if(h){if(u+h>c.byteLength){console.log("Invalid Exif data: Invalid thumbnail data.");return}return new Blob([e.bufferSlice.call(c.buffer,u,u+h)],{type:"image/jpeg"})}}var s={1:{getValue:function(c,u){return c.getUint8(u)},size:1},2:{getValue:function(c,u){return String.fromCharCode(c.getUint8(u))},size:1,ascii:!0},3:{getValue:function(c,u,h){return c.getUint16(u,h)},size:2},4:{getValue:function(c,u,h){return c.getUint32(u,h)},size:4},5:{getValue:function(c,u,h){return c.getUint32(u,h)/c.getUint32(u+4,h)},size:8},9:{getValue:function(c,u,h){return c.getInt32(u,h)},size:4},10:{getValue:function(c,u,h){return c.getInt32(u,h)/c.getInt32(u+4,h)},size:8}};s[7]=s[1];function i(c,u,h,f,d,p){var m=s[f],g,y,b,x,w,S;if(!m){console.log("Invalid Exif data: Invalid tag type.");return}if(g=m.size*d,y=g>4?u+c.getUint32(h+8,p):h+8,y+g>c.byteLength){console.log("Invalid Exif data: Invalid data offset.");return}if(d===1)return m.getValue(c,y,p);for(b=[],x=0;x<d;x+=1)b[x]=m.getValue(c,y+x*m.size,p);if(m.ascii){for(w="",x=0;x<b.length&&(S=b[x],S!=="\0");x+=1)w+=S;return w}return b}function o(c,u,h){return(!c||c[h])&&(!u||u[h]!==!0)}function a(c,u,h,f,d,p,m,g){var y,b,x,w,S,C;if(h+6>c.byteLength){console.log("Invalid Exif data: Invalid directory offset.");return}if(y=c.getUint16(h,f),b=h+2+12*y,b+4>c.byteLength){console.log("Invalid Exif data: Invalid directory size.");return}for(x=0;x<y;x+=1)w=h+2+12*x,S=c.getUint16(w,f),o(m,g,S)&&(C=i(c,u,w,c.getUint16(w+2,f),c.getUint32(w+4,f),f),d[S]=C,p&&(p[S]=w));return c.getUint32(b,f)}function l(c,u,h,f,d,p,m){var g=c.exif[u];g&&(c.exif[u]=new t(u),c.exifOffsets&&(c.exifOffsets[u]=new t(u)),a(h,f,f+g,d,c.exif[u],c.exifOffsets&&c.exifOffsets[u],p&&p[u],m&&m[u]))}e.parseExifData=function(c,u,h,f,d){if(!d.disableExif){var p=d.includeExifTags,m=d.excludeExifTags||{34665:{37500:!0}},g=u+10,y,b,x;if(c.getUint32(u+4)===1165519206){if(g+8>c.byteLength){console.log("Invalid Exif data: Invalid segment size.");return}if(c.getUint16(u+8)!==0){console.log("Invalid Exif data: Missing byte alignment offset.");return}switch(c.getUint16(g)){case 18761:y=!0;break;case 19789:y=!1;break;default:console.log("Invalid Exif data: Invalid byte alignment marker.");return}if(c.getUint16(g+2,y)!==42){console.log("Invalid Exif data: Missing TIFF marker.");return}b=c.getUint32(g+4,y),f.exif=new t,d.disableExifOffsets||(f.exifOffsets=new t,f.exifTiffOffset=g,f.exifLittleEndian=y),b=a(c,g,g+b,y,f.exif,f.exifOffsets,p,m),b&&o(p,m,"ifd1")&&(f.exif.ifd1=b,f.exifOffsets&&(f.exifOffsets.ifd1=g+b)),Object.keys(f.exif.ifds).forEach(function(w){l(f,w,c,g,y,p,m)}),x=f.exif.ifd1,x&&x[513]&&(x[513]=r(c,g+x[513],x[514]))}}},e.metaDataParsers.jpeg[65505].push(e.parseExifData),e.exifWriters={274:function(c,u,h){var f=u.exifOffsets[274];if(!f)return c;var d=new DataView(c,f+8,2);return d.setUint16(0,h,u.exifLittleEndian),c}},e.writeExifData=function(c,u,h,f){return e.exifWriters[u.exif.map[h]](c,u,f)},e.ExifMap=t})})(ioe);var Out=ioe.exports,Fut={exports:{}};(function(n){(function(e){n.exports?e(jf,Out):e(window.loadImage)})(function(e){var t=e.ExifMap.prototype;t.tags={256:"ImageWidth",257:"ImageHeight",258:"BitsPerSample",259:"Compression",262:"PhotometricInterpretation",274:"Orientation",277:"SamplesPerPixel",284:"PlanarConfiguration",530:"YCbCrSubSampling",531:"YCbCrPositioning",282:"XResolution",283:"YResolution",296:"ResolutionUnit",273:"StripOffsets",278:"RowsPerStrip",279:"StripByteCounts",513:"JPEGInterchangeFormat",514:"JPEGInterchangeFormatLength",301:"TransferFunction",318:"WhitePoint",319:"PrimaryChromaticities",529:"YCbCrCoefficients",532:"ReferenceBlackWhite",306:"DateTime",270:"ImageDescription",271:"Make",272:"Model",305:"Software",315:"Artist",33432:"Copyright",34665:{36864:"ExifVersion",40960:"FlashpixVersion",40961:"ColorSpace",40962:"PixelXDimension",40963:"PixelYDimension",42240:"Gamma",37121:"ComponentsConfiguration",37122:"CompressedBitsPerPixel",37500:"MakerNote",37510:"UserComment",40964:"RelatedSoundFile",36867:"DateTimeOriginal",36868:"DateTimeDigitized",36880:"OffsetTime",36881:"OffsetTimeOriginal",36882:"OffsetTimeDigitized",37520:"SubSecTime",37521:"SubSecTimeOriginal",37522:"SubSecTimeDigitized",33434:"ExposureTime",33437:"FNumber",34850:"ExposureProgram",34852:"SpectralSensitivity",34855:"PhotographicSensitivity",34856:"OECF",34864:"SensitivityType",34865:"StandardOutputSensitivity",34866:"RecommendedExposureIndex",34867:"ISOSpeed",34868:"ISOSpeedLatitudeyyy",34869:"ISOSpeedLatitudezzz",37377:"ShutterSpeedValue",37378:"ApertureValue",37379:"BrightnessValue",37380:"ExposureBias",37381:"MaxApertureValue",37382:"SubjectDistance",37383:"MeteringMode",37384:"LightSource",37385:"Flash",37396:"SubjectArea",37386:"FocalLength",41483:"FlashEnergy",41484:"SpatialFrequencyResponse",41486:"FocalPlaneXResolution",41487:"FocalPlaneYResolution",41488:"FocalPlaneResolutionUnit",41492:"SubjectLocation",41493:"ExposureIndex",41495:"SensingMethod",41728:"FileSource",41729:"SceneType",41730:"CFAPattern",41985:"CustomRendered",41986:"ExposureMode",41987:"WhiteBalance",41988:"DigitalZoomRatio",41989:"FocalLengthIn35mmFilm",41990:"SceneCaptureType",41991:"GainControl",41992:"Contrast",41993:"Saturation",41994:"Sharpness",41995:"DeviceSettingDescription",41996:"SubjectDistanceRange",42016:"ImageUniqueID",42032:"CameraOwnerName",42033:"BodySerialNumber",42034:"LensSpecification",42035:"LensMake",42036:"LensModel",42037:"LensSerialNumber"},34853:{0:"GPSVersionID",1:"GPSLatitudeRef",2:"GPSLatitude",3:"GPSLongitudeRef",4:"GPSLongitude",5:"GPSAltitudeRef",6:"GPSAltitude",7:"GPSTimeStamp",8:"GPSSatellites",9:"GPSStatus",10:"GPSMeasureMode",11:"GPSDOP",12:"GPSSpeedRef",13:"GPSSpeed",14:"GPSTrackRef",15:"GPSTrack",16:"GPSImgDirectionRef",17:"GPSImgDirection",18:"GPSMapDatum",19:"GPSDestLatitudeRef",20:"GPSDestLatitude",21:"GPSDestLongitudeRef",22:"GPSDestLongitude",23:"GPSDestBearingRef",24:"GPSDestBearing",25:"GPSDestDistanceRef",26:"GPSDestDistance",27:"GPSProcessingMethod",28:"GPSAreaInformation",29:"GPSDateStamp",30:"GPSDifferential",31:"GPSHPositioningError"},40965:{1:"InteroperabilityIndex"}},t.tags.ifd1=t.tags,t.stringValues={ExposureProgram:{0:"Undefined",1:"Manual",2:"Normal program",3:"Aperture priority",4:"Shutter priority",5:"Creative program",6:"Action program",7:"Portrait mode",8:"Landscape mode"},MeteringMode:{0:"Unknown",1:"Average",2:"CenterWeightedAverage",3:"Spot",4:"MultiSpot",5:"Pattern",6:"Partial",255:"Other"},LightSource:{0:"Unknown",1:"Daylight",2:"Fluorescent",3:"Tungsten (incandescent light)",4:"Flash",9:"Fine weather",10:"Cloudy weather",11:"Shade",12:"Daylight fluorescent (D 5700 - 7100K)",13:"Day white fluorescent (N 4600 - 5400K)",14:"Cool white fluorescent (W 3900 - 4500K)",15:"White fluorescent (WW 3200 - 3700K)",17:"Standard light A",18:"Standard light B",19:"Standard light C",20:"D55",21:"D65",22:"D75",23:"D50",24:"ISO studio tungsten",255:"Other"},Flash:{0:"Flash did not fire",1:"Flash fired",5:"Strobe return light not detected",7:"Strobe return light detected",9:"Flash fired, compulsory flash mode",13:"Flash fired, compulsory flash mode, return light not detected",15:"Flash fired, compulsory flash mode, return light detected",16:"Flash did not fire, compulsory flash mode",24:"Flash did not fire, auto mode",25:"Flash fired, auto mode",29:"Flash fired, auto mode, return light not detected",31:"Flash fired, auto mode, return light detected",32:"No flash function",65:"Flash fired, red-eye reduction mode",69:"Flash fired, red-eye reduction mode, return light not detected",71:"Flash fired, red-eye reduction mode, return light detected",73:"Flash fired, compulsory flash mode, red-eye reduction mode",77:"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected",79:"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected",89:"Flash fired, auto mode, red-eye reduction mode",93:"Flash fired, auto mode, return light not detected, red-eye reduction mode",95:"Flash fired, auto mode, return light detected, red-eye reduction mode"},SensingMethod:{1:"Undefined",2:"One-chip color area sensor",3:"Two-chip color area sensor",4:"Three-chip color area sensor",5:"Color sequential area sensor",7:"Trilinear sensor",8:"Color sequential linear sensor"},SceneCaptureType:{0:"Standard",1:"Landscape",2:"Portrait",3:"Night scene"},SceneType:{1:"Directly photographed"},CustomRendered:{0:"Normal process",1:"Custom process"},WhiteBalance:{0:"Auto white balance",1:"Manual white balance"},GainControl:{0:"None",1:"Low gain up",2:"High gain up",3:"Low gain down",4:"High gain down"},Contrast:{0:"Normal",1:"Soft",2:"Hard"},Saturation:{0:"Normal",1:"Low saturation",2:"High saturation"},Sharpness:{0:"Normal",1:"Soft",2:"Hard"},SubjectDistanceRange:{0:"Unknown",1:"Macro",2:"Close view",3:"Distant view"},FileSource:{3:"DSC"},ComponentsConfiguration:{0:"",1:"Y",2:"Cb",3:"Cr",4:"R",5:"G",6:"B"},Orientation:{1:"Original",2:"Horizontal flip",3:"Rotate 180° CCW",4:"Vertical flip",5:"Vertical flip + Rotate 90° CW",6:"Rotate 90° CW",7:"Horizontal flip + Rotate 90° CW",8:"Rotate 90° CCW"}},t.getText=function(r){var s=this.get(r);switch(r){case"LightSource":case"Flash":case"MeteringMode":case"ExposureProgram":case"SensingMethod":case"SceneCaptureType":case"SceneType":case"CustomRendered":case"WhiteBalance":case"GainControl":case"Contrast":case"Saturation":case"Sharpness":case"SubjectDistanceRange":case"FileSource":case"Orientation":return this.stringValues[r][s];case"ExifVersion":case"FlashpixVersion":return s?String.fromCharCode(s[0],s[1],s[2],s[3]):void 0;case"ComponentsConfiguration":return s?this.stringValues[r][s[0]]+this.stringValues[r][s[1]]+this.stringValues[r][s[2]]+this.stringValues[r][s[3]]:void 0;case"GPSVersionID":return s?s[0]+"."+s[1]+"."+s[2]+"."+s[3]:void 0}return String(s)},t.getAll=function(){var r={},s,i,o;for(s in this)Object.prototype.hasOwnProperty.call(this,s)&&(i=this[s],i&&i.getAll?r[this.ifds[s].name]=i.getAll():(o=this.tags[s],o&&(r[o]=this.getText(o))));return r},t.getName=function(r){var s=this.tags[r];return typeof s=="object"?this.ifds[r].name:s},function(){var r=t.tags,s,i,o;for(s in r)if(Object.prototype.hasOwnProperty.call(r,s))if(i=t.ifds[s],i){o=r[s];for(s in o)Object.prototype.hasOwnProperty.call(o,s)&&(i.map[o[s]]=Number(s))}else t.map[r[s]]=Number(s)}()})})(Fut);var ooe={exports:{}};(function(n){(function(e){n.exports?e(jf,W4):e(window.loadImage)})(function(e){function t(){}t.prototype.map={ObjectName:5},t.prototype.types={0:"Uint16",200:"Uint16",201:"Uint16",202:"binary"},t.prototype.get=function(c){return this[c]||this[this.map[c]]};function r(c,u,h){for(var f="",d=u+h,p=u;p<d;p+=1)f+=String.fromCharCode(c.getUint8(p));return f}function s(c,u,h,f,d){return u.types[c]==="binary"?new Blob([h.buffer.slice(f,f+d)]):u.types[c]==="Uint16"?h.getUint16(f):r(h,f,d)}function i(c,u){return c===void 0?u:c instanceof Array?(c.push(u),c):[c,u]}function o(c,u,h,f,d,p){for(var m,g,y,b=u+h,x=u;x<b;)c.getUint8(x)===28&&c.getUint8(x+1)===2&&(y=c.getUint8(x+2),(!d||d[y])&&(!p||!p[y])&&(g=c.getInt16(x+3),m=s(y,f.iptc,c,x+5,g),f.iptc[y]=i(f.iptc[y],m),f.iptcOffsets&&(f.iptcOffsets[y]=x))),x+=1}function a(c,u){return c.getUint32(u)===943868237&&c.getUint16(u+4)===1028}function l(c,u){var h=c.getUint8(u+7);return h%2!==0&&(h+=1),h===0&&(h=4),h}e.parseIptcData=function(c,u,h,f,d){if(!d.disableIptc)for(var p=u+h;u+8<p;){if(a(c,u)){var m=l(c,u),g=u+8+m;if(g>p){console.log("Invalid IPTC data: Invalid segment offset.");break}var y=c.getUint16(u+6+m);if(u+y>p){console.log("Invalid IPTC data: Invalid segment size.");break}f.iptc=new t,d.disableIptcOffsets||(f.iptcOffsets=new t),o(c,g,y,f,d.includeIptcTags,d.excludeIptcTags||{202:!0});return}u+=1}},e.metaDataParsers.jpeg[65517].push(e.parseIptcData),e.IptcMap=t})})(ooe);var Lut=ooe.exports,zut={exports:{}};(function(n){(function(e){n.exports?e(jf,Lut):e(window.loadImage)})(function(e){var t=e.IptcMap.prototype;t.tags={0:"ApplicationRecordVersion",3:"ObjectTypeReference",4:"ObjectAttributeReference",5:"ObjectName",7:"EditStatus",8:"EditorialUpdate",10:"Urgency",12:"SubjectReference",15:"Category",20:"SupplementalCategories",22:"FixtureIdentifier",25:"Keywords",26:"ContentLocationCode",27:"ContentLocationName",30:"ReleaseDate",35:"ReleaseTime",37:"ExpirationDate",38:"ExpirationTime",40:"SpecialInstructions",42:"ActionAdvised",45:"ReferenceService",47:"ReferenceDate",50:"ReferenceNumber",55:"DateCreated",60:"TimeCreated",62:"DigitalCreationDate",63:"DigitalCreationTime",65:"OriginatingProgram",70:"ProgramVersion",75:"ObjectCycle",80:"Byline",85:"BylineTitle",90:"City",92:"Sublocation",95:"State",100:"CountryCode",101:"Country",103:"OriginalTransmissionReference",105:"Headline",110:"Credit",115:"Source",116:"CopyrightNotice",118:"Contact",120:"Caption",121:"LocalCaption",122:"Writer",125:"RasterizedCaption",130:"ImageType",131:"ImageOrientation",135:"LanguageIdentifier",150:"AudioType",151:"AudioSamplingRate",152:"AudioSamplingResolution",153:"AudioDuration",154:"AudioOutcue",184:"JobID",185:"MasterDocumentID",186:"ShortDocumentID",187:"UniqueDocumentID",188:"OwnerID",200:"ObjectPreviewFileFormat",201:"ObjectPreviewFileVersion",202:"ObjectPreviewData",221:"Prefs",225:"ClassifyState",228:"SimilarityIndex",230:"DocumentNotes",231:"DocumentHistory",232:"ExifCameraInfo",255:"CatalogSets"},t.stringValues={10:{0:"0 (reserved)",1:"1 (most urgent)",2:"2",3:"3",4:"4",5:"5 (normal urgency)",6:"6",7:"7",8:"8 (least urgent)",9:"9 (user-defined priority)"},75:{a:"Morning",b:"Both Morning and Evening",p:"Evening"},131:{L:"Landscape",P:"Portrait",S:"Square"}},t.getText=function(r){var s=this.get(r),i=this.map[r],o=this.stringValues[i];return o?o[s]:String(s)},t.getAll=function(){var r={},s,i;for(s in this)Object.prototype.hasOwnProperty.call(this,s)&&(i=this.tags[s],i&&(r[i]=this.getText(i)));return r},t.getName=function(r){return this.tags[r]},function(){var r=t.tags,s=t.map||{},i;for(i in r)Object.prototype.hasOwnProperty.call(r,i)&&(s[r[i]]=Number(i))}()})})(zut);var But={exports:{}};(function(n){(function(e){n.exports?e(jf,Put,W4):e(window.loadImage)})(function(e){var t=e.transform,r=e.requiresCanvas,s=e.requiresMetaData,i=e.transformCoordinates,o=e.getTransformedOptions;(function(u){if(u.global.document){var h="data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/xABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAAAAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQvoP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXwH/9k=",f=document.createElement("img");f.onload=function(){if(u.orientation=f.width===2&&f.height===3,u.orientation){var d=u.createCanvas(1,1,!0),p=d.getContext("2d");p.drawImage(f,1,1,1,1,0,0,1,1),u.orientationCropBug=p.getImageData(0,0,1,1).data.toString()!=="255,255,255,255"}},f.src=h}})(e);function a(u,h){var f=u&&u.orientation;return f===!0&&!e.orientation||f===1&&e.orientation||(!h||e.orientation)&&f>1&&f<9}function l(u,h){return u!==h&&(u===1&&h>1&&h<9||u>1&&u<9)}function c(u,h){if(h>1&&h<9)switch(u){case 2:case 4:return h>4;case 5:case 7:return h%2===0;case 6:case 8:return h===2||h===4||h===5||h===7}return!1}e.requiresCanvas=function(u){return a(u)||r.call(e,u)},e.requiresMetaData=function(u){return a(u,!0)||s.call(e,u)},e.transform=function(u,h,f,d,p){t.call(e,u,h,function(m,g){if(g){var y=e.orientation&&g.exif&&g.exif.get("Orientation");if(y>4&&y<9){var b=g.originalWidth,x=g.originalHeight;g.originalWidth=x,g.originalHeight=b}}f(m,g)},d,p)},e.getTransformedOptions=function(u,h,f){var d=o.call(e,u,h),p=f.exif&&f.exif.get("Orientation"),m=d.orientation,g=e.orientation&&p;if(m===!0&&(m=p),!l(m,g))return d;var y=d.top,b=d.right,x=d.bottom,w=d.left,S={};for(var C in d)Object.prototype.hasOwnProperty.call(d,C)&&(S[C]=d[C]);if(S.orientation=m,(m>4&&!(g>4)||m<5&&g>4)&&(S.maxWidth=d.maxHeight,S.maxHeight=d.maxWidth,S.minWidth=d.minHeight,S.minHeight=d.minWidth,S.sourceWidth=d.sourceHeight,S.sourceHeight=d.sourceWidth),g>1){switch(g){case 2:b=d.left,w=d.right;break;case 3:y=d.bottom,b=d.left,x=d.top,w=d.right;break;case 4:y=d.bottom,x=d.top;break;case 5:y=d.left,b=d.bottom,x=d.right,w=d.top;break;case 6:y=d.left,b=d.top,x=d.right,w=d.bottom;break;case 7:y=d.right,b=d.top,x=d.left,w=d.bottom;break;case 8:y=d.right,b=d.bottom,x=d.left,w=d.top;break}if(c(m,g)){var k=y,A=b;y=x,b=w,x=k,w=A}}switch(S.top=y,S.right=b,S.bottom=x,S.left=w,m){case 2:S.right=w,S.left=b;break;case 3:S.top=x,S.right=w,S.bottom=y,S.left=b;break;case 4:S.top=x,S.bottom=y;break;case 5:S.top=w,S.right=x,S.bottom=b,S.left=y;break;case 6:S.top=b,S.right=x,S.bottom=w,S.left=y;break;case 7:S.top=b,S.right=y,S.bottom=w,S.left=x;break;case 8:S.top=w,S.right=y,S.bottom=b,S.left=x;break}return S},e.transformCoordinates=function(u,h,f){i.call(e,u,h,f);var d=h.orientation,p=e.orientation&&f.exif&&f.exif.get("Orientation");if(l(d,p)){var m=u.getContext("2d"),g=u.width,y=u.height,b=g,x=y;switch((d>4&&!(p>4)||d<5&&p>4)&&(u.width=y,u.height=g),d>4&&(b=y,x=g),p){case 2:m.translate(b,0),m.scale(-1,1);break;case 3:m.translate(b,x),m.rotate(Math.PI);break;case 4:m.translate(0,x),m.scale(1,-1);break;case 5:m.rotate(-.5*Math.PI),m.scale(-1,1);break;case 6:m.rotate(-.5*Math.PI),m.translate(-b,0);break;case 7:m.rotate(-.5*Math.PI),m.translate(-b,x),m.scale(1,-1);break;case 8:m.rotate(.5*Math.PI),m.translate(0,-x);break}switch(c(d,p)&&(m.translate(b,x),m.rotate(Math.PI)),d){case 2:m.translate(g,0),m.scale(-1,1);break;case 3:m.translate(g,y),m.rotate(Math.PI);break;case 4:m.translate(0,y),m.scale(1,-1);break;case 5:m.rotate(.5*Math.PI),m.scale(1,-1);break;case 6:m.rotate(.5*Math.PI),m.translate(0,-y);break;case 7:m.rotate(.5*Math.PI),m.translate(g,-y),m.scale(-1,1);break;case 8:m.rotate(-.5*Math.PI),m.translate(-g,0);break}}}})})(But);var Vut=jf;const Sj=Tp(Vut);function T$(n,e){let t=0;for(let r=0;r<n.length;r++)t+=(n[r]-e[r])*(n[r]-e[r]);return t}const Y3={distanceFunction:T$};function Uut(n,e,t=Y3){const r=t.distanceFunction||Y3.distanceFunction,s=t.similarityFunction||Y3.similarityFunction;let i=-1;if(typeof s=="function"){let o=Number.MIN_VALUE;for(let a=0;a<n.length;a++){const l=s(e,n[a]);l>o&&(o=l,i=a)}}else if(typeof r=="function"){let o=Number.MAX_VALUE;for(let a=0;a<n.length;a++){const l=r(e,n[a]);l<o&&(o=l,i=a)}}else throw new Error("A similarity or distance function it's required");return i}function Wut(n,e){for(var t=new Array(n.length),r=0;r<n.length;++r)for(var s=r;s<n.length;++s){t[r]||(t[r]=new Array(n.length)),t[s]||(t[s]=new Array(n.length));const i=e(n[r],n[s]);t[r][s]=i,t[s][r]=i}return t}function aoe(n,e,t,r){for(var s=0;s<n.length;s++)t[s]=Uut(e,n[s],{distanceFunction:r});return t}function Gut(n,e,t,r){const s=e[0].length;for(var i=new Array(r),o=new Array(r),a=0;a<r;a++){i[a]=new Array(s),o[a]=0;for(var l=0;l<s;l++)i[a][l]=0}for(var c=0;c<e.length;c++){o[t[c]]++;for(var u=0;u<s;u++)i[t[c]][u]+=e[c][u]}for(var h=0;h<r;h++)for(var f=0;f<s;f++)o[h]?i[h][f]/=o[h]:i[h][f]=n[h][f];return i}function Hut(n,e,t,r){for(var s=0;s<n.length;s++)if(t(n[s],e[s])>r)return!1;return!0}const Cj=8,jut=1/16777216,qut=15,Xut=18,Kut=11;function Yut(n,e){n>>>=0,e>>>=0;const t=n&65535;return((n-t)*e>>>0)+t*e>>>0}class Zut{constructor(e=Date.now()){this.state=new Uint32Array(4),this.init(e),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*jut}init(e){if(!Number.isInteger(e))throw new TypeError("seed must be an integer");this.state[0]=e,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<Cj;t++)this.state[t&3]^=t+Yut(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<Cj;t++)this.nextState()}periodCertification(){this.state[0]===0&&this.state[1]===0&&this.state[2]===0&&this.state[3]===0&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let e=this.state[0];e^=e<<qut,e^=e>>>Xut,e^=this.state[3]<<Kut,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=e}}const Jut=1e-8;function kj(n,e={},t=Math.random){const{size:r=1,replace:s=!1,probabilities:i}=e;let o,a;if(typeof n=="number"?o=Qut(n):o=n.slice(),i){if(!s)throw new Error("choice with probabilities and no replacement is not implemented");if(i.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[i[0]];for(let c=1;c<i.length;c++)a[c]=a[c-1]+i[c];if(Math.abs(1-a[a.length-1])>Jut)throw new Error(`probabilities should sum to 1, but instead sums to ${a[a.length-1]}`)}if(s===!1&&r>o.length)throw new Error("size option is too large");const l=[];for(let c=0;c<r;c++){const u=eht(o.length,t,a);l.push(o[u]),s||o.splice(u,1)}return l}function Qut(n){const e=[];for(let t=0;t<n;t++)e.push(t);return e}function eht(n,e,t){const r=e();if(t){let s=0;for(;r>t[s];)s++;return s}else return Math.floor(r*n)}class G4{constructor(e=Math.random){if(typeof e=="number"){const t=new Zut(e);this.randomGenerator=t.random}else this.randomGenerator=e}choice(e,t){return typeof e=="number"?kj(e,t,this.randomGenerator):kj(e,t,this.randomGenerator)}random(){return this.randomGenerator()}randInt(e,t){return t===void 0&&(t=e,e=0),e+Math.floor(this.randomGenerator()*(t-e))}randomSample(e){const t=[];for(let r=0;r<e;r++)t.push(this.random());return t}}var cr={};const tht=Object.prototype.toString;function rS(n){const e=tht.call(n);return e.endsWith("Array]")&&!e.includes("Big")}const nht=Object.freeze(Object.defineProperty({__proto__:null,isAnyArray:rS},Symbol.toStringTag,{value:"Module"})),rht=zf(nht);function sht(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!rS(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,s=e.toIndex,i=s===void 0?n.length:s;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=r||i>n.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<i;a++)n[a]>o&&(o=n[a]);return o}function iht(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!rS(n))throw new TypeError("input must be an array");if(n.length===0)throw new TypeError("input must not be empty");var t=e.fromIndex,r=t===void 0?0:t,s=e.toIndex,i=s===void 0?n.length:s;if(r<0||r>=n.length||!Number.isInteger(r))throw new Error("fromIndex must be a positive integer smaller than length");if(i<=r||i>n.length||!Number.isInteger(i))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var o=n[r],a=r+1;a<i;a++)n[a]<o&&(o=n[a]);return o}function oht(n){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(rS(n)){if(n.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var t;if(e.output!==void 0){if(!rS(e.output))throw new TypeError("output option must be an array if specified");t=e.output}else t=new Array(n.length);var r=iht(n),s=sht(n);if(r===s)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var i=e.min,o=i===void 0?e.autoMinMax?r:0:i,a=e.max,l=a===void 0?e.autoMinMax?s:1:a;if(o>=l)throw new RangeError("min option must be smaller than max option");for(var c=(l-o)/(s-r),u=0;u<n.length;u++)t[u]=(n[u]-r)*c+o;return t}const aht=Object.freeze(Object.defineProperty({__proto__:null,default:oht},Symbol.toStringTag,{value:"Module"})),lht=zf(aht);var Va=rht,Tj=lht;const NT=" ".repeat(2),loe=" ".repeat(4);function cht(){return coe(this)}function coe(n,e={}){const{maxRows:t=15,maxColumns:r=10,maxNumSize:s=8,padMinus:i="auto"}=e;return`${n.constructor.name} {
${NT}[
${loe}${uht(n,t,r,s,i)}
${NT}]
${NT}rows: ${n.rows}
${NT}columns: ${n.columns}
}`}function uht(n,e,t,r,s){const{rows:i,columns:o}=n,a=Math.min(i,e),l=Math.min(o,t),c=[];if(s==="auto"){s=!1;e:for(let u=0;u<a;u++)for(let h=0;h<l;h++)if(n.get(u,h)<0){s=!0;break e}}for(let u=0;u<a;u++){let h=[];for(let f=0;f<l;f++)h.push(hht(n.get(u,f),r,s));c.push(`${h.join(" ")}`)}return l!==o&&(c[c.length-1]+=` ... ${o-t} more columns`),a!==i&&c.push(`... ${i-e} more rows`),c.join(`
${loe}`)}function hht(n,e,t){return(n>=0&&t?` ${Ej(n,e-1)}`:Ej(n,e)).padEnd(e)}function Ej(n,e){let t=n.toString();if(t.length<=e)return t;let r=n.toFixed(e);if(r.length>e&&(r=n.toFixed(Math.max(0,e-(r.length-e)))),r.length<=e&&!r.startsWith("0.000")&&!r.startsWith("-0.000"))return r;let s=n.toExponential(e);return s.length>e&&(s=n.toExponential(Math.max(0,e-(s.length-e)))),s.slice(0)}function fht(n,e){n.prototype.add=function(r){return typeof r=="number"?this.addS(r):this.addM(r)},n.prototype.addS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)+r);return this},n.prototype.addM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)+r.get(s,i));return this},n.add=function(r,s){return new e(r).add(s)},n.prototype.sub=function(r){return typeof r=="number"?this.subS(r):this.subM(r)},n.prototype.subS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)-r);return this},n.prototype.subM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)-r.get(s,i));return this},n.sub=function(r,s){return new e(r).sub(s)},n.prototype.subtract=n.prototype.sub,n.prototype.subtractS=n.prototype.subS,n.prototype.subtractM=n.prototype.subM,n.subtract=n.sub,n.prototype.mul=function(r){return typeof r=="number"?this.mulS(r):this.mulM(r)},n.prototype.mulS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)*r);return this},n.prototype.mulM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)*r.get(s,i));return this},n.mul=function(r,s){return new e(r).mul(s)},n.prototype.multiply=n.prototype.mul,n.prototype.multiplyS=n.prototype.mulS,n.prototype.multiplyM=n.prototype.mulM,n.multiply=n.mul,n.prototype.div=function(r){return typeof r=="number"?this.divS(r):this.divM(r)},n.prototype.divS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)/r);return this},n.prototype.divM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)/r.get(s,i));return this},n.div=function(r,s){return new e(r).div(s)},n.prototype.divide=n.prototype.div,n.prototype.divideS=n.prototype.divS,n.prototype.divideM=n.prototype.divM,n.divide=n.div,n.prototype.mod=function(r){return typeof r=="number"?this.modS(r):this.modM(r)},n.prototype.modS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)%r);return this},n.prototype.modM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)%r.get(s,i));return this},n.mod=function(r,s){return new e(r).mod(s)},n.prototype.modulus=n.prototype.mod,n.prototype.modulusS=n.prototype.modS,n.prototype.modulusM=n.prototype.modM,n.modulus=n.mod,n.prototype.and=function(r){return typeof r=="number"?this.andS(r):this.andM(r)},n.prototype.andS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)&r);return this},n.prototype.andM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)&r.get(s,i));return this},n.and=function(r,s){return new e(r).and(s)},n.prototype.or=function(r){return typeof r=="number"?this.orS(r):this.orM(r)},n.prototype.orS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)|r);return this},n.prototype.orM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)|r.get(s,i));return this},n.or=function(r,s){return new e(r).or(s)},n.prototype.xor=function(r){return typeof r=="number"?this.xorS(r):this.xorM(r)},n.prototype.xorS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)^r);return this},n.prototype.xorM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)^r.get(s,i));return this},n.xor=function(r,s){return new e(r).xor(s)},n.prototype.leftShift=function(r){return typeof r=="number"?this.leftShiftS(r):this.leftShiftM(r)},n.prototype.leftShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)<<r);return this},n.prototype.leftShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)<<r.get(s,i));return this},n.leftShift=function(r,s){return new e(r).leftShift(s)},n.prototype.signPropagatingRightShift=function(r){return typeof r=="number"?this.signPropagatingRightShiftS(r):this.signPropagatingRightShiftM(r)},n.prototype.signPropagatingRightShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>r);return this},n.prototype.signPropagatingRightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>r.get(s,i));return this},n.signPropagatingRightShift=function(r,s){return new e(r).signPropagatingRightShift(s)},n.prototype.rightShift=function(r){return typeof r=="number"?this.rightShiftS(r):this.rightShiftM(r)},n.prototype.rightShiftS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>>r);return this},n.prototype.rightShiftM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,this.get(s,i)>>>r.get(s,i));return this},n.rightShift=function(r,s){return new e(r).rightShift(s)},n.prototype.zeroFillRightShift=n.prototype.rightShift,n.prototype.zeroFillRightShiftS=n.prototype.rightShiftS,n.prototype.zeroFillRightShiftM=n.prototype.rightShiftM,n.zeroFillRightShift=n.rightShift,n.prototype.not=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,~this.get(r,s));return this},n.not=function(r){return new e(r).not()},n.prototype.abs=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.abs(this.get(r,s)));return this},n.abs=function(r){return new e(r).abs()},n.prototype.acos=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.acos(this.get(r,s)));return this},n.acos=function(r){return new e(r).acos()},n.prototype.acosh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.acosh(this.get(r,s)));return this},n.acosh=function(r){return new e(r).acosh()},n.prototype.asin=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.asin(this.get(r,s)));return this},n.asin=function(r){return new e(r).asin()},n.prototype.asinh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.asinh(this.get(r,s)));return this},n.asinh=function(r){return new e(r).asinh()},n.prototype.atan=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.atan(this.get(r,s)));return this},n.atan=function(r){return new e(r).atan()},n.prototype.atanh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.atanh(this.get(r,s)));return this},n.atanh=function(r){return new e(r).atanh()},n.prototype.cbrt=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cbrt(this.get(r,s)));return this},n.cbrt=function(r){return new e(r).cbrt()},n.prototype.ceil=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.ceil(this.get(r,s)));return this},n.ceil=function(r){return new e(r).ceil()},n.prototype.clz32=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.clz32(this.get(r,s)));return this},n.clz32=function(r){return new e(r).clz32()},n.prototype.cos=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cos(this.get(r,s)));return this},n.cos=function(r){return new e(r).cos()},n.prototype.cosh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.cosh(this.get(r,s)));return this},n.cosh=function(r){return new e(r).cosh()},n.prototype.exp=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.exp(this.get(r,s)));return this},n.exp=function(r){return new e(r).exp()},n.prototype.expm1=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.expm1(this.get(r,s)));return this},n.expm1=function(r){return new e(r).expm1()},n.prototype.floor=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.floor(this.get(r,s)));return this},n.floor=function(r){return new e(r).floor()},n.prototype.fround=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.fround(this.get(r,s)));return this},n.fround=function(r){return new e(r).fround()},n.prototype.log=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log(this.get(r,s)));return this},n.log=function(r){return new e(r).log()},n.prototype.log1p=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log1p(this.get(r,s)));return this},n.log1p=function(r){return new e(r).log1p()},n.prototype.log10=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log10(this.get(r,s)));return this},n.log10=function(r){return new e(r).log10()},n.prototype.log2=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.log2(this.get(r,s)));return this},n.log2=function(r){return new e(r).log2()},n.prototype.round=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.round(this.get(r,s)));return this},n.round=function(r){return new e(r).round()},n.prototype.sign=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sign(this.get(r,s)));return this},n.sign=function(r){return new e(r).sign()},n.prototype.sin=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sin(this.get(r,s)));return this},n.sin=function(r){return new e(r).sin()},n.prototype.sinh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sinh(this.get(r,s)));return this},n.sinh=function(r){return new e(r).sinh()},n.prototype.sqrt=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.sqrt(this.get(r,s)));return this},n.sqrt=function(r){return new e(r).sqrt()},n.prototype.tan=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.tan(this.get(r,s)));return this},n.tan=function(r){return new e(r).tan()},n.prototype.tanh=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.tanh(this.get(r,s)));return this},n.tanh=function(r){return new e(r).tanh()},n.prototype.trunc=function(){for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.set(r,s,Math.trunc(this.get(r,s)));return this},n.trunc=function(r){return new e(r).trunc()},n.pow=function(r,s){return new e(r).pow(s)},n.prototype.pow=function(r){return typeof r=="number"?this.powS(r):this.powM(r)},n.prototype.powS=function(r){for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,Math.pow(this.get(s,i),r));return this},n.prototype.powM=function(r){if(r=e.checkMatrix(r),this.rows!==r.rows||this.columns!==r.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let i=0;i<this.columns;i++)this.set(s,i,Math.pow(this.get(s,i),r.get(s,i)));return this}}function rc(n,e,t){let r=t?n.rows:n.rows-1;if(e<0||e>r)throw new RangeError("Row index out of range")}function sc(n,e,t){let r=t?n.columns:n.columns-1;if(e<0||e>r)throw new RangeError("Column index out of range")}function pb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function mb(n,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==n.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function H4(n,e){if(!Va.isAnyArray(e))throw new TypeError("row indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.rows)throw new RangeError("row indices are out of range")}function j4(n,e){if(!Va.isAnyArray(e))throw new TypeError("column indices must be an array");for(let t=0;t<e.length;t++)if(e[t]<0||e[t]>=n.columns)throw new RangeError("column indices are out of range")}function gF(n,e,t,r,s){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if($T("startRow",e),$T("endRow",t),$T("startColumn",r),$T("endColumn",s),e>t||r>s||e<0||e>=n.rows||t<0||t>=n.rows||r<0||r>=n.columns||s<0||s>=n.columns)throw new RangeError("Submatrix indices are out of range")}function E$(n,e=0){let t=[];for(let r=0;r<n;r++)t.push(e);return t}function $T(n,e){if(typeof e!="number")throw new TypeError(`${n} must be a number`)}function B0(n){if(n.isEmpty())throw new Error("Empty matrix has no elements to index")}function dht(n){let e=E$(n.rows);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]+=n.get(t,r);return e}function pht(n){let e=E$(n.columns);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]+=n.get(t,r);return e}function mht(n){let e=0;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e+=n.get(t,r);return e}function ght(n){let e=E$(n.rows,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[t]*=n.get(t,r);return e}function yht(n){let e=E$(n.columns,1);for(let t=0;t<n.rows;++t)for(let r=0;r<n.columns;++r)e[r]*=n.get(t,r);return e}function bht(n){let e=1;for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)e*=n.get(t,r);return e}function vht(n,e,t){const r=n.rows,s=n.columns,i=[];for(let o=0;o<r;o++){let a=0,l=0,c=0;for(let u=0;u<s;u++)c=n.get(o,u)-t[o],a+=c,l+=c*c;e?i.push((l-a*a/s)/(s-1)):i.push((l-a*a/s)/s)}return i}function wht(n,e,t){const r=n.rows,s=n.columns,i=[];for(let o=0;o<s;o++){let a=0,l=0,c=0;for(let u=0;u<r;u++)c=n.get(u,o)-t[o],a+=c,l+=c*c;e?i.push((l-a*a/r)/(r-1)):i.push((l-a*a/r)/r)}return i}function xht(n,e,t){const r=n.rows,s=n.columns,i=r*s;let o=0,a=0,l=0;for(let c=0;c<r;c++)for(let u=0;u<s;u++)l=n.get(c,u)-t,o+=l,a+=l*l;return e?(a-o*o/i)/(i-1):(a-o*o/i)/i}function _ht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[t])}function Sht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e[r])}function Cht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)-e)}function kht(n){const e=[];for(let t=0;t<n.rows;t++){let r=0;for(let s=0;s<n.columns;s++)r+=Math.pow(n.get(t,s),2)/(n.columns-1);e.push(Math.sqrt(r))}return e}function Tht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[t])}function Eht(n){const e=[];for(let t=0;t<n.columns;t++){let r=0;for(let s=0;s<n.rows;s++)r+=Math.pow(n.get(s,t),2)/(n.rows-1);e.push(Math.sqrt(r))}return e}function Iht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e[r])}function Aht(n){const e=n.size-1;let t=0;for(let r=0;r<n.columns;r++)for(let s=0;s<n.rows;s++)t+=Math.pow(n.get(s,r),2)/e;return Math.sqrt(t)}function Mht(n,e){for(let t=0;t<n.rows;t++)for(let r=0;r<n.columns;r++)n.set(t,r,n.get(t,r)/e)}class Gn{static from1DArray(e,t,r){if(e*t!==r.length)throw new RangeError("data length does not match given dimensions");let i=new Wt(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)i.set(o,a,r[o*t+a]);return i}static rowVector(e){let t=new Wt(1,e.length);for(let r=0;r<e.length;r++)t.set(0,r,e[r]);return t}static columnVector(e){let t=new Wt(e.length,1);for(let r=0;r<e.length;r++)t.set(r,0,e[r]);return t}static zeros(e,t){return new Wt(e,t)}static ones(e,t){return new Wt(e,t).fill(1)}static rand(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{random:s=Math.random}=r;let i=new Wt(e,t);for(let o=0;o<e;o++)for(let a=0;a<t;a++)i.set(o,a,s());return i}static randInt(e,t,r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:s=0,max:i=1e3,random:o=Math.random}=r;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(i))throw new TypeError("max must be an integer");if(s>=i)throw new RangeError("min must be smaller than max");let a=i-s,l=new Wt(e,t);for(let c=0;c<e;c++)for(let u=0;u<t;u++){let h=s+Math.round(o()*a);l.set(c,u,h)}return l}static eye(e,t,r){t===void 0&&(t=e),r===void 0&&(r=1);let s=Math.min(e,t),i=this.zeros(e,t);for(let o=0;o<s;o++)i.set(o,o,r);return i}static diag(e,t,r){let s=e.length;t===void 0&&(t=s),r===void 0&&(r=t);let i=Math.min(s,t,r),o=this.zeros(t,r);for(let a=0;a<i;a++)o.set(a,a,e[a]);return o}static min(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,s=e.columns,i=new Wt(r,s);for(let o=0;o<r;o++)for(let a=0;a<s;a++)i.set(o,a,Math.min(e.get(o,a),t.get(o,a)));return i}static max(e,t){e=this.checkMatrix(e),t=this.checkMatrix(t);let r=e.rows,s=e.columns,i=new this(r,s);for(let o=0;o<r;o++)for(let a=0;a<s;a++)i.set(o,a,Math.max(e.get(o,a),t.get(o,a)));return i}static checkMatrix(e){return Gn.isMatrix(e)?e:new Wt(e)}static isMatrix(e){return e!=null&&e.klass==="Matrix"}get size(){return this.rows*this.columns}apply(e){if(typeof e!="function")throw new TypeError("callback must be a function");for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.call(this,t,r);return this}to1DArray(){let e=[];for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}to2DArray(){let e=[];for(let t=0;t<this.rows;t++){e.push([]);for(let r=0;r<this.columns;r++)e[t].push(this.get(t,r))}return e}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let e=0;e<this.rows;e++)for(let t=0;t<=e;t++)if(this.get(e,t)!==this.get(t,e))return!1;return!0}return!1}isEchelonForm(){let e=0,t=0,r=-1,s=!0,i=!1;for(;e<this.rows&&s;){for(t=0,i=!1;t<this.columns&&i===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(i=!0,r=t):(s=!1,i=!0);e++}return s}isReducedEchelonForm(){let e=0,t=0,r=-1,s=!0,i=!1;for(;e<this.rows&&s;){for(t=0,i=!1;t<this.columns&&i===!1;)this.get(e,t)===0?t++:this.get(e,t)===1&&t>r?(i=!0,r=t):(s=!1,i=!0);for(let o=t+1;o<this.rows;o++)this.get(e,o)!==0&&(s=!1);e++}return s}echelonForm(){let e=this.clone(),t=0,r=0;for(;t<e.rows&&r<e.columns;){let s=t;for(let i=t;i<e.rows;i++)e.get(i,r)>e.get(s,r)&&(s=i);if(e.get(s,r)===0)r++;else{e.swapRows(t,s);let i=e.get(t,r);for(let o=r;o<e.columns;o++)e.set(t,o,e.get(t,o)/i);for(let o=t+1;o<e.rows;o++){let a=e.get(o,r)/e.get(t,r);e.set(o,r,0);for(let l=r+1;l<e.columns;l++)e.set(o,l,e.get(o,l)-e.get(t,l)*a)}t++,r++}}return e}reducedEchelonForm(){let e=this.echelonForm(),t=e.columns,r=e.rows,s=r-1;for(;s>=0;)if(e.maxRow(s)===0)s--;else{let i=0,o=!1;for(;i<r&&o===!1;)e.get(s,i)===1?o=!0:i++;for(let a=0;a<s;a++){let l=e.get(a,i);for(let c=i;c<t;c++){let u=e.get(a,c)-l*e.get(s,c);e.set(a,c,u)}}s--}return e}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{rows:t=1,columns:r=1}=e;if(!Number.isInteger(t)||t<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let s=new Wt(this.rows*t,this.columns*r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)s.setSubMatrix(this,this.rows*i,this.columns*o);return s}fill(e){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,e);return this}neg(){return this.mulS(-1)}getRow(e){rc(this,e);let t=[];for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}getRowVector(e){return Wt.rowVector(this.getRow(e))}setRow(e,t){rc(this,e),t=pb(this,t);for(let r=0;r<this.columns;r++)this.set(e,r,t[r]);return this}swapRows(e,t){rc(this,e),rc(this,t);for(let r=0;r<this.columns;r++){let s=this.get(e,r);this.set(e,r,this.get(t,r)),this.set(t,r,s)}return this}getColumn(e){sc(this,e);let t=[];for(let r=0;r<this.rows;r++)t.push(this.get(r,e));return t}getColumnVector(e){return Wt.columnVector(this.getColumn(e))}setColumn(e,t){sc(this,e),t=mb(this,t);for(let r=0;r<this.rows;r++)this.set(r,e,t[r]);return this}swapColumns(e,t){sc(this,e),sc(this,t);for(let r=0;r<this.rows;r++){let s=this.get(r,e);this.set(r,e,this.get(r,t)),this.set(r,t,s)}return this}addRowVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[r]);return this}subRowVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[r]);return this}mulRowVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[r]);return this}divRowVector(e){e=pb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[r]);return this}addColumnVector(e){e=mb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)+e[t]);return this}subColumnVector(e){e=mb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)-e[t]);return this}mulColumnVector(e){e=mb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e[t]);return this}divColumnVector(e){e=mb(this,e);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)/e[t]);return this}mulRow(e,t){rc(this,e);for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this}mulColumn(e,t){sc(this,e);for(let r=0;r<this.rows;r++)this.set(r,e,this.get(r,e)*t);return this}max(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t[r]&&(t[r]=this.get(r,s));return t}case"column":{const t=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t[s]&&(t[s]=this.get(r,s));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>t&&(t=this.get(r,s));return t}default:throw new Error(`invalid option: ${e}`)}}maxIndex(){B0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)>e&&(e=this.get(r,s),t[0]=r,t[1]=s);return t}min(e){if(this.isEmpty())return NaN;switch(e){case"row":{const t=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t[r]&&(t[r]=this.get(r,s));return t}case"column":{const t=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t[s]&&(t[s]=this.get(r,s));return t}case void 0:{let t=this.get(0,0);for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<t&&(t=this.get(r,s));return t}default:throw new Error(`invalid option: ${e}`)}}minIndex(){B0(this);let e=this.get(0,0),t=[0,0];for(let r=0;r<this.rows;r++)for(let s=0;s<this.columns;s++)this.get(r,s)<e&&(e=this.get(r,s),t[0]=r,t[1]=s);return t}maxRow(e){if(rc(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxRowIndex(e){rc(this,e),B0(this);let t=this.get(e,0),r=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)>t&&(t=this.get(e,s),r[1]=s);return r}minRow(e){if(rc(this,e),this.isEmpty())return NaN;let t=this.get(e,0);for(let r=1;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minRowIndex(e){rc(this,e),B0(this);let t=this.get(e,0),r=[e,0];for(let s=1;s<this.columns;s++)this.get(e,s)<t&&(t=this.get(e,s),r[1]=s);return r}maxColumn(e){if(sc(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)>t&&(t=this.get(r,e));return t}maxColumnIndex(e){sc(this,e),B0(this);let t=this.get(0,e),r=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)>t&&(t=this.get(s,e),r[0]=s);return r}minColumn(e){if(sc(this,e),this.isEmpty())return NaN;let t=this.get(0,e);for(let r=1;r<this.rows;r++)this.get(r,e)<t&&(t=this.get(r,e));return t}minColumnIndex(e){sc(this,e),B0(this);let t=this.get(0,e),r=[0,e];for(let s=1;s<this.rows;s++)this.get(s,e)<t&&(t=this.get(s,e),r[0]=s);return r}diag(){let e=Math.min(this.rows,this.columns),t=[];for(let r=0;r<e;r++)t.push(this.get(r,r));return t}norm(e="frobenius"){switch(e){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${e}`)}}cumulativeSum(){let e=0;for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r),this.set(t,r,e);return this}dot(e){Gn.isMatrix(e)&&(e=e.to1DArray());let t=this.to1DArray();if(t.length!==e.length)throw new RangeError("vectors do not have the same size");let r=0;for(let s=0;s<t.length;s++)r+=t[s]*e[s];return r}mmul(e){e=Wt.checkMatrix(e);let t=this.rows,r=this.columns,s=e.columns,i=new Wt(t,s),o=new Float64Array(r);for(let a=0;a<s;a++){for(let l=0;l<r;l++)o[l]=e.get(l,a);for(let l=0;l<t;l++){let c=0;for(let u=0;u<r;u++)c+=this.get(l,u)*o[u];i.set(l,a,c)}}return i}strassen2x2(e){e=Wt.checkMatrix(e);let t=new Wt(2,2);const r=this.get(0,0),s=e.get(0,0),i=this.get(0,1),o=e.get(0,1),a=this.get(1,0),l=e.get(1,0),c=this.get(1,1),u=e.get(1,1),h=(r+c)*(s+u),f=(a+c)*s,d=r*(o-u),p=c*(l-s),m=(r+i)*u,g=(a-r)*(s+o),y=(i-c)*(l+u),b=h+p-m+y,x=d+m,w=f+p,S=h-f+d+g;return t.set(0,0,b),t.set(0,1,x),t.set(1,0,w),t.set(1,1,S),t}strassen3x3(e){e=Wt.checkMatrix(e);let t=new Wt(3,3);const r=this.get(0,0),s=this.get(0,1),i=this.get(0,2),o=this.get(1,0),a=this.get(1,1),l=this.get(1,2),c=this.get(2,0),u=this.get(2,1),h=this.get(2,2),f=e.get(0,0),d=e.get(0,1),p=e.get(0,2),m=e.get(1,0),g=e.get(1,1),y=e.get(1,2),b=e.get(2,0),x=e.get(2,1),w=e.get(2,2),S=(r+s+i-o-a-u-h)*g,C=(r-o)*(-d+g),k=a*(-f+d+m-g-y-b+w),A=(-r+o+a)*(f-d+g),M=(o+a)*(-f+d),E=r*f,N=(-r+c+u)*(f-p+y),O=(-r+c)*(p-y),R=(c+u)*(-f+p),D=(r+s+i-a-l-c-u)*y,z=u*(-f+p+m-g-y-b+x),B=(-i+u+h)*(g+b-x),X=(i-h)*(g-x),G=i*b,te=(u+h)*(-b+x),ge=(-i+a+l)*(y+b-w),ae=(i-l)*(y-w),Ne=(a+l)*(-b+w),ke=s*m,De=l*x,be=o*p,Xe=c*d,Oe=h*w,it=E+G+ke,We=S+A+M+E+B+G+te,dt=E+N+R+D+G+ge+Ne,ct=C+k+A+E+G+ge+ae,Ve=C+A+M+E+De,ze=G+ge+ae+Ne+be,Be=E+N+O+z+B+X+G,ut=B+X+G+te+Xe,Ke=E+N+O+R+Oe;return t.set(0,0,it),t.set(0,1,We),t.set(0,2,dt),t.set(1,0,ct),t.set(1,1,Ve),t.set(1,2,ze),t.set(2,0,Be),t.set(2,1,ut),t.set(2,2,Ke),t}mmulStrassen(e){e=Wt.checkMatrix(e);let t=this.clone(),r=t.rows,s=t.columns,i=e.rows,o=e.columns;s!==i&&console.warn(`Multiplying ${r} x ${s} and ${i} x ${o} matrix: dimensions do not match.`);function a(h,f,d){let p=h.rows,m=h.columns;if(p===f&&m===d)return h;{let g=Gn.zeros(f,d);return g=g.setSubMatrix(h,0,0),g}}let l=Math.max(r,i),c=Math.max(s,o);t=a(t,l,c),e=a(e,l,c);function u(h,f,d,p){if(d<=512||p<=512)return h.mmul(f);d%2===1&&p%2===1?(h=a(h,d+1,p+1),f=a(f,d+1,p+1)):d%2===1?(h=a(h,d+1,p),f=a(f,d+1,p)):p%2===1&&(h=a(h,d,p+1),f=a(f,d,p+1));let m=parseInt(h.rows/2,10),g=parseInt(h.columns/2,10),y=h.subMatrix(0,m-1,0,g-1),b=f.subMatrix(0,m-1,0,g-1),x=h.subMatrix(0,m-1,g,h.columns-1),w=f.subMatrix(0,m-1,g,f.columns-1),S=h.subMatrix(m,h.rows-1,0,g-1),C=f.subMatrix(m,f.rows-1,0,g-1),k=h.subMatrix(m,h.rows-1,g,h.columns-1),A=f.subMatrix(m,f.rows-1,g,f.columns-1),M=u(Gn.add(y,k),Gn.add(b,A),m,g),E=u(Gn.add(S,k),b,m,g),N=u(y,Gn.sub(w,A),m,g),O=u(k,Gn.sub(C,b),m,g),R=u(Gn.add(y,x),A,m,g),D=u(Gn.sub(S,y),Gn.add(b,w),m,g),z=u(Gn.sub(x,k),Gn.add(C,A),m,g),B=Gn.add(M,O);B.sub(R),B.add(z);let X=Gn.add(N,R),G=Gn.add(E,O),te=Gn.sub(M,E);te.add(N),te.add(D);let ge=Gn.zeros(2*B.rows,2*B.columns);return ge=ge.setSubMatrix(B,0,0),ge=ge.setSubMatrix(X,B.rows,0),ge=ge.setSubMatrix(G,0,B.columns),ge=ge.setSubMatrix(te,B.rows,B.columns),ge.subMatrix(0,d-1,0,p-1)}return u(t,e,l,c)}scaleRows(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let s=new Wt(this.rows,this.columns);for(let i=0;i<this.rows;i++){const o=this.getRow(i);o.length>0&&Tj(o,{min:t,max:r,output:o}),s.setRow(i,o)}return s}scaleColumns(e={}){if(typeof e!="object")throw new TypeError("options must be an object");const{min:t=0,max:r=1}=e;if(!Number.isFinite(t))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(t>=r)throw new RangeError("min must be smaller than max");let s=new Wt(this.rows,this.columns);for(let i=0;i<this.columns;i++){const o=this.getColumn(i);o.length&&Tj(o,{min:t,max:r,output:o}),s.setColumn(i,o)}return s}flipRows(){const e=Math.ceil(this.columns/2);for(let t=0;t<this.rows;t++)for(let r=0;r<e;r++){let s=this.get(t,r),i=this.get(t,this.columns-1-r);this.set(t,r,i),this.set(t,this.columns-1-r,s)}return this}flipColumns(){const e=Math.ceil(this.rows/2);for(let t=0;t<this.columns;t++)for(let r=0;r<e;r++){let s=this.get(r,t),i=this.get(this.rows-1-r,t);this.set(r,t,i),this.set(this.rows-1-r,t,s)}return this}kroneckerProduct(e){e=Wt.checkMatrix(e);let t=this.rows,r=this.columns,s=e.rows,i=e.columns,o=new Wt(t*s,r*i);for(let a=0;a<t;a++)for(let l=0;l<r;l++)for(let c=0;c<s;c++)for(let u=0;u<i;u++)o.set(s*a+c,i*l+u,this.get(a,l)*e.get(c,u));return o}kroneckerSum(e){if(e=Wt.checkMatrix(e),!this.isSquare()||!e.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let t=this.rows,r=e.rows,s=this.kroneckerProduct(Wt.eye(r,r)),i=Wt.eye(t,t).kroneckerProduct(e);return s.add(i)}transpose(){let e=new Wt(this.columns,this.rows);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(r,t,this.get(t,r));return e}sortRows(e=Ij){for(let t=0;t<this.rows;t++)this.setRow(t,this.getRow(t).sort(e));return this}sortColumns(e=Ij){for(let t=0;t<this.columns;t++)this.setColumn(t,this.getColumn(t).sort(e));return this}subMatrix(e,t,r,s){gF(this,e,t,r,s);let i=new Wt(t-e+1,s-r+1);for(let o=e;o<=t;o++)for(let a=r;a<=s;a++)i.set(o-e,a-r,this.get(o,a));return i}subMatrixRow(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.columns-1),t>r||t<0||t>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let s=new Wt(e.length,r-t+1);for(let i=0;i<e.length;i++)for(let o=t;o<=r;o++){if(e[i]<0||e[i]>=this.rows)throw new RangeError(`Row index out of range: ${e[i]}`);s.set(i,o-t,this.get(e[i],o))}return s}subMatrixColumn(e,t,r){if(t===void 0&&(t=0),r===void 0&&(r=this.rows-1),t>r||t<0||t>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let s=new Wt(r-t+1,e.length);for(let i=0;i<e.length;i++)for(let o=t;o<=r;o++){if(e[i]<0||e[i]>=this.columns)throw new RangeError(`Column index out of range: ${e[i]}`);s.set(o-t,i,this.get(o,e[i]))}return s}setSubMatrix(e,t,r){if(e=Wt.checkMatrix(e),e.isEmpty())return this;let s=t+e.rows-1,i=r+e.columns-1;gF(this,t,s,r,i);for(let o=0;o<e.rows;o++)for(let a=0;a<e.columns;a++)this.set(t+o,r+a,e.get(o,a));return this}selection(e,t){H4(this,e),j4(this,t);let r=new Wt(e.length,t.length);for(let s=0;s<e.length;s++){let i=e[s];for(let o=0;o<t.length;o++){let a=t[o];r.set(s,o,this.get(i,a))}}return r}trace(){let e=Math.min(this.rows,this.columns),t=0;for(let r=0;r<e;r++)t+=this.get(r,r);return t}clone(){let e=new Wt(this.rows,this.columns);for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e.set(t,r,this.get(t,r));return e}sum(e){switch(e){case"row":return dht(this);case"column":return pht(this);case void 0:return mht(this);default:throw new Error(`invalid option: ${e}`)}}product(e){switch(e){case"row":return ght(this);case"column":return yht(this);case void 0:return bht(this);default:throw new Error(`invalid option: ${e}`)}}mean(e){const t=this.sum(e);switch(e){case"row":{for(let r=0;r<this.rows;r++)t[r]/=this.columns;return t}case"column":{for(let r=0;r<this.columns;r++)t[r]/=this.rows;return t}case void 0:return t/this.size;default:throw new Error(`invalid option: ${e}`)}}variance(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{unbiased:r=!0,mean:s=this.mean(e)}=t;if(typeof r!="boolean")throw new TypeError("unbiased must be a boolean");switch(e){case"row":{if(!Va.isAnyArray(s))throw new TypeError("mean must be an array");return vht(this,r,s)}case"column":{if(!Va.isAnyArray(s))throw new TypeError("mean must be an array");return wht(this,r,s)}case void 0:{if(typeof s!="number")throw new TypeError("mean must be a number");return xht(this,r,s)}default:throw new Error(`invalid option: ${e}`)}}standardDeviation(e,t){typeof e=="object"&&(t=e,e=void 0);const r=this.variance(e,t);if(e===void 0)return Math.sqrt(r);for(let s=0;s<r.length;s++)r[s]=Math.sqrt(r[s]);return r}center(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");const{center:r=this.mean(e)}=t;switch(e){case"row":{if(!Va.isAnyArray(r))throw new TypeError("center must be an array");return _ht(this,r),this}case"column":{if(!Va.isAnyArray(r))throw new TypeError("center must be an array");return Sht(this,r),this}case void 0:{if(typeof r!="number")throw new TypeError("center must be a number");return Cht(this,r),this}default:throw new Error(`invalid option: ${e}`)}}scale(e,t={}){if(typeof e=="object"&&(t=e,e=void 0),typeof t!="object")throw new TypeError("options must be an object");let r=t.scale;switch(e){case"row":{if(r===void 0)r=kht(this);else if(!Va.isAnyArray(r))throw new TypeError("scale must be an array");return Tht(this,r),this}case"column":{if(r===void 0)r=Eht(this);else if(!Va.isAnyArray(r))throw new TypeError("scale must be an array");return Iht(this,r),this}case void 0:{if(r===void 0)r=Aht(this);else if(typeof r!="number")throw new TypeError("scale must be a number");return Mht(this,r),this}default:throw new Error(`invalid option: ${e}`)}}toString(e){return coe(this,e)}}Gn.prototype.klass="Matrix";typeof Symbol<"u"&&(Gn.prototype[Symbol.for("nodejs.util.inspect.custom")]=cht);function Ij(n,e){return n-e}function Nht(n){return n.every(e=>typeof e=="number")}Gn.random=Gn.rand;Gn.randomInt=Gn.randInt;Gn.diagonal=Gn.diag;Gn.prototype.diagonal=Gn.prototype.diag;Gn.identity=Gn.eye;Gn.prototype.negate=Gn.prototype.neg;Gn.prototype.tensorProduct=Gn.prototype.kroneckerProduct;let Wt=class uoe extends Gn{constructor(e,t){if(super(),uoe.isMatrix(e))return e.clone();if(Number.isInteger(e)&&e>=0)if(this.data=[],Number.isInteger(t)&&t>=0)for(let r=0;r<e;r++)this.data.push(new Float64Array(t));else throw new TypeError("nColumns must be a positive integer");else if(Va.isAnyArray(e)){const r=e;if(e=r.length,t=e?r[0].length:0,typeof t!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let s=0;s<e;s++){if(r[s].length!==t)throw new RangeError("Inconsistent array dimensions");if(!Nht(r[s]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(r[s]))}}else throw new TypeError("First argument must be a positive number or an array");this.rows=e,this.columns=t}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}removeRow(e){return rc(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,t){return t===void 0&&(t=e,e=this.rows),rc(this,e,!0),t=Float64Array.from(pb(this,t)),this.data.splice(e,0,t),this.rows+=1,this}removeColumn(e){sc(this,e);for(let t=0;t<this.rows;t++){const r=new Float64Array(this.columns-1);for(let s=0;s<e;s++)r[s]=this.data[t][s];for(let s=e+1;s<this.columns;s++)r[s-1]=this.data[t][s];this.data[t]=r}return this.columns-=1,this}addColumn(e,t){typeof t>"u"&&(t=e,e=this.columns),sc(this,e,!0),t=mb(this,t);for(let r=0;r<this.rows;r++){const s=new Float64Array(this.columns+1);let i=0;for(;i<e;i++)s[i]=this.data[r][i];for(s[i++]=t[r];i<this.columns+1;i++)s[i]=this.data[r][i-1];this.data[r]=s}return this.columns+=1,this}};fht(Gn,Wt);class qf extends Gn{constructor(e,t,r){super(),this.matrix=e,this.rows=t,this.columns=r}}class $ht extends qf{constructor(e,t){sc(e,t),super(e,e.rows,1),this.column=t}set(e,t,r){return this.matrix.set(e,this.column,r),this}get(e){return this.matrix.get(e,this.column)}}class Rht extends qf{constructor(e,t){j4(e,t),super(e,e.rows,t.length),this.columnIndices=t}set(e,t,r){return this.matrix.set(e,this.columnIndices[t],r),this}get(e,t){return this.matrix.get(e,this.columnIndices[t])}}class Pht extends qf{constructor(e){super(e,e.rows,e.columns)}set(e,t,r){return this.matrix.set(e,this.columns-t-1,r),this}get(e,t){return this.matrix.get(e,this.columns-t-1)}}class Dht extends qf{constructor(e){super(e,e.rows,e.columns)}set(e,t,r){return this.matrix.set(this.rows-e-1,t,r),this}get(e,t){return this.matrix.get(this.rows-e-1,t)}}class Oht extends qf{constructor(e,t){rc(e,t),super(e,1,e.columns),this.row=t}set(e,t,r){return this.matrix.set(this.row,t,r),this}get(e,t){return this.matrix.get(this.row,t)}}class Fht extends qf{constructor(e,t){H4(e,t),super(e,t.length,e.columns),this.rowIndices=t}set(e,t,r){return this.matrix.set(this.rowIndices[e],t,r),this}get(e,t){return this.matrix.get(this.rowIndices[e],t)}}class eI extends qf{constructor(e,t,r){H4(e,t),j4(e,r),super(e,t.length,r.length),this.rowIndices=t,this.columnIndices=r}set(e,t,r){return this.matrix.set(this.rowIndices[e],this.columnIndices[t],r),this}get(e,t){return this.matrix.get(this.rowIndices[e],this.columnIndices[t])}}class Lht extends qf{constructor(e,t,r,s,i){gF(e,t,r,s,i),super(e,r-t+1,i-s+1),this.startRow=t,this.startColumn=s}set(e,t,r){return this.matrix.set(this.startRow+e,this.startColumn+t,r),this}get(e,t){return this.matrix.get(this.startRow+e,this.startColumn+t)}}class zht extends qf{constructor(e){super(e,e.columns,e.rows)}set(e,t,r){return this.matrix.set(t,e,r),this}get(e,t){return this.matrix.get(t,e)}}class hoe extends Gn{constructor(e,t={}){const{rows:r=1}=t;if(e.length%r!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=e.length/r,this.data=e}set(e,t,r){let s=this._calculateIndex(e,t);return this.data[s]=r,this}get(e,t){let r=this._calculateIndex(e,t);return this.data[r]}_calculateIndex(e,t){return e*this.columns+t}}class $l extends Gn{constructor(e){super(),this.data=e,this.rows=e.length,this.columns=e[0].length}set(e,t,r){return this.data[e][t]=r,this}get(e,t){return this.data[e][t]}}function Bht(n,e){if(Va.isAnyArray(n))return n[0]&&Va.isAnyArray(n[0])?new $l(n):new hoe(n,e);throw new Error("the argument is not an array")}class I${constructor(e){e=$l.checkMatrix(e);let t=e.clone(),r=t.rows,s=t.columns,i=new Float64Array(r),o=1,a,l,c,u,h,f,d,p,m;for(a=0;a<r;a++)i[a]=a;for(p=new Float64Array(r),l=0;l<s;l++){for(a=0;a<r;a++)p[a]=t.get(a,l);for(a=0;a<r;a++){for(m=Math.min(a,l),h=0,c=0;c<m;c++)h+=t.get(a,c)*p[c];p[a]-=h,t.set(a,l,p[a])}for(u=l,a=l+1;a<r;a++)Math.abs(p[a])>Math.abs(p[u])&&(u=a);if(u!==l){for(c=0;c<s;c++)f=t.get(u,c),t.set(u,c,t.get(l,c)),t.set(l,c,f);d=i[u],i[u]=i[l],i[l]=d,o=-o}if(l<r&&t.get(l,l)!==0)for(a=l+1;a<r;a++)t.set(a,l,t.get(a,l)/t.get(l,l))}this.LU=t,this.pivotVector=i,this.pivotSign=o}isSingular(){let e=this.LU,t=e.columns;for(let r=0;r<t;r++)if(e.get(r,r)===0)return!0;return!1}solve(e){e=Wt.checkMatrix(e);let t=this.LU;if(t.rows!==e.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let s=e.columns,i=e.subMatrixRow(this.pivotVector,0,s-1),o=t.columns,a,l,c;for(c=0;c<o;c++)for(a=c+1;a<o;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c));for(c=o-1;c>=0;c--){for(l=0;l<s;l++)i.set(c,l,i.get(c,l)/t.get(c,c));for(a=0;a<c;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c))}return i}get determinant(){let e=this.LU;if(!e.isSquare())throw new Error("Matrix must be square");let t=this.pivotSign,r=e.columns;for(let s=0;s<r;s++)t*=e.get(s,s);return t}get lowerTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,s=new Wt(t,r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)i>o?s.set(i,o,e.get(i,o)):i===o?s.set(i,o,1):s.set(i,o,0);return s}get upperTriangularMatrix(){let e=this.LU,t=e.rows,r=e.columns,s=new Wt(t,r);for(let i=0;i<t;i++)for(let o=0;o<r;o++)i<=o?s.set(i,o,e.get(i,o)):s.set(i,o,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function bf(n,e){let t=0;return Math.abs(n)>Math.abs(e)?(t=e/n,Math.abs(n)*Math.sqrt(1+t*t)):e!==0?(t=n/e,Math.abs(e)*Math.sqrt(1+t*t)):0}class q4{constructor(e){e=$l.checkMatrix(e);let t=e.clone(),r=e.rows,s=e.columns,i=new Float64Array(s),o,a,l,c;for(l=0;l<s;l++){let u=0;for(o=l;o<r;o++)u=bf(u,t.get(o,l));if(u!==0){for(t.get(l,l)<0&&(u=-u),o=l;o<r;o++)t.set(o,l,t.get(o,l)/u);for(t.set(l,l,t.get(l,l)+1),a=l+1;a<s;a++){for(c=0,o=l;o<r;o++)c+=t.get(o,l)*t.get(o,a);for(c=-c/t.get(l,l),o=l;o<r;o++)t.set(o,a,t.get(o,a)+c*t.get(o,l))}}i[l]=-u}this.QR=t,this.Rdiag=i}solve(e){e=Wt.checkMatrix(e);let t=this.QR,r=t.rows;if(e.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s=e.columns,i=e.clone(),o=t.columns,a,l,c,u;for(c=0;c<o;c++)for(l=0;l<s;l++){for(u=0,a=c;a<r;a++)u+=t.get(a,c)*i.get(a,l);for(u=-u/t.get(c,c),a=c;a<r;a++)i.set(a,l,i.get(a,l)+u*t.get(a,c))}for(c=o-1;c>=0;c--){for(l=0;l<s;l++)i.set(c,l,i.get(c,l)/this.Rdiag[c]);for(a=0;a<c;a++)for(l=0;l<s;l++)i.set(a,l,i.get(a,l)-i.get(c,l)*t.get(a,c))}return i.subMatrix(0,o-1,0,s-1)}isFullRank(){let e=this.QR.columns;for(let t=0;t<e;t++)if(this.Rdiag[t]===0)return!1;return!0}get upperTriangularMatrix(){let e=this.QR,t=e.columns,r=new Wt(t,t),s,i;for(s=0;s<t;s++)for(i=0;i<t;i++)s<i?r.set(s,i,e.get(s,i)):s===i?r.set(s,i,this.Rdiag[s]):r.set(s,i,0);return r}get orthogonalMatrix(){let e=this.QR,t=e.rows,r=e.columns,s=new Wt(t,r),i,o,a,l;for(a=r-1;a>=0;a--){for(i=0;i<t;i++)s.set(i,a,0);for(s.set(a,a,1),o=a;o<r;o++)if(e.get(a,a)!==0){for(l=0,i=a;i<t;i++)l+=e.get(i,a)*s.get(i,o);for(l=-l/e.get(a,a),i=a;i<t;i++)s.set(i,o,s.get(i,o)+l*e.get(i,a))}}return s}}class nx{constructor(e,t={}){if(e=$l.checkMatrix(e),e.isEmpty())throw new Error("Matrix must be non-empty");let r=e.rows,s=e.columns;const{computeLeftSingularVectors:i=!0,computeRightSingularVectors:o=!0,autoTranspose:a=!1}=t;let l=!!i,c=!!o,u=!1,h;if(r<s)if(!a)h=e.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{h=e.transpose(),r=h.rows,s=h.columns,u=!0;let E=l;l=c,c=E}else h=e.clone();let f=Math.min(r,s),d=Math.min(r+1,s),p=new Float64Array(d),m=new Wt(r,f),g=new Wt(s,s),y=new Float64Array(s),b=new Float64Array(r),x=new Float64Array(d);for(let E=0;E<d;E++)x[E]=E;let w=Math.min(r-1,s),S=Math.max(0,Math.min(s-2,r)),C=Math.max(w,S);for(let E=0;E<C;E++){if(E<w){p[E]=0;for(let N=E;N<r;N++)p[E]=bf(p[E],h.get(N,E));if(p[E]!==0){h.get(E,E)<0&&(p[E]=-p[E]);for(let N=E;N<r;N++)h.set(N,E,h.get(N,E)/p[E]);h.set(E,E,h.get(E,E)+1)}p[E]=-p[E]}for(let N=E+1;N<s;N++){if(E<w&&p[E]!==0){let O=0;for(let R=E;R<r;R++)O+=h.get(R,E)*h.get(R,N);O=-O/h.get(E,E);for(let R=E;R<r;R++)h.set(R,N,h.get(R,N)+O*h.get(R,E))}y[N]=h.get(E,N)}if(l&&E<w)for(let N=E;N<r;N++)m.set(N,E,h.get(N,E));if(E<S){y[E]=0;for(let N=E+1;N<s;N++)y[E]=bf(y[E],y[N]);if(y[E]!==0){y[E+1]<0&&(y[E]=0-y[E]);for(let N=E+1;N<s;N++)y[N]/=y[E];y[E+1]+=1}if(y[E]=-y[E],E+1<r&&y[E]!==0){for(let N=E+1;N<r;N++)b[N]=0;for(let N=E+1;N<r;N++)for(let O=E+1;O<s;O++)b[N]+=y[O]*h.get(N,O);for(let N=E+1;N<s;N++){let O=-y[N]/y[E+1];for(let R=E+1;R<r;R++)h.set(R,N,h.get(R,N)+O*b[R])}}if(c)for(let N=E+1;N<s;N++)g.set(N,E,y[N])}}let k=Math.min(s,r+1);if(w<s&&(p[w]=h.get(w,w)),r<k&&(p[k-1]=0),S+1<k&&(y[S]=h.get(S,k-1)),y[k-1]=0,l){for(let E=w;E<f;E++){for(let N=0;N<r;N++)m.set(N,E,0);m.set(E,E,1)}for(let E=w-1;E>=0;E--)if(p[E]!==0){for(let N=E+1;N<f;N++){let O=0;for(let R=E;R<r;R++)O+=m.get(R,E)*m.get(R,N);O=-O/m.get(E,E);for(let R=E;R<r;R++)m.set(R,N,m.get(R,N)+O*m.get(R,E))}for(let N=E;N<r;N++)m.set(N,E,-m.get(N,E));m.set(E,E,1+m.get(E,E));for(let N=0;N<E-1;N++)m.set(N,E,0)}else{for(let N=0;N<r;N++)m.set(N,E,0);m.set(E,E,1)}}if(c)for(let E=s-1;E>=0;E--){if(E<S&&y[E]!==0)for(let N=E+1;N<s;N++){let O=0;for(let R=E+1;R<s;R++)O+=g.get(R,E)*g.get(R,N);O=-O/g.get(E+1,E);for(let R=E+1;R<s;R++)g.set(R,N,g.get(R,N)+O*g.get(R,E))}for(let N=0;N<s;N++)g.set(N,E,0);g.set(E,E,1)}let A=k-1,M=Number.EPSILON;for(;k>0;){let E,N;for(E=k-2;E>=-1&&E!==-1;E--){const O=Number.MIN_VALUE+M*Math.abs(p[E]+Math.abs(p[E+1]));if(Math.abs(y[E])<=O||Number.isNaN(y[E])){y[E]=0;break}}if(E===k-2)N=4;else{let O;for(O=k-1;O>=E&&O!==E;O--){let R=(O!==k?Math.abs(y[O]):0)+(O!==E+1?Math.abs(y[O-1]):0);if(Math.abs(p[O])<=M*R){p[O]=0;break}}O===E?N=3:O===k-1?N=1:(N=2,E=O)}switch(E++,N){case 1:{let O=y[k-2];y[k-2]=0;for(let R=k-2;R>=E;R--){let D=bf(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,R!==E&&(O=-B*y[R-1],y[R-1]=z*y[R-1]),c)for(let X=0;X<s;X++)D=z*g.get(X,R)+B*g.get(X,k-1),g.set(X,k-1,-B*g.get(X,R)+z*g.get(X,k-1)),g.set(X,R,D)}break}case 2:{let O=y[E-1];y[E-1]=0;for(let R=E;R<k;R++){let D=bf(p[R],O),z=p[R]/D,B=O/D;if(p[R]=D,O=-B*y[R],y[R]=z*y[R],l)for(let X=0;X<r;X++)D=z*m.get(X,R)+B*m.get(X,E-1),m.set(X,E-1,-B*m.get(X,R)+z*m.get(X,E-1)),m.set(X,R,D)}break}case 3:{const O=Math.max(Math.abs(p[k-1]),Math.abs(p[k-2]),Math.abs(y[k-2]),Math.abs(p[E]),Math.abs(y[E])),R=p[k-1]/O,D=p[k-2]/O,z=y[k-2]/O,B=p[E]/O,X=y[E]/O,G=((D+R)*(D-R)+z*z)/2,te=R*z*(R*z);let ge=0;(G!==0||te!==0)&&(G<0?ge=0-Math.sqrt(G*G+te):ge=Math.sqrt(G*G+te),ge=te/(G+ge));let ae=(B+R)*(B-R)+ge,Ne=B*X;for(let ke=E;ke<k-1;ke++){let De=bf(ae,Ne);De===0&&(De=Number.MIN_VALUE);let be=ae/De,Xe=Ne/De;if(ke!==E&&(y[ke-1]=De),ae=be*p[ke]+Xe*y[ke],y[ke]=be*y[ke]-Xe*p[ke],Ne=Xe*p[ke+1],p[ke+1]=be*p[ke+1],c)for(let Oe=0;Oe<s;Oe++)De=be*g.get(Oe,ke)+Xe*g.get(Oe,ke+1),g.set(Oe,ke+1,-Xe*g.get(Oe,ke)+be*g.get(Oe,ke+1)),g.set(Oe,ke,De);if(De=bf(ae,Ne),De===0&&(De=Number.MIN_VALUE),be=ae/De,Xe=Ne/De,p[ke]=De,ae=be*y[ke]+Xe*p[ke+1],p[ke+1]=-Xe*y[ke]+be*p[ke+1],Ne=Xe*y[ke+1],y[ke+1]=be*y[ke+1],l&&ke<r-1)for(let Oe=0;Oe<r;Oe++)De=be*m.get(Oe,ke)+Xe*m.get(Oe,ke+1),m.set(Oe,ke+1,-Xe*m.get(Oe,ke)+be*m.get(Oe,ke+1)),m.set(Oe,ke,De)}y[k-2]=ae;break}case 4:{if(p[E]<=0&&(p[E]=p[E]<0?-p[E]:0,c))for(let O=0;O<=A;O++)g.set(O,E,-g.get(O,E));for(;E<A&&!(p[E]>=p[E+1]);){let O=p[E];if(p[E]=p[E+1],p[E+1]=O,c&&E<s-1)for(let R=0;R<s;R++)O=g.get(R,E+1),g.set(R,E+1,g.get(R,E)),g.set(R,E,O);if(l&&E<r-1)for(let R=0;R<r;R++)O=m.get(R,E+1),m.set(R,E+1,m.get(R,E)),m.set(R,E,O);E++}k--;break}}}if(u){let E=g;g=m,m=E}this.m=r,this.n=s,this.s=p,this.U=m,this.V=g}solve(e){let t=e,r=this.threshold,s=this.s.length,i=Wt.zeros(s,s);for(let f=0;f<s;f++)Math.abs(this.s[f])<=r?i.set(f,f,0):i.set(f,f,1/this.s[f]);let o=this.U,a=this.rightSingularVectors,l=a.mmul(i),c=a.rows,u=o.rows,h=Wt.zeros(c,u);for(let f=0;f<c;f++)for(let d=0;d<u;d++){let p=0;for(let m=0;m<s;m++)p+=l.get(f,m)*o.get(d,m);h.set(f,d,p)}return h.mmul(t)}solveForDiagonal(e){return this.solve(Wt.diag(e))}inverse(){let e=this.V,t=this.threshold,r=e.rows,s=e.columns,i=new Wt(r,this.s.length);for(let u=0;u<r;u++)for(let h=0;h<s;h++)Math.abs(this.s[h])>t&&i.set(u,h,e.get(u,h)/this.s[h]);let o=this.U,a=o.rows,l=o.columns,c=new Wt(r,a);for(let u=0;u<r;u++)for(let h=0;h<a;h++){let f=0;for(let d=0;d<l;d++)f+=i.get(u,d)*o.get(h,d);c.set(u,h,f)}return c}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let e=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,t=0,r=this.s;for(let s=0,i=r.length;s<i;s++)r[s]>e&&t++;return t}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Wt.diag(this.s)}}function Vht(n,e=!1){return n=$l.checkMatrix(n),e?new nx(n).inverse():foe(n,Wt.eye(n.rows))}function foe(n,e,t=!1){return n=$l.checkMatrix(n),e=$l.checkMatrix(e),t?new nx(n).solve(e):n.isSquare()?new I$(n).solve(e):new q4(n).solve(e)}function tI(n){if(n=Wt.checkMatrix(n),n.isSquare()){if(n.columns===0)return 1;let e,t,r,s;if(n.columns===2)return e=n.get(0,0),t=n.get(0,1),r=n.get(1,0),s=n.get(1,1),e*s-t*r;if(n.columns===3){let i,o,a;return i=new eI(n,[1,2],[1,2]),o=new eI(n,[1,2],[0,2]),a=new eI(n,[1,2],[0,1]),e=n.get(0,0),t=n.get(0,1),r=n.get(0,2),e*tI(i)-t*tI(o)+r*tI(a)}else return new I$(n).determinant}else throw Error("determinant can only be calculated for a square matrix")}function Uht(n,e){let t=[];for(let r=0;r<n;r++)r!==e&&t.push(r);return t}function Wht(n,e,t,r=1e-9,s=1e-9){if(n>s)return new Array(e.rows+1).fill(0);{let i=e.addRow(t,[0]);for(let o=0;o<i.rows;o++)Math.abs(i.get(o,0))<r&&i.set(o,0,0);return i.to1DArray()}}function Ght(n,e={}){const{thresholdValue:t=1e-9,thresholdError:r=1e-9}=e;n=Wt.checkMatrix(n);let s=n.rows,i=new Wt(s,s);for(let o=0;o<s;o++){let a=Wt.columnVector(n.getRow(o)),l=n.subMatrixRow(Uht(s,o)).transpose(),u=new nx(l).solve(a),h=Wt.sub(a,l.mmul(u)).abs().max();i.setRow(o,Wht(h,u,o,t,r))}return i}function Hht(n,e=Number.EPSILON){if(n=Wt.checkMatrix(n),n.isEmpty())return n.transpose();let t=new nx(n,{autoTranspose:!0}),r=t.leftSingularVectors,s=t.rightSingularVectors,i=t.diagonal;for(let o=0;o<i.length;o++)Math.abs(i[o])>e?i[o]=1/i[o]:i[o]=0;return s.mmul(Wt.diag(i).mmul(r.transpose()))}function jht(n,e=n,t={}){n=new Wt(n);let r=!1;if(typeof e=="object"&&!Wt.isMatrix(e)&&!Va.isAnyArray(e)?(t=e,e=n,r=!0):e=new Wt(e),n.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0}=t;s&&(n=n.center("column"),r||(e=e.center("column")));const i=n.transpose().mmul(e);for(let o=0;o<i.rows;o++)for(let a=0;a<i.columns;a++)i.set(o,a,i.get(o,a)*(1/(n.rows-1)));return i}function qht(n,e=n,t={}){n=new Wt(n);let r=!1;if(typeof e=="object"&&!Wt.isMatrix(e)&&!Va.isAnyArray(e)?(t=e,e=n,r=!0):e=new Wt(e),n.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0,scale:i=!0}=t;s&&(n.center("column"),r||e.center("column")),i&&(n.scale("column"),r||e.scale("column"));const o=n.standardDeviation("column",{unbiased:!0}),a=r?o:e.standardDeviation("column",{unbiased:!0}),l=n.transpose().mmul(e);for(let c=0;c<l.rows;c++)for(let u=0;u<l.columns;u++)l.set(c,u,l.get(c,u)*(1/(o[c]*a[u]))*(1/(n.rows-1)));return l}class doe{constructor(e,t={}){const{assumeSymmetric:r=!1}=t;if(e=$l.checkMatrix(e),!e.isSquare())throw new Error("Matrix is not a square matrix");if(e.isEmpty())throw new Error("Matrix must be non-empty");let s=e.columns,i=new Wt(s,s),o=new Float64Array(s),a=new Float64Array(s),l=e,c,u,h=!1;if(r?h=!0:h=e.isSymmetric(),h){for(c=0;c<s;c++)for(u=0;u<s;u++)i.set(c,u,l.get(c,u));Xht(s,a,o,i),Kht(s,a,o,i)}else{let f=new Wt(s,s),d=new Float64Array(s);for(u=0;u<s;u++)for(c=0;c<s;c++)f.set(c,u,l.get(c,u));Yht(s,f,d,i),Zht(s,a,o,i,f)}this.n=s,this.e=a,this.d=o,this.V=i}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let e=this.n,t=this.e,r=this.d,s=new Wt(e,e),i,o;for(i=0;i<e;i++){for(o=0;o<e;o++)s.set(i,o,0);s.set(i,i,r[i]),t[i]>0?s.set(i,i+1,t[i]):t[i]<0&&s.set(i,i-1,t[i])}return s}}function Xht(n,e,t,r){let s,i,o,a,l,c,u,h;for(l=0;l<n;l++)t[l]=r.get(n-1,l);for(a=n-1;a>0;a--){for(h=0,o=0,c=0;c<a;c++)h=h+Math.abs(t[c]);if(h===0)for(e[a]=t[a-1],l=0;l<a;l++)t[l]=r.get(a-1,l),r.set(a,l,0),r.set(l,a,0);else{for(c=0;c<a;c++)t[c]/=h,o+=t[c]*t[c];for(s=t[a-1],i=Math.sqrt(o),s>0&&(i=-i),e[a]=h*i,o=o-s*i,t[a-1]=s-i,l=0;l<a;l++)e[l]=0;for(l=0;l<a;l++){for(s=t[l],r.set(l,a,s),i=e[l]+r.get(l,l)*s,c=l+1;c<=a-1;c++)i+=r.get(c,l)*t[c],e[c]+=r.get(c,l)*s;e[l]=i}for(s=0,l=0;l<a;l++)e[l]/=o,s+=e[l]*t[l];for(u=s/(o+o),l=0;l<a;l++)e[l]-=u*t[l];for(l=0;l<a;l++){for(s=t[l],i=e[l],c=l;c<=a-1;c++)r.set(c,l,r.get(c,l)-(s*e[c]+i*t[c]));t[l]=r.get(a-1,l),r.set(a,l,0)}}t[a]=o}for(a=0;a<n-1;a++){if(r.set(n-1,a,r.get(a,a)),r.set(a,a,1),o=t[a+1],o!==0){for(c=0;c<=a;c++)t[c]=r.get(c,a+1)/o;for(l=0;l<=a;l++){for(i=0,c=0;c<=a;c++)i+=r.get(c,a+1)*r.get(c,l);for(c=0;c<=a;c++)r.set(c,l,r.get(c,l)-i*t[c])}}for(c=0;c<=a;c++)r.set(c,a+1,0)}for(l=0;l<n;l++)t[l]=r.get(n-1,l),r.set(n-1,l,0);r.set(n-1,n-1,1),e[0]=0}function Kht(n,e,t,r){let s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x;for(o=1;o<n;o++)e[o-1]=e[o];e[n-1]=0;let w=0,S=0,C=Number.EPSILON;for(c=0;c<n;c++){for(S=Math.max(S,Math.abs(t[c])+Math.abs(e[c])),u=c;u<n&&!(Math.abs(e[u])<=C*S);)u++;if(u>c)do{for(s=t[c],h=(t[c+1]-s)/(2*e[c]),f=bf(h,1),h<0&&(f=-f),t[c]=e[c]/(h+f),t[c+1]=e[c]*(h+f),d=t[c+1],i=s-t[c],o=c+2;o<n;o++)t[o]-=i;for(w=w+i,h=t[u],p=1,m=p,g=p,y=e[c+1],b=0,x=0,o=u-1;o>=c;o--)for(g=m,m=p,x=b,s=p*e[o],i=p*h,f=bf(h,e[o]),e[o+1]=b*f,b=e[o]/f,p=h/f,h=p*t[o]-b*s,t[o+1]=i+b*(p*s+b*t[o]),l=0;l<n;l++)i=r.get(l,o+1),r.set(l,o+1,b*r.get(l,o)+p*i),r.set(l,o,p*r.get(l,o)-b*i);h=-b*x*g*y*e[c]/d,e[c]=b*h,t[c]=p*h}while(Math.abs(e[c])>C*S);t[c]=t[c]+w,e[c]=0}for(o=0;o<n-1;o++){for(l=o,h=t[o],a=o+1;a<n;a++)t[a]<h&&(l=a,h=t[a]);if(l!==o)for(t[l]=t[o],t[o]=h,a=0;a<n;a++)h=r.get(a,o),r.set(a,o,r.get(a,l)),r.set(a,l,h)}}function Yht(n,e,t,r){let s=0,i=n-1,o,a,l,c,u,h,f;for(h=s+1;h<=i-1;h++){for(f=0,c=h;c<=i;c++)f=f+Math.abs(e.get(c,h-1));if(f!==0){for(l=0,c=i;c>=h;c--)t[c]=e.get(c,h-1)/f,l+=t[c]*t[c];for(a=Math.sqrt(l),t[h]>0&&(a=-a),l=l-t[h]*a,t[h]=t[h]-a,u=h;u<n;u++){for(o=0,c=i;c>=h;c--)o+=t[c]*e.get(c,u);for(o=o/l,c=h;c<=i;c++)e.set(c,u,e.get(c,u)-o*t[c])}for(c=0;c<=i;c++){for(o=0,u=i;u>=h;u--)o+=t[u]*e.get(c,u);for(o=o/l,u=h;u<=i;u++)e.set(c,u,e.get(c,u)-o*t[u])}t[h]=f*t[h],e.set(h,h-1,f*a)}}for(c=0;c<n;c++)for(u=0;u<n;u++)r.set(c,u,c===u?1:0);for(h=i-1;h>=s+1;h--)if(e.get(h,h-1)!==0){for(c=h+1;c<=i;c++)t[c]=e.get(c,h-1);for(u=h;u<=i;u++){for(a=0,c=h;c<=i;c++)a+=t[c]*r.get(c,u);for(a=a/t[h]/e.get(h,h-1),c=h;c<=i;c++)r.set(c,u,r.get(c,u)+a*t[c])}}}function Zht(n,e,t,r,s){let i=n-1,o=0,a=n-1,l=Number.EPSILON,c=0,u=0,h=0,f=0,d=0,p=0,m=0,g=0,y,b,x,w,S,C,k,A,M,E,N,O,R,D,z;for(y=0;y<n;y++)for((y<o||y>a)&&(t[y]=s.get(y,y),e[y]=0),b=Math.max(y-1,0);b<n;b++)u=u+Math.abs(s.get(y,b));for(;i>=o;){for(w=i;w>o&&(p=Math.abs(s.get(w-1,w-1))+Math.abs(s.get(w,w)),p===0&&(p=u),!(Math.abs(s.get(w,w-1))<l*p));)w--;if(w===i)s.set(i,i,s.get(i,i)+c),t[i]=s.get(i,i),e[i]=0,i--,g=0;else if(w===i-1){if(k=s.get(i,i-1)*s.get(i-1,i),h=(s.get(i-1,i-1)-s.get(i,i))/2,f=h*h+k,m=Math.sqrt(Math.abs(f)),s.set(i,i,s.get(i,i)+c),s.set(i-1,i-1,s.get(i-1,i-1)+c),A=s.get(i,i),f>=0){for(m=h>=0?h+m:h-m,t[i-1]=A+m,t[i]=t[i-1],m!==0&&(t[i]=A-k/m),e[i-1]=0,e[i]=0,A=s.get(i,i-1),p=Math.abs(A)+Math.abs(m),h=A/p,f=m/p,d=Math.sqrt(h*h+f*f),h=h/d,f=f/d,b=i-1;b<n;b++)m=s.get(i-1,b),s.set(i-1,b,f*m+h*s.get(i,b)),s.set(i,b,f*s.get(i,b)-h*m);for(y=0;y<=i;y++)m=s.get(y,i-1),s.set(y,i-1,f*m+h*s.get(y,i)),s.set(y,i,f*s.get(y,i)-h*m);for(y=o;y<=a;y++)m=r.get(y,i-1),r.set(y,i-1,f*m+h*r.get(y,i)),r.set(y,i,f*r.get(y,i)-h*m)}else t[i-1]=A+h,t[i]=A+h,e[i-1]=m,e[i]=-m;i=i-2,g=0}else{if(A=s.get(i,i),M=0,k=0,w<i&&(M=s.get(i-1,i-1),k=s.get(i,i-1)*s.get(i-1,i)),g===10){for(c+=A,y=o;y<=i;y++)s.set(y,y,s.get(y,y)-A);p=Math.abs(s.get(i,i-1))+Math.abs(s.get(i-1,i-2)),A=M=.75*p,k=-.4375*p*p}if(g===30&&(p=(M-A)/2,p=p*p+k,p>0)){for(p=Math.sqrt(p),M<A&&(p=-p),p=A-k/((M-A)/2+p),y=o;y<=i;y++)s.set(y,y,s.get(y,y)-p);c+=p,A=M=k=.964}for(g=g+1,S=i-2;S>=w&&(m=s.get(S,S),d=A-m,p=M-m,h=(d*p-k)/s.get(S+1,S)+s.get(S,S+1),f=s.get(S+1,S+1)-m-d-p,d=s.get(S+2,S+1),p=Math.abs(h)+Math.abs(f)+Math.abs(d),h=h/p,f=f/p,d=d/p,!(S===w||Math.abs(s.get(S,S-1))*(Math.abs(f)+Math.abs(d))<l*(Math.abs(h)*(Math.abs(s.get(S-1,S-1))+Math.abs(m)+Math.abs(s.get(S+1,S+1))))));)S--;for(y=S+2;y<=i;y++)s.set(y,y-2,0),y>S+2&&s.set(y,y-3,0);for(x=S;x<=i-1&&(D=x!==i-1,x!==S&&(h=s.get(x,x-1),f=s.get(x+1,x-1),d=D?s.get(x+2,x-1):0,A=Math.abs(h)+Math.abs(f)+Math.abs(d),A!==0&&(h=h/A,f=f/A,d=d/A)),A!==0);x++)if(p=Math.sqrt(h*h+f*f+d*d),h<0&&(p=-p),p!==0){for(x!==S?s.set(x,x-1,-p*A):w!==S&&s.set(x,x-1,-s.get(x,x-1)),h=h+p,A=h/p,M=f/p,m=d/p,f=f/h,d=d/h,b=x;b<n;b++)h=s.get(x,b)+f*s.get(x+1,b),D&&(h=h+d*s.get(x+2,b),s.set(x+2,b,s.get(x+2,b)-h*m)),s.set(x,b,s.get(x,b)-h*A),s.set(x+1,b,s.get(x+1,b)-h*M);for(y=0;y<=Math.min(i,x+3);y++)h=A*s.get(y,x)+M*s.get(y,x+1),D&&(h=h+m*s.get(y,x+2),s.set(y,x+2,s.get(y,x+2)-h*d)),s.set(y,x,s.get(y,x)-h),s.set(y,x+1,s.get(y,x+1)-h*f);for(y=o;y<=a;y++)h=A*r.get(y,x)+M*r.get(y,x+1),D&&(h=h+m*r.get(y,x+2),r.set(y,x+2,r.get(y,x+2)-h*d)),r.set(y,x,r.get(y,x)-h),r.set(y,x+1,r.get(y,x+1)-h*f)}}}if(u!==0){for(i=n-1;i>=0;i--)if(h=t[i],f=e[i],f===0)for(w=i,s.set(i,i,1),y=i-1;y>=0;y--){for(k=s.get(y,y)-h,d=0,b=w;b<=i;b++)d=d+s.get(y,b)*s.get(b,i);if(e[y]<0)m=k,p=d;else if(w=y,e[y]===0?s.set(y,i,k!==0?-d/k:-d/(l*u)):(A=s.get(y,y+1),M=s.get(y+1,y),f=(t[y]-h)*(t[y]-h)+e[y]*e[y],C=(A*p-m*d)/f,s.set(y,i,C),s.set(y+1,i,Math.abs(A)>Math.abs(m)?(-d-k*C)/A:(-p-M*C)/m)),C=Math.abs(s.get(y,i)),l*C*C>1)for(b=y;b<=i;b++)s.set(b,i,s.get(b,i)/C)}else if(f<0)for(w=i-1,Math.abs(s.get(i,i-1))>Math.abs(s.get(i-1,i))?(s.set(i-1,i-1,f/s.get(i,i-1)),s.set(i-1,i,-(s.get(i,i)-h)/s.get(i,i-1))):(z=RT(0,-s.get(i-1,i),s.get(i-1,i-1)-h,f),s.set(i-1,i-1,z[0]),s.set(i-1,i,z[1])),s.set(i,i-1,0),s.set(i,i,1),y=i-2;y>=0;y--){for(E=0,N=0,b=w;b<=i;b++)E=E+s.get(y,b)*s.get(b,i-1),N=N+s.get(y,b)*s.get(b,i);if(k=s.get(y,y)-h,e[y]<0)m=k,d=E,p=N;else if(w=y,e[y]===0?(z=RT(-E,-N,k,f),s.set(y,i-1,z[0]),s.set(y,i,z[1])):(A=s.get(y,y+1),M=s.get(y+1,y),O=(t[y]-h)*(t[y]-h)+e[y]*e[y]-f*f,R=(t[y]-h)*2*f,O===0&&R===0&&(O=l*u*(Math.abs(k)+Math.abs(f)+Math.abs(A)+Math.abs(M)+Math.abs(m))),z=RT(A*d-m*E+f*N,A*p-m*N-f*E,O,R),s.set(y,i-1,z[0]),s.set(y,i,z[1]),Math.abs(A)>Math.abs(m)+Math.abs(f)?(s.set(y+1,i-1,(-E-k*s.get(y,i-1)+f*s.get(y,i))/A),s.set(y+1,i,(-N-k*s.get(y,i)-f*s.get(y,i-1))/A)):(z=RT(-d-M*s.get(y,i-1),-p-M*s.get(y,i),m,f),s.set(y+1,i-1,z[0]),s.set(y+1,i,z[1]))),C=Math.max(Math.abs(s.get(y,i-1)),Math.abs(s.get(y,i))),l*C*C>1)for(b=y;b<=i;b++)s.set(b,i-1,s.get(b,i-1)/C),s.set(b,i,s.get(b,i)/C)}for(y=0;y<n;y++)if(y<o||y>a)for(b=y;b<n;b++)r.set(y,b,s.get(y,b));for(b=n-1;b>=o;b--)for(y=o;y<=a;y++){for(m=0,x=o;x<=Math.min(b,a);x++)m=m+r.get(y,x)*s.get(x,b);r.set(y,b,m)}}}function RT(n,e,t,r){let s,i;return Math.abs(t)>Math.abs(r)?(s=r/t,i=t+s*r,[(n+s*e)/i,(e-s*n)/i]):(s=t/r,i=r+s*t,[(s*n+e)/i,(s*e-n)/i])}class poe{constructor(e){if(e=$l.checkMatrix(e),!e.isSymmetric())throw new Error("Matrix is not symmetric");let t=e,r=t.rows,s=new Wt(r,r),i=!0,o,a,l;for(a=0;a<r;a++){let c=0;for(l=0;l<a;l++){let u=0;for(o=0;o<l;o++)u+=s.get(l,o)*s.get(a,o);u=(t.get(a,l)-u)/s.get(l,l),s.set(a,l,u),c=c+u*u}for(c=t.get(a,a)-c,i&=c>0,s.set(a,a,Math.sqrt(Math.max(c,0))),l=a+1;l<r;l++)s.set(a,l,0)}this.L=s,this.positiveDefinite=!!i}isPositiveDefinite(){return this.positiveDefinite}solve(e){e=$l.checkMatrix(e);let t=this.L,r=t.rows;if(e.rows!==r)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let s=e.columns,i=e.clone(),o,a,l;for(l=0;l<r;l++)for(a=0;a<s;a++){for(o=0;o<l;o++)i.set(l,a,i.get(l,a)-i.get(o,a)*t.get(l,o));i.set(l,a,i.get(l,a)/t.get(l,l))}for(l=r-1;l>=0;l--)for(a=0;a<s;a++){for(o=l+1;o<r;o++)i.set(l,a,i.get(l,a)-i.get(o,a)*t.get(o,l));i.set(l,a,i.get(l,a)/t.get(l,l))}return i}get lowerTriangularMatrix(){return this.L}}class moe{constructor(e,t={}){e=$l.checkMatrix(e);let{Y:r}=t;const{scaleScores:s=!1,maxIterations:i=1e3,terminationCriteria:o=1e-10}=t;let a;if(r){if(Va.isAnyArray(r)&&typeof r[0]=="number"?r=Wt.columnVector(r):r=$l.checkMatrix(r),r.rows!==e.rows)throw new Error("Y should have the same number of rows as X");a=r.getColumnVector(0)}else a=e.getColumnVector(0);let l=1,c,u,h,f;for(let d=0;d<i&&l>o;d++)h=e.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),h=h.div(h.norm()),c=e.mmul(h).div(h.transpose().mmul(h).get(0,0)),d>0&&(l=c.clone().sub(f).pow(2).sum()),f=c.clone(),r?(u=r.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0)),u=u.div(u.norm()),a=r.mmul(u).div(u.transpose().mmul(u).get(0,0))):a=c;if(r){let d=e.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0));d=d.div(d.norm());let p=e.clone().sub(c.clone().mmul(d.transpose())),m=a.transpose().mmul(c).div(c.transpose().mmul(c).get(0,0)),g=r.clone().sub(c.clone().mulS(m.get(0,0)).mmul(u.transpose()));this.t=c,this.p=d.transpose(),this.w=h.transpose(),this.q=u,this.u=a,this.s=c.transpose().mmul(c),this.xResidual=p,this.yResidual=g,this.betas=m}else this.w=h.transpose(),this.s=c.transpose().mmul(c).sqrt(),s?this.t=c.clone().div(this.s.get(0,0)):this.t=c,this.xResidual=e.sub(c.mmul(h.transpose()))}}cr.AbstractMatrix=Gn;cr.CHO=poe;cr.CholeskyDecomposition=poe;cr.EVD=doe;cr.EigenvalueDecomposition=doe;cr.LU=I$;cr.LuDecomposition=I$;cr.Matrix=Wt;cr.MatrixColumnSelectionView=Rht;cr.MatrixColumnView=$ht;cr.MatrixFlipColumnView=Pht;cr.MatrixFlipRowView=Dht;cr.MatrixRowSelectionView=Fht;cr.MatrixRowView=Oht;cr.MatrixSelectionView=eI;cr.MatrixSubView=Lht;cr.MatrixTransposeView=zht;cr.NIPALS=moe;cr.Nipals=moe;cr.QR=q4;cr.QrDecomposition=q4;cr.SVD=nx;cr.SingularValueDecomposition=nx;cr.WrapperMatrix1D=hoe;cr.WrapperMatrix2D=$l;cr.correlation=qht;cr.covariance=jht;cr.default=Wt;cr.determinant=tI;cr.inverse=Vht;cr.linearDependencies=Ght;cr.pseudoInverse=Hht;cr.solve=foe;cr.wrap=Bht;const ch=cr.Matrix,Jht=cr.inverse;function Qht(n,e,t){return new G4(t).choice(n,{size:e})}function eft(n,e,t,r){const s=new G4(r);var i=new Array(e);if(i[0]=Math.floor(s.random()*n.length),e>1){for(var o={dist:-1,index:-1},a=0;a<n.length;++a)t[i[0]][a]>o.dist&&(o.dist=t[i[0]][a],o.index=a);if(i[1]=o.index,e>2)for(var l=2;l<e;++l){for(var c={dist:-1,index:-1},u=0;u<n.length;++u){for(var h={dist:Number.MAX_VALUE,index:-1},f=0;f<l;++f)t[f][u]<h.dist&&i.indexOf(u)===-1&&(h={dist:t[f][u],index:u});h.dist!==Number.MAX_VALUE&&h.dist>c.dist&&(c=Object.assign({},h))}i[l]=c.index}}return i.map(d=>n[d])}function tft(n,e,t={}){n=new ch(n);const r=n.rows,s=new G4(t.seed),i=[],o=t.localTrials||2+Math.floor(Math.log(e)),a=s.randInt(r);i.push(n.getRow(a));let l=new ch(1,n.rows);for(let f=0;f<n.rows;f++)l.set(0,f,T$(n.getRow(f),i[0]));let c=[Aj(l.getRow(0))];const u=1/c[0][r-1];let h=ch.mul(l,u);for(let f=1;f<e;f++){const d=s.choice(r,{replace:!0,size:o,probabilities:h[0]}),p=n.selection(d,rft(n.columns)),m=nft(p,n);let g,y,b;for(let x=0;x<o;x++){const w=ch.min(l,[m.getRow(x)]),S=w.sum();(g===void 0||S<y)&&(g=d[x],y=S,b=w)}i[f]=n.getRow(g),l=b,c=[Aj(l.getRow(0))],h=ch.mul(l,1/c[0][r-1])}return i}function nft(n,e){const t=new ch(n.rows,e.rows);for(let r=0;r<n.rows;r++)for(let s=0;s<e.rows;s++)t.set(r,s,T$(n.getRow(r),e.getRow(s)));return t}function rft(n){let e=[];for(let t=0;t<n;t++)e.push(t);return e}function Aj(n){let e=[n[0]];for(let t=1;t<n.length;t++)e[t]=e[t-1]+n[t];return e}const PT=Symbol("distance");class X4{constructor(e,t,r,s,i){this.clusters=e,this.centroids=t,this.converged=r,this.iterations=s,this[PT]=i}nearest(e){const t=new Array(e.length),r=this.centroids.map(function(s){return s.centroid});return aoe(e,r,t,this[PT])}computeInformation(e){for(var t=this.centroids.map(function(i){return{centroid:i,error:0,size:0}}),r=0;r<e.length;r++)t[this.clusters[r]].error+=this[PT](e[r],this.centroids[this.clusters[r]]),t[this.clusters[r]].size++;for(var s=0;s<this.centroids.length;s++)t[s].size?t[s].error/=t[s].size:t[s].error=null;return new X4(this.clusters,t,this.converged,this.iterations,this[PT])}}const sft={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:T$};function goe(n,e,t,r,s,i){t=aoe(e,n,t,s.distanceFunction);var o=Gut(n,e,t,r),a=Hut(o,n,s.distanceFunction,s.tolerance);return new X4(t,o,a,i,s.distanceFunction)}function*ift(n,e,t,r,s){for(var i=!1,o=0,a;!i&&o<s.maxIterations;)a=goe(n,e,t,r,s,++o),yield a.computeInformation(e),i=a.converged,n=a.centroids}function oft(n,e,t){if(t=Object.assign({},sft,t),e<=0||e>n.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var r;if(Array.isArray(t.initialization)){if(t.initialization.length!==e)throw new Error("The initial centers should have the same length as K");r=t.initialization}else switch(t.initialization){case"kmeans++":r=tft(n,e,t);break;case"random":r=Qht(n,e,t.seed);break;case"mostDistant":r=eft(n,e,Wut(n,t.distanceFunction),t.seed);break;default:throw new Error(`Unknown initialization method: "${t.initialization}"`)}t.maxIterations===0&&(t.maxIterations=Number.MAX_VALUE);var s=new Array(n.length);if(t.withIterations)return ift(r,n,s,e,t);for(var i=!1,o=0,a;!i&&o<t.maxIterations;)a=goe(r,n,s,e,t,++o),i=a.converged,r=a.centroids;return a.computeInformation(n)}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    *//*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function aft(n,e,t,r){function s(i){return i instanceof t?i:new t(function(o){o(i)})}return new(t||(t=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(h){o(h)}}function l(u){try{c(r.throw(u))}catch(h){o(h)}}function c(u){u.done?i(u.value):s(u.value).then(a,l)}c((r=r.apply(n,e||[])).next())})}function lft(n,e){var t={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},r,s,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(i=c[0]&2?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,s=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(i=t.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){t.label=c[1];break}if(c[0]===6&&t.label<i[1]){t.label=i[1],i=c;break}if(i&&t.label<i[2]){t.label=i[2],t.ops.push(c);break}i[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],s=0}finally{r=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cft(n,e){return n==null&&e==null?null:n==null?e.clone():e===null?n.clone():cs([n,e],0)}function uft(n,e){for(var t=[],r=0;r<n.length;r++)t.push({value:n[r],index:r});t.sort(function(o,a){return a.value-o.value});for(var s=new Float32Array(e),i=new Int32Array(e),r=0;r<e;r++)s[r]=t[r].value,i[r]=t[r].index;return{values:s,indices:i}}var hft=function(){function n(){this.classDatasetMatrices={},this.classExampleCount={},this.labelToClassId={},this.nextClassId=0}return n.prototype.addExample=function(e,t){var r=this;if(this.exampleShape==null&&(this.exampleShape=e.shape),!Rn(this.exampleShape,e.shape))throw new Error("Example shape provided, ".concat(e.shape," does not match ")+"previously provided example shapes ".concat(this.exampleShape,"."));this.clearTrainDatasetMatrix(),t in this.labelToClassId||(this.labelToClassId[t]=this.nextClassId++),Se(function(){var s=r.normalizeVectorToUnitLength(ve(e,[e.size])),i=s.shape[0];if(r.classDatasetMatrices[t]==null)r.classDatasetMatrices[t]=ve(s,[1,i]);else{var o=cs([ve(r.classDatasetMatrices[t],[r.classExampleCount[t],i]),ve(s,[1,i])],0);r.classDatasetMatrices[t].dispose(),r.classDatasetMatrices[t]=o}Xs(r.classDatasetMatrices[t]),r.classExampleCount[t]==null&&(r.classExampleCount[t]=0),r.classExampleCount[t]++})},n.prototype.similarities=function(e){var t=this;return Se(function(){var r=t.normalizeVectorToUnitLength(ve(e,[e.size])),s=r.shape[0];if(t.trainDatasetMatrix==null){var i=null;for(var o in t.classDatasetMatrices)i=cft(i,t.classDatasetMatrices[o]);t.trainDatasetMatrix=i}if(t.trainDatasetMatrix==null)return console.warn("Cannot predict without providing training examples."),null;Xs(t.trainDatasetMatrix);var a=t.getNumExamples();return ve(Hn(ve(t.trainDatasetMatrix,[a,s]),ve(r,[s,1])),[a])})},n.prototype.predictClass=function(e,t){return t===void 0&&(t=3),aft(this,void 0,void 0,function(){var r,s,i,o,a=this;return lft(this,function(l){switch(l.label){case 0:if(t<1)throw new Error("Please provide a positive integer k value to predictClass.");if(this.getNumExamples()===0)throw new Error("You have not added any examples to the KNN classifier. Please add examples before calling predictClass.");return r=Se(function(){return wt(a.similarities(e),"float32")}),s=Math.min(t,this.getNumExamples()),o=uft,[4,r.data()];case 1:return i=o.apply(void 0,[l.sent(),s]).indices,r.dispose(),[2,this.calculateTopClass(i,s)]}})})},n.prototype.clearClass=function(e){if(this.classDatasetMatrices[e]==null)throw new Error("Cannot clear invalid class ".concat(e));this.classDatasetMatrices[e].dispose(),delete this.classDatasetMatrices[e],delete this.classExampleCount[e],this.clearTrainDatasetMatrix()},n.prototype.clearAllClasses=function(){for(var e in this.classDatasetMatrices)this.clearClass(e)},n.prototype.getClassExampleCount=function(){return this.classExampleCount},n.prototype.getClassifierDataset=function(){return this.classDatasetMatrices},n.prototype.getNumClasses=function(){return Object.keys(this.classExampleCount).length},n.prototype.setClassifierDataset=function(e){this.clearTrainDatasetMatrix(),this.classDatasetMatrices=e;for(var t in e)this.classExampleCount[t]=e[t].shape[0]},n.prototype.calculateTopClass=function(e,t){var r,s={};if(e==null)return{classIndex:this.labelToClassId[r],label:r,confidences:s};var i={},o=0;for(var a in this.classDatasetMatrices)o+=this.classExampleCount[a],i[a]=o;var l={};for(var a in this.classDatasetMatrices)l[a]=0;for(var c=0;c<e.length;c++){var u=e[c];for(var a in this.classDatasetMatrices)if(u<i[a]){l[a]++;break}}var h=0;for(var a in this.classDatasetMatrices){var f=l[a]/t;f>h&&(h=f,r=a),s[a]=f}return{classIndex:this.labelToClassId[r],label:r,confidences:s}},n.prototype.clearTrainDatasetMatrix=function(){this.trainDatasetMatrix!=null&&(this.trainDatasetMatrix.dispose(),this.trainDatasetMatrix=null)},n.prototype.normalizeVectorToUnitLength=function(e){return Se(function(){var t=Ew(e);return Lt(e,t)})},n.prototype.getNumExamples=function(){var e=0;for(var t in this.classDatasetMatrices)e+=this.classExampleCount[t];return e},n.prototype.dispose=function(){this.clearTrainDatasetMatrix();for(var e in this.classDatasetMatrices)this.classDatasetMatrices[e].dispose()},n}();/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function _A(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?s(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function SA(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&u[0]?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(s=(s=o.trys).length>0&&s[s.length-1])&&(u[0]===6||u[0]===2)){o=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){o.label=u[1];break}if(u[0]===6&&o.label<s[1]){o.label=s[1],s=u;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(u);break}s[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}var fft={0:"tench, Tinca tinca",1:"goldfish, Carassius auratus",2:"great white shark, white shark, man-eater, man-eating shark, Carcharodon carcharias",3:"tiger shark, Galeocerdo cuvieri",4:"hammerhead, hammerhead shark",5:"electric ray, crampfish, numbfish, torpedo",6:"stingray",7:"cock",8:"hen",9:"ostrich, Struthio camelus",10:"brambling, Fringilla montifringilla",11:"goldfinch, Carduelis carduelis",12:"house finch, linnet, Carpodacus mexicanus",13:"junco, snowbird",14:"indigo bunting, indigo finch, indigo bird, Passerina cyanea",15:"robin, American robin, Turdus migratorius",16:"bulbul",17:"jay",18:"magpie",19:"chickadee",20:"water ouzel, dipper",21:"kite",22:"bald eagle, American eagle, Haliaeetus leucocephalus",23:"vulture",24:"great grey owl, great gray owl, Strix nebulosa",25:"European fire salamander, Salamandra salamandra",26:"common newt, Triturus vulgaris",27:"eft",28:"spotted salamander, Ambystoma maculatum",29:"axolotl, mud puppy, Ambystoma mexicanum",30:"bullfrog, Rana catesbeiana",31:"tree frog, tree-frog",32:"tailed frog, bell toad, ribbed toad, tailed toad, Ascaphus trui",33:"loggerhead, loggerhead turtle, Caretta caretta",34:"leatherback turtle, leatherback, leathery turtle, Dermochelys coriacea",35:"mud turtle",36:"terrapin",37:"box turtle, box tortoise",38:"banded gecko",39:"common iguana, iguana, Iguana iguana",40:"American chameleon, anole, Anolis carolinensis",41:"whiptail, whiptail lizard",42:"agama",43:"frilled lizard, Chlamydosaurus kingi",44:"alligator lizard",45:"Gila monster, Heloderma suspectum",46:"green lizard, Lacerta viridis",47:"African chameleon, Chamaeleo chamaeleon",48:"Komodo dragon, Komodo lizard, dragon lizard, giant lizard, Varanus komodoensis",49:"African crocodile, Nile crocodile, Crocodylus niloticus",50:"American alligator, Alligator mississipiensis",51:"triceratops",52:"thunder snake, worm snake, Carphophis amoenus",53:"ringneck snake, ring-necked snake, ring snake",54:"hognose snake, puff adder, sand viper",55:"green snake, grass snake",56:"king snake, kingsnake",57:"garter snake, grass snake",58:"water snake",59:"vine snake",60:"night snake, Hypsiglena torquata",61:"boa constrictor, Constrictor constrictor",62:"rock python, rock snake, Python sebae",63:"Indian cobra, Naja naja",64:"green mamba",65:"sea snake",66:"horned viper, cerastes, sand viper, horned asp, Cerastes cornutus",67:"diamondback, diamondback rattlesnake, Crotalus adamanteus",68:"sidewinder, horned rattlesnake, Crotalus cerastes",69:"trilobite",70:"harvestman, daddy longlegs, Phalangium opilio",71:"scorpion",72:"black and gold garden spider, Argiope aurantia",73:"barn spider, Araneus cavaticus",74:"garden spider, Aranea diademata",75:"black widow, Latrodectus mactans",76:"tarantula",77:"wolf spider, hunting spider",78:"tick",79:"centipede",80:"black grouse",81:"ptarmigan",82:"ruffed grouse, partridge, Bonasa umbellus",83:"prairie chicken, prairie grouse, prairie fowl",84:"peacock",85:"quail",86:"partridge",87:"African grey, African gray, Psittacus erithacus",88:"macaw",89:"sulphur-crested cockatoo, Kakatoe galerita, Cacatua galerita",90:"lorikeet",91:"coucal",92:"bee eater",93:"hornbill",94:"hummingbird",95:"jacamar",96:"toucan",97:"drake",98:"red-breasted merganser, Mergus serrator",99:"goose",100:"black swan, Cygnus atratus",101:"tusker",102:"echidna, spiny anteater, anteater",103:"platypus, duckbill, duckbilled platypus, duck-billed platypus, Ornithorhynchus anatinus",104:"wallaby, brush kangaroo",105:"koala, koala bear, kangaroo bear, native bear, Phascolarctos cinereus",106:"wombat",107:"jelly fish",108:"sea anemone, anemone",109:"brain coral",110:"flatworm, platyhelminth",111:"nematode, nematode worm, roundworm",112:"conch",113:"snail",114:"slug",115:"sea slug, nudibranch",116:"chiton, coat-of-mail shell, sea cradle, polyplacophore",117:"chambered nautilus, pearly nautilus, nautilus",118:"Dungeness crab, Cancer magister",119:"rock crab, Cancer irroratus",120:"fiddler crab",121:"king crab, Alaska crab, Alaskan king crab, Alaska king crab, Paralithodes camtschatica",122:"American lobster, Northern lobster, Maine lobster, Homarus americanus",123:"spiny lobster, langouste, rock lobster, crawfish, crayfish, sea crawfish",124:"crayfish, crawfish, crawdad, crawdaddy",125:"hermit crab",126:"isopod",127:"white stork, Ciconia ciconia",128:"black stork, Ciconia nigra",129:"spoonbill",130:"flamingo",131:"little blue heron, Egretta caerulea",132:"American egret, great white heron, Egretta albus",133:"bittern",134:"crane",135:"limpkin, Aramus pictus",136:"European gallinule, Porphyrio porphyrio",137:"American coot, marsh hen, mud hen, water hen, Fulica americana",138:"bustard",139:"ruddy turnstone, Arenaria interpres",140:"red-backed sandpiper, dunlin, Erolia alpina",141:"redshank, Tringa totanus",142:"dowitcher",143:"oystercatcher, oyster catcher",144:"pelican",145:"king penguin, Aptenodytes patagonica",146:"albatross, mollymawk",147:"grey whale, gray whale, devilfish, Eschrichtius gibbosus, Eschrichtius robustus",148:"killer whale, killer, orca, grampus, sea wolf, Orcinus orca",149:"dugong, Dugong dugon",150:"sea lion",151:"Chihuahua",152:"Japanese spaniel",153:"Maltese dog, Maltese terrier, Maltese",154:"Pekinese, Pekingese, Peke",155:"Shih-Tzu",156:"Blenheim spaniel",157:"papillon",158:"toy terrier",159:"Rhodesian ridgeback",160:"Afghan hound, Afghan",161:"basset, basset hound",162:"beagle",163:"bloodhound, sleuthhound",164:"bluetick",165:"black-and-tan coonhound",166:"Walker hound, Walker foxhound",167:"English foxhound",168:"redbone",169:"borzoi, Russian wolfhound",170:"Irish wolfhound",171:"Italian greyhound",172:"whippet",173:"Ibizan hound, Ibizan Podenco",174:"Norwegian elkhound, elkhound",175:"otterhound, otter hound",176:"Saluki, gazelle hound",177:"Scottish deerhound, deerhound",178:"Weimaraner",179:"Staffordshire bullterrier, Staffordshire bull terrier",180:"American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier",181:"Bedlington terrier",182:"Border terrier",183:"Kerry blue terrier",184:"Irish terrier",185:"Norfolk terrier",186:"Norwich terrier",187:"Yorkshire terrier",188:"wire-haired fox terrier",189:"Lakeland terrier",190:"Sealyham terrier, Sealyham",191:"Airedale, Airedale terrier",192:"cairn, cairn terrier",193:"Australian terrier",194:"Dandie Dinmont, Dandie Dinmont terrier",195:"Boston bull, Boston terrier",196:"miniature schnauzer",197:"giant schnauzer",198:"standard schnauzer",199:"Scotch terrier, Scottish terrier, Scottie",200:"Tibetan terrier, chrysanthemum dog",201:"silky terrier, Sydney silky",202:"soft-coated wheaten terrier",203:"West Highland white terrier",204:"Lhasa, Lhasa apso",205:"flat-coated retriever",206:"curly-coated retriever",207:"golden retriever",208:"Labrador retriever",209:"Chesapeake Bay retriever",210:"German short-haired pointer",211:"vizsla, Hungarian pointer",212:"English setter",213:"Irish setter, red setter",214:"Gordon setter",215:"Brittany spaniel",216:"clumber, clumber spaniel",217:"English springer, English springer spaniel",218:"Welsh springer spaniel",219:"cocker spaniel, English cocker spaniel, cocker",220:"Sussex spaniel",221:"Irish water spaniel",222:"kuvasz",223:"schipperke",224:"groenendael",225:"malinois",226:"briard",227:"kelpie",228:"komondor",229:"Old English sheepdog, bobtail",230:"Shetland sheepdog, Shetland sheep dog, Shetland",231:"collie",232:"Border collie",233:"Bouvier des Flandres, Bouviers des Flandres",234:"Rottweiler",235:"German shepherd, German shepherd dog, German police dog, alsatian",236:"Doberman, Doberman pinscher",237:"miniature pinscher",238:"Greater Swiss Mountain dog",239:"Bernese mountain dog",240:"Appenzeller",241:"EntleBucher",242:"boxer",243:"bull mastiff",244:"Tibetan mastiff",245:"French bulldog",246:"Great Dane",247:"Saint Bernard, St Bernard",248:"Eskimo dog, husky",249:"malamute, malemute, Alaskan malamute",250:"Siberian husky",251:"dalmatian, coach dog, carriage dog",252:"affenpinscher, monkey pinscher, monkey dog",253:"basenji",254:"pug, pug-dog",255:"Leonberg",256:"Newfoundland, Newfoundland dog",257:"Great Pyrenees",258:"Samoyed, Samoyede",259:"Pomeranian",260:"chow, chow chow",261:"keeshond",262:"Brabancon griffon",263:"Pembroke, Pembroke Welsh corgi",264:"Cardigan, Cardigan Welsh corgi",265:"toy poodle",266:"miniature poodle",267:"standard poodle",268:"Mexican hairless",269:"timber wolf, grey wolf, gray wolf, Canis lupus",270:"white wolf, Arctic wolf, Canis lupus tundrarum",271:"red wolf, maned wolf, Canis rufus, Canis niger",272:"coyote, prairie wolf, brush wolf, Canis latrans",273:"dingo, warrigal, warragal, Canis dingo",274:"dhole, Cuon alpinus",275:"African hunting dog, hyena dog, Cape hunting dog, Lycaon pictus",276:"hyena, hyaena",277:"red fox, Vulpes vulpes",278:"kit fox, Vulpes macrotis",279:"Arctic fox, white fox, Alopex lagopus",280:"grey fox, gray fox, Urocyon cinereoargenteus",281:"tabby, tabby cat",282:"tiger cat",283:"Persian cat",284:"Siamese cat, Siamese",285:"Egyptian cat",286:"cougar, puma, catamount, mountain lion, painter, panther, Felis concolor",287:"lynx, catamount",288:"leopard, Panthera pardus",289:"snow leopard, ounce, Panthera uncia",290:"jaguar, panther, Panthera onca, Felis onca",291:"lion, king of beasts, Panthera leo",292:"tiger, Panthera tigris",293:"cheetah, chetah, Acinonyx jubatus",294:"brown bear, bruin, Ursus arctos",295:"American black bear, black bear, Ursus americanus, Euarctos americanus",296:"ice bear, polar bear, Ursus Maritimus, Thalarctos maritimus",297:"sloth bear, Melursus ursinus, Ursus ursinus",298:"mongoose",299:"meerkat, mierkat",300:"tiger beetle",301:"ladybug, ladybeetle, lady beetle, ladybird, ladybird beetle",302:"ground beetle, carabid beetle",303:"long-horned beetle, longicorn, longicorn beetle",304:"leaf beetle, chrysomelid",305:"dung beetle",306:"rhinoceros beetle",307:"weevil",308:"fly",309:"bee",310:"ant, emmet, pismire",311:"grasshopper, hopper",312:"cricket",313:"walking stick, walkingstick, stick insect",314:"cockroach, roach",315:"mantis, mantid",316:"cicada, cicala",317:"leafhopper",318:"lacewing, lacewing fly",319:"dragonfly, darning needle, devil's darning needle, sewing needle, snake feeder, snake doctor, mosquito hawk, skeeter hawk",320:"damselfly",321:"admiral",322:"ringlet, ringlet butterfly",323:"monarch, monarch butterfly, milkweed butterfly, Danaus plexippus",324:"cabbage butterfly",325:"sulphur butterfly, sulfur butterfly",326:"lycaenid, lycaenid butterfly",327:"starfish, sea star",328:"sea urchin",329:"sea cucumber, holothurian",330:"wood rabbit, cottontail, cottontail rabbit",331:"hare",332:"Angora, Angora rabbit",333:"hamster",334:"porcupine, hedgehog",335:"fox squirrel, eastern fox squirrel, Sciurus niger",336:"marmot",337:"beaver",338:"guinea pig, Cavia cobaya",339:"sorrel",340:"zebra",341:"hog, pig, grunter, squealer, Sus scrofa",342:"wild boar, boar, Sus scrofa",343:"warthog",344:"hippopotamus, hippo, river horse, Hippopotamus amphibius",345:"ox",346:"water buffalo, water ox, Asiatic buffalo, Bubalus bubalis",347:"bison",348:"ram, tup",349:"bighorn, bighorn sheep, cimarron, Rocky Mountain bighorn, Rocky Mountain sheep, Ovis canadensis",350:"ibex, Capra ibex",351:"hartebeest",352:"impala, Aepyceros melampus",353:"gazelle",354:"Arabian camel, dromedary, Camelus dromedarius",355:"llama",356:"weasel",357:"mink",358:"polecat, fitch, foulmart, foumart, Mustela putorius",359:"black-footed ferret, ferret, Mustela nigripes",360:"otter",361:"skunk, polecat, wood pussy",362:"badger",363:"armadillo",364:"three-toed sloth, ai, Bradypus tridactylus",365:"orangutan, orang, orangutang, Pongo pygmaeus",366:"gorilla, Gorilla gorilla",367:"chimpanzee, chimp, Pan troglodytes",368:"gibbon, Hylobates lar",369:"siamang, Hylobates syndactylus, Symphalangus syndactylus",370:"guenon, guenon monkey",371:"patas, hussar monkey, Erythrocebus patas",372:"baboon",373:"macaque",374:"langur",375:"colobus, colobus monkey",376:"proboscis monkey, Nasalis larvatus",377:"marmoset",378:"capuchin, ringtail, Cebus capucinus",379:"howler monkey, howler",380:"titi, titi monkey",381:"spider monkey, Ateles geoffroyi",382:"squirrel monkey, Saimiri sciureus",383:"Madagascar cat, ring-tailed lemur, Lemur catta",384:"indri, indris, Indri indri, Indri brevicaudatus",385:"Indian elephant, Elephas maximus",386:"African elephant, Loxodonta africana",387:"lesser panda, red panda, panda, bear cat, cat bear, Ailurus fulgens",388:"giant panda, panda, panda bear, coon bear, Ailuropoda melanoleuca",389:"barracouta, snoek",390:"eel",391:"coho, cohoe, coho salmon, blue jack, silver salmon, Oncorhynchus kisutch",392:"rock beauty, Holocanthus tricolor",393:"anemone fish",394:"sturgeon",395:"gar, garfish, garpike, billfish, Lepisosteus osseus",396:"lionfish",397:"puffer, pufferfish, blowfish, globefish",398:"abacus",399:"abaya",400:"academic gown, academic robe, judge's robe",401:"accordion, piano accordion, squeeze box",402:"acoustic guitar",403:"aircraft carrier, carrier, flattop, attack aircraft carrier",404:"airliner",405:"airship, dirigible",406:"altar",407:"ambulance",408:"amphibian, amphibious vehicle",409:"analog clock",410:"apiary, bee house",411:"apron",412:"ashcan, trash can, garbage can, wastebin, ash bin, ash-bin, ashbin, dustbin, trash barrel, trash bin",413:"assault rifle, assault gun",414:"backpack, back pack, knapsack, packsack, rucksack, haversack",415:"bakery, bakeshop, bakehouse",416:"balance beam, beam",417:"balloon",418:"ballpoint, ballpoint pen, ballpen, Biro",419:"Band Aid",420:"banjo",421:"bannister, banister, balustrade, balusters, handrail",422:"barbell",423:"barber chair",424:"barbershop",425:"barn",426:"barometer",427:"barrel, cask",428:"barrow, garden cart, lawn cart, wheelbarrow",429:"baseball",430:"basketball",431:"bassinet",432:"bassoon",433:"bathing cap, swimming cap",434:"bath towel",435:"bathtub, bathing tub, bath, tub",436:"beach wagon, station wagon, wagon, estate car, beach waggon, station waggon, waggon",437:"beacon, lighthouse, beacon light, pharos",438:"beaker",439:"bearskin, busby, shako",440:"beer bottle",441:"beer glass",442:"bell cote, bell cot",443:"bib",444:"bicycle-built-for-two, tandem bicycle, tandem",445:"bikini, two-piece",446:"binder, ring-binder",447:"binoculars, field glasses, opera glasses",448:"birdhouse",449:"boathouse",450:"bobsled, bobsleigh, bob",451:"bolo tie, bolo, bola tie, bola",452:"bonnet, poke bonnet",453:"bookcase",454:"bookshop, bookstore, bookstall",455:"bottlecap",456:"bow",457:"bow tie, bow-tie, bowtie",458:"brass, memorial tablet, plaque",459:"brassiere, bra, bandeau",460:"breakwater, groin, groyne, mole, bulwark, seawall, jetty",461:"breastplate, aegis, egis",462:"broom",463:"bucket, pail",464:"buckle",465:"bulletproof vest",466:"bullet train, bullet",467:"butcher shop, meat market",468:"cab, hack, taxi, taxicab",469:"caldron, cauldron",470:"candle, taper, wax light",471:"cannon",472:"canoe",473:"can opener, tin opener",474:"cardigan",475:"car mirror",476:"carousel, carrousel, merry-go-round, roundabout, whirligig",477:"carpenter's kit, tool kit",478:"carton",479:"car wheel",480:"cash machine, cash dispenser, automated teller machine, automatic teller machine, automated teller, automatic teller, ATM",481:"cassette",482:"cassette player",483:"castle",484:"catamaran",485:"CD player",486:"cello, violoncello",487:"cellular telephone, cellular phone, cellphone, cell, mobile phone",488:"chain",489:"chainlink fence",490:"chain mail, ring mail, mail, chain armor, chain armour, ring armor, ring armour",491:"chain saw, chainsaw",492:"chest",493:"chiffonier, commode",494:"chime, bell, gong",495:"china cabinet, china closet",496:"Christmas stocking",497:"church, church building",498:"cinema, movie theater, movie theatre, movie house, picture palace",499:"cleaver, meat cleaver, chopper",500:"cliff dwelling",501:"cloak",502:"clog, geta, patten, sabot",503:"cocktail shaker",504:"coffee mug",505:"coffeepot",506:"coil, spiral, volute, whorl, helix",507:"combination lock",508:"computer keyboard, keypad",509:"confectionery, confectionary, candy store",510:"container ship, containership, container vessel",511:"convertible",512:"corkscrew, bottle screw",513:"cornet, horn, trumpet, trump",514:"cowboy boot",515:"cowboy hat, ten-gallon hat",516:"cradle",517:"crane",518:"crash helmet",519:"crate",520:"crib, cot",521:"Crock Pot",522:"croquet ball",523:"crutch",524:"cuirass",525:"dam, dike, dyke",526:"desk",527:"desktop computer",528:"dial telephone, dial phone",529:"diaper, nappy, napkin",530:"digital clock",531:"digital watch",532:"dining table, board",533:"dishrag, dishcloth",534:"dishwasher, dish washer, dishwashing machine",535:"disk brake, disc brake",536:"dock, dockage, docking facility",537:"dogsled, dog sled, dog sleigh",538:"dome",539:"doormat, welcome mat",540:"drilling platform, offshore rig",541:"drum, membranophone, tympan",542:"drumstick",543:"dumbbell",544:"Dutch oven",545:"electric fan, blower",546:"electric guitar",547:"electric locomotive",548:"entertainment center",549:"envelope",550:"espresso maker",551:"face powder",552:"feather boa, boa",553:"file, file cabinet, filing cabinet",554:"fireboat",555:"fire engine, fire truck",556:"fire screen, fireguard",557:"flagpole, flagstaff",558:"flute, transverse flute",559:"folding chair",560:"football helmet",561:"forklift",562:"fountain",563:"fountain pen",564:"four-poster",565:"freight car",566:"French horn, horn",567:"frying pan, frypan, skillet",568:"fur coat",569:"garbage truck, dustcart",570:"gasmask, respirator, gas helmet",571:"gas pump, gasoline pump, petrol pump, island dispenser",572:"goblet",573:"go-kart",574:"golf ball",575:"golfcart, golf cart",576:"gondola",577:"gong, tam-tam",578:"gown",579:"grand piano, grand",580:"greenhouse, nursery, glasshouse",581:"grille, radiator grille",582:"grocery store, grocery, food market, market",583:"guillotine",584:"hair slide",585:"hair spray",586:"half track",587:"hammer",588:"hamper",589:"hand blower, blow dryer, blow drier, hair dryer, hair drier",590:"hand-held computer, hand-held microcomputer",591:"handkerchief, hankie, hanky, hankey",592:"hard disc, hard disk, fixed disk",593:"harmonica, mouth organ, harp, mouth harp",594:"harp",595:"harvester, reaper",596:"hatchet",597:"holster",598:"home theater, home theatre",599:"honeycomb",600:"hook, claw",601:"hoopskirt, crinoline",602:"horizontal bar, high bar",603:"horse cart, horse-cart",604:"hourglass",605:"iPod",606:"iron, smoothing iron",607:"jack-o'-lantern",608:"jean, blue jean, denim",609:"jeep, landrover",610:"jersey, T-shirt, tee shirt",611:"jigsaw puzzle",612:"jinrikisha, ricksha, rickshaw",613:"joystick",614:"kimono",615:"knee pad",616:"knot",617:"lab coat, laboratory coat",618:"ladle",619:"lampshade, lamp shade",620:"laptop, laptop computer",621:"lawn mower, mower",622:"lens cap, lens cover",623:"letter opener, paper knife, paperknife",624:"library",625:"lifeboat",626:"lighter, light, igniter, ignitor",627:"limousine, limo",628:"liner, ocean liner",629:"lipstick, lip rouge",630:"Loafer",631:"lotion",632:"loudspeaker, speaker, speaker unit, loudspeaker system, speaker system",633:"loupe, jeweler's loupe",634:"lumbermill, sawmill",635:"magnetic compass",636:"mailbag, postbag",637:"mailbox, letter box",638:"maillot",639:"maillot, tank suit",640:"manhole cover",641:"maraca",642:"marimba, xylophone",643:"mask",644:"matchstick",645:"maypole",646:"maze, labyrinth",647:"measuring cup",648:"medicine chest, medicine cabinet",649:"megalith, megalithic structure",650:"microphone, mike",651:"microwave, microwave oven",652:"military uniform",653:"milk can",654:"minibus",655:"miniskirt, mini",656:"minivan",657:"missile",658:"mitten",659:"mixing bowl",660:"mobile home, manufactured home",661:"Model T",662:"modem",663:"monastery",664:"monitor",665:"moped",666:"mortar",667:"mortarboard",668:"mosque",669:"mosquito net",670:"motor scooter, scooter",671:"mountain bike, all-terrain bike, off-roader",672:"mountain tent",673:"mouse, computer mouse",674:"mousetrap",675:"moving van",676:"muzzle",677:"nail",678:"neck brace",679:"necklace",680:"nipple",681:"notebook, notebook computer",682:"obelisk",683:"oboe, hautboy, hautbois",684:"ocarina, sweet potato",685:"odometer, hodometer, mileometer, milometer",686:"oil filter",687:"organ, pipe organ",688:"oscilloscope, scope, cathode-ray oscilloscope, CRO",689:"overskirt",690:"oxcart",691:"oxygen mask",692:"packet",693:"paddle, boat paddle",694:"paddlewheel, paddle wheel",695:"padlock",696:"paintbrush",697:"pajama, pyjama, pj's, jammies",698:"palace",699:"panpipe, pandean pipe, syrinx",700:"paper towel",701:"parachute, chute",702:"parallel bars, bars",703:"park bench",704:"parking meter",705:"passenger car, coach, carriage",706:"patio, terrace",707:"pay-phone, pay-station",708:"pedestal, plinth, footstall",709:"pencil box, pencil case",710:"pencil sharpener",711:"perfume, essence",712:"Petri dish",713:"photocopier",714:"pick, plectrum, plectron",715:"pickelhaube",716:"picket fence, paling",717:"pickup, pickup truck",718:"pier",719:"piggy bank, penny bank",720:"pill bottle",721:"pillow",722:"ping-pong ball",723:"pinwheel",724:"pirate, pirate ship",725:"pitcher, ewer",726:"plane, carpenter's plane, woodworking plane",727:"planetarium",728:"plastic bag",729:"plate rack",730:"plow, plough",731:"plunger, plumber's helper",732:"Polaroid camera, Polaroid Land camera",733:"pole",734:"police van, police wagon, paddy wagon, patrol wagon, wagon, black Maria",735:"poncho",736:"pool table, billiard table, snooker table",737:"pop bottle, soda bottle",738:"pot, flowerpot",739:"potter's wheel",740:"power drill",741:"prayer rug, prayer mat",742:"printer",743:"prison, prison house",744:"projectile, missile",745:"projector",746:"puck, hockey puck",747:"punching bag, punch bag, punching ball, punchball",748:"purse",749:"quill, quill pen",750:"quilt, comforter, comfort, puff",751:"racer, race car, racing car",752:"racket, racquet",753:"radiator",754:"radio, wireless",755:"radio telescope, radio reflector",756:"rain barrel",757:"recreational vehicle, RV, R.V.",758:"reel",759:"reflex camera",760:"refrigerator, icebox",761:"remote control, remote",762:"restaurant, eating house, eating place, eatery",763:"revolver, six-gun, six-shooter",764:"rifle",765:"rocking chair, rocker",766:"rotisserie",767:"rubber eraser, rubber, pencil eraser",768:"rugby ball",769:"rule, ruler",770:"running shoe",771:"safe",772:"safety pin",773:"saltshaker, salt shaker",774:"sandal",775:"sarong",776:"sax, saxophone",777:"scabbard",778:"scale, weighing machine",779:"school bus",780:"schooner",781:"scoreboard",782:"screen, CRT screen",783:"screw",784:"screwdriver",785:"seat belt, seatbelt",786:"sewing machine",787:"shield, buckler",788:"shoe shop, shoe-shop, shoe store",789:"shoji",790:"shopping basket",791:"shopping cart",792:"shovel",793:"shower cap",794:"shower curtain",795:"ski",796:"ski mask",797:"sleeping bag",798:"slide rule, slipstick",799:"sliding door",800:"slot, one-armed bandit",801:"snorkel",802:"snowmobile",803:"snowplow, snowplough",804:"soap dispenser",805:"soccer ball",806:"sock",807:"solar dish, solar collector, solar furnace",808:"sombrero",809:"soup bowl",810:"space bar",811:"space heater",812:"space shuttle",813:"spatula",814:"speedboat",815:"spider web, spider's web",816:"spindle",817:"sports car, sport car",818:"spotlight, spot",819:"stage",820:"steam locomotive",821:"steel arch bridge",822:"steel drum",823:"stethoscope",824:"stole",825:"stone wall",826:"stopwatch, stop watch",827:"stove",828:"strainer",829:"streetcar, tram, tramcar, trolley, trolley car",830:"stretcher",831:"studio couch, day bed",832:"stupa, tope",833:"submarine, pigboat, sub, U-boat",834:"suit, suit of clothes",835:"sundial",836:"sunglass",837:"sunglasses, dark glasses, shades",838:"sunscreen, sunblock, sun blocker",839:"suspension bridge",840:"swab, swob, mop",841:"sweatshirt",842:"swimming trunks, bathing trunks",843:"swing",844:"switch, electric switch, electrical switch",845:"syringe",846:"table lamp",847:"tank, army tank, armored combat vehicle, armoured combat vehicle",848:"tape player",849:"teapot",850:"teddy, teddy bear",851:"television, television system",852:"tennis ball",853:"thatch, thatched roof",854:"theater curtain, theatre curtain",855:"thimble",856:"thresher, thrasher, threshing machine",857:"throne",858:"tile roof",859:"toaster",860:"tobacco shop, tobacconist shop, tobacconist",861:"toilet seat",862:"torch",863:"totem pole",864:"tow truck, tow car, wrecker",865:"toyshop",866:"tractor",867:"trailer truck, tractor trailer, trucking rig, rig, articulated lorry, semi",868:"tray",869:"trench coat",870:"tricycle, trike, velocipede",871:"trimaran",872:"tripod",873:"triumphal arch",874:"trolleybus, trolley coach, trackless trolley",875:"trombone",876:"tub, vat",877:"turnstile",878:"typewriter keyboard",879:"umbrella",880:"unicycle, monocycle",881:"upright, upright piano",882:"vacuum, vacuum cleaner",883:"vase",884:"vault",885:"velvet",886:"vending machine",887:"vestment",888:"viaduct",889:"violin, fiddle",890:"volleyball",891:"waffle iron",892:"wall clock",893:"wallet, billfold, notecase, pocketbook",894:"wardrobe, closet, press",895:"warplane, military plane",896:"washbasin, handbasin, washbowl, lavabo, wash-hand basin",897:"washer, automatic washer, washing machine",898:"water bottle",899:"water jug",900:"water tower",901:"whiskey jug",902:"whistle",903:"wig",904:"window screen",905:"window shade",906:"Windsor tie",907:"wine bottle",908:"wing",909:"wok",910:"wooden spoon",911:"wool, woolen, woollen",912:"worm fence, snake fence, snake-rail fence, Virginia fence",913:"wreck",914:"yawl",915:"yurt",916:"web site, website, internet site, site",917:"comic book",918:"crossword puzzle, crossword",919:"street sign",920:"traffic light, traffic signal, stoplight",921:"book jacket, dust cover, dust jacket, dust wrapper",922:"menu",923:"plate",924:"guacamole",925:"consomme",926:"hot pot, hotpot",927:"trifle",928:"ice cream, icecream",929:"ice lolly, lolly, lollipop, popsicle",930:"French loaf",931:"bagel, beigel",932:"pretzel",933:"cheeseburger",934:"hotdog, hot dog, red hot",935:"mashed potato",936:"head cabbage",937:"broccoli",938:"cauliflower",939:"zucchini, courgette",940:"spaghetti squash",941:"acorn squash",942:"butternut squash",943:"cucumber, cuke",944:"artichoke, globe artichoke",945:"bell pepper",946:"cardoon",947:"mushroom",948:"Granny Smith",949:"strawberry",950:"orange",951:"lemon",952:"fig",953:"pineapple, ananas",954:"banana",955:"jackfruit, jak, jack",956:"custard apple",957:"pomegranate",958:"hay",959:"carbonara",960:"chocolate sauce, chocolate syrup",961:"dough",962:"meat loaf, meatloaf",963:"pizza, pizza pie",964:"potpie",965:"burrito",966:"red wine",967:"espresso",968:"cup",969:"eggnog",970:"alp",971:"bubble",972:"cliff, drop, drop-off",973:"coral reef",974:"geyser",975:"lakeside, lakeshore",976:"promontory, headland, head, foreland",977:"sandbar, sand bar",978:"seashore, coast, seacoast, sea-coast",979:"valley, vale",980:"volcano",981:"ballplayer, baseball player",982:"groom, bridegroom",983:"scuba diver",984:"rapeseed",985:"daisy",986:"yellow lady's slipper, yellow lady-slipper, Cypripedium calceolus, Cypripedium parviflorum",987:"corn",988:"acorn",989:"hip, rose hip, rosehip",990:"buckeye, horse chestnut, conker",991:"coral fungus",992:"agaric",993:"gyromitra",994:"stinkhorn, carrion fungus",995:"earthstar",996:"hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa",997:"bolete",998:"ear, spike, capitulum",999:"toilet tissue, toilet paper, bathroom tissue"},fd=224,dft={"1.00":"module_apply_default/MobilenetV1/Logits/global_pool","2.00":"module_apply_default/MobilenetV2/Logits/AvgPool"},gb={"1.00":{.25:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_025_224/classification/1",inputRange:[0,1]},"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_050_224/classification/1",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_075_224/classification/1",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v1_100_224/classification/1",inputRange:[0,1]}},"2.00":{"0.50":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_050_224/classification/2",inputRange:[0,1]},.75:{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_075_224/classification/2",inputRange:[0,1]},"1.00":{url:"https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/2",inputRange:[0,1]}}};function Mj(n){return n===void 0&&(n={version:1,alpha:1}),_A(this,void 0,void 0,function(){var e,t,r,s,i,o,a;return SA(this,function(l){switch(l.label){case 0:if(cZ==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");if(e=n.version.toFixed(2),t=n.alpha?n.alpha.toFixed(2):"",r=-1,s=1,n.modelUrl==null){if(!(e in gb))throw new Error("Invalid version of MobileNet. Valid versions are: "+Object.keys(gb));if(!(t in gb[e]))throw new Error("MobileNet constructed with invalid alpha "+n.alpha+". Valid multipliers for this version are: "+Object.keys(gb[e])+".");o=gb[e][t].inputRange,r=o[0],s=o[1]}return n.inputRange!=null&&(a=n.inputRange,r=a[0],s=a[1]),[4,(i=new pft(e,t,n.modelUrl,r,s)).load()];case 1:return l.sent(),[2,i]}})})}var pft=function(){function n(e,t,r,s,i){s===void 0&&(s=-1),i===void 0&&(i=1),this.version=e,this.alpha=t,this.modelUrl=r,this.inputMin=s,this.inputMax=i,this.normalizationConstant=(i-s)/255}return n.prototype.load=function(){return _A(this,void 0,void 0,function(){var e,t,r,s,i=this;return SA(this,function(o){switch(o.label){case 0:return this.modelUrl?(e=this,[4,Nl(this.modelUrl)]):[3,2];case 1:return e.model=o.sent(),[3,4];case 2:return t=gb[this.version][this.alpha].url,r=this,[4,Nl(t,{fromTFHub:!0})];case 3:r.model=o.sent(),o.label=4;case 4:return[4,(s=Se(function(){return i.model.predict(ms([1,fd,fd,3]))})).data()];case 5:return o.sent(),s.dispose(),[2]}})})},n.prototype.infer=function(e,t){var r=this;return t===void 0&&(t=!1),Se(function(){e instanceof jn||(e=oC(e));var s=qe(fe(wt(e,"float32"),r.normalizationConstant),r.inputMin),i=s;(e.shape[0]!==fd||e.shape[1]!==fd)&&(i=Ci.resizeBilinear(s,[fd,fd],!0));var o,a=ve(i,[-1,fd,fd,3]);if(t){var l=dft[r.version],c=r.model.execute(a,l);o=vr(c,[1,2])}else{var u=r.model.predict(a);o=dn(u,[0,1],[-1,1e3])}return o})},n.prototype.classify=function(e,t){return t===void 0&&(t=3),_A(this,void 0,void 0,function(){var r,s;return SA(this,function(i){switch(i.label){case 0:return[4,mft(r=this.infer(e),t)];case 1:return s=i.sent(),r.dispose(),[2,s]}})})},n}();function mft(n,e){return _A(this,void 0,void 0,function(){var t,r,s,i,o,a,l;return SA(this,function(c){switch(c.label){case 0:return[4,(t=nC(n)).data()];case 1:for(r=c.sent(),t.dispose(),s=[],l=0;l<r.length;l++)s.push({value:r[l],index:l});for(s.sort(function(u,h){return h.value-u.value}),i=new Float32Array(e),o=new Int32Array(e),l=0;l<e;l++)i[l]=s[l].value,o[l]=s[l].index;for(a=[],l=0;l<o.length;l++)a.push({className:fft[o[l]],probability:i[l]});return[2,a]}})})}var gft={};(function(){var n;function e(T){var $=0;return function(){return $<T.length?{done:!1,value:T[$++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,$,L){return T==Array.prototype||T==Object.prototype||(T[$]=L.value),T};function r(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof pt=="object"&&pt];for(var $=0;$<T.length;++$){var L=T[$];if(L&&L.Math==Math)return L}throw Error("Cannot find global object")}var s=r(this);function i(T,$){if($)e:{var L=s;T=T.split(".");for(var W=0;W<T.length-1;W++){var ne=T[W];if(!(ne in L))break e;L=L[ne]}T=T[T.length-1],W=L[T],$=$(W),$!=W&&$!=null&&t(L,T,{configurable:!0,writable:!0,value:$})}}i("Symbol",function(T){function $(oe){if(this instanceof $)throw new TypeError("Symbol is not a constructor");return new L(W+(oe||"")+"_"+ne++,oe)}function L(oe,ie){this.h=oe,t(this,"description",{configurable:!0,writable:!0,value:ie})}if(T)return T;L.prototype.toString=function(){return this.h};var W="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ne=0;return $}),i("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var $="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),L=0;L<$.length;L++){var W=s[$[L]];typeof W=="function"&&typeof W.prototype[T]!="function"&&t(W.prototype,T,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return T});function o(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function a(T){var $=typeof Symbol<"u"&&Symbol.iterator&&T[Symbol.iterator];return $?$.call(T):{next:e(T)}}function l(T){if(!(T instanceof Array)){T=a(T);for(var $,L=[];!($=T.next()).done;)L.push($.value);T=L}return T}var c=typeof Object.assign=="function"?Object.assign:function(T,$){for(var L=1;L<arguments.length;L++){var W=arguments[L];if(W)for(var ne in W)Object.prototype.hasOwnProperty.call(W,ne)&&(T[ne]=W[ne])}return T};i("Object.assign",function(T){return T||c});var u=typeof Object.create=="function"?Object.create:function(T){function $(){}return $.prototype=T,new $},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var f;e:{var d={a:!0},p={};try{p.__proto__=d,f=p.a;break e}catch{}f=!1}h=f?function(T,$){if(T.__proto__=$,T.__proto__!==$)throw new TypeError(T+" is not extensible");return T}:null}var m=h;function g(T,$){if(T.prototype=u($.prototype),T.prototype.constructor=T,m)m(T,$);else for(var L in $)if(L!="prototype")if(Object.defineProperties){var W=Object.getOwnPropertyDescriptor($,L);W&&Object.defineProperty(T,L,W)}else T[L]=$[L];T.za=$.prototype}function y(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function b(T){if(T.m)throw new TypeError("Generator is already running");T.m=!0}y.prototype.u=function(T){this.i=T};function x(T,$){T.l={ma:$,na:!0},T.h=T.s||T.v}y.prototype.return=function(T){this.l={return:T},this.h=this.v};function w(T,$,L){return T.h=L,{value:$}}function S(T){this.h=new y,this.i=T}function C(T,$){b(T.h);var L=T.h.j;return L?k(T,"return"in L?L.return:function(W){return{value:W,done:!0}},$,T.h.return):(T.h.return($),A(T))}function k(T,$,L,W){try{var ne=$.call(T.h.j,L);if(!(ne instanceof Object))throw new TypeError("Iterator result "+ne+" is not an object");if(!ne.done)return T.h.m=!1,ne;var oe=ne.value}catch(ie){return T.h.j=null,x(T.h,ie),A(T)}return T.h.j=null,W.call(T.h,oe),A(T)}function A(T){for(;T.h.h;)try{var $=T.i(T.h);if($)return T.h.m=!1,{value:$.value,done:!1}}catch(L){T.h.i=void 0,x(T.h,L)}if(T.h.m=!1,T.h.l){if($=T.h.l,T.h.l=null,$.na)throw $.ma;return{value:$.return,done:!0}}return{value:void 0,done:!0}}function M(T){this.next=function($){return b(T.h),T.h.j?$=k(T,T.h.j.next,$,T.h.u):(T.h.u($),$=A(T)),$},this.throw=function($){return b(T.h),T.h.j?$=k(T,T.h.j.throw,$,T.h.u):(x(T.h,$),$=A(T)),$},this.return=function($){return C(T,$)},this[Symbol.iterator]=function(){return this}}function E(T){function $(W){return T.next(W)}function L(W){return T.throw(W)}return new Promise(function(W,ne){function oe(ie){ie.done?W(ie.value):Promise.resolve(ie.value).then($,L).then(oe,ne)}oe(T.next())})}function N(T){return E(new M(new S(T)))}i("Promise",function(T){function $(ie){this.i=0,this.j=void 0,this.h=[],this.u=!1;var Ce=this.l();try{ie(Ce.resolve,Ce.reject)}catch(Pe){Ce.reject(Pe)}}function L(){this.h=null}function W(ie){return ie instanceof $?ie:new $(function(Ce){Ce(ie)})}if(T)return T;L.prototype.i=function(ie){if(this.h==null){this.h=[];var Ce=this;this.j(function(){Ce.m()})}this.h.push(ie)};var ne=s.setTimeout;L.prototype.j=function(ie){ne(ie,0)},L.prototype.m=function(){for(;this.h&&this.h.length;){var ie=this.h;this.h=[];for(var Ce=0;Ce<ie.length;++Ce){var Pe=ie[Ce];ie[Ce]=null;try{Pe()}catch(ht){this.l(ht)}}}this.h=null},L.prototype.l=function(ie){this.j(function(){throw ie})},$.prototype.l=function(){function ie(ht){return function(Et){Pe||(Pe=!0,ht.call(Ce,Et))}}var Ce=this,Pe=!1;return{resolve:ie(this.I),reject:ie(this.m)}},$.prototype.I=function(ie){if(ie===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(ie instanceof $)this.L(ie);else{e:switch(typeof ie){case"object":var Ce=ie!=null;break e;case"function":Ce=!0;break e;default:Ce=!1}Ce?this.F(ie):this.s(ie)}},$.prototype.F=function(ie){var Ce=void 0;try{Ce=ie.then}catch(Pe){this.m(Pe);return}typeof Ce=="function"?this.M(Ce,ie):this.s(ie)},$.prototype.m=function(ie){this.v(2,ie)},$.prototype.s=function(ie){this.v(1,ie)},$.prototype.v=function(ie,Ce){if(this.i!=0)throw Error("Cannot settle("+ie+", "+Ce+"): Promise already settled in state"+this.i);this.i=ie,this.j=Ce,this.i===2&&this.K(),this.H()},$.prototype.K=function(){var ie=this;ne(function(){if(ie.D()){var Ce=s.console;typeof Ce<"u"&&Ce.error(ie.j)}},1)},$.prototype.D=function(){if(this.u)return!1;var ie=s.CustomEvent,Ce=s.Event,Pe=s.dispatchEvent;return typeof Pe>"u"?!0:(typeof ie=="function"?ie=new ie("unhandledrejection",{cancelable:!0}):typeof Ce=="function"?ie=new Ce("unhandledrejection",{cancelable:!0}):(ie=s.document.createEvent("CustomEvent"),ie.initCustomEvent("unhandledrejection",!1,!0,ie)),ie.promise=this,ie.reason=this.j,Pe(ie))},$.prototype.H=function(){if(this.h!=null){for(var ie=0;ie<this.h.length;++ie)oe.i(this.h[ie]);this.h=null}};var oe=new L;return $.prototype.L=function(ie){var Ce=this.l();ie.T(Ce.resolve,Ce.reject)},$.prototype.M=function(ie,Ce){var Pe=this.l();try{ie.call(Ce,Pe.resolve,Pe.reject)}catch(ht){Pe.reject(ht)}},$.prototype.then=function(ie,Ce){function Pe(Ut,Rt){return typeof Ut=="function"?function(an){try{ht(Ut(an))}catch(Bn){Et(Bn)}}:Rt}var ht,Et,hn=new $(function(Ut,Rt){ht=Ut,Et=Rt});return this.T(Pe(ie,ht),Pe(Ce,Et)),hn},$.prototype.catch=function(ie){return this.then(void 0,ie)},$.prototype.T=function(ie,Ce){function Pe(){switch(ht.i){case 1:ie(ht.j);break;case 2:Ce(ht.j);break;default:throw Error("Unexpected state: "+ht.i)}}var ht=this;this.h==null?oe.i(Pe):this.h.push(Pe),this.u=!0},$.resolve=W,$.reject=function(ie){return new $(function(Ce,Pe){Pe(ie)})},$.race=function(ie){return new $(function(Ce,Pe){for(var ht=a(ie),Et=ht.next();!Et.done;Et=ht.next())W(Et.value).T(Ce,Pe)})},$.all=function(ie){var Ce=a(ie),Pe=Ce.next();return Pe.done?W([]):new $(function(ht,Et){function hn(an){return function(Bn){Ut[an]=Bn,Rt--,Rt==0&&ht(Ut)}}var Ut=[],Rt=0;do Ut.push(void 0),Rt++,W(Pe.value).T(hn(Ut.length-1),Et),Pe=Ce.next();while(!Pe.done)})},$});function O(T,$){T instanceof String&&(T+="");var L=0,W=!1,ne={next:function(){if(!W&&L<T.length){var oe=L++;return{value:$(oe,T[oe]),done:!1}}return W=!0,{done:!0,value:void 0}}};return ne[Symbol.iterator]=function(){return ne},ne}i("Array.prototype.keys",function(T){return T||function(){return O(this,function($){return $})}}),i("Array.prototype.fill",function(T){return T||function($,L,W){var ne=this.length||0;for(0>L&&(L=Math.max(0,ne+L)),(W==null||W>ne)&&(W=ne),W=Number(W),0>W&&(W=Math.max(0,ne+W)),L=Number(L||0);L<W;L++)this[L]=$;return this}});function R(T){return T||Array.prototype.fill}i("Int8Array.prototype.fill",R),i("Uint8Array.prototype.fill",R),i("Uint8ClampedArray.prototype.fill",R),i("Int16Array.prototype.fill",R),i("Uint16Array.prototype.fill",R),i("Int32Array.prototype.fill",R),i("Uint32Array.prototype.fill",R),i("Float32Array.prototype.fill",R),i("Float64Array.prototype.fill",R),i("Object.is",function(T){return T||function($,L){return $===L?$!==0||1/$===1/L:$!==$&&L!==L}}),i("Array.prototype.includes",function(T){return T||function($,L){var W=this;W instanceof String&&(W=String(W));var ne=W.length;for(L=L||0,0>L&&(L=Math.max(L+ne,0));L<ne;L++){var oe=W[L];if(oe===$||Object.is(oe,$))return!0}return!1}}),i("String.prototype.includes",function(T){return T||function($,L){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if($ instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf($,L||0)!==-1}});var D=this||self;function z(T,$){T=T.split(".");var L=D;T[0]in L||typeof L.execScript>"u"||L.execScript("var "+T[0]);for(var W;T.length&&(W=T.shift());)T.length||$===void 0?L[W]&&L[W]!==Object.prototype[W]?L=L[W]:L=L[W]={}:L[W]=$}function B(T){var $;e:{if(($=D.navigator)&&($=$.userAgent))break e;$=""}return $.indexOf(T)!=-1}var X=Array.prototype.map?function(T,$){return Array.prototype.map.call(T,$,void 0)}:function(T,$){for(var L=T.length,W=Array(L),ne=typeof T=="string"?T.split(""):T,oe=0;oe<L;oe++)oe in ne&&(W[oe]=$.call(void 0,ne[oe],oe,T));return W},G={},te=null;function ge(T){var $=T.length,L=3*$/4;L%3?L=Math.floor(L):"=.".indexOf(T[$-1])!=-1&&(L="=.".indexOf(T[$-2])!=-1?L-2:L-1);var W=new Uint8Array(L),ne=0;return ae(T,function(oe){W[ne++]=oe}),ne!==L?W.subarray(0,ne):W}function ae(T,$){function L(Pe){for(;W<T.length;){var ht=T.charAt(W++),Et=te[ht];if(Et!=null)return Et;if(!/^[\s\xa0]*$/.test(ht))throw Error("Unknown base64 encoding at char: "+ht)}return Pe}Ne();for(var W=0;;){var ne=L(-1),oe=L(0),ie=L(64),Ce=L(64);if(Ce===64&&ne===-1)break;$(ne<<2|oe>>4),ie!=64&&($(oe<<4&240|ie>>2),Ce!=64&&$(ie<<6&192|Ce))}}function Ne(){if(!te){te={};for(var T="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),$=["+/=","+/","-_=","-_.","-_"],L=0;5>L;L++){var W=T.concat($[L].split(""));G[L]=W;for(var ne=0;ne<W.length;ne++){var oe=W[ne];te[oe]===void 0&&(te[oe]=ne)}}}}var ke=typeof Uint8Array<"u",De=!(B("Trident")||B("MSIE"))&&typeof D.btoa=="function";function be(T){if(!De){var $;$===void 0&&($=0),Ne(),$=G[$];for(var L=Array(Math.floor(T.length/3)),W=$[64]||"",ne=0,oe=0;ne<T.length-2;ne+=3){var ie=T[ne],Ce=T[ne+1],Pe=T[ne+2],ht=$[ie>>2];ie=$[(ie&3)<<4|Ce>>4],Ce=$[(Ce&15)<<2|Pe>>6],Pe=$[Pe&63],L[oe++]=ht+ie+Ce+Pe}switch(ht=0,Pe=W,T.length-ne){case 2:ht=T[ne+1],Pe=$[(ht&15)<<2]||W;case 1:T=T[ne],L[oe]=$[T>>2]+$[(T&3)<<4|ht>>4]+Pe+W}return L.join("")}for($="";10240<T.length;)$+=String.fromCharCode.apply(null,T.subarray(0,10240)),T=T.subarray(10240);return $+=String.fromCharCode.apply(null,T),btoa($)}var Xe=RegExp("[-_.]","g");function Oe(T){switch(T){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function it(T){if(!De)return ge(T);Xe.test(T)&&(T=T.replace(Xe,Oe)),T=atob(T);for(var $=new Uint8Array(T.length),L=0;L<T.length;L++)$[L]=T.charCodeAt(L);return $}var We;function dt(){return We||(We=new Uint8Array(0))}var ct={},Ve=typeof Uint8Array.prototype.slice=="function",ze=0,Be=0;function ut(T){var $=0>T;T=Math.abs(T);var L=T>>>0;T=Math.floor((T-L)/4294967296),$&&(L=a(ee(L,T)),$=L.next().value,T=L.next().value,L=$),ze=L>>>0,Be=T>>>0}var Ke=typeof BigInt=="function";function ee(T,$){return $=~$,T?T=~T+1:$+=1,[T,$]}function J(T,$){this.i=T>>>0,this.h=$>>>0}function rt(T){if(!T)return Ge||(Ge=new J(0,0));if(!/^-?\d+$/.test(T))return null;if(16>T.length)ut(Number(T));else if(Ke)T=BigInt(T),ze=Number(T&BigInt(4294967295))>>>0,Be=Number(T>>BigInt(32)&BigInt(4294967295));else{var $=+(T[0]==="-");Be=ze=0;for(var L=T.length,W=$,ne=(L-$)%6+$;ne<=L;W=ne,ne+=6)W=Number(T.slice(W,ne)),Be*=1e6,ze=1e6*ze+W,4294967296<=ze&&(Be+=ze/4294967296|0,ze%=4294967296);$&&($=a(ee(ze,Be)),T=$.next().value,$=$.next().value,ze=T,Be=$)}return new J(ze,Be)}var Ge;function ye(T,$){return Error("Invalid wire type: "+T+" (at position "+$+")")}function Ze(){return Error("Failed to read varint, encoding is invalid.")}function yt(T,$){return Error("Tried to read past the end of the data "+$+" > "+T)}function Ct(){throw Error("Invalid UTF8")}function ft(T,$){return $=String.fromCharCode.apply(null,$),T==null?$:T+$}var ce=void 0,nt,St=typeof TextDecoder<"u",gt,Gt=typeof TextEncoder<"u",Mn;function Cr(T){if(T!==ct)throw Error("illegal external caller")}function Bs(T,$){if(Cr($),this.V=T,T!=null&&T.length===0)throw Error("ByteString should be constructed with non-empty values")}function As(){return Mn||(Mn=new Bs(null,ct))}function Ms(T){Cr(ct);var $=T.V;return $=$==null||ke&&$!=null&&$ instanceof Uint8Array?$:typeof $=="string"?it($):null,$==null?$:T.V=$}function Oh(T){if(typeof T=="string")return{buffer:it(T),C:!1};if(Array.isArray(T))return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Uint8Array)return{buffer:T,C:!1};if(T.constructor===ArrayBuffer)return{buffer:new Uint8Array(T),C:!1};if(T.constructor===Bs)return{buffer:Ms(T)||dt(),C:!0};if(T instanceof Uint8Array)return{buffer:new Uint8Array(T.buffer,T.byteOffset,T.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Bl(T,$){this.i=null,this.m=!1,this.h=this.j=this.l=0,Vl(this,T,$)}function Vl(T,$,L){L=L===void 0?{}:L,T.S=L.S===void 0?!1:L.S,$&&($=Oh($),T.i=$.buffer,T.m=$.C,T.l=0,T.j=T.i.length,T.h=T.l)}Bl.prototype.reset=function(){this.h=this.l};function go(T,$){if(T.h=$,$>T.j)throw yt(T.j,$)}function Ul(T){var $=T.i,L=T.h,W=$[L++],ne=W&127;if(W&128&&(W=$[L++],ne|=(W&127)<<7,W&128&&(W=$[L++],ne|=(W&127)<<14,W&128&&(W=$[L++],ne|=(W&127)<<21,W&128&&(W=$[L++],ne|=W<<28,W&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128&&$[L++]&128)))))throw Ze();return go(T,L),ne}function Fc(T,$){if(0>$)throw Error("Tried to read a negative byte length: "+$);var L=T.h,W=L+$;if(W>T.j)throw yt($,T.j-L);return T.h=W,L}var Lc=[];function Di(){this.h=[]}Di.prototype.length=function(){return this.h.length},Di.prototype.end=function(){var T=this.h;return this.h=[],T};function Fh(T,$,L){for(;0<L||127<$;)T.h.push($&127|128),$=($>>>7|L<<25)>>>0,L>>>=7;T.h.push($)}function rl(T,$){for(;127<$;)T.h.push($&127|128),$>>>=7;T.h.push($)}function Lh(T,$){if(Lc.length){var L=Lc.pop();Vl(L,T,$),T=L}else T=new Bl(T,$);this.h=T,this.j=this.h.h,this.i=this.l=-1,this.setOptions($)}Lh.prototype.setOptions=function(T){T=T===void 0?{}:T,this.ca=T.ca===void 0?!1:T.ca},Lh.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function re(T){var $=T.h;if($.h==$.j)return!1;T.j=T.h.h;var L=Ul(T.h)>>>0;if($=L>>>3,L&=7,!(0<=L&&5>=L))throw ye(L,T.j);if(1>$)throw Error("Invalid field number: "+$+" (at position "+T.j+")");return T.l=$,T.i=L,!0}function Ue(T){switch(T.i){case 0:if(T.i!=0)Ue(T);else e:{T=T.h;for(var $=T.h,L=$+10,W=T.i;$<L;)if(!(W[$++]&128)){go(T,$);break e}throw Ze()}break;case 1:T=T.h,go(T,T.h+8);break;case 2:T.i!=2?Ue(T):($=Ul(T.h)>>>0,T=T.h,go(T,T.h+$));break;case 5:T=T.h,go(T,T.h+4);break;case 3:$=T.l;do{if(!re(T))throw Error("Unmatched start-group tag: stream EOF");if(T.i==4){if(T.l!=$)throw Error("Unmatched end-group tag");break}Ue(T)}while(1);break;default:throw ye(T.i,T.j)}}var Fe=[];function Je(){this.j=[],this.i=0,this.h=new Di}function vt(T,$){$.length!==0&&(T.j.push($),T.i+=$.length)}function zn(T,$){if($=$.R){vt(T,T.h.end());for(var L=0;L<$.length;L++)vt(T,Ms($[L])||dt())}}var sn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Tn(T,$){return sn?T[sn]|=$:T.A!==void 0?T.A|=$:(Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}}),$)}function En(T,$){sn?T[sn]&&(T[sn]&=~$):T.A!==void 0&&(T.A&=~$)}function Nn(T){var $;return sn?$=T[sn]:$=T.A,$??0}function er(T,$){sn?T[sn]=$:T.A!==void 0?T.A=$:Object.defineProperties(T,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}})}function _n(T){return Tn(T,1),T}function ur(T,$){er($,(T|0)&-51)}function Oi(T,$){er($,(T|18)&-41)}var xr={};function Zi(T){return T!==null&&typeof T=="object"&&!Array.isArray(T)&&T.constructor===Object}var Ar,Io=[];er(Io,23),Ar=Object.freeze(Io);function rs(T){if(Nn(T.o)&2)throw Error("Cannot mutate an immutable Message")}function yo(T){var $=T.length;($=$?T[$-1]:void 0)&&Zi($)?$.g=1:($={},T.push(($.g=1,$)))}function Ao(T){var $=T.i+T.G;return T.B||(T.B=T.o[$]={})}function Ns(T,$){return $===-1?null:$>=T.i?T.B?T.B[$]:void 0:T.o[$+T.G]}function bo(T,$,L,W){rs(T),zh(T,$,L,W)}function zh(T,$,L,W){T.j&&(T.j=void 0),$>=T.i||W?Ao(T)[$]=L:(T.o[$+T.G]=L,(T=T.B)&&$ in T&&delete T[$])}function sl(T,$,L,W){var ne=Ns(T,$);Array.isArray(ne)||(ne=Ar);var oe=Nn(ne);if(oe&1||_n(ne),W)oe&2||Tn(ne,2),L&1||Object.freeze(ne);else{W=!(L&2);var ie=oe&2;L&1||!ie?W&&oe&16&&!ie&&En(ne,16):(ne=_n(Array.prototype.slice.call(ne)),zh(T,$,ne))}return ne}function Ji(T,$){var L=Ns(T,$),W=L==null?L:typeof L=="number"||L==="NaN"||L==="Infinity"||L==="-Infinity"?Number(L):void 0;return W!=null&&W!==L&&zh(T,$,W),W}function zc(T,$,L,W,ne){T.h||(T.h={});var oe=T.h[L],ie=sl(T,L,3,ne);if(!oe){var Ce=ie;oe=[];var Pe=!!(Nn(T.o)&16);ie=!!(Nn(Ce)&2);var ht=Ce;!ne&&ie&&(Ce=Array.prototype.slice.call(Ce));for(var Et=ie,hn=0;hn<Ce.length;hn++){var Ut=Ce[hn],Rt=$,an=!1;if(an=an===void 0?!1:an,Ut=Array.isArray(Ut)?new Rt(Ut):an?new Rt:void 0,Ut!==void 0){Rt=Ut.o;var Bn=an=Nn(Rt);ie&&(Bn|=2),Pe&&(Bn|=16),Bn!=an&&er(Rt,Bn),Rt=Bn,Et=Et||!!(2&Rt),oe.push(Ut)}}return T.h[L]=oe,Pe=Nn(Ce),$=Pe|33,$=Et?$&-9:$|8,Pe!=$&&(Et=Ce,Object.isFrozen(Et)&&(Et=Array.prototype.slice.call(Et)),er(Et,$),Ce=Et),ht!==Ce&&zh(T,L,Ce),(ne||W&&ie)&&Tn(oe,2),W&&Object.freeze(oe),oe}return ne||(ne=Object.isFrozen(oe),W&&!ne?Object.freeze(oe):!W&&ne&&(oe=Array.prototype.slice.call(oe),T.h[L]=oe)),oe}function Aa(T,$,L){var W=!!(Nn(T.o)&2);if($=zc(T,$,L,W,W),T=sl(T,L,3,W),!(W||Nn(T)&8)){for(W=0;W<$.length;W++){if(L=$[W],Nn(L.o)&2){var ne=Wl(L,!1);ne.j=L}else ne=L;L!==ne&&($[W]=ne,T[W]=ne.o)}Tn(T,8)}return $}function $s(T,$,L){if(L!=null&&typeof L!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof L+": "+L);bo(T,$,L)}function Bc(T,$,L,W,ne){rs(T);var oe=zc(T,L,$,!1,!1);return L=W??new L,T=sl(T,$,2,!1),ne!=null?(oe.splice(ne,0,L),T.splice(ne,0,L.o)):(oe.push(L),T.push(L.o)),L.C()&&En(T,8),L}function Qi(T,$){return T??$}function Vs(T,$,L){return L=L===void 0?0:L,Qi(Ji(T,$),L)}var Bh;function o0(T){switch(typeof T){case"number":return isFinite(T)?T:String(T);case"object":if(T)if(Array.isArray(T)){if(Nn(T)&128)return T=Array.prototype.slice.call(T),yo(T),T}else{if(ke&&T!=null&&T instanceof Uint8Array)return be(T);if(T instanceof Bs){var $=T.V;return $==null?"":typeof $=="string"?$:T.V=be($)}}}return T}function Vh(T,$,L,W){if(T!=null){if(Array.isArray(T))T=eo(T,$,L,W!==void 0);else if(Zi(T)){var ne={},oe;for(oe in T)ne[oe]=Vh(T[oe],$,L,W);T=ne}else T=$(T,W);return T}}function eo(T,$,L,W){var ne=Nn(T);W=W?!!(ne&16):void 0,T=Array.prototype.slice.call(T);for(var oe=0;oe<T.length;oe++)T[oe]=Vh(T[oe],$,L,W);return L(ne,T),T}function Uh(T){return T.ja===xr?T.toJSON():o0(T)}function Jf(T,$){T&128&&yo($)}function Hu(T,$,L){if(L=L===void 0?Oi:L,T!=null){if(ke&&T instanceof Uint8Array)return T.length?new Bs(new Uint8Array(T),ct):As();if(Array.isArray(T)){var W=Nn(T);return W&2?T:$&&!(W&32)&&(W&16||W===0)?(er(T,W|2),T):(T=eo(T,Hu,W&4?Oi:L,!0),$=Nn(T),$&4&&$&2&&Object.freeze(T),T)}return T.ja===xr?Wh(T):T}}function Qf(T,$,L,W,ne,oe,ie){if(T=T.h&&T.h[L]){if(W=Nn(T),W&2?W=T:(oe=X(T,Wh),Oi(W,oe),Object.freeze(oe),W=oe),rs($),ie=W==null?Ar:_n([]),W!=null){for(oe=!!W.length,T=0;T<W.length;T++){var Ce=W[T];oe=oe&&!(Nn(Ce.o)&2),ie[T]=Ce.o}oe=(oe?8:0)|1,T=Nn(ie),(T&oe)!==oe&&(Object.isFrozen(ie)&&(ie=Array.prototype.slice.call(ie)),er(ie,T|oe)),$.h||($.h={}),$.h[L]=W}else $.h&&($.h[L]=void 0);zh($,L,ie,ne)}else bo($,L,Hu(W,oe,ie),ne)}function Wh(T){return Nn(T.o)&2||(T=Wl(T,!0),Tn(T.o,2)),T}function Wl(T,$){var L=T.o,W=[];Tn(W,16);var ne=T.constructor.h;if(ne&&W.push(ne),ne=T.B,ne){W.length=L.length,W.fill(void 0,W.length,L.length);var oe={};W[W.length-1]=oe}Nn(L)&128&&yo(W),$=$||T.C()?Oi:ur,oe=T.constructor,Bh=W,W=new oe(W),Bh=void 0,T.R&&(W.R=T.R.slice()),oe=!!(Nn(L)&16);for(var ie=ne?L.length-1:L.length,Ce=0;Ce<ie;Ce++)Qf(T,W,Ce-T.G,L[Ce],!1,oe,$);if(ne)for(var Pe in ne)Qf(T,W,+Pe,ne[Pe],!0,oe,$);return W}function Zr(T,$,L){T==null&&(T=Bh),Bh=void 0;var W=this.constructor.i||0,ne=0<W,oe=this.constructor.h,ie=!1;if(T==null){T=oe?[oe]:[];var Ce=48,Pe=!0;ne&&(W=0,Ce|=128),er(T,Ce)}else{if(!Array.isArray(T)||oe&&oe!==T[0])throw Error();var ht=Ce=Tn(T,0);if((Pe=(16&ht)!==0)&&((ie=(32&ht)!==0)||(ht|=32)),ne){if(128&ht)W=0;else if(0<T.length){var Et=T[T.length-1];if(Zi(Et)&&"g"in Et){W=0,ht|=128,delete Et.g;var hn=!0,Ut;for(Ut in Et){hn=!1;break}hn&&T.pop()}}}else if(128&ht)throw Error();Ce!==ht&&er(T,ht)}this.G=(oe?0:-1)-W,this.h=void 0,this.o=T;e:{if(oe=this.o.length,W=oe-1,oe&&(oe=this.o[W],Zi(oe))){this.B=oe,this.i=W-this.G;break e}$!==void 0&&-1<$?(this.i=Math.max($,W+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!ne&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(L){$=Pe&&!ie&&!0,ne=this.i;var Rt;for(Pe=0;Pe<L.length;Pe++)ie=L[Pe],ie<ne?(ie+=this.G,(W=T[ie])?a0(W,$):T[ie]=Ar):(Rt||(Rt=Ao(this)),(W=Rt[ie])?a0(W,$):Rt[ie]=Ar)}}Zr.prototype.toJSON=function(){return eo(this.o,Uh,Jf)},Zr.prototype.C=function(){return!!(Nn(this.o)&2)};function a0(T,$){if(Array.isArray(T)){var L=Nn(T),W=1;!$||L&2||(W|=16),(L&W)!==W&&er(T,L|W)}}Zr.prototype.ja=xr,Zr.prototype.toString=function(){return this.o.toString()};function ed(T,$,L){if(L){var W={},ne;for(ne in L){var oe=L[ne],ie=oe.ra;ie||(W.J=oe.xa||oe.oa.W,oe.ia?(W.aa=at(oe.ia),ie=function(Ce){return function(Pe,ht,Et){return Ce.J(Pe,ht,Et,Ce.aa)}}(W)):oe.ka?(W.Z=Vt(oe.da.P,oe.ka),ie=function(Ce){return function(Pe,ht,Et){return Ce.J(Pe,ht,Et,Ce.Z)}}(W)):ie=W.J,oe.ra=ie),ie($,T,oe.da),W={J:W.J,aa:W.aa,Z:W.Z}}}zn($,T)}var Vc=Symbol();function Gh(T,$,L){return T[Vc]||(T[Vc]=function(W,ne){return $(W,ne,L)})}function l0(T){var $=T[Vc];if(!$){var L=vx(T);$=function(W,ne){return u0(W,ne,L)},T[Vc]=$}return $}function c0(T){var $=T.ia;if($)return l0($);if($=T.wa)return Gh(T.da.P,$,T.ka)}function H(T){var $=c0(T),L=T.da,W=T.oa.U;return $?function(ne,oe){return W(ne,oe,L,$)}:function(ne,oe){return W(ne,oe,L)}}function Y(T,$){var L=T[$];return typeof L=="function"&&L.length===0&&(L=L(),T[$]=L),Array.isArray(L)&&(Gp in L||$n in L||0<L.length&&typeof L[0]=="function")?L:void 0}function pe(T,$,L,W,ne,oe){$.P=T[0];var ie=1;if(T.length>ie&&typeof T[ie]!="number"){var Ce=T[ie++];L($,Ce)}for(;ie<T.length;){L=T[ie++];for(var Pe=ie+1;Pe<T.length&&typeof T[Pe]!="number";)Pe++;switch(Ce=T[ie++],Pe-=ie,Pe){case 0:W($,L,Ce);break;case 1:(Pe=Y(T,ie))?(ie++,ne($,L,Ce,Pe)):W($,L,Ce,T[ie++]);break;case 2:Pe=ie++,Pe=Y(T,Pe),ne($,L,Ce,Pe,T[ie++]);break;case 3:oe($,L,Ce,T[ie++],T[ie++],T[ie++]);break;case 4:oe($,L,Ce,T[ie++],T[ie++],T[ie++],T[ie++]);break;default:throw Error("unexpected number of binary field arguments: "+Pe)}}return $}var Re=Symbol();function at(T){var $=T[Re];if(!$){var L=bx(T);$=function(W,ne){return JC(W,ne,L)},T[Re]=$}return $}function Vt(T,$){var L=T[Re];return L||(L=function(W,ne){return ed(W,ne,$)},T[Re]=L),L}var $n=Symbol();function Rs(T,$){T.push($)}function Us(T,$,L){T.push($,L.W)}function pi(T,$,L,W){var ne=at(W),oe=bx(W).P,ie=L.W;T.push($,function(Ce,Pe,ht){return ie(Ce,Pe,ht,oe,ne)})}function Ma(T,$,L,W,ne,oe){var ie=Vt(W,oe),Ce=L.W;T.push($,function(Pe,ht,Et){return Ce(Pe,ht,Et,W,ie)})}function bx(T){var $=T[$n];return $||($=pe(T,T[$n]=[],Rs,Us,pi,Ma),Gp in T&&$n in T&&(T.length=0),$)}var Gp=Symbol();function ZC(T,$){T[0]=$}function K$(T,$,L,W){var ne=L.U;T[$]=W?function(oe,ie,Ce){return ne(oe,ie,Ce,W)}:ne}function Y$(T,$,L,W,ne){var oe=L.U,ie=l0(W),Ce=vx(W).P;T[$]=function(Pe,ht,Et){return oe(Pe,ht,Et,Ce,ie,ne)}}function Z$(T,$,L,W,ne,oe,ie){var Ce=L.U,Pe=Gh(W,ne,oe);T[$]=function(ht,Et,hn){return Ce(ht,Et,hn,W,Pe,ie)}}function vx(T){var $=T[Gp];return $||($=pe(T,T[Gp]={},ZC,K$,Y$,Z$),Gp in T&&$n in T&&(T.length=0),$)}function u0(T,$,L){for(;re($)&&$.i!=4;){var W=$.l,ne=L[W];if(!ne){var oe=L[0];oe&&(oe=oe[W])&&(ne=L[W]=H(oe))}if(!ne||!ne($,T,W)){ne=$,W=T,oe=ne.j,Ue(ne);var ie=ne;if(!ie.ca){if(ne=ie.h.h-oe,ie.h.h=oe,ie=ie.h,ne==0)ne=As();else{if(oe=Fc(ie,ne),ie.S&&ie.m)ne=ie.i.subarray(oe,oe+ne);else{ie=ie.i;var Ce=oe;ne=oe+ne,ne=Ce===ne?dt():Ve?ie.slice(Ce,ne):new Uint8Array(ie.subarray(Ce,ne))}ne=ne.length==0?As():new Bs(ne,ct)}(oe=W.R)?oe.push(ne):W.R=[ne]}}}return T}function JC(T,$,L){for(var W=L.length,ne=W%2==1,oe=ne?1:0;oe<W;oe+=2)(0,L[oe+1])($,T,L[oe]);ed(T,$,ne?L[0]:void 0)}function Hp(T,$){return{U:T,W:$}}var il=Hp(function(T,$,L){if(T.i!==5)return!1;T=T.h;var W=T.i,ne=T.h,oe=W[ne],ie=W[ne+1],Ce=W[ne+2];return W=W[ne+3],go(T,T.h+4),ie=(oe<<0|ie<<8|Ce<<16|W<<24)>>>0,T=2*(ie>>31)+1,oe=ie>>>23&255,ie&=8388607,bo($,L,oe==255?ie?NaN:1/0*T:oe==0?T*Math.pow(2,-149)*ie:T*Math.pow(2,oe-150)*(ie+Math.pow(2,23))),!0},function(T,$,L){if($=Ji($,L),$!=null){rl(T.h,8*L+5),T=T.h;var W=+$;W===0?0<1/W?ze=Be=0:(Be=0,ze=2147483648):isNaN(W)?(Be=0,ze=2147483647):(W=(L=0>W?-2147483648:0)?-W:W,34028234663852886e22<W?(Be=0,ze=(L|2139095040)>>>0):11754943508222875e-54>W?(W=Math.round(W/Math.pow(2,-149)),Be=0,ze=(L|W)>>>0):($=Math.floor(Math.log(W)/Math.LN2),W*=Math.pow(2,-$),W=Math.round(8388608*W),16777216<=W&&++$,Be=0,ze=(L|$+127<<23|W&8388607)>>>0)),L=ze,T.h.push(L>>>0&255),T.h.push(L>>>8&255),T.h.push(L>>>16&255),T.h.push(L>>>24&255)}}),J$=Hp(function(T,$,L){if(T.i!==0)return!1;var W=T.h,ne=0,oe=T=0,ie=W.i,Ce=W.h;do{var Pe=ie[Ce++];ne|=(Pe&127)<<oe,oe+=7}while(32>oe&&Pe&128);for(32<oe&&(T|=(Pe&127)>>4),oe=3;32>oe&&Pe&128;oe+=7)Pe=ie[Ce++],T|=(Pe&127)<<oe;if(go(W,Ce),128>Pe)W=ne>>>0,Pe=T>>>0,(T=Pe&2147483648)&&(W=~W+1>>>0,Pe=~Pe>>>0,W==0&&(Pe=Pe+1>>>0)),W=4294967296*Pe+(W>>>0);else throw Ze();return bo($,L,T?-W:W),!0},function(T,$,L){$=Ns($,L),$!=null&&(typeof $=="string"&&rt($),$!=null&&(rl(T.h,8*L),typeof $=="number"?(T=T.h,ut($),Fh(T,ze,Be)):(L=rt($),Fh(T.h,L.i,L.h))))}),Q$=Hp(function(T,$,L){return T.i!==0?!1:(bo($,L,Ul(T.h)),!0)},function(T,$,L){if($=Ns($,L),$!=null&&$!=null)if(rl(T.h,8*L),T=T.h,L=$,0<=L)rl(T,L);else{for($=0;9>$;$++)T.h.push(L&127|128),L>>=7;T.h.push(1)}}),Br=Hp(function(T,$,L){if(T.i!==2)return!1;var W=Ul(T.h)>>>0;T=T.h;var ne=Fc(T,W);if(T=T.i,St){var oe=T,ie;(ie=nt)||(ie=nt=new TextDecoder("utf-8",{fatal:!0})),T=ne+W,oe=ne===0&&T===oe.length?oe:oe.subarray(ne,T);try{var Ce=ie.decode(oe)}catch(hn){if(ce===void 0){try{ie.decode(new Uint8Array([128]))}catch{}try{ie.decode(new Uint8Array([97])),ce=!0}catch{ce=!1}}throw!ce&&(nt=void 0),hn}}else{Ce=ne,W=Ce+W,ne=[];for(var Pe=null,ht,Et;Ce<W;)ht=T[Ce++],128>ht?ne.push(ht):224>ht?Ce>=W?Ct():(Et=T[Ce++],194>ht||(Et&192)!==128?(Ce--,Ct()):ne.push((ht&31)<<6|Et&63)):240>ht?Ce>=W-1?Ct():(Et=T[Ce++],(Et&192)!==128||ht===224&&160>Et||ht===237&&160<=Et||((oe=T[Ce++])&192)!==128?(Ce--,Ct()):ne.push((ht&15)<<12|(Et&63)<<6|oe&63)):244>=ht?Ce>=W-2?Ct():(Et=T[Ce++],(Et&192)!==128||(ht<<28)+(Et-144)>>30||((oe=T[Ce++])&192)!==128||((ie=T[Ce++])&192)!==128?(Ce--,Ct()):(ht=(ht&7)<<18|(Et&63)<<12|(oe&63)<<6|ie&63,ht-=65536,ne.push((ht>>10&1023)+55296,(ht&1023)+56320))):Ct(),8192<=ne.length&&(Pe=ft(Pe,ne),ne.length=0);Ce=ft(Pe,ne)}return bo($,L,Ce),!0},function(T,$,L){if($=Ns($,L),$!=null){var W=!1;if(W=W===void 0?!1:W,Gt){if(W&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test($))throw Error("Found an unpaired surrogate");$=(gt||(gt=new TextEncoder)).encode($)}else{for(var ne=0,oe=new Uint8Array(3*$.length),ie=0;ie<$.length;ie++){var Ce=$.charCodeAt(ie);if(128>Ce)oe[ne++]=Ce;else{if(2048>Ce)oe[ne++]=Ce>>6|192;else{if(55296<=Ce&&57343>=Ce){if(56319>=Ce&&ie<$.length){var Pe=$.charCodeAt(++ie);if(56320<=Pe&&57343>=Pe){Ce=1024*(Ce-55296)+Pe-56320+65536,oe[ne++]=Ce>>18|240,oe[ne++]=Ce>>12&63|128,oe[ne++]=Ce>>6&63|128,oe[ne++]=Ce&63|128;continue}else ie--}if(W)throw Error("Found an unpaired surrogate");Ce=65533}oe[ne++]=Ce>>12|224,oe[ne++]=Ce>>6&63|128}oe[ne++]=Ce&63|128}}$=ne===oe.length?oe:oe.subarray(0,ne)}rl(T.h,8*L+2),rl(T.h,$.length),vt(T,T.h.end()),vt(T,$)}}),Rr=Hp(function(T,$,L,W,ne){if(T.i!==2)return!1;$=Bc($,L,W),L=T.h.j,W=Ul(T.h)>>>0;var oe=T.h.h+W,ie=oe-L;if(0>=ie&&(T.h.j=oe,ne($,T,void 0,void 0,void 0),ie=oe-T.h.h),ie)throw Error("Message parsing ended unexpectedly. Expected to read "+(W+" bytes, instead read "+(W-ie)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return T.h.h=oe,T.h.j=L,!0},function(T,$,L,W,ne){if($=Aa($,W,L),$!=null)for(W=0;W<$.length;W++){var oe=T;rl(oe.h,8*L+2);var ie=oe.h.end();vt(oe,ie),ie.push(oe.i),oe=ie,ne($[W],T),ie=T;var Ce=oe.pop();for(Ce=ie.i+ie.h.length()-Ce;127<Ce;)oe.push(Ce&127|128),Ce>>>=7,ie.i++;oe.push(Ce),ie.i++}});function wx(T){return function($,L){e:{if(Fe.length){var W=Fe.pop();W.setOptions(L),Vl(W.h,$,L),$=W}else $=new Lh($,L);try{var ne=vx(T),oe=u0(new ne.P,$,ne);break e}finally{ne=$.h,ne.i=null,ne.m=!1,ne.l=0,ne.j=0,ne.h=0,ne.S=!1,$.l=-1,$.i=-1,100>Fe.length&&Fe.push($)}oe=void 0}return oe}}function xx(T){return function(){var $=new Je;JC(this,$,bx(T)),vt($,$.h.end());for(var L=new Uint8Array($.i),W=$.j,ne=W.length,oe=0,ie=0;ie<ne;ie++){var Ce=W[ie];L.set(Ce,oe),oe+=Ce.length}return $.j=[L],L}}function td(T){Zr.call(this,T)}g(td,Zr);var QC=[td,1,Q$,2,il,3,Br,4,Br];td.prototype.l=xx(QC);function _x(T){Zr.call(this,T,-1,eR)}g(_x,Zr),_x.prototype.addClassification=function(T,$){return Bc(this,1,td,T,$),this};var eR=[1],ek=wx([_x,1,Rr,QC]);function jp(T){Zr.call(this,T)}g(jp,Zr);var mi=[jp,1,il,2,il,3,il,4,il,5,il];jp.prototype.l=xx(mi);function h0(T){Zr.call(this,T,-1,Hh)}g(h0,Zr);var Hh=[1],tk=wx([h0,1,Rr,mi]);function nd(T){Zr.call(this,T)}g(nd,Zr);var ia=[nd,1,il,2,il,3,il,4,il,5,il,6,J$],nk=wx(ia);nd.prototype.l=xx(ia);function Sx(T,$,L){if(L=T.createShader(L===0?T.VERTEX_SHADER:T.FRAGMENT_SHADER),T.shaderSource(L,$),T.compileShader(L),!T.getShaderParameter(L,T.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+T.getShaderInfoLog(L));return L}function rk(T){return Aa(T,td,1).map(function($){var L=Ns($,1);return{index:L??0,qa:Vs($,2),label:Ns($,3)!=null?Qi(Ns($,3),""):void 0,displayName:Ns($,4)!=null?Qi(Ns($,4),""):void 0}})}function sk(T){return{x:Vs(T,1),y:Vs(T,2),z:Vs(T,3),visibility:Ji(T,4)!=null?Vs(T,4):void 0}}function f0(T){return Aa(tk(T),jp,1).map(sk)}function d0(T,$){this.i=T,this.h=$,this.m=0}function Mo(T,$,L){return tR(T,$),typeof T.h.canvas.transferToImageBitmap=="function"?Promise.resolve(T.h.canvas.transferToImageBitmap()):L?Promise.resolve(T.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(T.h.canvas):(T.j===void 0&&(T.j=document.createElement("canvas")),new Promise(function(W){T.j.height=T.h.canvas.height,T.j.width=T.h.canvas.width,T.j.getContext("2d",{}).drawImage(T.h.canvas,0,0,T.h.canvas.width,T.h.canvas.height),W(T.j)}))}function tR(T,$){var L=T.h;if(T.s===void 0){var W=Sx(L,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ne=Sx(L,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),oe=L.createProgram();if(L.attachShader(oe,W),L.attachShader(oe,ne),L.linkProgram(oe),!L.getProgramParameter(oe,L.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+L.getProgramInfoLog(oe));W=T.s=oe,L.useProgram(W),ne=L.getUniformLocation(W,"sampler0"),T.l={O:L.getAttribLocation(W,"aVertex"),N:L.getAttribLocation(W,"aTex"),ya:ne},T.v=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.enableVertexAttribArray(T.l.O),L.vertexAttribPointer(T.l.O,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),T.u=L.createBuffer(),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.enableVertexAttribArray(T.l.N),L.vertexAttribPointer(T.l.N,2,L.FLOAT,!1,0,0),L.bufferData(L.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),L.STATIC_DRAW),L.bindBuffer(L.ARRAY_BUFFER,null),L.uniform1i(ne,0)}W=T.l,L.useProgram(T.s),L.canvas.width=$.width,L.canvas.height=$.height,L.viewport(0,0,$.width,$.height),L.activeTexture(L.TEXTURE0),T.i.bindTexture2d($.glName),L.enableVertexAttribArray(W.O),L.bindBuffer(L.ARRAY_BUFFER,T.v),L.vertexAttribPointer(W.O,2,L.FLOAT,!1,0,0),L.enableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,T.u),L.vertexAttribPointer(W.N,2,L.FLOAT,!1,0,0),L.bindFramebuffer(L.DRAW_FRAMEBUFFER?L.DRAW_FRAMEBUFFER:L.FRAMEBUFFER,null),L.clearColor(0,0,0,0),L.clear(L.COLOR_BUFFER_BIT),L.colorMask(!0,!0,!0,!0),L.drawArrays(L.TRIANGLE_FAN,0,4),L.disableVertexAttribArray(W.O),L.disableVertexAttribArray(W.N),L.bindBuffer(L.ARRAY_BUFFER,null),T.i.bindTexture2d(0)}function Na(T){this.h=T}var nR=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ik(T,$){return $+T}function Uc(T,$){window[T]=$}function p0(T){var $=document.createElement("script");return $.setAttribute("src",T),$.setAttribute("crossorigin","anonymous"),new Promise(function(L){$.addEventListener("load",function(){L()},!1),$.addEventListener("error",function(){L()},!1),document.body.appendChild($)})}function Cx(){return N(function(T){switch(T.h){case 1:return T.s=2,w(T,WebAssembly.instantiate(nR),4);case 4:T.h=3,T.s=0;break;case 2:return T.s=0,T.l=null,T.return(!1);case 3:return T.return(!0)}})}function Vr(T){if(this.h=T,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=T&&T.locateFile||ik,typeof window=="object")var $=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")$=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=$,T.options){$=a(Object.keys(T.options));for(var L=$.next();!L.done;L=$.next()){L=L.value;var W=T.options[L].default;W!==void 0&&(this.l[L]=typeof W=="function"?W():W)}}}n=Vr.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function ju(T){var $,L,W,ne,oe,ie,Ce,Pe,ht,Et,hn;return N(function(Ut){switch(Ut.h){case 1:return T.ga?($=T.h.files===void 0?[]:typeof T.h.files=="function"?T.h.files(T.l):T.h.files,w(Ut,Cx(),2)):Ut.return();case 2:if(L=Ut.i,typeof window=="object")return Uc("createMediapipeSolutionsWasm",{locateFile:T.locateFile}),Uc("createMediapipeSolutionsPackedAssets",{locateFile:T.locateFile}),ie=$.filter(function(Rt){return Rt.data!==void 0}),Ce=$.filter(function(Rt){return Rt.data===void 0}),Pe=Promise.all(ie.map(function(Rt){var an=rd(T,Rt.url);if(Rt.path!==void 0){var Bn=Rt.path;an=an.then(function(Ur){return T.overrideFile(Bn,Ur),Promise.resolve(Ur)})}return an})),ht=Promise.all(Ce.map(function(Rt){return Rt.simd===void 0||Rt.simd&&L||!Rt.simd&&!L?p0(T.locateFile(Rt.url,T.ha)):Promise.resolve()})).then(function(){var Rt,an,Bn;return N(function(Ur){if(Ur.h==1)return Rt=window.createMediapipeSolutionsWasm,an=window.createMediapipeSolutionsPackedAssets,Bn=T,w(Ur,Rt(an),2);Bn.i=Ur.i,Ur.h=0})}),Et=function(){return N(function(Rt){return T.h.graph&&T.h.graph.url?Rt=w(Rt,rd(T,T.h.graph.url),0):(Rt.h=0,Rt=void 0),Rt})}(),w(Ut,Promise.all([ht,Pe,Et]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return W=$.filter(function(Rt){return Rt.simd===void 0||Rt.simd&&L||!Rt.simd&&!L}).map(function(Rt){return T.locateFile(Rt.url,T.ha)}),importScripts.apply(null,l(W)),ne=T,w(Ut,createMediapipeSolutionsWasm(Module),6);case 6:ne.i=Ut.i,T.m=new OffscreenCanvas(1,1),T.i.canvas=T.m,oe=T.i.GL.createContext(T.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),T.i.GL.makeContextCurrent(oe),Ut.h=4;break;case 7:if(T.m=document.createElement("canvas"),hn=T.m.getContext("webgl2",{}),!hn&&(hn=T.m.getContext("webgl",{}),!hn))return alert("Failed to create WebGL canvas context when passing video frame."),Ut.return();T.K=hn,T.i.canvas=T.m,T.i.createContext(T.m,!0,!0,{});case 4:T.j=new T.i.SolutionWasm,T.ga=!1,Ut.h=0}})}function kx(T){var $,L,W,ne,oe,ie,Ce,Pe;return N(function(ht){if(ht.h==1){if(T.h.graph&&T.h.graph.url&&T.fa===T.h.graph.url)return ht.return();if(T.u=!0,!T.h.graph||!T.h.graph.url){ht.h=2;return}return T.fa=T.h.graph.url,w(ht,rd(T,T.h.graph.url),3)}for(ht.h!=2&&($=ht.i,T.j.loadGraph($)),L=a(Object.keys(T.D)),W=L.next();!W.done;W=L.next())ne=W.value,T.j.overrideFile(ne,T.D[ne]);if(T.D={},T.h.listeners)for(oe=a(T.h.listeners),ie=oe.next();!ie.done;ie=oe.next())Ce=ie.value,oR(T,Ce);Pe=T.l,T.l={},T.setOptions(Pe),ht.h=0})}n.reset=function(){var T=this;return N(function($){T.j&&(T.j.reset(),T.s={},T.v={}),$.h=0})},n.setOptions=function(T,$){var L=this;if($=$||this.h.options){for(var W=[],ne=[],oe={},ie=a(Object.keys(T)),Ce=ie.next();!Ce.done;oe={X:oe.X,Y:oe.Y},Ce=ie.next())if(Ce=Ce.value,!(Ce in this.l&&this.l[Ce]===T[Ce])){this.l[Ce]=T[Ce];var Pe=$[Ce];Pe!==void 0&&(Pe.onChange&&(oe.X=Pe.onChange,oe.Y=T[Ce],W.push(function(ht){return function(){var Et;return N(function(hn){if(hn.h==1)return w(hn,ht.X(ht.Y),2);Et=hn.i,Et===!0&&(L.u=!0),hn.h=0})}}(oe))),Pe.graphOptionXref&&(Ce=Object.assign({},{calculatorName:"",calculatorIndex:0},Pe.graphOptionXref,{valueNumber:Pe.type===1?T[Ce]:0,valueBoolean:Pe.type===0?T[Ce]:!1,valueString:Pe.type===2?T[Ce]:""}),ne.push(Ce)))}(W.length!==0||ne.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(ne),this.F=(this.F===void 0?[]:this.F).concat(W))}};function rR(T){var $,L,W,ne,oe,ie,Ce;return N(function(Pe){switch(Pe.h){case 1:if(!T.u)return Pe.return();if(!T.F){Pe.h=2;break}$=a(T.F),L=$.next();case 3:if(L.done){Pe.h=5;break}return W=L.value,w(Pe,W(),4);case 4:L=$.next(),Pe.h=3;break;case 5:T.F=void 0;case 2:if(T.H){for(ne=new T.i.GraphOptionChangeRequestList,oe=a(T.H),ie=oe.next();!ie.done;ie=oe.next())Ce=ie.value,ne.push_back(Ce);T.j.changeOptions(ne),ne.delete(),T.H=void 0}T.u=!1,Pe.h=0}})}n.initialize=function(){var T=this;return N(function($){return $.h==1?w($,ju(T),2):$.h!=3?w($,kx(T),3):w($,rR(T),0)})};function rd(T,$){var L,W;return N(function(ne){return $ in T.L?ne.return(T.L[$]):(L=T.locateFile($,""),W=fetch(L).then(function(oe){return oe.arrayBuffer()}),T.L[$]=W,ne.return(W))})}n.overrideFile=function(T,$){this.j?this.j.overrideFile(T,$):this.D[T]=$},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(T,$){var L=this,W,ne,oe,ie,Ce,Pe,ht,Et,hn;return N(function(Ut){switch(Ut.h){case 1:return L.h.inputs?(W=1e3*($??performance.now()),w(Ut,L.I,2)):Ut.return();case 2:return w(Ut,L.initialize(),3);case 3:for(ne=new L.i.PacketDataList,oe=a(Object.keys(T)),ie=oe.next();!ie.done;ie=oe.next())if(Ce=ie.value,Pe=L.h.inputs[Ce]){e:{var Rt=T[Ce];switch(Pe.type){case"video":var an=L.s[Pe.stream];if(an||(an=new d0(L.i,L.K),L.s[Pe.stream]=an),an.m===0&&(an.m=an.i.createTexture()),typeof HTMLVideoElement<"u"&&Rt instanceof HTMLVideoElement)var Bn=Rt.videoWidth,Ur=Rt.videoHeight;else typeof HTMLImageElement<"u"&&Rt instanceof HTMLImageElement?(Bn=Rt.naturalWidth,Ur=Rt.naturalHeight):(Bn=Rt.width,Ur=Rt.height);Ur={glName:an.m,width:Bn,height:Ur},Bn=an.h,Bn.canvas.width=Ur.width,Bn.canvas.height=Ur.height,Bn.activeTexture(Bn.TEXTURE0),an.i.bindTexture2d(an.m),Bn.texImage2D(Bn.TEXTURE_2D,0,Bn.RGBA,Bn.RGBA,Bn.UNSIGNED_BYTE,Rt),an.i.bindTexture2d(0),an=Ur;break e;case"detections":for(an=L.s[Pe.stream],an||(an=new Na(L.i),L.s[Pe.stream]=an),an.data||(an.data=new an.h.DetectionListData),an.data.reset(Rt.length),Ur=0;Ur<Rt.length;++Ur){Bn=Rt[Ur];var Wr=an.data,Fi=Wr.setBoundingBox,$a=Ur,No=Bn.la,br=new nd;if($s(br,1,No.sa),$s(br,2,No.ta),$s(br,3,No.height),$s(br,4,No.width),$s(br,5,No.rotation),bo(br,6,No.pa),No=br.l(),Fi.call(Wr,$a,No),Bn.ea)for(Wr=0;Wr<Bn.ea.length;++Wr){br=Bn.ea[Wr],Fi=an.data,$a=Fi.addNormalizedLandmark,No=Ur,br=Object.assign({},br,{visibility:br.visibility?br.visibility:0});var xs=new jp;$s(xs,1,br.x),$s(xs,2,br.y),$s(xs,3,br.z),br.visibility&&$s(xs,4,br.visibility),br=xs.l(),$a.call(Fi,No,br)}if(Bn.ba)for(Wr=0;Wr<Bn.ba.length;++Wr)Fi=an.data,$a=Fi.addClassification,No=Ur,br=Bn.ba[Wr],xs=new td,$s(xs,2,br.qa),br.index&&bo(xs,1,br.index),br.label&&bo(xs,3,br.label),br.displayName&&bo(xs,4,br.displayName),br=xs.l(),$a.call(Fi,No,br)}an=an.data;break e;default:an={}}}switch(ht=an,Et=Pe.stream,Pe.type){case"video":ne.pushTexture2d(Object.assign({},ht,{stream:Et,timestamp:W}));break;case"detections":hn=ht,hn.stream=Et,hn.timestamp=W,ne.pushDetectionList(hn);break;default:throw Error("Unknown input config type: '"+Pe.type+"'")}}return L.j.send(ne),w(Ut,L.I,4);case 4:ne.delete(),Ut.h=0}})};function sR(T,$,L){var W,ne,oe,ie,Ce,Pe,ht,Et,hn,Ut,Rt,an,Bn,Ur;return N(function(Wr){switch(Wr.h){case 1:if(!L)return Wr.return($);for(W={},ne=0,oe=a(Object.keys(L)),ie=oe.next();!ie.done;ie=oe.next())Ce=ie.value,Pe=L[Ce],typeof Pe!="string"&&Pe.type==="texture"&&$[Pe.stream]!==void 0&&++ne;1<ne&&(T.M=!1),ht=a(Object.keys(L)),ie=ht.next();case 2:if(ie.done){Wr.h=4;break}if(Et=ie.value,hn=L[Et],typeof hn=="string")return Bn=W,Ur=Et,w(Wr,iR(T,Et,$[hn]),14);if(Ut=$[hn.stream],hn.type==="detection_list"){if(Ut){for(var Fi=Ut.getRectList(),$a=Ut.getLandmarksList(),No=Ut.getClassificationsList(),br=[],xs=0;xs<Fi.size();++xs){var qu=nk(Fi.get(xs)),aR=Vs(qu,1),Ex=Vs(qu,2),ok=Vs(qu,3),Xu=Vs(qu,4),m0=Vs(qu,5,0),g0=void 0;g0=g0===void 0?0:g0,qu={la:{sa:aR,ta:Ex,height:ok,width:Xu,rotation:m0,pa:Qi(Ns(qu,6),g0)},ea:f0($a.get(xs)),ba:rk(ek(No.get(xs)))},br.push(qu)}Fi=br}else Fi=[];W[Et]=Fi,Wr.h=7;break}if(hn.type==="proto_list"){if(Ut){for(Fi=Array(Ut.size()),$a=0;$a<Ut.size();$a++)Fi[$a]=Ut.get($a);Ut.delete()}else Fi=[];W[Et]=Fi,Wr.h=7;break}if(Ut===void 0){Wr.h=3;break}if(hn.type==="float_list"){W[Et]=Ut,Wr.h=7;break}if(hn.type==="proto"){W[Et]=Ut,Wr.h=7;break}if(hn.type!=="texture")throw Error("Unknown output config type: '"+hn.type+"'");return Rt=T.v[Et],Rt||(Rt=new d0(T.i,T.K),T.v[Et]=Rt),w(Wr,Mo(Rt,Ut,T.M),13);case 13:an=Wr.i,W[Et]=an;case 7:hn.transform&&W[Et]&&(W[Et]=hn.transform(W[Et])),Wr.h=3;break;case 14:Bn[Ur]=Wr.i;case 3:ie=ht.next(),Wr.h=2;break;case 4:return Wr.return(W)}})}function iR(T,$,L){var W;return N(function(ne){return typeof L=="number"||L instanceof Uint8Array||L instanceof T.i.Uint8BlobList?ne.return(L):L instanceof T.i.Texture2dDataOut?(W=T.v[$],W||(W=new d0(T.i,T.K),T.v[$]=W),ne.return(Mo(W,L,T.M))):ne.return(void 0)})}function oR(T,$){for(var L=$.name||"$",W=[].concat(l($.wants)),ne=new T.i.StringList,oe=a($.wants),ie=oe.next();!ie.done;ie=oe.next())ne.push_back(ie.value);oe=T.i.PacketListener.implement({onResults:function(Ce){for(var Pe={},ht=0;ht<$.wants.length;++ht)Pe[W[ht]]=Ce.get(ht);var Et=T.listeners[L];Et&&(T.I=sR(T,Pe,$.outs).then(function(hn){hn=Et(hn);for(var Ut=0;Ut<$.wants.length;++Ut){var Rt=Pe[W[Ut]];typeof Rt=="object"&&Rt.hasOwnProperty&&Rt.hasOwnProperty("delete")&&Rt.delete()}hn&&(T.I=hn)}))}}),T.j.attachMultiListener(ne,oe),ne.delete()}n.onResults=function(T,$){this.listeners[$||"$"]=T},z("Solution",Vr),z("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Tx(T){switch(T===void 0&&(T=0),T){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function qp(T){var $=this;T=T||{},this.h=new Vr({locateFile:T.locateFile,files:function(L){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Tx(L.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:f0},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:f0},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(L){var W,ne,oe;return N(function(ie){return ie.h==1?(W=Tx(L),ne="third_party/mediapipe/modules/pose_landmark/"+W,w(ie,rd($.h,W),2)):(oe=ie.i,$.h.overrideFile(ne,oe),ie.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=qp.prototype,n.reset=function(){this.h.reset()},n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(T){this.h.onResults(T)},n.initialize=function(){var T=this;return N(function($){return w($,T.h.initialize(),0)})},n.send=function(T,$){var L=this;return N(function(W){return w(W,L.h.send(T,$),0)})},n.setOptions=function(T){this.h.setOptions(T)},z("Pose",qp),z("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),z("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),z("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),z("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),z("VERSION","0.5.1675469404")}).call(pt);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var yoe=function(n,e){return(yoe=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(t[s]=r[s])})(n,e)};function boe(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}yoe(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var qr=function(){return(qr=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function or(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?s(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((r=r.apply(n,e||[])).next())})}function ar(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,r&&(s=2&u[0]?r.return:u[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,u[1])).done)return s;switch(r=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){o.label=u[1];break}if(u[0]===6&&o.label<s[1]){o.label=s[1],s=u;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(u);break}s[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],r=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function Um(n,e,t){if(t||arguments.length===2)for(var r,s=0,i=e.length;s<i;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return n.concat(r||Array.prototype.slice.call(e))}var Ch=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],sS=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],yft={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},bft={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},vft=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],wft=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function CA(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function voe(n){return or(this,void 0,void 0,function(){var e,t;return ar(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof jn?[4,iC(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=CA(n.width),e.height=CA(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function woe(n){return or(this,void 0,void 0,function(){var e,t,r,s,i,o;return ar(this,function(a){switch(a.label){case 0:return n instanceof jn?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,iC(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,t]))];case 2:return i=document.createElement("canvas"),o=i.getContext("2d"),i.width=CA(n.width),i.height=CA(n.height),o.drawImage(n,0,0),[2,o.getImageData(0,0,i.width,i.height)]}})})}function xft(n){return or(this,void 0,void 0,function(){var e,t;return ar(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,voe(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,oC(e,4)]}})})}function xoe(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(n));if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got ".concat(n))}var t1={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},_ft=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,woe(this.mask)]})})},n.prototype.toTensor=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,xft(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function Sft(n){return xoe(n),"person"}var Cft=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new gft.Pose({locateFile:function(s,i){if(e.solutionPath){var o=e.solutionPath.replace(/\/+$/,"");return"".concat(o,"/").concat(s)}return"".concat(i,"/").concat(s)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var i=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(i.segmentation={maskValueToLabel:Sft,mask:new _ft(s.segmentationMask)}),r.poses=[i]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(i,o){return{x:i.x*r.width,y:i.y*r.height,z:i.z,score:i.visibility,name:sS[o]}})};return t!=null&&(s.keypoints3D=t.map(function(i,o){return{x:i.x,y:i.y,z:i.z,score:i.visibility,name:sS[o]}})),s},n.prototype.estimatePoses=function(e,t,r){return or(this,void 0,void 0,function(){var s,i;return ar(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof jn?(i=ImageData.bind,[4,iC(e)]):[3,2];case 1:return s=new(i.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,o.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return o.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function kft(n){return or(this,void 0,void 0,function(){var e,t;return ar(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return qr({},t1);var i=qr({},s);return i.runtime="mediapipe",i.enableSegmentation==null&&(i.enableSegmentation=t1.enableSegmentation),i.enableSmoothing==null&&(i.enableSmoothing=t1.enableSmoothing),i.smoothSegmentation==null&&(i.smoothSegmentation=t1.smoothSegmentation),i.modelType==null&&(i.modelType=t1.modelType),i}(n),[4,(t=new Cft(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function uv(n){return n instanceof jn?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function _oe(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function K4(n){return n instanceof jn?n:oC(n)}function Soe(n,e,t){return yF(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function yF(n,e){U(n.width!==0,function(){return"".concat(e," width cannot be 0.")}),U(n.height!==0,function(){return"".concat(e," height cannot be 0.")})}function Z3(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,i=n.locationData,o=i.relativeKeypoints[r].x*e.width,a=i.relativeKeypoints[r].y*e.height,l=i.relativeKeypoints[s].x*e.width,c=i.relativeKeypoints[s].y*e.height,u=2*Math.sqrt((l-o)*(l-o)+(c-a)*(c-a)),h=function(f,d,p){var m,g=f.locationData,y=p.rotationVectorStartKeypointIndex,b=p.rotationVectorEndKeypointIndex;m=p.rotationVectorTargetAngle?p.rotationVectorTargetAngle:Math.PI*p.rotationVectorTargetAngleDegree/180;var x=g.relativeKeypoints[y].x*d.width,w=g.relativeKeypoints[y].y*d.height,S=g.relativeKeypoints[b].x*d.width,C=g.relativeKeypoints[b].y*d.height;return _oe(m-Math.atan2(-(C-w),S-x))}(n,e,t);return{xCenter:o/e.width,yCenter:a/e.height,width:u/e.width,height:u/e.height,rotation:h}}function Coe(n){if(n.length!==16)throw new Error("Array length must be 16 but got ".concat(n.length));return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function J3(n,e,t,r,s,i,o){return n[e][s]*(n[t][i]*n[r][o]-n[t][o]*n[r][i])}function Po(n,e,t){var r=(e+1)%4,s=(e+2)%4,i=(e+3)%4,o=(t+1)%4,a=(t+2)%4,l=(t+3)%4;return J3(n,r,s,i,o,a,l)+J3(n,s,i,r,o,a,l)+J3(n,i,r,s,o,a,l)}function Nj(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,i=n;s<i.length;s++){var o=i[s],a=o.x-.5,l=o.y-.5,c=t.ignoreRotation?0:e.rotation,u=Math.cos(c)*a-Math.sin(c)*l,h=Math.sin(c)*a+Math.cos(c)*l;u=u*e.width+e.xCenter,h=h*e.height+e.yCenter;var f=o.z*e.width,d=qr({},o);d.x=u,d.y=h,d.z=f,r.push(d)}return r}function koe(n,e){var t=function(r,s,i,o){var a=s-r,l=o-i;if(a===0)throw new Error("Original min and max are both ".concat(r,", range cannot be 0."));var c=l/a;return{scale:c,offset:i-r*c}}(0,255,e[0],e[1]);return Se(function(){return qe(fe(n,t.scale),t.offset)})}function bF(n,e,t){var r,s,i,o,a,l,c,u,h,f,d,p,m,g,y=e.outputTensorSize,b=e.keepAspectRatio,x=e.borderMode,w=e.outputTensorFloatRange,S=uv(n),C=function(M,E){return E?{xCenter:E.xCenter*M.width,yCenter:E.yCenter*M.height,width:E.width*M.width,height:E.height*M.height,rotation:E.rotation}:{xCenter:.5*M.width,yCenter:.5*M.height,width:M.width,height:M.height,rotation:0}}(S,t),k=function(M,E,N){if(N===void 0&&(N=!1),!N)return{top:0,left:0,right:0,bottom:0};var O=E.height,R=E.width;yF(E,"targetSize"),yF(M,"roi");var D,z,B=O/R,X=M.height/M.width,G=0,te=0;return B>X?(D=M.width,z=M.width*B,te=(1-X/B)/2):(D=M.height/B,z=M.height,G=(1-B/X)/2),M.width=D,M.height=z,{top:te,left:G,right:G,bottom:te}}(C,y,b),A=(r=C,s=S.width,i=S.height,o=!1,a=r.width,l=r.height,c=o?-1:1,u=Math.cos(r.rotation),h=Math.sin(r.rotation),f=r.xCenter,d=r.yCenter,p=1/s,m=1/i,(g=new Array(16))[0]=a*u*c*p,g[1]=-l*h*p,g[2]=0,g[3]=(-.5*a*u*c+.5*l*h+f)*p,g[4]=a*h*c*m,g[5]=l*u*m,g[6]=0,g[7]=(-.5*l*u-.5*a*h*c+d)*m,g[8]=0,g[9]=0,g[10]=a*p,g[11]=0,g[12]=0,g[13]=0,g[14]=0,g[15]=1,Coe(g));return{imageTensor:Se(function(){var M=K4(n),E=qa(Soe(A,S,y),[1,8]),N=x==="zero"?"constant":"nearest",O=Ci.transform(oi(wt(M,"float32")),E,"bilinear",N,0,[y.height,y.width]);return w!=null?koe(O,w):O}),padding:k,transformationMatrix:A}}function $j(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function Tft(n){return Se(function(){var e=function(s){return Se(function(){return[dn(s,[0,0,0],[1,-1,1]),dn(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:vr(r),logits:vr(t)}})}function Toe(n){return n!=null&&n.currentTime!=null}function Rj(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,i=Number.MIN_SAFE_INTEGER,o=0;o<n.length;++o){var a=n[o];t=Math.min(t,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),i=Math.max(i,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:i,width:r-t,height:i-s},e}function Eft(n,e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l;return ar(this,function(c){switch(c.label){case 0:return n.sort(function(u,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,u.score)}),s=qa(n.map(function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]})),i=Ks(n.map(function(u){return u.score[0]})),[4,Ci.nonMaxSuppressionAsync(s,i,e,t)];case 1:return[4,(o=c.sent()).array()];case 2:return a=c.sent(),l=n.filter(function(u,h){return a.indexOf(h)>-1}),nn([s,i,o]),[2,l]}})})}function Eoe(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function Ift(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S,C,k,A,M,E;return ar(this,function(N){switch(N.label){case 0:if(r=vr(e,[0]),s=r.shape,i=s[0],o=s[1],a=s[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(n.length,", heatmap length: ").concat(a));return l=[],[4,r.buffer()];case 1:for(c=N.sent(),u=0;u<n.length;u++)if(h=n[u],f=qr({},h),l.push(f),d=Math.trunc(f.x*o),p=Math.trunc(f.y*i),!(d<0||d>=o||p<0||d>=i)){for(m=Math.trunc((t.kernelSize-1)/2),g=Math.max(0,d-m),y=Math.min(o,d+m+1),b=Math.max(0,p-m),x=Math.min(i,p+m+1),w=0,S=0,C=0,k=0,A=b;A<x;++A)for(M=g;M<y;++M)E=c.get(A,M,u),w+=E,k=Math.max(k,E),S+=M*E,C+=A*E;k>=t.minConfidenceToRefine&&w>0&&(f.x=S/o/w,f.y=C/i/w)}return r.dispose(),[2,l]}})})}function Pj(n,e){var t=e.left,r=e.top,s=e.left+e.right,i=e.top+e.bottom;return n.map(function(o){return qr(qr({},o),{x:(o.x-t)/(1-s),y:(o.y-r)/(1-i),z:o.z/(1-s)})})}function Aft(n,e,t){return x_()==="webgl"?function(r,s,i){var o=i.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(o,`);

      setOutput(outputValue);
    }
`)},l=sg();return Se(function(){var c=l.compileAndRun(a,[r,s]);return xo().makeTensorFromDataId(c.dataId,c.shape,c.dtype)})}(n,e,t):Se(function(){var r=Dt(e,.5),s=Or(r),i=Dt(1,op(1,fe(s,qe(5.68842,fe(s,qe(-.748699,fe(s,qe(-57.8051,fe(s,qe(291.309,fe(s,-624.717)))))))))));return qe(e,fe(Dt(n,e),fe(i,t.combineWithPreviousRatio)))})}function Mft(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a;return ar(this,function(l){switch(l.label){case 0:return r=n[0],s=n[1],i=function(c,u,h){return Se(function(){var f,d,p,m;h.reverseOutputOrder?(d=vr(dn(c,[0,h.boxCoordOffset+0],[-1,1])),f=vr(dn(c,[0,h.boxCoordOffset+1],[-1,1])),m=vr(dn(c,[0,h.boxCoordOffset+2],[-1,1])),p=vr(dn(c,[0,h.boxCoordOffset+3],[-1,1]))):(f=vr(dn(c,[0,h.boxCoordOffset+0],[-1,1])),d=vr(dn(c,[0,h.boxCoordOffset+1],[-1,1])),p=vr(dn(c,[0,h.boxCoordOffset+2],[-1,1])),m=vr(dn(c,[0,h.boxCoordOffset+3],[-1,1]))),d=qe(fe(Lt(d,h.xScale),u.w),u.x),f=qe(fe(Lt(f,h.yScale),u.h),u.y),h.applyExponentialOnBoxSize?(p=fe(Yo(Lt(p,h.hScale)),u.h),m=fe(Yo(Lt(m,h.wScale)),u.w)):(p=fe(Lt(p,h.hScale),u.h),m=fe(Lt(m,h.wScale),u.h));var g=Dt(f,Lt(p,2)),y=Dt(d,Lt(m,2)),b=qe(f,Lt(p,2)),x=qe(d,Lt(m,2)),w=cs([ve(g,[h.numBoxes,1]),ve(y,[h.numBoxes,1]),ve(b,[h.numBoxes,1]),ve(x,[h.numBoxes,1])],1);if(h.numKeypoints)for(var S=0;S<h.numKeypoints;++S){var C=h.keypointCoordOffset+S*h.numValuesPerKeypoint,k=void 0,A=void 0;h.reverseOutputOrder?(k=vr(dn(c,[0,C],[-1,1])),A=vr(dn(c,[0,C+1],[-1,1]))):(A=vr(dn(c,[0,C],[-1,1])),k=vr(dn(c,[0,C+1],[-1,1])));var M=qe(fe(Lt(k,h.xScale),u.w),u.x),E=qe(fe(Lt(A,h.yScale),u.h),u.y);w=cs([w,ve(M,[h.numBoxes,1]),ve(E,[h.numBoxes,1])],1)}return w})}(s,e,t),o=Se(function(){var c=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(c=wa(r,-t.scoreClippingThresh,t.scoreClippingThresh)),c=kl(c)):c}),[4,Nft(i,o,t)];case 1:return a=l.sent(),nn([i,o]),[2,a]}})})}function Nft(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p;return ar(this,function(m){switch(m.label){case 0:return r=[],[4,n.data()];case 1:return s=m.sent(),[4,e.data()];case 2:for(i=m.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&i[o]<t.minScoreThresh||(a=o*t.numCoords,l=$ft(s[a+0],s[a+1],s[a+2],s[a+3],i[o],t.flipVertically,o),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(t.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,f=0;f<h;f+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+f,p={x:s[d+0],y:t.flipVertically?1-s[d+1]:s[d+1]},u.relativeKeypoints.push(p);r.push(l)}return[2,r]}})})}function $ft(n,e,t,r,s,i,o){return{score:[s],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-t:n,xMax:r,yMax:i?1-n:t,width:r-e,height:t-n}}}}function Rft(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Dj(n,e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h;return ar(this,function(f){switch(f.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,i=s/e.numLandmarks,[4,n.data()];case 1:for(o=f.sent(),a=[],l=0;l<e.numLandmarks;++l)c=l*i,(h={x:0,y:0}).x=t?e.inputImageWidth-o[c]:o[c],i>1&&(h.y=r?e.inputImageHeight-o[c+1]:o[c+1]),i>2&&(h.z=o[c+2]),i>3&&(h.score=Rft(e.visibilityActivation,o[c+3])),a.push(h);for(u=0;u<a.length;++u)(h=a[u]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Oj(n,e,t){var r=n.width,s=n.height,i=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(i=function(u,h){return h.rotation!=null?u+=h.rotation:h.rotationDegree!=null&&(u+=Math.PI*h.rotationDegree/180),_oe(u)}(i,t)),i===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var o=(e.width*r*t.shiftX*Math.cos(i)-e.height*s*t.shiftY*Math.sin(i))/e.width,a=(e.width*r*t.shiftX*Math.sin(i)+e.height*s*t.shiftY*Math.cos(i))/e.height;n.xCenter=n.xCenter+o,n.yCenter=n.yCenter+a}if(t.squareLong){var l=Math.max(r*e.width,s*e.height);r=l/e.width,s=l/e.height}else if(t.squareShort){var c=Math.min(r*e.width,s*e.height);r=c/e.width,s=c/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function Pft(n,e){return n.map(function(t){var r=qr(qr({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var Ld=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),Q3=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Ld(this.getAlpha(this.minCutOff)),this.dx=new Ld(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,o=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(o),l=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(a),l)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),vF=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Um([],e,!0);i=1/r}return e.map(function(o,a){var l=qr(qr({},o),{x:s.xFilters[a].apply(o.x,t,i),y:s.yFilters[a].apply(o.y,t,i)});return o.z!=null&&(l.z=s.zFilters[a].apply(o.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new Q3(t.config)}),this.yFilters=e.map(function(r){return new Q3(t.config)}),this.zFilters=e.map(function(r){return new Q3(t.config)}))},n}(),eP=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new Ld(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(this.lastTimestamp===-1)s=1;else{for(var o=e*r-this.lastValue*this.lastValueScale,a=i-this.lastTimestamp,l=o,c=a,u=(1+this.window.length)*(1e6/30),h=0,f=this.window;h<f.length;h++){var d=f[h];if(c+d.duration>u)break;l+=d.distance,c+=d.duration}var p=l/(1e-6*c);s=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:o,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,s)},n}(),Dft=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Um([],e,!0);i=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(o,a){var l=qr(qr({},o),{x:s.xFilters[a].apply(o.x,t,i),y:s.yFilters[a].apply(o.y,t,i)});return o.z!=null&&(l.z=s.zFilters[a].apply(o.z,t,i)),l})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new eP(t.config)}),this.yFilters=e.map(function(r){return new eP(t.config)}),this.zFilters=e.map(function(r){return new eP(t.config)}))},n}(),tP=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new Dft(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new vF(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,i){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var o=i!=null?function(c,u){return(c.width*u.width+c.height*u.height)/2}(i,r):1,a=s?Eoe(e,r):e,l=this.keypointsFilter.apply(a,t,o);return s?Pft(l,r):l},n}(),Fj=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Ld(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var i=e[s],o=qr({},i);o.score=this.visibilityFilters[s].apply(i.score),r.push(o)}return r},n}(),Oft={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},V0={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},Fft={maxPoses:1,flipHorizontal:!1},Lft={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},zft=.3,Lj={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Bft={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Vft={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Uft={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Wft={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Gft={kernelSize:7,minConfidenceToRefine:.5},zj={alpha:.1},Hft={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},jft={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},qft={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Xft={activation:"none"},Kft={combineWithPreviousRatio:.7},Yft=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,voe(this.mask)]})})},n.prototype.toImageData=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,woe(this.mask)]})})},n.prototype.toTensor=function(){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function Zft(n){return xoe(n),"person"}var Jft=function(){function n(e,t,r,s,i,o){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=i,this.modelType=o,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var f=[],d=0;d<h.numLayers;){for(var p=[],m=[],g=[],y=[],b=d;b<h.strides.length&&h.strides[b]===h.strides[d];){var x=$j(h.minScale,h.maxScale,b,h.strides.length);if(b===0&&h.reduceBoxesInLowestLayer)g.push(1),g.push(2),g.push(.5),y.push(.1),y.push(x),y.push(x);else{for(var w=0;w<h.aspectRatios.length;++w)g.push(h.aspectRatios[w]),y.push(x);if(h.interpolatedScaleAspectRatio>0){var S=b===h.strides.length-1?1:$j(h.minScale,h.maxScale,b+1,h.strides.length);y.push(Math.sqrt(x*S)),g.push(h.interpolatedScaleAspectRatio)}}b++}for(var C=0;C<g.length;++C){var k=Math.sqrt(g[C]);p.push(y[C]/k),m.push(y[C]*k)}var A=0,M=0;if(h.featureMapHeight.length>0)A=h.featureMapHeight[d],M=h.featureMapWidth[d];else{var E=h.strides[d];A=Math.ceil(h.inputSizeHeight/E),M=Math.ceil(h.inputSizeWidth/E)}for(var N=0;N<A;++N)for(var O=0;O<M;++O)for(var R=0;R<p.length;++R){var D={xCenter:(O+h.anchorOffsetX)/M,yCenter:(N+h.anchorOffsetY)/A,width:0,height:0};h.fixedAnchorSize?(D.width=1,D.height=1):(D.width=m[R],D.height=p[R]),f.push(D)}d=b}return f}(Oft);var a=Ks(this.anchors.map(function(h){return h.width})),l=Ks(this.anchors.map(function(h){return h.height})),c=Ks(this.anchors.map(function(h){return h.xCenter})),u=Ks(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:c,y:u,w:a,h:l},this.prevFilteredSegmentationMask=this.enableSegmentation?qa([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S,C,k,A,M,E;return ar(this,function(N){switch(N.label){case 0:return s=function(O){var R;if((R=O==null?Fft:qr({},O)).maxPoses==null&&(R.maxPoses=1),R.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(R.maxPoses,". Should be > 0."));if(R.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return R}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:Toe(e)?1e6*e.currentTime:null,i=uv(e),o=Se(function(){return wt(K4(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(o)]);case 1:if((l=N.sent()).length===0)return this.reset(),o.dispose(),[2,[]];c=l[0],a=this.poseDetectionToRoi(c,i),N.label=2;case 2:return[4,this.poseLandmarksByRoi(a,o)];case 3:return u=N.sent(),o.dispose(),u==null?(this.reset(),[2,[]]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,g=this.poseLandmarkFiltering(h,f,p,i),y=g.actualLandmarksFiltered,b=g.auxiliaryLandmarksFiltered,x=g.actualWorldLandmarksFiltered,w=this.poseLandmarksToRoi(b,i),this.regionOfInterest=w,S=this.smoothSegmentation&&m!=null?this.poseSegmentationFiltering(m):m,(C=y!=null?Eoe(y,i):null)!=null&&C.forEach(function(O,R){O.name=sS[R]}),(k=x)!=null&&k.forEach(function(O,R){O.name=sS[R]}),A={score:d,keypoints:C,keypoints3D:k},S!==null&&(M=Se(function(){var O=oi(S,2),R=vu(O,[[0,0],[0,0],[0,1]]);return uz(R,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||nn(S),E={maskValueToLabel:Zft,mask:new Yft(M)},A.segmentation=E),[2,[A]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=Aft(t,e,Kft),nn(e)),nn(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),nn([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(nn(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=qa([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c,u,h;return ar(this,function(f){switch(f.label){case 0:return t=bF(e,Bft),r=t.imageTensor,s=t.padding,i=this.detectorModel.predict(r),o=Tft(i),a=o.boxes,[4,Mft([l=o.logits,a],this.anchorTensor,Lft)];case 1:return(c=f.sent()).length===0?(nn([r,i,l,a]),[2,c]):[4,Eft(c,this.maxPoses,zft)];case 2:return u=f.sent(),h=function(d,p){d===void 0&&(d=[]);for(var m=p.left,g=p.top,y=p.left+p.right,b=p.top+p.bottom,x=0;x<d.length;x++){var w=d[x],S=w.locationData.relativeBoundingBox,C=(S.xMin-m)/(1-y),k=(S.yMin-g)/(1-b),A=S.width/(1-y),M=S.height/(1-b);S.xMin=C,S.yMin=k,S.width=A,S.height=M,S.xMax=C+A,S.yMax=k+M;var E=w.locationData.relativeKeypoints;E&&E.forEach(function(N){var O=(N.x-m)/(1-y),R=(N.y-g)/(1-b);N.x=O,N.y=R})}return d}(u,s),nn([r,i,l,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return Oj(Z3(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,Lj)},n.prototype.poseLandmarksByRoi=function(e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f,d,p,m,g;return ar(this,function(y){switch(y.label){case 0:if(r=uv(t),s=bF(t,Vft,e),i=s.imageTensor,o=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return l=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&l.push("activation_segmentation"),c=this.landmarkModel.execute(i,l),[4,this.tensorsToPoseLandmarksAndSegmentation(c)];case 1:return(u=y.sent())==null?(nn(c),nn(i),[2,null]):(h=u.landmarks,f=u.auxiliaryLandmarks,d=u.poseScore,p=u.worldLandmarks,m=u.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,o,a,h,f,p,m)]);case 2:return g=y.sent(),nn(c),nn(i),[2,qr({poseScore:d},g)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,i,o,a,l){return or(this,void 0,void 0,function(){var c,u,h,f,d,p;return ar(this,function(m){return c=Pj(i,r),u=Pj(o,r),h=Nj(c,t),f=Nj(u,t),d=function(g,y){for(var b=[],x=0,w=g;x<w.length;x++){var S=w[x],C=S.x,k=S.y,A=y.rotation,M=Math.cos(A)*C-Math.sin(A)*k,E=Math.sin(A)*C+Math.cos(A)*k,N=qr({},S);N.x=M,N.y=E,b.push(N)}return b}(a,t),p=null,this.enableSegmentation&&(p=Se(function(){var g=l.shape,y=g[0],b=g[1],x=function(C){var k=Coe(new Array(16).fill(0));k[0][0]=Po(C,0,0),k[1][0]=-Po(C,0,1),k[2][0]=Po(C,0,2),k[3][0]=-Po(C,0,3),k[0][2]=Po(C,2,0),k[1][2]=-Po(C,2,1),k[2][2]=Po(C,2,2),k[3][2]=-Po(C,2,3),k[0][1]=-Po(C,1,0),k[1][1]=Po(C,1,1),k[2][1]=-Po(C,1,2),k[3][1]=Po(C,1,3),k[0][3]=-Po(C,3,0),k[1][3]=Po(C,3,1),k[2][3]=-Po(C,3,2),k[3][3]=Po(C,3,3);for(var A=C[0][0]*k[0][0]+C[1][0]*k[0][1]+C[2][0]*k[0][2]+C[3][0]*k[0][3],M=0;M<k.length;M++)for(var E=0;E<k.length;E++)k[M][E]/=A;return k}(s),w=qa(Soe(x,{width:b,height:y},e),[1,8]),S=[1,y,b,1];return vr(Ci.transform(ve(l,S),w,"bilinear","constant",0,[e.height,e.width]),[0,3])}),nn(l)),[2,{landmarks:h,auxiliaryLandmarks:f,worldLandmarks:d,segmentationMask:p}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c,u,h,f,d,p;return ar(this,function(m){switch(m.label){case 0:return t=e[0],r=e[1],s=e[2],i=e[3],o=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,Dj(t,Uft)];case 2:return[4,Ift(m.sent(),s,Gft)];case 3:return l=m.sent(),c=l.slice(0,33),u=l.slice(33,35),[4,Dj(i,Wft)];case 4:return h=m.sent(),f=h.slice(0,33),d=function(g,y,b){b===void 0&&(b=!0);for(var x=[],w=0;w<g.length;w++){var S=qr({},y[w]);b&&(S.score=g[w].score),x.push(S)}return x}(c,f,!0),p=this.enableSegmentation?function(g,y,b){return Se(function(){var x=vr(g,[0]),w=x.shape[2];if(w===1){var S=x;switch(y.activation){case"none":break;case"sigmoid":S=kl(S);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(y.activation,")"))}var C=b?Ci.resizeBilinear(S,[b.height,b.width]):S;return vr(C,[2])}throw new Error("Unsupported number of tensor channels ".concat(w))})}(o,Xft):null,[2,{landmarks:c,auxiliaryLandmarks:u,poseScore:a,worldLandmarks:d,segmentationMask:p}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return Oj(Z3(Rj(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,Lj)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var i,o,a;if(this.timestamp!=null&&this.enableSmoothing){var l=Z3(Rj(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new Fj(zj)),i=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new Fj(zj)),o=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new tP(Hft)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,s,!0,l),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new tP(jft)),o=this.landmarksSmoothingFilterAuxiliary.apply(o,this.timestamp,s,!0,l),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new tP(qft)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else i=e,o=t,a=r;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:o,actualWorldLandmarksFiltered:a}},n}();function Qft(n){return or(this,void 0,void 0,function(){var e,t,r,s,i,o;return ar(this,function(a){switch(a.label){case 0:return e=function(l){var c=qr({},l??V0);if(c.enableSmoothing==null&&(c.enableSmoothing=V0.enableSmoothing),c.enableSegmentation==null&&(c.enableSegmentation=V0.enableSegmentation),c.smoothSegmentation==null&&(c.smoothSegmentation=V0.smoothSegmentation),c.modelType==null&&(c.modelType=V0.modelType),c.detectorModelUrl==null&&(c.detectorModelUrl=V0.detectorModelUrl),c.landmarkModelUrl==null)switch(c.modelType){case"lite":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:c.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return c}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Nl(e.detectorModelUrl,{fromTFHub:t}),Nl(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),i=s[0],o=s[1],[2,new Jft(i,o,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Zm,io,Ioe=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var i=s[r];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),i=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(s.length!==0){for(var c=-1,u=-1,h=0,f=s;h<f.length;h++){var d=f[h],p=t[l][d];p>=this.minSimilarity&&p>u&&(c=d,u=p)}if(c>=0){var m=this.tracks[c];m=Object.assign(m,this.createTrack(e[l],r,m.id)),e[l].id=m.id;var g=s.indexOf(c);s.splice(g,1)}else i.push(l)}else i.push(l)}for(var y=0,b=i;y<b.length;y++){l=b[y];var x=this.createTrack(e[l],r);this.tracks.push(x),e[l].id=x.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:Um([],e.keypoints,!0).map(function(i){return qr({},i)})};return e.box!==void 0&&(s.box=qr({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),edt=function(n){function e(t){return n.call(this,t)||this}return boe(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(i){return r.iou(s,i)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),i=Math.max(t.box.yMin,r.box.yMin),o=Math.min(t.box.xMax,r.box.xMax),a=Math.min(t.box.yMax,r.box.yMax);if(s>=o||i>=a)return 0;var l=(o-s)*(a-i);return l/(t.box.width*t.box.height+r.box.width*r.box.height-l)},e}(Ioe),tdt=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return boe(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,i=t;s<i.length;s++){for(var o=i[s],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}r.push(a)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,i=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=r.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),h=2*this.keypointFalloff[a];i+=Math.exp(-1*u/(2*s*Math.pow(h,2)))}}return o<this.minNumKeyoints?0:i/o},e.prototype.area=function(t){var r=this,s=t.filter(function(l){return l.score>r.keypointThreshold}),i=Math.min.apply(Math,Um([1],s.map(function(l){return l.x}),!1)),o=Math.max.apply(Math,Um([0],s.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,Um([1],s.map(function(l){return l.y}),!1));return(o-i)*(Math.max.apply(Math,Um([0],s.map(function(l){return l.y}),!1))-a)},e}(Ioe);function Aoe(n){switch(n){case io.BlazePose:return sS.reduce(function(e,t,r){return e[t]=r,e},{});case io.PoseNet:case io.MoveNet:return Ch.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model ".concat(n," is not supported."))}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Zm||(Zm={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(io||(io={}));var Bj=Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case io.BlazePose:return yft;case io.PoseNet:case io.MoveNet:return bft;default:throw new Error("Model ".concat(n," is not supported."))}},getAdjacentPairs:function(n){switch(n){case io.BlazePose:return wft;case io.PoseNet:case io.MoveNet:return vft;default:throw new Error("Model ".concat(n," is not supported."))}},getKeypointIndexByName:Aoe}),Vj=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],Moe={modelType:"SinglePose.Lightning",enableSmoothing:!0},Uj={},Wj={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},nP={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Gj={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function ndt(n,e,t,r){for(var s={},i=0,o=Ch;i<o.length;i++){var a=o[i];s[a]=[e[t[a]].y*r.height,e[t[a]].x*r.width]}if(function(b,x){return(b[x.left_hip].score>.2||b[x.right_hip].score>.2)&&(b[x.left_shoulder].score>.2||b[x.right_shoulder].score>.2)}(e,t)){var l=(s.left_hip[0]+s.right_hip[0])/2,c=(s.left_hip[1]+s.right_hip[1])/2,u=function(b,x,w,S,C){for(var k=["left_shoulder","right_shoulder","left_hip","right_hip"],A=0,M=0,E=0;E<k.length;E++)(z=Math.abs(S-w[k[E]][0]))>A&&(A=z),(B=Math.abs(C-w[k[E]][1]))>M&&(M=B);for(var N=0,O=0,R=0,D=Object.keys(w);R<D.length;R++){var z,B,X=D[R];b[x[X]].score<.2||((z=Math.abs(S-w[X][0]))>N&&(N=z),(B=Math.abs(C-w[X][1]))>O&&(O=B))}return[A,M,N,O]}(e,t,s,l,c),h=u[0],f=u[1],d=u[2],p=u[3],m=Math.max(1.9*f,1.9*h,1.2*d,1.2*p),g=[l-(m=Math.min(m,Math.max(c,r.width-c,l,r.height-l))),c-m];if(m>Math.max(r.width,r.height)/2)return wF(n==null,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return wF(n==null,r)}function wF(n,e){var t,r,s,i;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,i=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,i=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,i=0):(t=1,r=e.height/e.width,s=0,i=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:i,yMax:s+t,xMax:i+r,height:t,width:r}}function rdt(n){var e,t=n==null?Moe:qr({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(Vj.indexOf(t.modelType)<0)throw new Error("Invalid architecture ".concat(t.modelType,". ")+"Should be one of ".concat(Vj));if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Zm.BoundingBox),t.trackerType===Zm.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=Hj(nP,r);return s.keypointTrackerParams=qr({},nP.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=nP;else{if(t.trackerType!==Zm.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Hj(Gj,e)):t.trackerConfig=Gj}return t}function Hj(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var sdt=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Aoe(io.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new vF(Wj),this.cropRegionFilterYMin=new Ld(.9),this.cropRegionFilterXMin=new Ld(.9),this.cropRegionFilterYMax=new Ld(.9),this.cropRegionFilterXMax=new Ld(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Zm.Keypoint?this.tracker=new tdt(t.trackerConfig):t.trackerType===Zm.BoundingBox&&(this.tracker=new edt(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o;return ar(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return x_()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=a.sent(),a.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},i=0,o=0;o<17;++o)s.keypoints[o]={y:r[3*o],x:r[3*o+1],score:r[3*o+2]},s.keypoints[o].score>.2&&(++i,s.score+=s.keypoints[o].score);return i>0&&(s.score/=i),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return or(this,void 0,void 0,function(){var t,r,s,i,o,a,l,c;return ar(this,function(u){switch(u.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return x_()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=u.sent(),u.label=3;case 3:for(t.dispose(),s=[],i=r.length/56,o=0;o<i;++o)for(s[o]={keypoints:[]},a=56*o+51,s[o].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},l=56*o+55,s[o].score=r[l],s[o].keypoints=[],c=0;c<17;++c)s[o].keypoints[c]={y:r[56*o+3*c],x:r[56*o+3*c+1],score:r[56*o+3*c+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=Uj),or(this,void 0,void 0,function(){var s,i,o,a,l,c;return ar(this,function(u){switch(u.label){case 0:return t=function(h){return h==null?Uj:qr({},h)}(t),e==null?(this.reset(),[2,[]]):(r==null?Toe(e)&&(r=1e6*e.currentTime):r*=1e3,s=K4(e),i=uv(s),o=oi(s,0),e instanceof jn||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(o,i,r)]);case 1:return a=u.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(o,i,r)];case 3:a=u.sent(),u.label=4;case 4:for(l=0;l<a.length;++l)for(c=0;c<a[l].keypoints.length;++c)a[l].keypoints[c].name=Ch[c],a[l].keypoints[c].y*=i.height,a[l].keypoints[c].x*=i.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l=this;return ar(this,function(c){switch(c.label){case 0:return this.cropRegion||(this.cropRegion=wF(this.cropRegion==null,t)),s=Se(function(){var u=qa([[l.cropRegion.yMin,l.cropRegion.xMin,l.cropRegion.yMax,l.cropRegion.xMax]]),h=ms([1],"int32"),f=[l.modelInputResolution.height,l.modelInputResolution.width];return wt(Ci.cropAndResize(e,u,h,f,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(i=c.sent(),s.dispose(),i.score<this.minPoseScore)return this.reset(),[2,[]];for(o=0;o<i.keypoints.length;++o)i.keypoints[o].y=this.cropRegion.yMin+i.keypoints[o].y*this.cropRegion.height,i.keypoints[o].x=this.cropRegion.xMin+i.keypoints[o].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(i.keypoints=this.keypointFilter.apply(i.keypoints,r,1)),a=ndt(this.cropRegion,i.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[i]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m=this;return ar(this,function(g){switch(g.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,o=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=Ci.resizeBilinear(e,[o,i]),l=i,c=32*Math.ceil(o/32),a=vu(s,[[0,0],[0,c-o],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),o=this.multiPoseMaxDimension,s=Ci.resizeBilinear(e,[o,i]),l=32*Math.ceil(i/32),c=o,a=vu(s,[[0,0],[0,0],[0,l-i],[0,0]])),s.dispose(),e.dispose(),u=wt(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(u)];case 1:for(h=g.sent(),u.dispose(),h=h.filter(function(y){return y.score>=m.minPoseScore}),d=0;d<h.length;++d)for(f=0;f<h[d].keypoints.length;++f)h[d].keypoints[f].y*=c/o,h[d].keypoints[f].x*=l/i;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new vF(Wj)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,r,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(y,b){p.has(b)||m.keypointFilterMap.delete(b)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:i,height:s-t,width:i-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function idt(n){return n===void 0&&(n=Moe),or(this,void 0,void 0,function(){var e,t,r,s;return ar(this,function(i){switch(i.label){case 0:return e=rdt(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Nl(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=i.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Nl(s,{fromTFHub:r})];case 3:t=i.sent(),i.label=4;case 4:return x_()==="webgl"&&Ee().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new sdt(t,e)]}})})}var jj={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},qj=["MobileNetV1","ResNet50"],Xj={MobileNetV1:[8,16],ResNet50:[16]},odt=[8,16,32],Kj={MobileNetV1:[.5,.75,1],ResNet50:[1]},Yj=[1,2,4],Zj={maxPoses:1,flipHorizontal:!1},adt={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},ldt=[-123.15,-115.9,-103.06];function rP(n){return Math.floor(n/2)}var cdt=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(rP(e),e);)this.exchange(e,rP(e)),e=rP(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function udt(n,e,t,r,s,i){for(var o=i.shape,a=o[0],l=o[1],c=!0,u=Math.max(t-s,0),h=Math.min(t+s+1,a),f=u;f<h;++f){for(var d=Math.max(r-s,0),p=Math.min(r+s+1,l),m=d;m<p;++m)if(i.get(f,m,n)>e){c=!1;break}if(!c)break}return c}function hdt(n){return or(this,void 0,void 0,function(){return ar(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function Noe(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function $oe(n,e,t){var r=Noe(n.heatmapY,n.heatmapX,n.id,t),s=r.y,i=r.x;return{x:n.heatmapX*e+i,y:n.heatmapY*e+s}}function Roe(n,e,t,r){var s=t.x,i=t.y;return n.some(function(o){var a,l,c,u,h,f,d=o.keypoints;return a=i,l=s,c=d[r].y,u=d[r].x,(h=c-a)*h+(f=u-l)*f<=e})}var Jj=Ch.reduce(function(n,e,t){return n[e]=t,n},{}),Poe=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[Jj[e],Jj[t]]}),sP=Poe.map(function(n){return n[1]}),Qj=Poe.map(function(n){return n[0]});function e8(n,e,t){return n<e?e:n>t?t:n}function iP(n,e,t,r){return{y:e8(Math.round(n.y/e),0,t-1),x:e8(Math.round(n.x/e),0,r-1)}}function t8(n,e){return{x:n.x+e.x,y:n.y+e.y}}function n8(n,e,t,r,s,i,o,a){a===void 0&&(a=2);for(var l=r.shape,c=l[0],u=l[1],h={y:e.y,x:e.x},f=t8(h,function(b,x,w){var S=w.shape[2]/2;return{y:w.get(x.y,x.x,b),x:w.get(x.y,x.x,S+b)}}(n,iP(h,i,c,u),o)),d=0;d<a;d++){var p=iP(f,i,c,u),m=Noe(p.y,p.x,t,s);f=t8({x:p.x*i,y:p.y*i},{x:m.x,y:m.y})}var g=iP(f,i,c,u),y=r.get(g.y,g.x,t);return{y:f.y,x:f.x,name:Ch[t],score:y}}function fdt(n,e,t,r,s,i){var o=e.shape[2],a=sP.length,l=new Array(o),c=n.part,u=n.score,h=$oe(c,r,t);l[c.id]={score:u,name:Ch[c.id],y:h.y,x:h.x};for(var f=a-1;f>=0;--f){var d=sP[f],p=Qj[f];l[d]&&!l[p]&&(l[p]=n8(f,l[d],p,e,t,r,i))}for(f=0;f<a;++f)d=Qj[f],p=sP[f],l[d]&&!l[p]&&(l[p]=n8(f,l[d],p,e,t,r,s));return l}function ddt(n,e,t){return t.reduce(function(r,s,i){var o=s.y,a=s.x,l=s.score;return Roe(n,e,{y:o,x:a},i)||(r+=l),r},0)/t.length}function pdt(n,e,t,r,s,i,o,a){return o===void 0&&(o=.5),a===void 0&&(a=20),or(this,void 0,void 0,function(){var l,c,u,h,f,d,p,m,g,y,b,x;return ar(this,function(w){switch(w.label){case 0:return[4,hdt([n,e,t,r])];case 1:for(l=w.sent(),c=l[0],u=l[1],h=l[2],f=l[3],d=[],p=function(S,C,k){for(var A=k.shape,M=A[0],E=A[1],N=A[2],O=new cdt(M*E*N,function(X){return X.score}),R=0;R<M;++R)for(var D=0;D<E;++D)for(var z=0;z<N;++z){var B=k.get(R,D,z);B<S||udt(z,B,R,D,C,k)&&O.enqueue({score:B,part:{heatmapY:R,heatmapX:D,id:z}})}return O}(o,1,c),m=a*a;d.length<i&&!p.empty();)g=p.dequeue(),y=$oe(g.part,s,u),Roe(d,m,y,g.part.id)||(b=fdt(g,c,u,s,h,f),x=ddt(d,m,b),d.push({keypoints:b,score:x}));return[2,d]}})})}function Doe(){for(var n,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];switch(e.length){case 0:n="fn main() ";break;case 1:n="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return n}var mdt=function(){function n(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Ot(this.outputShape),this.dispatch=_t(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return n.prototype.getUserCode=function(){return`
        `.concat(Doe("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},n}();function gdt(n,e){if(sg()instanceof Bw)return function(t,r){var s=sg(),i=new mdt(r.shape),o=s.runWebGPUProgram(i,[t,r],"float32");return xo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var ydt=function(){function n(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Ot(t),this.dispatch=_t(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return n.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(Doe("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},n}();function bdt(n,e){if(sg()instanceof Bw)return function(t,r){var s=sg(),i=new ydt(t.shape),o=s.runWebGPUProgram(i,[t,r],"float32");return xo().makeTensorFromTensorInfo(o)}(n,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function Ooe(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return Se(function(){var i,o,a=ve(n,[t*r,s]),l=ig(a,0),c=oi(Lt(l,en(r,"int32")),1),u=oi((i=l,o=r,Se(function(){var h=Lt(i,en(o,"int32"));return Dt(i,fe(h,en(o,"int32")))})),1);return cs([c,u],1)})}function vdt(n,e,t){return Se(function(){var r=function(s,i){for(var o=[],a=0;a<Ch.length;a++){var l=s.get(a,0).valueOf(),c=s.get(a,1).valueOf(),u=wdt(l,c,a,i),h=u.x,f=u.y;o.push(f),o.push(h)}return qa(o,[Ch.length,2])}(n,t);return qe(wt(fe(n.toTensor(),en(e,"int32")),"float32"),r)})}function wdt(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+Ch.length)}}function xdt(n,e,t){return or(this,void 0,void 0,function(){var r,s,i,o,a,l,c,u,h,f;return ar(this,function(d){switch(d.label){case 0:return r=0,s=Ooe(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return i=d.sent(),o=i[0],a=i[1],l=i[2],[4,(c=vdt(l,t,a)).buffer()];case 2:return u=d.sent(),h=Array.from(function(p,m){for(var g=m.shape[0],y=new Float32Array(g),b=0;b<g;b++){var x=m.get(b,0),w=m.get(b,1);y[b]=p.get(x,w,b)}return y}(o,l)),f=h.map(function(p,m){return r+=p,{y:u.get(m,0),x:u.get(m,1),score:p,name:Ch[m]}}),s.dispose(),c.dispose(),[2,{keypoints:f,score:r/f.length}]}})})}function _dt(n,e,t){return or(this,void 0,void 0,function(){var r,s,i;return ar(this,function(o){return r=Ooe(n),s=function(a,l,c){return Se(function(){var u=bdt(a,c);return qe(wt(fe(a,en(l,"int32")),"float32"),u)})}(r,t,e),i=gdt(n,r),[2,[s,i]]})})}function r8(n,e){return(n-1)%e==0}var s8="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",i8="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function o8(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var a8=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;U(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"});var s,i,o=(s=t.inputResolution,i=t.outputStride,{height:o8(s.height,i),width:o8(s.width,i)});(function(a){U(odt.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(t.outputStride),function(a,l){U(r8(a.height,l),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(l,".")}),U(r8(a.width,l),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(l,".")})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=Zj),or(this,void 0,void 0,function(){return ar(this,function(r){return[2,this.estimatePosesGPU(e,t,!1)]})})},n.prototype.estimatePosesGPU=function(e,t,r){return t===void 0&&(t=Zj),r===void 0&&(r=!1),or(this,void 0,void 0,function(){var s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S;return ar(this,function(C){switch(C.label){case 0:return s=function(k){var A=k;if(A.maxPoses==null&&(A.maxPoses=1),A.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(A.maxPoses,". Should be > 0."));if(A.maxPoses>1){if((A=qr(qr({},adt),A)).scoreThreshold<0||A.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(A.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(A.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(A.nmsRadius,"."))}return A}(t),e==null?[2,r?[[],[]]:[]]:(this.maxPoses=s.maxPoses,i=bF(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=i.imageTensor,a=i.padding,l=this.architecture==="ResNet50"?qe(o,ldt):koe(o,[-1,1]),c=this.posenetModel.predict(l),this.architecture==="ResNet50"?(u=vr(c[2],[0]),h=vr(c[3],[0]),f=vr(c[0],[0]),d=vr(c[1],[0])):(u=vr(c[0],[0]),h=vr(c[1],[0]),f=vr(c[2],[0]),d=vr(c[3],[0])),p=kl(h),this.maxPoses!==1?[3,5]:r?[4,_dt(p,u,this.outputStride)]:[3,2]);case 1:return g=C.sent(),b=g[0],y=g[1],m=[b,y],[3,4];case 2:return[4,xdt(p,u,this.outputStride)];case 3:b=C.sent(),m=[b],C.label=4;case 4:return[3,7];case 5:if(r)throw new Error("GPU renderer only supports single pose!");return[4,pdt(p,u,f,d,this.outputStride,this.maxPoses,s.scoreThreshold,s.nmsRadius)];case 6:m=C.sent(),C.label=7;case 7:if(r){if(s.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");x=this.getCanvasInfo(uv(e),this.inputResolution,a)}else S=uv(e),w=function(k,A,M,E){var N=A.height,O=A.width,R=N/(M.height*(1-E.top-E.bottom)),D=O/(M.width*(1-E.left-E.right)),z=-E.top*M.height,B=-E.left*M.width;if(D===1&&R===1&&z===0&&B===0)return k;for(var X=0,G=k;X<G.length;X++)for(var te=0,ge=G[X].keypoints;te<ge.length;te++){var ae=ge[te];ae.x=(ae.x+B)*D,ae.y=(ae.y+z)*R}return k}(m,S,this.inputResolution,a),s.flipHorizontal&&(w=function(k,A){for(var M=0,E=k;M<E.length;M++)for(var N=0,O=E[M].keypoints;N<O.length;N++){var R=O[N];R.x=A.width-1-R.x}return k}(w,S));return o.dispose(),l.dispose(),nn(c),u.dispose(),h.dispose(),f.dispose(),d.dispose(),p.dispose(),[2,r?[m,x]:w]}})})},n.prototype.getCanvasInfo=function(e,t,r){var s=e.height,i=e.width,o=s/(t.height*(1-r.top-r.bottom)),a=i/(t.width*(1-r.left-r.right)),l=-r.top*t.height;return[-r.left*t.width,l,a,o,e.width,e.height]},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function Sdt(n){return n===void 0&&(n=jj),or(this,void 0,void 0,function(){var e,t,r,s,i;return ar(this,function(o){switch(o.label){case 0:return(e=function(u){var h=u||jj;if(h.architecture==null&&(h.architecture="MobileNetV1"),qj.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(qj));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),Xj[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(Xj[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),Kj[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(Kj[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),Yj.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(Yj," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,l=e.quantBytes,c="model-stride".concat(a,".json"),t=l===4?i8+"float/"+c:i8+"quant".concat(l,"/")+c,[4,Nl(e.modelUrl||t)]);case 1:return r=o.sent(),[2,new a8(r,e)];case 2:return s=function(u,h,f){var d={1:"100",.75:"075",.5:"050"},p="model-stride".concat(u,".json");return f===4?s8+"float/".concat(d[h],"/")+p:s8+"quant".concat(f,"/").concat(d[h],"/")+p}(e.outputStride,e.multiplier,e.quantBytes),[4,Nl(e.modelUrl||s)];case 3:return i=o.sent(),[2,new a8(i,e)]}var a,l,c})})}function Cdt(n,e){return or(this,void 0,void 0,function(){var t,r;return ar(this,function(s){switch(n){case io.PoseNet:return[2,Sdt(e)];case io.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,Qft(e)];if(t.runtime==="mediapipe")return[2,kft(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case io.MoveNet:return[2,idt(e)];default:throw new Error("".concat(n," is not a supported model name."))}})})}var Y4={},Z4={},J4={};const Q4="125",vf={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},wf={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Foe=0,xF=1,Loe=2,kdt=3,Tdt=0,eV=1,zoe=2,_b=3,rx=0,gi=1,FC=2,tV=1,Edt=2,If=0,Pb=1,_F=2,SF=3,CF=4,Boe=5,Om=100,Voe=101,Uoe=102,kF=103,TF=104,Woe=200,Goe=201,Hoe=202,joe=203,nV=204,rV=205,qoe=206,Xoe=207,Koe=208,Yoe=209,Zoe=210,Joe=0,Qoe=1,eae=2,kA=3,tae=4,nae=5,rae=6,sae=7,LC=0,iae=1,oae=2,Jm=0,aae=1,lae=2,cae=3,uae=4,hae=5,A$=300,zC=301,BC=302,TA=303,EA=304,sx=306,VC=307,iS=1e3,da=1001,oS=1002,Ui=1003,IA=1004,Idt=1004,AA=1005,Adt=1005,lo=1006,sV=1007,Mdt=1007,ix=1008,Ndt=1008,ox=1009,fae=1010,dae=1011,aS=1012,pae=1013,o_=1014,Sf=1015,lS=1016,mae=1017,gae=1018,yae=1019,Db=1020,bae=1021,Kd=1022,El=1023,vae=1024,wae=1025,xae=El,Qm=1026,hv=1027,_ae=1028,Sae=1029,Cae=1030,kae=1031,Tae=1032,Eae=1033,EF=33776,IF=33777,AF=33778,MF=33779,NF=35840,$F=35841,RF=35842,PF=35843,Iae=36196,DF=37492,OF=37496,Aae=37808,Mae=37809,Nae=37810,$ae=37811,Rae=37812,Pae=37813,Dae=37814,Oae=37815,Fae=37816,Lae=37817,zae=37818,Bae=37819,Vae=37820,Uae=37821,Wae=36492,Gae=37840,Hae=37841,jae=37842,qae=37843,Xae=37844,Kae=37845,Yae=37846,Zae=37847,Jae=37848,Qae=37849,ele=37850,tle=37851,nle=37852,rle=37853,sle=2200,ile=2201,ole=2202,cS=2300,a_=2301,nI=2302,Wm=2400,Gm=2401,uS=2402,M$=2500,iV=2501,ale=0,$dt=1,Rdt=2,Sa=3e3,UC=3001,N$=3007,$$=3002,lle=3003,oV=3004,aV=3005,lV=3006,cle=3200,ule=3201,Zy=0,hle=1,Pdt=0,rI=7680,Ddt=7681,Odt=7682,Fdt=7683,Ldt=34055,zdt=34056,Bdt=5386,Vdt=512,Udt=513,Wdt=514,Gdt=515,Hdt=516,jdt=517,qdt=518,fle=519,WC=35044,bg=35048,Xdt=35040,Kdt=35045,Ydt=35049,Zdt=35041,Jdt=35046,Qdt=35050,ept=35042,tpt="100",FF="300 es";function Uu(){}Object.assign(Uu.prototype,{addEventListener:function(n,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[n]===void 0&&(t[n]=[]),t[n].indexOf(e)===-1&&t[n].push(e)},hasEventListener:function(n,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[n]!==void 0&&t[n].indexOf(e)!==-1},removeEventListener:function(n,e){if(this._listeners===void 0)return;const r=this._listeners[n];if(r!==void 0){const s=r.indexOf(e);s!==-1&&r.splice(s,1)}},dispatchEvent:function(n){if(this._listeners===void 0)return;const t=this._listeners[n.type];if(t!==void 0){n.target=this;const r=t.slice(0);for(let s=0,i=r.length;s<i;s++)r[s].call(this,n)}}});const wo=[];for(let n=0;n<256;n++)wo[n]=(n<16?"0":"")+n.toString(16);let DT=1234567;const In={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(wo[n&255]+wo[n>>8&255]+wo[n>>16&255]+wo[n>>24&255]+"-"+wo[e&255]+wo[e>>8&255]+"-"+wo[e>>16&15|64]+wo[e>>24&255]+"-"+wo[t&63|128]+wo[t>>8&255]+"-"+wo[t>>16&255]+wo[t>>24&255]+wo[r&255]+wo[r>>8&255]+wo[r>>16&255]+wo[r>>24&255]).toUpperCase()},clamp:function(n,e,t){return Math.max(e,Math.min(t,n))},euclideanModulo:function(n,e){return(n%e+e)%e},mapLinear:function(n,e,t,r,s){return r+(n-e)*(s-r)/(t-e)},lerp:function(n,e,t){return(1-t)*n+t*e},damp:function(n,e,t,r){return In.lerp(n,e,1-Math.exp(-t*r))},pingpong:function(n,e=1){return e-Math.abs(In.euclideanModulo(n,e*2)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){return n!==void 0&&(DT=n%2147483647),DT=DT*16807%2147483647,(DT-1)/2147483646},degToRad:function(n){return n*In.DEG2RAD},radToDeg:function(n){return n*In.RAD2DEG},isPowerOfTwo:function(n){return(n&n-1)===0&&n!==0},ceilPowerOfTwo:function(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))},floorPowerOfTwo:function(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))},setQuaternionFromProperEuler:function(n,e,t,r,s){const i=Math.cos,o=Math.sin,a=i(t/2),l=o(t/2),c=i((e+r)/2),u=o((e+r)/2),h=i((e-r)/2),f=o((e-r)/2),d=i((r-e)/2),p=o((r-e)/2);switch(s){case"XYX":n.set(a*u,l*h,l*f,a*c);break;case"YZY":n.set(l*f,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*f,a*u,a*c);break;case"XZX":n.set(a*u,l*p,l*d,a*c);break;case"YXY":n.set(l*d,a*u,l*p,a*c);break;case"ZYZ":n.set(l*p,l*d,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}};class st{constructor(e=0,t=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6],this.y=s[1]*t+s[4]*r+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),s=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*r-o*s+e.x,this.y=i*s+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class _l{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,s,i,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=s,u[2]=a,u[3]=t,u[4]=i,u[5]=l,u[6]=r,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[3],l=r[6],c=r[1],u=r[4],h=r[7],f=r[2],d=r[5],p=r[8],m=s[0],g=s[3],y=s[6],b=s[1],x=s[4],w=s[7],S=s[2],C=s[5],k=s[8];return i[0]=o*m+a*b+l*S,i[3]=o*g+a*x+l*C,i[6]=o*y+a*w+l*k,i[1]=c*m+u*b+h*S,i[4]=c*g+u*x+h*C,i[7]=c*y+u*w+h*k,i[2]=f*m+d*b+p*S,i[5]=f*g+d*x+p*C,i[8]=f*y+d*w+p*k,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-r*i*u+r*a*l+s*i*c-s*o*l}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,f=a*l-u*i,d=c*i-o*l,p=t*h+r*f+s*d;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(s*c-u*r)*m,e[2]=(a*r-s*o)*m,e[3]=f*m,e[4]=(u*t-s*l)*m,e[5]=(s*i-a*t)*m,e[6]=d*m,e[7]=(r*l-c*t)*m,e[8]=(o*t-r*i)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).copy(this).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,s,i,o,a){const l=Math.cos(i),c=Math.sin(i);return this.set(r*l,r*c,-r*(l*o+c*a)+o+e,-s*c,s*l,-s*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const r=this.elements;return r[0]*=e,r[3]*=e,r[6]*=e,r[1]*=t,r[4]*=t,r[7]*=t,this}rotate(e){const t=Math.cos(e),r=Math.sin(e),s=this.elements,i=s[0],o=s[3],a=s[6],l=s[1],c=s[4],u=s[7];return s[0]=t*i+r*l,s[3]=t*o+r*c,s[6]=t*a+r*u,s[1]=-r*i+t*l,s[4]=-r*o+t*c,s[7]=-r*a+t*u,this}translate(e,t){const r=this.elements;return r[0]+=e*r[2],r[3]+=e*r[5],r[6]+=e*r[8],r[1]+=t*r[2],r[4]+=t*r[5],r[7]+=t*r[8],this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<9;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}}let U0;const Jy={getDataURL:function(n){if(/^data:/i.test(n.src)||typeof HTMLCanvasElement>"u")return n.src;let e;if(n instanceof HTMLCanvasElement)e=n;else{U0===void 0&&(U0=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),U0.width=n.width,U0.height=n.height;const t=U0.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=U0}return e.width>2048||e.height>2048?e.toDataURL("image/jpeg",.6):e.toDataURL("image/png")}};let npt=0;function Kr(n=Kr.DEFAULT_IMAGE,e=Kr.DEFAULT_MAPPING,t=da,r=da,s=lo,i=ix,o=El,a=ox,l=1,c=Sa){Object.defineProperty(this,"id",{value:npt++}),this.uuid=In.generateUUID(),this.name="",this.image=n,this.mipmaps=[],this.mapping=e,this.wrapS=t,this.wrapT=r,this.magFilter=s,this.minFilter=i,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new st(0,0),this.repeat=new st(1,1),this.center=new st(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new _l,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}Kr.DEFAULT_IMAGE=void 0;Kr.DEFAULT_MAPPING=A$;Kr.prototype=Object.assign(Object.create(Uu.prototype),{constructor:Kr,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.name=n.name,this.image=n.image,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this},toJSON:function(n){const e=n===void 0||typeof n=="string";if(!e&&n.textures[this.uuid]!==void 0)return n.textures[this.uuid];const t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=In.generateUUID()),!e&&n.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let i=0,o=r.length;i<o;i++)r[i].isDataTexture?s.push(oP(r[i].image)):s.push(oP(r[i]))}else s=oP(r);n.images[r.uuid]={uuid:r.uuid,url:s}}t.image=r.uuid}return e||(n.textures[this.uuid]=t),t},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(n){if(this.mapping!==A$)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case iS:n.x=n.x-Math.floor(n.x);break;case da:n.x=n.x<0?0:1;break;case oS:Math.abs(Math.floor(n.x)%2)===1?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x);break}if(n.y<0||n.y>1)switch(this.wrapT){case iS:n.y=n.y-Math.floor(n.y);break;case da:n.y=n.y<0?0:1;break;case oS:Math.abs(Math.floor(n.y)%2)===1?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y);break}return this.flipY&&(n.y=1-n.y),n}});Object.defineProperty(Kr.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function oP(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?Jy.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Hr{constructor(e=0,t=0,r=0,s=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=e,this.y=t,this.z=r,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,s){return this.x=e,this.y=t,this.z=r,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*s+o[12]*i,this.y=o[1]*t+o[5]*r+o[9]*s+o[13]*i,this.z=o[2]*t+o[6]*r+o[10]*s+o[14]*i,this.w=o[3]*t+o[7]*r+o[11]*s+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,s,i;const l=e.elements,c=l[0],u=l[4],h=l[8],f=l[1],d=l[5],p=l[9],m=l[2],g=l[6],y=l[10];if(Math.abs(u-f)<.01&&Math.abs(h-m)<.01&&Math.abs(p-g)<.01){if(Math.abs(u+f)<.1&&Math.abs(h+m)<.1&&Math.abs(p+g)<.1&&Math.abs(c+d+y-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const x=(c+1)/2,w=(d+1)/2,S=(y+1)/2,C=(u+f)/4,k=(h+m)/4,A=(p+g)/4;return x>w&&x>S?x<.01?(r=0,s=.707106781,i=.707106781):(r=Math.sqrt(x),s=C/r,i=k/r):w>S?w<.01?(r=.707106781,s=0,i=.707106781):(s=Math.sqrt(w),r=C/s,i=A/s):S<.01?(r=.707106781,s=.707106781,i=0):(i=Math.sqrt(S),r=k/i,s=A/i),this.set(r,s,i,t),this}let b=Math.sqrt((g-p)*(g-p)+(h-m)*(h-m)+(f-u)*(f-u));return Math.abs(b)<.001&&(b=1),this.x=(g-p)/b,this.y=(h-m)/b,this.z=(f-u)/b,this.w=Math.acos((c+d+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}class Yd extends Uu{constructor(e,t,r){super(),Object.defineProperty(this,"isWebGLRenderTarget",{value:!0}),this.width=e,this.height=t,this.scissor=new Hr(0,0,e,t),this.scissorTest=!1,this.viewport=new Hr(0,0,e,t),r=r||{},this.texture=new Kr(void 0,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=r.generateMipmaps!==void 0?r.generateMipmaps:!1,this.texture.minFilter=r.minFilter!==void 0?r.minFilter:lo,this.depthBuffer=r.depthBuffer!==void 0?r.depthBuffer:!0,this.stencilBuffer=r.stencilBuffer!==void 0?r.stencilBuffer:!1,this.depthTexture=r.depthTexture!==void 0?r.depthTexture:null}setSize(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}class rpt extends Yd{constructor(e,t,r){super(e,t,r),Object.defineProperty(this,"isWebGLMultisampleRenderTarget",{value:!0}),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}class co{constructor(e=0,t=0,r=0,s=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=e,this._y=t,this._z=r,this._w=s}static slerp(e,t,r,s){return r.copy(e).slerp(t,s)}static slerpFlat(e,t,r,s,i,o,a){let l=r[s+0],c=r[s+1],u=r[s+2],h=r[s+3];const f=i[o+0],d=i[o+1],p=i[o+2],m=i[o+3];if(h!==m||l!==f||c!==d||u!==p){let g=1-a;const y=l*f+c*d+u*p+h*m,b=y>=0?1:-1,x=1-y*y;if(x>Number.EPSILON){const S=Math.sqrt(x),C=Math.atan2(S,y*b);g=Math.sin(g*C)/S,a=Math.sin(a*C)/S}const w=a*b;if(l=l*g+f*w,c=c*g+d*w,u=u*g+p*w,h=h*g+m*w,g===1-a){const S=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=S,c*=S,u*=S,h*=S}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,r,s,i,o){const a=r[s],l=r[s+1],c=r[s+2],u=r[s+3],h=i[o],f=i[o+1],d=i[o+2],p=i[o+3];return e[t]=a*p+u*h+l*d-c*f,e[t+1]=l*p+u*f+c*h-a*d,e[t+2]=c*p+u*d+a*f-l*h,e[t+3]=u*p-a*h-l*f-c*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const r=e._x,s=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(r/2),u=a(s/2),h=a(i/2),f=l(r/2),d=l(s/2),p=l(i/2);switch(o){case"XYZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"YXZ":this._x=f*u*h+c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"ZXY":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h-f*d*p;break;case"ZYX":this._x=f*u*h-c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h+f*d*p;break;case"YZX":this._x=f*u*h+c*d*p,this._y=c*d*h+f*u*p,this._z=c*u*p-f*d*h,this._w=c*u*h-f*d*p;break;case"XZY":this._x=f*u*h-c*d*p,this._y=c*d*h-f*u*p,this._z=c*u*p+f*d*h,this._w=c*u*h+f*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,s=Math.sin(r);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],s=t[4],i=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],f=r+a+h;if(f>0){const d=.5/Math.sqrt(f+1);this._w=.25/d,this._x=(u-l)*d,this._y=(i-c)*d,this._z=(o-s)*d}else if(r>a&&r>h){const d=2*Math.sqrt(1+r-a-h);this._w=(u-l)/d,this._x=.25*d,this._y=(s+o)/d,this._z=(i+c)/d}else if(a>h){const d=2*Math.sqrt(1+a-r-h);this._w=(i-c)/d,this._x=(s+o)/d,this._y=.25*d,this._z=(l+u)/d}else{const d=2*Math.sqrt(1+h-r-a);this._w=(o-s)/d,this._x=(i+c)/d,this._y=(l+u)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<1e-6?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(In.clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const s=Math.min(1,t/r);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,s=e._y,i=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=r*u+o*a+s*c-i*l,this._y=s*u+o*l+i*a-r*c,this._z=i*u+o*c+r*l-s*a,this._w=o*u-r*a-s*l-i*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,s=this._y,i=this._z,o=this._w;let a=o*e._w+r*e._x+s*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=s,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const d=1-t;return this._w=d*o+t*this._w,this._x=d*r+t*this._x,this._y=d*s+t*this._y,this._z=d*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,f=Math.sin(t*u)/c;return this._w=o*h+this._w*f,this._x=r*h+this._x*f,this._y=s*h+this._y*f,this._z=i*h+this._z*f,this._onChangeCallback(),this}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}class Q{constructor(e=0,t=0,r=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(l8.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(l8.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6]*s,this.y=i[1]*t+i[4]*r+i[7]*s,this.z=i[2]*t+i[5]*r+i[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=e.elements,o=1/(i[3]*t+i[7]*r+i[11]*s+i[15]);return this.x=(i[0]*t+i[4]*r+i[8]*s+i[12])*o,this.y=(i[1]*t+i[5]*r+i[9]*s+i[13])*o,this.z=(i[2]*t+i[6]*r+i[10]*s+i[14])*o,this}applyQuaternion(e){const t=this.x,r=this.y,s=this.z,i=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*s-a*r,u=l*r+a*t-i*s,h=l*s+i*r-o*t,f=-i*t-o*r-a*s;return this.x=c*l+f*-i+u*-a-h*-o,this.y=u*l+f*-o+h*-i-c*-a,this.z=h*l+f*-a+c*-o-u*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[4]*r+i[8]*s,this.y=i[1]*t+i[5]*r+i[9]*s,this.z=i[2]*t+i[6]*r+i[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,s=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=s*l-i*a,this.y=i*o-r*l,this.z=r*a-s*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return aP.copy(this).projectOnVector(e),this.sub(aP)}reflect(e){return this.sub(aP.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(In.clamp(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,s=this.z-e.z;return t*t+r*r+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const s=Math.sin(t)*e;return this.x=s*Math.sin(r),this.y=Math.cos(t)*e,this.z=s*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,r){return r!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const aP=new Q,l8=new co;class Xf{constructor(e,t){Object.defineProperty(this,"isBox3",{value:!0}),this.min=e!==void 0?e:new Q(1/0,1/0,1/0),this.max=t!==void 0?t:new Q(-1/0,-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],f=e[l+2];u<t&&(t=u),h<r&&(r=h),f<s&&(s=f),u>i&&(i=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,s),this.max.set(i,o,a),this}setFromBufferAttribute(e){let t=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),f=e.getZ(l);u<t&&(t=u),h<r&&(r=h),f<s&&(s=f),u>i&&(i=u),h>o&&(o=h),f>a&&(a=f)}return this.min.set(t,r,s),this.max.set(i,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=n1.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return e===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new Q),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new Q),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),cP.copy(t.boundingBox),cP.applyMatrix4(e.matrixWorld),this.union(cP));const r=e.children;for(let s=0,i=r.length;s<i;s++)this.expandByObject(r[s]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new Q),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,n1),n1.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(r1),OT.subVectors(this.max,r1),W0.subVectors(e.a,r1),G0.subVectors(e.b,r1),H0.subVectors(e.c,r1),dd.subVectors(G0,W0),pd.subVectors(H0,G0),hm.subVectors(W0,H0);let t=[0,-dd.z,dd.y,0,-pd.z,pd.y,0,-hm.z,hm.y,dd.z,0,-dd.x,pd.z,0,-pd.x,hm.z,0,-hm.x,-dd.y,dd.x,0,-pd.y,pd.x,0,-hm.y,hm.x,0];return!lP(t,W0,G0,H0,OT)||(t=[1,0,0,0,1,0,0,0,1],!lP(t,W0,G0,H0,OT))?!1:(FT.crossVectors(dd,pd),t=[FT.x,FT.y,FT.z],lP(t,W0,G0,H0,OT))}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new Q),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return n1.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return e===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=this.getSize(n1).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(nf[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),nf[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),nf[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),nf[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),nf[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),nf[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),nf[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),nf[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(nf),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}function lP(n,e,t,r,s){for(let i=0,o=n.length-3;i<=o;i+=3){fm.fromArray(n,i);const a=s.x*Math.abs(fm.x)+s.y*Math.abs(fm.y)+s.z*Math.abs(fm.z),l=e.dot(fm),c=t.dot(fm),u=r.dot(fm);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const nf=[new Q,new Q,new Q,new Q,new Q,new Q,new Q,new Q],n1=new Q,cP=new Xf,W0=new Q,G0=new Q,H0=new Q,dd=new Q,pd=new Q,hm=new Q,r1=new Q,OT=new Q,FT=new Q,fm=new Q,spt=new Xf;class zp{constructor(e,t){this.center=e!==void 0?e:new Q,this.radius=t!==void 0?t:-1}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):spt.setFromPoints(e).getCenter(r);let s=0;for(let i=0,o=e.length;i<o;i++)s=Math.max(s,r.distanceToSquared(e[i]));return this.radius=Math.sqrt(s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new Q),t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return e===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Xf),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}}const rf=new Q,uP=new Q,LT=new Q,md=new Q,hP=new Q,zT=new Q,fP=new Q;class ax{constructor(e,t){this.origin=e!==void 0?e:new Q,this.direction=t!==void 0?t:new Q(0,0,-1)}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t===void 0&&(console.warn("THREE.Ray: .at() target is now required"),t=new Q),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,rf)),this}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new Q),t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=rf.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(rf.copy(this.direction).multiplyScalar(t).add(this.origin),rf.distanceToSquared(e))}distanceSqToSegment(e,t,r,s){uP.copy(e).add(t).multiplyScalar(.5),LT.copy(t).sub(e).normalize(),md.copy(this.origin).sub(uP);const i=e.distanceTo(t)*.5,o=-this.direction.dot(LT),a=md.dot(this.direction),l=-md.dot(LT),c=md.lengthSq(),u=Math.abs(1-o*o);let h,f,d,p;if(u>0)if(h=o*l-a,f=o*a-l,p=i*u,h>=0)if(f>=-p)if(f<=p){const m=1/u;h*=m,f*=m,d=h*(h+o*f+2*a)+f*(o*h+f+2*l)+c}else f=i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f=-i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;else f<=-p?(h=Math.max(0,-(-o*i+a)),f=h>0?-i:Math.min(Math.max(-i,-l),i),d=-h*h+f*(f+2*l)+c):f<=p?(h=0,f=Math.min(Math.max(-i,-l),i),d=f*(f+2*l)+c):(h=Math.max(0,-(o*i+a)),f=h>0?i:Math.min(Math.max(-i,-l),i),d=-h*h+f*(f+2*l)+c);else f=o>0?-i:i,h=Math.max(0,-(o*f+a)),d=-h*h+f*(f+2*l)+c;return r&&r.copy(this.direction).multiplyScalar(h).add(this.origin),s&&s.copy(LT).multiplyScalar(f).add(uP),d}intersectSphere(e,t){rf.subVectors(e.center,this.origin);const r=rf.dot(this.direction),s=rf.dot(rf)-r*r,i=e.radius*e.radius;if(s>i)return null;const o=Math.sqrt(i-s),a=r-o,l=r+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,s,i,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,f=this.origin;return c>=0?(r=(e.min.x-f.x)*c,s=(e.max.x-f.x)*c):(r=(e.max.x-f.x)*c,s=(e.min.x-f.x)*c),u>=0?(i=(e.min.y-f.y)*u,o=(e.max.y-f.y)*u):(i=(e.max.y-f.y)*u,o=(e.min.y-f.y)*u),r>o||i>s||((i>r||r!==r)&&(r=i),(o<s||s!==s)&&(s=o),h>=0?(a=(e.min.z-f.z)*h,l=(e.max.z-f.z)*h):(a=(e.max.z-f.z)*h,l=(e.min.z-f.z)*h),r>l||a>s)||((a>r||r!==r)&&(r=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(r>=0?r:s,t)}intersectsBox(e){return this.intersectBox(e,rf)!==null}intersectTriangle(e,t,r,s,i){hP.subVectors(t,e),zT.subVectors(r,e),fP.crossVectors(hP,zT);let o=this.direction.dot(fP),a;if(o>0){if(s)return null;a=1}else if(o<0)a=-1,o=-o;else return null;md.subVectors(this.origin,e);const l=a*this.direction.dot(zT.crossVectors(md,zT));if(l<0)return null;const c=a*this.direction.dot(hP.cross(md));if(c<0||l+c>o)return null;const u=-a*md.dot(fP);return u<0?null:this.at(u/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}class Zn{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g){const y=this.elements;return y[0]=e,y[4]=t,y[8]=r,y[12]=s,y[1]=i,y[5]=o,y[9]=a,y[13]=l,y[2]=c,y[6]=u,y[10]=h,y[14]=f,y[3]=d,y[7]=p,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Zn().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,s=1/j0.setFromMatrixColumn(e,0).length(),i=1/j0.setFromMatrixColumn(e,1).length(),o=1/j0.setFromMatrixColumn(e,2).length();return t[0]=r[0]*s,t[1]=r[1]*s,t[2]=r[2]*s,t[3]=0,t[4]=r[4]*i,t[5]=r[5]*i,t[6]=r[6]*i,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,r=e.x,s=e.y,i=e.z,o=Math.cos(r),a=Math.sin(r),l=Math.cos(s),c=Math.sin(s),u=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=d+p*c,t[5]=f-m*c,t[9]=-a*l,t[2]=m-f*c,t[6]=p+d*c,t[10]=o*l}else if(e.order==="YXZ"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f+m*a,t[4]=p*a-d,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=d*a-p,t[6]=m+f*a,t[10]=o*l}else if(e.order==="ZXY"){const f=l*u,d=l*h,p=c*u,m=c*h;t[0]=f-m*a,t[4]=-o*h,t[8]=p+d*a,t[1]=d+p*a,t[5]=o*u,t[9]=m-f*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const f=o*u,d=o*h,p=a*u,m=a*h;t[0]=l*u,t[4]=p*c-d,t[8]=f*c+m,t[1]=l*h,t[5]=m*c+f,t[9]=d*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=m-f*h,t[8]=p*h+d,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=d*h+p,t[10]=f-m*h}else if(e.order==="XZY"){const f=o*l,d=o*c,p=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=f*h+m,t[5]=o*u,t[9]=d*h-p,t[2]=p*h-d,t[6]=a*u,t[10]=m*h+f}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(ipt,e,opt)}lookAt(e,t,r){const s=this.elements;return ul.subVectors(e,t),ul.lengthSq()===0&&(ul.z=1),ul.normalize(),gd.crossVectors(r,ul),gd.lengthSq()===0&&(Math.abs(r.z)===1?ul.x+=1e-4:ul.z+=1e-4,ul.normalize(),gd.crossVectors(r,ul)),gd.normalize(),BT.crossVectors(ul,gd),s[0]=gd.x,s[4]=BT.x,s[8]=ul.x,s[1]=gd.y,s[5]=BT.y,s[9]=ul.y,s[2]=gd.z,s[6]=BT.z,s[10]=ul.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[4],l=r[8],c=r[12],u=r[1],h=r[5],f=r[9],d=r[13],p=r[2],m=r[6],g=r[10],y=r[14],b=r[3],x=r[7],w=r[11],S=r[15],C=s[0],k=s[4],A=s[8],M=s[12],E=s[1],N=s[5],O=s[9],R=s[13],D=s[2],z=s[6],B=s[10],X=s[14],G=s[3],te=s[7],ge=s[11],ae=s[15];return i[0]=o*C+a*E+l*D+c*G,i[4]=o*k+a*N+l*z+c*te,i[8]=o*A+a*O+l*B+c*ge,i[12]=o*M+a*R+l*X+c*ae,i[1]=u*C+h*E+f*D+d*G,i[5]=u*k+h*N+f*z+d*te,i[9]=u*A+h*O+f*B+d*ge,i[13]=u*M+h*R+f*X+d*ae,i[2]=p*C+m*E+g*D+y*G,i[6]=p*k+m*N+g*z+y*te,i[10]=p*A+m*O+g*B+y*ge,i[14]=p*M+m*R+g*X+y*ae,i[3]=b*C+x*E+w*D+S*G,i[7]=b*k+x*N+w*z+S*te,i[11]=b*A+x*O+w*B+S*ge,i[15]=b*M+x*R+w*X+S*ae,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],s=e[8],i=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],f=e[10],d=e[14],p=e[3],m=e[7],g=e[11],y=e[15];return p*(+i*l*h-s*c*h-i*a*f+r*c*f+s*a*d-r*l*d)+m*(+t*l*d-t*c*f+i*o*f-s*o*d+s*c*u-i*l*u)+g*(+t*c*h-t*a*d-i*o*h+r*o*d+i*a*u-r*c*u)+y*(-s*a*u-t*l*h+t*a*f+s*o*h-r*o*f+r*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],f=e[10],d=e[11],p=e[12],m=e[13],g=e[14],y=e[15],b=h*g*c-m*f*c+m*l*d-a*g*d-h*l*y+a*f*y,x=p*f*c-u*g*c-p*l*d+o*g*d+u*l*y-o*f*y,w=u*m*c-p*h*c+p*a*d-o*m*d-u*a*y+o*h*y,S=p*h*l-u*m*l-p*a*f+o*m*f+u*a*g-o*h*g,C=t*b+r*x+s*w+i*S;if(C===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/C;return e[0]=b*k,e[1]=(m*f*i-h*g*i-m*s*d+r*g*d+h*s*y-r*f*y)*k,e[2]=(a*g*i-m*l*i+m*s*c-r*g*c-a*s*y+r*l*y)*k,e[3]=(h*l*i-a*f*i-h*s*c+r*f*c+a*s*d-r*l*d)*k,e[4]=x*k,e[5]=(u*g*i-p*f*i+p*s*d-t*g*d-u*s*y+t*f*y)*k,e[6]=(p*l*i-o*g*i-p*s*c+t*g*c+o*s*y-t*l*y)*k,e[7]=(o*f*i-u*l*i+u*s*c-t*f*c-o*s*d+t*l*d)*k,e[8]=w*k,e[9]=(p*h*i-u*m*i-p*r*d+t*m*d+u*r*y-t*h*y)*k,e[10]=(o*m*i-p*a*i+p*r*c-t*m*c-o*r*y+t*a*y)*k,e[11]=(u*a*i-o*h*i-u*r*c+t*h*c+o*r*d-t*a*d)*k,e[12]=S*k,e[13]=(u*m*s-p*h*s+p*r*f-t*m*f-u*r*g+t*h*g)*k,e[14]=(p*a*s-o*m*s-p*r*l+t*m*l+o*r*g-t*a*g)*k,e[15]=(o*h*s-u*a*s+u*r*l-t*h*l-o*r*f+t*a*f)*k,this}scale(e){const t=this.elements,r=e.x,s=e.y,i=e.z;return t[0]*=r,t[4]*=s,t[8]*=i,t[1]*=r,t[5]*=s,t[9]*=i,t[2]*=r,t[6]*=s,t[10]*=i,t[3]*=r,t[7]*=s,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,s))}makeTranslation(e,t,r){return this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),s=Math.sin(t),i=1-r,o=e.x,a=e.y,l=e.z,c=i*o,u=i*a;return this.set(c*o+r,c*a-s*l,c*l+s*a,0,c*a+s*l,u*a+r,u*l-s*o,0,c*l-s*a,u*l+s*o,i*l*l+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r){return this.set(1,t,r,0,e,1,r,0,e,t,1,0,0,0,0,1),this}compose(e,t,r){const s=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,c=i+i,u=o+o,h=a+a,f=i*c,d=i*u,p=i*h,m=o*u,g=o*h,y=a*h,b=l*c,x=l*u,w=l*h,S=r.x,C=r.y,k=r.z;return s[0]=(1-(m+y))*S,s[1]=(d+w)*S,s[2]=(p-x)*S,s[3]=0,s[4]=(d-w)*C,s[5]=(1-(f+y))*C,s[6]=(g+b)*C,s[7]=0,s[8]=(p+x)*k,s[9]=(g-b)*k,s[10]=(1-(f+m))*k,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,r){const s=this.elements;let i=j0.set(s[0],s[1],s[2]).length();const o=j0.set(s[4],s[5],s[6]).length(),a=j0.set(s[8],s[9],s[10]).length();this.determinant()<0&&(i=-i),e.x=s[12],e.y=s[13],e.z=s[14],Yc.copy(this);const c=1/i,u=1/o,h=1/a;return Yc.elements[0]*=c,Yc.elements[1]*=c,Yc.elements[2]*=c,Yc.elements[4]*=u,Yc.elements[5]*=u,Yc.elements[6]*=u,Yc.elements[8]*=h,Yc.elements[9]*=h,Yc.elements[10]*=h,t.setFromRotationMatrix(Yc),r.x=i,r.y=o,r.z=a,this}makePerspective(e,t,r,s,i,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*i/(t-e),c=2*i/(r-s),u=(t+e)/(t-e),h=(r+s)/(r-s),f=-(o+i)/(o-i),d=-2*o*i/(o-i);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=f,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,r,s,i,o){const a=this.elements,l=1/(t-e),c=1/(r-s),u=1/(o-i),h=(t+e)*l,f=(r+s)*c,d=(o+i)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-f,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<16;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const j0=new Q,Yc=new Zn,ipt=new Q(0,0,0),opt=new Q(1,1,1),gd=new Q,BT=new Q,ul=new Q;class lx{constructor(e=0,t=0,r=0,s=lx.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=e,this._y=t,this._z=r,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._order=s||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,r){const s=In.clamp,i=e.elements,o=i[0],a=i[4],l=i[8],c=i[1],u=i[5],h=i[9],f=i[2],d=i[6],p=i[10];switch(t=t||this._order,t){case"XYZ":this._y=Math.asin(s(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-s(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,u)):(this._y=Math.atan2(-f,o),this._z=0);break;case"ZXY":this._x=Math.asin(s(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,p),this._z=Math.atan2(-a,u)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-s(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,u));break;case"YZX":this._z=Math.asin(s(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-h,u),this._y=Math.atan2(-f,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-s(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-h,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r!==!1&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return c8.makeRotationFromQuaternion(e),this.setFromRotationMatrix(c8,t,r)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return u8.setFromEuler(this),this.setFromQuaternion(u8,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new Q(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}lx.DefaultOrder="XYZ";lx.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const c8=new Zn,u8=new co;class cV{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}}let apt=0;const h8=new Q,q0=new co,sf=new Zn,VT=new Q,s1=new Q,lpt=new Q,cpt=new co,f8=new Q(1,0,0),d8=new Q(0,1,0),p8=new Q(0,0,1),upt={type:"added"},m8={type:"removed"};function rn(){Object.defineProperty(this,"id",{value:apt++}),this.uuid=In.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=rn.DefaultUp.clone();const n=new Q,e=new lx,t=new co,r=new Q(1,1,1);function s(){t.setFromEuler(e,!1)}function i(){e.setFromQuaternion(t,void 0,!1)}e._onChange(s),t._onChange(i),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:n},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Zn},normalMatrix:{value:new _l}}),this.matrix=new Zn,this.matrixWorld=new Zn,this.matrixAutoUpdate=rn.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new cV,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}rn.DefaultUp=new Q(0,1,0);rn.DefaultMatrixAutoUpdate=!0;rn.prototype=Object.assign(Object.create(Uu.prototype),{constructor:rn,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(n){return this.quaternion.premultiply(n),this},setRotationFromAxisAngle:function(n,e){this.quaternion.setFromAxisAngle(n,e)},setRotationFromEuler:function(n){this.quaternion.setFromEuler(n,!0)},setRotationFromMatrix:function(n){this.quaternion.setFromRotationMatrix(n)},setRotationFromQuaternion:function(n){this.quaternion.copy(n)},rotateOnAxis:function(n,e){return q0.setFromAxisAngle(n,e),this.quaternion.multiply(q0),this},rotateOnWorldAxis:function(n,e){return q0.setFromAxisAngle(n,e),this.quaternion.premultiply(q0),this},rotateX:function(n){return this.rotateOnAxis(f8,n)},rotateY:function(n){return this.rotateOnAxis(d8,n)},rotateZ:function(n){return this.rotateOnAxis(p8,n)},translateOnAxis:function(n,e){return h8.copy(n).applyQuaternion(this.quaternion),this.position.add(h8.multiplyScalar(e)),this},translateX:function(n){return this.translateOnAxis(f8,n)},translateY:function(n){return this.translateOnAxis(d8,n)},translateZ:function(n){return this.translateOnAxis(p8,n)},localToWorld:function(n){return n.applyMatrix4(this.matrixWorld)},worldToLocal:function(n){return n.applyMatrix4(sf.copy(this.matrixWorld).invert())},lookAt:function(n,e,t){n.isVector3?VT.copy(n):VT.set(n,e,t);const r=this.parent;this.updateWorldMatrix(!0,!1),s1.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?sf.lookAt(s1,VT,this.up):sf.lookAt(VT,s1,this.up),this.quaternion.setFromRotationMatrix(sf),r&&(sf.extractRotation(r.matrixWorld),q0.setFromRotationMatrix(sf),this.quaternion.premultiply(q0.invert()))},add:function(n){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(n.parent!==null&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(upt)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)},remove:function(n){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(n);return e!==-1&&(n.parent=null,this.children.splice(e,1),n.dispatchEvent(m8)),this},clear:function(){for(let n=0;n<this.children.length;n++){const e=this.children[n];e.parent=null,e.dispatchEvent(m8)}return this.children.length=0,this},attach:function(n){return this.updateWorldMatrix(!0,!1),sf.copy(this.matrixWorld).invert(),n.parent!==null&&(n.parent.updateWorldMatrix(!0,!1),sf.multiply(n.parent.matrixWorld)),n.applyMatrix4(sf),n.updateWorldMatrix(!1,!1),this.add(n),this},getObjectById:function(n){return this.getObjectByProperty("id",n)},getObjectByName:function(n){return this.getObjectByProperty("name",n)},getObjectByProperty:function(n,e){if(this[n]===e)return this;for(let t=0,r=this.children.length;t<r;t++){const i=this.children[t].getObjectByProperty(n,e);if(i!==void 0)return i}},getWorldPosition:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),n=new co),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(s1,n,lpt),n},getWorldScale:function(n){return n===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(s1,cpt,n),n},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()},raycast:function(){},traverse:function(n){n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverse(n)},traverseVisible:function(n){if(this.visible===!1)return;n(this);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].traverseVisible(n)},traverseAncestors:function(n){const e=this.parent;e!==null&&(n(e),e.traverseAncestors(n))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].updateMatrixWorld(n)},updateWorldMatrix:function(n,e){const t=this.parent;if(n===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let s=0,i=r.length;s<i;s++)r[s].updateWorldMatrix(!1,!0)}},toJSON:function(n){const e=n===void 0||typeof n=="string",t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON());function s(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(n)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(n.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const u=a[l];s(n.shapes,u)}else s(n.shapes,a)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(n.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(s(n.materials,this.material[a]));r.material=o}else r.material=s(n.materials,this.material);if(this.children.length>0){r.children=[];for(let o=0;o<this.children.length;o++)r.children.push(this.children[o].toJSON(n).object)}if(this.animations.length>0){r.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];r.animations.push(s(n.animations,a))}}if(e){const o=i(n.geometries),a=i(n.materials),l=i(n.textures),c=i(n.images),u=i(n.shapes),h=i(n.skeletons),f=i(n.animations);o.length>0&&(t.geometries=o),a.length>0&&(t.materials=a),l.length>0&&(t.textures=l),c.length>0&&(t.images=c),u.length>0&&(t.shapes=u),h.length>0&&(t.skeletons=h),f.length>0&&(t.animations=f)}return t.object=r,t;function i(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(n){return new this.constructor().copy(this,n)},copy:function(n,e=!0){if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),e===!0)for(let t=0;t<n.children.length;t++){const r=n.children[t];this.add(r.clone())}return this}});const dP=new Q,hpt=new Q,fpt=new _l;class ah{constructor(e,t){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=e!==void 0?e:new Q(1,0,0),this.constant=t!==void 0?t:0}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,s){return this.normal.set(e,t,r),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const s=dP.subVectors(r,t).cross(hpt.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}clone(){return new this.constructor().copy(this)}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new Q),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){t===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new Q);const r=e.delta(dP),s=this.normal.dot(r);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):void 0;const i=-(e.start.dot(this.normal)+this.constant)/s;if(!(i<0||i>1))return t.copy(r).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new Q),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||fpt.getNormalMatrix(e),s=this.coplanarPoint(dP).applyMatrix4(e),i=this.normal.applyMatrix3(r).normalize();return this.constant=-s.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}}const Zc=new Q,of=new Q,pP=new Q,af=new Q,X0=new Q,K0=new Q,g8=new Q,mP=new Q,gP=new Q,yP=new Q;class jo{constructor(e,t,r){this.a=e!==void 0?e:new Q,this.b=t!==void 0?t:new Q,this.c=r!==void 0?r:new Q}static getNormal(e,t,r,s){s===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),s=new Q),s.subVectors(r,t),Zc.subVectors(e,t),s.cross(Zc);const i=s.lengthSq();return i>0?s.multiplyScalar(1/Math.sqrt(i)):s.set(0,0,0)}static getBarycoord(e,t,r,s,i){Zc.subVectors(s,t),of.subVectors(r,t),pP.subVectors(e,t);const o=Zc.dot(Zc),a=Zc.dot(of),l=Zc.dot(pP),c=of.dot(of),u=of.dot(pP),h=o*c-a*a;if(i===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),i=new Q),h===0)return i.set(-2,-1,-1);const f=1/h,d=(c*l-a*u)*f,p=(o*u-a*l)*f;return i.set(1-d-p,p,d)}static containsPoint(e,t,r,s){return this.getBarycoord(e,t,r,s,af),af.x>=0&&af.y>=0&&af.x+af.y<=1}static getUV(e,t,r,s,i,o,a,l){return this.getBarycoord(e,t,r,s,af),l.set(0,0),l.addScaledVector(i,af.x),l.addScaledVector(o,af.y),l.addScaledVector(a,af.z),l}static isFrontFacing(e,t,r,s){return Zc.subVectors(r,t),of.subVectors(e,t),Zc.cross(of).dot(s)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,s){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[s]),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Zc.subVectors(this.c,this.b),of.subVectors(this.a,this.b),Zc.cross(of).length()*.5}getMidpoint(e){return e===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new Q),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return jo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new ah),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return jo.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,s,i){return jo.getUV(e,this.a,this.b,this.c,t,r,s,i)}containsPoint(e){return jo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return jo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){t===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new Q);const r=this.a,s=this.b,i=this.c;let o,a;X0.subVectors(s,r),K0.subVectors(i,r),mP.subVectors(e,r);const l=X0.dot(mP),c=K0.dot(mP);if(l<=0&&c<=0)return t.copy(r);gP.subVectors(e,s);const u=X0.dot(gP),h=K0.dot(gP);if(u>=0&&h<=u)return t.copy(s);const f=l*h-u*c;if(f<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(r).addScaledVector(X0,o);yP.subVectors(e,i);const d=X0.dot(yP),p=K0.dot(yP);if(p>=0&&d<=p)return t.copy(i);const m=d*c-l*p;if(m<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(r).addScaledVector(K0,a);const g=u*p-d*h;if(g<=0&&h-u>=0&&d-p>=0)return g8.subVectors(i,s),a=(h-u)/(h-u+(d-p)),t.copy(s).addScaledVector(g8,a);const y=1/(g+m+f);return o=m*y,a=f*y,t.copy(r).addScaledVector(X0,o).addScaledVector(K0,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const dle={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Jc={h:0,s:0,l:0},UT={h:0,s:0,l:0};function bP(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function vP(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function wP(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class Ht{constructor(e,t,r){return Object.defineProperty(this,"isColor",{value:!0}),t===void 0&&r===void 0?this.set(e):this.setRGB(e,t,r)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,r){return this.r=e,this.g=t,this.b=r,this}setHSL(e,t,r){if(e=In.euclideanModulo(e,1),t=In.clamp(t,0,1),r=In.clamp(r,0,1),t===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+t):r+t-r*t,i=2*r-s;this.r=bP(i,s,e+1/3),this.g=bP(i,s,e),this.b=bP(i,s,e-1/3)}return this}setStyle(e){function t(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let r;if(r=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const i=r[1],o=r[2];switch(i){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,t(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,t(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(s[1])/360,l=parseInt(s[2],10)/100,c=parseInt(s[3],10)/100;return t(s[4]),this.setHSL(a,l,c)}break}}else if(r=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=r[1],i=s.length;if(i===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,this;if(i===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=dle[e];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const r=t>0?1/t:1;return this.r=Math.pow(e.r,r),this.g=Math.pow(e.g,r),this.b=Math.pow(e.b,r),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=vP(e.r),this.g=vP(e.g),this.b=vP(e.b),this}copyLinearToSRGB(e){return this.r=wP(e.r),this.g=wP(e.g),this.b=wP(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){e===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,r=this.g,s=this.b,i=Math.max(t,r,s),o=Math.min(t,r,s);let a,l;const c=(o+i)/2;if(o===i)a=0,l=0;else{const u=i-o;switch(l=c<=.5?u/(i+o):u/(2-i-o),i){case t:a=(r-s)/u+(r<s?6:0);break;case r:a=(s-t)/u+2;break;case s:a=(t-r)/u+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,r){return this.getHSL(Jc),Jc.h+=e,Jc.s+=t,Jc.l+=r,this.setHSL(Jc.h,Jc.s,Jc.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(Jc),e.getHSL(UT);const r=In.lerp(Jc.h,UT.h,t),s=In.lerp(Jc.s,UT.s,t),i=In.lerp(Jc.l,UT.l,t);return this.setHSL(r,s,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Ht.NAMES=dle;Ht.prototype.r=1;Ht.prototype.g=1;Ht.prototype.b=1;class uV{constructor(e,t,r,s,i,o=0){this.a=e,this.b=t,this.c=r,this.normal=s&&s.isVector3?s:new Q,this.vertexNormals=Array.isArray(s)?s:[],this.color=i&&i.isColor?i:new Ht,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,r=e.vertexNormals.length;t<r;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,r=e.vertexColors.length;t<r;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}let dpt=0;function kn(){Object.defineProperty(this,"id",{value:dpt++}),this.uuid=In.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Pb,this.side=rx,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=nV,this.blendDst=rV,this.blendEquation=Om,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=kA,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=fle,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=rI,this.stencilZFail=rI,this.stencilZPass=rI,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}kn.prototype=Object.assign(Object.create(Uu.prototype),{constructor:kn,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(n){if(n!==void 0)for(const e in n){const t=n[e];if(t===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=t===tV;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(t):r&&r.isVector3&&t&&t.isVector3?r.copy(t):this[e]=t}},toJSON:function(n){const e=n===void 0||typeof n=="string";e&&(n={textures:{},images:{}});const t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(t.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,t.reflectivity=this.reflectivity,t.refractionRatio=this.refractionRatio,this.combine!==void 0&&(t.combine=this.combine),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),this.size!==void 0&&(t.size=this.size),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Pb&&(t.blending=this.blending),this.flatShading===!0&&(t.flatShading=this.flatShading),this.side!==rx&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(t.morphTargets=!0),this.morphNormals===!0&&(t.morphNormals=!0),this.skinning===!0&&(t.skinning=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(t.userData=this.userData);function r(s){const i=[];for(const o in s){const a=s[o];delete a.metadata,i.push(a)}return i}if(e){const s=r(n.textures),i=r(n.images);s.length>0&&(t.textures=s),i.length>0&&(t.images=i)}return t},clone:function(){return new this.constructor().copy(this)},copy:function(n){this.name=n.name,this.fog=n.fog,this.blending=n.blending,this.side=n.side,this.flatShading=n.flatShading,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;const e=n.clippingPlanes;let t=null;if(e!==null){const r=e.length;t=new Array(r);for(let s=0;s!==r;++s)t[s]=e[s].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(kn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});function Rl(n){kn.call(this),this.type="MeshBasicMaterial",this.color=new Ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=LC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(n)}Rl.prototype=Object.create(kn.prototype);Rl.prototype.constructor=Rl;Rl.prototype.isMeshBasicMaterial=!0;Rl.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this};const ss=new Q,WT=new st;function Cn(n,e,t){if(Array.isArray(n))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=n,this.itemSize=e,this.count=n!==void 0?n.length/e:0,this.normalized=t===!0,this.usage=WC,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Cn.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Cn.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[n+r]=e.array[t+r];return this},copyArray:function(n){return this.array.set(n),this},copyColorsArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),i=new Ht),e[t++]=i.r,e[t++]=i.g,e[t++]=i.b}return this},copyVector2sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),i=new st),e[t++]=i.x,e[t++]=i.y}return this},copyVector3sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),i=new Q),e[t++]=i.x,e[t++]=i.y,e[t++]=i.z}return this},copyVector4sArray:function(n){const e=this.array;let t=0;for(let r=0,s=n.length;r<s;r++){let i=n[r];i===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),i=new Hr),e[t++]=i.x,e[t++]=i.y,e[t++]=i.z,e[t++]=i.w}return this},applyMatrix3:function(n){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)WT.fromBufferAttribute(this,e),WT.applyMatrix3(n),this.setXY(e,WT.x,WT.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)ss.fromBufferAttribute(this,e),ss.applyMatrix3(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},applyMatrix4:function(n){for(let e=0,t=this.count;e<t;e++)ss.x=this.getX(e),ss.y=this.getY(e),ss.z=this.getZ(e),ss.applyMatrix4(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},applyNormalMatrix:function(n){for(let e=0,t=this.count;e<t;e++)ss.x=this.getX(e),ss.y=this.getY(e),ss.z=this.getZ(e),ss.applyNormalMatrix(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},transformDirection:function(n){for(let e=0,t=this.count;e<t;e++)ss.x=this.getX(e),ss.y=this.getY(e),ss.z=this.getZ(e),ss.transformDirection(n),this.setXYZ(e,ss.x,ss.y,ss.z);return this},set:function(n,e=0){return this.array.set(n,e),this},getX:function(n){return this.array[n*this.itemSize]},setX:function(n,e){return this.array[n*this.itemSize]=e,this},getY:function(n){return this.array[n*this.itemSize+1]},setY:function(n,e){return this.array[n*this.itemSize+1]=e,this},getZ:function(n){return this.array[n*this.itemSize+2]},setZ:function(n,e){return this.array[n*this.itemSize+2]=e,this},getW:function(n){return this.array[n*this.itemSize+3]},setW:function(n,e){return this.array[n*this.itemSize+3]=e,this},setXY:function(n,e,t){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this},setXYZW:function(n,e,t,r,s){return n*=this.itemSize,this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this.array[n+3]=s,this},onUpload:function(n){return this.onUploadCallback=n,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function hS(n,e,t){Cn.call(this,new Int8Array(n),e,t)}hS.prototype=Object.create(Cn.prototype);hS.prototype.constructor=hS;function fS(n,e,t){Cn.call(this,new Uint8Array(n),e,t)}fS.prototype=Object.create(Cn.prototype);fS.prototype.constructor=fS;function dS(n,e,t){Cn.call(this,new Uint8ClampedArray(n),e,t)}dS.prototype=Object.create(Cn.prototype);dS.prototype.constructor=dS;function pS(n,e,t){Cn.call(this,new Int16Array(n),e,t)}pS.prototype=Object.create(Cn.prototype);pS.prototype.constructor=pS;function vg(n,e,t){Cn.call(this,new Uint16Array(n),e,t)}vg.prototype=Object.create(Cn.prototype);vg.prototype.constructor=vg;function mS(n,e,t){Cn.call(this,new Int32Array(n),e,t)}mS.prototype=Object.create(Cn.prototype);mS.prototype.constructor=mS;function wg(n,e,t){Cn.call(this,new Uint32Array(n),e,t)}wg.prototype=Object.create(Cn.prototype);wg.prototype.constructor=wg;function gS(n,e,t){Cn.call(this,new Uint16Array(n),e,t)}gS.prototype=Object.create(Cn.prototype);gS.prototype.constructor=gS;gS.prototype.isFloat16BufferAttribute=!0;function Xt(n,e,t){Cn.call(this,new Float32Array(n),e,t)}Xt.prototype=Object.create(Cn.prototype);Xt.prototype.constructor=Xt;function yS(n,e,t){Cn.call(this,new Float64Array(n),e,t)}yS.prototype=Object.create(Cn.prototype);yS.prototype.constructor=yS;function ple(n){if(n.length===0)return-1/0;let e=n[0];for(let t=1,r=n.length;t<r;++t)n[t]>e&&(e=n[t]);return e}const ppt={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function O1(n,e){return new ppt[n](e)}let mpt=0;const Ju=new Zn,xP=new rn,Y0=new Q,hl=new Xf,i1=new Xf,no=new Q;function un(){Object.defineProperty(this,"id",{value:mpt++}),this.uuid=In.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}un.prototype=Object.assign(Object.create(Uu.prototype),{constructor:un,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(n){return Array.isArray(n)?this.index=new(ple(n)>65535?wg:vg)(n,1):this.index=n,this},getAttribute:function(n){return this.attributes[n]},setAttribute:function(n,e){return this.attributes[n]=e,this},deleteAttribute:function(n){return delete this.attributes[n],this},hasAttribute:function(n){return this.attributes[n]!==void 0},addGroup:function(n,e,t=0){this.groups.push({start:n,count:e,materialIndex:t})},clearGroups:function(){this.groups=[]},setDrawRange:function(n,e){this.drawRange.start=n,this.drawRange.count=e},applyMatrix4:function(n){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(n),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const s=new _l().getNormalMatrix(n);t.applyNormalMatrix(s),t.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(n),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(n){return Ju.makeRotationX(n),this.applyMatrix4(Ju),this},rotateY:function(n){return Ju.makeRotationY(n),this.applyMatrix4(Ju),this},rotateZ:function(n){return Ju.makeRotationZ(n),this.applyMatrix4(Ju),this},translate:function(n,e,t){return Ju.makeTranslation(n,e,t),this.applyMatrix4(Ju),this},scale:function(n,e,t){return Ju.makeScale(n,e,t),this.applyMatrix4(Ju),this},lookAt:function(n){return xP.lookAt(n),xP.updateMatrix(),this.applyMatrix4(xP.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Y0).negate(),this.translate(Y0.x,Y0.y,Y0.z),this},setFromPoints:function(n){const e=[];for(let t=0,r=n.length;t<r;t++){const s=n[t];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Xt(e,3)),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Xf);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Q(-1/0,-1/0,-1/0),new Q(1/0,1/0,1/0));return}if(n!==void 0){if(this.boundingBox.setFromBufferAttribute(n),e)for(let t=0,r=e.length;t<r;t++){const s=e[t];hl.setFromBufferAttribute(s),this.morphTargetsRelative?(no.addVectors(this.boundingBox.min,hl.min),this.boundingBox.expandByPoint(no),no.addVectors(this.boundingBox.max,hl.max),this.boundingBox.expandByPoint(no)):(this.boundingBox.expandByPoint(hl.min),this.boundingBox.expandByPoint(hl.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new zp);const n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Q,1/0);return}if(n){const t=this.boundingSphere.center;if(hl.setFromBufferAttribute(n),e)for(let s=0,i=e.length;s<i;s++){const o=e[s];i1.setFromBufferAttribute(o),this.morphTargetsRelative?(no.addVectors(hl.min,i1.min),hl.expandByPoint(no),no.addVectors(hl.max,i1.max),hl.expandByPoint(no)):(hl.expandByPoint(i1.min),hl.expandByPoint(i1.max))}hl.getCenter(t);let r=0;for(let s=0,i=n.count;s<i;s++)no.fromBufferAttribute(n,s),r=Math.max(r,t.distanceToSquared(no));if(e)for(let s=0,i=e.length;s<i;s++){const o=e[s],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)no.fromBufferAttribute(o,l),a&&(Y0.fromBufferAttribute(n,l),no.add(Y0)),r=Math.max(r,t.distanceToSquared(no))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeTangents:function(){const n=this.index,e=this.attributes;if(n===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=n.array,r=e.position.array,s=e.normal.array,i=e.uv.array,o=r.length/3;e.tangent===void 0&&this.setAttribute("tangent",new Cn(new Float32Array(4*o),4));const a=e.tangent.array,l=[],c=[];for(let M=0;M<o;M++)l[M]=new Q,c[M]=new Q;const u=new Q,h=new Q,f=new Q,d=new st,p=new st,m=new st,g=new Q,y=new Q;function b(M,E,N){u.fromArray(r,M*3),h.fromArray(r,E*3),f.fromArray(r,N*3),d.fromArray(i,M*2),p.fromArray(i,E*2),m.fromArray(i,N*2),h.sub(u),f.sub(u),p.sub(d),m.sub(d);const O=1/(p.x*m.y-m.x*p.y);isFinite(O)&&(g.copy(h).multiplyScalar(m.y).addScaledVector(f,-p.y).multiplyScalar(O),y.copy(f).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar(O),l[M].add(g),l[E].add(g),l[N].add(g),c[M].add(y),c[E].add(y),c[N].add(y))}let x=this.groups;x.length===0&&(x=[{start:0,count:t.length}]);for(let M=0,E=x.length;M<E;++M){const N=x[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)b(t[D+0],t[D+1],t[D+2])}const w=new Q,S=new Q,C=new Q,k=new Q;function A(M){C.fromArray(s,M*3),k.copy(C);const E=l[M];w.copy(E),w.sub(C.multiplyScalar(C.dot(E))).normalize(),S.crossVectors(k,E);const O=S.dot(c[M])<0?-1:1;a[M*4]=w.x,a[M*4+1]=w.y,a[M*4+2]=w.z,a[M*4+3]=O}for(let M=0,E=x.length;M<E;++M){const N=x[M],O=N.start,R=N.count;for(let D=O,z=O+R;D<z;D+=3)A(t[D+0]),A(t[D+1]),A(t[D+2])}},computeVertexNormals:function(){const n=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new Cn(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let h=0,f=t.count;h<f;h++)t.setXYZ(h,0,0,0);const r=new Q,s=new Q,i=new Q,o=new Q,a=new Q,l=new Q,c=new Q,u=new Q;if(n)for(let h=0,f=n.count;h<f;h+=3){const d=n.getX(h+0),p=n.getX(h+1),m=n.getX(h+2);r.fromBufferAttribute(e,d),s.fromBufferAttribute(e,p),i.fromBufferAttribute(e,m),c.subVectors(i,s),u.subVectors(r,s),c.cross(u),o.fromBufferAttribute(t,d),a.fromBufferAttribute(t,p),l.fromBufferAttribute(t,m),o.add(c),a.add(c),l.add(c),t.setXYZ(d,o.x,o.y,o.z),t.setXYZ(p,a.x,a.y,a.z),t.setXYZ(m,l.x,l.y,l.z)}else for(let h=0,f=e.count;h<f;h+=3)r.fromBufferAttribute(e,h+0),s.fromBufferAttribute(e,h+1),i.fromBufferAttribute(e,h+2),c.subVectors(i,s),u.subVectors(r,s),c.cross(u),t.setXYZ(h+0,c.x,c.y,c.z),t.setXYZ(h+1,c.x,c.y,c.z),t.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),t.needsUpdate=!0}},merge:function(n,e){if(!(n&&n.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",n);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const t=this.attributes;for(const r in t){if(n.attributes[r]===void 0)continue;const i=t[r].array,o=n.attributes[r],a=o.array,l=o.itemSize*e,c=Math.min(a.length,i.length-l);for(let u=0,h=l;u<c;u++,h++)i[h]=a[u]}return this},normalizeNormals:function(){const n=this.attributes.normal;for(let e=0,t=n.count;e<t;e++)no.fromBufferAttribute(n,e),no.normalize(),n.setXYZ(e,no.x,no.y,no.z)},toNonIndexed:function(){function n(o,a){const l=o.array,c=o.itemSize,u=o.normalized,h=new l.constructor(a.length*c);let f=0,d=0;for(let p=0,m=a.length;p<m;p++){f=a[p]*c;for(let g=0;g<c;g++)h[d++]=l[f++]}return new Cn(h,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new un,t=this.index.array,r=this.attributes;for(const o in r){const a=r[o],l=n(a,t);e.setAttribute(o,l)}const s=this.morphAttributes;for(const o in s){const a=[],l=s[o];for(let c=0,u=l.length;c<u;c++){const h=l[c],f=n(h,t);a.push(f)}e.morphAttributes[o]=a}e.morphTargetsRelative=this.morphTargetsRelative;const i=this.groups;for(let o=0,a=i.length;o<a;o++){const l=i[o];e.addGroup(l.start,l.count,l.materialIndex)}return e},toJSON:function(){const n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(n[l]=a[l]);return n}n.data={attributes:{}};const e=this.index;e!==null&&(n.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const l=t[a],c=l.toJSON(n.data);l.name!==""&&(c.name=l.name),n.data.attributes[a]=c}const r={};let s=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let u=0,h=l.length;u<h;u++){const f=l[u],d=f.toJSON(n.data);f.name!==""&&(d.name=f.name),c.push(d)}c.length>0&&(r[a]=c,s=!0)}s&&(n.data.morphAttributes=r,n.data.morphTargetsRelative=this.morphTargetsRelative);const i=this.groups;i.length>0&&(n.data.groups=JSON.parse(JSON.stringify(i)));const o=this.boundingSphere;return o!==null&&(n.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),n},clone:function(){return new un().copy(this)},copy:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=n.name;const t=n.index;t!==null&&this.setIndex(t.clone(e));const r=n.attributes;for(const l in r){const c=r[l];this.setAttribute(l,c.clone(e))}const s=n.morphAttributes;for(const l in s){const c=[],u=s[l];for(let h=0,f=u.length;h<f;h++)c.push(u[h].clone(e));this.morphAttributes[l]=c}this.morphTargetsRelative=n.morphTargetsRelative;const i=n.groups;for(let l=0,c=i.length;l<c;l++){const u=i[l];this.addGroup(u.start,u.count,u.materialIndex)}const o=n.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=n.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const y8=new Zn,Z0=new ax,_P=new zp,yd=new Q,bd=new Q,vd=new Q,SP=new Q,CP=new Q,kP=new Q,GT=new Q,HT=new Q,jT=new Q,qT=new st,XT=new st,KT=new st,TP=new Q,YT=new Q;function hs(n=new un,e=new Rl){rn.call(this),this.type="Mesh",this.geometry=n,this.material=e,this.updateMorphTargets()}hs.prototype=Object.assign(Object.create(rn.prototype),{constructor:hs,isMesh:!0,copy:function(n){return rn.prototype.copy.call(this,n),n.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),n.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(n,e){const t=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(t.boundingSphere===null&&t.computeBoundingSphere(),_P.copy(t.boundingSphere),_P.applyMatrix4(s),n.ray.intersectsSphere(_P)===!1)||(y8.copy(s).invert(),Z0.copy(n.ray).applyMatrix4(y8),t.boundingBox!==null&&Z0.intersectsBox(t.boundingBox)===!1))return;let i;if(t.isBufferGeometry){const o=t.index,a=t.attributes.position,l=t.morphAttributes.position,c=t.morphTargetsRelative,u=t.attributes.uv,h=t.attributes.uv2,f=t.groups,d=t.drawRange;if(o!==null)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),x=Math.min(g.start+g.count,d.start+d.count);for(let w=b,S=x;w<S;w+=3){const C=o.getX(w),k=o.getX(w+1),A=o.getX(w+2);i=ZT(this,y,n,Z0,a,l,c,u,h,C,k,A),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=g.materialIndex,e.push(i))}}else{const p=Math.max(0,d.start),m=Math.min(o.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=o.getX(g),x=o.getX(g+1),w=o.getX(g+2);i=ZT(this,r,n,Z0,a,l,c,u,h,b,x,w),i&&(i.faceIndex=Math.floor(g/3),e.push(i))}}else if(a!==void 0)if(Array.isArray(r))for(let p=0,m=f.length;p<m;p++){const g=f[p],y=r[g.materialIndex],b=Math.max(g.start,d.start),x=Math.min(g.start+g.count,d.start+d.count);for(let w=b,S=x;w<S;w+=3){const C=w,k=w+1,A=w+2;i=ZT(this,y,n,Z0,a,l,c,u,h,C,k,A),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=g.materialIndex,e.push(i))}}else{const p=Math.max(0,d.start),m=Math.min(a.count,d.start+d.count);for(let g=p,y=m;g<y;g+=3){const b=g,x=g+1,w=g+2;i=ZT(this,r,n,Z0,a,l,c,u,h,b,x,w),i&&(i.faceIndex=Math.floor(g/3),e.push(i))}}}else t.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});function gpt(n,e,t,r,s,i,o,a){let l;if(e.side===gi?l=r.intersectTriangle(o,i,s,!0,a):l=r.intersectTriangle(s,i,o,e.side!==FC,a),l===null)return null;YT.copy(a),YT.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(YT);return c<t.near||c>t.far?null:{distance:c,point:YT.clone(),object:n}}function ZT(n,e,t,r,s,i,o,a,l,c,u,h){yd.fromBufferAttribute(s,c),bd.fromBufferAttribute(s,u),vd.fromBufferAttribute(s,h);const f=n.morphTargetInfluences;if(e.morphTargets&&i&&f){GT.set(0,0,0),HT.set(0,0,0),jT.set(0,0,0);for(let p=0,m=i.length;p<m;p++){const g=f[p],y=i[p];g!==0&&(SP.fromBufferAttribute(y,c),CP.fromBufferAttribute(y,u),kP.fromBufferAttribute(y,h),o?(GT.addScaledVector(SP,g),HT.addScaledVector(CP,g),jT.addScaledVector(kP,g)):(GT.addScaledVector(SP.sub(yd),g),HT.addScaledVector(CP.sub(bd),g),jT.addScaledVector(kP.sub(vd),g)))}yd.add(GT),bd.add(HT),vd.add(jT)}n.isSkinnedMesh&&(n.boneTransform(c,yd),n.boneTransform(u,bd),n.boneTransform(h,vd));const d=gpt(n,e,t,r,yd,bd,vd,TP);if(d){a&&(qT.fromBufferAttribute(a,c),XT.fromBufferAttribute(a,u),KT.fromBufferAttribute(a,h),d.uv=jo.getUV(TP,yd,bd,vd,qT,XT,KT,new st)),l&&(qT.fromBufferAttribute(l,c),XT.fromBufferAttribute(l,u),KT.fromBufferAttribute(l,h),d.uv2=jo.getUV(TP,yd,bd,vd,qT,XT,KT,new st));const p=new uV(c,u,h);jo.getNormal(yd,bd,vd,p.normal),d.face=p}return d}class xg extends un{constructor(e=1,t=1,r=1,s=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:s,heightSegments:i,depthSegments:o};const a=this;s=Math.floor(s),i=Math.floor(i),o=Math.floor(o);const l=[],c=[],u=[],h=[];let f=0,d=0;p("z","y","x",-1,-1,r,t,e,o,i,0),p("z","y","x",1,-1,r,t,-e,o,i,1),p("x","z","y",1,1,e,r,t,s,o,2),p("x","z","y",1,-1,e,r,-t,s,o,3),p("x","y","z",1,-1,e,t,r,s,i,4),p("x","y","z",-1,-1,e,t,-r,s,i,5),this.setIndex(l),this.setAttribute("position",new Xt(c,3)),this.setAttribute("normal",new Xt(u,3)),this.setAttribute("uv",new Xt(h,2));function p(m,g,y,b,x,w,S,C,k,A,M){const E=w/k,N=S/A,O=w/2,R=S/2,D=C/2,z=k+1,B=A+1;let X=0,G=0;const te=new Q;for(let ge=0;ge<B;ge++){const ae=ge*N-R;for(let Ne=0;Ne<z;Ne++){const ke=Ne*E-O;te[m]=ke*b,te[g]=ae*x,te[y]=D,c.push(te.x,te.y,te.z),te[m]=0,te[g]=0,te[y]=C>0?1:-1,u.push(te.x,te.y,te.z),h.push(Ne/k),h.push(1-ge/A),X+=1}}for(let ge=0;ge<A;ge++)for(let ae=0;ae<k;ae++){const Ne=f+ae+z*ge,ke=f+ae+z*(ge+1),De=f+(ae+1)+z*(ge+1),be=f+(ae+1)+z*ge;l.push(Ne,ke,be),l.push(ke,De,be),G+=6}a.addGroup(d,G,M),d+=G,f+=X}}}function fv(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const s=n[t][r];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture)?e[t][r]=s.clone():Array.isArray(s)?e[t][r]=s.slice():e[t][r]=s}}return e}function Fo(n){const e={};for(let t=0;t<n.length;t++){const r=fv(n[t]);for(const s in r)e[s]=r[s]}return e}const mle={clone:fv,merge:Fo};var ypt=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,bpt=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function Ca(n){kn.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=ypt,this.fragmentShader=bpt,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,n!==void 0&&(n.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(n))}Ca.prototype=Object.create(kn.prototype);Ca.prototype.constructor=Ca;Ca.prototype.isShaderMaterial=!0;Ca.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=fv(n.uniforms),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.lights=n.lights,this.clipping=n.clipping,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this};Ca.prototype.toJSON=function(n){const e=kn.prototype.toJSON.call(this,n);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const i=this.uniforms[r].value;i&&i.isTexture?e.uniforms[r]={type:"t",value:i.toJSON(n).uuid}:i&&i.isColor?e.uniforms[r]={type:"c",value:i.getHex()}:i&&i.isVector2?e.uniforms[r]={type:"v2",value:i.toArray()}:i&&i.isVector3?e.uniforms[r]={type:"v3",value:i.toArray()}:i&&i.isVector4?e.uniforms[r]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?e.uniforms[r]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?e.uniforms[r]={type:"m4",value:i.toArray()}:e.uniforms[r]={value:i}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const t={};for(const r in this.extensions)this.extensions[r]===!0&&(t[r]=!0);return Object.keys(t).length>0&&(e.extensions=t),e};function kh(){rn.call(this),this.type="Camera",this.matrixWorldInverse=new Zn,this.projectionMatrix=new Zn,this.projectionMatrixInverse=new Zn}kh.prototype=Object.assign(Object.create(rn.prototype),{constructor:kh,isCamera:!0,copy:function(n,e){return rn.prototype.copy.call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this},getWorldDirection:function(n){n===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),n=new Q),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()},updateMatrixWorld:function(n){rn.prototype.updateMatrixWorld.call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(n,e){rn.prototype.updateWorldMatrix.call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function Si(n=50,e=1,t=.1,r=2e3){kh.call(this),this.type="PerspectiveCamera",this.fov=n,this.zoom=1,this.near=t,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}Si.prototype=Object.assign(Object.create(kh.prototype),{constructor:Si,isPerspectiveCamera:!0,copy:function(n,e){return kh.prototype.copy.call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=n.view===null?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this},setFocalLength:function(n){const e=.5*this.getFilmHeight()/n;this.fov=In.RAD2DEG*2*Math.atan(e),this.updateProjectionMatrix()},getFocalLength:function(){const n=Math.tan(In.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/n},getEffectiveFOV:function(){return In.RAD2DEG*2*Math.atan(Math.tan(In.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(n,e,t,r,s,i){this.aspect=n/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=this.near;let e=n*Math.tan(In.DEG2RAD*.5*this.fov)/this.zoom,t=2*e,r=this.aspect*t,s=-.5*r;const i=this.view;if(this.view!==null&&this.view.enabled){const a=i.fullWidth,l=i.fullHeight;s+=i.offsetX*r/a,e-=i.offsetY*t/l,r*=i.width/a,t*=i.height/l}const o=this.filmOffset;o!==0&&(s+=n*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}});const J0=90,Q0=1;function _g(n,e,t){if(rn.call(this),this.type="CubeCamera",t.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=t;const r=new Si(J0,Q0,n,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Q(1,0,0)),this.add(r);const s=new Si(J0,Q0,n,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new Q(-1,0,0)),this.add(s);const i=new Si(J0,Q0,n,e);i.layers=this.layers,i.up.set(0,0,1),i.lookAt(new Q(0,1,0)),this.add(i);const o=new Si(J0,Q0,n,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new Q(0,-1,0)),this.add(o);const a=new Si(J0,Q0,n,e);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new Q(0,0,1)),this.add(a);const l=new Si(J0,Q0,n,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new Q(0,0,-1)),this.add(l),this.update=function(c,u){this.parent===null&&this.updateMatrixWorld();const h=c.xr.enabled,f=c.getRenderTarget();c.xr.enabled=!1;const d=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,c.setRenderTarget(t,0),c.render(u,r),c.setRenderTarget(t,1),c.render(u,s),c.setRenderTarget(t,2),c.render(u,i),c.setRenderTarget(t,3),c.render(u,o),c.setRenderTarget(t,4),c.render(u,a),t.texture.generateMipmaps=d,c.setRenderTarget(t,5),c.render(u,l),c.setRenderTarget(f),c.xr.enabled=h}}_g.prototype=Object.create(rn.prototype);_g.prototype.constructor=_g;function Th(n,e,t,r,s,i,o,a,l,c){n=n!==void 0?n:[],e=e!==void 0?e:zC,o=o!==void 0?o:Kd,Kr.call(this,n,e,t,r,s,i,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}Th.prototype=Object.create(Kr.prototype);Th.prototype.constructor=Th;Th.prototype.isCubeTexture=!0;Object.defineProperty(Th.prototype,"images",{get:function(){return this.image},set:function(n){this.image=n}});class hV extends Yd{constructor(e,t,r){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=r),super(e,e,t),Object.defineProperty(this,"isWebGLCubeRenderTarget",{value:!0}),t=t||{},this.texture=new Th(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=El,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new xg(5,5,5),i=new Ca({name:"CubemapFromEquirect",uniforms:fv(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:gi,blending:If});i.uniforms.tEquirect.value=t;const o=new hs(s,i),a=t.minFilter;return t.minFilter===ix&&(t.minFilter=lo),new _g(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,r,s){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,r,s);e.setRenderTarget(i)}}function Pf(n,e,t,r,s,i,o,a,l,c,u,h){Kr.call(this,null,i,o,a,l,c,r,s,u,h),this.image={data:n||null,width:e||1,height:t||1},this.magFilter=l!==void 0?l:Ui,this.minFilter=c!==void 0?c:Ui,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Pf.prototype=Object.create(Kr.prototype);Pf.prototype.constructor=Pf;Pf.prototype.isDataTexture=!0;const eb=new zp,JT=new Q;class GC{constructor(e,t,r,s,i,o){this.planes=[e!==void 0?e:new ah,t!==void 0?t:new ah,r!==void 0?r:new ah,s!==void 0?s:new ah,i!==void 0?i:new ah,o!==void 0?o:new ah]}set(e,t,r,s,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(r),a[3].copy(s),a[4].copy(i),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e){const t=this.planes,r=e.elements,s=r[0],i=r[1],o=r[2],a=r[3],l=r[4],c=r[5],u=r[6],h=r[7],f=r[8],d=r[9],p=r[10],m=r[11],g=r[12],y=r[13],b=r[14],x=r[15];return t[0].setComponents(a-s,h-l,m-f,x-g).normalize(),t[1].setComponents(a+s,h+l,m+f,x+g).normalize(),t[2].setComponents(a+i,h+c,m+d,x+y).normalize(),t[3].setComponents(a-i,h-c,m-d,x-y).normalize(),t[4].setComponents(a-o,h-u,m-p,x-b).normalize(),t[5].setComponents(a+o,h+u,m+p,x+b).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),eb.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(eb)}intersectsSprite(e){return eb.center.set(0,0,0),eb.radius=.7071067811865476,eb.applyMatrix4(e.matrixWorld),this.intersectsSphere(eb)}intersectsSphere(e){const t=this.planes,r=e.center,s=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(r)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const s=t[r];if(JT.x=s.normal.x>0?e.max.x:e.min.x,JT.y=s.normal.y>0?e.max.y:e.min.y,JT.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(JT)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}}function gle(){let n=null,e=!1,t=null,r=null;function s(i,o){t(i,o),r=n.requestAnimationFrame(s)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(s),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function vpt(n,e){const t=e.isWebGL2,r=new WeakMap;function s(c,u){const h=c.array,f=c.usage,d=n.createBuffer();n.bindBuffer(u,d),n.bufferData(u,h,f),c.onUploadCallback();let p=5126;return h instanceof Float32Array?p=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?c.isFloat16BufferAttribute?t?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:h instanceof Int16Array?p=5122:h instanceof Uint32Array?p=5125:h instanceof Int32Array?p=5124:h instanceof Int8Array?p=5120:h instanceof Uint8Array&&(p=5121),{buffer:d,type:p,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function i(c,u,h){const f=u.array,d=u.updateRange;n.bindBuffer(h,c),d.count===-1?n.bufferSubData(h,0,f):(t?n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f,d.offset,d.count):n.bufferSubData(h,d.offset*f.BYTES_PER_ELEMENT,f.subarray(d.offset,d.offset+d.count)),d.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),r.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=r.get(c);u&&(n.deleteBuffer(u.buffer),r.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const f=r.get(c);(!f||f.version<c.version)&&r.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=r.get(c);h===void 0?r.set(c,s(c,u)):h.version<c.version&&(i(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class bS extends un{constructor(e=1,t=1,r=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:s};const i=e/2,o=t/2,a=Math.floor(r),l=Math.floor(s),c=a+1,u=l+1,h=e/a,f=t/l,d=[],p=[],m=[],g=[];for(let y=0;y<u;y++){const b=y*f-o;for(let x=0;x<c;x++){const w=x*h-i;p.push(w,-b,0),m.push(0,0,1),g.push(x/a),g.push(1-y/l)}}for(let y=0;y<l;y++)for(let b=0;b<a;b++){const x=b+c*y,w=b+c*(y+1),S=b+1+c*(y+1),C=b+1+c*y;d.push(x,w,C),d.push(w,S,C)}this.setIndex(d),this.setAttribute("position",new Xt(p,3)),this.setAttribute("normal",new Xt(m,3)),this.setAttribute("uv",new Xt(g,2))}}var wpt=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,xpt=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,_pt=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,Spt=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,Cpt=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,kpt="vec3 transformed = vec3( position );",Tpt=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Ept=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,Ipt=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Apt=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Mpt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Npt=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,$pt=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Rpt=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,Ppt=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,Dpt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Opt=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Fpt=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Lpt=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,zpt=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Bpt=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Vpt=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Upt=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Wpt=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Gpt="gl_FragColor = linearToOutputTexel( gl_FragColor );",Hpt=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,jpt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,qpt=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Xpt=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Kpt=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Ypt=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Zpt=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,Jpt=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,Qpt=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,emt=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,tmt=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,nmt=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,rmt=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,smt=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,imt=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,omt=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,amt=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lmt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,cmt=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,umt=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,hmt=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,fmt=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,dmt=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,pmt=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,mmt=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,gmt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,ymt=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,bmt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,vmt=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,wmt=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,xmt=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,_mt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,Smt=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Cmt=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,kmt=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,Tmt=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,Emt=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,Imt=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,Amt=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,Mmt=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,Nmt=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,$mt=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,Rmt=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,Pmt=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,Dmt=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,Omt=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Fmt=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Lmt=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,zmt=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Bmt=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Vmt=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Umt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Wmt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Gmt=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Hmt=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,jmt=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,qmt=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Xmt=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Kmt=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Ymt=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Zmt=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Jmt=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Qmt=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,egt=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,tgt=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,ngt=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,rgt=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,sgt=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,igt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,ogt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,agt=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,lgt=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,cgt=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ugt=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,hgt=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,fgt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,dgt=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,pgt=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,mgt=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,ggt=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,ygt=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,bgt=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,vgt=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,wgt=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,xgt=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_gt=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Sgt=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Cgt=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,kgt=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Tgt=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Egt=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Igt=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Agt=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Mgt=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Ngt=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$gt=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Rgt=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,Pgt=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Dgt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Ogt=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Fgt=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Lgt=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,zgt=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,Bgt=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Jn={alphamap_fragment:wpt,alphamap_pars_fragment:xpt,alphatest_fragment:_pt,aomap_fragment:Spt,aomap_pars_fragment:Cpt,begin_vertex:kpt,beginnormal_vertex:Tpt,bsdfs:Ept,bumpmap_pars_fragment:Ipt,clipping_planes_fragment:Apt,clipping_planes_pars_fragment:Mpt,clipping_planes_pars_vertex:Npt,clipping_planes_vertex:$pt,color_fragment:Rpt,color_pars_fragment:Ppt,color_pars_vertex:Dpt,color_vertex:Opt,common:Fpt,cube_uv_reflection_fragment:Lpt,defaultnormal_vertex:zpt,displacementmap_pars_vertex:Bpt,displacementmap_vertex:Vpt,emissivemap_fragment:Upt,emissivemap_pars_fragment:Wpt,encodings_fragment:Gpt,encodings_pars_fragment:Hpt,envmap_fragment:jpt,envmap_common_pars_fragment:qpt,envmap_pars_fragment:Xpt,envmap_pars_vertex:Kpt,envmap_physical_pars_fragment:omt,envmap_vertex:Ypt,fog_vertex:Zpt,fog_pars_vertex:Jpt,fog_fragment:Qpt,fog_pars_fragment:emt,gradientmap_pars_fragment:tmt,lightmap_fragment:nmt,lightmap_pars_fragment:rmt,lights_lambert_vertex:smt,lights_pars_begin:imt,lights_toon_fragment:amt,lights_toon_pars_fragment:lmt,lights_phong_fragment:cmt,lights_phong_pars_fragment:umt,lights_physical_fragment:hmt,lights_physical_pars_fragment:fmt,lights_fragment_begin:dmt,lights_fragment_maps:pmt,lights_fragment_end:mmt,logdepthbuf_fragment:gmt,logdepthbuf_pars_fragment:ymt,logdepthbuf_pars_vertex:bmt,logdepthbuf_vertex:vmt,map_fragment:wmt,map_pars_fragment:xmt,map_particle_fragment:_mt,map_particle_pars_fragment:Smt,metalnessmap_fragment:Cmt,metalnessmap_pars_fragment:kmt,morphnormal_vertex:Tmt,morphtarget_pars_vertex:Emt,morphtarget_vertex:Imt,normal_fragment_begin:Amt,normal_fragment_maps:Mmt,normalmap_pars_fragment:Nmt,clearcoat_normal_fragment_begin:$mt,clearcoat_normal_fragment_maps:Rmt,clearcoat_pars_fragment:Pmt,packing:Dmt,premultiplied_alpha_fragment:Omt,project_vertex:Fmt,dithering_fragment:Lmt,dithering_pars_fragment:zmt,roughnessmap_fragment:Bmt,roughnessmap_pars_fragment:Vmt,shadowmap_pars_fragment:Umt,shadowmap_pars_vertex:Wmt,shadowmap_vertex:Gmt,shadowmask_pars_fragment:Hmt,skinbase_vertex:jmt,skinning_pars_vertex:qmt,skinning_vertex:Xmt,skinnormal_vertex:Kmt,specularmap_fragment:Ymt,specularmap_pars_fragment:Zmt,tonemapping_fragment:Jmt,tonemapping_pars_fragment:Qmt,transmissionmap_fragment:egt,transmissionmap_pars_fragment:tgt,uv_pars_fragment:ngt,uv_pars_vertex:rgt,uv_vertex:sgt,uv2_pars_fragment:igt,uv2_pars_vertex:ogt,uv2_vertex:agt,worldpos_vertex:lgt,background_frag:cgt,background_vert:ugt,cube_frag:hgt,cube_vert:fgt,depth_frag:dgt,depth_vert:pgt,distanceRGBA_frag:mgt,distanceRGBA_vert:ggt,equirect_frag:ygt,equirect_vert:bgt,linedashed_frag:vgt,linedashed_vert:wgt,meshbasic_frag:xgt,meshbasic_vert:_gt,meshlambert_frag:Sgt,meshlambert_vert:Cgt,meshmatcap_frag:kgt,meshmatcap_vert:Tgt,meshtoon_frag:Egt,meshtoon_vert:Igt,meshphong_frag:Agt,meshphong_vert:Mgt,meshphysical_frag:Ngt,meshphysical_vert:$gt,normal_frag:Rgt,normal_vert:Pgt,points_frag:Dgt,points_vert:Ogt,shadow_frag:Fgt,shadow_vert:Lgt,sprite_frag:zgt,sprite_vert:Bgt},Pt={common:{diffuse:{value:new Ht(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new _l},uv2Transform:{value:new _l},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new st(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ht(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ht(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new _l}},sprite:{diffuse:{value:new Ht(15658734)},opacity:{value:1},center:{value:new st(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new _l}}},iu={basic:{uniforms:Fo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.fog]),vertexShader:Jn.meshbasic_vert,fragmentShader:Jn.meshbasic_frag},lambert:{uniforms:Fo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)}}]),vertexShader:Jn.meshlambert_vert,fragmentShader:Jn.meshlambert_frag},phong:{uniforms:Fo([Pt.common,Pt.specularmap,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)},specular:{value:new Ht(1118481)},shininess:{value:30}}]),vertexShader:Jn.meshphong_vert,fragmentShader:Jn.meshphong_frag},standard:{uniforms:Fo([Pt.common,Pt.envmap,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.roughnessmap,Pt.metalnessmap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag},toon:{uniforms:Fo([Pt.common,Pt.aomap,Pt.lightmap,Pt.emissivemap,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.gradientmap,Pt.fog,Pt.lights,{emissive:{value:new Ht(0)}}]),vertexShader:Jn.meshtoon_vert,fragmentShader:Jn.meshtoon_frag},matcap:{uniforms:Fo([Pt.common,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,Pt.fog,{matcap:{value:null}}]),vertexShader:Jn.meshmatcap_vert,fragmentShader:Jn.meshmatcap_frag},points:{uniforms:Fo([Pt.points,Pt.fog]),vertexShader:Jn.points_vert,fragmentShader:Jn.points_frag},dashed:{uniforms:Fo([Pt.common,Pt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Jn.linedashed_vert,fragmentShader:Jn.linedashed_frag},depth:{uniforms:Fo([Pt.common,Pt.displacementmap]),vertexShader:Jn.depth_vert,fragmentShader:Jn.depth_frag},normal:{uniforms:Fo([Pt.common,Pt.bumpmap,Pt.normalmap,Pt.displacementmap,{opacity:{value:1}}]),vertexShader:Jn.normal_vert,fragmentShader:Jn.normal_frag},sprite:{uniforms:Fo([Pt.sprite,Pt.fog]),vertexShader:Jn.sprite_vert,fragmentShader:Jn.sprite_frag},background:{uniforms:{uvTransform:{value:new _l},t2D:{value:null}},vertexShader:Jn.background_vert,fragmentShader:Jn.background_frag},cube:{uniforms:Fo([Pt.envmap,{opacity:{value:1}}]),vertexShader:Jn.cube_vert,fragmentShader:Jn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Jn.equirect_vert,fragmentShader:Jn.equirect_frag},distanceRGBA:{uniforms:Fo([Pt.common,Pt.displacementmap,{referencePosition:{value:new Q},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Jn.distanceRGBA_vert,fragmentShader:Jn.distanceRGBA_frag},shadow:{uniforms:Fo([Pt.lights,Pt.fog,{color:{value:new Ht(0)},opacity:{value:1}}]),vertexShader:Jn.shadow_vert,fragmentShader:Jn.shadow_frag}};iu.physical={uniforms:Fo([iu.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new st(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Ht(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Jn.meshphysical_vert,fragmentShader:Jn.meshphysical_frag};function Vgt(n,e,t,r,s){const i=new Ht(0);let o=0,a,l,c=null,u=0,h=null;function f(p,m,g,y){let b=m.isScene===!0?m.background:null;b&&b.isTexture&&(b=e.get(b));const x=n.xr,w=x.getSession&&x.getSession();w&&w.environmentBlendMode==="additive"&&(b=null),b===null?d(i,o):b&&b.isColor&&(d(b,1),y=!0),(n.autoClear||y)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),b&&(b.isCubeTexture||b.isWebGLCubeRenderTarget||b.mapping===sx)?(l===void 0&&(l=new hs(new xg(1,1,1),new Ca({name:"BackgroundCubeMaterial",uniforms:fv(iu.cube.uniforms),vertexShader:iu.cube.vertexShader,fragmentShader:iu.cube.fragmentShader,side:gi,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(S,C,k){this.matrixWorld.copyPosition(k.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),b.isWebGLCubeRenderTarget&&(b=b.texture),l.material.uniforms.envMap.value=b,l.material.uniforms.flipEnvMap.value=b.isCubeTexture&&b._needsFlipEnvMap?-1:1,(c!==b||u!==b.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):b&&b.isTexture&&(a===void 0&&(a=new hs(new bS(2,2),new Ca({name:"BackgroundMaterial",uniforms:fv(iu.background.uniforms),vertexShader:iu.background.vertexShader,fragmentShader:iu.background.fragmentShader,side:rx,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=b,b.matrixAutoUpdate===!0&&b.updateMatrix(),a.material.uniforms.uvTransform.value.copy(b.matrix),(c!==b||u!==b.version||h!==n.toneMapping)&&(a.material.needsUpdate=!0,c=b,u=b.version,h=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function d(p,m){t.buffers.color.setClear(p.r,p.g,p.b,m,s)}return{getClearColor:function(){return i},setClearColor:function(p,m=1){i.set(p),o=m,d(i,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,d(i,o)},render:f}}function Ugt(n,e,t,r){const s=n.getParameter(34921),i=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||i!==null,a={},l=m(null);let c=l;function u(R,D,z,B,X){let G=!1;if(o){const te=p(B,z,D);c!==te&&(c=te,f(c.object)),G=g(B,X),G&&y(B,X)}else{const te=D.wireframe===!0;(c.geometry!==B.id||c.program!==z.id||c.wireframe!==te)&&(c.geometry=B.id,c.program=z.id,c.wireframe=te,G=!0)}R.isInstancedMesh===!0&&(G=!0),X!==null&&t.update(X,34963),G&&(k(R,D,z,B),X!==null&&n.bindBuffer(34963,t.get(X).buffer))}function h(){return r.isWebGL2?n.createVertexArray():i.createVertexArrayOES()}function f(R){return r.isWebGL2?n.bindVertexArray(R):i.bindVertexArrayOES(R)}function d(R){return r.isWebGL2?n.deleteVertexArray(R):i.deleteVertexArrayOES(R)}function p(R,D,z){const B=z.wireframe===!0;let X=a[R.id];X===void 0&&(X={},a[R.id]=X);let G=X[D.id];G===void 0&&(G={},X[D.id]=G);let te=G[B];return te===void 0&&(te=m(h()),G[B]=te),te}function m(R){const D=[],z=[],B=[];for(let X=0;X<s;X++)D[X]=0,z[X]=0,B[X]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:D,enabledAttributes:z,attributeDivisors:B,object:R,attributes:{},index:null}}function g(R,D){const z=c.attributes,B=R.attributes;let X=0;for(const G in B){const te=z[G],ge=B[G];if(te===void 0||te.attribute!==ge||te.data!==ge.data)return!0;X++}return c.attributesNum!==X||c.index!==D}function y(R,D){const z={},B=R.attributes;let X=0;for(const G in B){const te=B[G],ge={};ge.attribute=te,te.data&&(ge.data=te.data),z[G]=ge,X++}c.attributes=z,c.attributesNum=X,c.index=D}function b(){const R=c.newAttributes;for(let D=0,z=R.length;D<z;D++)R[D]=0}function x(R){w(R,0)}function w(R,D){const z=c.newAttributes,B=c.enabledAttributes,X=c.attributeDivisors;z[R]=1,B[R]===0&&(n.enableVertexAttribArray(R),B[R]=1),X[R]!==D&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](R,D),X[R]=D)}function S(){const R=c.newAttributes,D=c.enabledAttributes;for(let z=0,B=D.length;z<B;z++)D[z]!==R[z]&&(n.disableVertexAttribArray(z),D[z]=0)}function C(R,D,z,B,X,G){r.isWebGL2===!0&&(z===5124||z===5125)?n.vertexAttribIPointer(R,D,z,X,G):n.vertexAttribPointer(R,D,z,B,X,G)}function k(R,D,z,B){if(r.isWebGL2===!1&&(R.isInstancedMesh||B.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;b();const X=B.attributes,G=z.getAttributes(),te=D.defaultAttributeValues;for(const ge in G){const ae=G[ge];if(ae>=0){const Ne=X[ge];if(Ne!==void 0){const ke=Ne.normalized,De=Ne.itemSize,be=t.get(Ne);if(be===void 0)continue;const Xe=be.buffer,Oe=be.type,it=be.bytesPerElement;if(Ne.isInterleavedBufferAttribute){const We=Ne.data,dt=We.stride,ct=Ne.offset;We&&We.isInstancedInterleavedBuffer?(w(ae,We.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=We.meshPerAttribute*We.count)):x(ae),n.bindBuffer(34962,Xe),C(ae,De,Oe,ke,dt*it,ct*it)}else Ne.isInstancedBufferAttribute?(w(ae,Ne.meshPerAttribute),B._maxInstanceCount===void 0&&(B._maxInstanceCount=Ne.meshPerAttribute*Ne.count)):x(ae),n.bindBuffer(34962,Xe),C(ae,De,Oe,ke,0,0)}else if(ge==="instanceMatrix"){const ke=t.get(R.instanceMatrix);if(ke===void 0)continue;const De=ke.buffer,be=ke.type;w(ae+0,1),w(ae+1,1),w(ae+2,1),w(ae+3,1),n.bindBuffer(34962,De),n.vertexAttribPointer(ae+0,4,be,!1,64,0),n.vertexAttribPointer(ae+1,4,be,!1,64,16),n.vertexAttribPointer(ae+2,4,be,!1,64,32),n.vertexAttribPointer(ae+3,4,be,!1,64,48)}else if(ge==="instanceColor"){const ke=t.get(R.instanceColor);if(ke===void 0)continue;const De=ke.buffer,be=ke.type;w(ae,1),n.bindBuffer(34962,De),n.vertexAttribPointer(ae,3,be,!1,12,0)}else if(te!==void 0){const ke=te[ge];if(ke!==void 0)switch(ke.length){case 2:n.vertexAttrib2fv(ae,ke);break;case 3:n.vertexAttrib3fv(ae,ke);break;case 4:n.vertexAttrib4fv(ae,ke);break;default:n.vertexAttrib1fv(ae,ke)}}}}S()}function A(){N();for(const R in a){const D=a[R];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R]}}function M(R){if(a[R.id]===void 0)return;const D=a[R.id];for(const z in D){const B=D[z];for(const X in B)d(B[X].object),delete B[X];delete D[z]}delete a[R.id]}function E(R){for(const D in a){const z=a[D];if(z[R.id]===void 0)continue;const B=z[R.id];for(const X in B)d(B[X].object),delete B[X];delete z[R.id]}}function N(){O(),c!==l&&(c=l,f(c.object))}function O(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:N,resetDefaultState:O,dispose:A,releaseStatesOfGeometry:M,releaseStatesOfProgram:E,initAttributes:b,enableAttribute:x,disableUnusedAttributes:S}}function Wgt(n,e,t,r){const s=r.isWebGL2;let i;function o(c){i=c}function a(c,u){n.drawArrays(i,c,u),t.update(u,i,1)}function l(c,u,h){if(h===0)return;let f,d;if(s)f=n,d="drawArraysInstanced";else if(f=e.get("ANGLE_instanced_arrays"),d="drawArraysInstancedANGLE",f===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}f[d](i,c,u,h),t.update(u,i,h)}this.setMode=o,this.render=a,this.renderInstances=l}function Ggt(n,e,t){let r;function s(){if(r!==void 0)return r;const C=e.get("EXT_texture_filter_anisotropic");return C!==null?r=n.getParameter(C.MAX_TEXTURE_MAX_ANISOTROPY_EXT):r=0,r}function i(C){if(C==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";C="mediump"}return C==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=t.logarithmicDepthBuffer===!0,u=n.getParameter(34930),h=n.getParameter(35660),f=n.getParameter(3379),d=n.getParameter(34076),p=n.getParameter(34921),m=n.getParameter(36347),g=n.getParameter(36348),y=n.getParameter(36349),b=h>0,x=o||!!e.get("OES_texture_float"),w=b&&x,S=o?n.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:s,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:u,maxVertexTextures:h,maxTextureSize:f,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:b,floatFragmentTextures:x,floatVertexTextures:w,maxSamples:S}}function Hgt(n){const e=this;let t=null,r=0,s=!1,i=!1;const o=new ah,a=new _l,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,f,d){const p=h.length!==0||f||r!==0||s;return s=f,t=u(h,d,0),r=h.length,p},this.beginShadows=function(){i=!0,u(null)},this.endShadows=function(){i=!1,c()},this.setState=function(h,f,d){const p=h.clippingPlanes,m=h.clipIntersection,g=h.clipShadows,y=n.get(h);if(!s||p===null||p.length===0||i&&!g)i?u(null):c();else{const b=i?0:r,x=b*4;let w=y.clippingState||null;l.value=w,w=u(p,f,x,d);for(let S=0;S!==x;++S)w[S]=t[S];y.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(h,f,d,p){const m=h!==null?h.length:0;let g=null;if(m!==0){if(g=l.value,p!==!0||g===null){const y=d+m*4,b=f.matrixWorldInverse;a.getNormalMatrix(b),(g===null||g.length<y)&&(g=new Float32Array(y));for(let x=0,w=d;x!==m;++x,w+=4)o.copy(h[x]).applyMatrix4(b,a),o.normal.toArray(g,w),g[w+3]=o.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,g}}function jgt(n){let e=new WeakMap;function t(o,a){return a===TA?o.mapping=zC:a===EA&&(o.mapping=BC),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===TA||a===EA)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderList(),u=n.getRenderTarget(),h=new hV(l.height/2);return h.fromEquirectangularTexture(n,o),e.set(o,h),n.setRenderTarget(u),n.setRenderList(c),o.addEventListener("dispose",s),t(h.texture,o.mapping)}else return null}}return o}function s(o){const a=o.target;a.removeEventListener("dispose",s);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:r,dispose:i}}function qgt(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let s;switch(r){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(r)}return e[r]=s,s}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float")},get:function(r){const s=t(r);return s===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),s}}}function Xgt(n,e,t,r){const s={},i=new WeakMap;function o(h){const f=h.target;f.index!==null&&e.remove(f.index);for(const p in f.attributes)e.remove(f.attributes[p]);f.removeEventListener("dispose",o),delete s[f.id];const d=i.get(f);d&&(e.remove(d),i.delete(f)),r.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,t.memory.geometries--}function a(h,f){return s[f.id]===!0||(f.addEventListener("dispose",o),s[f.id]=!0,t.memory.geometries++),f}function l(h){const f=h.attributes;for(const p in f)e.update(f[p],34962);const d=h.morphAttributes;for(const p in d){const m=d[p];for(let g=0,y=m.length;g<y;g++)e.update(m[g],34962)}}function c(h){const f=[],d=h.index,p=h.attributes.position;let m=0;if(d!==null){const b=d.array;m=d.version;for(let x=0,w=b.length;x<w;x+=3){const S=b[x+0],C=b[x+1],k=b[x+2];f.push(S,C,C,k,k,S)}}else{const b=p.array;m=p.version;for(let x=0,w=b.length/3-1;x<w;x+=3){const S=x+0,C=x+1,k=x+2;f.push(S,C,C,k,k,S)}}const g=new(ple(f)>65535?wg:vg)(f,1);g.version=m;const y=i.get(h);y&&e.remove(y),i.set(h,g)}function u(h){const f=i.get(h);if(f){const d=h.index;d!==null&&f.version<d.version&&c(h)}else c(h);return i.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function Kgt(n,e,t,r){const s=r.isWebGL2;let i;function o(f){i=f}let a,l;function c(f){a=f.type,l=f.bytesPerElement}function u(f,d){n.drawElements(i,d,a,f*l),t.update(d,i,1)}function h(f,d,p){if(p===0)return;let m,g;if(s)m=n,g="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[g](i,d,a,f*l,p),t.update(d,i,p)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function Ygt(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(i,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(i/3);break;case 1:t.lines+=a*(i/2);break;case 3:t.lines+=a*(i-1);break;case 2:t.lines+=a*i;break;case 0:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function s(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:r}}function Zgt(n,e){return n[0]-e[0]}function Jgt(n,e){return Math.abs(e[1])-Math.abs(n[1])}function Qgt(n){const e={},t=new Float32Array(8),r=[];for(let i=0;i<8;i++)r[i]=[i,0];function s(i,o,a,l){const c=i.morphTargetInfluences,u=c===void 0?0:c.length;let h=e[o.id];if(h===void 0){h=[];for(let g=0;g<u;g++)h[g]=[g,0];e[o.id]=h}for(let g=0;g<u;g++){const y=h[g];y[0]=g,y[1]=c[g]}h.sort(Jgt);for(let g=0;g<8;g++)g<u&&h[g][1]?(r[g][0]=h[g][0],r[g][1]=h[g][1]):(r[g][0]=Number.MAX_SAFE_INTEGER,r[g][1]=0);r.sort(Zgt);const f=a.morphTargets&&o.morphAttributes.position,d=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let g=0;g<8;g++){const y=r[g],b=y[0],x=y[1];b!==Number.MAX_SAFE_INTEGER&&x?(f&&o.getAttribute("morphTarget"+g)!==f[b]&&o.setAttribute("morphTarget"+g,f[b]),d&&o.getAttribute("morphNormal"+g)!==d[b]&&o.setAttribute("morphNormal"+g,d[b]),t[g]=x,p+=x):(f&&o.hasAttribute("morphTarget"+g)===!0&&o.deleteAttribute("morphTarget"+g),d&&o.hasAttribute("morphNormal"+g)===!0&&o.deleteAttribute("morphNormal"+g),t[g]=0)}const m=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(n,"morphTargetBaseInfluence",m),l.getUniforms().setValue(n,"morphTargetInfluences",t)}return{update:s}}function eyt(n,e,t,r){let s=new WeakMap;function i(l){const c=r.render.frame,u=l.geometry,h=e.get(l,u);return s.get(h)!==c&&(e.update(h),s.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){s=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:i,dispose:o}}function dv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Ui,this.minFilter=Ui,this.wrapR=da,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}dv.prototype=Object.create(Kr.prototype);dv.prototype.constructor=dv;dv.prototype.isDataTexture2DArray=!0;function pv(n=null,e=1,t=1,r=1){Kr.call(this,null),this.image={data:n,width:e,height:t,depth:r},this.magFilter=Ui,this.minFilter=Ui,this.wrapR=da,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}pv.prototype=Object.create(Kr.prototype);pv.prototype.constructor=pv;pv.prototype.isDataTexture3D=!0;const yle=new Kr,tyt=new dv,nyt=new pv,ble=new Th,b8=[],v8=[],w8=new Float32Array(16),x8=new Float32Array(9),_8=new Float32Array(4);function cx(n,e,t){const r=n[0];if(r<=0||r>0)return n;const s=e*t;let i=b8[s];if(i===void 0&&(i=new Float32Array(s),b8[s]=i),e!==0){r.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function Ac(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function Pl(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function vle(n,e){let t=v8[e];t===void 0&&(t=new Int32Array(e),v8[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function ryt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function syt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Ac(t,e))return;n.uniform2fv(this.addr,e),Pl(t,e)}}function iyt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Ac(t,e))return;n.uniform3fv(this.addr,e),Pl(t,e)}}function oyt(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Ac(t,e))return;n.uniform4fv(this.addr,e),Pl(t,e)}}function ayt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Ac(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Pl(t,e)}else{if(Ac(t,r))return;_8.set(r),n.uniformMatrix2fv(this.addr,!1,_8),Pl(t,r)}}function lyt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Ac(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Pl(t,e)}else{if(Ac(t,r))return;x8.set(r),n.uniformMatrix3fv(this.addr,!1,x8),Pl(t,r)}}function cyt(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Ac(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Pl(t,e)}else{if(Ac(t,r))return;w8.set(r),n.uniformMatrix4fv(this.addr,!1,w8),Pl(t,r)}}function uyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.safeSetTexture2D(e||yle,s)}function hyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture2DArray(e||tyt,s)}function fyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture3D(e||nyt,s)}function dyt(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.safeSetTextureCube(e||ble,s)}function pyt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function myt(n,e){const t=this.cache;Ac(t,e)||(n.uniform2iv(this.addr,e),Pl(t,e))}function gyt(n,e){const t=this.cache;Ac(t,e)||(n.uniform3iv(this.addr,e),Pl(t,e))}function yyt(n,e){const t=this.cache;Ac(t,e)||(n.uniform4iv(this.addr,e),Pl(t,e))}function byt(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function vyt(n){switch(n){case 5126:return ryt;case 35664:return syt;case 35665:return iyt;case 35666:return oyt;case 35674:return ayt;case 35675:return lyt;case 35676:return cyt;case 5124:case 35670:return pyt;case 35667:case 35671:return myt;case 35668:case 35672:return gyt;case 35669:case 35673:return yyt;case 5125:return byt;case 35678:case 36198:case 36298:case 36306:case 35682:return uyt;case 35679:case 36299:case 36307:return fyt;case 35680:case 36300:case 36308:case 36293:return dyt;case 36289:case 36303:case 36311:case 36292:return hyt}}function wyt(n,e){n.uniform1fv(this.addr,e)}function xyt(n,e){n.uniform1iv(this.addr,e)}function _yt(n,e){n.uniform2iv(this.addr,e)}function Syt(n,e){n.uniform3iv(this.addr,e)}function Cyt(n,e){n.uniform4iv(this.addr,e)}function kyt(n,e){const t=cx(e,this.size,2);n.uniform2fv(this.addr,t)}function Tyt(n,e){const t=cx(e,this.size,3);n.uniform3fv(this.addr,t)}function Eyt(n,e){const t=cx(e,this.size,4);n.uniform4fv(this.addr,t)}function Iyt(n,e){const t=cx(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Ayt(n,e){const t=cx(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Myt(n,e){const t=cx(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function Nyt(n,e,t){const r=e.length,s=vle(t,r);n.uniform1iv(this.addr,s);for(let i=0;i!==r;++i)t.safeSetTexture2D(e[i]||yle,s[i])}function $yt(n,e,t){const r=e.length,s=vle(t,r);n.uniform1iv(this.addr,s);for(let i=0;i!==r;++i)t.safeSetTextureCube(e[i]||ble,s[i])}function Ryt(n){switch(n){case 5126:return wyt;case 35664:return kyt;case 35665:return Tyt;case 35666:return Eyt;case 35674:return Iyt;case 35675:return Ayt;case 35676:return Myt;case 5124:case 35670:return xyt;case 35667:case 35671:return _yt;case 35668:case 35672:return Syt;case 35669:case 35673:return Cyt;case 35678:case 36198:case 36298:case 36306:case 35682:return Nyt;case 35680:case 36300:case 36308:case 36293:return $yt}}function Pyt(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=vyt(e.type)}function wle(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=Ryt(e.type)}wle.prototype.updateCache=function(n){const e=this.cache;n instanceof Float32Array&&e.length!==n.length&&(this.cache=new Float32Array(n.length)),Pl(e,n)};function xle(n){this.id=n,this.seq=[],this.map={}}xle.prototype.setValue=function(n,e,t){const r=this.seq;for(let s=0,i=r.length;s!==i;++s){const o=r[s];o.setValue(n,e[o.id],t)}};const EP=/(\w+)(\])?(\[|\.)?/g;function S8(n,e){n.seq.push(e),n.map[e.id]=e}function Dyt(n,e,t){const r=n.name,s=r.length;for(EP.lastIndex=0;;){const i=EP.exec(r),o=EP.lastIndex;let a=i[1];const l=i[2]==="]",c=i[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===s){S8(t,c===void 0?new Pyt(a,n,e):new wle(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new xle(a),S8(t,h)),t=h}}}function Zd(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let r=0;r<t;++r){const s=n.getActiveUniform(e,r),i=n.getUniformLocation(e,s.name);Dyt(s,i,this)}}Zd.prototype.setValue=function(n,e,t,r){const s=this.map[e];s!==void 0&&s.setValue(n,t,r)};Zd.prototype.setOptional=function(n,e,t){const r=e[t];r!==void 0&&this.setValue(n,t,r)};Zd.upload=function(n,e,t,r){for(let s=0,i=e.length;s!==i;++s){const o=e[s],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,r)}};Zd.seqWithValue=function(n,e){const t=[];for(let r=0,s=n.length;r!==s;++r){const i=n[r];i.id in e&&t.push(i)}return t};function C8(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}let Oyt=0;function Fyt(n){const e=n.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function _le(n){switch(n){case Sa:return["Linear","( value )"];case UC:return["sRGB","( value )"];case $$:return["RGBE","( value )"];case oV:return["RGBM","( value, 7.0 )"];case aV:return["RGBM","( value, 16.0 )"];case lV:return["RGBD","( value, 256.0 )"];case N$:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case lle:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function k8(n,e,t){const r=n.getShaderParameter(e,35713),s=n.getShaderInfoLog(e).trim();if(r&&s==="")return"";const i=n.getShaderSource(e);return"THREE.WebGLShader: gl.getShaderInfoLog() "+t+`
`+s+Fyt(i)}function o1(n,e){const t=_le(e);return"vec4 "+n+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function Lyt(n,e){const t=_le(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function zyt(n,e){let t;switch(e){case aae:t="Linear";break;case lae:t="Reinhard";break;case cae:t="OptimizedCineon";break;case uae:t="ACESFilmic";break;case hae:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Byt(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(F1).join(`
`)}function Vyt(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function Uyt(n,e){const t={},r=n.getProgramParameter(e,35721);for(let s=0;s<r;s++){const o=n.getActiveAttrib(e,s).name;t[o]=n.getAttribLocation(e,o)}return t}function F1(n){return n!==""}function T8(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function E8(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Wyt=/^[ \t]*#include +<([\w\d./]+)>/gm;function LF(n){return n.replace(Wyt,Gyt)}function Gyt(n,e){const t=Jn[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return LF(t)}const Hyt=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,jyt=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function I8(n){return n.replace(jyt,Sle).replace(Hyt,qyt)}function qyt(n,e,t,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Sle(n,e,t,r)}function Sle(n,e,t,r){let s="";for(let i=parseInt(e);i<parseInt(t);i++)s+=r.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return s}function A8(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Xyt(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===eV?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===zoe?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===_b&&(e="SHADOWMAP_TYPE_VSM"),e}function Kyt(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case zC:case BC:e="ENVMAP_TYPE_CUBE";break;case sx:case VC:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Yyt(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case BC:case VC:e="ENVMAP_MODE_REFRACTION";break}return e}function Zyt(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case LC:e="ENVMAP_BLENDING_MULTIPLY";break;case iae:e="ENVMAP_BLENDING_MIX";break;case oae:e="ENVMAP_BLENDING_ADD";break}return e}function Jyt(n,e,t,r){const s=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=Xyt(t),c=Kyt(t),u=Yyt(t),h=Zyt(t),f=n.gammaFactor>0?n.gammaFactor:1,d=t.isWebGL2?"":Byt(t),p=Vyt(i),m=s.createProgram();let g,y,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(g=[p].filter(F1).join(`
`),g.length>0&&(g+=`
`),y=[d,p].filter(F1).join(`
`),y.length>0&&(y+=`
`)):(g=[A8(t),"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+f,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(F1).join(`
`),y=[d,A8(t),"#define SHADER_NAME "+t.shaderName,p,t.alphaTest?"#define ALPHATEST "+t.alphaTest+(t.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.sheen?"#define USE_SHEEN":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Jm?"#define TONE_MAPPING":"",t.toneMapping!==Jm?Jn.tonemapping_pars_fragment:"",t.toneMapping!==Jm?zyt("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",Jn.encodings_pars_fragment,t.map?o1("mapTexelToLinear",t.mapEncoding):"",t.matcap?o1("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?o1("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?o1("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.lightMap?o1("lightMapTexelToLinear",t.lightMapEncoding):"",Lyt("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(F1).join(`
`)),o=LF(o),o=T8(o,t),o=E8(o,t),a=LF(a),a=T8(a,t),a=E8(a,t),o=I8(o),a=I8(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,g=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+g,y=["#define varying in",t.glslVersion===FF?"":"out highp vec4 pc_fragColor;",t.glslVersion===FF?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const x=b+g+o,w=b+y+a,S=C8(s,35633,x),C=C8(s,35632,w);if(s.attachShader(m,S),s.attachShader(m,C),t.index0AttributeName!==void 0?s.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(m,0,"position"),s.linkProgram(m),n.debug.checkShaderErrors){const M=s.getProgramInfoLog(m).trim(),E=s.getShaderInfoLog(S).trim(),N=s.getShaderInfoLog(C).trim();let O=!0,R=!0;if(s.getProgramParameter(m,35714)===!1){O=!1;const D=k8(s,S,"vertex"),z=k8(s,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",s.getError(),"35715",s.getProgramParameter(m,35715),"gl.getProgramInfoLog",M,D,z)}else M!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",M):(E===""||N==="")&&(R=!1);R&&(this.diagnostics={runnable:O,programLog:M,vertexShader:{log:E,prefix:g},fragmentShader:{log:N,prefix:y}})}s.deleteShader(S),s.deleteShader(C);let k;this.getUniforms=function(){return k===void 0&&(k=new Zd(s,m)),k};let A;return this.getAttributes=function(){return A===void 0&&(A=Uyt(s,m)),A},this.destroy=function(){r.releaseStatesOfProgram(this),s.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=Oyt++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=S,this.fragmentShader=C,this}function Qyt(n,e,t,r,s,i){const o=[],a=r.isWebGL2,l=r.logarithmicDepthBuffer,c=r.floatVertexTextures,u=r.maxVertexUniforms,h=r.vertexTextures;let f=r.precision;const d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function m(C){const A=C.skeleton.bones;if(c)return 1024;{const E=Math.floor((u-20)/4),N=Math.min(E,A.length);return N<A.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+A.length+" bones. This GPU supports "+N+"."),0):N}}function g(C){let k;return C&&C.isTexture?k=C.encoding:C&&C.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),k=C.texture.encoding):k=Sa,k}function y(C,k,A,M,E){const N=M.fog,O=C.isMeshStandardMaterial?M.environment:null,R=e.get(C.envMap||O),D=d[C.type],z=E.isSkinnedMesh?m(E):0;C.precision!==null&&(f=r.getMaxPrecision(C.precision),f!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",f,"instead."));let B,X;if(D){const ge=iu[D];B=ge.vertexShader,X=ge.fragmentShader}else B=C.vertexShader,X=C.fragmentShader;const G=n.getRenderTarget();return{isWebGL2:a,shaderID:D,shaderName:C.type,vertexShader:B,fragmentShader:X,defines:C.defines,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:f,instancing:E.isInstancedMesh===!0,instancingColor:E.isInstancedMesh===!0&&E.instanceColor!==null,supportsVertexTextures:h,outputEncoding:G!==null?g(G.texture):n.outputEncoding,map:!!C.map,mapEncoding:g(C.map),matcap:!!C.matcap,matcapEncoding:g(C.matcap),envMap:!!R,envMapMode:R&&R.mapping,envMapEncoding:g(R),envMapCubeUV:!!R&&(R.mapping===sx||R.mapping===VC),lightMap:!!C.lightMap,lightMapEncoding:g(C.lightMap),aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,emissiveMapEncoding:g(C.emissiveMap),bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===hle,tangentSpaceNormalMap:C.normalMapType===Zy,clearcoatMap:!!C.clearcoatMap,clearcoatRoughnessMap:!!C.clearcoatRoughnessMap,clearcoatNormalMap:!!C.clearcoatNormalMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,alphaMap:!!C.alphaMap,gradientMap:!!C.gradientMap,sheen:!!C.sheen,transmissionMap:!!C.transmissionMap,combine:C.combine,vertexTangents:C.normalMap&&C.vertexTangents,vertexColors:C.vertexColors,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.displacementMap||!!C.transmissionMap,uvsVertexOnly:!(C.map||C.bumpMap||C.normalMap||C.specularMap||C.alphaMap||C.emissiveMap||C.roughnessMap||C.metalnessMap||C.clearcoatNormalMap||C.transmissionMap)&&!!C.displacementMap,fog:!!N,useFog:C.fog,fogExp2:N&&N.isFogExp2,flatShading:C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:l,skinning:C.skinning&&z>0,maxBones:z,useVertexTexture:c,morphTargets:C.morphTargets,morphNormals:C.morphNormals,maxMorphTargets:n.maxMorphTargets,maxMorphNormals:n.maxMorphNormals,numDirLights:k.directional.length,numPointLights:k.point.length,numSpotLights:k.spot.length,numRectAreaLights:k.rectArea.length,numHemiLights:k.hemi.length,numDirLightShadows:k.directionalShadowMap.length,numPointLightShadows:k.pointShadowMap.length,numSpotLightShadows:k.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:C.dithering,shadowMapEnabled:n.shadowMap.enabled&&A.length>0,shadowMapType:n.shadowMap.type,toneMapping:C.toneMapped?n.toneMapping:Jm,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,alphaTest:C.alphaTest,doubleSided:C.side===FC,flipSided:C.side===gi,depthPacking:C.depthPacking!==void 0?C.depthPacking:!1,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||t.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||t.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||t.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function b(C){const k=[];if(C.shaderID?k.push(C.shaderID):(k.push(C.fragmentShader),k.push(C.vertexShader)),C.defines!==void 0)for(const A in C.defines)k.push(A),k.push(C.defines[A]);if(C.isRawShaderMaterial===!1){for(let A=0;A<p.length;A++)k.push(C[p[A]]);k.push(n.outputEncoding),k.push(n.gammaFactor)}return k.push(C.customProgramCacheKey),k.join()}function x(C){const k=d[C.type];let A;if(k){const M=iu[k];A=mle.clone(M.uniforms)}else A=C.uniforms;return A}function w(C,k){let A;for(let M=0,E=o.length;M<E;M++){const N=o[M];if(N.cacheKey===k){A=N,++A.usedTimes;break}}return A===void 0&&(A=new Jyt(n,k,C,s),o.push(A)),A}function S(C){if(--C.usedTimes===0){const k=o.indexOf(C);o[k]=o[o.length-1],o.pop(),C.destroy()}}return{getParameters:y,getProgramCacheKey:b,getUniforms:x,acquireProgram:w,releaseProgram:S,programs:o}}function e0t(){let n=new WeakMap;function e(i){let o=n.get(i);return o===void 0&&(o={},n.set(i,o)),o}function t(i){n.delete(i)}function r(i,o,a){n.get(i)[o]=a}function s(){n=new WeakMap}return{get:e,remove:t,update:r,dispose:s}}function t0t(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.program!==e.program?n.program.id-e.program.id:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function n0t(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function M8(n){const e=[];let t=0;const r=[],s=[],i={id:-1};function o(){t=0,r.length=0,s.length=0}function a(f,d,p,m,g,y){let b=e[t];const x=n.get(p);return b===void 0?(b={id:f.id,object:f,geometry:d,material:p,program:x.program||i,groupOrder:m,renderOrder:f.renderOrder,z:g,group:y},e[t]=b):(b.id=f.id,b.object=f,b.geometry=d,b.material=p,b.program=x.program||i,b.groupOrder=m,b.renderOrder=f.renderOrder,b.z=g,b.group=y),t++,b}function l(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?s:r).push(b)}function c(f,d,p,m,g,y){const b=a(f,d,p,m,g,y);(p.transparent===!0?s:r).unshift(b)}function u(f,d){r.length>1&&r.sort(f||t0t),s.length>1&&s.sort(d||n0t)}function h(){for(let f=t,d=e.length;f<d;f++){const p=e[f];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:r,transparent:s,init:o,push:l,unshift:c,finish:h,sort:u}}function r0t(n){let e=new WeakMap;function t(s,i){const o=e.get(s);let a;return o===void 0?(a=new M8(n),e.set(s,new WeakMap),e.get(s).set(i,a)):(a=o.get(i),a===void 0&&(a=new M8(n),o.set(i,a))),a}function r(){e=new WeakMap}return{get:t,dispose:r}}function s0t(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Q,color:new Ht};break;case"SpotLight":t={position:new Q,direction:new Q,color:new Ht,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Q,color:new Ht,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Q,skyColor:new Ht,groundColor:new Ht};break;case"RectAreaLight":t={color:new Ht,position:new Q,halfWidth:new Q,halfHeight:new Q};break}return n[e.id]=t,t}}}function i0t(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let o0t=0;function a0t(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function l0t(n,e){const t=new s0t,r=i0t(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)s.probe.push(new Q);const i=new Q,o=new Zn,a=new Zn;function l(u){let h=0,f=0,d=0;for(let k=0;k<9;k++)s.probe[k].set(0,0,0);let p=0,m=0,g=0,y=0,b=0,x=0,w=0,S=0;u.sort(a0t);for(let k=0,A=u.length;k<A;k++){const M=u[k],E=M.color,N=M.intensity,O=M.distance,R=M.shadow&&M.shadow.map?M.shadow.map.texture:null;if(M.isAmbientLight)h+=E.r*N,f+=E.g*N,d+=E.b*N;else if(M.isLightProbe)for(let D=0;D<9;D++)s.probe[D].addScaledVector(M.sh.coefficients[D],N);else if(M.isDirectionalLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,s.directionalShadow[p]=B,s.directionalShadowMap[p]=R,s.directionalShadowMatrix[p]=M.shadow.matrix,x++}s.directional[p]=D,p++}else if(M.isSpotLight){const D=t.get(M);if(D.position.setFromMatrixPosition(M.matrixWorld),D.color.copy(E).multiplyScalar(N),D.distance=O,D.coneCos=Math.cos(M.angle),D.penumbraCos=Math.cos(M.angle*(1-M.penumbra)),D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,s.spotShadow[g]=B,s.spotShadowMap[g]=R,s.spotShadowMatrix[g]=M.shadow.matrix,S++}s.spot[g]=D,g++}else if(M.isRectAreaLight){const D=t.get(M);D.color.copy(E).multiplyScalar(N),D.halfWidth.set(M.width*.5,0,0),D.halfHeight.set(0,M.height*.5,0),s.rectArea[y]=D,y++}else if(M.isPointLight){const D=t.get(M);if(D.color.copy(M.color).multiplyScalar(M.intensity),D.distance=M.distance,D.decay=M.decay,M.castShadow){const z=M.shadow,B=r.get(M);B.shadowBias=z.bias,B.shadowNormalBias=z.normalBias,B.shadowRadius=z.radius,B.shadowMapSize=z.mapSize,B.shadowCameraNear=z.camera.near,B.shadowCameraFar=z.camera.far,s.pointShadow[m]=B,s.pointShadowMap[m]=R,s.pointShadowMatrix[m]=M.shadow.matrix,w++}s.point[m]=D,m++}else if(M.isHemisphereLight){const D=t.get(M);D.skyColor.copy(M.color).multiplyScalar(N),D.groundColor.copy(M.groundColor).multiplyScalar(N),s.hemi[b]=D,b++}}y>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Pt.LTC_FLOAT_1,s.rectAreaLTC2=Pt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=Pt.LTC_HALF_1,s.rectAreaLTC2=Pt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=h,s.ambient[1]=f,s.ambient[2]=d;const C=s.hash;(C.directionalLength!==p||C.pointLength!==m||C.spotLength!==g||C.rectAreaLength!==y||C.hemiLength!==b||C.numDirectionalShadows!==x||C.numPointShadows!==w||C.numSpotShadows!==S)&&(s.directional.length=p,s.spot.length=g,s.rectArea.length=y,s.point.length=m,s.hemi.length=b,s.directionalShadow.length=x,s.directionalShadowMap.length=x,s.pointShadow.length=w,s.pointShadowMap.length=w,s.spotShadow.length=S,s.spotShadowMap.length=S,s.directionalShadowMatrix.length=x,s.pointShadowMatrix.length=w,s.spotShadowMatrix.length=S,C.directionalLength=p,C.pointLength=m,C.spotLength=g,C.rectAreaLength=y,C.hemiLength=b,C.numDirectionalShadows=x,C.numPointShadows=w,C.numSpotShadows=S,s.version=o0t++)}function c(u,h){let f=0,d=0,p=0,m=0,g=0;const y=h.matrixWorldInverse;for(let b=0,x=u.length;b<x;b++){const w=u[b];if(w.isDirectionalLight){const S=s.directional[f];S.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(i),S.direction.transformDirection(y),f++}else if(w.isSpotLight){const S=s.spot[p];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),S.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),S.direction.sub(i),S.direction.transformDirection(y),p++}else if(w.isRectAreaLight){const S=s.rectArea[m];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),a.identity(),o.copy(w.matrixWorld),o.premultiply(y),a.extractRotation(o),S.halfWidth.set(w.width*.5,0,0),S.halfHeight.set(0,w.height*.5,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),m++}else if(w.isPointLight){const S=s.point[d];S.position.setFromMatrixPosition(w.matrixWorld),S.position.applyMatrix4(y),d++}else if(w.isHemisphereLight){const S=s.hemi[g];S.direction.setFromMatrixPosition(w.matrixWorld),S.direction.transformDirection(y),S.direction.normalize(),g++}}}return{setup:l,setupView:c,state:s}}function N8(n,e){const t=new l0t(n,e),r=[],s=[];function i(){r.length=0,s.length=0}function o(h){r.push(h)}function a(h){s.push(h)}function l(){t.setup(r)}function c(h){t.setupView(r,h)}return{init:i,state:{lightsArray:r,shadowsArray:s,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function c0t(n,e){let t=new WeakMap;function r(i,o=0){let a;return t.has(i)===!1?(a=new N8(n,e),t.set(i,[]),t.get(i).push(a)):o>=t.get(i).length?(a=new N8(n,e),t.get(i).push(a)):a=t.get(i)[o],a}function s(){t=new WeakMap}return{get:r,dispose:s}}function mp(n){kn.call(this),this.type="MeshDepthMaterial",this.depthPacking=cle,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(n)}mp.prototype=Object.create(kn.prototype);mp.prototype.constructor=mp;mp.prototype.isMeshDepthMaterial=!0;mp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.depthPacking=n.depthPacking,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this};function gp(n){kn.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new Q,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(n)}gp.prototype=Object.create(kn.prototype);gp.prototype.constructor=gp;gp.prototype.isMeshDistanceMaterial=!0;gp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this};var u0t=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,h0t=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function Cle(n,e,t){let r=new GC;const s=new st,i=new st,o=new Hr,a=[],l=[],c={},u={0:gi,1:rx,2:FC},h=new Ca({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new st},radius:{value:4}},vertexShader:h0t,fragmentShader:u0t}),f=h.clone();f.defines.HORIZONTAL_PASS=1;const d=new un;d.setAttribute("position",new Cn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new hs(d,h),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=eV,this.render=function(S,C,k){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||S.length===0)return;const A=n.getRenderTarget(),M=n.getActiveCubeFace(),E=n.getActiveMipmapLevel(),N=n.state;N.setBlending(If),N.buffers.color.setClear(1,1,1,1),N.buffers.depth.setTest(!0),N.setScissorTest(!1);for(let O=0,R=S.length;O<R;O++){const D=S[O],z=D.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",D,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;s.copy(z.mapSize);const B=z.getFrameExtents();if(s.multiply(B),i.copy(z.mapSize),(s.x>t||s.y>t)&&(s.x>t&&(i.x=Math.floor(t/B.x),s.x=i.x*B.x,z.mapSize.x=i.x),s.y>t&&(i.y=Math.floor(t/B.y),s.y=i.y*B.y,z.mapSize.y=i.y)),z.map===null&&!z.isPointLightShadow&&this.type===_b){const G={minFilter:lo,magFilter:lo,format:El};z.map=new Yd(s.x,s.y,G),z.map.texture.name=D.name+".shadowMap",z.mapPass=new Yd(s.x,s.y,G),z.camera.updateProjectionMatrix()}if(z.map===null){const G={minFilter:Ui,magFilter:Ui,format:El};z.map=new Yd(s.x,s.y,G),z.map.texture.name=D.name+".shadowMap",z.camera.updateProjectionMatrix()}n.setRenderTarget(z.map),n.clear();const X=z.getViewportCount();for(let G=0;G<X;G++){const te=z.getViewport(G);o.set(i.x*te.x,i.y*te.y,i.x*te.z,i.y*te.w),N.viewport(o),z.updateMatrices(D,G),r=z.getFrustum(),w(C,k,z.camera,D,this.type)}!z.isPointLightShadow&&this.type===_b&&g(z,k),z.needsUpdate=!1}m.needsUpdate=!1,n.setRenderTarget(A,M,E)};function g(S,C){const k=e.update(p);h.uniforms.shadow_pass.value=S.map.texture,h.uniforms.resolution.value=S.mapSize,h.uniforms.radius.value=S.radius,n.setRenderTarget(S.mapPass),n.clear(),n.renderBufferDirect(C,null,k,h,p,null),f.uniforms.shadow_pass.value=S.mapPass.texture,f.uniforms.resolution.value=S.mapSize,f.uniforms.radius.value=S.radius,n.setRenderTarget(S.map),n.clear(),n.renderBufferDirect(C,null,k,f,p,null)}function y(S,C,k){const A=S<<0|C<<1|k<<2;let M=a[A];return M===void 0&&(M=new mp({depthPacking:ule,morphTargets:S,skinning:C}),a[A]=M),M}function b(S,C,k){const A=S<<0|C<<1|k<<2;let M=l[A];return M===void 0&&(M=new gp({morphTargets:S,skinning:C}),l[A]=M),M}function x(S,C,k,A,M,E,N){let O=null,R=y,D=S.customDepthMaterial;if(A.isPointLight===!0&&(R=b,D=S.customDistanceMaterial),D===void 0){let z=!1;k.morphTargets===!0&&(z=C.morphAttributes&&C.morphAttributes.position&&C.morphAttributes.position.length>0);let B=!1;S.isSkinnedMesh===!0&&(k.skinning===!0?B=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",S));const X=S.isInstancedMesh===!0;O=R(z,B,X)}else O=D;if(n.localClippingEnabled&&k.clipShadows===!0&&k.clippingPlanes.length!==0){const z=O.uuid,B=k.uuid;let X=c[z];X===void 0&&(X={},c[z]=X);let G=X[B];G===void 0&&(G=O.clone(),X[B]=G),O=G}return O.visible=k.visible,O.wireframe=k.wireframe,N===_b?O.side=k.shadowSide!==null?k.shadowSide:k.side:O.side=k.shadowSide!==null?k.shadowSide:u[k.side],O.clipShadows=k.clipShadows,O.clippingPlanes=k.clippingPlanes,O.clipIntersection=k.clipIntersection,O.wireframeLinewidth=k.wireframeLinewidth,O.linewidth=k.linewidth,A.isPointLight===!0&&O.isMeshDistanceMaterial===!0&&(O.referencePosition.setFromMatrixPosition(A.matrixWorld),O.nearDistance=M,O.farDistance=E),O}function w(S,C,k,A,M){if(S.visible===!1)return;if(S.layers.test(C.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&M===_b)&&(!S.frustumCulled||r.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,S.matrixWorld);const O=e.update(S),R=S.material;if(Array.isArray(R)){const D=O.groups;for(let z=0,B=D.length;z<B;z++){const X=D[z],G=R[X.materialIndex];if(G&&G.visible){const te=x(S,O,G,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,te,S,X)}}}else if(R.visible){const D=x(S,O,R,A,k.near,k.far,M);n.renderBufferDirect(k,null,O,D,S,null)}}const N=S.children;for(let O=0,R=N.length;O<R;O++)w(N[O],C,k,A,M)}}function f0t(n,e,t){const r=t.isWebGL2;function s(){let ye=!1;const Ze=new Hr;let yt=null;const Ct=new Hr(0,0,0,0);return{setMask:function(ft){yt!==ft&&!ye&&(n.colorMask(ft,ft,ft,ft),yt=ft)},setLocked:function(ft){ye=ft},setClear:function(ft,ce,nt,St,gt){gt===!0&&(ft*=St,ce*=St,nt*=St),Ze.set(ft,ce,nt,St),Ct.equals(Ze)===!1&&(n.clearColor(ft,ce,nt,St),Ct.copy(Ze))},reset:function(){ye=!1,yt=null,Ct.set(-1,0,0,0)}}}function i(){let ye=!1,Ze=null,yt=null,Ct=null;return{setTest:function(ft){ft?ge(2929):ae(2929)},setMask:function(ft){Ze!==ft&&!ye&&(n.depthMask(ft),Ze=ft)},setFunc:function(ft){if(yt!==ft){if(ft)switch(ft){case Joe:n.depthFunc(512);break;case Qoe:n.depthFunc(519);break;case eae:n.depthFunc(513);break;case kA:n.depthFunc(515);break;case tae:n.depthFunc(514);break;case nae:n.depthFunc(518);break;case rae:n.depthFunc(516);break;case sae:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);yt=ft}},setLocked:function(ft){ye=ft},setClear:function(ft){Ct!==ft&&(n.clearDepth(ft),Ct=ft)},reset:function(){ye=!1,Ze=null,yt=null,Ct=null}}}function o(){let ye=!1,Ze=null,yt=null,Ct=null,ft=null,ce=null,nt=null,St=null,gt=null;return{setTest:function(Gt){ye||(Gt?ge(2960):ae(2960))},setMask:function(Gt){Ze!==Gt&&!ye&&(n.stencilMask(Gt),Ze=Gt)},setFunc:function(Gt,Mn,Cr){(yt!==Gt||Ct!==Mn||ft!==Cr)&&(n.stencilFunc(Gt,Mn,Cr),yt=Gt,Ct=Mn,ft=Cr)},setOp:function(Gt,Mn,Cr){(ce!==Gt||nt!==Mn||St!==Cr)&&(n.stencilOp(Gt,Mn,Cr),ce=Gt,nt=Mn,St=Cr)},setLocked:function(Gt){ye=Gt},setClear:function(Gt){gt!==Gt&&(n.clearStencil(Gt),gt=Gt)},reset:function(){ye=!1,Ze=null,yt=null,Ct=null,ft=null,ce=null,nt=null,St=null,gt=null}}}const a=new s,l=new i,c=new o;let u={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,x=null,w=!1,S=null,C=null,k=null,A=null,M=null;const E=n.getParameter(35661);let N=!1,O=0;const R=n.getParameter(7938);R.indexOf("WebGL")!==-1?(O=parseFloat(/^WebGL (\d)/.exec(R)[1]),N=O>=1):R.indexOf("OpenGL ES")!==-1&&(O=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),N=O>=2);let D=null,z={};const B=new Hr,X=new Hr;function G(ye,Ze,yt){const Ct=new Uint8Array(4),ft=n.createTexture();n.bindTexture(ye,ft),n.texParameteri(ye,10241,9728),n.texParameteri(ye,10240,9728);for(let ce=0;ce<yt;ce++)n.texImage2D(Ze+ce,0,6408,1,1,0,6408,5121,Ct);return ft}const te={};te[3553]=G(3553,3553,1),te[34067]=G(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ge(2929),l.setFunc(kA),Oe(!1),it(xF),ge(2884),be(If);function ge(ye){u[ye]!==!0&&(n.enable(ye),u[ye]=!0)}function ae(ye){u[ye]!==!1&&(n.disable(ye),u[ye]=!1)}function Ne(ye){return h!==ye?(n.useProgram(ye),h=ye,!0):!1}const ke={[Om]:32774,[Voe]:32778,[Uoe]:32779};if(r)ke[kF]=32775,ke[TF]=32776;else{const ye=e.get("EXT_blend_minmax");ye!==null&&(ke[kF]=ye.MIN_EXT,ke[TF]=ye.MAX_EXT)}const De={[Woe]:0,[Goe]:1,[Hoe]:768,[nV]:770,[Zoe]:776,[Koe]:774,[qoe]:772,[joe]:769,[rV]:771,[Yoe]:775,[Xoe]:773};function be(ye,Ze,yt,Ct,ft,ce,nt,St){if(ye===If){f&&(ae(3042),f=!1);return}if(f||(ge(3042),f=!0),ye!==Boe){if(ye!==d||St!==w){if((p!==Om||y!==Om)&&(n.blendEquation(32774),p=Om,y=Om),St)switch(ye){case Pb:n.blendFuncSeparate(1,771,1,771);break;case _F:n.blendFunc(1,1);break;case SF:n.blendFuncSeparate(0,0,769,771);break;case CF:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}else switch(ye){case Pb:n.blendFuncSeparate(770,771,1,771);break;case _F:n.blendFunc(770,1);break;case SF:n.blendFunc(0,769);break;case CF:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",ye);break}m=null,g=null,b=null,x=null,d=ye,w=St}return}ft=ft||Ze,ce=ce||yt,nt=nt||Ct,(Ze!==p||ft!==y)&&(n.blendEquationSeparate(ke[Ze],ke[ft]),p=Ze,y=ft),(yt!==m||Ct!==g||ce!==b||nt!==x)&&(n.blendFuncSeparate(De[yt],De[Ct],De[ce],De[nt]),m=yt,g=Ct,b=ce,x=nt),d=ye,w=null}function Xe(ye,Ze){ye.side===FC?ae(2884):ge(2884);let yt=ye.side===gi;Ze&&(yt=!yt),Oe(yt),ye.blending===Pb&&ye.transparent===!1?be(If):be(ye.blending,ye.blendEquation,ye.blendSrc,ye.blendDst,ye.blendEquationAlpha,ye.blendSrcAlpha,ye.blendDstAlpha,ye.premultipliedAlpha),l.setFunc(ye.depthFunc),l.setTest(ye.depthTest),l.setMask(ye.depthWrite),a.setMask(ye.colorWrite);const Ct=ye.stencilWrite;c.setTest(Ct),Ct&&(c.setMask(ye.stencilWriteMask),c.setFunc(ye.stencilFunc,ye.stencilRef,ye.stencilFuncMask),c.setOp(ye.stencilFail,ye.stencilZFail,ye.stencilZPass)),dt(ye.polygonOffset,ye.polygonOffsetFactor,ye.polygonOffsetUnits)}function Oe(ye){S!==ye&&(ye?n.frontFace(2304):n.frontFace(2305),S=ye)}function it(ye){ye!==Foe?(ge(2884),ye!==C&&(ye===xF?n.cullFace(1029):ye===Loe?n.cullFace(1028):n.cullFace(1032))):ae(2884),C=ye}function We(ye){ye!==k&&(N&&n.lineWidth(ye),k=ye)}function dt(ye,Ze,yt){ye?(ge(32823),(A!==Ze||M!==yt)&&(n.polygonOffset(Ze,yt),A=Ze,M=yt)):ae(32823)}function ct(ye){ye?ge(3089):ae(3089)}function Ve(ye){ye===void 0&&(ye=33984+E-1),D!==ye&&(n.activeTexture(ye),D=ye)}function ze(ye,Ze){D===null&&Ve();let yt=z[D];yt===void 0&&(yt={type:void 0,texture:void 0},z[D]=yt),(yt.type!==ye||yt.texture!==Ze)&&(n.bindTexture(ye,Ze||te[ye]),yt.type=ye,yt.texture=Ze)}function Be(){const ye=z[D];ye!==void 0&&ye.type!==void 0&&(n.bindTexture(ye.type,null),ye.type=void 0,ye.texture=void 0)}function ut(){try{n.compressedTexImage2D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function Ke(){try{n.texImage2D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function ee(){try{n.texImage3D.apply(n,arguments)}catch(ye){console.error("THREE.WebGLState:",ye)}}function J(ye){B.equals(ye)===!1&&(n.scissor(ye.x,ye.y,ye.z,ye.w),B.copy(ye))}function rt(ye){X.equals(ye)===!1&&(n.viewport(ye.x,ye.y,ye.z,ye.w),X.copy(ye))}function Ge(){u={},D=null,z={},h=null,f=null,d=null,p=null,m=null,g=null,y=null,b=null,x=null,w=!1,S=null,C=null,k=null,A=null,M=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:ge,disable:ae,useProgram:Ne,setBlending:be,setMaterial:Xe,setFlipSided:Oe,setCullFace:it,setLineWidth:We,setPolygonOffset:dt,setScissorTest:ct,activeTexture:Ve,bindTexture:ze,unbindTexture:Be,compressedTexImage2D:ut,texImage2D:Ke,texImage3D:ee,scissor:J,viewport:rt,reset:Ge}}function d0t(n,e,t,r,s,i,o){const a=s.isWebGL2,l=s.maxTextures,c=s.maxCubemapSize,u=s.maxTextureSize,h=s.maxSamples,f=new WeakMap;let d,p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(ee,J){return p?new OffscreenCanvas(ee,J):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function g(ee,J,rt,Ge){let ye=1;if((ee.width>Ge||ee.height>Ge)&&(ye=Ge/Math.max(ee.width,ee.height)),ye<1||J===!0)if(typeof HTMLImageElement<"u"&&ee instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ee instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ee instanceof ImageBitmap){const Ze=J?In.floorPowerOfTwo:Math.floor,yt=Ze(ye*ee.width),Ct=Ze(ye*ee.height);d===void 0&&(d=m(yt,Ct));const ft=rt?m(yt,Ct):d;return ft.width=yt,ft.height=Ct,ft.getContext("2d").drawImage(ee,0,0,yt,Ct),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ee.width+"x"+ee.height+") to ("+yt+"x"+Ct+")."),ft}else return"data"in ee&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ee.width+"x"+ee.height+")."),ee;return ee}function y(ee){return In.isPowerOfTwo(ee.width)&&In.isPowerOfTwo(ee.height)}function b(ee){return a?!1:ee.wrapS!==da||ee.wrapT!==da||ee.minFilter!==Ui&&ee.minFilter!==lo}function x(ee,J){return ee.generateMipmaps&&J&&ee.minFilter!==Ui&&ee.minFilter!==lo}function w(ee,J,rt,Ge){n.generateMipmap(ee);const ye=r.get(J);ye.__maxMipLevel=Math.log(Math.max(rt,Ge))*Math.LOG2E}function S(ee,J,rt){if(a===!1)return J;if(ee!==null){if(n[ee]!==void 0)return n[ee];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ee+"'")}let Ge=J;return J===6403&&(rt===5126&&(Ge=33326),rt===5131&&(Ge=33325),rt===5121&&(Ge=33321)),J===6407&&(rt===5126&&(Ge=34837),rt===5131&&(Ge=34843),rt===5121&&(Ge=32849)),J===6408&&(rt===5126&&(Ge=34836),rt===5131&&(Ge=34842),rt===5121&&(Ge=32856)),(Ge===33325||Ge===33326||Ge===34842||Ge===34836)&&e.get("EXT_color_buffer_float"),Ge}function C(ee){return ee===Ui||ee===IA||ee===AA?9728:9729}function k(ee){const J=ee.target;J.removeEventListener("dispose",k),M(J),J.isVideoTexture&&f.delete(J),o.memory.textures--}function A(ee){const J=ee.target;J.removeEventListener("dispose",A),E(J),o.memory.textures--}function M(ee){const J=r.get(ee);J.__webglInit!==void 0&&(n.deleteTexture(J.__webglTexture),r.remove(ee))}function E(ee){const J=r.get(ee),rt=r.get(ee.texture);if(ee){if(rt.__webglTexture!==void 0&&n.deleteTexture(rt.__webglTexture),ee.depthTexture&&ee.depthTexture.dispose(),ee.isWebGLCubeRenderTarget)for(let Ge=0;Ge<6;Ge++)n.deleteFramebuffer(J.__webglFramebuffer[Ge]),J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer[Ge]);else n.deleteFramebuffer(J.__webglFramebuffer),J.__webglDepthbuffer&&n.deleteRenderbuffer(J.__webglDepthbuffer),J.__webglMultisampledFramebuffer&&n.deleteFramebuffer(J.__webglMultisampledFramebuffer),J.__webglColorRenderbuffer&&n.deleteRenderbuffer(J.__webglColorRenderbuffer),J.__webglDepthRenderbuffer&&n.deleteRenderbuffer(J.__webglDepthRenderbuffer);r.remove(ee.texture),r.remove(ee)}}let N=0;function O(){N=0}function R(){const ee=N;return ee>=l&&console.warn("THREE.WebGLTextures: Trying to use "+ee+" texture units while this GPU supports only "+l),N+=1,ee}function D(ee,J){const rt=r.get(ee);if(ee.isVideoTexture&&Ve(ee),ee.version>0&&rt.__version!==ee.version){const Ge=ee.image;if(Ge===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(Ge.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Ne(rt,ee,J);return}}t.activeTexture(33984+J),t.bindTexture(3553,rt.__webglTexture)}function z(ee,J){const rt=r.get(ee);if(ee.version>0&&rt.__version!==ee.version){Ne(rt,ee,J);return}t.activeTexture(33984+J),t.bindTexture(35866,rt.__webglTexture)}function B(ee,J){const rt=r.get(ee);if(ee.version>0&&rt.__version!==ee.version){Ne(rt,ee,J);return}t.activeTexture(33984+J),t.bindTexture(32879,rt.__webglTexture)}function X(ee,J){const rt=r.get(ee);if(ee.version>0&&rt.__version!==ee.version){ke(rt,ee,J);return}t.activeTexture(33984+J),t.bindTexture(34067,rt.__webglTexture)}const G={[iS]:10497,[da]:33071,[oS]:33648},te={[Ui]:9728,[IA]:9984,[AA]:9986,[lo]:9729,[sV]:9985,[ix]:9987};function ge(ee,J,rt){rt?(n.texParameteri(ee,10242,G[J.wrapS]),n.texParameteri(ee,10243,G[J.wrapT]),(ee===32879||ee===35866)&&n.texParameteri(ee,32882,G[J.wrapR]),n.texParameteri(ee,10240,te[J.magFilter]),n.texParameteri(ee,10241,te[J.minFilter])):(n.texParameteri(ee,10242,33071),n.texParameteri(ee,10243,33071),(ee===32879||ee===35866)&&n.texParameteri(ee,32882,33071),(J.wrapS!==da||J.wrapT!==da)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(ee,10240,C(J.magFilter)),n.texParameteri(ee,10241,C(J.minFilter)),J.minFilter!==Ui&&J.minFilter!==lo&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const Ge=e.get("EXT_texture_filter_anisotropic");if(Ge){if(J.type===Sf&&e.get("OES_texture_float_linear")===null||J.type===lS&&(a||e.get("OES_texture_half_float_linear"))===null)return;(J.anisotropy>1||r.get(J).__currentAnisotropy)&&(n.texParameterf(ee,Ge.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(J.anisotropy,s.getMaxAnisotropy())),r.get(J).__currentAnisotropy=J.anisotropy)}}function ae(ee,J){ee.__webglInit===void 0&&(ee.__webglInit=!0,J.addEventListener("dispose",k),ee.__webglTexture=n.createTexture(),o.memory.textures++)}function Ne(ee,J,rt){let Ge=3553;J.isDataTexture2DArray&&(Ge=35866),J.isDataTexture3D&&(Ge=32879),ae(ee,J),t.activeTexture(33984+rt),t.bindTexture(Ge,ee.__webglTexture),n.pixelStorei(37440,J.flipY),n.pixelStorei(37441,J.premultiplyAlpha),n.pixelStorei(3317,J.unpackAlignment);const ye=b(J)&&y(J.image)===!1,Ze=g(J.image,ye,!1,u),yt=y(Ze)||a,Ct=i.convert(J.format);let ft=i.convert(J.type),ce=S(J.internalFormat,Ct,ft);ge(Ge,J,yt);let nt;const St=J.mipmaps;if(J.isDepthTexture)ce=6402,a?J.type===Sf?ce=36012:J.type===o_?ce=33190:J.type===Db?ce=35056:ce=33189:J.type===Sf&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),J.format===Qm&&ce===6402&&J.type!==aS&&J.type!==o_&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),J.type=aS,ft=i.convert(J.type)),J.format===hv&&ce===6402&&(ce=34041,J.type!==Db&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),J.type=Db,ft=i.convert(J.type))),t.texImage2D(3553,0,ce,Ze.width,Ze.height,0,Ct,ft,null);else if(J.isDataTexture)if(St.length>0&&yt){for(let gt=0,Gt=St.length;gt<Gt;gt++)nt=St[gt],t.texImage2D(3553,gt,ce,nt.width,nt.height,0,Ct,ft,nt.data);J.generateMipmaps=!1,ee.__maxMipLevel=St.length-1}else t.texImage2D(3553,0,ce,Ze.width,Ze.height,0,Ct,ft,Ze.data),ee.__maxMipLevel=0;else if(J.isCompressedTexture){for(let gt=0,Gt=St.length;gt<Gt;gt++)nt=St[gt],J.format!==El&&J.format!==Kd?Ct!==null?t.compressedTexImage2D(3553,gt,ce,nt.width,nt.height,0,nt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,gt,ce,nt.width,nt.height,0,Ct,ft,nt.data);ee.__maxMipLevel=St.length-1}else if(J.isDataTexture2DArray)t.texImage3D(35866,0,ce,Ze.width,Ze.height,Ze.depth,0,Ct,ft,Ze.data),ee.__maxMipLevel=0;else if(J.isDataTexture3D)t.texImage3D(32879,0,ce,Ze.width,Ze.height,Ze.depth,0,Ct,ft,Ze.data),ee.__maxMipLevel=0;else if(St.length>0&&yt){for(let gt=0,Gt=St.length;gt<Gt;gt++)nt=St[gt],t.texImage2D(3553,gt,ce,Ct,ft,nt);J.generateMipmaps=!1,ee.__maxMipLevel=St.length-1}else t.texImage2D(3553,0,ce,Ct,ft,Ze),ee.__maxMipLevel=0;x(J,yt)&&w(Ge,J,Ze.width,Ze.height),ee.__version=J.version,J.onUpdate&&J.onUpdate(J)}function ke(ee,J,rt){if(J.image.length!==6)return;ae(ee,J),t.activeTexture(33984+rt),t.bindTexture(34067,ee.__webglTexture),n.pixelStorei(37440,J.flipY),n.pixelStorei(37441,J.premultiplyAlpha),n.pixelStorei(3317,J.unpackAlignment);const Ge=J&&(J.isCompressedTexture||J.image[0].isCompressedTexture),ye=J.image[0]&&J.image[0].isDataTexture,Ze=[];for(let gt=0;gt<6;gt++)!Ge&&!ye?Ze[gt]=g(J.image[gt],!1,!0,c):Ze[gt]=ye?J.image[gt].image:J.image[gt];const yt=Ze[0],Ct=y(yt)||a,ft=i.convert(J.format),ce=i.convert(J.type),nt=S(J.internalFormat,ft,ce);ge(34067,J,Ct);let St;if(Ge){for(let gt=0;gt<6;gt++){St=Ze[gt].mipmaps;for(let Gt=0;Gt<St.length;Gt++){const Mn=St[Gt];J.format!==El&&J.format!==Kd?ft!==null?t.compressedTexImage2D(34069+gt,Gt,nt,Mn.width,Mn.height,0,Mn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+gt,Gt,nt,Mn.width,Mn.height,0,ft,ce,Mn.data)}}ee.__maxMipLevel=St.length-1}else{St=J.mipmaps;for(let gt=0;gt<6;gt++)if(ye){t.texImage2D(34069+gt,0,nt,Ze[gt].width,Ze[gt].height,0,ft,ce,Ze[gt].data);for(let Gt=0;Gt<St.length;Gt++){const Cr=St[Gt].image[gt].image;t.texImage2D(34069+gt,Gt+1,nt,Cr.width,Cr.height,0,ft,ce,Cr.data)}}else{t.texImage2D(34069+gt,0,nt,ft,ce,Ze[gt]);for(let Gt=0;Gt<St.length;Gt++){const Mn=St[Gt];t.texImage2D(34069+gt,Gt+1,nt,ft,ce,Mn.image[gt])}}ee.__maxMipLevel=St.length}x(J,Ct)&&w(34067,J,yt.width,yt.height),ee.__version=J.version,J.onUpdate&&J.onUpdate(J)}function De(ee,J,rt,Ge){const ye=i.convert(J.texture.format),Ze=i.convert(J.texture.type),yt=S(J.texture.internalFormat,ye,Ze);t.texImage2D(Ge,0,yt,J.width,J.height,0,ye,Ze,null),n.bindFramebuffer(36160,ee),n.framebufferTexture2D(36160,rt,Ge,r.get(J.texture).__webglTexture,0),n.bindFramebuffer(36160,null)}function be(ee,J,rt){if(n.bindRenderbuffer(36161,ee),J.depthBuffer&&!J.stencilBuffer){let Ge=33189;if(rt){const ye=J.depthTexture;ye&&ye.isDepthTexture&&(ye.type===Sf?Ge=36012:ye.type===o_&&(Ge=33190));const Ze=ct(J);n.renderbufferStorageMultisample(36161,Ze,Ge,J.width,J.height)}else n.renderbufferStorage(36161,Ge,J.width,J.height);n.framebufferRenderbuffer(36160,36096,36161,ee)}else if(J.depthBuffer&&J.stencilBuffer){if(rt){const Ge=ct(J);n.renderbufferStorageMultisample(36161,Ge,35056,J.width,J.height)}else n.renderbufferStorage(36161,34041,J.width,J.height);n.framebufferRenderbuffer(36160,33306,36161,ee)}else{const Ge=i.convert(J.texture.format),ye=i.convert(J.texture.type),Ze=S(J.texture.internalFormat,Ge,ye);if(rt){const yt=ct(J);n.renderbufferStorageMultisample(36161,yt,Ze,J.width,J.height)}else n.renderbufferStorage(36161,Ze,J.width,J.height)}n.bindRenderbuffer(36161,null)}function Xe(ee,J){if(J&&J.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(36160,ee),!(J.depthTexture&&J.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(J.depthTexture).__webglTexture||J.depthTexture.image.width!==J.width||J.depthTexture.image.height!==J.height)&&(J.depthTexture.image.width=J.width,J.depthTexture.image.height=J.height,J.depthTexture.needsUpdate=!0),D(J.depthTexture,0);const Ge=r.get(J.depthTexture).__webglTexture;if(J.depthTexture.format===Qm)n.framebufferTexture2D(36160,36096,3553,Ge,0);else if(J.depthTexture.format===hv)n.framebufferTexture2D(36160,33306,3553,Ge,0);else throw new Error("Unknown depthTexture format")}function Oe(ee){const J=r.get(ee),rt=ee.isWebGLCubeRenderTarget===!0;if(ee.depthTexture){if(rt)throw new Error("target.depthTexture not supported in Cube render targets");Xe(J.__webglFramebuffer,ee)}else if(rt){J.__webglDepthbuffer=[];for(let Ge=0;Ge<6;Ge++)n.bindFramebuffer(36160,J.__webglFramebuffer[Ge]),J.__webglDepthbuffer[Ge]=n.createRenderbuffer(),be(J.__webglDepthbuffer[Ge],ee,!1)}else n.bindFramebuffer(36160,J.__webglFramebuffer),J.__webglDepthbuffer=n.createRenderbuffer(),be(J.__webglDepthbuffer,ee,!1);n.bindFramebuffer(36160,null)}function it(ee){const J=r.get(ee),rt=r.get(ee.texture);ee.addEventListener("dispose",A),rt.__webglTexture=n.createTexture(),o.memory.textures++;const Ge=ee.isWebGLCubeRenderTarget===!0,ye=ee.isWebGLMultisampleRenderTarget===!0,Ze=y(ee)||a;if(a&&ee.texture.format===Kd&&(ee.texture.type===Sf||ee.texture.type===lS)&&(ee.texture.format=El,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),Ge){J.__webglFramebuffer=[];for(let yt=0;yt<6;yt++)J.__webglFramebuffer[yt]=n.createFramebuffer()}else if(J.__webglFramebuffer=n.createFramebuffer(),ye)if(a){J.__webglMultisampledFramebuffer=n.createFramebuffer(),J.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,J.__webglColorRenderbuffer);const yt=i.convert(ee.texture.format),Ct=i.convert(ee.texture.type),ft=S(ee.texture.internalFormat,yt,Ct),ce=ct(ee);n.renderbufferStorageMultisample(36161,ce,ft,ee.width,ee.height),n.bindFramebuffer(36160,J.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,J.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),ee.depthBuffer&&(J.__webglDepthRenderbuffer=n.createRenderbuffer(),be(J.__webglDepthRenderbuffer,ee,!0)),n.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(Ge){t.bindTexture(34067,rt.__webglTexture),ge(34067,ee.texture,Ze);for(let yt=0;yt<6;yt++)De(J.__webglFramebuffer[yt],ee,36064,34069+yt);x(ee.texture,Ze)&&w(34067,ee.texture,ee.width,ee.height),t.bindTexture(34067,null)}else t.bindTexture(3553,rt.__webglTexture),ge(3553,ee.texture,Ze),De(J.__webglFramebuffer,ee,36064,3553),x(ee.texture,Ze)&&w(3553,ee.texture,ee.width,ee.height),t.bindTexture(3553,null);ee.depthBuffer&&Oe(ee)}function We(ee){const J=ee.texture,rt=y(ee)||a;if(x(J,rt)){const Ge=ee.isWebGLCubeRenderTarget?34067:3553,ye=r.get(J).__webglTexture;t.bindTexture(Ge,ye),w(Ge,J,ee.width,ee.height),t.bindTexture(Ge,null)}}function dt(ee){if(ee.isWebGLMultisampleRenderTarget)if(a){const J=r.get(ee);n.bindFramebuffer(36008,J.__webglMultisampledFramebuffer),n.bindFramebuffer(36009,J.__webglFramebuffer);const rt=ee.width,Ge=ee.height;let ye=16384;ee.depthBuffer&&(ye|=256),ee.stencilBuffer&&(ye|=1024),n.blitFramebuffer(0,0,rt,Ge,0,0,rt,Ge,ye,9728),n.bindFramebuffer(36160,J.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function ct(ee){return a&&ee.isWebGLMultisampleRenderTarget?Math.min(h,ee.samples):0}function Ve(ee){const J=o.render.frame;f.get(ee)!==J&&(f.set(ee,J),ee.update())}let ze=!1,Be=!1;function ut(ee,J){ee&&ee.isWebGLRenderTarget&&(ze===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),ze=!0),ee=ee.texture),D(ee,J)}function Ke(ee,J){ee&&ee.isWebGLCubeRenderTarget&&(Be===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Be=!0),ee=ee.texture),X(ee,J)}this.allocateTextureUnit=R,this.resetTextureUnits=O,this.setTexture2D=D,this.setTexture2DArray=z,this.setTexture3D=B,this.setTextureCube=X,this.setupRenderTarget=it,this.updateRenderTargetMipmap=We,this.updateMultisampleRenderTarget=dt,this.safeSetTexture2D=ut,this.safeSetTextureCube=Ke}function kle(n,e,t){const r=t.isWebGL2;function s(i){let o;if(i===ox)return 5121;if(i===mae)return 32819;if(i===gae)return 32820;if(i===yae)return 33635;if(i===fae)return 5120;if(i===dae)return 5122;if(i===aS)return 5123;if(i===pae)return 5124;if(i===o_)return 5125;if(i===Sf)return 5126;if(i===lS)return r?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(i===bae)return 6406;if(i===Kd)return 6407;if(i===El)return 6408;if(i===vae)return 6409;if(i===wae)return 6410;if(i===Qm)return 6402;if(i===hv)return 34041;if(i===_ae)return 6403;if(i===Sae)return 36244;if(i===Cae)return 33319;if(i===kae)return 33320;if(i===Tae)return 36248;if(i===Eae)return 36249;if(i===EF||i===IF||i===AF||i===MF)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(i===EF)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===IF)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===AF)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===MF)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===NF||i===$F||i===RF||i===PF)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(i===NF)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===$F)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===RF)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===PF)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===Iae)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===DF||i===OF)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(i===DF)return o.COMPRESSED_RGB8_ETC2;if(i===OF)return o.COMPRESSED_RGBA8_ETC2_EAC}if(i===Aae||i===Mae||i===Nae||i===$ae||i===Rae||i===Pae||i===Dae||i===Oae||i===Fae||i===Lae||i===zae||i===Bae||i===Vae||i===Uae||i===Gae||i===Hae||i===jae||i===qae||i===Xae||i===Kae||i===Yae||i===Zae||i===Jae||i===Qae||i===ele||i===tle||i===nle||i===rle)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?i:null;if(i===Wae)return o=e.get("EXT_texture_compression_bptc"),o!==null?i:null;if(i===Db)return r?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:s}}function MA(n=[]){Si.call(this),this.cameras=n}MA.prototype=Object.assign(Object.create(Si.prototype),{constructor:MA,isArrayCamera:!0});function zd(){rn.call(this),this.type="Group"}zd.prototype=Object.assign(Object.create(rn.prototype),{constructor:zd,isGroup:!0});function l_(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(l_.prototype,{constructor:l_,getHandSpace:function(){return this._hand===null&&(this._hand=new zd,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new zd,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new zd,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(n){return this._targetRay!==null&&this._targetRay.dispatchEvent(n),this._grip!==null&&this._grip.dispatchEvent(n),this._hand!==null&&this._hand.dispatchEvent(n),this},disconnect:function(n){return this.dispatchEvent({type:"disconnected",data:n}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(n,e,t){let r=null,s=null,i=null;const o=this._targetRay,a=this._grip,l=this._hand;if(n&&e.session.visibilityState!=="visible-blurred")if(l&&n.hand){i=!0;for(const p of n.hand.values()){const m=e.getJointPose(p,t);if(l.joints[p.jointName]===void 0){const y=new zd;y.matrixAutoUpdate=!1,y.visible=!1,l.joints[p.jointName]=y,l.add(y)}const g=l.joints[p.jointName];m!==null&&(g.matrix.fromArray(m.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=m.radius),g.visible=m!==null}const c=l.joints["index-finger-tip"],u=l.joints["thumb-tip"],h=c.position.distanceTo(u.position),f=.02,d=.005;l.inputState.pinching&&h>f+d?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!l.inputState.pinching&&h<=f-d&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else o!==null&&(r=e.getPose(n.targetRaySpace,t),r!==null&&(o.matrix.fromArray(r.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&n.gripSpace&&(s=e.getPose(n.gripSpace,t),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=r!==null),a!==null&&(a.visible=s!==null),l!==null&&(l.visible=i!==null),this}});function Tle(n,e){const t=this;let r=null,s=1,i=null,o="local-floor",a=null;const l=[],c=new Map,u=new Si;u.layers.enable(1),u.viewport=new Hr;const h=new Si;h.layers.enable(2),h.viewport=new Hr;const f=[u,h],d=new MA;d.layers.enable(1),d.layers.enable(2);let p=null,m=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(E){let N=l[E];return N===void 0&&(N=new l_,l[E]=N),N.getTargetRaySpace()},this.getControllerGrip=function(E){let N=l[E];return N===void 0&&(N=new l_,l[E]=N),N.getGripSpace()},this.getHand=function(E){let N=l[E];return N===void 0&&(N=new l_,l[E]=N),N.getHandSpace()};function g(E){const N=c.get(E.inputSource);N&&N.dispatchEvent({type:E.type,data:E.inputSource})}function y(){c.forEach(function(E,N){E.disconnect(N)}),c.clear(),p=null,m=null,n.setFramebuffer(null),n.setRenderTarget(n.getRenderTarget()),M.stop(),t.isPresenting=!1,t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(E){s=E,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(E){o=E,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i},this.getSession=function(){return r},this.setSession=async function(E){if(r=E,r!==null){r.addEventListener("select",g),r.addEventListener("selectstart",g),r.addEventListener("selectend",g),r.addEventListener("squeeze",g),r.addEventListener("squeezestart",g),r.addEventListener("squeezeend",g),r.addEventListener("end",y),r.addEventListener("inputsourceschange",b);const N=e.getContextAttributes();N.xrCompatible!==!0&&await e.makeXRCompatible();const O={antialias:N.antialias,alpha:N.alpha,depth:N.depth,stencil:N.stencil,framebufferScaleFactor:s},R=new XRWebGLLayer(r,e,O);r.updateRenderState({baseLayer:R}),i=await r.requestReferenceSpace(o),M.setContext(r),M.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}};function b(E){const N=r.inputSources;for(let O=0;O<l.length;O++)c.set(N[O],l[O]);for(let O=0;O<E.removed.length;O++){const R=E.removed[O],D=c.get(R);D&&(D.dispatchEvent({type:"disconnected",data:R}),c.delete(R))}for(let O=0;O<E.added.length;O++){const R=E.added[O],D=c.get(R);D&&D.dispatchEvent({type:"connected",data:R})}}const x=new Q,w=new Q;function S(E,N,O){x.setFromMatrixPosition(N.matrixWorld),w.setFromMatrixPosition(O.matrixWorld);const R=x.distanceTo(w),D=N.projectionMatrix.elements,z=O.projectionMatrix.elements,B=D[14]/(D[10]-1),X=D[14]/(D[10]+1),G=(D[9]+1)/D[5],te=(D[9]-1)/D[5],ge=(D[8]-1)/D[0],ae=(z[8]+1)/z[0],Ne=B*ge,ke=B*ae,De=R/(-ge+ae),be=De*-ge;N.matrixWorld.decompose(E.position,E.quaternion,E.scale),E.translateX(be),E.translateZ(De),E.matrixWorld.compose(E.position,E.quaternion,E.scale),E.matrixWorldInverse.copy(E.matrixWorld).invert();const Xe=B+De,Oe=X+De,it=Ne-be,We=ke+(R-be),dt=G*X/Oe*Xe,ct=te*X/Oe*Xe;E.projectionMatrix.makePerspective(it,We,dt,ct,Xe,Oe)}function C(E,N){N===null?E.matrixWorld.copy(E.matrix):E.matrixWorld.multiplyMatrices(N.matrixWorld,E.matrix),E.matrixWorldInverse.copy(E.matrixWorld).invert()}this.getCamera=function(E){d.near=h.near=u.near=E.near,d.far=h.far=u.far=E.far,(p!==d.near||m!==d.far)&&(r.updateRenderState({depthNear:d.near,depthFar:d.far}),p=d.near,m=d.far);const N=E.parent,O=d.cameras;C(d,N);for(let D=0;D<O.length;D++)C(O[D],N);E.matrixWorld.copy(d.matrixWorld),E.matrix.copy(d.matrix),E.matrix.decompose(E.position,E.quaternion,E.scale);const R=E.children;for(let D=0,z=R.length;D<z;D++)R[D].updateMatrixWorld(!0);return O.length===2?S(d,u,h):d.projectionMatrix.copy(u.projectionMatrix),d};let k=null;function A(E,N){if(a=N.getViewerPose(i),a!==null){const R=a.views,D=r.renderState.baseLayer;n.setFramebuffer(D.framebuffer);let z=!1;R.length!==d.cameras.length&&(d.cameras.length=0,z=!0);for(let B=0;B<R.length;B++){const X=R[B],G=D.getViewport(X),te=f[B];te.matrix.fromArray(X.transform.matrix),te.projectionMatrix.fromArray(X.projectionMatrix),te.viewport.set(G.x,G.y,G.width,G.height),B===0&&d.matrix.copy(te.matrix),z===!0&&d.cameras.push(te)}}const O=r.inputSources;for(let R=0;R<l.length;R++){const D=l[R],z=O[R];D.update(z,N,i)}k&&k(E,N)}const M=new gle;M.setAnimationLoop(A),this.setAnimationLoop=function(E){k=E},this.dispose=function(){}}Object.assign(Tle.prototype,Uu.prototype);function p0t(n){function e(y,b){y.fogColor.value.copy(b.color),b.isFog?(y.fogNear.value=b.near,y.fogFar.value=b.far):b.isFogExp2&&(y.fogDensity.value=b.density)}function t(y,b,x,w){b.isMeshBasicMaterial?r(y,b):b.isMeshLambertMaterial?(r(y,b),l(y,b)):b.isMeshToonMaterial?(r(y,b),u(y,b)):b.isMeshPhongMaterial?(r(y,b),c(y,b)):b.isMeshStandardMaterial?(r(y,b),b.isMeshPhysicalMaterial?f(y,b):h(y,b)):b.isMeshMatcapMaterial?(r(y,b),d(y,b)):b.isMeshDepthMaterial?(r(y,b),p(y,b)):b.isMeshDistanceMaterial?(r(y,b),m(y,b)):b.isMeshNormalMaterial?(r(y,b),g(y,b)):b.isLineBasicMaterial?(s(y,b),b.isLineDashedMaterial&&i(y,b)):b.isPointsMaterial?o(y,b,x,w):b.isSpriteMaterial?a(y,b):b.isShadowMaterial?(y.color.value.copy(b.color),y.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function r(y,b){y.opacity.value=b.opacity,b.color&&y.diffuse.value.copy(b.color),b.emissive&&y.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap),b.specularMap&&(y.specularMap.value=b.specularMap);const x=n.get(b).envMap;if(x){y.envMap.value=x,y.flipEnvMap.value=x.isCubeTexture&&x._needsFlipEnvMap?-1:1,y.reflectivity.value=b.reflectivity,y.refractionRatio.value=b.refractionRatio;const C=n.get(x).__maxMipLevel;C!==void 0&&(y.maxMipLevel.value=C)}b.lightMap&&(y.lightMap.value=b.lightMap,y.lightMapIntensity.value=b.lightMapIntensity),b.aoMap&&(y.aoMap.value=b.aoMap,y.aoMapIntensity.value=b.aoMapIntensity);let w;b.map?w=b.map:b.specularMap?w=b.specularMap:b.displacementMap?w=b.displacementMap:b.normalMap?w=b.normalMap:b.bumpMap?w=b.bumpMap:b.roughnessMap?w=b.roughnessMap:b.metalnessMap?w=b.metalnessMap:b.alphaMap?w=b.alphaMap:b.emissiveMap?w=b.emissiveMap:b.clearcoatMap?w=b.clearcoatMap:b.clearcoatNormalMap?w=b.clearcoatNormalMap:b.clearcoatRoughnessMap&&(w=b.clearcoatRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),y.uvTransform.value.copy(w.matrix));let S;b.aoMap?S=b.aoMap:b.lightMap&&(S=b.lightMap),S!==void 0&&(S.isWebGLRenderTarget&&(S=S.texture),S.matrixAutoUpdate===!0&&S.updateMatrix(),y.uv2Transform.value.copy(S.matrix))}function s(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity}function i(y,b){y.dashSize.value=b.dashSize,y.totalSize.value=b.dashSize+b.gapSize,y.scale.value=b.scale}function o(y,b,x,w){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.size.value=b.size*x,y.scale.value=w*.5,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let S;b.map?S=b.map:b.alphaMap&&(S=b.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),y.uvTransform.value.copy(S.matrix))}function a(y,b){y.diffuse.value.copy(b.color),y.opacity.value=b.opacity,y.rotation.value=b.rotation,b.map&&(y.map.value=b.map),b.alphaMap&&(y.alphaMap.value=b.alphaMap);let x;b.map?x=b.map:b.alphaMap&&(x=b.alphaMap),x!==void 0&&(x.matrixAutoUpdate===!0&&x.updateMatrix(),y.uvTransform.value.copy(x.matrix))}function l(y,b){b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap)}function c(y,b){y.specular.value.copy(b.specular),y.shininess.value=Math.max(b.shininess,1e-4),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function u(y,b){b.gradientMap&&(y.gradientMap.value=b.gradientMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function h(y,b){y.roughness.value=b.roughness,y.metalness.value=b.metalness,b.roughnessMap&&(y.roughnessMap.value=b.roughnessMap),b.metalnessMap&&(y.metalnessMap.value=b.metalnessMap),b.emissiveMap&&(y.emissiveMap.value=b.emissiveMap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),n.get(b).envMap&&(y.envMapIntensity.value=b.envMapIntensity)}function f(y,b){h(y,b),y.reflectivity.value=b.reflectivity,y.clearcoat.value=b.clearcoat,y.clearcoatRoughness.value=b.clearcoatRoughness,b.sheen&&y.sheen.value.copy(b.sheen),b.clearcoatMap&&(y.clearcoatMap.value=b.clearcoatMap),b.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap),b.clearcoatNormalMap&&(y.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),y.clearcoatNormalMap.value=b.clearcoatNormalMap,b.side===gi&&y.clearcoatNormalScale.value.negate()),y.transmission.value=b.transmission,b.transmissionMap&&(y.transmissionMap.value=b.transmissionMap)}function d(y,b){b.matcap&&(y.matcap.value=b.matcap),b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function p(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}function m(y,b){b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias),y.referencePosition.value.copy(b.referencePosition),y.nearDistance.value=b.nearDistance,y.farDistance.value=b.farDistance}function g(y,b){b.bumpMap&&(y.bumpMap.value=b.bumpMap,y.bumpScale.value=b.bumpScale,b.side===gi&&(y.bumpScale.value*=-1)),b.normalMap&&(y.normalMap.value=b.normalMap,y.normalScale.value.copy(b.normalScale),b.side===gi&&y.normalScale.value.negate()),b.displacementMap&&(y.displacementMap.value=b.displacementMap,y.displacementScale.value=b.displacementScale,y.displacementBias.value=b.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function m0t(){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return n.style.display="block",n}function HC(n){n=n||{};const e=n.canvas!==void 0?n.canvas:m0t(),t=n.context!==void 0?n.context:null,r=n.alpha!==void 0?n.alpha:!1,s=n.depth!==void 0?n.depth:!0,i=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",u=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h=null,f=null;const d=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Sa,this.physicallyCorrectLights=!1,this.toneMapping=Jm,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let m=!1,g=null,y=0,b=0,x=null,w=null,S=-1,C=null;const k=new Hr,A=new Hr;let M=null,E=e.width,N=e.height,O=1,R=null,D=null;const z=new Hr(0,0,E,N),B=new Hr(0,0,E,N);let X=!1;const G=new GC;let te=!1,ge=!1;const ae=new Zn,Ne=new Q,ke={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function De(){return x===null?O:1}let be=t;function Xe(re,Ue){for(let Fe=0;Fe<re.length;Fe++){const Je=re[Fe],vt=e.getContext(Je,Ue);if(vt!==null)return vt}return null}try{const re={alpha:r,depth:s,stencil:i,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if(e.addEventListener("webglcontextlost",Mn,!1),e.addEventListener("webglcontextrestored",Cr,!1),be===null){const Ue=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&Ue.shift(),be=Xe(Ue,re),be===null)throw Xe(Ue)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}be.getShaderPrecisionFormat===void 0&&(be.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(re){throw console.error("THREE.WebGLRenderer: "+re.message),re}let Oe,it,We,dt,ct,Ve,ze,Be,ut,Ke,ee,J,rt,Ge,ye,Ze,yt,Ct,ft,ce,nt;function St(){Oe=new qgt(be),it=new Ggt(be,Oe,n),Oe.init(it),ce=new kle(be,Oe,it),We=new f0t(be,Oe,it),We.scissor(A.copy(B).multiplyScalar(O).floor()),We.viewport(k.copy(z).multiplyScalar(O).floor()),dt=new Ygt,ct=new e0t,Ve=new d0t(be,Oe,We,ct,it,ce,dt),ze=new jgt(p),Be=new vpt(be,it),nt=new Ugt(be,Oe,Be,it),ut=new Xgt(be,Be,dt,nt),Ke=new eyt(be,ut,Be,dt),yt=new Qgt(be),ye=new Hgt(ct),ee=new Qyt(p,ze,Oe,it,nt,ye),J=new p0t(ct),rt=new r0t(ct),Ge=new c0t(Oe,it),Ze=new Vgt(p,ze,We,Ke,a),Ct=new Wgt(be,Oe,dt,it),ft=new Kgt(be,Oe,dt,it),dt.programs=ee.programs,p.capabilities=it,p.extensions=Oe,p.properties=ct,p.renderLists=rt,p.state=We,p.info=dt}St();const gt=new Tle(p,be);this.xr=gt;const Gt=new Cle(p,Ke,it.maxTextureSize);this.shadowMap=Gt,this.getContext=function(){return be},this.getContextAttributes=function(){return be.getContextAttributes()},this.forceContextLoss=function(){const re=Oe.get("WEBGL_lose_context");re&&re.loseContext()},this.forceContextRestore=function(){const re=Oe.get("WEBGL_lose_context");re&&re.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(re){re!==void 0&&(O=re,this.setSize(E,N,!1))},this.getSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),re=new st),re.set(E,N)},this.setSize=function(re,Ue,Fe){if(gt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}E=re,N=Ue,e.width=Math.floor(re*O),e.height=Math.floor(Ue*O),Fe!==!1&&(e.style.width=re+"px",e.style.height=Ue+"px"),this.setViewport(0,0,re,Ue)},this.getDrawingBufferSize=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),re=new st),re.set(E*O,N*O).floor()},this.setDrawingBufferSize=function(re,Ue,Fe){E=re,N=Ue,O=Fe,e.width=Math.floor(re*Fe),e.height=Math.floor(Ue*Fe),this.setViewport(0,0,re,Ue)},this.getCurrentViewport=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),re=new Hr),re.copy(k)},this.getViewport=function(re){return re.copy(z)},this.setViewport=function(re,Ue,Fe,Je){re.isVector4?z.set(re.x,re.y,re.z,re.w):z.set(re,Ue,Fe,Je),We.viewport(k.copy(z).multiplyScalar(O).floor())},this.getScissor=function(re){return re.copy(B)},this.setScissor=function(re,Ue,Fe,Je){re.isVector4?B.set(re.x,re.y,re.z,re.w):B.set(re,Ue,Fe,Je),We.scissor(A.copy(B).multiplyScalar(O).floor())},this.getScissorTest=function(){return X},this.setScissorTest=function(re){We.setScissorTest(X=re)},this.setOpaqueSort=function(re){R=re},this.setTransparentSort=function(re){D=re},this.getClearColor=function(re){return re===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),re=new Ht),re.copy(Ze.getClearColor())},this.setClearColor=function(){Ze.setClearColor.apply(Ze,arguments)},this.getClearAlpha=function(){return Ze.getClearAlpha()},this.setClearAlpha=function(){Ze.setClearAlpha.apply(Ze,arguments)},this.clear=function(re,Ue,Fe){let Je=0;(re===void 0||re)&&(Je|=16384),(Ue===void 0||Ue)&&(Je|=256),(Fe===void 0||Fe)&&(Je|=1024),be.clear(Je)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Mn,!1),e.removeEventListener("webglcontextrestored",Cr,!1),rt.dispose(),Ge.dispose(),ct.dispose(),ze.dispose(),Ke.dispose(),nt.dispose(),gt.dispose(),go.stop()};function Mn(re){re.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function Cr(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1,St()}function Bs(re){const Ue=re.target;Ue.removeEventListener("dispose",Bs),As(Ue)}function As(re){Ms(re),ct.remove(re)}function Ms(re){const Ue=ct.get(re).program;Ue!==void 0&&ee.releaseProgram(Ue)}function Oh(re,Ue){re.render(function(Fe){p.renderBufferImmediate(Fe,Ue)})}this.renderBufferImmediate=function(re,Ue){nt.initAttributes();const Fe=ct.get(re);re.hasPositions&&!Fe.position&&(Fe.position=be.createBuffer()),re.hasNormals&&!Fe.normal&&(Fe.normal=be.createBuffer()),re.hasUvs&&!Fe.uv&&(Fe.uv=be.createBuffer()),re.hasColors&&!Fe.color&&(Fe.color=be.createBuffer());const Je=Ue.getAttributes();re.hasPositions&&(be.bindBuffer(34962,Fe.position),be.bufferData(34962,re.positionArray,35048),nt.enableAttribute(Je.position),be.vertexAttribPointer(Je.position,3,5126,!1,0,0)),re.hasNormals&&(be.bindBuffer(34962,Fe.normal),be.bufferData(34962,re.normalArray,35048),nt.enableAttribute(Je.normal),be.vertexAttribPointer(Je.normal,3,5126,!1,0,0)),re.hasUvs&&(be.bindBuffer(34962,Fe.uv),be.bufferData(34962,re.uvArray,35048),nt.enableAttribute(Je.uv),be.vertexAttribPointer(Je.uv,2,5126,!1,0,0)),re.hasColors&&(be.bindBuffer(34962,Fe.color),be.bufferData(34962,re.colorArray,35048),nt.enableAttribute(Je.color),be.vertexAttribPointer(Je.color,3,5126,!1,0,0)),nt.disableUnusedAttributes(),be.drawArrays(4,0,re.count),re.count=0},this.renderBufferDirect=function(re,Ue,Fe,Je,vt,zn){Ue===null&&(Ue=ke);const sn=vt.isMesh&&vt.matrixWorld.determinant()<0,Tn=Fh(re,Ue,Je,vt);We.setMaterial(Je,sn);let En=Fe.index;const Nn=Fe.attributes.position;if(En===null){if(Nn===void 0||Nn.count===0)return}else if(En.count===0)return;let er=1;Je.wireframe===!0&&(En=ut.getWireframeAttribute(Fe),er=2),(Je.morphTargets||Je.morphNormals)&&yt.update(vt,Fe,Je,Tn),nt.setup(vt,Je,Tn,Fe,En);let _n,ur=Ct;En!==null&&(_n=Be.get(En),ur=ft,ur.setIndex(_n));const Oi=En!==null?En.count:Nn.count,xr=Fe.drawRange.start*er,Zi=Fe.drawRange.count*er,Ar=zn!==null?zn.start*er:0,Io=zn!==null?zn.count*er:1/0,rs=Math.max(xr,Ar),yo=Math.min(Oi,xr+Zi,Ar+Io)-1,Ao=Math.max(0,yo-rs+1);if(Ao!==0){if(vt.isMesh)Je.wireframe===!0?(We.setLineWidth(Je.wireframeLinewidth*De()),ur.setMode(1)):ur.setMode(4);else if(vt.isLine){let Ns=Je.linewidth;Ns===void 0&&(Ns=1),We.setLineWidth(Ns*De()),vt.isLineSegments?ur.setMode(1):vt.isLineLoop?ur.setMode(2):ur.setMode(3)}else vt.isPoints?ur.setMode(0):vt.isSprite&&ur.setMode(4);if(vt.isInstancedMesh)ur.renderInstances(rs,Ao,vt.count);else if(Fe.isInstancedBufferGeometry){const Ns=Math.min(Fe.instanceCount,Fe._maxInstanceCount);ur.renderInstances(rs,Ao,Ns)}else ur.render(rs,Ao)}},this.compile=function(re,Ue){f=Ge.get(re),f.init(),re.traverseVisible(function(Je){Je.isLight&&Je.layers.test(Ue.layers)&&(f.pushLight(Je),Je.castShadow&&f.pushShadow(Je))}),f.setupLights();const Fe=new WeakMap;re.traverse(function(Je){const vt=Je.material;if(vt)if(Array.isArray(vt))for(let zn=0;zn<vt.length;zn++){const sn=vt[zn];Fe.has(sn)===!1&&(Di(sn,re,Je),Fe.set(sn))}else Fe.has(vt)===!1&&(Di(vt,re,Je),Fe.set(vt))})};let Bl=null;function Vl(re){gt.isPresenting||Bl&&Bl(re)}const go=new gle;go.setAnimationLoop(Vl),typeof window<"u"&&go.setContext(window),this.setAnimationLoop=function(re){Bl=re,gt.setAnimationLoop(re),re===null?go.stop():go.start()},this.render=function(re,Ue){let Fe,Je;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),Fe=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),Je=arguments[3]),Ue!==void 0&&Ue.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(m===!0)return;nt.resetDefaultState(),S=-1,C=null,re.autoUpdate===!0&&re.updateMatrixWorld(),Ue.parent===null&&Ue.updateMatrixWorld(),gt.enabled===!0&&gt.isPresenting===!0&&(Ue=gt.getCamera(Ue)),re.isScene===!0&&re.onBeforeRender(p,re,Ue,Fe||x),f=Ge.get(re,d.length),f.init(),d.push(f),ae.multiplyMatrices(Ue.projectionMatrix,Ue.matrixWorldInverse),G.setFromProjectionMatrix(ae),ge=this.localClippingEnabled,te=ye.init(this.clippingPlanes,ge,Ue),h=rt.get(re,Ue),h.init(),Ul(re,Ue,0,p.sortObjects),h.finish(),p.sortObjects===!0&&h.sort(R,D),te===!0&&ye.beginShadows();const vt=f.state.shadowsArray;Gt.render(vt,re,Ue),f.setupLights(),f.setupLightsView(Ue),te===!0&&ye.endShadows(),this.info.autoReset===!0&&this.info.reset(),Fe!==void 0&&this.setRenderTarget(Fe),Ze.render(h,re,Ue,Je);const zn=h.opaque,sn=h.transparent;zn.length>0&&Fc(zn,re,Ue),sn.length>0&&Fc(sn,re,Ue),re.isScene===!0&&re.onAfterRender(p,re,Ue),x!==null&&(Ve.updateRenderTargetMipmap(x),Ve.updateMultisampleRenderTarget(x)),We.buffers.depth.setTest(!0),We.buffers.depth.setMask(!0),We.buffers.color.setMask(!0),We.setPolygonOffset(!1),d.pop(),d.length>0?f=d[d.length-1]:f=null,h=null};function Ul(re,Ue,Fe,Je){if(re.visible===!1)return;if(re.layers.test(Ue.layers)){if(re.isGroup)Fe=re.renderOrder;else if(re.isLOD)re.autoUpdate===!0&&re.update(Ue);else if(re.isLight)f.pushLight(re),re.castShadow&&f.pushShadow(re);else if(re.isSprite){if(!re.frustumCulled||G.intersectsSprite(re)){Je&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae);const sn=Ke.update(re),Tn=re.material;Tn.visible&&h.push(re,sn,Tn,Fe,Ne.z,null)}}else if(re.isImmediateRenderObject)Je&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae),h.push(re,null,re.material,Fe,Ne.z,null);else if((re.isMesh||re.isLine||re.isPoints)&&(re.isSkinnedMesh&&re.skeleton.frame!==dt.render.frame&&(re.skeleton.update(),re.skeleton.frame=dt.render.frame),!re.frustumCulled||G.intersectsObject(re))){Je&&Ne.setFromMatrixPosition(re.matrixWorld).applyMatrix4(ae);const sn=Ke.update(re),Tn=re.material;if(Array.isArray(Tn)){const En=sn.groups;for(let Nn=0,er=En.length;Nn<er;Nn++){const _n=En[Nn],ur=Tn[_n.materialIndex];ur&&ur.visible&&h.push(re,sn,ur,Fe,Ne.z,_n)}}else Tn.visible&&h.push(re,sn,Tn,Fe,Ne.z,null)}}const zn=re.children;for(let sn=0,Tn=zn.length;sn<Tn;sn++)Ul(zn[sn],Ue,Fe,Je)}function Fc(re,Ue,Fe){const Je=Ue.isScene===!0?Ue.overrideMaterial:null;for(let vt=0,zn=re.length;vt<zn;vt++){const sn=re[vt],Tn=sn.object,En=sn.geometry,Nn=Je===null?sn.material:Je,er=sn.group;if(Fe.isArrayCamera){const _n=Fe.cameras;for(let ur=0,Oi=_n.length;ur<Oi;ur++){const xr=_n[ur];Tn.layers.test(xr.layers)&&(We.viewport(k.copy(xr.viewport)),f.setupLightsView(xr),Lc(Tn,Ue,xr,En,Nn,er))}}else Lc(Tn,Ue,Fe,En,Nn,er)}}function Lc(re,Ue,Fe,Je,vt,zn){if(re.onBeforeRender(p,Ue,Fe,Je,vt,zn),re.modelViewMatrix.multiplyMatrices(Fe.matrixWorldInverse,re.matrixWorld),re.normalMatrix.getNormalMatrix(re.modelViewMatrix),re.isImmediateRenderObject){const sn=Fh(Fe,Ue,vt,re);We.setMaterial(vt),nt.reset(),Oh(re,sn)}else p.renderBufferDirect(Fe,Ue,Je,vt,re,zn);re.onAfterRender(p,Ue,Fe,Je,vt,zn)}function Di(re,Ue,Fe){Ue.isScene!==!0&&(Ue=ke);const Je=ct.get(re),vt=f.state.lights,zn=f.state.shadowsArray,sn=vt.state.version,Tn=ee.getParameters(re,vt.state,zn,Ue,Fe),En=ee.getProgramCacheKey(Tn);let Nn=Je.program,er=!0;if(Je.environment=re.isMeshStandardMaterial?Ue.environment:null,Je.fog=Ue.fog,Je.envMap=ze.get(re.envMap||Je.environment),Nn===void 0)re.addEventListener("dispose",Bs);else if(Nn.cacheKey!==En)Ms(re);else if(Je.lightsStateVersion!==sn)er=!1;else{if(Tn.shaderID!==void 0)return;er=!1}er&&(Tn.uniforms=ee.getUniforms(re),re.onBeforeCompile(Tn,p),Nn=ee.acquireProgram(Tn,En),Je.program=Nn,Je.uniforms=Tn.uniforms,Je.outputEncoding=Tn.outputEncoding);const _n=Je.uniforms;(!re.isShaderMaterial&&!re.isRawShaderMaterial||re.clipping===!0)&&(Je.numClippingPlanes=ye.numPlanes,Je.numIntersection=ye.numIntersection,_n.clippingPlanes=ye.uniform),Je.needsLights=Lh(re),Je.lightsStateVersion=sn,Je.needsLights&&(_n.ambientLightColor.value=vt.state.ambient,_n.lightProbe.value=vt.state.probe,_n.directionalLights.value=vt.state.directional,_n.directionalLightShadows.value=vt.state.directionalShadow,_n.spotLights.value=vt.state.spot,_n.spotLightShadows.value=vt.state.spotShadow,_n.rectAreaLights.value=vt.state.rectArea,_n.ltc_1.value=vt.state.rectAreaLTC1,_n.ltc_2.value=vt.state.rectAreaLTC2,_n.pointLights.value=vt.state.point,_n.pointLightShadows.value=vt.state.pointShadow,_n.hemisphereLights.value=vt.state.hemi,_n.directionalShadowMap.value=vt.state.directionalShadowMap,_n.directionalShadowMatrix.value=vt.state.directionalShadowMatrix,_n.spotShadowMap.value=vt.state.spotShadowMap,_n.spotShadowMatrix.value=vt.state.spotShadowMatrix,_n.pointShadowMap.value=vt.state.pointShadowMap,_n.pointShadowMatrix.value=vt.state.pointShadowMatrix);const ur=Je.program.getUniforms(),Oi=Zd.seqWithValue(ur.seq,_n);Je.uniformsList=Oi}function Fh(re,Ue,Fe,Je){Ue.isScene!==!0&&(Ue=ke),Ve.resetTextureUnits();const vt=Ue.fog,zn=Fe.isMeshStandardMaterial?Ue.environment:null,sn=x===null?p.outputEncoding:x.texture.encoding,Tn=ze.get(Fe.envMap||zn),En=ct.get(Fe),Nn=f.state.lights;if(te===!0&&(ge===!0||re!==C)){const Ar=re===C&&Fe.id===S;ye.setState(Fe,re,Ar)}Fe.version===En.__version?(Fe.fog&&En.fog!==vt||En.environment!==zn||En.needsLights&&En.lightsStateVersion!==Nn.state.version||En.numClippingPlanes!==void 0&&(En.numClippingPlanes!==ye.numPlanes||En.numIntersection!==ye.numIntersection)||En.outputEncoding!==sn||En.envMap!==Tn)&&Di(Fe,Ue,Je):(Di(Fe,Ue,Je),En.__version=Fe.version);let er=!1,_n=!1,ur=!1;const Oi=En.program,xr=Oi.getUniforms(),Zi=En.uniforms;if(We.useProgram(Oi.program)&&(er=!0,_n=!0,ur=!0),Fe.id!==S&&(S=Fe.id,_n=!0),er||C!==re){if(xr.setValue(be,"projectionMatrix",re.projectionMatrix),it.logarithmicDepthBuffer&&xr.setValue(be,"logDepthBufFC",2/(Math.log(re.far+1)/Math.LN2)),C!==re&&(C=re,_n=!0,ur=!0),Fe.isShaderMaterial||Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshStandardMaterial||Fe.envMap){const Ar=xr.map.cameraPosition;Ar!==void 0&&Ar.setValue(be,Ne.setFromMatrixPosition(re.matrixWorld))}(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial)&&xr.setValue(be,"isOrthographic",re.isOrthographicCamera===!0),(Fe.isMeshPhongMaterial||Fe.isMeshToonMaterial||Fe.isMeshLambertMaterial||Fe.isMeshBasicMaterial||Fe.isMeshStandardMaterial||Fe.isShaderMaterial||Fe.isShadowMaterial||Fe.skinning)&&xr.setValue(be,"viewMatrix",re.matrixWorldInverse)}if(Fe.skinning){xr.setOptional(be,Je,"bindMatrix"),xr.setOptional(be,Je,"bindMatrixInverse");const Ar=Je.skeleton;if(Ar){const Io=Ar.bones;if(it.floatVertexTextures){if(Ar.boneTexture===null){let rs=Math.sqrt(Io.length*4);rs=In.ceilPowerOfTwo(rs),rs=Math.max(rs,4);const yo=new Float32Array(rs*rs*4);yo.set(Ar.boneMatrices);const Ao=new Pf(yo,rs,rs,El,Sf);Ar.boneMatrices=yo,Ar.boneTexture=Ao,Ar.boneTextureSize=rs}xr.setValue(be,"boneTexture",Ar.boneTexture,Ve),xr.setValue(be,"boneTextureSize",Ar.boneTextureSize)}else xr.setOptional(be,Ar,"boneMatrices")}}return(_n||En.receiveShadow!==Je.receiveShadow)&&(En.receiveShadow=Je.receiveShadow,xr.setValue(be,"receiveShadow",Je.receiveShadow)),_n&&(xr.setValue(be,"toneMappingExposure",p.toneMappingExposure),En.needsLights&&rl(Zi,ur),vt&&Fe.fog&&J.refreshFogUniforms(Zi,vt),J.refreshMaterialUniforms(Zi,Fe,O,N),Zd.upload(be,En.uniformsList,Zi,Ve)),Fe.isShaderMaterial&&Fe.uniformsNeedUpdate===!0&&(Zd.upload(be,En.uniformsList,Zi,Ve),Fe.uniformsNeedUpdate=!1),Fe.isSpriteMaterial&&xr.setValue(be,"center",Je.center),xr.setValue(be,"modelViewMatrix",Je.modelViewMatrix),xr.setValue(be,"normalMatrix",Je.normalMatrix),xr.setValue(be,"modelMatrix",Je.matrixWorld),Oi}function rl(re,Ue){re.ambientLightColor.needsUpdate=Ue,re.lightProbe.needsUpdate=Ue,re.directionalLights.needsUpdate=Ue,re.directionalLightShadows.needsUpdate=Ue,re.pointLights.needsUpdate=Ue,re.pointLightShadows.needsUpdate=Ue,re.spotLights.needsUpdate=Ue,re.spotLightShadows.needsUpdate=Ue,re.rectAreaLights.needsUpdate=Ue,re.hemisphereLights.needsUpdate=Ue}function Lh(re){return re.isMeshLambertMaterial||re.isMeshToonMaterial||re.isMeshPhongMaterial||re.isMeshStandardMaterial||re.isShadowMaterial||re.isShaderMaterial&&re.lights===!0}this.setFramebuffer=function(re){g!==re&&x===null&&be.bindFramebuffer(36160,re),g=re},this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return b},this.getRenderList=function(){return h},this.setRenderList=function(re){h=re},this.getRenderTarget=function(){return x},this.setRenderTarget=function(re,Ue=0,Fe=0){x=re,y=Ue,b=Fe,re&&ct.get(re).__webglFramebuffer===void 0&&Ve.setupRenderTarget(re);let Je=g,vt=!1;if(re){const zn=ct.get(re).__webglFramebuffer;re.isWebGLCubeRenderTarget?(Je=zn[Ue],vt=!0):re.isWebGLMultisampleRenderTarget?Je=ct.get(re).__webglMultisampledFramebuffer:Je=zn,k.copy(re.viewport),A.copy(re.scissor),M=re.scissorTest}else k.copy(z).multiplyScalar(O).floor(),A.copy(B).multiplyScalar(O).floor(),M=X;if(w!==Je&&(be.bindFramebuffer(36160,Je),w=Je),We.viewport(k),We.scissor(A),We.setScissorTest(M),vt){const zn=ct.get(re.texture);be.framebufferTexture2D(36160,36064,34069+Ue,zn.__webglTexture,Fe)}},this.readRenderTargetPixels=function(re,Ue,Fe,Je,vt,zn,sn){if(!(re&&re.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Tn=ct.get(re).__webglFramebuffer;if(re.isWebGLCubeRenderTarget&&sn!==void 0&&(Tn=Tn[sn]),Tn){let En=!1;Tn!==w&&(be.bindFramebuffer(36160,Tn),En=!0);try{const Nn=re.texture,er=Nn.format,_n=Nn.type;if(er!==El&&ce.convert(er)!==be.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const ur=_n===lS&&(Oe.has("EXT_color_buffer_half_float")||it.isWebGL2&&Oe.has("EXT_color_buffer_float"));if(_n!==ox&&ce.convert(_n)!==be.getParameter(35738)&&!(_n===Sf&&(it.isWebGL2||Oe.has("OES_texture_float")||Oe.has("WEBGL_color_buffer_float")))&&!ur){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}be.checkFramebufferStatus(36160)===36053?Ue>=0&&Ue<=re.width-Je&&Fe>=0&&Fe<=re.height-vt&&be.readPixels(Ue,Fe,Je,vt,ce.convert(er),ce.convert(_n),zn):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{En&&be.bindFramebuffer(36160,w)}}},this.copyFramebufferToTexture=function(re,Ue,Fe=0){const Je=Math.pow(2,-Fe),vt=Math.floor(Ue.image.width*Je),zn=Math.floor(Ue.image.height*Je),sn=ce.convert(Ue.format);Ve.setTexture2D(Ue,0),be.copyTexImage2D(3553,Fe,sn,re.x,re.y,vt,zn,0),We.unbindTexture()},this.copyTextureToTexture=function(re,Ue,Fe,Je=0){const vt=Ue.image.width,zn=Ue.image.height,sn=ce.convert(Fe.format),Tn=ce.convert(Fe.type);Ve.setTexture2D(Fe,0),be.pixelStorei(37440,Fe.flipY),be.pixelStorei(37441,Fe.premultiplyAlpha),be.pixelStorei(3317,Fe.unpackAlignment),Ue.isDataTexture?be.texSubImage2D(3553,Je,re.x,re.y,vt,zn,sn,Tn,Ue.image.data):Ue.isCompressedTexture?be.compressedTexSubImage2D(3553,Je,re.x,re.y,Ue.mipmaps[0].width,Ue.mipmaps[0].height,sn,Ue.mipmaps[0].data):be.texSubImage2D(3553,Je,re.x,re.y,sn,Tn,Ue.image),Je===0&&Fe.generateMipmaps&&be.generateMipmap(3553),We.unbindTexture()},this.initTexture=function(re){Ve.setTexture2D(re,0),We.unbindTexture()},this.resetState=function(){We.reset(),nt.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function zF(n){HC.call(this,n)}zF.prototype=Object.assign(Object.create(HC.prototype),{constructor:zF,isWebGL1Renderer:!0});class R${constructor(e,t){Object.defineProperty(this,"isFogExp2",{value:!0}),this.name="",this.color=new Ht(e),this.density=t!==void 0?t:25e-5}clone(){return new R$(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class P${constructor(e,t,r){Object.defineProperty(this,"isFog",{value:!0}),this.name="",this.color=new Ht(e),this.near=t!==void 0?t:1,this.far=r!==void 0?r:1e3}clone(){return new P$(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class fV extends rn{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.background!==null&&(t.object.background=this.background.toJSON(e)),this.environment!==null&&(t.object.environment=this.environment.toJSON(e)),this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}function Sl(n,e){this.array=n,this.stride=e,this.count=n!==void 0?n.length/e:0,this.usage=WC,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=In.generateUUID()}Object.defineProperty(Sl.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(Sl.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(n){return this.usage=n,this},copy:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this},copyAt:function(n,e,t){n*=this.stride,t*=e.stride;for(let r=0,s=this.stride;r<s;r++)this.array[n+r]=e.array[t+r];return this},set:function(n,e=0){return this.array.set(n,e),this},clone:function(n){n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new Sl(e,this.stride);return t.setUsage(this.usage),t},onUpload:function(n){return this.onUploadCallback=n,this},toJSON:function(n){return n.arrayBuffers===void 0&&(n.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In.generateUUID()),n.arrayBuffers[this.array.buffer._uuid]===void 0&&(n.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const dm=new Q;function yp(n,e,t,r){this.name="",this.data=n,this.itemSize=e,this.offset=t,this.normalized=r===!0}Object.defineProperties(yp.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(n){this.data.needsUpdate=n}}});Object.assign(yp.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(n){for(let e=0,t=this.data.count;e<t;e++)dm.x=this.getX(e),dm.y=this.getY(e),dm.z=this.getZ(e),dm.applyMatrix4(n),this.setXYZ(e,dm.x,dm.y,dm.z);return this},setX:function(n,e){return this.data.array[n*this.data.stride+this.offset]=e,this},setY:function(n,e){return this.data.array[n*this.data.stride+this.offset+1]=e,this},setZ:function(n,e){return this.data.array[n*this.data.stride+this.offset+2]=e,this},setW:function(n,e){return this.data.array[n*this.data.stride+this.offset+3]=e,this},getX:function(n){return this.data.array[n*this.data.stride+this.offset]},getY:function(n){return this.data.array[n*this.data.stride+this.offset+1]},getZ:function(n){return this.data.array[n*this.data.stride+this.offset+2]},getW:function(n){return this.data.array[n*this.data.stride+this.offset+3]},setXY:function(n,e,t){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this},setXYZ:function(n,e,t,r){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this},setXYZW:function(n,e,t,r,s){return n=n*this.data.stride+this.offset,this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this.data.array[n+3]=s,this},clone:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return new Cn(new this.array.constructor(e),this.itemSize,this.normalized)}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.clone(n)),new yp(n.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(n){if(n===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const r=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return n.interleavedBuffers===void 0&&(n.interleavedBuffers={}),n.interleavedBuffers[this.data.uuid]===void 0&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function bp(n){kn.call(this),this.type="SpriteMaterial",this.color=new Ht(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(n)}bp.prototype=Object.create(kn.prototype);bp.prototype.constructor=bp;bp.prototype.isSpriteMaterial=!0;bp.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this};let tb;const a1=new Q,nb=new Q,rb=new Q,sb=new st,l1=new st,Ele=new Zn,QT=new Q,c1=new Q,eE=new Q,$8=new st,IP=new st,R8=new st;function vS(n){if(rn.call(this),this.type="Sprite",tb===void 0){tb=new un;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new Sl(e,5);tb.setIndex([0,1,2,0,2,3]),tb.setAttribute("position",new yp(t,3,0,!1)),tb.setAttribute("uv",new yp(t,2,3,!1))}this.geometry=tb,this.material=n!==void 0?n:new bp,this.center=new st(.5,.5)}vS.prototype=Object.assign(Object.create(rn.prototype),{constructor:vS,isSprite:!0,raycast:function(n,e){n.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),nb.setFromMatrixScale(this.matrixWorld),Ele.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),rb.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&nb.multiplyScalar(-rb.z);const t=this.material.rotation;let r,s;t!==0&&(s=Math.cos(t),r=Math.sin(t));const i=this.center;tE(QT.set(-.5,-.5,0),rb,i,nb,r,s),tE(c1.set(.5,-.5,0),rb,i,nb,r,s),tE(eE.set(.5,.5,0),rb,i,nb,r,s),$8.set(0,0),IP.set(1,0),R8.set(1,1);let o=n.ray.intersectTriangle(QT,c1,eE,!1,a1);if(o===null&&(tE(c1.set(-.5,.5,0),rb,i,nb,r,s),IP.set(0,1),o=n.ray.intersectTriangle(QT,eE,c1,!1,a1),o===null))return;const a=n.ray.origin.distanceTo(a1);a<n.near||a>n.far||e.push({distance:a,point:a1.clone(),uv:jo.getUV(a1,QT,c1,eE,$8,IP,R8,new st),face:null,object:this})},copy:function(n){return rn.prototype.copy.call(this,n),n.center!==void 0&&this.center.copy(n.center),this.material=n.material,this}});function tE(n,e,t,r,s,i){sb.subVectors(n,t).addScalar(.5).multiply(r),s!==void 0?(l1.x=i*sb.x-s*sb.y,l1.y=s*sb.x+i*sb.y):l1.copy(sb),n.copy(e),n.x+=l1.x,n.y+=l1.y,n.applyMatrix4(Ele)}const nE=new Q,P8=new Q;function wS(){rn.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}wS.prototype=Object.assign(Object.create(rn.prototype),{constructor:wS,isLOD:!0,copy:function(n){rn.prototype.copy.call(this,n,!1);const e=n.levels;for(let t=0,r=e.length;t<r;t++){const s=e[t];this.addLevel(s.object.clone(),s.distance)}return this.autoUpdate=n.autoUpdate,this},addLevel:function(n,e=0){e=Math.abs(e);const t=this.levels;let r;for(r=0;r<t.length&&!(e<t[r].distance);r++);return t.splice(r,0,{distance:e,object:n}),this.add(n),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(n){const e=this.levels;if(e.length>0){let t,r;for(t=1,r=e.length;t<r&&!(n<e[t].distance);t++);return e[t-1].object}return null},raycast:function(n,e){if(this.levels.length>0){nE.setFromMatrixPosition(this.matrixWorld);const r=n.ray.origin.distanceTo(nE);this.getObjectForDistance(r).raycast(n,e)}},update:function(n){const e=this.levels;if(e.length>1){nE.setFromMatrixPosition(n.matrixWorld),P8.setFromMatrixPosition(this.matrixWorld);const t=nE.distanceTo(P8)/n.zoom;e[0].object.visible=!0;let r,s;for(r=1,s=e.length;r<s&&t>=e[r].distance;r++)e[r-1].object.visible=!1,e[r].object.visible=!0;for(this._currentLevel=r-1;r<s;r++)e[r].object.visible=!1}},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);this.autoUpdate===!1&&(e.object.autoUpdate=!1),e.object.levels=[];const t=this.levels;for(let r=0,s=t.length;r<s;r++){const i=t[r];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}});const D8=new Q,O8=new Hr,F8=new Hr,g0t=new Q,L8=new Zn;function xS(n,e){n&&n.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),hs.call(this,n,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Zn,this.bindMatrixInverse=new Zn}xS.prototype=Object.assign(Object.create(hs.prototype),{constructor:xS,isSkinnedMesh:!0,copy:function(n){return hs.prototype.copy.call(this,n),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this},bind:function(n,e){this.skeleton=n,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const n=new Hr,e=this.geometry.attributes.skinWeight;for(let t=0,r=e.count;t<r;t++){n.x=e.getX(t),n.y=e.getY(t),n.z=e.getZ(t),n.w=e.getW(t);const s=1/n.manhattanLength();s!==1/0?n.multiplyScalar(s):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}},updateMatrixWorld:function(n){hs.prototype.updateMatrixWorld.call(this,n),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(n,e){const t=this.skeleton,r=this.geometry;O8.fromBufferAttribute(r.attributes.skinIndex,n),F8.fromBufferAttribute(r.attributes.skinWeight,n),D8.fromBufferAttribute(r.attributes.position,n).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const i=F8.getComponent(s);if(i!==0){const o=O8.getComponent(s);L8.multiplyMatrices(t.bones[o].matrixWorld,t.boneInverses[o]),e.addScaledVector(g0t.copy(D8).applyMatrix4(L8),i)}}return e.applyMatrix4(this.bindMatrixInverse)}});function _S(){rn.call(this),this.type="Bone"}_S.prototype=Object.assign(Object.create(rn.prototype),{constructor:_S,isBone:!0});const z8=new Zn,y0t=new Zn;function SS(n=[],e=[]){this.uuid=In.generateUUID(),this.bones=n.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(SS.prototype,{init:function(){const n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(n.length*16),e.length===0)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,r=this.bones.length;t<r;t++)this.boneInverses.push(new Zn)}},calculateInverses:function(){this.boneInverses.length=0;for(let n=0,e=this.bones.length;n<e;n++){const t=new Zn;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}},pose:function(){for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(let n=0,e=this.bones.length;n<e;n++){const t=this.bones[n];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}},update:function(){const n=this.bones,e=this.boneInverses,t=this.boneMatrices,r=this.boneTexture;for(let s=0,i=n.length;s<i;s++){const o=n[s]?n[s].matrixWorld:y0t;z8.multiplyMatrices(o,e[s]),z8.toArray(t,s*16)}r!==null&&(r.needsUpdate=!0)},clone:function(){return new SS(this.bones,this.boneInverses)},getBoneByName:function(n){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];if(r.name===n)return r}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(n,e){this.uuid=n.uuid;for(let t=0,r=n.bones.length;t<r;t++){const s=n.bones[t];let i=e[s];i===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),i=new _S),this.bones.push(i),this.boneInverses.push(new Zn().fromArray(n.boneInverses[t]))}return this.init(),this},toJSON:function(){const n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let r=0,s=e.length;r<s;r++){const i=e[r];n.bones.push(i.uuid);const o=t[r];n.boneInverses.push(o.toArray())}return n}});const B8=new Zn,V8=new Zn,rE=[],u1=new hs;function NA(n,e,t){hs.call(this,n,e),this.instanceMatrix=new Cn(new Float32Array(t*16),16),this.instanceColor=null,this.count=t,this.frustumCulled=!1}NA.prototype=Object.assign(Object.create(hs.prototype),{constructor:NA,isInstancedMesh:!0,copy:function(n){return hs.prototype.copy.call(this,n),this.instanceMatrix.copy(n.instanceMatrix),n.instanceColor!==null&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this},getColorAt:function(n,e){e.fromArray(this.instanceColor.array,n*3)},getMatrixAt:function(n,e){e.fromArray(this.instanceMatrix.array,n*16)},raycast:function(n,e){const t=this.matrixWorld,r=this.count;if(u1.geometry=this.geometry,u1.material=this.material,u1.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,B8),V8.multiplyMatrices(t,B8),u1.matrixWorld=V8,u1.raycast(n,rE);for(let i=0,o=rE.length;i<o;i++){const a=rE[i];a.instanceId=s,a.object=this,e.push(a)}rE.length=0}},setColorAt:function(n,e){this.instanceColor===null&&(this.instanceColor=new Cn(new Float32Array(this.count*3),3)),e.toArray(this.instanceColor.array,n*3)},setMatrixAt:function(n,e){e.toArray(this.instanceMatrix.array,n*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});function Es(n){kn.call(this),this.type="LineBasicMaterial",this.color=new Ht(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(n)}Es.prototype=Object.create(kn.prototype);Es.prototype.constructor=Es;Es.prototype.isLineBasicMaterial=!0;Es.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.morphTargets=n.morphTargets,this};const U8=new Q,W8=new Q,G8=new Zn,AP=new ax,sE=new zp;function Mc(n=new un,e=new Es){rn.call(this),this.type="Line",this.geometry=n,this.material=e,this.updateMorphTargets()}Mc.prototype=Object.assign(Object.create(rn.prototype),{constructor:Mc,isLine:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[0];for(let r=1,s=e.count;r<s;r++)U8.fromBufferAttribute(e,r-1),W8.fromBufferAttribute(e,r),t[r]=t[r-1],t[r]+=U8.distanceTo(W8);n.setAttribute("lineDistance",new Xt(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,s=n.params.Line.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),sE.copy(t.boundingSphere),sE.applyMatrix4(r),sE.radius+=s,n.ray.intersectsSphere(sE)===!1)return;G8.copy(r).invert(),AP.copy(n.ray).applyMatrix4(G8);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=i*i,a=new Q,l=new Q,c=new Q,u=new Q,h=this.isLineSegments?2:1;if(t.isBufferGeometry){const f=t.index,p=t.attributes.position;if(f!==null){const m=f.array;for(let g=0,y=m.length-1;g<y;g+=h){const b=m[g],x=m[g+1];if(a.fromBufferAttribute(p,b),l.fromBufferAttribute(p,x),AP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const S=n.ray.origin.distanceTo(u);S<n.near||S>n.far||e.push({distance:S,point:c.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this})}}else for(let m=0,g=p.count-1;m<g;m+=h){if(a.fromBufferAttribute(p,m),l.fromBufferAttribute(p,m+1),AP.distanceSqToSegment(a,l,u,c)>o)continue;u.applyMatrix4(this.matrixWorld);const b=n.ray.origin.distanceTo(u);b<n.near||b>n.far||e.push({distance:b,point:c.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else t.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const H8=new Q,j8=new Q;function ka(n,e){Mc.call(this,n,e),this.type="LineSegments"}ka.prototype=Object.assign(Object.create(Mc.prototype),{constructor:ka,isLineSegments:!0,computeLineDistances:function(){const n=this.geometry;if(n.isBufferGeometry)if(n.index===null){const e=n.attributes.position,t=[];for(let r=0,s=e.count;r<s;r+=2)H8.fromBufferAttribute(e,r),j8.fromBufferAttribute(e,r+1),t[r]=r===0?0:t[r-1],t[r+1]=t[r]+H8.distanceTo(j8);n.setAttribute("lineDistance",new Xt(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else n.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}});function $A(n,e){Mc.call(this,n,e),this.type="LineLoop"}$A.prototype=Object.assign(Object.create(Mc.prototype),{constructor:$A,isLineLoop:!0});function Tu(n){kn.call(this),this.type="PointsMaterial",this.color=new Ht(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(n)}Tu.prototype=Object.create(kn.prototype);Tu.prototype.constructor=Tu;Tu.prototype.isPointsMaterial=!0;Tu.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.morphTargets=n.morphTargets,this};const q8=new Zn,BF=new ax,iE=new zp,oE=new Q;function mv(n=new un,e=new Tu){rn.call(this),this.type="Points",this.geometry=n,this.material=e,this.updateMorphTargets()}mv.prototype=Object.assign(Object.create(rn.prototype),{constructor:mv,isPoints:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.material=n.material,this.geometry=n.geometry,this},raycast:function(n,e){const t=this.geometry,r=this.matrixWorld,s=n.params.Points.threshold;if(t.boundingSphere===null&&t.computeBoundingSphere(),iE.copy(t.boundingSphere),iE.applyMatrix4(r),iE.radius+=s,n.ray.intersectsSphere(iE)===!1)return;q8.copy(r).invert(),BF.copy(n.ray).applyMatrix4(q8);const i=s/((this.scale.x+this.scale.y+this.scale.z)/3),o=i*i;if(t.isBufferGeometry){const a=t.index,c=t.attributes.position;if(a!==null){const u=a.array;for(let h=0,f=u.length;h<f;h++){const d=u[h];oE.fromBufferAttribute(c,d),X8(oE,d,o,r,n,e,this)}}else for(let u=0,h=c.count;u<h;u++)oE.fromBufferAttribute(c,u),X8(oE,u,o,r,n,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")},updateMorphTargets:function(){const n=this.geometry;if(n.isBufferGeometry){const e=n.morphAttributes,t=Object.keys(e);if(t.length>0){const r=e[t[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,i=r.length;s<i;s++){const o=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}else{const e=n.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function X8(n,e,t,r,s,i,o){const a=BF.distanceSqToPoint(n);if(a<t){const l=new Q;BF.closestPointToPoint(n,l),l.applyMatrix4(r);const c=s.ray.origin.distanceTo(l);if(c<s.near||c>s.far)return;i.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}function VF(n,e,t,r,s,i,o,a,l){Kr.call(this,n,e,t,r,s,i,o,a,l),this.format=o!==void 0?o:Kd,this.minFilter=i!==void 0?i:lo,this.magFilter=s!==void 0?s:lo,this.generateMipmaps=!1;const c=this;function u(){c.needsUpdate=!0,n.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback(u)}VF.prototype=Object.assign(Object.create(Kr.prototype),{constructor:VF,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const n=this.image;"requestVideoFrameCallback"in n===!1&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function gv(n,e,t,r,s,i,o,a,l,c,u,h){Kr.call(this,null,i,o,a,l,c,r,s,u,h),this.image={width:e,height:t},this.mipmaps=n,this.flipY=!1,this.generateMipmaps=!1}gv.prototype=Object.create(Kr.prototype);gv.prototype.constructor=gv;gv.prototype.isCompressedTexture=!0;function CS(n,e,t,r,s,i,o,a,l){Kr.call(this,n,e,t,r,s,i,o,a,l),this.needsUpdate=!0}CS.prototype=Object.create(Kr.prototype);CS.prototype.constructor=CS;CS.prototype.isCanvasTexture=!0;function kS(n,e,t,r,s,i,o,a,l,c){if(c=c!==void 0?c:Qm,c!==Qm&&c!==hv)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&c===Qm&&(t=aS),t===void 0&&c===hv&&(t=Db),Kr.call(this,null,r,s,i,o,a,c,t,l),this.image={width:n,height:e},this.magFilter=o!==void 0?o:Ui,this.minFilter=a!==void 0?a:Ui,this.flipY=!1,this.generateMipmaps=!1}kS.prototype=Object.create(Kr.prototype);kS.prototype.constructor=kS;kS.prototype.isDepthTexture=!0;class RA extends un{constructor(e=1,t=8,r=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:s},t=Math.max(3,t);const i=[],o=[],a=[],l=[],c=new Q,u=new st;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,f=3;h<=t;h++,f+=3){const d=r+h/t*s;c.x=e*Math.cos(d),c.y=e*Math.sin(d),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[f]/e+1)/2,u.y=(o[f+1]/e+1)/2,l.push(u.x,u.y)}for(let h=1;h<=t;h++)i.push(h,h+1,0);this.setIndex(i),this.setAttribute("position",new Xt(o,3)),this.setAttribute("normal",new Xt(a,3)),this.setAttribute("uv",new Xt(l,2))}}class yv extends un{constructor(e=1,t=1,r=1,s=8,i=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:s,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l};const c=this;s=Math.floor(s),i=Math.floor(i);const u=[],h=[],f=[],d=[];let p=0;const m=[],g=r/2;let y=0;b(),o===!1&&(e>0&&x(!0),t>0&&x(!1)),this.setIndex(u),this.setAttribute("position",new Xt(h,3)),this.setAttribute("normal",new Xt(f,3)),this.setAttribute("uv",new Xt(d,2));function b(){const w=new Q,S=new Q;let C=0;const k=(t-e)/r;for(let A=0;A<=i;A++){const M=[],E=A/i,N=E*(t-e)+e;for(let O=0;O<=s;O++){const R=O/s,D=R*l+a,z=Math.sin(D),B=Math.cos(D);S.x=N*z,S.y=-E*r+g,S.z=N*B,h.push(S.x,S.y,S.z),w.set(z,k,B).normalize(),f.push(w.x,w.y,w.z),d.push(R,1-E),M.push(p++)}m.push(M)}for(let A=0;A<s;A++)for(let M=0;M<i;M++){const E=m[M][A],N=m[M+1][A],O=m[M+1][A+1],R=m[M][A+1];u.push(E,N,R),u.push(N,O,R),C+=6}c.addGroup(y,C,0),y+=C}function x(w){const S=p,C=new st,k=new Q;let A=0;const M=w===!0?e:t,E=w===!0?1:-1;for(let O=1;O<=s;O++)h.push(0,g*E,0),f.push(0,E,0),d.push(.5,.5),p++;const N=p;for(let O=0;O<=s;O++){const D=O/s*l+a,z=Math.cos(D),B=Math.sin(D);k.x=M*B,k.y=g*E,k.z=M*z,h.push(k.x,k.y,k.z),f.push(0,E,0),C.x=z*.5+.5,C.y=B*.5*E+.5,d.push(C.x,C.y),p++}for(let O=0;O<s;O++){const R=S+O,D=N+O;w===!0?u.push(D,D+1,R):u.push(D+1,D,R),A+=3}c.addGroup(y,A,w===!0?1:2),y+=A}}}class PA extends yv{constructor(e=1,t=1,r=8,s=1,i=!1,o=0,a=Math.PI*2){super(0,e,t,r,s,i,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:s,openEnded:i,thetaStart:o,thetaLength:a}}}class vp extends un{constructor(e,t,r=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:s};const i=[],o=[];a(s),c(r),u(),this.setAttribute("position",new Xt(i,3)),this.setAttribute("normal",new Xt(i.slice(),3)),this.setAttribute("uv",new Xt(o,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function a(b){const x=new Q,w=new Q,S=new Q;for(let C=0;C<t.length;C+=3)d(t[C+0],x),d(t[C+1],w),d(t[C+2],S),l(x,w,S,b)}function l(b,x,w,S){const C=S+1,k=[];for(let A=0;A<=C;A++){k[A]=[];const M=b.clone().lerp(w,A/C),E=x.clone().lerp(w,A/C),N=C-A;for(let O=0;O<=N;O++)O===0&&A===C?k[A][O]=M:k[A][O]=M.clone().lerp(E,O/N)}for(let A=0;A<C;A++)for(let M=0;M<2*(C-A)-1;M++){const E=Math.floor(M/2);M%2===0?(f(k[A][E+1]),f(k[A+1][E]),f(k[A][E])):(f(k[A][E+1]),f(k[A+1][E+1]),f(k[A+1][E]))}}function c(b){const x=new Q;for(let w=0;w<i.length;w+=3)x.x=i[w+0],x.y=i[w+1],x.z=i[w+2],x.normalize().multiplyScalar(b),i[w+0]=x.x,i[w+1]=x.y,i[w+2]=x.z}function u(){const b=new Q;for(let x=0;x<i.length;x+=3){b.x=i[x+0],b.y=i[x+1],b.z=i[x+2];const w=g(b)/2/Math.PI+.5,S=y(b)/Math.PI+.5;o.push(w,1-S)}p(),h()}function h(){for(let b=0;b<o.length;b+=6){const x=o[b+0],w=o[b+2],S=o[b+4],C=Math.max(x,w,S),k=Math.min(x,w,S);C>.9&&k<.1&&(x<.2&&(o[b+0]+=1),w<.2&&(o[b+2]+=1),S<.2&&(o[b+4]+=1))}}function f(b){i.push(b.x,b.y,b.z)}function d(b,x){const w=b*3;x.x=e[w+0],x.y=e[w+1],x.z=e[w+2]}function p(){const b=new Q,x=new Q,w=new Q,S=new Q,C=new st,k=new st,A=new st;for(let M=0,E=0;M<i.length;M+=9,E+=6){b.set(i[M+0],i[M+1],i[M+2]),x.set(i[M+3],i[M+4],i[M+5]),w.set(i[M+6],i[M+7],i[M+8]),C.set(o[E+0],o[E+1]),k.set(o[E+2],o[E+3]),A.set(o[E+4],o[E+5]),S.copy(b).add(x).add(w).divideScalar(3);const N=g(S);m(C,E+0,b,N),m(k,E+2,x,N),m(A,E+4,w,N)}}function m(b,x,w,S){S<0&&b.x===1&&(o[x]=b.x-1),w.x===0&&w.z===0&&(o[x]=S/2/Math.PI+.5)}function g(b){return Math.atan2(b.z,-b.x)}function y(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}}}class DA extends vp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=1/r,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-r,0,-s,r,0,s,-r,0,s,r,-s,-r,0,-s,r,0,s,-r,0,s,r,0,-r,0,-s,r,0,-s,-r,0,s,r,0,s],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const aE=new Q,lE=new Q,MP=new Q,cE=new jo;class dV extends un{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=t!==void 0?t:1,e.isGeometry===!0){console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const s=Math.pow(10,4),i=Math.cos(In.DEG2RAD*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],h=new Array(3),f={},d=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:m,b:g,c:y}=cE;if(m.fromBufferAttribute(a,c[0]),g.fromBufferAttribute(a,c[1]),y.fromBufferAttribute(a,c[2]),cE.getNormal(MP),h[0]=`${Math.round(m.x*s)},${Math.round(m.y*s)},${Math.round(m.z*s)}`,h[1]=`${Math.round(g.x*s)},${Math.round(g.y*s)},${Math.round(g.z*s)}`,h[2]=`${Math.round(y.x*s)},${Math.round(y.y*s)},${Math.round(y.z*s)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let b=0;b<3;b++){const x=(b+1)%3,w=h[b],S=h[x],C=cE[u[b]],k=cE[u[x]],A=`${w}_${S}`,M=`${S}_${w}`;M in f&&f[M]?(MP.dot(f[M].normal)<=i&&(d.push(C.x,C.y,C.z),d.push(k.x,k.y,k.z)),f[M]=null):A in f||(f[A]={index0:c[b],index1:c[x],normal:MP.clone()})}}for(const p in f)if(f[p]){const{index0:m,index1:g}=f[p];aE.fromBufferAttribute(a,m),lE.fromBufferAttribute(a,g),d.push(aE.x,aE.y,aE.z),d.push(lE.x,lE.y,lE.z)}this.setAttribute("position",new Xt(d,3))}}const b0t={triangulate:function(n,e,t){t=t||2;const r=e&&e.length,s=r?e[0]*t:n.length;let i=Ile(n,0,s,t,!0);const o=[];if(!i||i.next===i.prev)return o;let a,l,c,u,h,f,d;if(r&&(i=S0t(n,e,i,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let p=t;p<s;p+=t)h=n[p],f=n[p+1],h<a&&(a=h),f<l&&(l=f),h>c&&(c=h),f>u&&(u=f);d=Math.max(c-a,u-l),d=d!==0?1/d:0}return TS(i,o,t,a,l,d),o}};function Ile(n,e,t,r,s){let i,o;if(s===P0t(n,e,t,r)>0)for(i=e;i<t;i+=r)o=K8(i,n[i],n[i+1],o);else for(i=t-r;i>=e;i-=r)o=K8(i,n[i],n[i+1],o);return o&&D$(o,o.next)&&(IS(o),o=o.next),o}function wp(n,e){if(!n)return n;e||(e=n);let t=n,r;do if(r=!1,!t.steiner&&(D$(t,t.next)||Os(t.prev,t,t.next)===0)){if(IS(t),t=e=t.prev,t===t.next)break;r=!0}else t=t.next;while(r||t!==e);return e}function TS(n,e,t,r,s,i,o){if(!n)return;!o&&i&&I0t(n,r,s,i);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,i?w0t(n,r,s,i):v0t(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),IS(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=x0t(wp(n),e,t),TS(n,e,t,r,s,i,2)):o===2&&_0t(n,e,t,r,s,i):TS(wp(n),e,t,r,s,i,1);break}}}function v0t(n){const e=n.prev,t=n,r=n.next;if(Os(e,t,r)>=0)return!1;let s=n.next.next;for(;s!==n.prev;){if(Sb(e.x,e.y,t.x,t.y,r.x,r.y,s.x,s.y)&&Os(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function w0t(n,e,t,r){const s=n.prev,i=n,o=n.next;if(Os(s,i,o)>=0)return!1;const a=s.x<i.x?s.x<o.x?s.x:o.x:i.x<o.x?i.x:o.x,l=s.y<i.y?s.y<o.y?s.y:o.y:i.y<o.y?i.y:o.y,c=s.x>i.x?s.x>o.x?s.x:o.x:i.x>o.x?i.x:o.x,u=s.y>i.y?s.y>o.y?s.y:o.y:i.y>o.y?i.y:o.y,h=UF(a,l,e,t,r),f=UF(c,u,e,t,r);let d=n.prevZ,p=n.nextZ;for(;d&&d.z>=h&&p&&p.z<=f;){if(d!==n.prev&&d!==n.next&&Sb(s.x,s.y,i.x,i.y,o.x,o.y,d.x,d.y)&&Os(d.prev,d,d.next)>=0||(d=d.prevZ,p!==n.prev&&p!==n.next&&Sb(s.x,s.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Os(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;d&&d.z>=h;){if(d!==n.prev&&d!==n.next&&Sb(s.x,s.y,i.x,i.y,o.x,o.y,d.x,d.y)&&Os(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;p&&p.z<=f;){if(p!==n.prev&&p!==n.next&&Sb(s.x,s.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Os(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function x0t(n,e,t){let r=n;do{const s=r.prev,i=r.next.next;!D$(s,i)&&Ale(s,r,r.next,i)&&ES(s,i)&&ES(i,s)&&(e.push(s.i/t),e.push(r.i/t),e.push(i.i/t),IS(r),IS(r.next),r=n=i),r=r.next}while(r!==n);return wp(r)}function _0t(n,e,t,r,s,i){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&N0t(o,a)){let l=Mle(o,a);o=wp(o,o.next),l=wp(l,l.next),TS(o,e,t,r,s,i),TS(l,e,t,r,s,i);return}a=a.next}o=o.next}while(o!==n)}function S0t(n,e,t,r){const s=[];let i,o,a,l,c;for(i=0,o=e.length;i<o;i++)a=e[i]*r,l=i<o-1?e[i+1]*r:n.length,c=Ile(n,a,l,r,!1),c===c.next&&(c.steiner=!0),s.push(M0t(c));for(s.sort(C0t),i=0;i<s.length;i++)k0t(s[i],t),t=wp(t,t.next);return t}function C0t(n,e){return n.x-e.x}function k0t(n,e){if(e=T0t(n,e),e){const t=Mle(e,n);wp(e,e.next),wp(t,t.next)}}function T0t(n,e){let t=e;const r=n.x,s=n.y;let i=-1/0,o;do{if(s<=t.y&&s>=t.next.y&&t.next.y!==t.y){const f=t.x+(s-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(f<=r&&f>i){if(i=f,f===r){if(s===t.y)return t;if(s===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(r===i)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do r>=t.x&&t.x>=l&&r!==t.x&&Sb(s<c?r:i,s,l,c,s<c?i:r,s,t.x,t.y)&&(h=Math.abs(s-t.y)/(r-t.x),ES(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&E0t(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function E0t(n,e){return Os(n.prev,n,e.prev)<0&&Os(e.next,n,n.next)<0}function I0t(n,e,t,r){let s=n;do s.z===null&&(s.z=UF(s.x,s.y,e,t,r)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,A0t(s)}function A0t(n){let e,t,r,s,i,o,a,l,c=1;do{for(t=n,n=null,i=null,o=0;t;){for(o++,r=t,a=0,e=0;e<c&&(a++,r=r.nextZ,!!r);e++);for(l=c;a>0||l>0&&r;)a!==0&&(l===0||!r||t.z<=r.z)?(s=t,t=t.nextZ,a--):(s=r,r=r.nextZ,l--),i?i.nextZ=s:n=s,s.prevZ=i,i=s;t=r}i.nextZ=null,c*=2}while(o>1);return n}function UF(n,e,t,r,s){return n=32767*(n-t)*s,e=32767*(e-r)*s,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function M0t(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Sb(n,e,t,r,s,i,o,a){return(s-o)*(e-a)-(n-o)*(i-a)>=0&&(n-o)*(r-a)-(t-o)*(e-a)>=0&&(t-o)*(i-a)-(s-o)*(r-a)>=0}function N0t(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!$0t(n,e)&&(ES(n,e)&&ES(e,n)&&R0t(n,e)&&(Os(n.prev,n,e.prev)||Os(n,e.prev,e))||D$(n,e)&&Os(n.prev,n,n.next)>0&&Os(e.prev,e,e.next)>0)}function Os(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function D$(n,e){return n.x===e.x&&n.y===e.y}function Ale(n,e,t,r){const s=hE(Os(n,e,t)),i=hE(Os(n,e,r)),o=hE(Os(t,r,n)),a=hE(Os(t,r,e));return!!(s!==i&&o!==a||s===0&&uE(n,t,e)||i===0&&uE(n,r,e)||o===0&&uE(t,n,r)||a===0&&uE(t,e,r))}function uE(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function hE(n){return n>0?1:n<0?-1:0}function $0t(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&Ale(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function ES(n,e){return Os(n.prev,n,n.next)<0?Os(n,e,n.next)>=0&&Os(n,n.prev,e)>=0:Os(n,e,n.prev)<0||Os(n,n.next,e)<0}function R0t(n,e){let t=n,r=!1;const s=(n.x+e.x)/2,i=(n.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&s<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==n);return r}function Mle(n,e){const t=new WF(n.i,n.x,n.y),r=new WF(e.i,e.x,e.y),s=n.next,i=e.prev;return n.next=e,e.prev=n,t.next=s,s.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function K8(n,e,t,r){const s=new WF(n,e,t);return r?(s.next=r.next,s.prev=r,r.next.prev=s,r.next=s):(s.prev=s,s.next=s),s}function IS(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function WF(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function P0t(n,e,t,r){let s=0;for(let i=e,o=t-r;i<t;i+=r)s+=(n[o]-n[i])*(n[i+1]+n[o+1]),o=i;return s}const Af={area:function(n){const e=n.length;let t=0;for(let r=e-1,s=0;s<e;r=s++)t+=n[r].x*n[s].y-n[s].x*n[r].y;return t*.5},isClockWise:function(n){return Af.area(n)<0},triangulateShape:function(n,e){const t=[],r=[],s=[];Y8(n),Z8(t,n);let i=n.length;e.forEach(Y8);for(let a=0;a<e.length;a++)r.push(i),i+=e[a].length,Z8(t,e[a]);const o=b0t.triangulate(t,r);for(let a=0;a<o.length;a+=3)s.push(o.slice(a,a+3));return s}};function Y8(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function Z8(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class Sg extends un{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const r=this,s=[],i=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new Xt(s,3)),this.setAttribute("uv",new Xt(i,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:100,f=t.bevelEnabled!==void 0?t.bevelEnabled:!0,d=t.bevelThickness!==void 0?t.bevelThickness:6,p=t.bevelSize!==void 0?t.bevelSize:d-2,m=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const y=t.extrudePath,b=t.UVGenerator!==void 0?t.UVGenerator:D0t;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let x,w=!1,S,C,k,A;y&&(x=y.getSpacedPoints(u),w=!0,f=!1,S=y.computeFrenetFrames(u,!1),C=new Q,k=new Q,A=new Q),f||(g=0,d=0,p=0,m=0);const M=a.extractPoints(c);let E=M.shape;const N=M.holes;if(!Af.isClockWise(E)){E=E.reverse();for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];Af.isClockWise(Be)&&(N[Ve]=Be.reverse())}}const R=Af.triangulateShape(E,N),D=E;for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];E=E.concat(Be)}function z(Ve,ze,Be){return ze||console.error("THREE.ExtrudeGeometry: vec does not exist"),ze.clone().multiplyScalar(Be).add(Ve)}const B=E.length,X=R.length;function G(Ve,ze,Be){let ut,Ke,ee;const J=Ve.x-ze.x,rt=Ve.y-ze.y,Ge=Be.x-Ve.x,ye=Be.y-Ve.y,Ze=J*J+rt*rt,yt=J*ye-rt*Ge;if(Math.abs(yt)>Number.EPSILON){const Ct=Math.sqrt(Ze),ft=Math.sqrt(Ge*Ge+ye*ye),ce=ze.x-rt/Ct,nt=ze.y+J/Ct,St=Be.x-ye/ft,gt=Be.y+Ge/ft,Gt=((St-ce)*ye-(gt-nt)*Ge)/(J*ye-rt*Ge);ut=ce+J*Gt-Ve.x,Ke=nt+rt*Gt-Ve.y;const Mn=ut*ut+Ke*Ke;if(Mn<=2)return new st(ut,Ke);ee=Math.sqrt(Mn/2)}else{let Ct=!1;J>Number.EPSILON?Ge>Number.EPSILON&&(Ct=!0):J<-Number.EPSILON?Ge<-Number.EPSILON&&(Ct=!0):Math.sign(rt)===Math.sign(ye)&&(Ct=!0),Ct?(ut=-rt,Ke=J,ee=Math.sqrt(Ze)):(ut=J,Ke=rt,ee=Math.sqrt(Ze/2))}return new st(ut/ee,Ke/ee)}const te=[];for(let Ve=0,ze=D.length,Be=ze-1,ut=Ve+1;Ve<ze;Ve++,Be++,ut++)Be===ze&&(Be=0),ut===ze&&(ut=0),te[Ve]=G(D[Ve],D[Be],D[ut]);const ge=[];let ae,Ne=te.concat();for(let Ve=0,ze=N.length;Ve<ze;Ve++){const Be=N[Ve];ae=[];for(let ut=0,Ke=Be.length,ee=Ke-1,J=ut+1;ut<Ke;ut++,ee++,J++)ee===Ke&&(ee=0),J===Ke&&(J=0),ae[ut]=G(Be[ut],Be[ee],Be[J]);ge.push(ae),Ne=Ne.concat(ae)}for(let Ve=0;Ve<g;Ve++){const ze=Ve/g,Be=d*Math.cos(ze*Math.PI/2),ut=p*Math.sin(ze*Math.PI/2)+m;for(let Ke=0,ee=D.length;Ke<ee;Ke++){const J=z(D[Ke],te[Ke],ut);Oe(J.x,J.y,-Be)}for(let Ke=0,ee=N.length;Ke<ee;Ke++){const J=N[Ke];ae=ge[Ke];for(let rt=0,Ge=J.length;rt<Ge;rt++){const ye=z(J[rt],ae[rt],ut);Oe(ye.x,ye.y,-Be)}}}const ke=p+m;for(let Ve=0;Ve<B;Ve++){const ze=f?z(E[Ve],Ne[Ve],ke):E[Ve];w?(k.copy(S.normals[0]).multiplyScalar(ze.x),C.copy(S.binormals[0]).multiplyScalar(ze.y),A.copy(x[0]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(ze.x,ze.y,0)}for(let Ve=1;Ve<=u;Ve++)for(let ze=0;ze<B;ze++){const Be=f?z(E[ze],Ne[ze],ke):E[ze];w?(k.copy(S.normals[Ve]).multiplyScalar(Be.x),C.copy(S.binormals[Ve]).multiplyScalar(Be.y),A.copy(x[Ve]).add(k).add(C),Oe(A.x,A.y,A.z)):Oe(Be.x,Be.y,h/u*Ve)}for(let Ve=g-1;Ve>=0;Ve--){const ze=Ve/g,Be=d*Math.cos(ze*Math.PI/2),ut=p*Math.sin(ze*Math.PI/2)+m;for(let Ke=0,ee=D.length;Ke<ee;Ke++){const J=z(D[Ke],te[Ke],ut);Oe(J.x,J.y,h+Be)}for(let Ke=0,ee=N.length;Ke<ee;Ke++){const J=N[Ke];ae=ge[Ke];for(let rt=0,Ge=J.length;rt<Ge;rt++){const ye=z(J[rt],ae[rt],ut);w?Oe(ye.x,ye.y+x[u-1].y,x[u-1].x+Be):Oe(ye.x,ye.y,h+Be)}}}De(),be();function De(){const Ve=s.length/3;if(f){let ze=0,Be=B*ze;for(let ut=0;ut<X;ut++){const Ke=R[ut];it(Ke[2]+Be,Ke[1]+Be,Ke[0]+Be)}ze=u+g*2,Be=B*ze;for(let ut=0;ut<X;ut++){const Ke=R[ut];it(Ke[0]+Be,Ke[1]+Be,Ke[2]+Be)}}else{for(let ze=0;ze<X;ze++){const Be=R[ze];it(Be[2],Be[1],Be[0])}for(let ze=0;ze<X;ze++){const Be=R[ze];it(Be[0]+B*u,Be[1]+B*u,Be[2]+B*u)}}r.addGroup(Ve,s.length/3-Ve,0)}function be(){const Ve=s.length/3;let ze=0;Xe(D,ze),ze+=D.length;for(let Be=0,ut=N.length;Be<ut;Be++){const Ke=N[Be];Xe(Ke,ze),ze+=Ke.length}r.addGroup(Ve,s.length/3-Ve,1)}function Xe(Ve,ze){let Be=Ve.length;for(;--Be>=0;){const ut=Be;let Ke=Be-1;Ke<0&&(Ke=Ve.length-1);for(let ee=0,J=u+g*2;ee<J;ee++){const rt=B*ee,Ge=B*(ee+1),ye=ze+ut+rt,Ze=ze+Ke+rt,yt=ze+Ke+Ge,Ct=ze+ut+Ge;We(ye,Ze,yt,Ct)}}}function Oe(Ve,ze,Be){l.push(Ve),l.push(ze),l.push(Be)}function it(Ve,ze,Be){dt(Ve),dt(ze),dt(Be);const ut=s.length/3,Ke=b.generateTopUV(r,s,ut-3,ut-2,ut-1);ct(Ke[0]),ct(Ke[1]),ct(Ke[2])}function We(Ve,ze,Be,ut){dt(Ve),dt(ze),dt(ut),dt(ze),dt(Be),dt(ut);const Ke=s.length/3,ee=b.generateSideWallUV(r,s,Ke-6,Ke-3,Ke-2,Ke-1);ct(ee[0]),ct(ee[1]),ct(ee[3]),ct(ee[1]),ct(ee[2]),ct(ee[3])}function dt(Ve){s.push(l[Ve*3+0]),s.push(l[Ve*3+1]),s.push(l[Ve*3+2])}function ct(Ve){i.push(Ve.x),i.push(Ve.y)}}}toJSON(){const e=un.prototype.toJSON.call(this),t=this.parameters.shapes,r=this.parameters.options;return O0t(t,r,e)}}const D0t={generateTopUV:function(n,e,t,r,s){const i=e[t*3],o=e[t*3+1],a=e[r*3],l=e[r*3+1],c=e[s*3],u=e[s*3+1];return[new st(i,o),new st(a,l),new st(c,u)]},generateSideWallUV:function(n,e,t,r,s,i){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[r*3],u=e[r*3+1],h=e[r*3+2],f=e[s*3],d=e[s*3+1],p=e[s*3+2],m=e[i*3],g=e[i*3+1],y=e[i*3+2];return Math.abs(a-u)<.01?[new st(o,1-l),new st(c,1-h),new st(f,1-p),new st(m,1-y)]:[new st(a,1-l),new st(u,1-h),new st(d,1-p),new st(g,1-y)]}};function O0t(n,e,t){if(t.shapes=[],Array.isArray(n))for(let r=0,s=n.length;r<s;r++){const i=n[r];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class OA extends vp{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,i,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class FA extends un{constructor(e,t=12,r=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:s},t=Math.floor(t),s=In.clamp(s,0,Math.PI*2);const i=[],o=[],a=[],l=1/t,c=new Q,u=new st;for(let h=0;h<=t;h++){const f=r+h*l*s,d=Math.sin(f),p=Math.cos(f);for(let m=0;m<=e.length-1;m++)c.x=e[m].x*d,c.y=e[m].y,c.z=e[m].x*p,o.push(c.x,c.y,c.z),u.x=h/t,u.y=m/(e.length-1),a.push(u.x,u.y)}for(let h=0;h<t;h++)for(let f=0;f<e.length-1;f++){const d=f+h*e.length,p=d,m=d+e.length,g=d+e.length+1,y=d+1;i.push(p,m,y),i.push(m,g,y)}if(this.setIndex(i),this.setAttribute("position",new Xt(o,3)),this.setAttribute("uv",new Xt(a,2)),this.computeVertexNormals(),s===Math.PI*2){const h=this.attributes.normal.array,f=new Q,d=new Q,p=new Q,m=t*e.length*3;for(let g=0,y=0;g<e.length;g++,y+=3)f.x=h[y+0],f.y=h[y+1],f.z=h[y+2],d.x=h[m+y+0],d.y=h[m+y+1],d.z=h[m+y+2],p.addVectors(f,d).normalize(),h[y+0]=h[m+y+0]=p.x,h[y+1]=h[m+y+1]=p.y,h[y+2]=h[m+y+2]=p.z}}}class AS extends vp{constructor(e=1,t=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,s,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}function Cg(n,e,t){un.call(this),this.type="ParametricGeometry",this.parameters={func:n,slices:e,stacks:t};const r=[],s=[],i=[],o=[],a=1e-5,l=new Q,c=new Q,u=new Q,h=new Q,f=new Q;n.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const d=e+1;for(let p=0;p<=t;p++){const m=p/t;for(let g=0;g<=e;g++){const y=g/e;n(y,m,c),s.push(c.x,c.y,c.z),y-a>=0?(n(y-a,m,u),h.subVectors(c,u)):(n(y+a,m,u),h.subVectors(u,c)),m-a>=0?(n(y,m-a,u),f.subVectors(c,u)):(n(y,m+a,u),f.subVectors(u,c)),l.crossVectors(h,f).normalize(),i.push(l.x,l.y,l.z),o.push(y,m)}}for(let p=0;p<t;p++)for(let m=0;m<e;m++){const g=p*d+m,y=p*d+m+1,b=(p+1)*d+m+1,x=(p+1)*d+m;r.push(g,y,x),r.push(y,b,x)}this.setIndex(r),this.setAttribute("position",new Xt(s,3)),this.setAttribute("normal",new Xt(i,3)),this.setAttribute("uv",new Xt(o,2))}Cg.prototype=Object.create(un.prototype);Cg.prototype.constructor=Cg;class LA extends un{constructor(e=.5,t=1,r=8,s=1,i=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:s,thetaStart:i,thetaLength:o},r=Math.max(3,r),s=Math.max(1,s);const a=[],l=[],c=[],u=[];let h=e;const f=(t-e)/s,d=new Q,p=new st;for(let m=0;m<=s;m++){for(let g=0;g<=r;g++){const y=i+g/r*o;d.x=h*Math.cos(y),d.y=h*Math.sin(y),l.push(d.x,d.y,d.z),c.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,u.push(p.x,p.y)}h+=f}for(let m=0;m<s;m++){const g=m*(r+1);for(let y=0;y<r;y++){const b=y+g,x=b,w=b+r+1,S=b+r+2,C=b+1;a.push(x,w,C),a.push(w,S,C)}}this.setIndex(a),this.setAttribute("position",new Xt(l,3)),this.setAttribute("normal",new Xt(c,3)),this.setAttribute("uv",new Xt(u,2))}}class MS extends un{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],s=[],i=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(r),this.setAttribute("position",new Xt(s,3)),this.setAttribute("normal",new Xt(i,3)),this.setAttribute("uv",new Xt(o,2));function c(u){const h=s.length/3,f=u.extractPoints(t);let d=f.shape;const p=f.holes;Af.isClockWise(d)===!1&&(d=d.reverse());for(let g=0,y=p.length;g<y;g++){const b=p[g];Af.isClockWise(b)===!0&&(p[g]=b.reverse())}const m=Af.triangulateShape(d,p);for(let g=0,y=p.length;g<y;g++){const b=p[g];d=d.concat(b)}for(let g=0,y=d.length;g<y;g++){const b=d[g];s.push(b.x,b.y,0),i.push(0,0,1),o.push(b.x,b.y)}for(let g=0,y=m.length;g<y;g++){const b=m[g],x=b[0]+h,w=b[1]+h,S=b[2]+h;r.push(x,w,S),l+=3}}}toJSON(){const e=un.prototype.toJSON.call(this),t=this.parameters.shapes;return F0t(t,e)}}function F0t(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const s=n[t];e.shapes.push(s.uuid)}else e.shapes.push(n.uuid);return e}class NS extends un{constructor(e=1,t=8,r=6,s=0,i=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:s,phiLength:i,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),r=Math.max(2,Math.floor(r));const l=Math.min(o+a,Math.PI);let c=0;const u=[],h=new Q,f=new Q,d=[],p=[],m=[],g=[];for(let y=0;y<=r;y++){const b=[],x=y/r;let w=0;y==0&&o==0?w=.5/t:y==r&&l==Math.PI&&(w=-.5/t);for(let S=0;S<=t;S++){const C=S/t;h.x=-e*Math.cos(s+C*i)*Math.sin(o+x*a),h.y=e*Math.cos(o+x*a),h.z=e*Math.sin(s+C*i)*Math.sin(o+x*a),p.push(h.x,h.y,h.z),f.copy(h).normalize(),m.push(f.x,f.y,f.z),g.push(C+w,1-x),b.push(c++)}u.push(b)}for(let y=0;y<r;y++)for(let b=0;b<t;b++){const x=u[y][b+1],w=u[y][b],S=u[y+1][b],C=u[y+1][b+1];(y!==0||o>0)&&d.push(x,w,C),(y!==r-1||l<Math.PI)&&d.push(w,S,C)}this.setIndex(d),this.setAttribute("position",new Xt(p,3)),this.setAttribute("normal",new Xt(m,3)),this.setAttribute("uv",new Xt(g,2))}}class zA extends vp{constructor(e=1,t=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],s=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,s,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class BA extends Sg{constructor(e,t={}){const r=t.font;if(!(r&&r.isFont))return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new un;const s=r.generateShapes(e,t.size);t.depth=t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(s,t),this.type="TextGeometry"}}class VA extends un{constructor(e=1,t=.4,r=8,s=6,i=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:s,arc:i},r=Math.floor(r),s=Math.floor(s);const o=[],a=[],l=[],c=[],u=new Q,h=new Q,f=new Q;for(let d=0;d<=r;d++)for(let p=0;p<=s;p++){const m=p/s*i,g=d/r*Math.PI*2;h.x=(e+t*Math.cos(g))*Math.cos(m),h.y=(e+t*Math.cos(g))*Math.sin(m),h.z=t*Math.sin(g),a.push(h.x,h.y,h.z),u.x=e*Math.cos(m),u.y=e*Math.sin(m),f.subVectors(h,u).normalize(),l.push(f.x,f.y,f.z),c.push(p/s),c.push(d/r)}for(let d=1;d<=r;d++)for(let p=1;p<=s;p++){const m=(s+1)*d+p-1,g=(s+1)*(d-1)+p-1,y=(s+1)*(d-1)+p,b=(s+1)*d+p;o.push(m,g,b),o.push(g,y,b)}this.setIndex(o),this.setAttribute("position",new Xt(a,3)),this.setAttribute("normal",new Xt(l,3)),this.setAttribute("uv",new Xt(c,2))}}class UA extends un{constructor(e=1,t=.4,r=64,s=8,i=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:s,p:i,q:o},r=Math.floor(r),s=Math.floor(s);const a=[],l=[],c=[],u=[],h=new Q,f=new Q,d=new Q,p=new Q,m=new Q,g=new Q,y=new Q;for(let x=0;x<=r;++x){const w=x/r*i*Math.PI*2;b(w,i,o,e,d),b(w+.01,i,o,e,p),g.subVectors(p,d),y.addVectors(p,d),m.crossVectors(g,y),y.crossVectors(m,g),m.normalize(),y.normalize();for(let S=0;S<=s;++S){const C=S/s*Math.PI*2,k=-t*Math.cos(C),A=t*Math.sin(C);h.x=d.x+(k*y.x+A*m.x),h.y=d.y+(k*y.y+A*m.y),h.z=d.z+(k*y.z+A*m.z),l.push(h.x,h.y,h.z),f.subVectors(h,d).normalize(),c.push(f.x,f.y,f.z),u.push(x/r),u.push(S/s)}}for(let x=1;x<=r;x++)for(let w=1;w<=s;w++){const S=(s+1)*(x-1)+(w-1),C=(s+1)*x+(w-1),k=(s+1)*x+w,A=(s+1)*(x-1)+w;a.push(S,C,A),a.push(C,k,A)}this.setIndex(a),this.setAttribute("position",new Xt(l,3)),this.setAttribute("normal",new Xt(c,3)),this.setAttribute("uv",new Xt(u,2));function b(x,w,S,C,k){const A=Math.cos(x),M=Math.sin(x),E=S/w*x,N=Math.cos(E);k.x=C*(2+N)*.5*A,k.y=C*(2+N)*M*.5,k.z=C*Math.sin(E)*.5}}}class WA extends un{constructor(e,t=64,r=1,s=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:s,closed:i};const o=e.computeFrenetFrames(t,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new Q,l=new Q,c=new st;let u=new Q;const h=[],f=[],d=[],p=[];m(),this.setIndex(p),this.setAttribute("position",new Xt(h,3)),this.setAttribute("normal",new Xt(f,3)),this.setAttribute("uv",new Xt(d,2));function m(){for(let x=0;x<t;x++)g(x);g(i===!1?t:0),b(),y()}function g(x){u=e.getPointAt(x/t,u);const w=o.normals[x],S=o.binormals[x];for(let C=0;C<=s;C++){const k=C/s*Math.PI*2,A=Math.sin(k),M=-Math.cos(k);l.x=M*w.x+A*S.x,l.y=M*w.y+A*S.y,l.z=M*w.z+A*S.z,l.normalize(),f.push(l.x,l.y,l.z),a.x=u.x+r*l.x,a.y=u.y+r*l.y,a.z=u.z+r*l.z,h.push(a.x,a.y,a.z)}}function y(){for(let x=1;x<=t;x++)for(let w=1;w<=s;w++){const S=(s+1)*(x-1)+(w-1),C=(s+1)*x+(w-1),k=(s+1)*x+w,A=(s+1)*(x-1)+w;p.push(S,C,A),p.push(C,k,A)}}function b(){for(let x=0;x<=t;x++)for(let w=0;w<=s;w++)c.x=x/t,c.y=w/s,d.push(c.x,c.y)}}toJSON(){const e=un.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class pV extends un{constructor(e){if(super(),this.type="WireframeGeometry",e.isGeometry===!0){console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return}const t=[],r=[0,0],s={},i=new Q;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const h=l[c],f=h.start,d=h.count;for(let p=f,m=f+d;p<m;p+=3)for(let g=0;g<3;g++){const y=a.getX(p+g),b=a.getX(p+(g+1)%3);r[0]=Math.min(y,b),r[1]=Math.max(y,b);const x=r[0]+","+r[1];s[x]===void 0&&(s[x]={index1:r[0],index2:r[1]})}}for(const c in s){const u=s[c];i.fromBufferAttribute(o,u.index1),t.push(i.x,i.y,i.z),i.fromBufferAttribute(o,u.index2),t.push(i.x,i.y,i.z)}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c;i.fromBufferAttribute(o,u),t.push(i.x,i.y,i.z);const h=3*a+(c+1)%3;i.fromBufferAttribute(o,h),t.push(i.x,i.y,i.z)}}this.setAttribute("position",new Xt(t,3))}}var ca=Object.freeze({__proto__:null,BoxGeometry:xg,BoxBufferGeometry:xg,CircleGeometry:RA,CircleBufferGeometry:RA,ConeGeometry:PA,ConeBufferGeometry:PA,CylinderGeometry:yv,CylinderBufferGeometry:yv,DodecahedronGeometry:DA,DodecahedronBufferGeometry:DA,EdgesGeometry:dV,ExtrudeGeometry:Sg,ExtrudeBufferGeometry:Sg,IcosahedronGeometry:OA,IcosahedronBufferGeometry:OA,LatheGeometry:FA,LatheBufferGeometry:FA,OctahedronGeometry:AS,OctahedronBufferGeometry:AS,ParametricGeometry:Cg,ParametricBufferGeometry:Cg,PlaneGeometry:bS,PlaneBufferGeometry:bS,PolyhedronGeometry:vp,PolyhedronBufferGeometry:vp,RingGeometry:LA,RingBufferGeometry:LA,ShapeGeometry:MS,ShapeBufferGeometry:MS,SphereGeometry:NS,SphereBufferGeometry:NS,TetrahedronGeometry:zA,TetrahedronBufferGeometry:zA,TextGeometry:BA,TextBufferGeometry:BA,TorusGeometry:VA,TorusBufferGeometry:VA,TorusKnotGeometry:UA,TorusKnotBufferGeometry:UA,TubeGeometry:WA,TubeBufferGeometry:WA,WireframeGeometry:pV});function kg(n){kn.call(this),this.type="ShadowMaterial",this.color=new Ht(0),this.transparent=!0,this.setValues(n)}kg.prototype=Object.create(kn.prototype);kg.prototype.constructor=kg;kg.prototype.isShadowMaterial=!0;kg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this};function Df(n){Ca.call(this,n),this.type="RawShaderMaterial"}Df.prototype=Object.create(Ca.prototype);Df.prototype.constructor=Df;Df.prototype.isRawShaderMaterial=!0;function Eh(n){kn.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ht(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(n)}Eh.prototype=Object.create(kn.prototype);Eh.prototype.constructor=Eh;Eh.prototype.isMeshStandardMaterial=!0;Eh.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this.vertexTangents=n.vertexTangents,this};function xp(n){Eh.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new st(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=In.clamp(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(n)}xp.prototype=Object.create(Eh.prototype);xp.prototype.constructor=xp;xp.prototype.isMeshPhysicalMaterial=!0;xp.prototype.copy=function(n){return Eh.prototype.copy.call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.reflectivity=n.reflectivity,n.sheen?this.sheen=(this.sheen||new Ht).copy(n.sheen):this.sheen=null,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this};function _p(n){kn.call(this),this.type="MeshPhongMaterial",this.color=new Ht(16777215),this.specular=new Ht(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=LC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}_p.prototype=Object.create(kn.prototype);_p.prototype.constructor=_p;_p.prototype.isMeshPhongMaterial=!0;_p.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Tg(n){kn.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ht(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Tg.prototype=Object.create(kn.prototype);Tg.prototype.constructor=Tg;Tg.prototype.isMeshToonMaterial=!0;Tg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Eg(n){kn.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Eg.prototype=Object.create(kn.prototype);Eg.prototype.constructor=Eg;Eg.prototype.isMeshNormalMaterial=!0;Eg.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ig(n){kn.call(this),this.type="MeshLambertMaterial",this.color=new Ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=LC,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Ig.prototype=Object.create(kn.prototype);Ig.prototype.constructor=Ig;Ig.prototype.isMeshLambertMaterial=!0;Ig.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Ag(n){kn.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ht(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zy,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(n)}Ag.prototype=Object.create(kn.prototype);Ag.prototype.constructor=Ag;Ag.prototype.isMeshMatcapMaterial=!0;Ag.prototype.copy=function(n){return kn.prototype.copy.call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.skinning=n.skinning,this.morphTargets=n.morphTargets,this.morphNormals=n.morphNormals,this};function Mg(n){Es.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(n)}Mg.prototype=Object.create(Es.prototype);Mg.prototype.constructor=Mg;Mg.prototype.isLineDashedMaterial=!0;Mg.prototype.copy=function(n){return Es.prototype.copy.call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this};var L0t=Object.freeze({__proto__:null,ShadowMaterial:kg,SpriteMaterial:bp,RawShaderMaterial:Df,ShaderMaterial:Ca,PointsMaterial:Tu,MeshPhysicalMaterial:xp,MeshStandardMaterial:Eh,MeshPhongMaterial:_p,MeshToonMaterial:Tg,MeshNormalMaterial:Eg,MeshLambertMaterial:Ig,MeshDepthMaterial:mp,MeshDistanceMaterial:gp,MeshBasicMaterial:Rl,MeshMatcapMaterial:Ag,LineDashedMaterial:Mg,LineBasicMaterial:Es,Material:kn});const ps={arraySlice:function(n,e,t){return ps.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(s,i){return n[s]-n[i]}const t=n.length,r=new Array(t);for(let s=0;s!==t;++s)r[s]=s;return r.sort(e),r},sortedArray:function(n,e,t){const r=n.length,s=new n.constructor(r);for(let i=0,o=0;o!==r;++i){const a=t[i]*e;for(let l=0;l!==e;++l)s[o++]=n[a+l]}return s},flattenJSON:function(n,e,t,r){let s=1,i=n[0];for(;i!==void 0&&i[r]===void 0;)i=n[s++];if(i===void 0)return;let o=i[r];if(o!==void 0)if(Array.isArray(o))do o=i[r],o!==void 0&&(e.push(i.time),t.push.apply(t,o)),i=n[s++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[r],o!==void 0&&(e.push(i.time),o.toArray(t,t.length)),i=n[s++];while(i!==void 0);else do o=i[r],o!==void 0&&(e.push(i.time),t.push(o)),i=n[s++];while(i!==void 0)},subclip:function(n,e,t,r,s=30){const i=n.clone();i.name=e;const o=[];for(let l=0;l<i.tracks.length;++l){const c=i.tracks[l],u=c.getValueSize(),h=[],f=[];for(let d=0;d<c.times.length;++d){const p=c.times[d]*s;if(!(p<t||p>=r)){h.push(c.times[d]);for(let m=0;m<u;++m)f.push(c.values[d*u+m])}}h.length!==0&&(c.times=ps.convertArray(h,c.times.constructor),c.values=ps.convertArray(f,c.values.constructor),o.push(c))}i.tracks=o;let a=1/0;for(let l=0;l<i.tracks.length;++l)a>i.tracks[l].times[0]&&(a=i.tracks[l].times[0]);for(let l=0;l<i.tracks.length;++l)i.tracks[l].shift(-1*a);return i.resetDuration(),i},makeClipAdditive:function(n,e=0,t=n,r=30){r<=0&&(r=30);const s=t.tracks.length,i=e/r;for(let o=0;o<s;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(y){return y.name===a.name&&y.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let f=0;const d=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=d/3);const p=a.times.length-1;let m;if(i<=a.times[0]){const y=u,b=h-u;m=ps.arraySlice(a.values,y,b)}else if(i>=a.times[p]){const y=p*h+u,b=y+h-u;m=ps.arraySlice(a.values,y,b)}else{const y=a.createInterpolant(),b=u,x=h-u;y.evaluate(i),m=ps.arraySlice(y.resultBuffer,b,x)}l==="quaternion"&&new co().fromArray(m).normalize().conjugate().toArray(m);const g=c.times.length;for(let y=0;y<g;++y){const b=y*d+f;if(l==="quaternion")co.multiplyQuaternionsFlat(c.values,b,m,0,c.values,b);else{const x=d-f*2;for(let w=0;w<x;++w)c.values[b+w]-=m[w]}}}return n.blendMode=iV,n}};function Il(n,e,t,r){this.parameterPositions=n,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new e.constructor(t),this.sampleValues=e,this.valueSize=t}Object.assign(Il.prototype,{evaluate:function(n){const e=this.parameterPositions;let t=this._cachedIndex,r=e[t],s=e[t-1];e:{t:{let i;n:{r:if(!(n<r)){for(let o=t+2;;){if(r===void 0){if(n<s)break r;return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,n,s)}if(t===o)break;if(s=r,r=e[++t],n<r)break t}i=e.length;break n}if(!(n>=s)){const o=e[1];n<o&&(t=2,s=o);for(let a=t-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(t===a)break;if(r=s,s=e[--t-1],n>=s)break t}i=t,t=0;break n}break e}for(;t<i;){const o=t+i>>>1;n<e[o]?i=o:t=o+1}if(r=e[t],s=e[t-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,n,r);if(r===void 0)return t=e.length,this._cachedIndex=t,this.afterEnd_(t-1,s,n)}this._cachedIndex=t,this.intervalChanged_(t,s,r)}return this.interpolate_(t,s,n,r)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(n){const e=this.resultBuffer,t=this.sampleValues,r=this.valueSize,s=n*r;for(let i=0;i!==r;++i)e[i]=t[s+i];return e},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Il.prototype,{beforeStart_:Il.prototype.copySampleValue_,afterEnd_:Il.prototype.copySampleValue_});function GA(n,e,t,r){Il.call(this,n,e,t,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}GA.prototype=Object.assign(Object.create(Il.prototype),{constructor:GA,DefaultSettings_:{endingStart:Wm,endingEnd:Wm},intervalChanged_:function(n,e,t){const r=this.parameterPositions;let s=n-2,i=n+1,o=r[s],a=r[i];if(o===void 0)switch(this.getSettings_().endingStart){case Gm:s=n,o=2*e-t;break;case uS:s=r.length-2,o=e+r[s]-r[s+1];break;default:s=n,o=t}if(a===void 0)switch(this.getSettings_().endingEnd){case Gm:i=n,a=2*t-e;break;case uS:i=1,a=t+r[1]-r[0];break;default:i=n-1,a=e}const l=(t-e)*.5,c=this.valueSize;this._weightPrev=l/(e-o),this._weightNext=l/(a-t),this._offsetPrev=s*c,this._offsetNext=i*c},interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=this._offsetPrev,u=this._offsetNext,h=this._weightPrev,f=this._weightNext,d=(t-e)/(r-e),p=d*d,m=p*d,g=-h*m+2*h*p-h*d,y=(1+h)*m+(-1.5-2*h)*p+(-.5+h)*d+1,b=(-1-f)*m+(1.5+f)*p+.5*d,x=f*m-f*p;for(let w=0;w!==o;++w)s[w]=g*i[c+w]+y*i[l+w]+b*i[a+w]+x*i[u+w];return s}});function $S(n,e,t,r){Il.call(this,n,e,t,r)}$S.prototype=Object.assign(Object.create(Il.prototype),{constructor:$S,interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=n*o,l=a-o,c=(t-e)/(r-e),u=1-c;for(let h=0;h!==o;++h)s[h]=i[l+h]*u+i[a+h]*c;return s}});function HA(n,e,t,r){Il.call(this,n,e,t,r)}HA.prototype=Object.assign(Object.create(Il.prototype),{constructor:HA,interpolate_:function(n){return this.copySampleValue_(n-1)}});function Co(n,e,t,r){if(n===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+n);this.name=n,this.times=ps.convertArray(e,this.TimeBufferType),this.values=ps.convertArray(t,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}Object.assign(Co,{toJSON:function(n){const e=n.constructor;let t;if(e.toJSON!==void 0)t=e.toJSON(n);else{t={name:n.name,times:ps.convertArray(n.times,Array),values:ps.convertArray(n.values,Array)};const r=n.getInterpolation();r!==n.DefaultInterpolation&&(t.interpolation=r)}return t.type=n.ValueTypeName,t}});Object.assign(Co.prototype,{constructor:Co,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:a_,InterpolantFactoryMethodDiscrete:function(n){return new HA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodLinear:function(n){return new $S(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:function(n){return new GA(this.times,this.values,this.getValueSize(),n)},setInterpolation:function(n){let e;switch(n){case cS:e=this.InterpolantFactoryMethodDiscrete;break;case a_:e=this.InterpolantFactoryMethodLinear;break;case nI:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(n!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return cS;case this.InterpolantFactoryMethodLinear:return a_;case this.InterpolantFactoryMethodSmooth:return nI}},getValueSize:function(){return this.values.length/this.times.length},shift:function(n){if(n!==0){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]+=n}return this},scale:function(n){if(n!==1){const e=this.times;for(let t=0,r=e.length;t!==r;++t)e[t]*=n}return this},trim:function(n,e){const t=this.times,r=t.length;let s=0,i=r-1;for(;s!==r&&t[s]<n;)++s;for(;i!==-1&&t[i]>e;)--i;if(++i,s!==0||i!==r){s>=i&&(i=Math.max(i,1),s=i-1);const o=this.getValueSize();this.times=ps.arraySlice(t,s,i),this.values=ps.arraySlice(this.values,s*o,i*o)}return this},validate:function(){let n=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);const t=this.times,r=this.values,s=t.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);let i=null;for(let o=0;o!==s;o++){const a=t[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),n=!1;break}if(i!==null&&i>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,i),n=!1;break}i=a}if(r!==void 0&&ps.isTypedArray(r))for(let o=0,a=r.length;o!==a;++o){const l=r[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),n=!1;break}}return n},optimize:function(){const n=ps.arraySlice(this.times),e=ps.arraySlice(this.values),t=this.getValueSize(),r=this.getInterpolation()===nI,s=n.length-1;let i=1;for(let o=1;o<s;++o){let a=!1;const l=n[o],c=n[o+1];if(l!==c&&(o!==1||l!==n[0]))if(r)a=!0;else{const u=o*t,h=u-t,f=u+t;for(let d=0;d!==t;++d){const p=e[u+d];if(p!==e[h+d]||p!==e[f+d]){a=!0;break}}}if(a){if(o!==i){n[i]=n[o];const u=o*t,h=i*t;for(let f=0;f!==t;++f)e[h+f]=e[u+f]}++i}}if(s>0){n[i]=n[s];for(let o=s*t,a=i*t,l=0;l!==t;++l)e[a+l]=e[o+l];++i}return i!==n.length?(this.times=ps.arraySlice(n,0,i),this.values=ps.arraySlice(e,0,i*t)):(this.times=n,this.values=e),this},clone:function(){const n=ps.arraySlice(this.times,0),e=ps.arraySlice(this.values,0),t=this.constructor,r=new t(this.name,n,e);return r.createInterpolant=this.createInterpolant,r}});function jA(n,e,t){Co.call(this,n,e,t)}jA.prototype=Object.assign(Object.create(Co.prototype),{constructor:jA,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:cS,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function qA(n,e,t,r){Co.call(this,n,e,t,r)}qA.prototype=Object.assign(Object.create(Co.prototype),{constructor:qA,ValueTypeName:"color"});function bv(n,e,t,r){Co.call(this,n,e,t,r)}bv.prototype=Object.assign(Object.create(Co.prototype),{constructor:bv,ValueTypeName:"number"});function XA(n,e,t,r){Il.call(this,n,e,t,r)}XA.prototype=Object.assign(Object.create(Il.prototype),{constructor:XA,interpolate_:function(n,e,t,r){const s=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=(t-e)/(r-e);let l=n*o;for(let c=l+o;l!==c;l+=4)co.slerpFlat(s,0,i,l-o,i,l,a);return s}});function RS(n,e,t,r){Co.call(this,n,e,t,r)}RS.prototype=Object.assign(Object.create(Co.prototype),{constructor:RS,ValueTypeName:"quaternion",DefaultInterpolation:a_,InterpolantFactoryMethodLinear:function(n){return new XA(this.times,this.values,this.getValueSize(),n)},InterpolantFactoryMethodSmooth:void 0});function KA(n,e,t,r){Co.call(this,n,e,t,r)}KA.prototype=Object.assign(Object.create(Co.prototype),{constructor:KA,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:cS,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function vv(n,e,t,r){Co.call(this,n,e,t,r)}vv.prototype=Object.assign(Object.create(Co.prototype),{constructor:vv,ValueTypeName:"vector"});function wl(n,e=-1,t,r=M$){this.name=n,this.tracks=t,this.duration=e,this.blendMode=r,this.uuid=In.generateUUID(),this.duration<0&&this.resetDuration()}function z0t(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return bv;case"vector":case"vector2":case"vector3":case"vector4":return vv;case"color":return qA;case"quaternion":return RS;case"bool":case"boolean":return jA;case"string":return KA}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function B0t(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=z0t(n.type);if(n.times===void 0){const t=[],r=[];ps.flattenJSON(n.keys,t,r,"value"),n.times=t,n.values=r}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}Object.assign(wl,{parse:function(n){const e=[],t=n.tracks,r=1/(n.fps||1);for(let i=0,o=t.length;i!==o;++i)e.push(B0t(t[i]).scale(r));const s=new wl(n.name,n.duration,e,n.blendMode);return s.uuid=n.uuid,s},toJSON:function(n){const e=[],t=n.tracks,r={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode};for(let s=0,i=t.length;s!==i;++s)e.push(Co.toJSON(t[s]));return r},CreateFromMorphTargetSequence:function(n,e,t,r){const s=e.length,i=[];for(let o=0;o<s;o++){let a=[],l=[];a.push((o+s-1)%s,o,(o+1)%s),l.push(0,1,0);const c=ps.getKeyframeOrder(a);a=ps.sortedArray(a,1,c),l=ps.sortedArray(l,1,c),!r&&a[0]===0&&(a.push(s),l.push(l[0])),i.push(new bv(".morphTargetInfluences["+e[o].name+"]",a,l).scale(1/t))}return new wl(n,-1,i)},findByName:function(n,e){let t=n;if(!Array.isArray(n)){const r=n;t=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<t.length;r++)if(t[r].name===e)return t[r];return null},CreateClipsFromMorphTargetSequences:function(n,e,t){const r={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,a=n.length;o<a;o++){const l=n[o],c=l.name.match(s);if(c&&c.length>1){const u=c[1];let h=r[u];h||(r[u]=h=[]),h.push(l)}}const i=[];for(const o in r)i.push(wl.CreateFromMorphTargetSequence(o,r[o],e,t));return i},parseAnimation:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(u,h,f,d,p){if(f.length!==0){const m=[],g=[];ps.flattenJSON(f,m,g,d),m.length!==0&&p.push(new u(h,m,g))}},r=[],s=n.name||"default",i=n.fps||30,o=n.blendMode;let a=n.length||-1;const l=n.hierarchy||[];for(let u=0;u<l.length;u++){const h=l[u].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const f={};let d;for(d=0;d<h.length;d++)if(h[d].morphTargets)for(let p=0;p<h[d].morphTargets.length;p++)f[h[d].morphTargets[p]]=-1;for(const p in f){const m=[],g=[];for(let y=0;y!==h[d].morphTargets.length;++y){const b=h[d];m.push(b.time),g.push(b.morphTarget===p?1:0)}r.push(new bv(".morphTargetInfluence["+p+"]",m,g))}a=f.length*(i||1)}else{const f=".bones["+e[u].name+"]";t(vv,f+".position",h,"pos",r),t(RS,f+".quaternion",h,"rot",r),t(vv,f+".scale",h,"scl",r)}}return r.length===0?null:new wl(s,a,r,o)}});Object.assign(wl.prototype,{resetDuration:function(){const n=this.tracks;let e=0;for(let t=0,r=n.length;t!==r;++t){const s=this.tracks[t];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this},trim:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this},validate:function(){let n=!0;for(let e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n},optimize:function(){for(let n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this},clone:function(){const n=[];for(let e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new wl(this.name,this.duration,n,this.blendMode)},toJSON:function(){return wl.toJSON(this)}});const Ng={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};function mV(n,e,t){const r=this;let s=!1,i=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=n,this.onProgress=e,this.onError=t,this.itemStart=function(c){o++,s===!1&&r.onStart!==void 0&&r.onStart(c,i,o),s=!0},this.itemEnd=function(c){i++,r.onProgress!==void 0&&r.onProgress(c,i,o),i===o&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(c){r.onError!==void 0&&r.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,u){return l.push(c,u),this},this.removeHandler=function(c){const u=l.indexOf(c);return u!==-1&&l.splice(u,2),this},this.getHandler=function(c){for(let u=0,h=l.length;u<h;u+=2){const f=l[u],d=l[u+1];if(f.global&&(f.lastIndex=0),f.test(c))return d}return null}}const Nle=new mV;function zr(n){this.manager=n!==void 0?n:Nle,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(zr.prototype,{load:function(){},loadAsync:function(n,e){const t=this;return new Promise(function(r,s){t.load(n,r,e,s)})},parse:function(){},setCrossOrigin:function(n){return this.crossOrigin=n,this},setWithCredentials:function(n){return this.withCredentials=n,this},setPath:function(n){return this.path=n,this},setResourcePath:function(n){return this.resourcePath=n,this},setRequestHeader:function(n){return this.requestHeader=n,this}});const Qc={};function Nc(n){zr.call(this,n)}Nc.prototype=Object.assign(Object.create(zr.prototype),{constructor:Nc,load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Ng.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;if(Qc[n]!==void 0){Qc[n].push({onLoad:e,onProgress:t,onError:r});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=n.match(o);let l;if(a){const c=a[1],u=!!a[2];let h=a[3];h=decodeURIComponent(h),u&&(h=atob(h));try{let f;const d=(this.responseType||"").toLowerCase();switch(d){case"arraybuffer":case"blob":const p=new Uint8Array(h.length);for(let g=0;g<h.length;g++)p[g]=h.charCodeAt(g);d==="blob"?f=new Blob([p.buffer],{type:c}):f=p.buffer;break;case"document":f=new DOMParser().parseFromString(h,c);break;case"json":f=JSON.parse(h);break;default:f=h;break}setTimeout(function(){e&&e(f),s.manager.itemEnd(n)},0)}catch(f){setTimeout(function(){r&&r(f),s.manager.itemError(n),s.manager.itemEnd(n)},0)}}else{Qc[n]=[],Qc[n].push({onLoad:e,onProgress:t,onError:r}),l=new XMLHttpRequest,l.open("GET",n,!0),l.addEventListener("load",function(c){const u=this.response,h=Qc[n];if(delete Qc[n],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Ng.add(n,u);for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onLoad&&p.onLoad(u)}s.manager.itemEnd(n)}else{for(let f=0,d=h.length;f<d;f++){const p=h[f];p.onError&&p.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)}},!1),l.addEventListener("progress",function(c){const u=Qc[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onProgress&&d.onProgress(c)}},!1),l.addEventListener("error",function(c){const u=Qc[n];delete Qc[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)},!1),l.addEventListener("abort",function(c){const u=Qc[n];delete Qc[n];for(let h=0,f=u.length;h<f;h++){const d=u[h];d.onError&&d.onError(c)}s.manager.itemError(n),s.manager.itemEnd(n)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return s.manager.itemStart(n),l},setResponseType:function(n){return this.responseType=n,this},setMimeType:function(n){return this.mimeType=n,this}});function GF(n){zr.call(this,n)}GF.prototype=Object.assign(Object.create(zr.prototype),{constructor:GF,load:function(n,e,t,r){const s=this,i=new Nc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e=[];for(let t=0;t<n.length;t++){const r=wl.parse(n[t]);e.push(r)}return e}});function HF(n){zr.call(this,n)}HF.prototype=Object.assign(Object.create(zr.prototype),{constructor:HF,load:function(n,e,t,r){const s=this,i=[],o=new gv,a=new Nc(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(s.withCredentials);let l=0;function c(u){a.load(n[u],function(h){const f=s.parse(h,!0);i[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},l+=1,l===6&&(f.mipmapCount===1&&(o.minFilter=lo),o.image=i,o.format=f.format,o.needsUpdate=!0,e&&e(o))},t,r)}if(Array.isArray(n))for(let u=0,h=n.length;u<h;++u)c(u);else a.load(n,function(u){const h=s.parse(u,!0);if(h.isCubemap){const f=h.mipmaps.length/h.mipmapCount;for(let d=0;d<f;d++){i[d]={mipmaps:[]};for(let p=0;p<h.mipmapCount;p++)i[d].mipmaps.push(h.mipmaps[d*h.mipmapCount+p]),i[d].format=h.format,i[d].width=h.width,i[d].height=h.height}o.image=i}else o.image.width=h.width,o.image.height=h.height,o.mipmaps=h.mipmaps;h.mipmapCount===1&&(o.minFilter=lo),o.format=h.format,o.needsUpdate=!0,e&&e(o)},t,r);return o}});function wv(n){zr.call(this,n)}wv.prototype=Object.assign(Object.create(zr.prototype),{constructor:wv,load:function(n,e,t,r){this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Ng.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),Ng.add(n,this),e&&e(this),s.manager.itemEnd(n)}function l(c){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),r&&r(c),s.manager.itemError(n),s.manager.itemEnd(n)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),n.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(n),o.src=n,o}});function YA(n){zr.call(this,n)}YA.prototype=Object.assign(Object.create(zr.prototype),{constructor:YA,load:function(n,e,t,r){const s=new Th,i=new wv(this.manager);i.setCrossOrigin(this.crossOrigin),i.setPath(this.path);let o=0;function a(l){i.load(n[l],function(c){s.images[l]=c,o++,o===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let l=0;l<n.length;++l)a(l);return s}});function ZA(n){zr.call(this,n)}ZA.prototype=Object.assign(Object.create(zr.prototype),{constructor:ZA,load:function(n,e,t,r){const s=this,i=new Pf,o=new Nc(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(s.withCredentials),o.load(n,function(a){const l=s.parse(a);l&&(l.image!==void 0?i.image=l.image:l.data!==void 0&&(i.image.width=l.width,i.image.height=l.height,i.image.data=l.data),i.wrapS=l.wrapS!==void 0?l.wrapS:da,i.wrapT=l.wrapT!==void 0?l.wrapT:da,i.magFilter=l.magFilter!==void 0?l.magFilter:lo,i.minFilter=l.minFilter!==void 0?l.minFilter:lo,i.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.encoding!==void 0&&(i.encoding=l.encoding),l.flipY!==void 0&&(i.flipY=l.flipY),l.format!==void 0&&(i.format=l.format),l.type!==void 0&&(i.type=l.type),l.mipmaps!==void 0&&(i.mipmaps=l.mipmaps,i.minFilter=ix),l.mipmapCount===1&&(i.minFilter=lo),i.needsUpdate=!0,e&&e(i,l))},t,r),i}});function JA(n){zr.call(this,n)}JA.prototype=Object.assign(Object.create(zr.prototype),{constructor:JA,load:function(n,e,t,r){const s=new Kr,i=new wv(this.manager);return i.setCrossOrigin(this.crossOrigin),i.setPath(this.path),i.load(n,function(o){s.image=o;const a=n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0;s.format=a?Kd:El,s.needsUpdate=!0,e!==void 0&&e(s)},t,r),s}});function on(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(on.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(n,e){const t=this.getUtoTmapping(n);return this.getPoint(t,e)},getPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return e},getSpacedPoints:function(n=5){const e=[];for(let t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e},getLength:function(){const n=this.getLengths();return n[n.length-1]},getLengths:function(n){if(n===void 0&&(n=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let t,r=this.getPoint(0),s=0;e.push(0);for(let i=1;i<=n;i++)t=this.getPoint(i/n),s+=t.distanceTo(r),e.push(s),r=t;return this.cacheArcLengths=e,e},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(n,e){const t=this.getLengths();let r=0;const s=t.length;let i;e?i=e:i=n*t[s-1];let o=0,a=s-1,l;for(;o<=a;)if(r=Math.floor(o+(a-o)/2),l=t[r]-i,l<0)o=r+1;else if(l>0)a=r-1;else{a=r;break}if(r=a,t[r]===i)return r/(s-1);const c=t[r],h=t[r+1]-c,f=(i-c)/h;return(r+f)/(s-1)},getTangent:function(n,e){let r=n-1e-4,s=n+1e-4;r<0&&(r=0),s>1&&(s=1);const i=this.getPoint(r),o=this.getPoint(s),a=e||(i.isVector2?new st:new Q);return a.copy(o).sub(i).normalize(),a},getTangentAt:function(n,e){const t=this.getUtoTmapping(n);return this.getTangent(t,e)},computeFrenetFrames:function(n,e){const t=new Q,r=[],s=[],i=[],o=new Q,a=new Zn;for(let f=0;f<=n;f++){const d=f/n;r[f]=this.getTangentAt(d,new Q),r[f].normalize()}s[0]=new Q,i[0]=new Q;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),u=Math.abs(r[0].y),h=Math.abs(r[0].z);c<=l&&(l=c,t.set(1,0,0)),u<=l&&(l=u,t.set(0,1,0)),h<=l&&t.set(0,0,1),o.crossVectors(r[0],t).normalize(),s[0].crossVectors(r[0],o),i[0].crossVectors(r[0],s[0]);for(let f=1;f<=n;f++){if(s[f]=s[f-1].clone(),i[f]=i[f-1].clone(),o.crossVectors(r[f-1],r[f]),o.length()>Number.EPSILON){o.normalize();const d=Math.acos(In.clamp(r[f-1].dot(r[f]),-1,1));s[f].applyMatrix4(a.makeRotationAxis(o,d))}i[f].crossVectors(r[f],s[f])}if(e===!0){let f=Math.acos(In.clamp(s[0].dot(s[n]),-1,1));f/=n,r[0].dot(o.crossVectors(s[0],s[n]))>0&&(f=-f);for(let d=1;d<=n;d++)s[d].applyMatrix4(a.makeRotationAxis(r[d],f*d)),i[d].crossVectors(r[d],s[d])}return{tangents:r,normals:s,binormals:i}},clone:function(){return new this.constructor().copy(this)},copy:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this},toJSON:function(){const n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n},fromJSON:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}});function Dl(n,e,t,r,s,i,o,a){on.call(this),this.type="EllipseCurve",this.aX=n||0,this.aY=e||0,this.xRadius=t||1,this.yRadius=r||1,this.aStartAngle=s||0,this.aEndAngle=i||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}Dl.prototype=Object.create(on.prototype);Dl.prototype.constructor=Dl;Dl.prototype.isEllipseCurve=!0;Dl.prototype.getPoint=function(n,e){const t=e||new st,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const i=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(i?s=0:s=r),this.aClockwise===!0&&!i&&(s===r?s=-r:s=s-r);const o=this.aStartAngle+n*s;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),u=Math.sin(this.aRotation),h=a-this.aX,f=l-this.aY;a=h*c-f*u+this.aX,l=h*u+f*c+this.aY}return t.set(a,l)};Dl.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};Dl.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n};Dl.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this};function xv(n,e,t,r,s,i){Dl.call(this,n,e,t,t,r,s,i),this.type="ArcCurve"}xv.prototype=Object.create(Dl.prototype);xv.prototype.constructor=xv;xv.prototype.isArcCurve=!0;function gV(){let n=0,e=0,t=0,r=0;function s(i,o,a,l){n=i,e=a,t=-3*i+3*o-2*a-l,r=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,c){s(o,a,c*(a-i),c*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,c,u,h){let f=(o-i)/c-(a-i)/(c+u)+(a-o)/u,d=(a-o)/u-(l-o)/(u+h)+(l-a)/h;f*=u,d*=u,s(o,a,f,d)},calc:function(i){const o=i*i,a=o*i;return n+e*i+t*o+r*a}}}const fE=new Q,NP=new gV,$P=new gV,RP=new gV;function Qo(n=[],e=!1,t="centripetal",r=.5){on.call(this),this.type="CatmullRomCurve3",this.points=n,this.closed=e,this.curveType=t,this.tension=r}Qo.prototype=Object.create(on.prototype);Qo.prototype.constructor=Qo;Qo.prototype.isCatmullRomCurve3=!0;Qo.prototype.getPoint=function(n,e=new Q){const t=e,r=this.points,s=r.length,i=(s-(this.closed?0:1))*n;let o=Math.floor(i),a=i-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/s)+1)*s:a===0&&o===s-1&&(o=s-2,a=1);let l,c;this.closed||o>0?l=r[(o-1)%s]:(fE.subVectors(r[0],r[1]).add(r[0]),l=fE);const u=r[o%s],h=r[(o+1)%s];if(this.closed||o+2<s?c=r[(o+2)%s]:(fE.subVectors(r[s-1],r[s-2]).add(r[s-1]),c=fE),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let d=Math.pow(l.distanceToSquared(u),f),p=Math.pow(u.distanceToSquared(h),f),m=Math.pow(h.distanceToSquared(c),f);p<1e-4&&(p=1),d<1e-4&&(d=p),m<1e-4&&(m=p),NP.initNonuniformCatmullRom(l.x,u.x,h.x,c.x,d,p,m),$P.initNonuniformCatmullRom(l.y,u.y,h.y,c.y,d,p,m),RP.initNonuniformCatmullRom(l.z,u.z,h.z,c.z,d,p,m)}else this.curveType==="catmullrom"&&(NP.initCatmullRom(l.x,u.x,h.x,c.x,this.tension),$P.initCatmullRom(l.y,u.y,h.y,c.y,this.tension),RP.initCatmullRom(l.z,u.z,h.z,c.z,this.tension));return t.set(NP.calc(a),$P.calc(a),RP.calc(a)),t};Qo.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};Qo.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n};Qo.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new Q().fromArray(r))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this};function J8(n,e,t,r,s){const i=(r-e)*.5,o=(s-t)*.5,a=n*n,l=n*a;return(2*t-2*r+i+o)*l+(-3*t+3*r-2*i-o)*a+i*n+t}function V0t(n,e){const t=1-n;return t*t*e}function U0t(n,e){return 2*(1-n)*n*e}function W0t(n,e){return n*n*e}function c_(n,e,t,r){return V0t(n,e)+U0t(n,t)+W0t(n,r)}function G0t(n,e){const t=1-n;return t*t*t*e}function H0t(n,e){const t=1-n;return 3*t*t*n*e}function j0t(n,e){return 3*(1-n)*n*n*e}function q0t(n,e){return n*n*n*e}function u_(n,e,t,r,s){return G0t(n,e)+H0t(n,t)+j0t(n,r)+q0t(n,s)}function Eu(n=new st,e=new st,t=new st,r=new st){on.call(this),this.type="CubicBezierCurve",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Eu.prototype=Object.create(on.prototype);Eu.prototype.constructor=Eu;Eu.prototype.isCubicBezierCurve=!0;Eu.prototype.getPoint=function(n,e=new st){const t=e,r=this.v0,s=this.v1,i=this.v2,o=this.v3;return t.set(u_(n,r.x,s.x,i.x,o.x),u_(n,r.y,s.y,i.y,o.y)),t};Eu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Eu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Eu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Ih(n=new Q,e=new Q,t=new Q,r=new Q){on.call(this),this.type="CubicBezierCurve3",this.v0=n,this.v1=e,this.v2=t,this.v3=r}Ih.prototype=Object.create(on.prototype);Ih.prototype.constructor=Ih;Ih.prototype.isCubicBezierCurve3=!0;Ih.prototype.getPoint=function(n,e=new Q){const t=e,r=this.v0,s=this.v1,i=this.v2,o=this.v3;return t.set(u_(n,r.x,s.x,i.x,o.x),u_(n,r.y,s.y,i.y,o.y),u_(n,r.z,s.z,i.z,o.z)),t};Ih.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this};Ih.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n};Ih.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this};function Za(n=new st,e=new st){on.call(this),this.type="LineCurve",this.v1=n,this.v2=e}Za.prototype=Object.create(on.prototype);Za.prototype.constructor=Za;Za.prototype.isLineCurve=!0;Za.prototype.getPoint=function(n,e=new st){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Za.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Za.prototype.getTangent=function(n,e){const t=e||new st;return t.copy(this.v2).sub(this.v1).normalize(),t};Za.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Za.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Za.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Iu(n=new Q,e=new Q){on.call(this),this.type="LineCurve3",this.v1=n,this.v2=e}Iu.prototype=Object.create(on.prototype);Iu.prototype.constructor=Iu;Iu.prototype.isLineCurve3=!0;Iu.prototype.getPoint=function(n,e=new Q){const t=e;return n===1?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t};Iu.prototype.getPointAt=function(n,e){return this.getPoint(n,e)};Iu.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Iu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Iu.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Au(n=new st,e=new st,t=new st){on.call(this),this.type="QuadraticBezierCurve",this.v0=n,this.v1=e,this.v2=t}Au.prototype=Object.create(on.prototype);Au.prototype.constructor=Au;Au.prototype.isQuadraticBezierCurve=!0;Au.prototype.getPoint=function(n,e=new st){const t=e,r=this.v0,s=this.v1,i=this.v2;return t.set(c_(n,r.x,s.x,i.x),c_(n,r.y,s.y,i.y)),t};Au.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Au.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Au.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Ah(n=new Q,e=new Q,t=new Q){on.call(this),this.type="QuadraticBezierCurve3",this.v0=n,this.v1=e,this.v2=t}Ah.prototype=Object.create(on.prototype);Ah.prototype.constructor=Ah;Ah.prototype.isQuadraticBezierCurve3=!0;Ah.prototype.getPoint=function(n,e=new Q){const t=e,r=this.v0,s=this.v1,i=this.v2;return t.set(c_(n,r.x,s.x,i.x),c_(n,r.y,s.y,i.y),c_(n,r.z,s.z,i.z)),t};Ah.prototype.copy=function(n){return on.prototype.copy.call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this};Ah.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n};Ah.prototype.fromJSON=function(n){return on.prototype.fromJSON.call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this};function Mu(n=[]){on.call(this),this.type="SplineCurve",this.points=n}Mu.prototype=Object.create(on.prototype);Mu.prototype.constructor=Mu;Mu.prototype.isSplineCurve=!0;Mu.prototype.getPoint=function(n,e=new st){const t=e,r=this.points,s=(r.length-1)*n,i=Math.floor(s),o=s-i,a=r[i===0?i:i-1],l=r[i],c=r[i>r.length-2?r.length-1:i+1],u=r[i>r.length-3?r.length-1:i+2];return t.set(J8(o,a.x,l.x,c.x,u.x),J8(o,a.y,l.y,c.y,u.y)),t};Mu.prototype.copy=function(n){on.prototype.copy.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(r.clone())}return this};Mu.prototype.toJSON=function(){const n=on.prototype.toJSON.call(this);n.points=[];for(let e=0,t=this.points.length;e<t;e++){const r=this.points[e];n.points.push(r.toArray())}return n};Mu.prototype.fromJSON=function(n){on.prototype.fromJSON.call(this,n),this.points=[];for(let e=0,t=n.points.length;e<t;e++){const r=n.points[e];this.points.push(new st().fromArray(r))}return this};var jF=Object.freeze({__proto__:null,ArcCurve:xv,CatmullRomCurve3:Qo,CubicBezierCurve:Eu,CubicBezierCurve3:Ih,EllipseCurve:Dl,LineCurve:Za,LineCurve3:Iu,QuadraticBezierCurve:Au,QuadraticBezierCurve3:Ah,SplineCurve:Mu});function Bd(){on.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}Bd.prototype=Object.assign(Object.create(on.prototype),{constructor:Bd,add:function(n){this.curves.push(n)},closePath:function(){const n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new Za(e,n))},getPoint:function(n){const e=n*this.getLength(),t=this.getCurveLengths();let r=0;for(;r<t.length;){if(t[r]>=e){const s=t[r]-e,i=this.curves[r],o=i.getLength(),a=o===0?0:1-s/o;return i.getPointAt(a)}r++}return null},getLength:function(){const n=this.getCurveLengths();return n[n.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const n=[];let e=0;for(let t=0,r=this.curves.length;t<r;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n},getSpacedPoints:function(n=40){const e=[];for(let t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e},getPoints:function(n=12){const e=[];let t;for(let r=0,s=this.curves;r<s.length;r++){const i=s[r],o=i&&i.isEllipseCurve?n*2:i&&(i.isLineCurve||i.isLineCurve3)?1:i&&i.isSplineCurve?n*i.points.length:n,a=i.getPoints(o);for(let l=0;l<a.length;l++){const c=a[l];t&&t.equals(c)||(e.push(c),t=c)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e},copy:function(n){on.prototype.copy.call(this,n),this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(r.clone())}return this.autoClose=n.autoClose,this},toJSON:function(){const n=on.prototype.toJSON.call(this);n.autoClose=this.autoClose,n.curves=[];for(let e=0,t=this.curves.length;e<t;e++){const r=this.curves[e];n.curves.push(r.toJSON())}return n},fromJSON:function(n){on.prototype.fromJSON.call(this,n),this.autoClose=n.autoClose,this.curves=[];for(let e=0,t=n.curves.length;e<t;e++){const r=n.curves[e];this.curves.push(new jF[r.type]().fromJSON(r))}return this}});function au(n){Bd.call(this),this.type="Path",this.currentPoint=new st,n&&this.setFromPoints(n)}au.prototype=Object.assign(Object.create(Bd.prototype),{constructor:au,setFromPoints:function(n){this.moveTo(n[0].x,n[0].y);for(let e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this},moveTo:function(n,e){return this.currentPoint.set(n,e),this},lineTo:function(n,e){const t=new Za(this.currentPoint.clone(),new st(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this},quadraticCurveTo:function(n,e,t,r){const s=new Au(this.currentPoint.clone(),new st(n,e),new st(t,r));return this.curves.push(s),this.currentPoint.set(t,r),this},bezierCurveTo:function(n,e,t,r,s,i){const o=new Eu(this.currentPoint.clone(),new st(n,e),new st(t,r),new st(s,i));return this.curves.push(o),this.currentPoint.set(s,i),this},splineThru:function(n){const e=[this.currentPoint.clone()].concat(n),t=new Mu(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this},arc:function(n,e,t,r,s,i){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(n+o,e+a,t,r,s,i),this},absarc:function(n,e,t,r,s,i){return this.absellipse(n,e,t,t,r,s,i),this},ellipse:function(n,e,t,r,s,i,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(n+l,e+c,t,r,s,i,o,a),this},absellipse:function(n,e,t,r,s,i,o,a){const l=new Dl(n,e,t,r,s,i,o,a);if(this.curves.length>0){const u=l.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(n){return Bd.prototype.copy.call(this,n),this.currentPoint.copy(n.currentPoint),this},toJSON:function(){const n=Bd.prototype.toJSON.call(this);return n.currentPoint=this.currentPoint.toArray(),n},fromJSON:function(n){return Bd.prototype.fromJSON.call(this,n),this.currentPoint.fromArray(n.currentPoint),this}});function Jd(n){au.call(this,n),this.uuid=In.generateUUID(),this.type="Shape",this.holes=[]}Jd.prototype=Object.assign(Object.create(au.prototype),{constructor:Jd,getPointsHoles:function(n){const e=[];for(let t=0,r=this.holes.length;t<r;t++)e[t]=this.holes[t].getPoints(n);return e},extractPoints:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}},copy:function(n){au.prototype.copy.call(this,n),this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(r.clone())}return this},toJSON:function(){const n=au.prototype.toJSON.call(this);n.uuid=this.uuid,n.holes=[];for(let e=0,t=this.holes.length;e<t;e++){const r=this.holes[e];n.holes.push(r.toJSON())}return n},fromJSON:function(n){au.prototype.fromJSON.call(this,n),this.uuid=n.uuid,this.holes=[];for(let e=0,t=n.holes.length;e<t;e++){const r=n.holes[e];this.holes.push(new au().fromJSON(r))}return this}});function fs(n,e=1){rn.call(this),this.type="Light",this.color=new Ht(n),this.intensity=e}fs.prototype=Object.assign(Object.create(rn.prototype),{constructor:fs,isLight:!0,copy:function(n){return rn.prototype.copy.call(this,n),this.color.copy(n.color),this.intensity=n.intensity,this},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}});function QA(n,e,t){fs.call(this,n,t),this.type="HemisphereLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.groundColor=new Ht(e)}QA.prototype=Object.assign(Object.create(fs.prototype),{constructor:QA,isHemisphereLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.groundColor.copy(n.groundColor),this}});function Of(n){this.camera=n,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new st(512,512),this.map=null,this.mapPass=null,this.matrix=new Zn,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new GC,this._frameExtents=new st(1,1),this._viewportCount=1,this._viewports=[new Hr(0,0,1,1)]}Object.assign(Of.prototype,{_projScreenMatrix:new Zn,_lightPositionWorld:new Q,_lookTarget:new Q,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(n){const e=this.camera,t=this.matrix,r=this._projScreenMatrix,s=this._lookTarget,i=this._lightPositionWorld;i.setFromMatrixPosition(n.matrixWorld),e.position.copy(i),s.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(s),e.updateMatrixWorld(),r.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(r),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(e.projectionMatrix),t.multiply(e.matrixWorldInverse)},getViewport:function(n){return this._viewports[n]},getFrameExtents:function(){return this._frameExtents},copy:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n={};return this.bias!==0&&(n.bias=this.bias),this.normalBias!==0&&(n.normalBias=this.normalBias),this.radius!==1&&(n.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}});function qF(){Of.call(this,new Si(50,1,.5,500)),this.focus=1}qF.prototype=Object.assign(Object.create(Of.prototype),{constructor:qF,isSpotLightShadow:!0,updateMatrices:function(n){const e=this.camera,t=In.RAD2DEG*2*n.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=n.distance||e.far;(t!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=t,e.aspect=r,e.far=s,e.updateProjectionMatrix()),Of.prototype.updateMatrices.call(this,n)}});function eM(n,e,t,r,s,i){fs.call(this,n,e),this.type="SpotLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(o){this.intensity=o/Math.PI}}),this.distance=t!==void 0?t:0,this.angle=r!==void 0?r:Math.PI/3,this.penumbra=s!==void 0?s:0,this.decay=i!==void 0?i:1,this.shadow=new qF}eM.prototype=Object.assign(Object.create(fs.prototype),{constructor:eM,isSpotLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function XF(){Of.call(this,new Si(90,1,.5,500)),this._frameExtents=new st(4,2),this._viewportCount=6,this._viewports=[new Hr(2,1,1,1),new Hr(0,1,1,1),new Hr(3,1,1,1),new Hr(1,1,1,1),new Hr(3,0,1,1),new Hr(1,0,1,1)],this._cubeDirections=[new Q(1,0,0),new Q(-1,0,0),new Q(0,0,1),new Q(0,0,-1),new Q(0,1,0),new Q(0,-1,0)],this._cubeUps=[new Q(0,1,0),new Q(0,1,0),new Q(0,1,0),new Q(0,1,0),new Q(0,0,1),new Q(0,0,-1)]}XF.prototype=Object.assign(Object.create(Of.prototype),{constructor:XF,isPointLightShadow:!0,updateMatrices:function(n,e=0){const t=this.camera,r=this.matrix,s=this._lightPositionWorld,i=this._lookTarget,o=this._projScreenMatrix;s.setFromMatrixPosition(n.matrixWorld),t.position.copy(s),i.copy(t.position),i.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(i),t.updateMatrixWorld(),r.makeTranslation(-s.x,-s.y,-s.z),o.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}});function tM(n,e,t,r){fs.call(this,n,e),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(s){this.intensity=s/(4*Math.PI)}}),this.distance=t!==void 0?t:0,this.decay=r!==void 0?r:1,this.shadow=new XF}tM.prototype=Object.assign(Object.create(fs.prototype),{constructor:tM,isPointLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}});function _v(n=-1,e=1,t=1,r=-1,s=.1,i=2e3){kh.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=n,this.right=e,this.top=t,this.bottom=r,this.near=s,this.far=i,this.updateProjectionMatrix()}_v.prototype=Object.assign(Object.create(kh.prototype),{constructor:_v,isOrthographicCamera:!0,copy:function(n,e){return kh.prototype.copy.call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=n.view===null?null:Object.assign({},n.view),this},setViewOffset:function(n,e,t,r,s,i){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=s,this.view.height=i,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=t-n,i=t+n,o=r+e,a=r-e;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=l*this.view.offsetX,i=s+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(s,i,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(n){const e=rn.prototype.toJSON.call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}});function KF(){Of.call(this,new _v(-5,5,5,-5,.5,500))}KF.prototype=Object.assign(Object.create(Of.prototype),{constructor:KF,isDirectionalLightShadow:!0,updateMatrices:function(n){Of.prototype.updateMatrices.call(this,n)}});function nM(n,e){fs.call(this,n,e),this.type="DirectionalLight",this.position.copy(rn.DefaultUp),this.updateMatrix(),this.target=new rn,this.shadow=new KF}nM.prototype=Object.assign(Object.create(fs.prototype),{constructor:nM,isDirectionalLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}});function rM(n,e){fs.call(this,n,e),this.type="AmbientLight"}rM.prototype=Object.assign(Object.create(fs.prototype),{constructor:rM,isAmbientLight:!0});function sM(n,e,t,r){fs.call(this,n,e),this.type="RectAreaLight",this.width=t!==void 0?t:10,this.height=r!==void 0?r:10}sM.prototype=Object.assign(Object.create(fs.prototype),{constructor:sM,isRectAreaLight:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.width=n.width,this.height=n.height,this},toJSON:function(n){const e=fs.prototype.toJSON.call(this,n);return e.object.width=this.width,e.object.height=this.height,e}});class $le{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Q)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*s),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*r),t.addScaledVector(o[4],1.092548*(r*s)),t.addScaledVector(o[5],1.092548*(s*i)),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],1.092548*(r*i)),t.addScaledVector(o[8],.546274*(r*r-s*s)),t}getIrradianceAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*s),t.addScaledVector(o[2],2*.511664*i),t.addScaledVector(o[3],2*.511664*r),t.addScaledVector(o[4],2*.429043*r*s),t.addScaledVector(o[5],2*.429043*s*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],2*.429043*r*i),t.addScaledVector(o[8],.429043*(r*r-s*s)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].fromArray(e,t+s*3);return this}toArray(e=[],t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].toArray(e,t+s*3);return e}static getBasisAt(e,t){const r=e.x,s=e.y,i=e.z;t[0]=.282095,t[1]=.488603*s,t[2]=.488603*i,t[3]=.488603*r,t[4]=1.092548*r*s,t[5]=1.092548*s*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*r*i,t[8]=.546274*(r*r-s*s)}}function xc(n,e){fs.call(this,void 0,e),this.type="LightProbe",this.sh=n!==void 0?n:new $le}xc.prototype=Object.assign(Object.create(fs.prototype),{constructor:xc,isLightProbe:!0,copy:function(n){return fs.prototype.copy.call(this,n),this.sh.copy(n.sh),this},fromJSON:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this},toJSON:function(n){const e=fs.prototype.toJSON.call(this,n);return e.object.sh=this.sh.toArray(),e}});function iM(n){zr.call(this,n),this.textures={}}iM.prototype=Object.assign(Object.create(zr.prototype),{constructor:iM,load:function(n,e,t,r){const s=this,i=new Nc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e=this.textures;function t(s){return e[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),e[s]}const r=new L0t[n.type];if(n.uuid!==void 0&&(r.uuid=n.uuid),n.name!==void 0&&(r.name=n.name),n.color!==void 0&&r.color!==void 0&&r.color.setHex(n.color),n.roughness!==void 0&&(r.roughness=n.roughness),n.metalness!==void 0&&(r.metalness=n.metalness),n.sheen!==void 0&&(r.sheen=new Ht().setHex(n.sheen)),n.emissive!==void 0&&r.emissive!==void 0&&r.emissive.setHex(n.emissive),n.specular!==void 0&&r.specular!==void 0&&r.specular.setHex(n.specular),n.shininess!==void 0&&(r.shininess=n.shininess),n.clearcoat!==void 0&&(r.clearcoat=n.clearcoat),n.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=n.clearcoatRoughness),n.fog!==void 0&&(r.fog=n.fog),n.flatShading!==void 0&&(r.flatShading=n.flatShading),n.blending!==void 0&&(r.blending=n.blending),n.combine!==void 0&&(r.combine=n.combine),n.side!==void 0&&(r.side=n.side),n.opacity!==void 0&&(r.opacity=n.opacity),n.transparent!==void 0&&(r.transparent=n.transparent),n.alphaTest!==void 0&&(r.alphaTest=n.alphaTest),n.depthTest!==void 0&&(r.depthTest=n.depthTest),n.depthWrite!==void 0&&(r.depthWrite=n.depthWrite),n.colorWrite!==void 0&&(r.colorWrite=n.colorWrite),n.stencilWrite!==void 0&&(r.stencilWrite=n.stencilWrite),n.stencilWriteMask!==void 0&&(r.stencilWriteMask=n.stencilWriteMask),n.stencilFunc!==void 0&&(r.stencilFunc=n.stencilFunc),n.stencilRef!==void 0&&(r.stencilRef=n.stencilRef),n.stencilFuncMask!==void 0&&(r.stencilFuncMask=n.stencilFuncMask),n.stencilFail!==void 0&&(r.stencilFail=n.stencilFail),n.stencilZFail!==void 0&&(r.stencilZFail=n.stencilZFail),n.stencilZPass!==void 0&&(r.stencilZPass=n.stencilZPass),n.wireframe!==void 0&&(r.wireframe=n.wireframe),n.wireframeLinewidth!==void 0&&(r.wireframeLinewidth=n.wireframeLinewidth),n.wireframeLinecap!==void 0&&(r.wireframeLinecap=n.wireframeLinecap),n.wireframeLinejoin!==void 0&&(r.wireframeLinejoin=n.wireframeLinejoin),n.rotation!==void 0&&(r.rotation=n.rotation),n.linewidth!==1&&(r.linewidth=n.linewidth),n.dashSize!==void 0&&(r.dashSize=n.dashSize),n.gapSize!==void 0&&(r.gapSize=n.gapSize),n.scale!==void 0&&(r.scale=n.scale),n.polygonOffset!==void 0&&(r.polygonOffset=n.polygonOffset),n.polygonOffsetFactor!==void 0&&(r.polygonOffsetFactor=n.polygonOffsetFactor),n.polygonOffsetUnits!==void 0&&(r.polygonOffsetUnits=n.polygonOffsetUnits),n.skinning!==void 0&&(r.skinning=n.skinning),n.morphTargets!==void 0&&(r.morphTargets=n.morphTargets),n.morphNormals!==void 0&&(r.morphNormals=n.morphNormals),n.dithering!==void 0&&(r.dithering=n.dithering),n.vertexTangents!==void 0&&(r.vertexTangents=n.vertexTangents),n.visible!==void 0&&(r.visible=n.visible),n.toneMapped!==void 0&&(r.toneMapped=n.toneMapped),n.userData!==void 0&&(r.userData=n.userData),n.vertexColors!==void 0&&(typeof n.vertexColors=="number"?r.vertexColors=n.vertexColors>0:r.vertexColors=n.vertexColors),n.uniforms!==void 0)for(const s in n.uniforms){const i=n.uniforms[s];switch(r.uniforms[s]={},i.type){case"t":r.uniforms[s].value=t(i.value);break;case"c":r.uniforms[s].value=new Ht().setHex(i.value);break;case"v2":r.uniforms[s].value=new st().fromArray(i.value);break;case"v3":r.uniforms[s].value=new Q().fromArray(i.value);break;case"v4":r.uniforms[s].value=new Hr().fromArray(i.value);break;case"m3":r.uniforms[s].value=new _l().fromArray(i.value);break;case"m4":r.uniforms[s].value=new Zn().fromArray(i.value);break;default:r.uniforms[s].value=i.value}}if(n.defines!==void 0&&(r.defines=n.defines),n.vertexShader!==void 0&&(r.vertexShader=n.vertexShader),n.fragmentShader!==void 0&&(r.fragmentShader=n.fragmentShader),n.extensions!==void 0)for(const s in n.extensions)r.extensions[s]=n.extensions[s];if(n.shading!==void 0&&(r.flatShading=n.shading===1),n.size!==void 0&&(r.size=n.size),n.sizeAttenuation!==void 0&&(r.sizeAttenuation=n.sizeAttenuation),n.map!==void 0&&(r.map=t(n.map)),n.matcap!==void 0&&(r.matcap=t(n.matcap)),n.alphaMap!==void 0&&(r.alphaMap=t(n.alphaMap)),n.bumpMap!==void 0&&(r.bumpMap=t(n.bumpMap)),n.bumpScale!==void 0&&(r.bumpScale=n.bumpScale),n.normalMap!==void 0&&(r.normalMap=t(n.normalMap)),n.normalMapType!==void 0&&(r.normalMapType=n.normalMapType),n.normalScale!==void 0){let s=n.normalScale;Array.isArray(s)===!1&&(s=[s,s]),r.normalScale=new st().fromArray(s)}return n.displacementMap!==void 0&&(r.displacementMap=t(n.displacementMap)),n.displacementScale!==void 0&&(r.displacementScale=n.displacementScale),n.displacementBias!==void 0&&(r.displacementBias=n.displacementBias),n.roughnessMap!==void 0&&(r.roughnessMap=t(n.roughnessMap)),n.metalnessMap!==void 0&&(r.metalnessMap=t(n.metalnessMap)),n.emissiveMap!==void 0&&(r.emissiveMap=t(n.emissiveMap)),n.emissiveIntensity!==void 0&&(r.emissiveIntensity=n.emissiveIntensity),n.specularMap!==void 0&&(r.specularMap=t(n.specularMap)),n.envMap!==void 0&&(r.envMap=t(n.envMap)),n.envMapIntensity!==void 0&&(r.envMapIntensity=n.envMapIntensity),n.reflectivity!==void 0&&(r.reflectivity=n.reflectivity),n.refractionRatio!==void 0&&(r.refractionRatio=n.refractionRatio),n.lightMap!==void 0&&(r.lightMap=t(n.lightMap)),n.lightMapIntensity!==void 0&&(r.lightMapIntensity=n.lightMapIntensity),n.aoMap!==void 0&&(r.aoMap=t(n.aoMap)),n.aoMapIntensity!==void 0&&(r.aoMapIntensity=n.aoMapIntensity),n.gradientMap!==void 0&&(r.gradientMap=t(n.gradientMap)),n.clearcoatMap!==void 0&&(r.clearcoatMap=t(n.clearcoatMap)),n.clearcoatRoughnessMap!==void 0&&(r.clearcoatRoughnessMap=t(n.clearcoatRoughnessMap)),n.clearcoatNormalMap!==void 0&&(r.clearcoatNormalMap=t(n.clearcoatNormalMap)),n.clearcoatNormalScale!==void 0&&(r.clearcoatNormalScale=new st().fromArray(n.clearcoatNormalScale)),n.transmission!==void 0&&(r.transmission=n.transmission),n.transmissionMap!==void 0&&(r.transmissionMap=t(n.transmissionMap)),r},setTextures:function(n){return this.textures=n,this}});const yV={decodeText:function(n){if(typeof TextDecoder<"u")return new TextDecoder().decode(n);let e="";for(let t=0,r=n.length;t<r;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch{return e}},extractUrlBase:function(n){const e=n.lastIndexOf("/");return e===-1?"./":n.substr(0,e+1)}};function PS(){un.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}PS.prototype=Object.assign(Object.create(un.prototype),{constructor:PS,isInstancedBufferGeometry:!0,copy:function(n){return un.prototype.copy.call(this,n),this.instanceCount=n.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const n=un.prototype.toJSON.call(this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}});function oM(n,e,t,r){typeof t=="number"&&(r=t,t=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Cn.call(this,n,e,t),this.meshPerAttribute=r||1}oM.prototype=Object.assign(Object.create(Cn.prototype),{constructor:oM,isInstancedBufferAttribute:!0,copy:function(n){return Cn.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},toJSON:function(){const n=Cn.prototype.toJSON.call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}});function aM(n){zr.call(this,n)}aM.prototype=Object.assign(Object.create(zr.prototype),{constructor:aM,load:function(n,e,t,r){const s=this,i=new Nc(s.manager);i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{e(s.parse(JSON.parse(o)))}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)},parse:function(n){const e={},t={};function r(f,d){if(e[d]!==void 0)return e[d];const m=f.interleavedBuffers[d],g=s(f,m.buffer),y=O1(m.type,g),b=new Sl(y,m.stride);return b.uuid=m.uuid,e[d]=b,b}function s(f,d){if(t[d]!==void 0)return t[d];const m=f.arrayBuffers[d],g=new Uint32Array(m).buffer;return t[d]=g,g}const i=n.isInstancedBufferGeometry?new PS:new un,o=n.data.index;if(o!==void 0){const f=O1(o.type,o.array);i.setIndex(new Cn(f,1))}const a=n.data.attributes;for(const f in a){const d=a[f];let p;if(d.isInterleavedBufferAttribute){const m=r(n.data,d.data);p=new yp(m,d.itemSize,d.offset,d.normalized)}else{const m=O1(d.type,d.array),g=d.isInstancedBufferAttribute?oM:Cn;p=new g(m,d.itemSize,d.normalized)}d.name!==void 0&&(p.name=d.name),i.setAttribute(f,p)}const l=n.data.morphAttributes;if(l)for(const f in l){const d=l[f],p=[];for(let m=0,g=d.length;m<g;m++){const y=d[m];let b;if(y.isInterleavedBufferAttribute){const x=r(n.data,y.data);b=new yp(x,y.itemSize,y.offset,y.normalized)}else{const x=O1(y.type,y.array);b=new Cn(x,y.itemSize,y.normalized)}y.name!==void 0&&(b.name=y.name),p.push(b)}i.morphAttributes[f]=p}n.data.morphTargetsRelative&&(i.morphTargetsRelative=!0);const u=n.data.groups||n.data.drawcalls||n.data.offsets;if(u!==void 0)for(let f=0,d=u.length;f!==d;++f){const p=u[f];i.addGroup(p.start,p.count,p.materialIndex)}const h=n.data.boundingSphere;if(h!==void 0){const f=new Q;h.center!==void 0&&f.fromArray(h.center),i.boundingSphere=new zp(f,h.radius)}return n.name&&(i.name=n.name),n.userData&&(i.userData=n.userData),i}});class X0t extends zr{constructor(e){super(e)}load(e,t,r,s){const i=this,o=this.path===""?yV.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Nc(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(h){s!==void 0&&s(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){console.error("THREE.ObjectLoader: Can't load "+e);return}i.parse(c,t)},r,s)}parse(e,t){const r=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,i,l,r),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),t!==void 0){let h=!1;for(const f in o)if(o[f]instanceof HTMLImageElement){h=!0;break}h===!1&&t(c)}return c}parseShapes(e){const t={};if(e!==void 0)for(let r=0,s=e.length;r<s;r++){const i=new Jd().fromJSON(e[r]);t[i.uuid]=i}return t}parseSkeletons(e,t){const r={},s={};if(t.traverse(function(i){i.isBone&&(s[i.uuid]=i)}),e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=new SS().fromJSON(e[i],s);r[a.uuid]=a}return r}parseGeometries(e,t){const r={};let s;if(e!==void 0){const i=new aM;for(let o=0,a=e.length;o<a;o++){let l;const c=e[o];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":l=new ca[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":l=new ca[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":l=new ca[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":l=new ca[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":l=new ca[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":l=new ca[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":l=new ca[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":l=new ca[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":l=new ca[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":l=new ca[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":l=new ca[c.type](new jF[c.path.type]().fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":l=new ca[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":l=new ca[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":s=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];s.push(d)}l=new ca[c.type](s,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":s=[];for(let h=0,f=c.shapes.length;h<f;h++){const d=t[c.shapes[h]];s.push(d)}const u=c.options.extrudePath;u!==void 0&&(c.options.extrudePath=new jF[u.type]().fromJSON(u)),l=new ca[c.type](s,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":l=i.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}l.uuid=c.uuid,c.name!==void 0&&(l.name=c.name),l.isBufferGeometry===!0&&c.userData!==void 0&&(l.userData=c.userData),r[c.uuid]=l}}return r}parseMaterials(e,t){const r={},s={};if(e!==void 0){const i=new iM;i.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];if(l.type==="MultiMaterial"){const c=[];for(let u=0;u<l.materials.length;u++){const h=l.materials[u];r[h.uuid]===void 0&&(r[h.uuid]=i.parse(h)),c.push(r[h.uuid])}s[l.uuid]=c}else r[l.uuid]===void 0&&(r[l.uuid]=i.parse(l)),s[l.uuid]=r[l.uuid]}}return s}parseAnimations(e){const t={};if(e!==void 0)for(let r=0;r<e.length;r++){const s=e[r],i=wl.parse(s);t[i.uuid]=i}return t}parseImages(e,t){const r=this,s={};let i;function o(l){return r.manager.itemStart(l),i.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:r.resourcePath+c;return o(u)}else return l.data?{data:O1(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new mV(t);i=new wv(l),i.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const h=e[c],f=h.url;if(Array.isArray(f)){s[h.uuid]=[];for(let d=0,p=f.length;d<p;d++){const m=f[d],g=a(m);g!==null&&(g instanceof HTMLImageElement?s[h.uuid].push(g):s[h.uuid].push(new Pf(g.data,g.width,g.height)))}}else{const d=a(h.url);d!==null&&(s[h.uuid]=d)}}}return s}parseTextures(e,t){function r(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const s={};if(e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=e[i];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);let l;const c=t[a.image];Array.isArray(c)?(l=new Th(c),c.length===6&&(l.needsUpdate=!0)):(c&&c.data?l=new Pf(c.data,c.width,c.height):l=new Kr(c),c&&(l.needsUpdate=!0)),l.uuid=a.uuid,a.name!==void 0&&(l.name=a.name),a.mapping!==void 0&&(l.mapping=r(a.mapping,K0t)),a.offset!==void 0&&l.offset.fromArray(a.offset),a.repeat!==void 0&&l.repeat.fromArray(a.repeat),a.center!==void 0&&l.center.fromArray(a.center),a.rotation!==void 0&&(l.rotation=a.rotation),a.wrap!==void 0&&(l.wrapS=r(a.wrap[0],Q8),l.wrapT=r(a.wrap[1],Q8)),a.format!==void 0&&(l.format=a.format),a.type!==void 0&&(l.type=a.type),a.encoding!==void 0&&(l.encoding=a.encoding),a.minFilter!==void 0&&(l.minFilter=r(a.minFilter,eq)),a.magFilter!==void 0&&(l.magFilter=r(a.magFilter,eq)),a.anisotropy!==void 0&&(l.anisotropy=a.anisotropy),a.flipY!==void 0&&(l.flipY=a.flipY),a.premultiplyAlpha!==void 0&&(l.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(l.unpackAlignment=a.unpackAlignment),s[a.uuid]=l}return s}parseObject(e,t,r,s){let i;function o(u){return t[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",u),t[u]}function a(u){if(u!==void 0){if(Array.isArray(u)){const h=[];for(let f=0,d=u.length;f<d;f++){const p=u[f];r[p]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",p),h.push(r[p])}return h}return r[u]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",u),r[u]}}let l,c;switch(e.type){case"Scene":i=new fV,e.background!==void 0&&Number.isInteger(e.background)&&(i.background=new Ht(e.background)),e.fog!==void 0&&(e.fog.type==="Fog"?i.fog=new P$(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(i.fog=new R$(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":i=new Si(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(i.focus=e.focus),e.zoom!==void 0&&(i.zoom=e.zoom),e.filmGauge!==void 0&&(i.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(i.filmOffset=e.filmOffset),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"OrthographicCamera":i=new _v(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(i.zoom=e.zoom),e.view!==void 0&&(i.view=Object.assign({},e.view));break;case"AmbientLight":i=new rM(e.color,e.intensity);break;case"DirectionalLight":i=new nM(e.color,e.intensity);break;case"PointLight":i=new tM(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":i=new sM(e.color,e.intensity,e.width,e.height);break;case"SpotLight":i=new eM(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":i=new QA(e.color,e.groundColor,e.intensity);break;case"LightProbe":i=new xc().fromJSON(e);break;case"SkinnedMesh":l=o(e.geometry),c=a(e.material),i=new xS(l,c),e.bindMode!==void 0&&(i.bindMode=e.bindMode),e.bindMatrix!==void 0&&i.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(i.skeleton=e.skeleton);break;case"Mesh":l=o(e.geometry),c=a(e.material),i=new hs(l,c);break;case"InstancedMesh":l=o(e.geometry),c=a(e.material);const u=e.count,h=e.instanceMatrix;i=new NA(l,c,u),i.instanceMatrix=new Cn(new Float32Array(h.array),16);break;case"LOD":i=new wS;break;case"Line":i=new Mc(o(e.geometry),a(e.material));break;case"LineLoop":i=new $A(o(e.geometry),a(e.material));break;case"LineSegments":i=new ka(o(e.geometry),a(e.material));break;case"PointCloud":case"Points":i=new mv(o(e.geometry),a(e.material));break;case"Sprite":i=new vS(a(e.material));break;case"Group":i=new zd;break;case"Bone":i=new _S;break;default:i=new rn}if(i.uuid=e.uuid,e.name!==void 0&&(i.name=e.name),e.matrix!==void 0?(i.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(i.matrixAutoUpdate=e.matrixAutoUpdate),i.matrixAutoUpdate&&i.matrix.decompose(i.position,i.quaternion,i.scale)):(e.position!==void 0&&i.position.fromArray(e.position),e.rotation!==void 0&&i.rotation.fromArray(e.rotation),e.quaternion!==void 0&&i.quaternion.fromArray(e.quaternion),e.scale!==void 0&&i.scale.fromArray(e.scale)),e.castShadow!==void 0&&(i.castShadow=e.castShadow),e.receiveShadow!==void 0&&(i.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(i.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(i.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(i.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&i.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(i.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(i.visible=e.visible),e.frustumCulled!==void 0&&(i.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(i.renderOrder=e.renderOrder),e.userData!==void 0&&(i.userData=e.userData),e.layers!==void 0&&(i.layers.mask=e.layers),e.children!==void 0){const u=e.children;for(let h=0;h<u.length;h++)i.add(this.parseObject(u[h],t,r,s))}if(e.animations!==void 0){const u=e.animations;for(let h=0;h<u.length;h++){const f=u[h];i.animations.push(s[f])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(i.autoUpdate=e.autoUpdate);const u=e.levels;for(let h=0;h<u.length;h++){const f=u[h],d=i.getObjectByProperty("uuid",f.object);d!==void 0&&i.addLevel(d,f.distance)}}return i}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const s=t[r.skeleton];s===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(s,r.bindMatrix)}})}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const K0t={UVMapping:A$,CubeReflectionMapping:zC,CubeRefractionMapping:BC,EquirectangularReflectionMapping:TA,EquirectangularRefractionMapping:EA,CubeUVReflectionMapping:sx,CubeUVRefractionMapping:VC},Q8={RepeatWrapping:iS,ClampToEdgeWrapping:da,MirroredRepeatWrapping:oS},eq={NearestFilter:Ui,NearestMipmapNearestFilter:IA,NearestMipmapLinearFilter:AA,LinearFilter:lo,LinearMipmapNearestFilter:sV,LinearMipmapLinearFilter:ix};function YF(n){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),zr.call(this,n),this.options={premultiplyAlpha:"none"}}YF.prototype=Object.assign(Object.create(zr.prototype),{constructor:YF,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(n,e,t,r){n===void 0&&(n=""),this.path!==void 0&&(n=this.path+n),n=this.manager.resolveURL(n);const s=this,i=Ng.get(n);if(i!==void 0)return s.manager.itemStart(n),setTimeout(function(){e&&e(i),s.manager.itemEnd(n)},0),i;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(n,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,s.options)}).then(function(a){Ng.add(n,a),e&&e(a),s.manager.itemEnd(n)}).catch(function(a){r&&r(a),s.manager.itemError(n),s.manager.itemEnd(n)}),s.manager.itemStart(n)}});function bV(){this.type="ShapePath",this.color=new Ht,this.subPaths=[],this.currentPath=null}Object.assign(bV.prototype,{moveTo:function(n,e){return this.currentPath=new au,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this},lineTo:function(n,e){return this.currentPath.lineTo(n,e),this},quadraticCurveTo:function(n,e,t,r){return this.currentPath.quadraticCurveTo(n,e,t,r),this},bezierCurveTo:function(n,e,t,r,s,i){return this.currentPath.bezierCurveTo(n,e,t,r,s,i),this},splineThru:function(n){return this.currentPath.splineThru(n),this},toShapes:function(n,e){function t(y){const b=[];for(let x=0,w=y.length;x<w;x++){const S=y[x],C=new Jd;C.curves=S.curves,b.push(C)}return b}function r(y,b){const x=b.length;let w=!1;for(let S=x-1,C=0;C<x;S=C++){let k=b[S],A=b[C],M=A.x-k.x,E=A.y-k.y;if(Math.abs(E)>Number.EPSILON){if(E<0&&(k=b[C],M=-M,A=b[S],E=-E),y.y<k.y||y.y>A.y)continue;if(y.y===k.y){if(y.x===k.x)return!0}else{const N=E*(y.x-k.x)-M*(y.y-k.y);if(N===0)return!0;if(N<0)continue;w=!w}}else{if(y.y!==k.y)continue;if(A.x<=y.x&&y.x<=k.x||k.x<=y.x&&y.x<=A.x)return!0}}return w}const s=Af.isClockWise,i=this.subPaths;if(i.length===0)return[];if(e===!0)return t(i);let o,a,l;const c=[];if(i.length===1)return a=i[0],l=new Jd,l.curves=a.curves,c.push(l),c;let u=!s(i[0].getPoints());u=n?!u:u;const h=[],f=[];let d=[],p=0,m;f[p]=void 0,d[p]=[];for(let y=0,b=i.length;y<b;y++)a=i[y],m=a.getPoints(),o=s(m),o=n?!o:o,o?(!u&&f[p]&&p++,f[p]={s:new Jd,p:m},f[p].s.curves=a.curves,u&&p++,d[p]=[]):d[p].push({h:a,p:m[0]});if(!f[0])return t(i);if(f.length>1){let y=!1;const b=[];for(let x=0,w=f.length;x<w;x++)h[x]=[];for(let x=0,w=f.length;x<w;x++){const S=d[x];for(let C=0;C<S.length;C++){const k=S[C];let A=!0;for(let M=0;M<f.length;M++)r(k.p,f[M].p)&&(x!==M&&b.push({froms:x,tos:M,hole:C}),A?(A=!1,h[M].push(k)):y=!0);A&&h[x].push(k)}}b.length>0&&(y||(d=h))}let g;for(let y=0,b=f.length;y<b;y++){l=f[y].s,c.push(l),g=d[y];for(let x=0,w=g.length;x<w;x++)l.holes.push(g[x].h)}return c}});class Rle{constructor(e){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=e}generateShapes(e,t=100){const r=[],s=Y0t(e,t,this.data);for(let i=0,o=s.length;i<o;i++)Array.prototype.push.apply(r,s[i].toShapes());return r}}function Y0t(n,e,t){const r=Array.from?Array.from(n):String(n).split(""),s=e/t.resolution,i=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*s,o=[];let a=0,l=0;for(let c=0;c<r.length;c++){const u=r[c];if(u===`
`)a=0,l-=i;else{const h=Z0t(u,s,a,l,t);a+=h.offsetX,o.push(h.path)}}return o}function Z0t(n,e,t,r,s){const i=s.glyphs[n]||s.glyphs["?"];if(!i){console.error('THREE.Font: character "'+n+'" does not exists in font family '+s.familyName+".");return}const o=new bV;let a,l,c,u,h,f,d,p;if(i.o){const m=i._cachedOutline||(i._cachedOutline=i.o.split(" "));for(let g=0,y=m.length;g<y;)switch(m[g++]){case"m":a=m[g++]*e+t,l=m[g++]*e+r,o.moveTo(a,l);break;case"l":a=m[g++]*e+t,l=m[g++]*e+r,o.lineTo(a,l);break;case"q":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,o.quadraticCurveTo(h,f,c,u);break;case"b":c=m[g++]*e+t,u=m[g++]*e+r,h=m[g++]*e+t,f=m[g++]*e+r,d=m[g++]*e+t,p=m[g++]*e+r,o.bezierCurveTo(h,f,d,p,c,u);break}}return{offsetX:i.ha*e,path:o}}function ZF(n){zr.call(this,n)}ZF.prototype=Object.assign(Object.create(zr.prototype),{constructor:ZF,load:function(n,e,t,r){const s=this,i=new Nc(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){let a;try{a=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(o.substring(65,o.length-2))}const l=s.parse(a);e&&e(l)},t,r)},parse:function(n){return new Rle(n)}});let dE;const vV={getContext:function(){return dE===void 0&&(dE=new(window.AudioContext||window.webkitAudioContext)),dE},setContext:function(n){dE=n}};function lM(n){zr.call(this,n)}lM.prototype=Object.assign(Object.create(zr.prototype),{constructor:lM,load:function(n,e,t,r){const s=this,i=new Nc(s.manager);i.setResponseType("arraybuffer"),i.setPath(s.path),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(n,function(o){try{const a=o.slice(0);vV.getContext().decodeAudioData(a,function(c){e(c)})}catch(a){r?r(a):console.error(a),s.manager.itemError(n)}},t,r)}});function JF(n,e,t){xc.call(this,void 0,t);const r=new Ht().set(n),s=new Ht().set(e),i=new Q(r.r,r.g,r.b),o=new Q(s.r,s.g,s.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(i).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(i).sub(o).multiplyScalar(l)}JF.prototype=Object.assign(Object.create(xc.prototype),{constructor:JF,isHemisphereLightProbe:!0,copy:function(n){return xc.prototype.copy.call(this,n),this},toJSON:function(n){return xc.prototype.toJSON.call(this,n)}});function QF(n,e){xc.call(this,void 0,e);const t=new Ht().set(n);this.sh.coefficients[0].set(t.r,t.g,t.b).multiplyScalar(2*Math.sqrt(Math.PI))}QF.prototype=Object.assign(Object.create(xc.prototype),{constructor:QF,isAmbientLightProbe:!0,copy:function(n){return xc.prototype.copy.call(this,n),this},toJSON:function(n){return xc.prototype.toJSON.call(this,n)}});const tq=new Zn,nq=new Zn;function Ple(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Si,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Si,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(Ple.prototype,{update:function(n){const e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep;const r=n.projectionMatrix.clone(),s=e.eyeSep/2,i=s*e.near/e.focus,o=e.near*Math.tan(In.DEG2RAD*e.fov*.5)/e.zoom;let a,l;nq.elements[12]=-s,tq.elements[12]=s,a=-o*e.aspect+i,l=o*e.aspect+i,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(r),a=-o*e.aspect-i,l=o*e.aspect-i,r.elements[0]=2*e.near/(l-a),r.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(r)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(nq),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(tq)}});class Dle{constructor(e){this.autoStart=e!==void 0?e:!0,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=rq(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=rq();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function rq(){return(typeof performance>"u"?Date:performance).now()}const pm=new Q,sq=new co,J0t=new Q,mm=new Q;class Q0t extends rn{constructor(){super(),this.type="AudioListener",this.context=vV.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Dle}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(pm,sq,J0t),mm.set(0,0,-1).applyQuaternion(sq),t.positionX){const s=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(pm.x,s),t.positionY.linearRampToValueAtTime(pm.y,s),t.positionZ.linearRampToValueAtTime(pm.z,s),t.forwardX.linearRampToValueAtTime(mm.x,s),t.forwardY.linearRampToValueAtTime(mm.y,s),t.forwardZ.linearRampToValueAtTime(mm.z,s),t.upX.linearRampToValueAtTime(r.x,s),t.upY.linearRampToValueAtTime(r.y,s),t.upZ.linearRampToValueAtTime(r.z,s)}else t.setPosition(pm.x,pm.y,pm.z),t.setOrientation(mm.x,mm.y,mm.z,r.x,r.y,r.z)}}class wV extends rn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const gm=new Q,iq=new co,ebt=new Q,ym=new Q;class tbt extends wV{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(gm,iq,ebt),ym.set(0,0,1).applyQuaternion(iq);const t=this.panner;if(t.positionX){const r=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(gm.x,r),t.positionY.linearRampToValueAtTime(gm.y,r),t.positionZ.linearRampToValueAtTime(gm.z,r),t.orientationX.linearRampToValueAtTime(ym.x,r),t.orientationY.linearRampToValueAtTime(ym.y,r),t.orientationZ.linearRampToValueAtTime(ym.z,r)}else t.setPosition(gm.x,gm.y,gm.z),t.setOrientation(ym.x,ym.y,ym.z)}}class Ole{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let r=0;r<t.length;r++)e+=t[r];return e/t.length}}function xV(n,e,t){this.binding=n,this.valueSize=t;let r,s,i;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(t*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(t*5);break;default:r=this._lerp,s=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(t*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(xV.prototype,{accumulate:function(n,e){const t=this.buffer,r=this.valueSize,s=n*r+r;let i=this.cumulativeWeight;if(i===0){for(let o=0;o!==r;++o)t[s+o]=t[o];i=e}else{i+=e;const o=e/i;this._mixBufferRegion(t,s,0,o,r)}this.cumulativeWeight=i},accumulateAdditive:function(n){const e=this.buffer,t=this.valueSize,r=t*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,n,t),this.cumulativeWeightAdditive+=n},apply:function(n){const e=this.valueSize,t=this.buffer,r=n*e+e,s=this.cumulativeWeight,i=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const a=e*this._origIndex;this._mixBufferRegion(t,r,a,1-s,e)}i>0&&this._mixBufferRegionAdditive(t,r,this._addIndex*e,1,e);for(let a=e,l=e+e;a!==l;++a)if(t[a]!==t[a+e]){o.setValue(t,r);break}},saveOriginalState:function(){const n=this.binding,e=this.buffer,t=this.valueSize,r=t*this._origIndex;n.getValue(e,r);for(let s=t,i=r;s!==i;++s)e[s]=e[r+s%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const n=this.valueSize*3;this.binding.setValue(this.buffer,n)},_setAdditiveIdentityNumeric:function(){const n=this._addIndex*this.valueSize,e=n+this.valueSize;for(let t=n;t<e;t++)this.buffer[t]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]},_select:function(n,e,t,r,s){if(r>=.5)for(let i=0;i!==s;++i)n[e+i]=n[t+i]},_slerp:function(n,e,t,r){co.slerpFlat(n,e,n,e,n,t,r)},_slerpAdditive:function(n,e,t,r,s){const i=this._workIndex*s;co.multiplyQuaternionsFlat(n,i,n,e,n,t),co.slerpFlat(n,e,n,e,n,i,r)},_lerp:function(n,e,t,r,s){const i=1-r;for(let o=0;o!==s;++o){const a=e+o;n[a]=n[a]*i+n[t+o]*r}},_lerpAdditive:function(n,e,t,r,s){for(let i=0;i!==s;++i){const o=e+i;n[o]=n[o]+n[t+i]*r}}});const _V="\\[\\]\\.:\\/",nbt=new RegExp("["+_V+"]","g"),SV="[^"+_V+"]",rbt="[^"+_V.replace("\\.","")+"]",sbt=/((?:WC+[\/:])*)/.source.replace("WC",SV),ibt=/(WCOD+)?/.source.replace("WCOD",rbt),obt=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",SV),abt=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",SV),lbt=new RegExp("^"+sbt+ibt+obt+abt+"$"),cbt=["material","materials","bones"];function Fle(n,e,t){const r=t||Ko.parseTrackName(e);this._targetGroup=n,this._bindings=n.subscribe_(e,r)}Object.assign(Fle.prototype,{getValue:function(n,e){this.bind();const t=this._targetGroup.nCachedObjects_,r=this._bindings[t];r!==void 0&&r.getValue(n,e)},setValue:function(n,e){const t=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=t.length;r!==s;++r)t[r].setValue(n,e)},bind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()},unbind:function(){const n=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}});function Ko(n,e,t){this.path=e,this.parsedPath=t||Ko.parseTrackName(e),this.node=Ko.findNode(n,this.parsedPath.nodeName)||n,this.rootNode=n}Object.assign(Ko,{Composite:Fle,create:function(n,e,t){return n&&n.isAnimationObjectGroup?new Ko.Composite(n,e,t):new Ko(n,e,t)},sanitizeNodeName:function(n){return n.replace(/\s/g,"_").replace(nbt,"")},parseTrackName:function(n){const e=lbt.exec(n);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=t.nodeName&&t.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=t.nodeName.substring(r+1);cbt.indexOf(s)!==-1&&(t.nodeName=t.nodeName.substring(0,r),t.objectName=s)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t},findNode:function(n,e){if(!e||e===""||e==="."||e===-1||e===n.name||e===n.uuid)return n;if(n.skeleton){const t=n.skeleton.getBoneByName(e);if(t!==void 0)return t}if(n.children){const t=function(s){for(let i=0;i<s.length;i++){const o=s[i];if(o.name===e||o.uuid===e)return o;const a=t(o.children);if(a)return a}return null},r=t(n.children);if(r)return r}return null}});Object.assign(Ko.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)e[t++]=r[s]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++]},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){let n=this.node;const e=this.parsedPath,t=e.objectName,r=e.propertyName;let s=e.propertyIndex;if(n||(n=Ko.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=n),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!n){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(t){let l=e.objectIndex;switch(t){case"materials":if(!n.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!n.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}n=n.material.materials;break;case"bones":if(!n.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}n=n.skeleton.bones;for(let c=0;c<n.length;c++)if(n[c].name===l){l=c;break}break;default:if(n[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}n=n[t]}if(l!==void 0){if(n[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,n);return}n=n[l]}}const i=n[r];if(i===void 0){const l=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+r+" but it wasn't found.",n);return}let o=this.Versioning.None;this.targetObject=n,n.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:n.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!n.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(n.geometry.isBufferGeometry){if(!n.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}n.morphTargetDictionary[s]!==void 0&&(s=n.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=i,this.propertyIndex=s}else i.fromArray!==void 0&&i.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=i):Array.isArray(i)?(a=this.BindingType.EntireArray,this.resolvedProperty=i):this.propertyName=r;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(Ko.prototype,{_getValue_unbound:Ko.prototype.getValue,_setValue_unbound:Ko.prototype.setValue});function Lle(){this.uuid=In.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const n={};this._indicesByUUID=n;for(let t=0,r=arguments.length;t!==r;++t)n[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}}Object.assign(Lle.prototype,{isAnimationObjectGroup:!0,add:function(){const n=this._objects,e=this._indicesByUUID,t=this._paths,r=this._parsedPaths,s=this._bindings,i=s.length;let o,a=n.length,l=this.nCachedObjects_;for(let c=0,u=arguments.length;c!==u;++c){const h=arguments[c],f=h.uuid;let d=e[f];if(d===void 0){d=a++,e[f]=d,n.push(h);for(let p=0,m=i;p!==m;++p)s[p].push(new Ko(h,t[p],r[p]))}else if(d<l){o=n[d];const p=--l,m=n[p];e[m.uuid]=d,n[d]=m,e[f]=p,n[p]=h;for(let g=0,y=i;g!==y;++g){const b=s[g],x=b[p];let w=b[d];b[d]=x,w===void 0&&(w=new Ko(h,t[g],r[g])),b[p]=w}}else n[d]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let s=this.nCachedObjects_;for(let i=0,o=arguments.length;i!==o;++i){const a=arguments[i],l=a.uuid,c=e[l];if(c!==void 0&&c>=s){const u=s++,h=n[u];e[h.uuid]=c,n[c]=h,e[l]=u,n[u]=a;for(let f=0,d=r;f!==d;++f){const p=t[f],m=p[u],g=p[c];p[c]=m,p[u]=g}}}this.nCachedObjects_=s},uncache:function(){const n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length;let s=this.nCachedObjects_,i=n.length;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=e[c];if(u!==void 0)if(delete e[c],u<s){const h=--s,f=n[h],d=--i,p=n[d];e[f.uuid]=u,n[u]=f,e[p.uuid]=h,n[h]=p,n.pop();for(let m=0,g=r;m!==g;++m){const y=t[m],b=y[h],x=y[d];y[u]=b,y[h]=x,y.pop()}}else{const h=--i,f=n[h];h>0&&(e[f.uuid]=u),n[u]=f,n.pop();for(let d=0,p=r;d!==p;++d){const m=t[d];m[u]=m[h],m.pop()}}}this.nCachedObjects_=s},subscribe_:function(n,e){const t=this._bindingsIndicesByPath;let r=t[n];const s=this._bindings;if(r!==void 0)return s[r];const i=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,u=new Array(l);r=s.length,t[n]=r,i.push(n),o.push(e),s.push(u);for(let h=c,f=a.length;h!==f;++h){const d=a[h];u[h]=new Ko(d,n,e)}return u},unsubscribe_:function(n){const e=this._bindingsIndicesByPath,t=e[n];if(t!==void 0){const r=this._paths,s=this._parsedPaths,i=this._bindings,o=i.length-1,a=i[o],l=n[o];e[l]=t,i[t]=a,i.pop(),s[t]=s[o],s.pop(),r[t]=r[o],r.pop()}}});class ubt{constructor(e,t,r=null,s=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=s;const i=t.tracks,o=i.length,a=new Array(o),l={endingStart:Wm,endingEnd:Wm};for(let c=0;c!==o;++c){const u=i[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=ile,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){const s=this._clip.duration,i=e._clip.duration,o=i/s,a=s/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,r){return e.crossFadeFrom(this,t,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,r){const s=this._mixer,i=s.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=s._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=i,l[1]=i+r,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,r,s){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const l=(e-i)*r;if(l<0||r===0)return;this._startTime=null,t=r*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case iV:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case M$:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(s,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const r=this._weightInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,r=this.loop;let s=this.time+e,i=this._loopCount;const o=r===ole;if(e===0)return i===-1?s:o&&(i&1)===1?t-s:s;if(r===sle){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(s>=t)s=t;else if(s<0)s=0;else{this.time=s;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),s>=t||s<0){const a=Math.floor(s/t);s-=t*a,i+=Math.abs(a);const l=this.repetitions-i;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=e>0?t:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=s;if(o&&(i&1)===1)return t-s}return s}_setEndings(e,t,r){const s=this._interpolantSettings;r?(s.endingStart=Gm,s.endingEnd=Gm):(e?s.endingStart=this.zeroSlopeAtStart?Gm:Wm:s.endingStart=uS,t?s.endingEnd=this.zeroSlopeAtEnd?Gm:Wm:s.endingEnd=uS)}_scheduleFading(e,t,r){const s=this._mixer,i=s.time;let o=this._weightInterpolant;o===null&&(o=s._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,l[0]=t,a[1]=i+e,l[1]=r,this}}function eL(n){this._root=n,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}eL.prototype=Object.assign(Object.create(Uu.prototype),{constructor:eL,_bindAction:function(n,e){const t=n._localRoot||this._root,r=n._clip.tracks,s=r.length,i=n._propertyBindings,o=n._interpolants,a=t.uuid,l=this._bindingsByRootAndName;let c=l[a];c===void 0&&(c={},l[a]=c);for(let u=0;u!==s;++u){const h=r[u],f=h.name;let d=c[f];if(d!==void 0)i[u]=d;else{if(d=i[u],d!==void 0){d._cacheIndex===null&&(++d.referenceCount,this._addInactiveBinding(d,a,f));continue}const p=e&&e._propertyBindings[u].binding.parsedPath;d=new xV(Ko.create(t,f,p),h.ValueTypeName,h.getValueSize()),++d.referenceCount,this._addInactiveBinding(d,a,f),i[u]=d}o[u].resultBuffer=d.buffer}},_activateAction:function(n){if(!this._isActiveAction(n)){if(n._cacheIndex===null){const t=(n._localRoot||this._root).uuid,r=n._clip.uuid,s=this._actionsByClip[r];this._bindAction(n,s&&s.knownActions[0]),this._addInactiveAction(n,r,t)}const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(n)}},_deactivateAction:function(n){if(this._isActiveAction(n)){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(n)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}},_isActiveAction:function(n){const e=n._cacheIndex;return e!==null&&e<this._nActiveActions},_addInactiveAction:function(n,e,t){const r=this._actions,s=this._actionsByClip;let i=s[e];if(i===void 0)i={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,s[e]=i;else{const o=i.knownActions;n._byClipCacheIndex=o.length,o.push(n)}n._cacheIndex=r.length,r.push(n),i.actionByRoot[t]=n},_removeInactiveAction:function(n){const e=this._actions,t=e[e.length-1],r=n._cacheIndex;t._cacheIndex=r,e[r]=t,e.pop(),n._cacheIndex=null;const s=n._clip.uuid,i=this._actionsByClip,o=i[s],a=o.knownActions,l=a[a.length-1],c=n._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),n._byClipCacheIndex=null;const u=o.actionByRoot,h=(n._localRoot||this._root).uuid;delete u[h],a.length===0&&delete i[s],this._removeInactiveBindingsForAction(n)},_removeInactiveBindingsForAction:function(n){const e=n._propertyBindings;for(let t=0,r=e.length;t!==r;++t){const s=e[t];--s.referenceCount===0&&this._removeInactiveBinding(s)}},_lendAction:function(n){const e=this._actions,t=n._cacheIndex,r=this._nActiveActions++,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_takeBackAction:function(n){const e=this._actions,t=n._cacheIndex,r=--this._nActiveActions,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_addInactiveBinding:function(n,e,t){const r=this._bindingsByRootAndName,s=this._bindings;let i=r[e];i===void 0&&(i={},r[e]=i),i[t]=n,n._cacheIndex=s.length,s.push(n)},_removeInactiveBinding:function(n){const e=this._bindings,t=n.binding,r=t.rootNode.uuid,s=t.path,i=this._bindingsByRootAndName,o=i[r],a=e[e.length-1],l=n._cacheIndex;a._cacheIndex=l,e[l]=a,e.pop(),delete o[s],Object.keys(o).length===0&&delete i[r]},_lendBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=this._nActiveBindings++,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_takeBackBinding:function(n){const e=this._bindings,t=n._cacheIndex,r=--this._nActiveBindings,s=e[r];n._cacheIndex=r,e[r]=n,s._cacheIndex=t,e[t]=s},_lendControlInterpolant:function(){const n=this._controlInterpolants,e=this._nActiveControlInterpolants++;let t=n[e];return t===void 0&&(t=new $S(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),t.__cacheIndex=e,n[e]=t),t},_takeBackControlInterpolant:function(n){const e=this._controlInterpolants,t=n.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];n.__cacheIndex=r,e[r]=n,s.__cacheIndex=t,e[t]=s},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(n,e,t){const r=e||this._root,s=r.uuid;let i=typeof n=="string"?wl.findByName(r,n):n;const o=i!==null?i.uuid:n,a=this._actionsByClip[o];let l=null;if(t===void 0&&(i!==null?t=i.blendMode:t=M$),a!==void 0){const u=a.actionByRoot[s];if(u!==void 0&&u.blendMode===t)return u;l=a.knownActions[0],i===null&&(i=l._clip)}if(i===null)return null;const c=new ubt(this,i,e,t);return this._bindAction(c,l),this._addInactiveAction(c,o,s),c},existingAction:function(n,e){const t=e||this._root,r=t.uuid,s=typeof n=="string"?wl.findByName(t,n):n,i=s?s.uuid:n,o=this._actionsByClip[i];return o!==void 0&&o.actionByRoot[r]||null},stopAllAction:function(){const n=this._actions,e=this._nActiveActions;for(let t=e-1;t>=0;--t)n[t].stop();return this},update:function(n){n*=this.timeScale;const e=this._actions,t=this._nActiveActions,r=this.time+=n,s=Math.sign(n),i=this._accuIndex^=1;for(let l=0;l!==t;++l)e[l]._update(r,n,s,i);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(i);return this},setTime:function(n){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)},getRoot:function(){return this._root},uncacheClip:function(n){const e=this._actions,t=n.uuid,r=this._actionsByClip,s=r[t];if(s!==void 0){const i=s.knownActions;for(let o=0,a=i.length;o!==a;++o){const l=i[o];this._deactivateAction(l);const c=l._cacheIndex,u=e[e.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,u._cacheIndex=c,e[c]=u,e.pop(),this._removeInactiveBindingsForAction(l)}delete r[t]}},uncacheRoot:function(n){const e=n.uuid,t=this._actionsByClip;for(const i in t){const o=t[i].actionByRoot,a=o[e];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const i in s){const o=s[i];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(n,e){const t=this.existingAction(n,e);t!==null&&(this._deactivateAction(t),this._removeInactiveAction(t))}});class O${constructor(e){typeof e=="string"&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new O$(this.value.clone===void 0?this.value:this.value.clone())}}function tL(n,e,t){Sl.call(this,n,e),this.meshPerAttribute=t||1}tL.prototype=Object.assign(Object.create(Sl.prototype),{constructor:tL,isInstancedInterleavedBuffer:!0,copy:function(n){return Sl.prototype.copy.call(this,n),this.meshPerAttribute=n.meshPerAttribute,this},clone:function(n){const e=Sl.prototype.clone.call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e},toJSON:function(n){const e=Sl.prototype.toJSON.call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}});function CV(n,e,t,r,s){this.buffer=n,this.type=e,this.itemSize=t,this.elementSize=r,this.count=s,this.version=0}Object.defineProperty(CV.prototype,"needsUpdate",{set:function(n){n===!0&&this.version++}});Object.assign(CV.prototype,{isGLBufferAttribute:!0,setBuffer:function(n){return this.buffer=n,this},setType:function(n,e){return this.type=n,this.elementSize=e,this},setItemSize:function(n){return this.itemSize=n,this},setCount:function(n){return this.count=n,this}});function kV(n,e,t,r){this.ray=new ax(n,e),this.near=t||0,this.far=r||1/0,this.camera=null,this.layers=new cV,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function oq(n,e){return n.distance-e.distance}function nL(n,e,t,r){if(n.layers.test(e.layers)&&n.raycast(e,t),r===!0){const s=n.children;for(let i=0,o=s.length;i<o;i++)nL(s[i],e,t,!0)}}Object.assign(kV.prototype,{set:function(n,e){this.ray.set(n,e)},setFromCamera:function(n,e){e&&e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e&&e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)},intersectObject:function(n,e,t){const r=t||[];return nL(n,this,r,e),r.sort(oq),r},intersectObjects:function(n,e,t){const r=t||[];if(Array.isArray(n)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),r;for(let s=0,i=n.length;s<i;s++)nL(n[s],this,r,e);return r.sort(oq),r}});class rL{constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(In.clamp(t/this.radius,-1,1))),this}}class hbt{constructor(e,t,r){return this.radius=e!==void 0?e:1,this.theta=t!==void 0?t:0,this.y=r!==void 0?r:0,this}set(e,t,r){return this.radius=e,this.theta=t,this.y=r,this}clone(){return new this.constructor().copy(this)}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=t,this}}const aq=new st;class zle{constructor(e,t){Object.defineProperty(this,"isBox2",{value:!0}),this.min=e!==void 0?e:new st(1/0,1/0),this.max=t!==void 0?t:new st(-1/0,-1/0)}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=aq.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return e===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new st),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return e===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new st),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new st),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new st),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return aq.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const lq=new Q,pE=new Q;class Ble{constructor(e,t){this.start=e!==void 0?e:new Q,this.end=t!==void 0?t:new Q}set(e,t){return this.start.copy(e),this.end.copy(t),this}clone(){return new this.constructor().copy(this)}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e===void 0&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new Q),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e===void 0&&(console.warn("THREE.Line3: .delta() target is now required"),e=new Q),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return t===void 0&&(console.warn("THREE.Line3: .at() target is now required"),t=new Q),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){lq.subVectors(e,this.start),pE.subVectors(this.end,this.start);const r=pE.dot(pE);let i=pE.dot(lq)/r;return t&&(i=In.clamp(i,0,1)),i}closestPointToPoint(e,t,r){const s=this.closestPointToPointParameter(e,t);return r===void 0&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),r=new Q),this.delta(r).multiplyScalar(s).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}function DS(n){rn.call(this),this.material=n,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}DS.prototype=Object.create(rn.prototype);DS.prototype.constructor=DS;DS.prototype.isImmediateRenderObject=!0;const cq=new Q;class fbt extends rn{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const r=new un,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;s.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}r.setAttribute("position",new Xt(s,3));const i=new Es({fog:!1,toneMapped:!1});this.cone=new ka(r,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),cq.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(cq),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const wd=new Q,mE=new Zn,PP=new Zn;class Vle extends ka{constructor(e){const t=Ule(e),r=new un,s=[],i=[],o=new Ht(0,0,1),a=new Ht(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}r.setAttribute("position",new Xt(s,3)),r.setAttribute("color",new Xt(i,3));const l=new Es({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,r=this.geometry,s=r.getAttribute("position");PP.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(mE.multiplyMatrices(PP,a.matrixWorld),wd.setFromMatrixPosition(mE),s.setXYZ(o,wd.x,wd.y,wd.z),mE.multiplyMatrices(PP,a.parent.matrixWorld),wd.setFromMatrixPosition(mE),s.setXYZ(o+1,wd.x,wd.y,wd.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function Ule(n){const e=[];n&&n.isBone&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,Ule(n.children[t]));return e}class dbt extends hs{constructor(e,t,r){const s=new NS(t,4,2),i=new Rl({wireframe:!0,fog:!1,toneMapped:!1});super(s,i),this.light=e,this.light.updateMatrixWorld(),this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const pbt=new Q,uq=new Ht,hq=new Ht;class mbt extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r;const s=new AS(t);s.rotateY(Math.PI*.5),this.material=new Rl({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=s.getAttribute("position"),o=new Float32Array(i.count*3);s.setAttribute("color",new Cn(o,3)),this.add(new hs(s,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");uq.copy(this.light.color),hq.copy(this.light.groundColor);for(let r=0,s=t.count;r<s;r++){const i=r<s/2?uq:hq;t.setXYZ(r,i.r,i.g,i.b)}t.needsUpdate=!0}e.lookAt(pbt.setFromMatrixPosition(this.light.matrixWorld).negate())}}class Wle extends ka{constructor(e=10,t=10,r=4473924,s=8947848){r=new Ht(r),s=new Ht(s);const i=t/2,o=e/t,a=e/2,l=[],c=[];for(let f=0,d=0,p=-a;f<=t;f++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const m=f===i?r:s;m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3,m.toArray(c,d),d+=3}const u=new un;u.setAttribute("position",new Xt(l,3)),u.setAttribute("color",new Xt(c,3));const h=new Es({vertexColors:!0,toneMapped:!1});super(u,h),this.type="GridHelper"}}class gbt extends ka{constructor(e=10,t=16,r=8,s=64,i=4473924,o=8947848){i=new Ht(i),o=new Ht(o);const a=[],l=[];for(let h=0;h<=t;h++){const f=h/t*(Math.PI*2),d=Math.sin(f)*e,p=Math.cos(f)*e;a.push(0,0,0),a.push(d,0,p);const m=h&1?i:o;l.push(m.r,m.g,m.b),l.push(m.r,m.g,m.b)}for(let h=0;h<=r;h++){const f=h&1?i:o,d=e-e/r*h;for(let p=0;p<s;p++){let m=p/s*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d;a.push(g,0,y),l.push(f.r,f.g,f.b),m=(p+1)/s*(Math.PI*2),g=Math.sin(m)*d,y=Math.cos(m)*d,a.push(g,0,y),l.push(f.r,f.g,f.b)}}const c=new un;c.setAttribute("position",new Xt(a,3)),c.setAttribute("color",new Xt(l,3));const u=new Es({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}}const fq=new Q,gE=new Q,dq=new Q;class ybt extends rn{constructor(e,t,r){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,t===void 0&&(t=1);let s=new un;s.setAttribute("position",new Xt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new Es({fog:!1,toneMapped:!1});this.lightPlane=new Mc(s,i),this.add(this.lightPlane),s=new un,s.setAttribute("position",new Xt([0,0,0,0,0,1],3)),this.targetLine=new Mc(s,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){fq.setFromMatrixPosition(this.light.matrixWorld),gE.setFromMatrixPosition(this.light.target.matrixWorld),dq.subVectors(gE,fq),this.lightPlane.lookAt(gE),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(gE),this.targetLine.scale.z=dq.length()}}const yE=new Q,Gs=new kh;class bbt extends ka{constructor(e){const t=new un,r=new Es({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],i=[],o={},a=new Ht(16755200),l=new Ht(16711680),c=new Ht(43775),u=new Ht(16777215),h=new Ht(3355443);f("n1","n2",a),f("n2","n4",a),f("n4","n3",a),f("n3","n1",a),f("f1","f2",a),f("f2","f4",a),f("f4","f3",a),f("f3","f1",a),f("n1","f1",a),f("n2","f2",a),f("n3","f3",a),f("n4","f4",a),f("p","n1",l),f("p","n2",l),f("p","n3",l),f("p","n4",l),f("u1","u2",c),f("u2","u3",c),f("u3","u1",c),f("c","t",u),f("p","c",h),f("cn1","cn2",h),f("cn3","cn4",h),f("cf1","cf2",h),f("cf3","cf4",h);function f(p,m,g){d(p,g),d(m,g)}function d(p,m){s.push(0,0,0),i.push(m.r,m.g,m.b),o[p]===void 0&&(o[p]=[]),o[p].push(s.length/3-1)}t.setAttribute("position",new Xt(s,3)),t.setAttribute("color",new Xt(i,3)),super(t,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}update(){const e=this.geometry,t=this.pointMap,r=1,s=1;Gs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),si("c",t,e,Gs,0,0,-1),si("t",t,e,Gs,0,0,1),si("n1",t,e,Gs,-r,-s,-1),si("n2",t,e,Gs,r,-s,-1),si("n3",t,e,Gs,-r,s,-1),si("n4",t,e,Gs,r,s,-1),si("f1",t,e,Gs,-r,-s,1),si("f2",t,e,Gs,r,-s,1),si("f3",t,e,Gs,-r,s,1),si("f4",t,e,Gs,r,s,1),si("u1",t,e,Gs,r*.7,s*1.1,-1),si("u2",t,e,Gs,-r*.7,s*1.1,-1),si("u3",t,e,Gs,0,s*2,-1),si("cf1",t,e,Gs,-r,0,1),si("cf2",t,e,Gs,r,0,1),si("cf3",t,e,Gs,0,-s,1),si("cf4",t,e,Gs,0,s,1),si("cn1",t,e,Gs,-r,0,-1),si("cn2",t,e,Gs,r,0,-1),si("cn3",t,e,Gs,0,-s,-1),si("cn4",t,e,Gs,0,s,-1),e.getAttribute("position").needsUpdate=!0}}function si(n,e,t,r,s,i,o){yE.set(s,i,o).unproject(r);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],yE.x,yE.y,yE.z)}}const bE=new Xf;class Gle extends ka{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(8*3),i=new un;i.setIndex(new Cn(r,1)),i.setAttribute("position",new Cn(s,3)),super(i,new Es({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&bE.setFromObject(this.object),bE.isEmpty())return;const t=bE.min,r=bE.max,s=this.geometry.attributes.position,i=s.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=t.x,i[4]=r.y,i[5]=r.z,i[6]=t.x,i[7]=t.y,i[8]=r.z,i[9]=r.x,i[10]=t.y,i[11]=r.z,i[12]=r.x,i[13]=r.y,i[14]=t.z,i[15]=t.x,i[16]=r.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=r.x,i[22]=t.y,i[23]=t.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return ka.prototype.copy.call(this,e),this.object=e.object,this}}class vbt extends ka{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],i=new un;i.setIndex(new Cn(r,1)),i.setAttribute("position",new Xt(s,3)),super(i,new Es({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class wbt extends Mc{constructor(e,t=1,r=16776960){const s=r,i=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],o=new un;o.setAttribute("position",new Xt(i,3)),o.computeBoundingSphere(),super(o,new Es({color:s,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],l=new un;l.setAttribute("position",new Xt(a,3)),l.computeBoundingSphere(),this.add(new hs(l,new Rl({color:s,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?gi:rx,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const pq=new Q;let vE,DP;class xbt extends rn{constructor(e,t,r,s,i,o){super(),this.type="ArrowHelper",e===void 0&&(e=new Q(0,0,1)),t===void 0&&(t=new Q(0,0,0)),r===void 0&&(r=1),s===void 0&&(s=16776960),i===void 0&&(i=.2*r),o===void 0&&(o=.2*i),vE===void 0&&(vE=new un,vE.setAttribute("position",new Xt([0,0,0,0,1,0],3)),DP=new yv(0,.5,1,5,1),DP.translate(0,-.5,0)),this.position.copy(t),this.line=new Mc(vE,new Es({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new hs(DP,new Rl({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,i,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{pq.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(pq,t)}}setLength(e,t,r){t===void 0&&(t=.2*e),r===void 0&&(r=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(r,t,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class Hle extends ka{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new un;s.setAttribute("position",new Xt(t,3)),s.setAttribute("color",new Xt(r,3));const i=new Es({vertexColors:!0,toneMapped:!1});super(s,i),this.type="AxesHelper"}}const jle=new Float32Array(1),_bt=new Int32Array(jle.buffer),Sbt={toHalfFloat:function(n){jle[0]=n;const e=_bt[0];let t=e>>16&32768,r=e>>12&2047;const s=e>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?0:1)&&e&8388607,t):s<113?(r|=2048,t|=(r>>114-s)+(r>>113-s&1),t):(t|=s-112<<10|r>>1,t+=r&1,t)}},Ob=4,Qd=8,rh=Math.pow(2,Qd),qle=[.125,.215,.35,.446,.526,.582],Xle=Qd-Ob+1+qle.length,ib=20,hh={[Sa]:0,[UC]:1,[$$]:2,[oV]:3,[aV]:4,[lV]:5,[N$]:6},Cm=new Rl({side:gi,depthWrite:!1,depthTest:!1}),Cbt=new hs(new xg,Cm),OP=new _v,{_lodPlanes:h1,_sizeLods:mq,_sigmas:wE}=Ebt(),gq=new Ht;let FP=null;const km=(1+Math.sqrt(5))/2,ob=1/km,yq=[new Q(1,1,1),new Q(-1,1,1),new Q(1,1,-1),new Q(-1,1,-1),new Q(0,km,ob),new Q(0,km,-ob),new Q(ob,0,km),new Q(-ob,0,km),new Q(km,ob,0),new Q(-km,ob,0)];function bq(n){const e=Math.max(n.r,n.g,n.b),t=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return n.multiplyScalar(Math.pow(2,-t)),(t+128)/255}class kbt{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=Ibt(ib),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,s=100){FP=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(e,r,s,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=xq(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=wq(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<h1.length;e++)h1[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(FP),e.scissorTest=!1,xE(e,0,0,e.width,e.height)}_fromTexture(e){FP=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Ui,minFilter:Ui,generateMipmaps:!1,type:ox,format:xae,encoding:Tbt(e)?e.encoding:$$,depthBuffer:!1},r=vq(t);return r.depthBuffer=!e,this._pingPongRenderTarget=vq(t),r}_compileMaterial(e){const t=new hs(h1[0],e);this._renderer.compile(t,OP)}_sceneToCubeUV(e,t,r,s){const a=new Si(90,1,t,r),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,f=u.outputEncoding,d=u.toneMapping;u.getClearColor(gq),u.toneMapping=Jm,u.outputEncoding=Sa,u.autoClear=!1;let p=!1;const m=e.background;if(m){if(m.isColor){Cm.color.copy(m).convertSRGBToLinear(),e.background=null;const g=bq(Cm.color);Cm.opacity=g,p=!0}}else{Cm.color.copy(gq).convertSRGBToLinear();const g=bq(Cm.color);Cm.opacity=g,p=!0}for(let g=0;g<6;g++){const y=g%3;y==0?(a.up.set(0,l[g],0),a.lookAt(c[g],0,0)):y==1?(a.up.set(0,0,l[g]),a.lookAt(0,c[g],0)):(a.up.set(0,l[g],0),a.lookAt(0,0,c[g])),xE(s,y*rh,g>2?rh:0,rh,rh),u.setRenderTarget(s),p&&u.render(Cbt,a),u.render(e,a)}u.toneMapping=d,u.outputEncoding=f,u.autoClear=h}_textureToCubeUV(e,t){const r=this._renderer;e.isCubeTexture?this._cubemapShader==null&&(this._cubemapShader=xq()):this._equirectShader==null&&(this._equirectShader=wq());const s=e.isCubeTexture?this._cubemapShader:this._equirectShader,i=new hs(h1[0],s),o=s.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=hh[e.encoding],o.outputEncoding.value=hh[t.texture.encoding],xE(t,0,0,3*rh,2*rh),r.setRenderTarget(t),r.render(i,OP)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;for(let s=1;s<Xle;s++){const i=Math.sqrt(wE[s]*wE[s]-wE[s-1]*wE[s-1]),o=yq[(s-1)%yq.length];this._blur(e,s-1,s,i,o)}t.autoClear=r}_blur(e,t,r,s,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,s,"latitudinal",i),this._halfBlur(o,e,r,r,s,"longitudinal",i)}_halfBlur(e,t,r,s,i,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new hs(h1[s],c),f=c.uniforms,d=mq[r]-1,p=isFinite(i)?Math.PI/(2*d):2*Math.PI/(2*ib-1),m=i/p,g=isFinite(i)?1+Math.floor(u*m):ib;g>ib&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${ib}`);const y=[];let b=0;for(let C=0;C<ib;++C){const k=C/m,A=Math.exp(-k*k/2);y.push(A),C==0?b+=A:C<g&&(b+=2*A)}for(let C=0;C<y.length;C++)y[C]=y[C]/b;f.envMap.value=e.texture,f.samples.value=g,f.weights.value=y,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a),f.dTheta.value=p,f.mipInt.value=Qd-r,f.inputEncoding.value=hh[e.texture.encoding],f.outputEncoding.value=hh[e.texture.encoding];const x=mq[s],w=3*Math.max(0,rh-2*x),S=(s===0?0:2*rh)+2*x*(s>Qd-Ob?s-Qd+Ob:0);xE(t,w,S,3*x,2*x),l.setRenderTarget(t),l.render(h,OP)}}function Tbt(n){return n===void 0||n.type!==ox?!1:n.encoding===Sa||n.encoding===UC||n.encoding===N$}function Ebt(){const n=[],e=[],t=[];let r=Qd;for(let s=0;s<Xle;s++){const i=Math.pow(2,r);e.push(i);let o=1/i;s>Qd-Ob?o=qle[s-Qd+Ob-1]:s==0&&(o=0),t.push(o);const a=1/(i-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,f=6,d=3,p=2,m=1,g=new Float32Array(d*f*h),y=new Float32Array(p*f*h),b=new Float32Array(m*f*h);for(let w=0;w<h;w++){const S=w%3*2/3-1,C=w>2?0:-1,k=[S,C,0,S+2/3,C,0,S+2/3,C+1,0,S,C,0,S+2/3,C+1,0,S,C+1,0];g.set(k,d*f*w),y.set(u,p*f*w);const A=[w,w,w,w,w,w];b.set(A,m*f*w)}const x=new un;x.setAttribute("position",new Cn(g,d)),x.setAttribute("uv",new Cn(y,p)),x.setAttribute("faceIndex",new Cn(b,m)),n.push(x),r>Ob&&r--}return{_lodPlanes:n,_sizeLods:e,_sigmas:t}}function vq(n){const e=new Yd(3*rh,3*rh,n);return e.texture.mapping=sx,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function xE(n,e,t,r,s){n.viewport.set(e,t,r,s),n.scissor.set(e,t,r,s)}function Ibt(n){const e=new Float32Array(n),t=new Q(0,1,0);return new Df({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:hh[Sa]},outputEncoding:{value:hh[Sa]}},vertexShader:TV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${EV()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:If,depthTest:!1,depthWrite:!1})}function wq(){const n=new st(1,1);return new Df({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:hh[Sa]},outputEncoding:{value:hh[Sa]}},vertexShader:TV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${EV()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:If,depthTest:!1,depthWrite:!1})}function xq(){return new Df({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:hh[Sa]},outputEncoding:{value:hh[Sa]}},vertexShader:TV(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${EV()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:If,depthTest:!1,depthWrite:!1})}function TV(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function EV(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function Abt(n,e,t,r,s,i,o){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new uV(n,e,t,s,i,o)}const Mbt=0,Nbt=1,$bt=0,Rbt=1,Pbt=2;function Dbt(n){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),n}function Obt(n=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),n.isMultiMaterial=!0,n.materials=n,n.clone=function(){return n.slice()},n}function Fbt(n,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new mv(n,e)}function Lbt(n){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new vS(n)}function zbt(n,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new mv(n,e)}function Bbt(n){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Tu(n)}function Vbt(n){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Tu(n)}function Ubt(n){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Tu(n)}function Wbt(n,e,t){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new Q(n,e,t)}function Gbt(n,e){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Cn(n,e).setUsage(bg)}function Hbt(n,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new hS(n,e)}function jbt(n,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new fS(n,e)}function qbt(n,e){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new dS(n,e)}function Xbt(n,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new pS(n,e)}function Kbt(n,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new vg(n,e)}function Ybt(n,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new mS(n,e)}function Zbt(n,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new wg(n,e)}function Jbt(n,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new Xt(n,e)}function Qbt(n,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new yS(n,e)}on.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(on.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};Object.assign(au.prototype,{fromPoints:function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)}});function Kle(n){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Qo.call(this,n),this.type="catmullrom",this.closed=!0}Kle.prototype=Object.create(Qo.prototype);function Yle(n){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),Qo.call(this,n),this.type="catmullrom"}Yle.prototype=Object.create(Qo.prototype);function IV(n){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),Qo.call(this,n),this.type="catmullrom"}IV.prototype=Object.create(Qo.prototype);Object.assign(IV.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});function evt(n){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Hle(n)}function tvt(n,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Gle(n,e)}function nvt(n,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new ka(new dV(n.geometry),new Es({color:e!==void 0?e:16777215}))}Wle.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Vle.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};function rvt(n,e){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new ka(new pV(n.geometry),new Es({color:e!==void 0?e:16777215}))}Object.assign(zr.prototype,{extractUrlBase:function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),yV.extractUrlBase(n)}});zr.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};function svt(n){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Nc(n)}function ivt(n){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new ZA(n)}Object.assign(zle.prototype,{center:function(n){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},size:function(n){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(Xf.prototype,{center:function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionSphere:function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)},size:function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)}});Object.assign(zp.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}});GC.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};Ble.prototype.center=function(n){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Object.assign(In,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(n){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),In.floorPowerOfTwo(n)},nextPowerOfTwo:function(n){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),In.ceilPowerOfTwo(n)}});Object.assign(_l.prototype,{flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},multiplyVector3:function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});Object.assign(Zn.prototype,{extractPosition:function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)},flattenToArrayOffset:function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new Q().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector4:function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)},crossVector:function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(n,e,t,r,s,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,r,t,s,i)},getInverse:function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()}});ah.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Object.assign(co.prototype,{multiplyVector3:function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}});Object.assign(ax.prototype,{isIntersectionBox:function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)},isIntersectionPlane:function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)},isIntersectionSphere:function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)}});Object.assign(jo.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)},midpoint:function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)},normal:function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)},plane:function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)}});Object.assign(jo,{barycoordFromPoint:function(n,e,t,r,s){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),jo.getBarycoord(n,e,t,r,s)},normal:function(n,e,t,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),jo.getNormal(n,e,t,r)}});Object.assign(Jd.prototype,{extractAllPoints:function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)},extrude:function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Sg(this,n)},makeGeometry:function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new MS(this,n)}});Object.assign(st.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Q.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)},getScaleFromMatrix:function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)},getColumnFromMatrix:function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)},applyProjection:function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)},fromAttribute:function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},distanceToManhattan:function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Hr.prototype,{fromAttribute:function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(rn.prototype,{getChildByName:function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(rn.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.assign(hs.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}});Object.defineProperties(hs.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),ale},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Object.defineProperties(wS.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}});Object.defineProperty(SS.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});xS.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(on.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(n){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=n}});Si.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(fs.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(Cn.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===bg},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(bg)}}});Object.assign(Cn.prototype,{setDynamic:function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?bg:WC),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(un.prototype,{addIndex:function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)},addAttribute:function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new Cn(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)},addDrawCall:function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)},applyMatrix:function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)}});Object.defineProperties(un.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(PS.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(n){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=n}}});Object.defineProperties(kV.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(n){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=n}}});Object.defineProperties(Sl.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===bg},set:function(n){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(n)}}});Object.assign(Sl.prototype,{setDynamic:function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?bg:WC),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(Sg.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}});Object.assign(fV.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}});Object.defineProperties(O$.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}});Object.defineProperties(kn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ht}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===tV}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}}});Object.defineProperties(_p.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(xp.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(n){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=n}}});Object.defineProperties(Ca.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Object.assign(HC.prototype,{clearTarget:function(n,e,t,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,r)},animate:function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}});Object.defineProperties(HC.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?UC:Sa}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(Cle.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});function ovt(n,e,t){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new hV(n,t)}Object.defineProperties(Yd.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});Object.defineProperties(wV.prototype,{load:{value:function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new lM().load(n,function(r){e.setBuffer(r)}),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}});Ole.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()};_g.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};_g.prototype.clear=function(n,e,t,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,r)};const avt={merge:function(n,e,t){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");let r;e.isMesh&&(e.matrixAutoUpdate&&e.updateMatrix(),r=e.matrix,e=e.geometry),n.merge(e,r,t)},center:function(n){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),n.center()}};Jy.crossOrigin=void 0;Jy.loadTexture=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const s=new JA;s.setCrossOrigin(this.crossOrigin);const i=s.load(n,t,void 0,r);return e&&(i.mapping=e),i};Jy.loadTextureCube=function(n,e,t,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const s=new YA;s.setCrossOrigin(this.crossOrigin);const i=s.load(n,t,void 0,r);return e&&(i.mapping=e),i};Jy.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Jy.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};function lvt(){console.error("THREE.CanvasRenderer has been removed")}function cvt(){console.error("THREE.JSONLoader has been removed.")}const uvt={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function hvt(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Q4}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Q4);const fvt=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:uae,AddEquation:Om,AddOperation:oae,AdditiveAnimationBlendMode:iV,AdditiveBlending:_F,AlphaFormat:bae,AlwaysDepth:Qoe,AlwaysStencilFunc:fle,AmbientLight:rM,AmbientLightProbe:QF,AnimationClip:wl,AnimationLoader:GF,AnimationMixer:eL,AnimationObjectGroup:Lle,AnimationUtils:ps,ArcCurve:xv,ArrayCamera:MA,ArrowHelper:xbt,Audio:wV,AudioAnalyser:Ole,AudioContext:vV,AudioListener:Q0t,AudioLoader:lM,AxesHelper:Hle,AxisHelper:evt,BackSide:gi,BasicDepthPacking:cle,BasicShadowMap:Tdt,BinaryTextureLoader:ivt,Bone:_S,BooleanKeyframeTrack:jA,BoundingBoxHelper:tvt,Box2:zle,Box3:Xf,Box3Helper:vbt,BoxBufferGeometry:xg,BoxGeometry:xg,BoxHelper:Gle,BufferAttribute:Cn,BufferGeometry:un,BufferGeometryLoader:aM,ByteType:fae,Cache:Ng,Camera:kh,CameraHelper:bbt,CanvasRenderer:lvt,CanvasTexture:CS,CatmullRomCurve3:Qo,CineonToneMapping:cae,CircleBufferGeometry:RA,CircleGeometry:RA,ClampToEdgeWrapping:da,Clock:Dle,ClosedSplineCurve3:Kle,Color:Ht,ColorKeyframeTrack:qA,CompressedTexture:gv,CompressedTextureLoader:HF,ConeBufferGeometry:PA,ConeGeometry:PA,CubeCamera:_g,CubeReflectionMapping:zC,CubeRefractionMapping:BC,CubeTexture:Th,CubeTextureLoader:YA,CubeUVReflectionMapping:sx,CubeUVRefractionMapping:VC,CubicBezierCurve:Eu,CubicBezierCurve3:Ih,CubicInterpolant:GA,CullFaceBack:xF,CullFaceFront:Loe,CullFaceFrontBack:kdt,CullFaceNone:Foe,Curve:on,CurvePath:Bd,CustomBlending:Boe,CustomToneMapping:hae,CylinderBufferGeometry:yv,CylinderGeometry:yv,Cylindrical:hbt,DataTexture:Pf,DataTexture2DArray:dv,DataTexture3D:pv,DataTextureLoader:ZA,DataUtils:Sbt,DecrementStencilOp:Fdt,DecrementWrapStencilOp:zdt,DefaultLoadingManager:Nle,DepthFormat:Qm,DepthStencilFormat:hv,DepthTexture:kS,DirectionalLight:nM,DirectionalLightHelper:ybt,DiscreteInterpolant:HA,DodecahedronBufferGeometry:DA,DodecahedronGeometry:DA,DoubleSide:FC,DstAlphaFactor:qoe,DstColorFactor:Koe,DynamicBufferAttribute:Gbt,DynamicCopyUsage:Qdt,DynamicDrawUsage:bg,DynamicReadUsage:Ydt,EdgesGeometry:dV,EdgesHelper:nvt,EllipseCurve:Dl,EqualDepth:tae,EqualStencilFunc:Wdt,EquirectangularReflectionMapping:TA,EquirectangularRefractionMapping:EA,Euler:lx,EventDispatcher:Uu,ExtrudeBufferGeometry:Sg,ExtrudeGeometry:Sg,Face3:uV,Face4:Abt,FaceColors:Rbt,FileLoader:Nc,FlatShading:tV,Float16BufferAttribute:gS,Float32Attribute:Jbt,Float32BufferAttribute:Xt,Float64Attribute:Qbt,Float64BufferAttribute:yS,FloatType:Sf,Fog:P$,FogExp2:R$,Font:Rle,FontLoader:ZF,FrontSide:rx,Frustum:GC,GLBufferAttribute:CV,GLSL1:tpt,GLSL3:FF,GammaEncoding:N$,GeometryUtils:avt,GreaterDepth:rae,GreaterEqualDepth:nae,GreaterEqualStencilFunc:qdt,GreaterStencilFunc:Hdt,GridHelper:Wle,Group:zd,HalfFloatType:lS,HemisphereLight:QA,HemisphereLightHelper:mbt,HemisphereLightProbe:JF,IcosahedronBufferGeometry:OA,IcosahedronGeometry:OA,ImageBitmapLoader:YF,ImageLoader:wv,ImageUtils:Jy,ImmediateRenderObject:DS,IncrementStencilOp:Odt,IncrementWrapStencilOp:Ldt,InstancedBufferAttribute:oM,InstancedBufferGeometry:PS,InstancedInterleavedBuffer:tL,InstancedMesh:NA,Int16Attribute:Xbt,Int16BufferAttribute:pS,Int32Attribute:Ybt,Int32BufferAttribute:mS,Int8Attribute:Hbt,Int8BufferAttribute:hS,IntType:pae,InterleavedBuffer:Sl,InterleavedBufferAttribute:yp,Interpolant:Il,InterpolateDiscrete:cS,InterpolateLinear:a_,InterpolateSmooth:nI,InvertStencilOp:Bdt,JSONLoader:cvt,KeepStencilOp:rI,KeyframeTrack:Co,LOD:wS,LatheBufferGeometry:FA,LatheGeometry:FA,Layers:cV,LensFlare:hvt,LessDepth:eae,LessEqualDepth:kA,LessEqualStencilFunc:Gdt,LessStencilFunc:Udt,Light:fs,LightProbe:xc,Line:Mc,Line3:Ble,LineBasicMaterial:Es,LineCurve:Za,LineCurve3:Iu,LineDashedMaterial:Mg,LineLoop:$A,LinePieces:Nbt,LineSegments:ka,LineStrip:Mbt,LinearEncoding:Sa,LinearFilter:lo,LinearInterpolant:$S,LinearMipMapLinearFilter:Ndt,LinearMipMapNearestFilter:Mdt,LinearMipmapLinearFilter:ix,LinearMipmapNearestFilter:sV,LinearToneMapping:aae,Loader:zr,LoaderUtils:yV,LoadingManager:mV,LogLuvEncoding:lle,LoopOnce:sle,LoopPingPong:ole,LoopRepeat:ile,LuminanceAlphaFormat:wae,LuminanceFormat:vae,MOUSE:vf,Material:kn,MaterialLoader:iM,Math:In,MathUtils:In,Matrix3:_l,Matrix4:Zn,MaxEquation:TF,Mesh:hs,MeshBasicMaterial:Rl,MeshDepthMaterial:mp,MeshDistanceMaterial:gp,MeshFaceMaterial:Dbt,MeshLambertMaterial:Ig,MeshMatcapMaterial:Ag,MeshNormalMaterial:Eg,MeshPhongMaterial:_p,MeshPhysicalMaterial:xp,MeshStandardMaterial:Eh,MeshToonMaterial:Tg,MinEquation:kF,MirroredRepeatWrapping:oS,MixOperation:iae,MultiMaterial:Obt,MultiplyBlending:CF,MultiplyOperation:LC,NearestFilter:Ui,NearestMipMapLinearFilter:Adt,NearestMipMapNearestFilter:Idt,NearestMipmapLinearFilter:AA,NearestMipmapNearestFilter:IA,NeverDepth:Joe,NeverStencilFunc:Vdt,NoBlending:If,NoColors:$bt,NoToneMapping:Jm,NormalAnimationBlendMode:M$,NormalBlending:Pb,NotEqualDepth:sae,NotEqualStencilFunc:jdt,NumberKeyframeTrack:bv,Object3D:rn,ObjectLoader:X0t,ObjectSpaceNormalMap:hle,OctahedronBufferGeometry:AS,OctahedronGeometry:AS,OneFactor:Goe,OneMinusDstAlphaFactor:Xoe,OneMinusDstColorFactor:Yoe,OneMinusSrcAlphaFactor:rV,OneMinusSrcColorFactor:joe,OrthographicCamera:_v,PCFShadowMap:eV,PCFSoftShadowMap:zoe,PMREMGenerator:kbt,ParametricBufferGeometry:Cg,ParametricGeometry:Cg,Particle:Lbt,ParticleBasicMaterial:Vbt,ParticleSystem:zbt,ParticleSystemMaterial:Ubt,Path:au,PerspectiveCamera:Si,Plane:ah,PlaneBufferGeometry:bS,PlaneGeometry:bS,PlaneHelper:wbt,PointCloud:Fbt,PointCloudMaterial:Bbt,PointLight:tM,PointLightHelper:dbt,Points:mv,PointsMaterial:Tu,PolarGridHelper:gbt,PolyhedronBufferGeometry:vp,PolyhedronGeometry:vp,PositionalAudio:tbt,PropertyBinding:Ko,PropertyMixer:xV,QuadraticBezierCurve:Au,QuadraticBezierCurve3:Ah,Quaternion:co,QuaternionKeyframeTrack:RS,QuaternionLinearInterpolant:XA,REVISION:Q4,RGBADepthPacking:ule,RGBAFormat:El,RGBAIntegerFormat:Eae,RGBA_ASTC_10x10_Format:Bae,RGBA_ASTC_10x5_Format:Fae,RGBA_ASTC_10x6_Format:Lae,RGBA_ASTC_10x8_Format:zae,RGBA_ASTC_12x10_Format:Vae,RGBA_ASTC_12x12_Format:Uae,RGBA_ASTC_4x4_Format:Aae,RGBA_ASTC_5x4_Format:Mae,RGBA_ASTC_5x5_Format:Nae,RGBA_ASTC_6x5_Format:$ae,RGBA_ASTC_6x6_Format:Rae,RGBA_ASTC_8x5_Format:Pae,RGBA_ASTC_8x6_Format:Dae,RGBA_ASTC_8x8_Format:Oae,RGBA_BPTC_Format:Wae,RGBA_ETC2_EAC_Format:OF,RGBA_PVRTC_2BPPV1_Format:PF,RGBA_PVRTC_4BPPV1_Format:RF,RGBA_S3TC_DXT1_Format:IF,RGBA_S3TC_DXT3_Format:AF,RGBA_S3TC_DXT5_Format:MF,RGBDEncoding:lV,RGBEEncoding:$$,RGBEFormat:xae,RGBFormat:Kd,RGBIntegerFormat:Tae,RGBM16Encoding:aV,RGBM7Encoding:oV,RGB_ETC1_Format:Iae,RGB_ETC2_Format:DF,RGB_PVRTC_2BPPV1_Format:$F,RGB_PVRTC_4BPPV1_Format:NF,RGB_S3TC_DXT1_Format:EF,RGFormat:Cae,RGIntegerFormat:kae,RawShaderMaterial:Df,Ray:ax,Raycaster:kV,RectAreaLight:sM,RedFormat:_ae,RedIntegerFormat:Sae,ReinhardToneMapping:lae,RepeatWrapping:iS,ReplaceStencilOp:Ddt,ReverseSubtractEquation:Uoe,RingBufferGeometry:LA,RingGeometry:LA,SRGB8_ALPHA8_ASTC_10x10_Format:tle,SRGB8_ALPHA8_ASTC_10x5_Format:Jae,SRGB8_ALPHA8_ASTC_10x6_Format:Qae,SRGB8_ALPHA8_ASTC_10x8_Format:ele,SRGB8_ALPHA8_ASTC_12x10_Format:nle,SRGB8_ALPHA8_ASTC_12x12_Format:rle,SRGB8_ALPHA8_ASTC_4x4_Format:Gae,SRGB8_ALPHA8_ASTC_5x4_Format:Hae,SRGB8_ALPHA8_ASTC_5x5_Format:jae,SRGB8_ALPHA8_ASTC_6x5_Format:qae,SRGB8_ALPHA8_ASTC_6x6_Format:Xae,SRGB8_ALPHA8_ASTC_8x5_Format:Kae,SRGB8_ALPHA8_ASTC_8x6_Format:Yae,SRGB8_ALPHA8_ASTC_8x8_Format:Zae,Scene:fV,SceneUtils:uvt,ShaderChunk:Jn,ShaderLib:iu,ShaderMaterial:Ca,ShadowMaterial:kg,Shape:Jd,ShapeBufferGeometry:MS,ShapeGeometry:MS,ShapePath:bV,ShapeUtils:Af,ShortType:dae,Skeleton:SS,SkeletonHelper:Vle,SkinnedMesh:xS,SmoothShading:Edt,Sphere:zp,SphereBufferGeometry:NS,SphereGeometry:NS,Spherical:rL,SphericalHarmonics3:$le,Spline:IV,SplineCurve:Mu,SplineCurve3:Yle,SpotLight:eM,SpotLightHelper:fbt,Sprite:vS,SpriteMaterial:bp,SrcAlphaFactor:nV,SrcAlphaSaturateFactor:Zoe,SrcColorFactor:Hoe,StaticCopyUsage:Jdt,StaticDrawUsage:WC,StaticReadUsage:Kdt,StereoCamera:Ple,StreamCopyUsage:ept,StreamDrawUsage:Xdt,StreamReadUsage:Zdt,StringKeyframeTrack:KA,SubtractEquation:Voe,SubtractiveBlending:SF,TOUCH:wf,TangentSpaceNormalMap:Zy,TetrahedronBufferGeometry:zA,TetrahedronGeometry:zA,TextBufferGeometry:BA,TextGeometry:BA,Texture:Kr,TextureLoader:JA,TorusBufferGeometry:VA,TorusGeometry:VA,TorusKnotBufferGeometry:UA,TorusKnotGeometry:UA,Triangle:jo,TriangleFanDrawMode:Rdt,TriangleStripDrawMode:$dt,TrianglesDrawMode:ale,TubeBufferGeometry:WA,TubeGeometry:WA,UVMapping:A$,Uint16Attribute:Kbt,Uint16BufferAttribute:vg,Uint32Attribute:Zbt,Uint32BufferAttribute:wg,Uint8Attribute:jbt,Uint8BufferAttribute:fS,Uint8ClampedAttribute:qbt,Uint8ClampedBufferAttribute:dS,Uniform:O$,UniformsLib:Pt,UniformsUtils:mle,UnsignedByteType:ox,UnsignedInt248Type:Db,UnsignedIntType:o_,UnsignedShort4444Type:mae,UnsignedShort5551Type:gae,UnsignedShort565Type:yae,UnsignedShortType:aS,VSMShadowMap:_b,Vector2:st,Vector3:Q,Vector4:Hr,VectorKeyframeTrack:vv,Vertex:Wbt,VertexColors:Pbt,VideoTexture:VF,WebGL1Renderer:zF,WebGLCubeRenderTarget:hV,WebGLMultisampleRenderTarget:rpt,WebGLRenderTarget:Yd,WebGLRenderTargetCube:ovt,WebGLRenderer:HC,WebGLUtils:kle,WireframeGeometry:pV,WireframeHelper:rvt,WrapAroundEnding:uS,XHRLoader:svt,ZeroCurvatureEnding:Wm,ZeroFactor:Woe,ZeroSlopeEnding:Gm,ZeroStencilOp:Pdt,sRGBEncoding:UC},Symbol.toStringTag,{value:"Module"})),Qy=zf(fvt);var OS=function(n,e){e===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),e===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=n,this.domElement=e,this.enabled=!0,this.target=new Q,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:vf.ROTATE,MIDDLE:vf.DOLLY,RIGHT:vf.PAN},this.touches={ONE:wf.ROTATE,TWO:wf.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(ce){ce.addEventListener("keydown",ye),this._domElementKeyEvents=ce},this.saveState=function(){t.target0.copy(t.target),t.position0.copy(t.object.position),t.zoom0=t.object.zoom},this.reset=function(){t.target.copy(t.target0),t.object.position.copy(t.position0),t.object.zoom=t.zoom0,t.object.updateProjectionMatrix(),t.dispatchEvent(r),t.update(),a=o.NONE},this.update=function(){var ce=new Q,nt=new co().setFromUnitVectors(n.up,new Q(0,1,0)),St=nt.clone().invert(),gt=new Q,Gt=new co,Mn=2*Math.PI;return function(){var Bs=t.object.position;ce.copy(Bs).sub(t.target),ce.applyQuaternion(nt),c.setFromVector3(ce),t.autoRotate&&a===o.NONE&&M(k()),t.enableDamping?(c.theta+=u.theta*t.dampingFactor,c.phi+=u.phi*t.dampingFactor):(c.theta+=u.theta,c.phi+=u.phi);var As=t.minAzimuthAngle,Ms=t.maxAzimuthAngle;return isFinite(As)&&isFinite(Ms)&&(As<-Math.PI?As+=Mn:As>Math.PI&&(As-=Mn),Ms<-Math.PI?Ms+=Mn:Ms>Math.PI&&(Ms-=Mn),As<=Ms?c.theta=Math.max(As,Math.min(Ms,c.theta)):c.theta=c.theta>(As+Ms)/2?Math.max(As,c.theta):Math.min(Ms,c.theta)),c.phi=Math.max(t.minPolarAngle,Math.min(t.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=h,c.radius=Math.max(t.minDistance,Math.min(t.maxDistance,c.radius)),t.enableDamping===!0?t.target.addScaledVector(f,t.dampingFactor):t.target.add(f),ce.setFromSpherical(c),ce.applyQuaternion(St),Bs.copy(t.target).add(ce),t.object.lookAt(t.target),t.enableDamping===!0?(u.theta*=1-t.dampingFactor,u.phi*=1-t.dampingFactor,f.multiplyScalar(1-t.dampingFactor)):(u.set(0,0,0),f.set(0,0,0)),h=1,d||gt.distanceToSquared(t.object.position)>l||8*(1-Gt.dot(t.object.quaternion))>l?(t.dispatchEvent(r),gt.copy(t.object.position),Gt.copy(t.object.quaternion),d=!1,!0):!1}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",ft),t.domElement.removeEventListener("pointerdown",Be),t.domElement.removeEventListener("wheel",Ge),t.domElement.removeEventListener("touchstart",Ze),t.domElement.removeEventListener("touchend",Ct),t.domElement.removeEventListener("touchmove",yt),t.domElement.ownerDocument.removeEventListener("pointermove",ut),t.domElement.ownerDocument.removeEventListener("pointerup",Ke),t._domElementKeyEvents!==null&&t._domElementKeyEvents.removeEventListener("keydown",ye)};var t=this,r={type:"change"},s={type:"start"},i={type:"end"},o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},a=o.NONE,l=1e-6,c=new rL,u=new rL,h=1,f=new Q,d=!1,p=new st,m=new st,g=new st,y=new st,b=new st,x=new st,w=new st,S=new st,C=new st;function k(){return 2*Math.PI/60/60*t.autoRotateSpeed}function A(){return Math.pow(.95,t.zoomSpeed)}function M(ce){u.theta-=ce}function E(ce){u.phi-=ce}var N=function(){var ce=new Q;return function(St,gt){ce.setFromMatrixColumn(gt,0),ce.multiplyScalar(-St),f.add(ce)}}(),O=function(){var ce=new Q;return function(St,gt){t.screenSpacePanning===!0?ce.setFromMatrixColumn(gt,1):(ce.setFromMatrixColumn(gt,0),ce.crossVectors(t.object.up,ce)),ce.multiplyScalar(St),f.add(ce)}}(),R=function(){var ce=new Q;return function(St,gt){var Gt=t.domElement;if(t.object.isPerspectiveCamera){var Mn=t.object.position;ce.copy(Mn).sub(t.target);var Cr=ce.length();Cr*=Math.tan(t.object.fov/2*Math.PI/180),N(2*St*Cr/Gt.clientHeight,t.object.matrix),O(2*gt*Cr/Gt.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera?(N(St*(t.object.right-t.object.left)/t.object.zoom/Gt.clientWidth,t.object.matrix),O(gt*(t.object.top-t.object.bottom)/t.object.zoom/Gt.clientHeight,t.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),t.enablePan=!1)}}();function D(ce){t.object.isPerspectiveCamera?h/=ce:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom*ce)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function z(ce){t.object.isPerspectiveCamera?h*=ce:t.object.isOrthographicCamera?(t.object.zoom=Math.max(t.minZoom,Math.min(t.maxZoom,t.object.zoom/ce)),t.object.updateProjectionMatrix(),d=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),t.enableZoom=!1)}function B(ce){p.set(ce.clientX,ce.clientY)}function X(ce){w.set(ce.clientX,ce.clientY)}function G(ce){y.set(ce.clientX,ce.clientY)}function te(ce){m.set(ce.clientX,ce.clientY),g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var nt=t.domElement;M(2*Math.PI*g.x/nt.clientHeight),E(2*Math.PI*g.y/nt.clientHeight),p.copy(m),t.update()}function ge(ce){S.set(ce.clientX,ce.clientY),C.subVectors(S,w),C.y>0?D(A()):C.y<0&&z(A()),w.copy(S),t.update()}function ae(ce){b.set(ce.clientX,ce.clientY),x.subVectors(b,y).multiplyScalar(t.panSpeed),R(x.x,x.y),y.copy(b),t.update()}function Ne(ce){ce.deltaY<0?z(A()):ce.deltaY>0&&D(A()),t.update()}function ke(ce){var nt=!1;switch(ce.keyCode){case t.keys.UP:R(0,t.keyPanSpeed),nt=!0;break;case t.keys.BOTTOM:R(0,-t.keyPanSpeed),nt=!0;break;case t.keys.LEFT:R(t.keyPanSpeed,0),nt=!0;break;case t.keys.RIGHT:R(-t.keyPanSpeed,0),nt=!0;break}nt&&(ce.preventDefault(),t.update())}function De(ce){if(ce.touches.length==1)p.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);p.set(nt,St)}}function be(ce){if(ce.touches.length==1)y.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);y.set(nt,St)}}function Xe(ce){var nt=ce.touches[0].pageX-ce.touches[1].pageX,St=ce.touches[0].pageY-ce.touches[1].pageY,gt=Math.sqrt(nt*nt+St*St);w.set(0,gt)}function Oe(ce){t.enableZoom&&Xe(ce),t.enablePan&&be(ce)}function it(ce){t.enableZoom&&Xe(ce),t.enableRotate&&De(ce)}function We(ce){if(ce.touches.length==1)m.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);m.set(nt,St)}g.subVectors(m,p).multiplyScalar(t.rotateSpeed);var gt=t.domElement;M(2*Math.PI*g.x/gt.clientHeight),E(2*Math.PI*g.y/gt.clientHeight),p.copy(m)}function dt(ce){if(ce.touches.length==1)b.set(ce.touches[0].pageX,ce.touches[0].pageY);else{var nt=.5*(ce.touches[0].pageX+ce.touches[1].pageX),St=.5*(ce.touches[0].pageY+ce.touches[1].pageY);b.set(nt,St)}x.subVectors(b,y).multiplyScalar(t.panSpeed),R(x.x,x.y),y.copy(b)}function ct(ce){var nt=ce.touches[0].pageX-ce.touches[1].pageX,St=ce.touches[0].pageY-ce.touches[1].pageY,gt=Math.sqrt(nt*nt+St*St);S.set(0,gt),C.set(0,Math.pow(S.y/w.y,t.zoomSpeed)),D(C.y),w.copy(S)}function Ve(ce){t.enableZoom&&ct(ce),t.enablePan&&dt(ce)}function ze(ce){t.enableZoom&&ct(ce),t.enableRotate&&We(ce)}function Be(ce){if(t.enabled!==!1)switch(ce.pointerType){case"mouse":case"pen":ee(ce);break}}function ut(ce){if(t.enabled!==!1)switch(ce.pointerType){case"mouse":case"pen":J(ce);break}}function Ke(ce){switch(ce.pointerType){case"mouse":case"pen":rt();break}}function ee(ce){ce.preventDefault(),t.domElement.focus?t.domElement.focus():window.focus();var nt;switch(ce.button){case 0:nt=t.mouseButtons.LEFT;break;case 1:nt=t.mouseButtons.MIDDLE;break;case 2:nt=t.mouseButtons.RIGHT;break;default:nt=-1}switch(nt){case vf.DOLLY:if(t.enableZoom===!1)return;X(ce),a=o.DOLLY;break;case vf.ROTATE:if(ce.ctrlKey||ce.metaKey||ce.shiftKey){if(t.enablePan===!1)return;G(ce),a=o.PAN}else{if(t.enableRotate===!1)return;B(ce),a=o.ROTATE}break;case vf.PAN:if(ce.ctrlKey||ce.metaKey||ce.shiftKey){if(t.enableRotate===!1)return;B(ce),a=o.ROTATE}else{if(t.enablePan===!1)return;G(ce),a=o.PAN}break;default:a=o.NONE}a!==o.NONE&&(t.domElement.ownerDocument.addEventListener("pointermove",ut),t.domElement.ownerDocument.addEventListener("pointerup",Ke),t.dispatchEvent(s))}function J(ce){if(t.enabled!==!1)switch(ce.preventDefault(),a){case o.ROTATE:if(t.enableRotate===!1)return;te(ce);break;case o.DOLLY:if(t.enableZoom===!1)return;ge(ce);break;case o.PAN:if(t.enablePan===!1)return;ae(ce);break}}function rt(ce){t.domElement.ownerDocument.removeEventListener("pointermove",ut),t.domElement.ownerDocument.removeEventListener("pointerup",Ke),t.enabled!==!1&&(t.dispatchEvent(i),a=o.NONE)}function Ge(ce){t.enabled===!1||t.enableZoom===!1||a!==o.NONE&&a!==o.ROTATE||(ce.preventDefault(),ce.stopPropagation(),t.dispatchEvent(s),Ne(ce),t.dispatchEvent(i))}function ye(ce){t.enabled===!1||t.enablePan===!1||ke(ce)}function Ze(ce){if(t.enabled!==!1){switch(ce.preventDefault(),ce.touches.length){case 1:switch(t.touches.ONE){case wf.ROTATE:if(t.enableRotate===!1)return;De(ce),a=o.TOUCH_ROTATE;break;case wf.PAN:if(t.enablePan===!1)return;be(ce),a=o.TOUCH_PAN;break;default:a=o.NONE}break;case 2:switch(t.touches.TWO){case wf.DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Oe(ce),a=o.TOUCH_DOLLY_PAN;break;case wf.DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;it(ce),a=o.TOUCH_DOLLY_ROTATE;break;default:a=o.NONE}break;default:a=o.NONE}a!==o.NONE&&t.dispatchEvent(s)}}function yt(ce){if(t.enabled!==!1)switch(ce.preventDefault(),ce.stopPropagation(),a){case o.TOUCH_ROTATE:if(t.enableRotate===!1)return;We(ce),t.update();break;case o.TOUCH_PAN:if(t.enablePan===!1)return;dt(ce),t.update();break;case o.TOUCH_DOLLY_PAN:if(t.enableZoom===!1&&t.enablePan===!1)return;Ve(ce),t.update();break;case o.TOUCH_DOLLY_ROTATE:if(t.enableZoom===!1&&t.enableRotate===!1)return;ze(ce),t.update();break;default:a=o.NONE}}function Ct(ce){t.enabled!==!1&&(t.dispatchEvent(i),a=o.NONE)}function ft(ce){t.enabled!==!1&&ce.preventDefault()}t.domElement.addEventListener("contextmenu",ft),t.domElement.addEventListener("pointerdown",Be),t.domElement.addEventListener("wheel",Ge),t.domElement.addEventListener("touchstart",Ze),t.domElement.addEventListener("touchend",Ct),t.domElement.addEventListener("touchmove",yt),this.update()};OS.prototype=Object.create(Uu.prototype);OS.prototype.constructor=OS;var cM=function(n,e){OS.call(this,n,e),this.screenSpacePanning=!1,this.mouseButtons.LEFT=vf.PAN,this.mouseButtons.RIGHT=vf.ROTATE,this.touches.ONE=wf.PAN,this.touches.TWO=wf.DOLLY_ROTATE};cM.prototype=Object.create(Uu.prototype);cM.prototype.constructor=cM;const dvt=Object.freeze(Object.defineProperty({__proto__:null,MapControls:cM,OrbitControls:OS},Symbol.toStringTag,{value:"Module"})),pvt=zf(dvt);var jC={};(function(n){Object.defineProperty(n,"__esModule",{value:!0});var e=function(){function r(s,i,o,a,l,c,u){this.pointIndices=s,this.labelStrings=i,this.scaleFactors=o,this.useSceneOpacityFlags=a,this.defaultFontSize=l,this.fillColors=c,this.strokeColors=u}return r}();n.LabelRenderParams=e,function(r){r[r.Perspective=0]="Perspective",r[r.Orthographic=1]="Orthographic"}(n.CameraType||(n.CameraType={}));var t=function(){function r(s,i,o,a,l,c,u,h,f,d,p,m,g,y){this.camera=s,this.cameraType=i,this.cameraTarget=o,this.screenWidth=a,this.screenHeight=l,this.nearestCameraSpacePointZ=c,this.farthestCameraSpacePointZ=u,this.backgroundColor=h,this.pointColors=f,this.pointScaleFactors=d,this.labels=p,this.polylineColors=m,this.polylineOpacities=g,this.polylineWidths=y}return r}();n.RenderContext=t})(jC);var Yi={};Object.defineProperty(Yi,"__esModule",{value:!0});var du=Qy;function mvt(n,e,t,r){var s=window.devicePixelRatio,i=new du.Vector3().copy(r).project(n),o=[(i.x+1)/2*e*s,-((i.y-1)/2*t)*s];return o}Yi.vector3DToScreenCoords=mvt;function gvt(n,e){var t=e*3;return new du.Vector3(n[t],n[t+1],n[t+2])}Yi.vector3FromPackedArray=gvt;function yvt(n,e,t){for(var r=1/0,s=0,i=new du.Vector3().copy(t).sub(e),o=new du.Vector3().copy(i).normalize(),a=n.length/3,l=0,c=new du.Vector3,u=new du.Vector3,h=0;h<a;h++){c.x=n[l],c.y=n[l+1],c.z=n[l+2],l+=3,u.copy(c).sub(e);var f=o.dot(u);f<0||(s=f>s?f:s,r=f<r?f:r)}return[r,s]}Yi.getNearFarPoints=yvt;function Zle(n,e){return e===void 0&&(e=!0),n.needsUpdate=e,n.minFilter=du.LinearFilter,n.generateMipmaps=!1,n.flipY=!1,n}function bvt(n){var e=new du.Texture(n);return Zle(e)}Yi.createTextureFromCanvas=bvt;function vvt(n,e){var t=new du.Texture(n);return n.complete?(t.needsUpdate=!0,e()):n.onload=function(){t.needsUpdate=!0,e()},Zle(t,!1)}Yi.createTextureFromImage=vvt;function wvt(){try{var n=document.createElement("canvas"),e=n.getContext("webgl")||n.getContext("experimental-webgl");return e!=null}catch{return!1}}Yi.hasWebGLSupport=wvt;function xvt(n){for(var e=1/0,t=-1/0,r=0;r<n.length;r++){var s=n[r];s<e&&(e=s),s>t&&(t=s)}return[e,t]}Yi.extent=xvt;function _vt(n,e,t){var r=e[1]-e[0],s=t[1]-t[0],i=(n-e[0])/r;return i*s+t[0]}Yi.scaleLinear=_vt;function Svt(n,e,t){var r=Math.pow(e[1],Math.E)-Math.pow(e[0],Math.E),s=t[1]-t[0],i=(Math.pow(n,Math.E)-e[0])/r;return i*s+t[0]}Yi.scaleExponential=Svt;function Cvt(n,e,t,r,s){n[e*3]=t,n[e*3+1]=r,n[e*3+2]=s}Yi.packRgbIntoUint8Array=Cvt;function kvt(n){var e=new du.Color(n);return[e.r*255|0,e.g*255|0,e.b*255|0]}Yi.styleRgbFromHexColor=kvt;var _q=function(n){return 100*n+"%"};function Tvt(n,e,t,r,s,i){var o=t+(r-t)*n/e,a="hsl("+o+", "+_q(s)+", "+_q(i)+")";return new du.Color(a)}Yi.getDefaultPointInPolylineColor=Tvt;var AV={};Object.defineProperty(AV,"__esModule",{value:!0});var Evt=function(){function n(e,t,r){this.startCoordinates=[0,0],this.svgElement=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svgElement.style.display="none",this.svgElement.style.height="100%",this.svgElement.style.width="100%",this.svgElement.style.position="absolute",e.insertAdjacentElement("afterbegin",this.svgElement),this.rectElement=document.createElementNS("http://www.w3.org/2000/svg","rect"),this.rectElement.style.stroke=r.select.stroke,this.rectElement.style.strokeDasharray=r.select.strokeDashArray,this.rectElement.style.strokeWidth=""+r.select.strokeWidth,this.rectElement.style.fill=r.select.fill,this.rectElement.style.fillOpacity=""+r.select.fillOpacity,this.svgElement.appendChild(this.rectElement),this.selectionCallback=t,this.isMouseDown=!1}return n.prototype.onMouseDown=function(e,t){this.isMouseDown=!0,this.rectElement.style.display="block",this.svgElement.style.display="block",this.startCoordinates=[e,t],this.lastBoundingBox={x:this.startCoordinates[0],y:this.startCoordinates[1],width:1,height:1}},n.prototype.onMouseMove=function(e,t){this.isMouseDown&&(this.lastBoundingBox.x=Math.min(e,this.startCoordinates[0]),this.lastBoundingBox.y=Math.max(t,this.startCoordinates[1]),this.lastBoundingBox.width=Math.max(e,this.startCoordinates[0])-this.lastBoundingBox.x,this.lastBoundingBox.height=this.lastBoundingBox.y-Math.min(t,this.startCoordinates[1]),this.rectElement.setAttribute("x",""+this.lastBoundingBox.x),this.rectElement.setAttribute("y",""+(this.lastBoundingBox.y-this.lastBoundingBox.height)),this.rectElement.setAttribute("width",""+this.lastBoundingBox.width),this.rectElement.setAttribute("height",""+this.lastBoundingBox.height))},n.prototype.onMouseUp=function(){this.isMouseDown=!1,this.svgElement.style.display="none",this.rectElement.style.display="none",this.rectElement.setAttribute("width","0"),this.rectElement.setAttribute("height","0"),this.selectionCallback(this.lastBoundingBox)},n}();AV.ScatterPlotRectangleSelector=Evt;var uM=pt&&pt.__assign||function(){return uM=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++){e=arguments[t];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s])}return n},uM.apply(this,arguments)},LP=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Sq=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(J4,"__esModule",{value:!0});var _r=Qy,Ivt=pvt,zP=jC,Avt=Yi,Mvt=AV,Jle=2,Nvt=5*Jle,$vt=.025*Jle,Rvt=70,Pvt=.01,Dvt=100,_E=1.2,Cq="Shift",kq="Control",Ovt=new _r.Vector3(.45,.9,1.6),Fvt=new _r.Vector3(0,0,0),Lvt=new _r.Vector3(0,0,4),zvt=new _r.Vector3(0,0,0),Bvt={mouseRotateSpeed:1,autoRotateSpeed:2,zoomSpeed:.125},Vvt=function(){function n(e,t){var r=this;this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.selectEnabled=!0,this.visualizers=new Map,this.onCameraMoveListeners=[],this.height=0,this.width=0,this.dimensions=3,this.interactionMode="PAN",this.pickingTexture=new _r.WebGLRenderTarget(0,0),this.orbitAnimationOnNextCameraCreation=!1,this.orbitAnimationId=null,this.worldSpacePointPositions=new Float32Array(0),this.pointColors=new Float32Array(0),this.pointScaleFactors=new Float32Array(0),this.polylineColors={},this.polylineOpacities=new Float32Array(0),this.polylineWidths=new Float32Array(0),this.selecting=!1,this.nearestPoint=null,this.mouseIsDown=!1,this.isDragSequence=!1,this.lastHovered=null,this.container=e,this.styles=t.styles,this.setParameters(t),this.computeLayoutValues(),this.scene=new _r.Scene,this.renderer=new _r.WebGLRenderer({alpha:!0,premultipliedAlpha:!1,antialias:!1}),this.renderer.setClearColor(this.styles.backgroundColor,1),this.container.appendChild(this.renderer.domElement),this.light=new _r.PointLight(16772287,1,0),this.scene.add(this.light),this.orbitControlParams=uM(uM({},Bvt),t.orbitControlParams),this.rectangleSelector=new Mvt.ScatterPlotRectangleSelector(this.container,function(s){r.selectBoundingBox(s)},this.styles),this.addInteractionListeners(),this.setDimensions(3),this.makeCamera(t.camera),this.resize()}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled)},n.prototype.addInteractionListeners=function(){this.container.addEventListener("pointermove",this.onMouseMove.bind(this)),this.container.addEventListener("pointerdown",this.onMouseDown.bind(this)),this.container.addEventListener("pointerup",this.onMouseUp.bind(this)),this.container.addEventListener("click",this.onClick.bind(this)),window.addEventListener("keydown",this.onKeyDown.bind(this),!1),window.addEventListener("keyup",this.onKeyUp.bind(this),!1)},n.prototype.addCameraControlsEventListeners=function(e){var t=this;e.addEventListener("start",function(){t.stopOrbitAnimation(),t.onCameraMoveListeners.forEach(function(r){return r(t.camera.position,e.target)})}),e.addEventListener("change",function(){t.render()}),e.addEventListener("end",function(){})},n.prototype.makeOrbitControls=function(e,t){this.orbitCameraControls!=null&&this.orbitCameraControls.dispose();var r=new Ivt.OrbitControls(e,this.renderer.domElement);r.zoomSpeed=this.orbitControlParams.zoomSpeed,r.enableRotate=t,r.autoRotate=!1,r.enableKeys=!1,r.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,t?(r.mouseButtons.LEFT=_r.MOUSE.LEFT,r.mouseButtons.RIGHT=_r.MOUSE.RIGHT):(r.mouseButtons.LEFT=_r.MOUSE.RIGHT,r.mouseButtons.RIGHT=_r.MOUSE.LEFT),r.reset(),this.camera=e,this.orbitCameraControls=r,this.addCameraControlsEventListeners(this.orbitCameraControls)},n.prototype.makeCamera=function(e){e===void 0&&(e={});var t=this.makeDefaultCameraDef(this.dimensions,e);this.recreateCamera(t),this.dimensions===3&&this.styles.axesVisible?this.add3dAxes():this.remove3dAxesFromScene()},n.prototype.makeCamera3D=function(e,t,r){var s;{var i=t/r;s=new _r.PerspectiveCamera(Rvt,i,Pvt,Dvt),s.position.set(e.position[0],e.position[1],e.position[2]);var o=new _r.Vector3(e.target[0],e.target[1],e.target[2]);s.lookAt(o),s.zoom=e.zoom,s.updateProjectionMatrix()}this.camera=s,this.makeOrbitControls(s,!0)},n.prototype.makeCamera2D=function(e,t,r){var s,i=new _r.Vector3(e.target[0],e.target[1],e.target[2]);{var o=t/r,a=-_E,l=_E,c=-_E,u=_E;o>1?(a*=o,l*=o):(u/=o,c/=o),s=new _r.OrthographicCamera(a,l,u,c,-1e3,1e3),s.position.set(e.position[0],e.position[1],e.position[2]),s.up=new _r.Vector3(0,0,1),s.lookAt(i),s.zoom=e.zoom,s.updateProjectionMatrix()}this.camera=s,this.makeOrbitControls(s,!1)},n.prototype.makeDefaultCameraDef=function(e,t){t===void 0&&(t={});var r=e===2,s=r?Lvt:Ovt,i=r?zvt:Fvt,o={orthographic:r,zoom:1,position:[s.x,s.y,s.z],target:[i.x,i.y,i.z]};return t.zoom&&(o.zoom=t.zoom),t.position&&(o.position=t.position),t.target&&(o.target=t.target),o},n.prototype.recreateCamera=function(e){e.orthographic?this.makeCamera2D(e,this.width,this.height):this.makeCamera3D(e,this.width,this.height),this.orbitCameraControls.minDistance=$vt,this.orbitCameraControls.maxDistance=Nvt,this.orbitCameraControls.update(),this.orbitAnimationOnNextCameraCreation&&this.startOrbitAnimation()},n.prototype.setInteractionMode=function(e){this.interactionMode=e,e==="SELECT"?(this.selecting=!0,this.container.style.cursor="crosshair",this.orbitCameraControls.enabled=!1):(this.selecting=!1,this.container.style.cursor="default",this.orbitCameraControls.enabled=!0)},n.prototype.onClick=function(e,t){if(t===void 0&&(t=!0),!(e&&this.selecting)){if(!this.isDragSequence&&t){if(this.selectEnabled){var r=this.nearestPoint!=null?[this.nearestPoint]:[];this.selectCallback(r)}this.clickCallback(this.nearestPoint)}this.isDragSequence=!1,this.render()}},n.prototype.onMouseDown=function(e){this.isDragSequence=!1,this.mouseIsDown=!0,this.selecting?(this.rectangleSelector.onMouseDown(e.offsetX,e.offsetY),this.setNearestPointToMouse(e)):!e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===_r.MOUSE.RIGHT?(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.RIGHT):e.ctrlKey&&this.sceneIs3D()&&this.orbitCameraControls.mouseButtons.ORBIT===_r.MOUSE.LEFT&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.LEFT)},n.prototype.onMouseUp=function(e){this.selecting&&(this.rectangleSelector.onMouseUp(),this.render()),this.mouseIsDown=!1},n.prototype.onMouseMove=function(e){this.isDragSequence=this.mouseIsDown,this.selecting&&this.mouseIsDown?(this.rectangleSelector.onMouseMove(e.offsetX,e.offsetY),this.render()):this.mouseIsDown||(this.setNearestPointToMouse(e),this.nearestPoint!=this.lastHovered&&(this.lastHovered=this.nearestPoint,this.hoverCallback(this.nearestPoint)))},n.prototype.onKeyDown=function(e){e.key===kq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.RIGHT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.LEFT),e.key===Cq&&this.selectEnabled&&(this.selecting=!0,this.orbitCameraControls.enabled=!1,this.container.style.cursor="crosshair")},n.prototype.onKeyUp=function(e){e.key===kq&&this.sceneIs3D()&&(this.orbitCameraControls.mouseButtons.ORBIT=_r.MOUSE.LEFT,this.orbitCameraControls.mouseButtons.PAN=_r.MOUSE.RIGHT),e.key===Cq&&this.selectEnabled&&(this.selecting=!1,this.orbitCameraControls.enabled=!0,this.container.style.cursor="default",this.render())},n.prototype.getPointIndicesFromBoundingBox=function(e){if(this.worldSpacePointPositions==null)return[];this.camera.updateMatrixWorld();var t=window.devicePixelRatio||1,r=Math.floor(e.x*t),s=Math.floor(e.y*t),i=Math.max(Math.floor(e.width*t),1),o=Math.max(Math.floor(e.height*t),1);if(i<=2&&o<=2)return this.getPointIndicesFromBoundingBoxPickingTexture(e);for(var a=this.renderer.domElement,l=a.width,c=a.height,u=[],h=new _r.Vector3,f=0;f<this.worldSpacePointPositions.length;f++){var d=f*3,p=LP(this.worldSpacePointPositions.slice(d,d+3),3),m=p[0],g=p[1],y=p[2];h.x=m,h.y=g,h.z=y;var b=h.project(this.camera),x=(b.x+1)*l/2,w=-(b.y-1)*c/2;x>=r&&x<=r+i&&w<=s&&w>=s-o&&u.push(f)}return u},n.prototype.getPointIndicesFromBoundingBoxPickingTexture=function(e){if(this.worldSpacePointPositions==null)return[];var t=this.worldSpacePointPositions.length/3,r=window.devicePixelRatio||1,s=Math.floor(e.x*r),i=Math.floor(e.y*r),o=Math.max(Math.floor(e.width*r),1),a=Math.max(Math.floor(e.height*r),1),l=new Uint8Array(o*a*4);this.renderer.readRenderTargetPixels(this.pickingTexture,s,this.pickingTexture.height-i,o,a,l);for(var c=new Uint8Array(this.worldSpacePointPositions.length),u=0;u<o*a;u++){var h=l[u*4]<<16|l[u*4+1]<<8|l[u*4+2];h!==16777215&&h<t&&(c[h]=1)}for(var f=[],u=0;u<c.length;u++)c[u]===1&&f.push(u);return f},n.prototype.selectBoundingBox=function(e){var t=this.getPointIndicesFromBoundingBox(e);this.selectCallback(t)},n.prototype.setNearestPointToMouse=function(e){if(this.pickingTexture==null){this.nearestPoint=null;return}var t={x:e.offsetX,y:e.offsetY,width:1,height:1},r=this.getPointIndicesFromBoundingBoxPickingTexture(t);this.nearestPoint=r.length?r[0]:null},n.prototype.computeLayoutValues=function(){return this.width=this.container.offsetWidth,this.height=Math.max(1,this.container.offsetHeight),[this.width,this.height]},n.prototype.sceneIs3D=function(){return this.dimensions===3},n.prototype.remove3dAxesFromScene=function(){var e=this.scene.getObjectByName("axes");return e!=null&&this.scene.remove(e),e},n.prototype.add3dAxes=function(){var e=new _r.AxesHelper;e.name="axes",this.scene.add(e)},n.prototype.setDimensions=function(e){if(e!==2&&e!==3)throw new RangeError("dimensions must be 2 or 3");this.dimensions!==e&&(this.dimensions=e,this.makeCamera())},n.prototype.getCameraPosition=function(){var e=this.camera.position;return[e.x,e.y,e.z]},n.prototype.getCameraTarget=function(){var e=this.orbitCameraControls.target;return[e.x,e.y,e.z]},n.prototype.setCameraPositionAndTarget=function(e,t){this.stopOrbitAnimation(),this.camera.position.set(e[0],e[1],e[2]),this.orbitCameraControls.target.set(t[0],t[1],t[2]),this.orbitCameraControls.update(),this.render()},n.prototype.startOrbitAnimation=function(){this.sceneIs3D()&&(this.orbitAnimationId!=null&&this.stopOrbitAnimation(),this.orbitCameraControls.autoRotate=!0,this.orbitCameraControls.autoRotateSpeed=this.orbitControlParams.autoRotateSpeed,this.updateOrbitAnimation())},n.prototype.orbitIsAnimating=function(){return this.orbitAnimationId!=null},n.prototype.updateOrbitAnimation=function(){var e=this;this.orbitCameraControls.update(),this.orbitAnimationId=requestAnimationFrame(function(){return e.updateOrbitAnimation()})},n.prototype.stopOrbitAnimation=function(){this.orbitCameraControls.autoRotate=!1,this.orbitCameraControls.rotateSpeed=this.orbitControlParams.mouseRotateSpeed,this.orbitAnimationId!=null&&(cancelAnimationFrame(this.orbitAnimationId),this.orbitAnimationId=null)},n.prototype.setActiveVisualizers=function(e){var t,r,s,i,o=new Set(e.map(function(f){return f.id}));try{for(var a=Sq(this.visualizers.values()),l=a.next();!l.done;l=a.next()){var c=l.value;o.has(c.id)||(c.dispose(),this.visualizers.delete(c.id))}}catch(f){t={error:f}}finally{try{l&&!l.done&&(r=a.return)&&r.call(a)}finally{if(t)throw t.error}}try{for(var u=Sq(e),h=u.next();!h.done;h=u.next()){var c=h.value;this.visualizers.set(c.id,c),c.setScene(this.scene),c.onResize(this.width,this.height),this.worldSpacePointPositions&&c.onPointPositionsChanged(this.worldSpacePointPositions)}}catch(f){s={error:f}}finally{try{h&&!h.done&&(i=u.return)&&i.call(u)}finally{if(s)throw s.error}}},n.prototype.disposeAllVisualizers=function(){this.visualizers.forEach(function(e){return e.dispose()}),this.visualizers.clear()},n.prototype.setPointPositions=function(e){this.worldSpacePointPositions=e,this.visualizers.forEach(function(t){return t.onPointPositionsChanged(e)})},n.prototype.render=function(){{var e=this.camera.position.clone();e.x+=1,e.y+=1,this.light.position.set(e.x,e.y,e.z)}var t=this.camera instanceof _r.PerspectiveCamera?zP.CameraType.Perspective:zP.CameraType.Orthographic,r=[0,0];this.worldSpacePointPositions!=null&&(r=Avt.getNearFarPoints(this.worldSpacePointPositions,this.camera.position,this.orbitCameraControls.target));var s=new zP.RenderContext(this.camera,t,this.orbitCameraControls.target,this.width,this.height,r[0],r[1],this.styles.backgroundColor,this.pointColors,this.pointScaleFactors,this.labels,this.polylineColors,this.polylineOpacities,this.polylineWidths);this.visualizers.forEach(function(o){return o.onPickingRender(s)});{var i=this.remove3dAxesFromScene();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.render(this.scene,this.camera),i!=null&&this.scene.add(i)}this.visualizers.forEach(function(o){return o.onRender(s)}),this.renderer.setRenderTarget(null),this.renderer.render(this.scene,this.camera)},n.prototype.setPointColors=function(e){this.pointColors=e},n.prototype.setPointScaleFactors=function(e){this.pointScaleFactors=e},n.prototype.setLabels=function(e){this.labels=e},n.prototype.setPolylineColors=function(e){this.polylineColors=e},n.prototype.setPolylineOpacities=function(e){this.polylineOpacities=e},n.prototype.setPolylineWidths=function(e){this.polylineWidths=e},n.prototype.resetZoom=function(){this.recreateCamera(this.makeDefaultCameraDef(this.dimensions)),this.render()},n.prototype.setDayNightMode=function(e){for(var t=this.container.querySelectorAll("canvas"),r=e?"invert(100%)":"",s=0;s<t.length;s++)t[s].style.filter=r},n.prototype.resize=function(e){e===void 0&&(e=!0);var t=LP([this.width,this.height],2),r=t[0],s=t[1],i=LP(this.computeLayoutValues(),2),o=i[0],a=i[1];if(this.dimensions===3){var l=this.camera;l.aspect=o/a,l.updateProjectionMatrix()}else{var l=this.camera,c=o/r,u=a/s,h=(l.right-l.left)*c/2,f=(l.top-l.bottom)*u/2;l.top=f,l.bottom=-f,l.left=-h,l.right=h,l.updateProjectionMatrix()}var d=window.devicePixelRatio||1;this.renderer.setPixelRatio(d),this.renderer.setSize(o,a);{var p=new _r.Vector2;this.renderer.getSize(p);var m=this.renderer.getPixelRatio();this.pickingTexture=new _r.WebGLRenderTarget(p.width*m,p.height*m),this.pickingTexture.texture.minFilter=_r.LinearFilter}this.visualizers.forEach(function(g){return g.onResize(o,a)}),e&&this.render()},n.prototype.onCameraMove=function(e){this.onCameraMoveListeners.push(e)},n.prototype.clickOnPoint=function(e){this.nearestPoint=e,this.onClick(null,!1)},n}();J4.ScatterPlot=Vvt;var MV={},Uvt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i};Object.defineProperty(MV,"__esModule",{value:!0});var Wvt=Qy,BP=new Map,Gvt=/^(rgba|hsla)\((\d+),\s*(\d+%?),\s*(\d+%?)(?:,\s*(\d+(?:\.\d+)?))?\)$/;function Hvt(n){var e=Gvt.exec(n);if(e){var t=Uvt(e,6);t[0];var r=t[1],s=t[2],i=t[3],o=t[4],a=t[5],l=r.replace("a","")+"("+s+","+i+","+o+")";return{colorString:l,opacity:parseFloat(a)}}return{colorString:n,opacity:1}}function jvt(n){if(BP.has(n))return BP.get(n);var e=Hvt(n),t=e.colorString,r=e.opacity,s=new Wvt.Color(t),i=s.r,o=s.g,a=s.b,l={r:i,g:o,b:a,opacity:r};return BP.set(n,l),l}MV.parseColor=jvt;var F$={},qvt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(F$,"__esModule",{value:!0});var Tq="Points must be an array of either 2 or 3 dimensional number arrays",Xvt=function(){function n(e,t){var r,s;t===void 0&&(t=[]),this.points=e,this.metadata=t;var i=e[0].length;if(!(i===2||i===3))throw new Error(Tq);try{for(var o=qvt(e),a=o.next();!a.done;a=o.next()){var l=a.value;if(i!==l.length)throw new Error(Tq)}}catch(c){r={error:c}}finally{try{a&&!a.done&&(s=o.return)&&s.call(o)}finally{if(r)throw r.error}}this.dimensions=i}return n.prototype.setSpriteMetadata=function(e){this.spriteMetadata=e},n}();F$.Dataset=Xvt;var NV={};Object.defineProperty(NV,"__esModule",{value:!0});var Kvt=function(){var n={backgroundColor:"#ffffff",axesVisible:!0,fog:{color:"#ffffff",enabled:!0,threshold:5e3},label:{fontSize:10,scaleDefault:1,scaleLarge:2,fillColorSelected:"#000000",fillColorHover:"#000000",strokeColorSelected:"#ffffff",strokeColorHover:"#ffffff",strokeWidth:3,fillWidth:6},label3D:{fontSize:80,scale:2.2,color:"black",backgroundColor:"#ffffff",colorUnselected:"#ffffff",colorNoSelection:"#ffffff"},point:{colorUnselected:"rgba(227, 227, 227, 0.7)",colorNoSelection:"rgba(117, 117, 217, 0.7)",colorSelected:"rgba(250, 102, 102, 0.7)",colorHover:"rgba(118, 11, 79, 0.7)",scaleDefault:1,scaleSelected:1.2,scaleHover:1.2},polyline:{startHue:60,endHue:360,saturation:1,lightness:.3,defaultOpacity:.2,defaultLineWidth:2,selectedOpacity:.9,selectedLineWidth:3,deselectedOpacity:.05},select:{fill:"#dddddd",fillOpacity:.2,stroke:"#aaaaaa",strokeWidth:2,strokeDashArray:"10 5"},sprites:{minPointSize:5,imageSize:30,colorUnselected:"#ffffff",colorNoSelection:"#ffffff"}};return n};function Yvt(n){var e=Kvt();if(n===void 0)return e;for(var t in e){var r=t;typeof e[r]=="object"&&typeof n[r]=="object"?e[r]=Object.assign(e[r],n[r]):n[r]!==void 0&&(e[r]=n[r])}return e}NV.makeStyles=Yvt;var Wu={};Object.defineProperty(Wu,"__esModule",{value:!0});Wu.RGB_NUM_ELEMENTS=3;Wu.RGBA_NUM_ELEMENTS=4;Wu.XYZ_NUM_ELEMENTS=3;Wu.UV_NUM_ELEMENTS=2;Wu.INDEX_NUM_ELEMENTS=1;Wu.SCATTER_PLOT_CUBE_LENGTH=2;var $V={};Object.defineProperty($V,"__esModule",{value:!0});var lf=Qy,Eq=Yi,ro=Wu,VP=8192,UP=256,ua=2*3,Zvt=function(n,e){return`
      attribute vec2 posObj;
      attribute vec4 color;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        vUv = uv;
        vColor = color;

        // Rotate label to face camera.

        vec4 vRight = vec4(
          modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);

        vec4 vUp = vec4(
          modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);

        vec4 vAt = -vec4(
          modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);

        mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));

        vec2 scaledPos = posObj * `+1/n+" * "+e+`;

        vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);
        vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);
        gl_Position = projectionMatrix * mvPosition;
      }`},Jvt=`
      uniform sampler2D glyphTexture;
      uniform bool picking;
      varying vec2 vUv;
      varying vec4 vColor;

      void main() {
        if (picking) {
          gl_FragColor = vColor;
        } else {
          vec4 fromTexture = texture(glyphTexture, vUv);
          gl_FragColor = vColor * fromTexture;
        }
      }`,Qvt=function(){function n(e){this.styles=e,this.id="3D_LABELS",this.labelStrings=[],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.uniforms={},this.totalVertexCount=0,this.labelVertexMap=[]}return n.prototype.createGlyphTexture=function(){var e=this.styles.label3D,t=e.fontSize,r=e.backgroundColor,s=e.color,i=document.createElement("canvas");i.width=VP,i.height=t;var o=i.getContext("2d");o.font="bold "+t+"px roboto",o.textBaseline="top",o.fillStyle=r,o.rect(0,0,i.width,i.height),o.fill(),o.fillStyle=s;for(var a=o.measureText(" ").width,l=new Float32Array(UP),c=new Float32Array(UP),u=0,h=0;h<UP;h++){var f=" "+String.fromCharCode(h),d=o.measureText(f).width;l[h]=d-a,c[h]=u,o.fillText(f,u-a,0),u+=d}var p=Eq.createTextureFromCanvas(i);return{texture:p,lengths:l,offsets:c}},n.prototype.processLabelVerts=function(e){var t=0;this.labelVertexMap=[];for(var r=0;r<e;r++){for(var s=this.labelStrings[r],i=[],o=0;o<s.length;o++){for(var a=0;a<ua;a++)i.push(t*ua+a);t++}this.labelVertexMap.push(i)}this.totalVertexCount=t*ua},n.prototype.createColorBuffers=function(e){var t=this;this.pickingColors=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS),this.renderColors=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS);for(var r=function(o){var a=new lf.Color(o);s.labelVertexMap[o].forEach(function(l){t.pickingColors[ro.RGB_NUM_ELEMENTS*l]=a.r,t.pickingColors[ro.RGB_NUM_ELEMENTS*l+1]=a.g,t.pickingColors[ro.RGB_NUM_ELEMENTS*l+2]=a.b,t.renderColors[ro.RGB_NUM_ELEMENTS*l]=1,t.renderColors[ro.RGB_NUM_ELEMENTS*l+1]=1,t.renderColors[ro.RGB_NUM_ELEMENTS*l+2]=1})},s=this,i=0;i<e;i++)r(i)},n.prototype.createLabels=function(){var e=this,t=this.styles.label3D,r=t.fontSize,s=t.scale;if(!(this.labelStrings==null||this.worldSpacePointPositions==null)){var i=this.worldSpacePointPositions.length/ro.XYZ_NUM_ELEMENTS;if(i===this.labelStrings.length){this.glyphTexture=this.createGlyphTexture(),this.uniforms={glyphTexture:{value:null},picking:{value:!1}},this.material=new lf.ShaderMaterial({uniforms:this.uniforms,transparent:!0,vertexShader:Zvt(r,s),fragmentShader:Jvt}),this.processLabelVerts(i),this.createColorBuffers(i);var o=new Float32Array(this.totalVertexCount*ro.XYZ_NUM_ELEMENTS);this.positions=new lf.BufferAttribute(o,ro.XYZ_NUM_ELEMENTS);var a=new Float32Array(this.totalVertexCount*ro.XYZ_NUM_ELEMENTS),l=new Float32Array(this.totalVertexCount*ro.UV_NUM_ELEMENTS),c=new Float32Array(this.totalVertexCount*ro.RGB_NUM_ELEMENTS),u=new lf.BufferAttribute(a,2),h=new lf.BufferAttribute(l,ro.UV_NUM_ELEMENTS),f=new lf.BufferAttribute(c,ro.RGB_NUM_ELEMENTS);this.geometry=new lf.BufferGeometry,this.geometry.setAttribute("posObj",u),this.geometry.setAttribute("position",this.positions),this.geometry.setAttribute("uv",h),this.geometry.setAttribute("color",f);for(var d=0,p=0;p<i;p++){for(var m=this.labelStrings[p],g=0,y=0;y<m.length;y++){var b=m.charCodeAt(y);g+=this.glyphTexture.lengths[b]}g/=-2;for(var y=0;y<m.length;y++){var b=m.charCodeAt(y),x=this.glyphTexture.lengths[b],w=r,S=(g+x)/w,C=g/w,k=r/w;u.setXY(d*ua+0,C,0),u.setXY(d*ua+1,S,0),u.setXY(d*ua+2,C,k),u.setXY(d*ua+3,C,k),u.setXY(d*ua+4,S,0),u.setXY(d*ua+5,S,k);var A=this.glyphTexture.offsets[b],M=this.glyphTexture.offsets[b]+x;A/=VP,M/=VP;var E=1,N=0;h.setXY(d*ua+0,A,E),h.setXY(d*ua+1,M,E),h.setXY(d*ua+2,A,N),h.setXY(d*ua+3,A,N),h.setXY(d*ua+4,M,E),h.setXY(d*ua+5,M,N),d++,g+=x}}for(var O=function(D){var z=Eq.vector3FromPackedArray(R.worldSpacePointPositions,D);R.labelVertexMap[D].forEach(function(B){e.positions.setXYZ(B,z.x,z.y,z.z)})},R=this,p=0;p<i;p++)O(p);this.labelsMesh=new lf.Mesh(this.geometry,this.material),this.labelsMesh.frustumCulled=!1,this.scene.add(this.labelsMesh)}}},n.prototype.colorLabels=function(e){if(!(this.labelStrings==null||this.geometry==null||e==null)){var t=this.geometry.getAttribute("color");t.array=this.renderColors;for(var r=e.length/ro.RGBA_NUM_ELEMENTS,s=0,i=0;i<r;++i){for(var o=new lf.Color(e[s],e[s+1],e[s+2]),a=this.labelVertexMap[i].length,l=0;l<a;++l)t.setXYZ(this.labelVertexMap[i][l],o.r,o.g,o.b);s+=ro.RGBA_NUM_ELEMENTS}t.needsUpdate=!0}},n.prototype.setScene=function(e){this.scene=e},n.prototype.dispose=function(){this.labelsMesh&&(this.scene&&this.scene.remove(this.labelsMesh),this.labelsMesh=null),this.geometry&&(this.geometry.dispose(),this.geometry=null),this.glyphTexture!=null&&this.glyphTexture.texture!=null&&(this.glyphTexture.texture.dispose(),this.glyphTexture.texture=null)},n.prototype.onPickingRender=function(e){if(this.geometry==null){this.createLabels();return}this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!0;var t=this.geometry.getAttribute("color");t.array=this.pickingColors,t.needsUpdate=!0},n.prototype.onRender=function(e){if(this.geometry==null){this.createLabels();return}this.colorLabels(e.pointColors),this.material.uniforms.glyphTexture.value=this.glyphTexture.texture,this.material.uniforms.picking.value=!1;var t=this.geometry.getAttribute("color");t.array=this.renderColors,t.needsUpdate=!0},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.dispose()},n.prototype.setLabelStrings=function(e){this.labelStrings=e,this.dispose()},n.prototype.onResize=function(e,t){},n}();$V.ScatterPlotVisualizer3DLabels=Qvt;var RV={};Object.defineProperty(RV,"__esModule",{value:!0});var Oo=Qy,ewt=jC,Iq=Yi,ec=Wu,Aq=function(n){return`
    // Index of the specific vertex (passed in as bufferAttribute), and the
    // variable that will be used to pass it to the fragment shader.
    attribute float spriteIndex;
    attribute vec4 color;
    attribute float scaleFactor;

    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform bool sizeAttenuation;
    uniform float pointSize;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;

    varying float fogDepth;

    void main() {
      // Pass index and color values to fragment shader.
      vColor = color;
      xyIndex = vec2(mod(spriteIndex, spritesPerRow),
                floor(spriteIndex / spritesPerColumn));

      // Transform current vertex by modelViewMatrix (model world position and
      // camera world position matrix).
      vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);

      // Project vertex in camera-space to screen coordinates using the camera's
      // projection matrix.
      gl_Position = projectionMatrix * cameraSpacePos;

      // Create size attenuation (if we're in 3D mode) by making the size of
      // each point inversly proportional to its distance to the camera.
      float outputPointSize = pointSize;
      if (sizeAttenuation) {
        outputPointSize = -pointSize / cameraSpacePos.z;
        fogDepth = pointSize / outputPointSize * 1.2;
      } else {  // Create size attenuation (if we're in 2D mode)
        const float PI = 3.1415926535897932384626433832795;
        const float minScale = 0.1;  // minimum scaling factor
        const float outSpeed = 2.0;  // shrink speed when zooming out
        const float outNorm = (1. - minScale) / atan(outSpeed);
        const float maxScale = 15.0;  // maximum scaling factor
        const float inSpeed = 0.02;  // enlarge speed when zooming in
        const float zoomOffset = 0.3;  // offset zoom pivot
        float zoom = projectionMatrix[0][0] + zoomOffset;  // zoom pivot
        float scale = zoom < 1. ? 1. + outNorm * atan(outSpeed * (zoom - 1.)) :
                      1. + 2. / PI * (maxScale - 1.) * atan(inSpeed * (zoom - 1.));
        outputPointSize = pointSize * scale;
      }

      gl_PointSize =
        max(outputPointSize * scaleFactor, `+n.toFixed(1)+`);
    }`},Qle=`
    bool point_in_unit_circle(vec2 spriteCoord) {
      vec2 centerToP = spriteCoord - vec2(0.5, 0.5);
      return dot(centerToP, centerToP) < (0.5 * 0.5);
    }

    bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {
      vec3 v0 = vec3(0, 1, 0);
      vec3 v1 = vec3(0.5, 0, 0);
      vec3 v2 = vec3(1, 1, 0);
      vec3 p = vec3(spriteCoord, 0);
      float p_in_v0_v1 = cross(v1 - v0, p - v0).z;
      float p_in_v1_v2 = cross(v2 - v1, p - v1).z;
      return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);
    }

    bool point_in_unit_square(vec2 spriteCoord) {
      return true;
    }
  `,twt=`
    varying vec2 xyIndex;
    varying vec4 vColor;

    uniform sampler2D spriteTexture;
    uniform float spritesPerRow;
    uniform float spritesPerColumn;
    uniform bool isImage;

    `+Oo.ShaderChunk.common+`
    `+Qle+`
    uniform vec3 fogColor;
    varying float fogDepth;
		uniform float fogNear;
    uniform float fogFar;

    void main() {
      if (isImage) {
        // Coordinates of the vertex within the entire sprite image.
        vec2 coords =
          (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);
        gl_FragColor = vColor * texture(spriteTexture, coords);
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
      float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
      gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
    }`,nwt=`
    varying vec2 xyIndex;
    varying vec4 vColor;
    uniform bool isImage;

    `+Qle+`

    varying float fogDepth;

    void main() {
      xyIndex; // Silence 'unused variable' warning.
      fogDepth; // Silence 'unused variable' warning.
      if (isImage) {
        gl_FragColor = vColor;
      } else {
        bool inside = point_in_unit_circle(gl_PointCoord);
        if (!inside) {
          discard;
        }
        gl_FragColor = vColor;
      }
    }`,rwt=function(){function n(e,t){this.styles=e,this.id="SPRITES",this.isSpriteSheetMode=!1,this.spritesPerRow=0,this.spritesPerColumn=0,this.spriteDimensions=[0,0],this.worldSpacePointPositions=new Float32Array(0),this.pickingColors=new Float32Array(0),this.renderColors=new Float32Array(0),this.standinTextureForPoints=Iq.createTextureFromCanvas(document.createElement("canvas")),t&&(this.spriteSheetParams=t,this.setSpriteSheet(t),this.isSpriteSheetMode=!0),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial()}return n.prototype.createUniforms=function(){return{spriteTexture:{type:"t"},spritesPerRow:{type:"f"},spritesPerColumn:{type:"f"},fogColor:{type:"c"},fogNear:{type:"f"},fogFar:{type:"f"},isImage:{type:"bool"},sizeAttenuation:{type:"bool"},pointSize:{type:"f"}}},n.prototype.createRenderMaterial=function(){this.isSpriteSheetMode;var e=this.createUniforms();return new Oo.ShaderMaterial({uniforms:e,vertexShader:Aq(this.styles.sprites.minPointSize),fragmentShader:twt,transparent:!0,depthFunc:Oo.LessDepth,fog:this.styles.fog.enabled,blending:Oo.NormalBlending})},n.prototype.createPickingMaterial=function(){var e=this.createUniforms();return new Oo.ShaderMaterial({uniforms:e,vertexShader:Aq(this.styles.sprites.minPointSize),fragmentShader:nwt,transparent:!0,depthTest:!0,depthWrite:!0,fog:!1,blending:Oo.NormalBlending})},n.prototype.createPointSprites=function(e,t){var r=t!=null?t.length/ec.XYZ_NUM_ELEMENTS:0,s=this.createGeometry(r);this.fog=new Oo.Fog(16777215),this.points=new Oo.Points(s,this.renderMaterial),this.points.frustumCulled=!1,this.spriteIndexBufferAttribute!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute),e.add(this.points)},n.prototype.calculatePointSize=function(e){var t=this.styles.sprites.imageSize;if(this.texture)return e?t:this.spriteDimensions[0];var r=this.worldSpacePointPositions!=null?this.worldSpacePointPositions.length/ec.XYZ_NUM_ELEMENTS:1,s=200,i=8,o=1.5,a=s/Math.log(r)/Math.log(i);return e?a:a/o},n.prototype.createGeometry=function(e){var t=e;this.pickingColors=new Float32Array(t*ec.RGBA_NUM_ELEMENTS);for(var r=0,s=0;s<t;s++){var i=new Oo.Color(s);this.pickingColors[r++]=i.r,this.pickingColors[r++]=i.g,this.pickingColors[r++]=i.b,this.pickingColors[r++]=1}var o=new Oo.BufferGeometry;return o.setAttribute("position",new Oo.BufferAttribute(new Float32Array([]),ec.XYZ_NUM_ELEMENTS)),o.setAttribute("color",new Oo.BufferAttribute(new Float32Array([]),ec.RGBA_NUM_ELEMENTS)),o.setAttribute("scaleFactor",new Oo.BufferAttribute(new Float32Array([]),ec.INDEX_NUM_ELEMENTS)),o.computeVertexNormals(),o},n.prototype.setFogDistances=function(e,t,r){var s=this.styles.fog,i=s.threshold,o=s.enabled;if(e&&o){this.fog.near=t;var a=t-r;this.fog.far=t-i*a}else this.fog.near=1/0,this.fog.far=1/0},n.prototype.dispose=function(){this.disposeGeometry(),this.disposeSpriteSheet()},n.prototype.disposeGeometry=function(){this.points!=null&&(this.scene.remove(this.points),this.points.geometry.dispose(),this.points=null,this.worldSpacePointPositions=null)},n.prototype.disposeSpriteSheet=function(){this.texture&&this.texture.dispose(),this.texture=null,this.renderMaterial=null,this.pickingMaterial=null,this.spriteSheetImage=null},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSpriteSheet=function(e){var t=this,r=e.spriteDimensions,s=e.onImageLoad,i=e.spritesheetImage;if(typeof i=="string"){var o=i;i=new Image,i.src=o}this.spriteSheetImage=i,this.texture=Iq.createTextureFromImage(this.spriteSheetImage,function(){t.spritesPerRow=t.spriteSheetImage.width/r[0],t.spritesPerColumn=t.spriteSheetImage.height/r[1],s()}),this.spriteDimensions=r,this.setSpriteIndexBuffer()},n.prototype.setSpriteIndexBuffer=function(){var e=this.spriteSheetParams.spriteIndices;this.spriteIndexBufferAttribute=new Oo.BufferAttribute(e,ec.INDEX_NUM_ELEMENTS),this.points!=null&&this.points.geometry.setAttribute("spriteIndex",this.spriteIndexBufferAttribute)},n.prototype.onPointPositionsChanged=function(e){this.points!=null&&this.worldSpacePointPositions.length!==e.length&&this.disposeGeometry(),this.worldSpacePointPositions=e,this.points==null&&this.createPointSprites(this.scene,e),this.spriteSheetParams&&this.setSpriteIndexBuffer(),this.renderMaterial=this.createRenderMaterial(),this.pickingMaterial=this.createPickingMaterial();var t=this.points.geometry.getAttribute("position");t.array=e,t.count=e.length/ec.XYZ_NUM_ELEMENTS,t.needsUpdate=!0},n.prototype.onPickingRender=function(e){var t=e.cameraType===ewt.CameraType.Perspective;this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.pickingMaterial.uniforms.spritesPerRow.value=this.spritesPerColumn,this.pickingMaterial.uniforms.sizeAttenuation.value=t,this.pickingMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.pickingMaterial;var r=this.points.geometry.getAttribute("color");r.array=this.pickingColors,r.count=this.pickingColors.length/ec.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var s=this.points.geometry.getAttribute("scaleFactor");s.array=e.pointScaleFactors,s.count=e.pointScaleFactors.length,s.count=e.pointScaleFactors.length/ec.INDEX_NUM_ELEMENTS,s.needsUpdate=!0},n.prototype.onRender=function(e){var t=e.camera instanceof Oo.PerspectiveCamera;this.setFogDistances(t,e.nearestCameraSpacePointZ,e.farthestCameraSpacePointZ),this.scene.fog=this.fog,this.scene.fog.color=new Oo.Color(e.backgroundColor),this.renderMaterial.uniforms.fogColor.value=this.scene.fog.color,this.renderMaterial.uniforms.fogNear.value=this.fog.near,this.renderMaterial.uniforms.fogFar.value=this.fog.far,this.renderMaterial.uniforms.spritesPerRow.value=this.spritesPerRow,this.renderMaterial.uniforms.spritesPerColumn.value=this.spritesPerColumn,this.renderMaterial.uniforms.isImage.value=this.texture!=null,this.renderMaterial.uniforms.spriteTexture.value=this.texture!=null?this.texture:this.standinTextureForPoints,this.renderMaterial.uniforms.sizeAttenuation.value=t,this.renderMaterial.uniforms.pointSize.value=this.calculatePointSize(t),this.points.material=this.renderMaterial;var r=this.points.geometry.getAttribute("color");this.renderColors=e.pointColors,r.array=this.renderColors,r.count=this.renderColors.length/ec.RGBA_NUM_ELEMENTS,r.needsUpdate=!0;var s=this.points.geometry.getAttribute("scaleFactor");s.array=e.pointScaleFactors,s.count=e.pointScaleFactors.length/ec.INDEX_NUM_ELEMENTS,s.needsUpdate=!0},n.prototype.onResize=function(e,t){},n}();RV.ScatterPlotVisualizerSprites=rwt;var PV={},DV={};Object.defineProperty(DV,"__esModule",{value:!0});var swt=function(){function n(e,t,r){this.bound=e,this.cellWidth=t,this.cellHeight=r,this.numHorizCells=Math.ceil(this.boundWidth(e)/t),this.numVertCells=Math.ceil(this.boundHeight(e)/r),this.grid=new Array(this.numHorizCells*this.numVertCells)}return n.prototype.boundWidth=function(e){return e.hiX-e.loX},n.prototype.boundHeight=function(e){return e.hiY-e.loY},n.prototype.boundsIntersect=function(e,t){return!(e.loX>t.hiX||e.loY>t.hiY||e.hiX<t.loX||e.hiY<t.loY)},n.prototype.insert=function(e,t){if(t===void 0&&(t=!1),e.hiX<this.bound.loX||e.loX>this.bound.hiX||e.hiY<this.bound.loY||e.loY>this.bound.hiY)return!1;for(var r=this.getCellX(e.loX),s=this.getCellX(e.hiX),i=this.getCellY(e.loY),o=this.getCellY(e.hiY),a=i*this.numHorizCells+r,l=a,c=i;c<=o;c++){for(var u=r;u<=s;u++){var h=this.grid[l++];if(h){for(var f=0;f<h.length;f++)if(this.boundsIntersect(e,h[f]))return!1}}l+=this.numHorizCells-(s-r+1)}if(t)return!0;l=a;for(var c=i;c<=o;c++){for(var u=r;u<=s;u++)this.grid[l]?this.grid[l].push(e):this.grid[l]=[e],l++;l+=this.numHorizCells-(s-r+1)}return!0},n.prototype.getCellX=function(e){return Math.floor((e-this.bound.loX)/this.cellWidth)},n.prototype.getCellY=function(e){return Math.floor((e-this.bound.loY)/this.cellHeight)},n}();DV.CollisionGrid=swt;var iwt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i};Object.defineProperty(PV,"__esModule",{value:!0});var owt=Qy,awt=jC,lwt=DV,WP=Yi,cwt=1e4,uwt=function(){function n(e,t){this.styles=t,this.id="CANVAS_LABELS",this.worldSpacePointPositions=new Float32Array(0),this.labelsActive=!0,this.canvas=document.createElement("canvas"),e.appendChild(this.canvas),this.gc=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.left="0",this.canvas.style.top="0",this.canvas.style.pointerEvents="none"}return n.prototype.removeAllLabels=function(){var e=this.canvas.width*window.devicePixelRatio,t=this.canvas.height*window.devicePixelRatio;this.gc.clearRect(0,0,e,t)},n.prototype.makeLabels=function(e){if(!(e.labels==null||e.labels.pointIndices.length===0)&&this.worldSpacePointPositions!=null){var t=e.labels,r=e.cameraType===awt.CameraType.Perspective,s=parseInt(this.gc.font,10),i=window.devicePixelRatio,o;{var a=this.canvas.width*i,l=this.canvas.height*i,c={loX:0,hiX:a,loY:0,hiY:l};o=new lwt.CollisionGrid(c,a/25,l/50)}var u=[e.farthestCameraSpacePointZ,e.nearestCameraSpacePointZ],h=function(O){return WP.scaleExponential(O,u,[.1,1])},f=e.camera.position,d=f.clone().sub(e.cameraTarget),p=new owt.Vector3;this.gc.textBaseline="middle",this.gc.miterLimit=2;for(var m=2,g=4,y=Math.min(cwt,t.pointIndices.length),b=0;b<y;++b){var x=void 0;{var w=t.pointIndices[b];x=WP.vector3FromPackedArray(this.worldSpacePointPositions,w)}if(p.copy(f).sub(x),!(d.dot(p)<0)){var S=iwt(WP.vector3DToScreenCoords(e.camera,e.screenWidth,e.screenHeight,x),2),C=S[0],k=S[1];C+=g;var A={loX:C-m,hiX:C+1+m,loY:k-s/2-m,hiY:k+s/2+m};if(o.insert(A,!0)){var M=t.labelStrings[b],E=t.defaultFontSize*t.scaleFactors[b]*i;if(this.gc.font=E+"px roboto",A.hiX+=this.gc.measureText(M).width-1,o.insert(A)){var N=1;r&&t.useSceneOpacityFlags[b]===1&&(N=h(p.length())),this.gc.fillStyle=this.styleStringFromPackedRgba(t.fillColors,b,N),this.gc.strokeStyle=this.styleStringFromPackedRgba(t.strokeColors,b,N),this.gc.lineWidth=this.styles.label.strokeWidth,this.gc.strokeText(M,C,k),this.gc.lineWidth=this.styles.label.fillWidth,this.gc.fillText(M,C,k)}}}}}},n.prototype.styleStringFromPackedRgba=function(e,t,r){var s=t*3,i=e[s],o=e[s+1],a=e[s+2];return"rgba("+i+","+o+","+a+","+r+")"},n.prototype.onResize=function(e,t){var r=window.devicePixelRatio;this.canvas.width=e*r,this.canvas.height=t*r,this.canvas.style.width=e+"px",this.canvas.style.height=t+"px"},n.prototype.dispose=function(){this.removeAllLabels()},n.prototype.onPointPositionsChanged=function(e){this.worldSpacePointPositions=e,this.removeAllLabels()},n.prototype.onRender=function(e){this.labelsActive&&(this.removeAllLabels(),this.makeLabels(e))},n.prototype.setScene=function(e){},n.prototype.onPickingRender=function(e){},n}();PV.ScatterPlotVisualizerCanvasLabels=uwt;var OV={},Mq=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(OV,"__esModule",{value:!0});var f1=Qy,Nq=Yi,SE=Wu,hwt=function(){function n(){this.id="POLYLINES",this.sequences=[],this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={},this.pointSequenceIndices=new Map}return n.prototype.getPointSequenceIndex=function(e){return this.pointSequenceIndices.get(e)},n.prototype.updateSequenceIndices=function(){for(var e=0;e<this.sequences.length;e++)for(var t=this.sequences[e],r=0;r<t.indices.length-1;r++){var s=t.indices[r];this.pointSequenceIndices.set(s,e),this.pointSequenceIndices.set(s+1,e)}},n.prototype.createPolylines=function(){var e,t;this.updateSequenceIndices();try{for(var r=Mq(this.polylines),s=r.next();!s.done;s=r.next()){var i=s.value;this.scene.remove(i),i.geometry.dispose()}}catch(c){e={error:c}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[];for(var o=0;o<this.sequences.length;o++){var a=new f1.BufferGeometry;a.addAttribute("position",this.polylinePositionBuffer[o]),a.addAttribute("color",this.polylineColorBuffer[o]);var l=new f1.LineBasicMaterial({linewidth:1,opacity:1,transparent:!0,vertexColors:!0}),i=new f1.LineSegments(a,l);i.frustumCulled=!1,this.polylines.push(i),this.scene.add(i)}},n.prototype.dispose=function(){var e,t;try{for(var r=Mq(this.polylines),s=r.next();!s.done;s=r.next()){var i=s.value;this.scene.remove(i),i.geometry.dispose()}}catch(o){e={error:o}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}this.polylines=[],this.polylinePositionBuffer={},this.polylineColorBuffer={}},n.prototype.setScene=function(e){this.scene=e},n.prototype.setSequences=function(e){this.sequences=e},n.prototype.onPointPositionsChanged=function(e){if(e==null&&this.dispose(),!(e==null||this.sequences.length===0)){for(var t=0;t<this.sequences.length;t++){var r=this.sequences[t],s=2*(r.indices.length-1),i=new Float32Array(s*SE.XYZ_NUM_ELEMENTS);this.polylinePositionBuffer[t]=new f1.BufferAttribute(i,SE.XYZ_NUM_ELEMENTS);var o=new Float32Array(s*SE.RGBA_NUM_ELEMENTS);this.polylineColorBuffer[t]=new f1.BufferAttribute(o,SE.RGBA_NUM_ELEMENTS)}for(var t=0;t<this.sequences.length;t++){for(var r=this.sequences[t],a=0,l=0;l<r.indices.length-1;l++){var c=r.indices[l],u=r.indices[l+1],h=Nq.vector3FromPackedArray(e,c),f=Nq.vector3FromPackedArray(e,u);this.polylinePositionBuffer[t].setXYZ(a,h.x,h.y,h.z),this.polylinePositionBuffer[t].setXYZ(a+1,f.x,f.y,f.z),a+=2}this.polylinePositionBuffer[t].needsUpdate=!0}this.createPolylines()}},n.prototype.onRender=function(e){for(var t=0;t<this.polylines.length;t++){var r=this.polylines[t].material;r.opacity=e.polylineOpacities[t],r.linewidth=e.polylineWidths[t],this.polylineColorBuffer[t].array=e.polylineColors[t],this.polylineColorBuffer[t].needsUpdate=!0}},n.prototype.onPickingRender=function(e){},n.prototype.onResize=function(e,t){},n}();OV.ScatterPlotVisualizerPolylines=hwt;var fwt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},GP=pt&&pt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(fwt(arguments[e]));return n},$q=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")};Object.defineProperty(Z4,"__esModule",{value:!0});var dwt=J4,bm=MV,pwt=F$,mwt=jC,gwt=NV,Do=Yi,CE=Wu,ywt=$V,Rq=RV,bwt=PV,vwt=OV,wwt=function(){function n(e,t){var r=this;t===void 0&&(t={}),this.pointColorer=null,this.sequences=[],this.renderMode="POINT",this.rotateOnStart=!0,this.selectEnabled=!0,this.showLabelsOnHover=!0,this.hoverPointIndex=null,this.selectedPointIndices=new Set,this.clickCallback=function(){},this.hoverCallback=function(){},this.selectCallback=function(){},this.cameraMoveCallback=function(){},this.onHover=function(s){r.hoverCallback(s),r.hoverPointIndex=s,r.updateScatterPlotAttributes(),r.renderScatterPlot()},this.onClick=function(s){r.clickCallback(s)},this.select=function(s){r.selectEnabled&&(r.selectedPointIndices=new Set(s),r.updateScatterPlotAttributes(),r.renderScatterPlot())},this.onSelect=function(s){r.selectEnabled&&(r.selectCallback(s),r.select(s))},this.containerElement=e,this.styles=gwt.makeStyles(t.styles),this.setParameters(t),this.scatterPlot=new dwt.ScatterPlot(e,{camera:t.camera,onClick:this.onClick,onHover:this.onHover,onSelect:this.onSelect,selectEnabled:this.selectEnabled,styles:this.styles,orbitControlParams:t.orbitControls}),this.scatterPlot.onCameraMove(this.cameraMoveCallback)}return n.prototype.setParameters=function(e){e.onClick!==void 0&&(this.clickCallback=e.onClick),e.onHover!==void 0&&(this.hoverCallback=e.onHover),e.onSelect!==void 0&&(this.selectCallback=e.onSelect),e.onCameraMove!==void 0&&(this.cameraMoveCallback=e.onCameraMove),e.pointColorer!==void 0&&(this.pointColorer=e.pointColorer),e.renderMode!==void 0&&(this.renderMode=e.renderMode),e.rotateOnStart!==void 0&&(this.rotateOnStart=e.rotateOnStart),e.selectEnabled!==void 0&&(this.selectEnabled=e.selectEnabled),e.showLabelsOnHover!==void 0&&(this.showLabelsOnHover=e.showLabelsOnHover)},n.prototype.render=function(e){this.updateDataset(e),this.clearVisualizers(),this.setVisualizers(),this.rotateOnStart&&this.scatterPlot.startOrbitAnimation()},n.prototype.clearVisualizers=function(){this.canvasLabelsVisualizer=void 0,this.labels3DVisualizer=void 0,this.pointVisualizer=void 0,this.polylineVisualizer=void 0,this.spritesheetVisualizer=void 0,this.scatterPlot.disposeAllVisualizers()},n.prototype.renderScatterPlot=function(){this.dataset&&this.scatterPlot.render()},n.prototype.resetZoom=function(){this.scatterPlot.resetZoom()},n.prototype.setRenderMode=function(e){this.renderMode=e,this.setVisualizers(),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions()},n.prototype.setTextRenderMode=function(){this.setRenderMode("TEXT"),this.renderScatterPlot()},n.prototype.setPointRenderMode=function(){this.setRenderMode("POINT"),this.renderScatterPlot()},n.prototype.setSpriteRenderMode=function(){this.dataset&&this.dataset.spriteMetadata&&(this.setRenderMode("SPRITE"),this.renderScatterPlot())},n.prototype.setSequences=function(e){this.sequences=e,this.updatePolylineAttributes(),this.setVisualizers(),this.renderScatterPlot()},n.prototype.setPanMode=function(){this.scatterPlot.setInteractionMode("PAN")},n.prototype.setSelectMode=function(){this.scatterPlot.setInteractionMode("SELECT")},n.prototype.setDimensions=function(e){var t=e<2||e>3,r=this.dataset&&e>this.dataset.dimensions;if(t||r)throw new RangeError("Setting invalid dimensionality");this.scatterPlot.setDimensions(e),this.renderScatterPlot()},n.prototype.setPointColorer=function(e){this.pointColorer=e,this.updateScatterPlotAttributes(),this.renderScatterPlot()},n.prototype.callPointColorer=function(e,t){return e(t,this.selectedPointIndices,this.hoverPointIndex)},n.prototype.setHoverPointIndex=function(e){this.hoverPointIndex=e,this.updateScatterPlotAttributes(),!this.scatterPlot.orbitIsAnimating()&&this.renderScatterPlot()},n.prototype.resize=function(){this.scatterPlot.resize()},n.prototype.updateDataset=function(e){this.setDataset(e),this.scatterPlot.setDimensions(e.dimensions),this.updateScatterPlotAttributes(),this.updateScatterPlotPositions(),this.renderScatterPlot()},n.prototype.isOrbiting=function(){return this.scatterPlot.orbitIsAnimating()},n.prototype.startOrbitAnimation=function(){this.scatterPlot.startOrbitAnimation()},n.prototype.stopOrbitAnimation=function(){this.scatterPlot.stopOrbitAnimation()},n.prototype.setDataset=function(e){this.dataset=e,this.labels3DVisualizer&&this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray())},n.prototype.updateScatterPlotPositions=function(){var e=this.dataset;if(e){var t=this.generatePointPositionArray(e);this.scatterPlot.setPointPositions(t)}},n.prototype.updateScatterPlotAttributes=function(){var e=this.dataset;if(e){var t=this.generatePointColorArray(e),r=this.generatePointScaleFactorArray(e),s=this.generateVisibleLabelRenderParams();this.scatterPlot.setPointColors(t),this.scatterPlot.setPointScaleFactors(r),this.scatterPlot.setLabels(s)}},n.prototype.updatePolylineAttributes=function(){var e=this.dataset;if(e){var t=this.generateLineSegmentColorMap(e),r=this.generateLineSegmentOpacityArray(e),s=this.generateLineSegmentWidthArray(e);this.scatterPlot.setPolylineColors(t),this.scatterPlot.setPolylineOpacities(r),this.scatterPlot.setPolylineWidths(s)}},n.prototype.generatePointPositionArray=function(e){var t=[0,0],r=[0,0],s=[0,0];t=Do.extent(e.points.map(function(y){return y[0]})),r=Do.extent(e.points.map(function(y){return y[1]})),e.dimensions===3&&(s=Do.extent(e.points.map(function(y){return y[2]})));var i=function(y){return Math.abs(y[1]-y[0])},o=i(t),a=i(r),l=i(s),c=Math.max(o,a,l),u=CE.SCATTER_PLOT_CUBE_LENGTH/2,h=function(y,b){return[-b*(y/c),b*(y/c)]},f=h(o,u),d=h(a,u),p=h(l,u),m=new Float32Array(e.points.length*3),g=0;return e.points.forEach(function(y,b){var x=e.points[b];m[g++]=Do.scaleLinear(x[0],t,f),m[g++]=Do.scaleLinear(x[1],r,d),e.dimensions===3?m[g++]=Do.scaleLinear(x[2],s,p):m[g++]=0}),m},n.prototype.generateVisibleLabelRenderParams=function(){var e=this,t=e.hoverPointIndex,r=e.selectedPointIndices,s=e.styles,i=t!==null?1:0,o=new Uint32Array(i),a=new Float32Array(i),l=new Int8Array(i),c=new Uint8Array(i*3),u=new Uint8Array(i*3),h=[];a.fill(s.label.scaleDefault),l.fill(1);var f=0;if(t!==null){h.push(this.getLabelText(t)),o[f]=t,a[f]=s.label.scaleLarge,l[f]=0;var d=Do.styleRgbFromHexColor(s.label.fillColorHover);Do.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]);var p=Do.styleRgbFromHexColor(s.label.strokeColorHover);Do.packRgbIntoUint8Array(u,f,p[0],p[1],p[1]),++f}{var d=Do.styleRgbFromHexColor(s.label.fillColorSelected),p=Do.styleRgbFromHexColor(s.label.strokeColorSelected);if(r.size===1){var m=GP(r)[0];h.push(this.getLabelText(m)),o[f]=m,a[f]=s.label.scaleLarge,l[f]=0,Do.packRgbIntoUint8Array(c,f,d[0],d[1],d[2]),Do.packRgbIntoUint8Array(u,f,p[0],p[1],p[2])}}return new mwt.LabelRenderParams(new Float32Array(o),h,a,l,s.label.fontSize,c,u)},n.prototype.generatePointScaleFactorArray=function(e){var t,r,s=this,i=s.hoverPointIndex,o=s.selectedPointIndices,a=s.styles,l=a.point,c=l.scaleDefault,u=l.scaleSelected,h=l.scaleHover,f=new Float32Array(e.points.length);f.fill(c),o.size;try{for(var d=$q(o.values()),p=d.next();!p.done;p=d.next()){var m=p.value;f[m]=u}}catch(g){t={error:g}}finally{try{p&&!p.done&&(r=d.return)&&r.call(d)}finally{if(t)throw t.error}}return i!=null&&(f[i]=h),f},n.prototype.generatePointColorArray=function(e){var t,r,s=this,i=s.hoverPointIndex,o=s.pointColorer,a=s.selectedPointIndices,l=s.styles,c=l.point,u=c.colorHover,h=c.colorNoSelection,f=c.colorSelected,d=c.colorUnselected,p=new Float32Array(e.points.length*CE.RGBA_NUM_ELEMENTS),m=d,g=h;this.renderMode==="TEXT"&&(m=this.styles.label3D.colorUnselected,g=this.styles.label3D.colorNoSelection),this.renderMode==="SPRITE"&&(m=this.styles.sprites.colorUnselected,g=this.styles.sprites.colorNoSelection);var y=e.points.length,b=this.selectedPointIndices.size;if(o)for(var x=0,w=0;w<y;++w){var S=bm.parseColor(this.callPointColorer(o,w)||g);p[x++]=S.r,p[x++]=S.g,p[x++]=S.b,p[x++]=S.opacity}else{for(var x=0,S=b>0?bm.parseColor(m):bm.parseColor(g),w=0;w<y;++w)p[x++]=S.r,p[x++]=S.g,p[x++]=S.b,p[x++]=S.opacity;S=bm.parseColor(f);try{for(var C=$q(a.values()),k=C.next();!k.done;k=C.next()){var A=k.value,M=A*CE.RGBA_NUM_ELEMENTS;p[M++]=S.r,p[M++]=S.g,p[M++]=S.b,p[M++]=S.opacity}}catch(D){t={error:D}}finally{try{k&&!k.done&&(r=C.return)&&r.call(C)}finally{if(t)throw t.error}}if(i!=null){var E=bm.parseColor(u),N=i*CE.RGBA_NUM_ELEMENTS;p[N++]=E.r,p[N++]=E.g,p[N++]=E.b,p[N++]=E.opacity}}return p},n.prototype.generate3DLabelsArray=function(){var e=this.dataset;if(!e)return[];for(var t=[],r=e.points.length,s=0;s<r;++s)t.push(this.getLabelText(s));return t},n.prototype.generateLineSegmentColorMap=function(e){for(var t=this,r=t.pointColorer,s=t.styles,i={},o=0;o<this.sequences.length;o++){var a=this.sequences[o],l=new Float32Array(2*(a.indices.length-1)*3),c=0;if(r)for(var u=0;u<a.indices.length-1;u++){var h=bm.parseColor(this.callPointColorer(r,a.indices[u])),f=bm.parseColor(this.callPointColorer(r,a.indices[u+1]));l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}else for(var u=0;u<a.indices.length-1;u++){var h=Do.getDefaultPointInPolylineColor(u,a.indices.length,s.polyline.startHue,s.polyline.endHue,s.polyline.saturation,s.polyline.lightness),f=Do.getDefaultPointInPolylineColor(u+1,a.indices.length,s.polyline.startHue,s.polyline.endHue,s.polyline.saturation,s.polyline.lightness);l[c++]=h.r,l[c++]=h.g,l[c++]=h.b,l[c++]=f.r,l[c++]=f.g,l[c++]=f.b}i[o]=l}return i},n.prototype.generateLineSegmentOpacityArray=function(e){var t=this,r=t.selectedPointIndices,s=t.styles,i=new Float32Array(this.sequences.length),o=r.size;if(o>0){i.fill(s.polyline.deselectedOpacity);var a=this.polylineVisualizer.getPointSequenceIndex(GP(r)[0]);a!==void 0&&(i[a]=s.polyline.selectedOpacity)}else i.fill(s.polyline.defaultOpacity);return i},n.prototype.generateLineSegmentWidthArray=function(e){var t=this,r=t.selectedPointIndices,s=t.styles,i=new Float32Array(this.sequences.length);i.fill(s.polyline.defaultLineWidth);var o=r.size;if(o>0){var a=this.polylineVisualizer.getPointSequenceIndex(GP(r)[0]);a!==void 0&&(i[a]=s.polyline.selectedLineWidth)}return i},n.prototype.getLabelText=function(e){var t=this.dataset;if(!t)return"";var r=t.metadata[e];return r&&r.label!=null?""+r.label:""},n.prototype.initializeCanvasLabelsVisualizer=function(){return this.canvasLabelsVisualizer||(this.canvasLabelsVisualizer=new bwt.ScatterPlotVisualizerCanvasLabels(this.containerElement,this.styles)),this.canvasLabelsVisualizer},n.prototype.initialize3DLabelsVisualizer=function(){return this.labels3DVisualizer||(this.labels3DVisualizer=new ywt.ScatterPlotVisualizer3DLabels(this.styles)),this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray()),this.labels3DVisualizer},n.prototype.initializePointVisualizer=function(){return this.pointVisualizer||(this.pointVisualizer=new Rq.ScatterPlotVisualizerSprites(this.styles)),this.pointVisualizer},n.prototype.initializeSpritesheetVisualizer=function(){var e=this,t=this.styles,r=this.dataset,s=r.spriteMetadata;if(!this.spritesheetVisualizer&&s){if(!s.spriteImage||!s.singleSpriteSize)return;var i=r.points.length,o=void 0;if(s.spriteIndices)o=new Float32Array(s.spriteIndices);else{o=new Float32Array(i);for(var a=0;a<i;++a)o[a]=a}var l=function(){return e.renderScatterPlot()},c=new Rq.ScatterPlotVisualizerSprites(t,{spritesheetImage:s.spriteImage,spriteDimensions:s.singleSpriteSize,spriteIndices:o,onImageLoad:l});c.id="SPRITE_SHEET_VISUALIZER",this.spritesheetVisualizer=c}return this.spritesheetVisualizer},n.prototype.initializePolylineVisualizer=function(){return this.polylineVisualizer||(this.polylineVisualizer=new vwt.ScatterPlotVisualizerPolylines),this.polylineVisualizer.setSequences(this.sequences),this.polylineVisualizer},n.prototype.setVisualizers=function(){var e=this,t=e.dataset,r=e.renderMode,s=[];if(r==="TEXT"){var i=this.initialize3DLabelsVisualizer();s.push(i)}else if(r==="POINT"){var i=this.initializePointVisualizer();s.push(i)}else if(r==="SPRITE"&&t.spriteMetadata){var i=this.initializeSpritesheetVisualizer();i&&s.push(i)}if(this.sequences.length>0){var i=this.initializePolylineVisualizer();s.push(i)}var o=r==="POINT"||r==="SPRITE";if(o&&this.showLabelsOnHover){var i=this.initializeCanvasLabelsVisualizer();s.push(i)}this.scatterPlot.setActiveVisualizers(s)},n.Dataset=pwt.Dataset,n}();Z4.ScatterGL=wwt;Object.defineProperty(Y4,"__esModule",{value:!0});var xwt=Z4;Y4.ScatterGL=xwt.ScatterGL;var _wt=F$;Y4.Dataset=_wt.Dataset;var ece={},Kf={},Ph={},di={},Swt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}};Object.defineProperty(di,"__esModule",{value:!0});function tce(n,e){return Math.floor(e()*n)}di.tauRandInt=tce;function Cwt(n){return n()}di.tauRand=Cwt;function kwt(n){var e,t,r=0;try{for(var s=Swt(n),i=s.next();!i.done;i=s.next()){var o=i.value;r+=Math.pow(o,2)}}catch(a){e={error:a}}finally{try{i&&!i.done&&(t=s.return)&&t.call(s)}finally{if(e)throw e.error}}return Math.sqrt(r)}di.norm=kwt;function L$(n){for(var e=[],t=0;t<n;t++)e.push(void 0);return e}di.empty=L$;function Twt(n){return L$(n).map(function(e,t){return t})}di.range=Twt;function FV(n,e){return L$(n).map(function(){return e})}di.filled=FV;function nce(n){return FV(n,0)}di.zeros=nce;function Ewt(n){return FV(n,1)}di.ones=Ewt;function Iwt(n,e,t){return L$(t).map(function(r,s){return n+s*((e-n)/(t-1))})}di.linear=Iwt;function rce(n){return n.reduce(function(e,t){return e+t})}di.sum=rce;function Awt(n){return rce(n)/n.length}di.mean=Awt;function Mwt(n){for(var e=0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return e}di.max=Mwt;function Nwt(n){for(var e=0,t=0;t<n.length;t++)for(var r=0;r<n[t].length;r++)e=n[t][r]>e?n[t][r]:e;return e}di.max2d=Nwt;function $wt(n,e,t){for(var r=nce(n),s=0;s<n;s++)for(var i=!0;i;){for(var o=tce(e,t),a=!1,l=0;l<s;l++)if(o===r[l]){a=!0;break}a||(i=!1),r[s]=o}return r}di.rejectionSample=$wt;function Rwt(n,e,t){var r=[],s=0;if(n.length!==e*t)throw new Error("Array dimensions must match input length.");for(var i=0;i<e;i++){for(var o=[],a=0;a<t;a++)o.push(n[s]),s+=1;r.push(o)}return r}di.reshape2d=Rwt;var Pwt=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(Ph,"__esModule",{value:!0});var FS=Pwt(di);function sce(n,e){var t=function(s){return FS.empty(n).map(function(){return FS.filled(e,s)})},r=[];return r.push(t(-1)),r.push(t(1/0)),r.push(t(0)),r}Ph.makeHeap=sce;function Dwt(n,e,t){for(var r=FS.zeros(n),s=0;s<n;s++){for(var i=!0,o=0;i;){o=FS.tauRandInt(e,t);for(var a=!1,l=0;l<s;l++)if(o===r[l]){a=!0;break}a||(i=!1)}r[s]=o}return r}Ph.rejectionSample=Dwt;function sL(n,e,t,r,s){e=Math.floor(e);var i=n[0][e],o=n[1][e];if(n[2][e],t>=o[0])return 0;for(var a=0;a<i.length;a++)if(r===i[a])return 0;return ice(n,e,t,r,s)}Ph.heapPush=sL;function ice(n,e,t,r,s){var i=n[0][e],o=n[1][e],a=n[2][e];if(t>=o[0])return 0;o[0]=t,i[0]=r,a[0]=s;for(var l=0,c=0;;){var u=2*l+1,h=u+1,f=n[0][0].length;if(u>=f)break;if(h>=f)if(o[u]>t)c=u;else break;else if(o[u]>=o[h])if(t<o[u])c=u;else break;else if(t<o[h])c=h;else break;o[l]=o[c],i[l]=i[c],a[l]=a[c],l=c}return o[l]=t,i[l]=r,a[l]=s,1}Ph.uncheckedHeapPush=ice;function Owt(n,e,t,r,s){for(var i=sce(e,r),o=0;o<e;o++)for(var a=0;a<t;a++)if(!(n[0][o][a]<0)){var l=n[0][o][a],c=n[2][o][a],u=FS.tauRand(s);sL(i,o,u,l,c),sL(i,l,u,o,c),n[2][o][a]=0}return i}Ph.buildCandidates=Owt;function Fwt(n){for(var e=n[0],t=n[1],r=0;r<e.length;r++)for(var s=e[r],i=t[r],o=0;o<s.length-1;o++){var a=s.length-o-1,l=i.length-o-1,c=s[0];s[0]=s[a],s[a]=c;var u=i[0];i[0]=i[l],i[l]=u,Lwt(i,s,l,0)}return{indices:e,weights:t}}Ph.deheapSort=Fwt;function Lwt(n,e,t,r){for(;r*2+1<t;){var s=r*2+1,i=s+1,o=r;if(n[o]<n[s]&&(o=s),i<t&&n[o]<n[i]&&(o=i),o===r)break;var a=n[r];n[r]=n[o],n[o]=a;var l=e[r];e[r]=e[o],e[o]=l,r=o}}function zwt(n,e){for(var t=n[0][e],r=n[1][e],s=n[2][e],i=1/0,o=-1,a=0;a>t.length;a++)s[a]===1&&r[a]<i&&(i=r[a],o=a);return o>=0?(s[o]=0,Math.floor(t[o])):-1}Ph.smallestFlagged=zwt;var nl={},sI=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Bwt=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},Vwt=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(nl,"__esModule",{value:!0});var d1,Pq=Vwt(di),ux=function(){function n(e,t,r,s){if(this.entries=new Map,this.nRows=0,this.nCols=0,e.length!==t.length||e.length!==r.length)throw new Error("rows, cols and values arrays must all have the same length");this.nRows=s[0],this.nCols=s[1];for(var i=0;i<r.length;i++){var o=e[i],a=t[i];this.checkDims(o,a);var l=this.makeKey(o,a);this.entries.set(l,{value:r[i],row:o,col:a})}}return n.prototype.makeKey=function(e,t){return e+":"+t},n.prototype.checkDims=function(e,t){var r=e<this.nRows&&t<this.nCols;if(!r)throw new Error("row and/or col specified outside of matrix dimensions")},n.prototype.set=function(e,t,r){this.checkDims(e,t);var s=this.makeKey(e,t);this.entries.has(s)?this.entries.get(s).value=r:this.entries.set(s,{value:r,row:e,col:t})},n.prototype.get=function(e,t,r){r===void 0&&(r=0),this.checkDims(e,t);var s=this.makeKey(e,t);return this.entries.has(s)?this.entries.get(s).value:r},n.prototype.getAll=function(e){e===void 0&&(e=!0);var t=[];return this.entries.forEach(function(r){t.push(r)}),e&&t.sort(function(r,s){return r.row===s.row?r.col-s.col:r.row-s.row}),t},n.prototype.getDims=function(){return[this.nRows,this.nCols]},n.prototype.getRows=function(){return Array.from(this.entries,function(e){var t=sI(e,2);t[0];var r=t[1];return r.row})},n.prototype.getCols=function(){return Array.from(this.entries,function(e){var t=sI(e,2);t[0];var r=t[1];return r.col})},n.prototype.getValues=function(){return Array.from(this.entries,function(e){var t=sI(e,2);t[0];var r=t[1];return r.value})},n.prototype.forEach=function(e){this.entries.forEach(function(t){return e(t.value,t.row,t.col)})},n.prototype.map=function(e){var t=[];this.entries.forEach(function(s){t.push(e(s.value,s.row,s.col))});var r=[this.nRows,this.nCols];return new n(this.getRows(),this.getCols(),t,r)},n.prototype.toArray=function(){var e=this,t=Pq.empty(this.nRows),r=t.map(function(){return Pq.zeros(e.nCols)});return this.entries.forEach(function(s){r[s.row][s.col]=s.value}),r},n}();nl.SparseMatrix=ux;function Uwt(n){var e=[],t=[],r=[];n.forEach(function(i,o,a){e.push(o),t.push(a),r.push(i)});var s=[n.nCols,n.nRows];return new ux(t,e,r,s)}nl.transpose=Uwt;function Wwt(n){for(var e=sI(n,1),t=e[0],r=new ux([],[],[],n),s=0;s<t;s++)r.set(s,s,1);return r}nl.identity=Wwt;function Gwt(n,e){return z$(n,e,function(t,r){return t*r})}nl.pairwiseMultiply=Gwt;function Hwt(n,e){return z$(n,e,function(t,r){return t+r})}nl.add=Hwt;function jwt(n,e){return z$(n,e,function(t,r){return t-r})}nl.subtract=jwt;function qwt(n,e){return z$(n,e,function(t,r){return t>r?t:r})}nl.maximum=qwt;function Xwt(n,e){return n.map(function(t){return t*e})}nl.multiplyScalar=Xwt;function Kwt(n){for(var e=new Set,t=n.getValues(),r=n.getRows(),s=n.getCols(),i=0;i<t.length;i++)t[i]===0&&e.add(i);var o=function(u,h){return!e.has(h)},a=t.filter(o),l=r.filter(o),c=s.filter(o);return new ux(l,c,a,n.getDims())}nl.eliminateZeros=Kwt;function Ywt(n,e){e===void 0&&(e="l2");var t,r,s=Zwt[e],i=new Map;n.forEach(function(h,f,d){var p=i.get(f)||[];p.push(d),i.set(f,p)});var o=new ux([],[],[],n.getDims()),a=function(h){for(var f=i.get(h).sort(),d=f.map(function(g){return n.get(h,g)}),p=s(d),m=0;m<p.length;m++)o.set(h,f[m],p[m])};try{for(var l=Bwt(i.keys()),c=l.next();!c.done;c=l.next()){var u=c.value;a(u)}}catch(h){t={error:h}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(t)throw t.error}}return o}nl.normalize=Ywt;var Zwt=(d1={},d1.max=function(n){for(var e=-1/0,t=0;t<n.length;t++)e=n[t]>e?n[t]:e;return n.map(function(r){return r/e})},d1.l1=function(n){for(var e=0,t=0;t<n.length;t++)e+=n[t];return n.map(function(r){return r/e})},d1.l2=function(n){for(var e=0,t=0;t<n.length;t++)e+=Math.pow(n[t],2);return n.map(function(r){return Math.sqrt(Math.pow(r,2)/e)})},d1);function z$(n,e,t){for(var r=new Set,s=[],i=[],o=[],a=function(x,w){s.push(x),i.push(w);var S=t(n.get(x,w),e.get(x,w));o.push(S)},l=n.getValues(),c=n.getRows(),u=n.getCols(),h=0;h<l.length;h++){var f=c[h],d=u[h],p=f+":"+d;r.add(p),a(f,d)}for(var m=e.getValues(),g=e.getRows(),y=e.getCols(),h=0;h<m.length;h++){var f=g[h],d=y[h],p=f+":"+d;r.has(p)||a(f,d)}var b=[n.nRows,n.nCols];return new ux(s,i,o,b)}function Jwt(n){var e=[];n.forEach(function(h,f,d){e.push({value:h,row:f,col:d})}),e.sort(function(h,f){return h.row===f.row?h.col-f.col:h.row-f.row});for(var t=[],r=[],s=[],i=-1,o=0;o<e.length;o++){var a=e[o],l=a.row,c=a.col,u=a.value;l!==i&&(i=l,s.push(o)),t.push(c),r.push(u)}return{indices:t,values:r,indptr:s}}nl.getCSR=Jwt;var hx={},e0={},Qwt=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},oce=pt&&pt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(Qwt(arguments[e]));return n},ext=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},txt=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(e0,"__esModule",{value:!0});var Bo=txt(di),ace=function(){function n(e,t,r,s){this.hyperplanes=e,this.offsets=t,this.children=r,this.indices=s}return n}();e0.FlatTree=ace;function nxt(n,e,t,r){var s=Math.max(10,e),i=Bo.range(t).map(function(a,l){return rxt(n,s,l,r)}),o=i.map(function(a){return ixt(a,s)});return o}e0.makeForest=nxt;function rxt(n,e,t,r){e===void 0&&(e=30);var s=Bo.range(n.length),i=iL(n,s,e,t,r);return i}function iL(n,e,t,r,s){if(t===void 0&&(t=30),e.length>t){var i=sxt(n,e,s),o=i.indicesLeft,a=i.indicesRight,l=i.hyperplane,c=i.offset,u=iL(n,o,t,r+1,s),h=iL(n,a,t,r+1,s),f={leftChild:u,rightChild:h,isLeaf:!1,hyperplane:l,offset:c};return f}else{var f={indices:e,isLeaf:!0};return f}}function sxt(n,e,t){var r=n[0].length,s=Bo.tauRandInt(e.length,t),i=Bo.tauRandInt(e.length,t);i+=s===i?1:0,i=i%e.length;for(var o=e[s],a=e[i],l=0,c=Bo.zeros(r),u=0;u<c.length;u++)c[u]=n[o][u]-n[a][u],l-=c[u]*(n[o][u]+n[a][u])/2;for(var h=0,f=0,d=Bo.zeros(e.length),u=0;u<e.length;u++){for(var p=l,m=0;m<r;m++)p+=c[m]*n[e[u]][m];p===0?(d[u]=Bo.tauRandInt(2,t),d[u]===0?h+=1:f+=1):p>0?(d[u]=0,h+=1):(d[u]=1,f+=1)}var g=Bo.zeros(h),y=Bo.zeros(f);h=0,f=0;for(var u=0;u<d.length;u++)d[u]===0?(g[h]=e[u],h+=1):(y[f]=e[u],f+=1);return{indicesLeft:g,indicesRight:y,hyperplane:c,offset:l}}function ixt(n,e){var t=aL(n),r=lL(n),s=Bo.range(t).map(function(){return Bo.zeros(n.hyperplane?n.hyperplane.length:0)}),i=Bo.zeros(t),o=Bo.range(t).map(function(){return[-1,-1]}),a=Bo.range(r).map(function(){return Bo.range(e).map(function(){return-1})});return oL(n,s,i,o,a,0,0),new ace(s,i,o,a)}function oL(n,e,t,r,s,i,o){var a;if(n.isLeaf)return r[i][0]=-o,(a=s[o]).splice.apply(a,oce([0,n.indices.length],n.indices)),o+=1,{nodeNum:i,leafNum:o};e[i]=n.hyperplane,t[i]=n.offset,r[i][0]=i+1;var l=i,c=oL(n.leftChild,e,t,r,s,i+1,o);return i=c.nodeNum,o=c.leafNum,r[l][1]=i+1,c=oL(n.rightChild,e,t,r,s,i+1,o),{nodeNum:c.nodeNum,leafNum:c.leafNum}}function aL(n){return n.isLeaf?1:1+aL(n.leftChild)+aL(n.rightChild)}function lL(n){return n.isLeaf?1:lL(n.leftChild)+lL(n.rightChild)}function oxt(n){var e,t;if(n.length>0){var r=[];try{for(var s=ext(n),i=s.next();!i.done;i=s.next()){var o=i.value;r.push.apply(r,oce(o.indices))}}catch(a){e={error:a}}finally{try{i&&!i.done&&(t=s.return)&&t.call(s)}finally{if(e)throw e.error}}return r}else return[[-1]]}e0.makeLeafArray=oxt;function axt(n,e,t,r){for(var s=e,i=0;i<t.length;i++)s+=n[i]*t[i];if(s===0){var o=Bo.tauRandInt(2,r);return o}else return s>0?0:1}function lxt(n,e,t){for(var r=0;e.children[r][0]>0;){var s=axt(e.hyperplanes[r],e.offsets[r],n,t);s===0?r=e.children[r][0]:r=e.children[r][1]}var i=-1*e.children[r][0];return e.indices[i]}e0.searchFlatTree=lxt;var lce=pt&&pt.__values||function(n){var e=typeof Symbol=="function"&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}},B$=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e};Object.defineProperty(hx,"__esModule",{value:!0});var ha=B$(Ph),cxt=B$(nl),uxt=B$(e0),cce=B$(di);function hxt(n,e){return function(r,s,i,o,a,l,c,u){o===void 0&&(o=10),a===void 0&&(a=50),l===void 0&&(l=.001),c===void 0&&(c=.5),u===void 0&&(u=!0);for(var h=r.length,f=ha.makeHeap(r.length,i),d=0;d<r.length;d++)for(var p=ha.rejectionSample(i,r.length,e),m=0;m<p.length;m++){var g=n(r[d],r[p[m]]);ha.heapPush(f,d,g,p[m],1),ha.heapPush(f,p[m],g,d,1)}if(u)for(var y=0;y<s.length;y++)for(var d=0;d<s[y].length&&!(s[y][d]<0);d++)for(var m=d+1;m<s[y].length&&!(s[y][m]<0);m++){var g=n(r[s[y][d]],r[s[y][m]]);ha.heapPush(f,s[y][d],g,s[y][m],1),ha.heapPush(f,s[y][m],g,s[y][d],1)}for(var y=0;y<o;y++){for(var b=ha.buildCandidates(f,h,i,a,e),x=0,d=0;d<h;d++)for(var m=0;m<a;m++){var w=Math.floor(b[0][d][m]);if(!(w<0||cce.tauRand(e)<c))for(var S=0;S<a;S++){var C=Math.floor(b[0][d][S]),k=b[2][d][m],A=b[2][d][S];if(!(C<0||!k&&!A)){var g=n(r[w],r[C]);x+=ha.heapPush(f,w,g,C,1),x+=ha.heapPush(f,C,g,w,1)}}}if(x<=l*i*r.length)break}var M=ha.deheapSort(f);return M}}hx.makeNNDescent=hxt;function fxt(n){function e(r,s,i,o,a){for(var l=0;l<i.length;l++)for(var c=cce.rejectionSample(r,s.length,a),u=0;u<c.length;u++)if(!(c[u]<0)){var h=n(s[c[u]],i[l]);ha.heapPush(o,l,h,c[u],1)}}function t(r,s,i,o,a){for(var l=0;l<i.length;l++)for(var c=uxt.searchFlatTree(i[l],r,a),u=0;u<c.length;u++){if(c[u]<0)return;var h=n(s[c[u]],i[l]);ha.heapPush(o,l,h,c[u],1)}}return{initFromRandom:e,initFromTree:t}}hx.makeInitializations=fxt;function dxt(n){return function(t,r,s,i){for(var o,a,l=cxt.getCSR(r),c=l.indices,u=l.indptr,h=0;h<i.length;h++)for(var f=new Set(s[0][h]);;){var d=ha.smallestFlagged(s,h);if(d===-1)break;var p=c.slice(u[d],u[d+1]);try{for(var m=lce(p),g=m.next();!g.done;g=m.next()){var y=g.value;if(!(y===d||y===-1||f.has(y))){var b=n(t[y],i[h]);ha.uncheckedHeapPush(s,h,b,y,1),f.add(y)}}}catch(x){o={error:x}}finally{try{g&&!g.done&&(a=m.return)&&a.call(m)}finally{if(o)throw o.error}}}return s}}hx.makeInitializedNNSearch=dxt;function pxt(n,e,t,r,s,i,o){var a,l,c=ha.makeHeap(t.length,r);if(s(r,e,t,c,o),n)try{for(var u=lce(n),h=u.next();!h.done;h=u.next()){var f=h.value;i(f,e,t,c,o)}}catch(d){a={error:d}}finally{try{h&&!h.done&&(l=u.return)&&l.call(u)}finally{if(a)throw a.error}}return c}hx.initializeSearch=pxt;const mxt=Object.prototype.toString;function HP(n){return mxt.call(n).endsWith("Array]")}function Dq(n,e,t){let r=0;const s=t(e);for(let i=0;i<n.x.length;i++)r+=Math.abs(n.y[i]-s(n.x[i]));return r}function gxt(n,e,t,r,s){const i=t.length,o=n.x.length;let a=new Array(i);for(let l=0;l<i;l++){a[l]=new Array(o);let c=t.slice();c[l]+=r;let u=s(c);for(let h=0;h<o;h++)a[l][h]=e[h]-u(n.x[h])}return new ch(a)}function yxt(n,e){const t=n.x.length;let r=new Array(t);for(let s=0;s<t;s++)r[s]=[n.y[s]-e[s]];return new ch(r)}function bxt(n,e,t,r,s){let i=t*r*r,o=ch.eye(e.length,e.length,i);const a=s(e);let l=new Float64Array(n.x.length);for(let f=0;f<n.x.length;f++)l[f]=a(n.x[f]);let c=gxt(n,l,e,r,s),u=yxt(n,l),h=Jht(o.add(c.mmul(c.transpose())));return e=new ch([e]),e=e.sub(h.mmul(c).mmul(u).mul(r).transpose()),e.to1DArray()}function vxt(n,e,t={}){let{maxIterations:r=100,gradientDifference:s=.1,damping:i=0,errorTolerance:o=.01,minValues:a,maxValues:l,initialValues:c}=t;if(i<=0)throw new Error("The damping option must be a positive number");if(!n.x||!n.y)throw new Error("The data parameter must have x and y elements");if(!HP(n.x)||n.x.length<2||!HP(n.y)||n.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(n.x.length!==n.y.length)throw new Error("The data parameter elements must have the same size");let u=c||new Array(e.length).fill(1),h=u.length;if(l=l||new Array(h).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(h).fill(Number.MIN_SAFE_INTEGER),l.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!HP(u))throw new Error("initialValues must be an array");let f=Dq(n,u,e),d=f<=o,p;for(p=0;p<r&&!d;p++){u=bxt(n,u,i,s,e);for(let m=0;m<h;m++)u[m]=Math.min(Math.max(a[m],u[m]),l[m]);if(f=Dq(n,u,e),isNaN(f))break;d=f<=o}return{parameterValues:u,parameterError:f,iterations:p}}const wxt=Object.freeze(Object.defineProperty({__proto__:null,default:vxt},Symbol.toStringTag,{value:"Module"})),xxt=zf(wxt);var Oq=pt&&pt.__awaiter||function(n,e,t,r){return new(t||(t=Promise))(function(s,i){function o(c){try{l(r.next(c))}catch(u){i(u)}}function a(c){try{l(r.throw(c))}catch(u){i(u)}}function l(c){c.done?s(c.value):new t(function(u){u(c.value)}).then(o,a)}l((r=r.apply(n,e||[])).next())})},Fq=pt&&pt.__generator||function(n,e){var t={label:0,sent:function(){if(i[0]&1)throw i[1];return i[1]},trys:[],ops:[]},r,s,i,o;return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(c){return function(u){return l([c,u])}}function l(c){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(i=c[0]&2?s.return:c[0]?s.throw||((i=s.return)&&i.call(s),0):s.next)&&!(i=i.call(s,c[1])).done)return i;switch(s=0,i&&(c=[c[0]&2,i.value]),c[0]){case 0:case 1:i=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,s=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(i=t.trys,!(i=i.length>0&&i[i.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!i||c[1]>i[0]&&c[1]<i[3])){t.label=c[1];break}if(c[0]===6&&t.label<i[1]){t.label=i[1],i=c;break}if(i&&t.label<i[2]){t.label=i[2],t.ops.push(c);break}i[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],s=0}finally{r=i=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},cL=pt&&pt.__read||function(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r=t.call(n),s,i=[],o;try{for(;(e===void 0||e-- >0)&&!(s=r.next()).done;)i.push(s.value)}catch(a){o={error:a}}finally{try{s&&!s.done&&(t=r.return)&&t.call(r)}finally{if(o)throw o.error}}return i},Lq=pt&&pt.__spread||function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(cL(arguments[e]));return n},qC=pt&&pt.__importStar||function(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var t in n)Object.hasOwnProperty.call(n,t)&&(e[t]=n[t]);return e.default=n,e},_xt=pt&&pt.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Kf,"__esModule",{value:!0});var Sxt=qC(Ph),js=qC(nl),kE=qC(hx),zq=qC(e0),ii=qC(di),Cxt=_xt(xxt),Bq=1e-5,TE=.001,kxt=function(){function n(e){e===void 0&&(e={});var t=this;this.learningRate=1,this.localConnectivity=1,this.minDist=.1,this.nComponents=2,this.nEpochs=0,this.nNeighbors=15,this.negativeSampleRate=5,this.random=Math.random,this.repulsionStrength=1,this.setOpMixRatio=1,this.spread=1,this.transformQueueSize=4,this.targetMetric="categorical",this.targetWeight=.5,this.targetNNeighbors=this.nNeighbors,this.distanceFn=uce,this.isInitialized=!1,this.rpForest=[],this.embedding=[],this.optimizationState=new Ext;var r=function(s){e[s]!==void 0&&(t[s]=e[s])};r("distanceFn"),r("learningRate"),r("localConnectivity"),r("minDist"),r("nComponents"),r("nEpochs"),r("nNeighbors"),r("negativeSampleRate"),r("random"),r("repulsionStrength"),r("setOpMixRatio"),r("spread"),r("transformQueueSize")}return n.prototype.fit=function(e){return this.initializeFit(e),this.optimizeLayout(),this.embedding},n.prototype.fitAsync=function(e,t){return t===void 0&&(t=function(){return!0}),Oq(this,void 0,void 0,function(){return Fq(this,function(r){switch(r.label){case 0:return this.initializeFit(e),[4,this.optimizeLayoutAsync(t)];case 1:return r.sent(),[2,this.embedding]}})})},n.prototype.setSupervisedProjection=function(e,t){t===void 0&&(t={}),this.Y=e,this.targetMetric=t.targetMetric||this.targetMetric,this.targetWeight=t.targetWeight||this.targetWeight,this.targetNNeighbors=t.targetNNeighbors||this.targetNNeighbors},n.prototype.setPrecomputedKNN=function(e,t){this.knnIndices=e,this.knnDistances=t},n.prototype.initializeFit=function(e){if(e.length<=this.nNeighbors)throw new Error("Not enough data points ("+e.length+") to create nNeighbors: "+this.nNeighbors+".  Add more data points or adjust the configuration.");if(this.X===e&&this.isInitialized)return this.getNEpochs();if(this.X=e,!this.knnIndices&&!this.knnDistances){var t=this.nearestNeighbors(e);this.knnIndices=t.knnIndices,this.knnDistances=t.knnDistances}this.graph=this.fuzzySimplicialSet(e,this.nNeighbors,this.setOpMixRatio),this.makeSearchFns(),this.searchGraph=this.makeSearchGraph(e),this.processGraphForSupervisedProjection();var r=this.initializeSimplicialSetEmbedding(),s=r.head,i=r.tail,o=r.epochsPerSample;return this.optimizationState.head=s,this.optimizationState.tail=i,this.optimizationState.epochsPerSample=o,this.initializeOptimization(),this.prepareForOptimizationLoop(),this.isInitialized=!0,this.getNEpochs()},n.prototype.makeSearchFns=function(){var e=kE.makeInitializations(this.distanceFn),t=e.initFromTree,r=e.initFromRandom;this.initFromTree=t,this.initFromRandom=r,this.search=kE.makeInitializedNNSearch(this.distanceFn)},n.prototype.makeSearchGraph=function(e){for(var t=this.knnIndices,r=this.knnDistances,s=[e.length,e.length],i=new js.SparseMatrix([],[],[],s),o=0;o<t.length;o++)for(var a=t[o],l=r[o],c=0;c<a.length;c++){var u=a[c],h=l[c];h>0&&i.set(o,u,h)}var f=js.transpose(i);return js.maximum(i,f)},n.prototype.transform=function(e){var t=this,r=this.X;if(r===void 0||r.length===0)throw new Error("No data has been fit.");var s=Math.floor(this.nNeighbors*this.transformQueueSize);s=Math.min(r.length,s);var i=kE.initializeSearch(this.rpForest,r,e,s,this.initFromRandom,this.initFromTree,this.random),o=this.search(r,this.searchGraph,i,e),a=Sxt.deheapSort(o),l=a.indices,c=a.weights;l=l.map(function(z){return z.slice(0,t.nNeighbors)}),c=c.map(function(z){return z.slice(0,t.nNeighbors)});var u=Math.max(0,this.localConnectivity-1),h=this.smoothKNNDistance(c,this.nNeighbors,u),f=h.sigmas,d=h.rhos,p=this.computeMembershipStrengths(l,c,f,d),m=p.rows,g=p.cols,y=p.vals,b=[e.length,r.length],x=new js.SparseMatrix(m,g,y,b),w=js.normalize(x,"l1"),S=js.getCSR(w),C=e.length,k=ii.reshape2d(S.indices,C,this.nNeighbors),A=ii.reshape2d(S.values,C,this.nNeighbors),M=pce(k,A,this.embedding),E=this.nEpochs?this.nEpochs/3:x.nRows<=1e4?100:30,N=x.getValues().reduce(function(z,B){return B>z?B:z},0);x=x.map(function(z){return z<N/E?0:z}),x=js.eliminateZeros(x);var O=this.makeEpochsPerSample(x.getValues(),E),R=x.getRows(),D=x.getCols();return this.assignOptimizationStateParameters({headEmbedding:M,tailEmbedding:this.embedding,head:R,tail:D,currentEpoch:0,nEpochs:E,nVertices:x.getDims()[1],epochsPerSample:O}),this.prepareForOptimizationLoop(),this.optimizeLayout()},n.prototype.processGraphForSupervisedProjection=function(){var e=this,t=e.Y,r=e.X;if(t){if(t.length!==r.length)throw new Error("Length of X and y must be equal");if(this.targetMetric==="categorical"){var s=this.targetWeight<1,i=s?2.5*(1/(1-this.targetWeight)):1e12;this.graph=this.categoricalSimplicialSetIntersection(this.graph,t,i)}}},n.prototype.step=function(){var e=this.optimizationState.currentEpoch;return e<this.getNEpochs()&&this.optimizeLayoutStep(e),this.optimizationState.currentEpoch},n.prototype.getEmbedding=function(){return this.embedding},n.prototype.nearestNeighbors=function(e){var t=this,r=t.distanceFn,s=t.nNeighbors,i=function(p){return Math.log(p)/Math.log(2)},o=kE.makeNNDescent(r,this.random),a=function(p){return p===.5?0:Math.round(p)},l=5+Math.floor(a(Math.pow(e.length,.5)/20)),c=Math.max(5,Math.floor(Math.round(i(e.length))));this.rpForest=zq.makeForest(e,s,l,this.random);var u=zq.makeLeafArray(this.rpForest),h=o(e,u,s,c),f=h.indices,d=h.weights;return{knnIndices:f,knnDistances:d}},n.prototype.fuzzySimplicialSet=function(e,t,r){r===void 0&&(r=1);var s=this,i=s.knnIndices,o=i===void 0?[]:i,a=s.knnDistances,l=a===void 0?[]:a,c=s.localConnectivity,u=this.smoothKNNDistance(l,t,c),h=u.sigmas,f=u.rhos,d=this.computeMembershipStrengths(o,l,h,f),p=d.rows,m=d.cols,g=d.vals,y=[e.length,e.length],b=new js.SparseMatrix(p,m,g,y),x=js.transpose(b),w=js.pairwiseMultiply(b,x),S=js.subtract(js.add(b,x),w),C=js.multiplyScalar(S,r),k=js.multiplyScalar(w,1-r),A=js.add(C,k);return A},n.prototype.categoricalSimplicialSetIntersection=function(e,t,r,s){s===void 0&&(s=1);var i=fce(e,t,s,r);return i=js.eliminateZeros(i),dce(i)},n.prototype.smoothKNNDistance=function(e,t,r,s,i){r===void 0&&(r=1),s===void 0&&(s=64),i===void 0&&(i=1);for(var o=Math.log(t)/Math.log(2)*i,a=ii.zeros(e.length),l=ii.zeros(e.length),c=0;c<e.length;c++){var u=0,h=1/0,f=1,d=e[c],p=d.filter(function(k){return k>0});if(p.length>=r){var m=Math.floor(r),g=r-m;m>0?(a[c]=p[m-1],g>Bq&&(a[c]+=g*(p[m]-p[m-1]))):a[c]=g*p[0]}else p.length>0&&(a[c]=ii.max(p));for(var y=0;y<s;y++){for(var b=0,x=1;x<e[c].length;x++){var w=e[c][x]-a[c];w>0?b+=Math.exp(-(w/f)):b+=1}if(Math.abs(b-o)<Bq)break;b>o?(h=f,f=(u+h)/2):(u=f,h===1/0?f*=2:f=(u+h)/2)}if(l[c]=f,a[c]>0){var S=ii.mean(d);l[c]<TE*S&&(l[c]=TE*S)}else{var C=ii.mean(e.map(ii.mean));l[c]<TE*C&&(l[c]=TE*C)}}return{sigmas:l,rhos:a}},n.prototype.computeMembershipStrengths=function(e,t,r,s){for(var i=e.length,o=e[0].length,a=ii.zeros(i*o),l=ii.zeros(i*o),c=ii.zeros(i*o),u=0;u<i;u++)for(var h=0;h<o;h++){var f=0;e[u][h]!==-1&&(e[u][h]===u?f=0:t[u][h]-s[u]<=0?f=1:f=Math.exp(-((t[u][h]-s[u])/r[u])),a[u*o+h]=u,l[u*o+h]=e[u][h],c[u*o+h]=f)}return{rows:a,cols:l,vals:c}},n.prototype.initializeSimplicialSetEmbedding=function(){for(var e=this,t=this.getNEpochs(),r=this.nComponents,s=this.graph.getValues(),i=0,o=0;o<s.length;o++){var a=s[o];i<s[o]&&(i=a)}var l=this.graph.map(function(m){return m<i/t?0:m});this.embedding=ii.zeros(l.nRows).map(function(){return ii.zeros(r).map(function(){return ii.tauRand(e.random)*20+-10})});for(var c=[],u=[],h=[],f=l.getAll(),o=0;o<f.length;o++){var d=f[o];d.value&&(c.push(d.value),h.push(d.row),u.push(d.col))}var p=this.makeEpochsPerSample(c,t);return{head:u,tail:h,epochsPerSample:p}},n.prototype.makeEpochsPerSample=function(e,t){var r=ii.filled(e.length,-1),s=ii.max(e),i=e.map(function(o){return o/s*t});return i.forEach(function(o,a){o>0&&(r[a]=t/i[a])}),r},n.prototype.assignOptimizationStateParameters=function(e){Object.assign(this.optimizationState,e)},n.prototype.prepareForOptimizationLoop=function(){var e=this,t=e.repulsionStrength,r=e.learningRate,s=e.negativeSampleRate,i=this.optimizationState,o=i.epochsPerSample,a=i.headEmbedding,l=i.tailEmbedding,c=a[0].length,u=a.length===l.length,h=o.map(function(p){return p/s}),f=Lq(h),d=Lq(o);this.assignOptimizationStateParameters({epochOfNextSample:d,epochOfNextNegativeSample:f,epochsPerNegativeSample:h,moveOther:u,initialAlpha:r,alpha:r,gamma:t,dim:c})},n.prototype.initializeOptimization=function(){var e=this.embedding,t=this.embedding,r=this.optimizationState,s=r.head,i=r.tail,o=r.epochsPerSample,a=this.getNEpochs(),l=this.graph.nCols,c=hce(this.spread,this.minDist),u=c.a,h=c.b;this.assignOptimizationStateParameters({headEmbedding:e,tailEmbedding:t,head:s,tail:i,epochsPerSample:o,a:u,b:h,nEpochs:a,nVertices:l})},n.prototype.optimizeLayoutStep=function(e){for(var t=this.optimizationState,r=t.head,s=t.tail,i=t.headEmbedding,o=t.tailEmbedding,a=t.epochsPerSample,l=t.epochOfNextSample,c=t.epochOfNextNegativeSample,u=t.epochsPerNegativeSample,h=t.moveOther,f=t.initialAlpha,d=t.alpha,p=t.gamma,m=t.a,g=t.b,y=t.dim,b=t.nEpochs,x=t.nVertices,w=4,S=0;S<a.length;S++)if(!(l[S]>e)){var C=r[S],k=s[S],A=i[C],M=o[k],E=Uq(A,M),N=0;E>0&&(N=-2*m*g*Math.pow(E,g-1),N/=m*Math.pow(E,g)+1);for(var O=0;O<y;O++){var R=Vq(N*(A[O]-M[O]),w);A[O]+=R*d,h&&(M[O]+=-R*d)}l[S]+=a[S];for(var D=Math.floor((e-c[S])/u[S]),z=0;z<D;z++){var B=ii.tauRandInt(x,this.random),X=o[B],G=Uq(A,X),te=0;if(G>0)te=2*p*g,te/=(.001+G)*(m*Math.pow(G,g)+1);else if(C===B)continue;for(var O=0;O<y;O++){var R=4;te>0&&(R=Vq(te*(A[O]-X[O]),w)),A[O]+=R*d}}c[S]+=D*u[S]}return t.alpha=f*(1-e/b),t.currentEpoch+=1,i},n.prototype.optimizeLayoutAsync=function(e){var t=this;return e===void 0&&(e=function(){return!0}),new Promise(function(r,s){var i=function(){return Oq(t,void 0,void 0,function(){var o,a,l,c,u,h;return Fq(this,function(f){try{if(o=this.optimizationState,a=o.nEpochs,l=o.currentEpoch,this.embedding=this.optimizeLayoutStep(l),c=this.optimizationState.currentEpoch,u=e(c)===!1,h=c===a,!u&&!h)setTimeout(function(){return i()},0);else return[2,r(h)]}catch(d){s(d)}return[2]})})};setTimeout(function(){return i()},0)})},n.prototype.optimizeLayout=function(e){e===void 0&&(e=function(){return!0});for(var t=!1,r=[];!t;){var s=this.optimizationState,i=s.nEpochs,o=s.currentEpoch;r=this.optimizeLayoutStep(o);var a=this.optimizationState.currentEpoch,l=e(a)===!1;t=a===i||l}return r},n.prototype.getNEpochs=function(){var e=this.graph;if(this.nEpochs>0)return this.nEpochs;var t=e.nRows;return t<=2500?500:t<=5e3?400:t<=7500?300:200},n}();Kf.UMAP=kxt;function uce(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return Math.sqrt(t)}Kf.euclidean=uce;function Txt(n,e){for(var t=0,r=0,s=0,i=0;i<n.length;i++)t+=n[i]*e[i],r+=Math.pow(n[i],2),s+=Math.pow(e[i],2);return r===0&&s===0?0:r===0||s===0?1:1-t/Math.sqrt(r*s)}Kf.cosine=Txt;var Ext=function(){function n(){this.currentEpoch=0,this.headEmbedding=[],this.tailEmbedding=[],this.head=[],this.tail=[],this.epochsPerSample=[],this.epochOfNextSample=[],this.epochOfNextNegativeSample=[],this.epochsPerNegativeSample=[],this.moveOther=!0,this.initialAlpha=1,this.alpha=1,this.gamma=1,this.a=1.5769434603113077,this.b=.8950608779109733,this.dim=2,this.nEpochs=500,this.nVertices=0}return n}();function Vq(n,e){return n>e?e:n<-e?-e:n}function Uq(n,e){for(var t=0,r=0;r<n.length;r++)t+=Math.pow(n[r]-e[r],2);return t}function hce(n,e){var t=function(f){var d=cL(f,2),p=d[0],m=d[1];return function(g){return 1/(1+p*Math.pow(g,2*m))}},r=ii.linear(0,n*3,300).map(function(f){return f<e?1:f}),s=ii.zeros(r.length).map(function(f,d){var p=r[d]>=e;return p?Math.exp(-(r[d]-e)/n):f}),i=[.5,.5],o={x:r,y:s},a={damping:1.5,initialValues:i,gradientDifference:.1,maxIterations:100,errorTolerance:.01},l=Cxt.default(o,t,a).parameterValues,c=cL(l,2),u=c[0],h=c[1];return{a:u,b:h}}Kf.findABParams=hce;function fce(n,e,t,r){return t===void 0&&(t=1),r===void 0&&(r=5),n.map(function(s,i,o){return e[i]===-1||e[o]===-1?s*Math.exp(-t):e[i]!==e[o]?s*Math.exp(-r):s})}Kf.fastIntersection=fce;function dce(n){n=js.normalize(n,"max");var e=js.transpose(n),t=js.pairwiseMultiply(e,n);return n=js.add(n,js.subtract(e,t)),js.eliminateZeros(n)}Kf.resetLocalConnectivity=dce;function pce(n,e,t){for(var r=ii.zeros(n.length).map(function(l){return ii.zeros(t[0].length)}),s=0;s<n.length;s++)for(var i=0;i<n[0].length;i++)for(var o=0;o<t[0].length;o++){var a=n[s][i];r[s][o]+=e[s][i]*t[a][o]}return r}Kf.initTransform=pce;Object.defineProperty(ece,"__esModule",{value:!0});var Ixt=Kf;ece.UMAP=Ixt.UMAP;function tt(){}const V$=n=>n;function Axt(n,e){for(const t in e)n[t]=e[t];return n}function Mxt(n){return!!n&&(typeof n=="object"||typeof n=="function")&&typeof n.then=="function"}function mce(n){return n()}function Wq(){return Object.create(null)}function po(n){n.forEach(mce)}function t0(n){return typeof n=="function"}function pn(n,e){return n!=n?e==e:n!==e||n&&typeof n=="object"||typeof n=="function"}let EE;function Sv(n,e){return EE||(EE=document.createElement("a")),EE.href=e,n===EE.href}function Nxt(n){return Object.keys(n).length===0}function os(n,...e){if(n==null)return tt;const t=n.subscribe(...e);return t.unsubscribe?()=>t.unsubscribe():t}function h_(n){let e;return os(n,t=>e=t)(),e}function LV(n,e,t){n.$$.on_destroy.push(os(e,t))}function Bp(n,e,t,r){if(n){const s=gce(n,e,t,r);return n[0](s)}}function gce(n,e,t,r){return n[1]&&r?Axt(t.ctx.slice(),n[1](r(e))):t.ctx}function Vp(n,e,t,r){if(n[2]&&r){const s=n[2](r(t));if(e.dirty===void 0)return s;if(typeof s=="object"){const i=[],o=Math.max(e.dirty.length,s.length);for(let a=0;a<o;a+=1)i[a]=e.dirty[a]|s[a];return i}return e.dirty|s}return e.dirty}function Up(n,e,t,r,s,i){if(s){const o=gce(e,t,r,i);n.p(o,s)}}function Wp(n){if(n.ctx.length>32){const e=[],t=n.ctx.length/32;for(let r=0;r<t;r++)e[r]=-1;return e}return-1}function $xt(n){return n&&t0(n.destroy)?n.destroy:tt}function Rxt(n){const e=typeof n=="string"&&n.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);return e?[parseFloat(e[1]),e[2]||"px"]:[n,"px"]}const yce=typeof window<"u";let U$=yce?()=>window.performance.now():()=>Date.now(),zV=yce?n=>requestAnimationFrame(n):tt;const Fb=new Set;function bce(n){Fb.forEach(e=>{e.c(n)||(Fb.delete(e),e.f())}),Fb.size!==0&&zV(bce)}function W$(n){let e;return Fb.size===0&&zV(bce),{promise:new Promise(t=>{Fb.add(e={c:n,f:t})}),abort(){Fb.delete(e)}}}const Pxt=typeof window<"u"?window:typeof globalThis<"u"?globalThis:global;function se(n,e){n.appendChild(e)}function vce(n){if(!n)return document;const e=n.getRootNode?n.getRootNode():n.ownerDocument;return e&&e.host?e:n.ownerDocument}function Dxt(n){const e=we("style");return Oxt(vce(n),e),e.sheet}function Oxt(n,e){return se(n.head||n,e),e.sheet}function me(n,e,t){n.insertBefore(e,t||null)}function de(n){n.parentNode&&n.parentNode.removeChild(n)}function qs(n,e){for(let t=0;t<n.length;t+=1)n[t]&&n[t].d(e)}function we(n){return document.createElement(n)}function Fs(n){return document.createElementNS("http://www.w3.org/2000/svg",n)}function He(n){return document.createTextNode(n)}function Ye(){return He(" ")}function mo(){return He("")}function qn(n,e,t,r){return n.addEventListener(e,t,r),()=>n.removeEventListener(e,t,r)}function XC(n){return function(e){return e.preventDefault(),n.call(this,e)}}function Fxt(n){return function(e){return e.stopPropagation(),n.call(this,e)}}function Z(n,e,t){t==null?n.removeAttribute(e):n.getAttribute(e)!==t&&n.setAttribute(e,t)}function Cb(n,e,t){e in n?n[e]=typeof n[e]=="boolean"&&t===""?!0:t:Z(n,e,t)}function Lxt(n){return Array.from(n.childNodes)}function cn(n,e){e=""+e,n.data!==e&&(n.data=e)}function lu(n,e,t,r){t==null?n.style.removeProperty(e):n.style.setProperty(e,t,r?"important":"")}function Gq(n,e,t){for(let r=0;r<n.options.length;r+=1){const s=n.options[r];if(s.__value===e){s.selected=!0;return}}(!t||e!==void 0)&&(n.selectedIndex=-1)}function zxt(n){const e=n.querySelector(":checked");return e&&e.__value}function qt(n,e,t){n.classList[t?"add":"remove"](e)}function wce(n,e,{bubbles:t=!1,cancelable:r=!1}={}){const s=document.createEvent("CustomEvent");return s.initCustomEvent(n,t,r,e),s}class Bxt{constructor(e=!1){this.is_svg=!1,this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,r=null){this.e||(this.is_svg?this.e=Fs(t.nodeName):this.e=we(t.nodeType===11?"TEMPLATE":t.nodeName),this.t=t.tagName!=="TEMPLATE"?t:t.content,this.c(e)),this.i(r)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.nodeName==="TEMPLATE"?this.e.content.childNodes:this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)me(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(de)}}const hM=new Map;let fM=0;function Vxt(n){let e=5381,t=n.length;for(;t--;)e=(e<<5)-e^n.charCodeAt(t);return e>>>0}function Uxt(n,e){const t={stylesheet:Dxt(e),rules:{}};return hM.set(n,t),t}function LS(n,e,t,r,s,i,o,a=0){const l=16.666/r;let c=`{
`;for(let g=0;g<=1;g+=l){const y=e+(t-e)*i(g);c+=g*100+`%{${o(y,1-y)}}
`}const u=c+`100% {${o(t,1-t)}}
}`,h=`__svelte_${Vxt(u)}_${a}`,f=vce(n),{stylesheet:d,rules:p}=hM.get(f)||Uxt(f,n);p[h]||(p[h]=!0,d.insertRule(`@keyframes ${h} ${u}`,d.cssRules.length));const m=n.style.animation||"";return n.style.animation=`${m?`${m}, `:""}${h} ${r}ms linear ${s}ms 1 both`,fM+=1,h}function zS(n,e){const t=(n.style.animation||"").split(", "),r=t.filter(e?i=>i.indexOf(e)<0:i=>i.indexOf("__svelte")===-1),s=t.length-r.length;s&&(n.style.animation=r.join(", "),fM-=s,fM||Wxt())}function Wxt(){zV(()=>{fM||(hM.forEach(n=>{const{ownerNode:e}=n.stylesheet;e&&de(e)}),hM.clear())})}function Gxt(n,e,t,r){if(!e)return tt;const s=n.getBoundingClientRect();if(e.left===s.left&&e.right===s.right&&e.top===s.top&&e.bottom===s.bottom)return tt;const{delay:i=0,duration:o=300,easing:a=V$,start:l=U$()+i,end:c=l+o,tick:u=tt,css:h}=t(n,{from:e,to:s},r);let f=!0,d=!1,p;function m(){h&&(p=LS(n,0,1,o,i,a,h)),i||(d=!0)}function g(){h&&zS(n,p),f=!1}return W$(y=>{if(!d&&y>=l&&(d=!0),d&&y>=c&&(u(1,0),g()),!f)return!1;if(d){const b=y-l,x=0+1*a(b/o);u(x,1-x)}return!0}),m(),u(0,1),g}function Hxt(n){const e=getComputedStyle(n);if(e.position!=="absolute"&&e.position!=="fixed"){const{width:t,height:r}=e,s=n.getBoundingClientRect();n.style.position="absolute",n.style.width=t,n.style.height=r,xce(n,s)}}function xce(n,e){const t=n.getBoundingClientRect();if(e.left!==t.left||e.top!==t.top){const r=getComputedStyle(n),s=r.transform==="none"?"":r.transform;n.style.transform=`${s} translate(${e.left-t.left}px, ${e.top-t.top}px)`}}let BS;function Tf(n){BS=n}function n0(){if(!BS)throw new Error("Function called outside component initialization");return BS}function Nu(n){n0().$$.on_mount.push(n)}function _ce(n){n0().$$.after_update.push(n)}function $g(n){n0().$$.on_destroy.push(n)}function Pc(){const n=n0();return(e,t,{cancelable:r=!1}={})=>{const s=n.$$.callbacks[e];if(s){const i=wce(e,t,{cancelable:r});return s.slice().forEach(o=>{o.call(n,i)}),!i.defaultPrevented}return!0}}function jxt(n,e){return n0().$$.context.set(n,e),e}function Sce(n){return n0().$$.context.get(n)}function dM(n,e){const t=n.$$.callbacks[e.type];t&&t.slice().forEach(r=>r.call(this,e))}const yb=[],hi=[];let Lb=[];const uL=[],Cce=Promise.resolve();let hL=!1;function kce(){hL||(hL=!0,Cce.then(Rg))}function ea(){return kce(),Cce}function $u(n){Lb.push(n)}function Yf(n){uL.push(n)}const jP=new Set;let ab=0;function Rg(){if(ab!==0)return;const n=BS;do{try{for(;ab<yb.length;){const e=yb[ab];ab++,Tf(e),qxt(e.$$)}}catch(e){throw yb.length=0,ab=0,e}for(Tf(null),yb.length=0,ab=0;hi.length;)hi.pop()();for(let e=0;e<Lb.length;e+=1){const t=Lb[e];jP.has(t)||(jP.add(t),t())}Lb.length=0}while(yb.length);for(;uL.length;)uL.pop()();hL=!1,jP.clear(),Tf(n)}function qxt(n){if(n.fragment!==null){n.update(),po(n.before_update);const e=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,e),n.after_update.forEach($u)}}function Xxt(n){const e=[],t=[];Lb.forEach(r=>n.indexOf(r)===-1?e.push(r):t.push(r)),t.forEach(r=>r()),Lb=e}let p1;function BV(){return p1||(p1=Promise.resolve(),p1.then(()=>{p1=null})),p1}function eg(n,e,t){n.dispatchEvent(wce(`${e?"intro":"outro"}${t}`))}const iI=new Set;let fh;function dr(){fh={r:0,c:[],p:fh}}function pr(){fh.r||po(fh.c),fh=fh.p}function Ie(n,e){n&&n.i&&(iI.delete(n),n.i(e))}function $e(n,e,t,r){if(n&&n.o){if(iI.has(n))return;iI.add(n),fh.c.push(()=>{iI.delete(n),r&&(t&&n.d(1),r())}),n.o(e)}else r&&r()}const VV={duration:0};function Kxt(n,e,t){const r={direction:"in"};let s=e(n,t,r),i=!1,o,a,l=0;function c(){o&&zS(n,o)}function u(){const{delay:f=0,duration:d=300,easing:p=V$,tick:m=tt,css:g}=s||VV;g&&(o=LS(n,0,1,d,f,p,g,l++)),m(0,1);const y=U$()+f,b=y+d;a&&a.abort(),i=!0,$u(()=>eg(n,!0,"start")),a=W$(x=>{if(i){if(x>=b)return m(1,0),eg(n,!0,"end"),c(),i=!1;if(x>=y){const w=p((x-y)/d);m(w,1-w)}}return i})}let h=!1;return{start(){h||(h=!0,zS(n),t0(s)?(s=s(r),BV().then(u)):u())},invalidate(){h=!1},end(){i&&(c(),i=!1)}}}function Yxt(n,e,t){const r={direction:"out"};let s=e(n,t,r),i=!0,o;const a=fh;a.r+=1;function l(){const{delay:c=0,duration:u=300,easing:h=V$,tick:f=tt,css:d}=s||VV;d&&(o=LS(n,1,0,u,c,h,d));const p=U$()+c,m=p+u;$u(()=>eg(n,!1,"start")),W$(g=>{if(i){if(g>=m)return f(0,1),eg(n,!1,"end"),--a.r||po(a.c),!1;if(g>=p){const y=h((g-p)/u);f(1-y,y)}}return i})}return t0(s)?BV().then(()=>{s=s(r),l()}):l(),{end(c){c&&s.tick&&s.tick(1,0),i&&(o&&zS(n,o),i=!1)}}}function Cv(n,e,t,r){const s={direction:"both"};let i=e(n,t,s),o=r?0:1,a=null,l=null,c=null;function u(){c&&zS(n,c)}function h(d,p){const m=d.b-o;return p*=Math.abs(m),{a:o,b:d.b,d:m,duration:p,start:d.start,end:d.start+p,group:d.group}}function f(d){const{delay:p=0,duration:m=300,easing:g=V$,tick:y=tt,css:b}=i||VV,x={start:U$()+p,b:d};d||(x.group=fh,fh.r+=1),a||l?l=x:(b&&(u(),c=LS(n,o,d,m,p,g,b)),d&&y(0,1),a=h(x,m),$u(()=>eg(n,d,"start")),W$(w=>{if(l&&w>l.start&&(a=h(l,m),l=null,eg(n,a.b,"start"),b&&(u(),c=LS(n,o,a.b,a.duration,0,g,i.css))),a){if(w>=a.end)y(o=a.b,1-o),eg(n,a.b,"end"),l||(a.b?u():--a.group.r||po(a.group.c)),a=null;else if(w>=a.start){const S=w-a.start;o=a.a+a.d*g(S/a.duration),y(o,1-o)}}return!!(a||l)}))}return{run(d){t0(i)?BV().then(()=>{i=i(s),f(d)}):f(d)},end(){u(),a=l=null}}}function Hq(n,e){const t=e.token={};function r(s,i,o,a){if(e.token!==t)return;e.resolved=a;let l=e.ctx;o!==void 0&&(l=l.slice(),l[o]=a);const c=s&&(e.current=s)(l);let u=!1;e.block&&(e.blocks?e.blocks.forEach((h,f)=>{f!==i&&h&&(dr(),$e(h,1,1,()=>{e.blocks[f]===h&&(e.blocks[f]=null)}),pr())}):e.block.d(1),c.c(),Ie(c,1),c.m(e.mount(),e.anchor),u=!0),e.block=c,e.blocks&&(e.blocks[i]=c),u&&Rg()}if(Mxt(n)){const s=n0();if(n.then(i=>{Tf(s),r(e.then,1,e.value,i),Tf(null)},i=>{if(Tf(s),r(e.catch,2,e.error,i),Tf(null),!e.hasCatch)throw i}),e.current!==e.pending)return r(e.pending,0),!0}else{if(e.current!==e.then)return r(e.then,1,e.value,n),!0;e.resolved=n}}function Zxt(n,e,t){const r=e.slice(),{resolved:s}=n;n.current===n.then&&(r[n.value]=s),n.current===n.catch&&(r[n.error]=s),n.block.p(r,t)}function Tce(n,e){$e(n,1,1,()=>{e.delete(n.key)})}function Jxt(n,e){n.f(),Tce(n,e)}function Ece(n,e,t,r,s,i,o,a,l,c,u,h){let f=n.length,d=i.length,p=f;const m={};for(;p--;)m[n[p].key]=p;const g=[],y=new Map,b=new Map,x=[];for(p=d;p--;){const k=h(s,i,p),A=t(k);let M=o.get(A);M?r&&x.push(()=>M.p(k,e)):(M=c(A,k),M.c()),y.set(A,g[p]=M),A in m&&b.set(A,Math.abs(p-m[A]))}const w=new Set,S=new Set;function C(k){Ie(k,1),k.m(a,u),o.set(k.key,k),u=k.first,d--}for(;f&&d;){const k=g[d-1],A=n[f-1],M=k.key,E=A.key;k===A?(u=k.first,f--,d--):y.has(E)?!o.has(M)||w.has(M)?C(k):S.has(E)?f--:b.get(M)>b.get(E)?(S.add(M),C(k)):(w.add(E),f--):(l(A,o),f--)}for(;f--;){const k=n[f];y.has(k.key)||l(k,o)}for(;d;)C(g[d-1]);return po(x),g}function Zf(n,e,t){const r=n.$$.props[e];r!==void 0&&(n.$$.bound[r]=t,t(n.$$.ctx[r]))}function It(n){n&&n.c()}function kt(n,e,t,r){const{fragment:s,after_update:i}=n.$$;s&&s.m(e,t),r||$u(()=>{const o=n.$$.on_mount.map(mce).filter(t0);n.$$.on_destroy?n.$$.on_destroy.push(...o):po(o),n.$$.on_mount=[]}),i.forEach($u)}function Tt(n,e){const t=n.$$;t.fragment!==null&&(Xxt(t.after_update),po(t.on_destroy),t.fragment&&t.fragment.d(e),t.on_destroy=t.fragment=null,t.ctx=[])}function Qxt(n,e){n.$$.dirty[0]===-1&&(yb.push(n),kce(),n.$$.dirty.fill(0)),n.$$.dirty[e/31|0]|=1<<e%31}function wn(n,e,t,r,s,i,o,a=[-1]){const l=BS;Tf(n);const c=n.$$={fragment:null,ctx:[],props:i,update:tt,not_equal:s,bound:Wq(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(l?l.$$.context:[])),callbacks:Wq(),dirty:a,skip_bound:!1,root:e.target||l.$$.root};o&&o(c.root);let u=!1;if(c.ctx=t?t(n,e.props||{},(h,f,...d)=>{const p=d.length?d[0]:f;return c.ctx&&s(c.ctx[h],c.ctx[h]=p)&&(!c.skip_bound&&c.bound[h]&&c.bound[h](p),u&&Qxt(n,h)),f}):[],c.update(),u=!0,po(c.before_update),c.fragment=r?r(c.ctx):!1,e.target){if(e.hydrate){const h=Lxt(e.target);c.fragment&&c.fragment.l(h),h.forEach(de)}else c.fragment&&c.fragment.c();e.intro&&Ie(n.$$.fragment),kt(n,e.target,e.anchor,e.customElement),Rg()}Tf(l)}class xn{$destroy(){Tt(this,1),this.$destroy=tt}$on(e,t){if(!t0(t))return tt;const r=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return r.push(t),()=>{const s=r.indexOf(t);s!==-1&&r.splice(s,1)}}$set(e){this.$$set&&!Nxt(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}function e1t(n){let e,t,r,s,i;const o=n[10].default,a=Bp(o,n,n[9],null);return{c(){e=Ye(),t=we("button"),a&&a.c(),Z(t,"class","marcelle svelte-2j0fl0"),t.disabled=n[1],qt(t,"outline",n[0]==="outline"),qt(t,"filled",n[0]==="filled"),qt(t,"light",n[0]==="light"),qt(t,"success",n[2]==="success"),qt(t,"warning",n[2]==="warning"),qt(t,"danger",n[2]==="danger"),qt(t,"size-small",n[3]==="small"),qt(t,"size-large",n[3]==="large"),qt(t,"round",n[4])},m(l,c){me(l,e,c),me(l,t,c),a&&a.m(t,null),r=!0,s||(i=[qn(document.body,"mouseup",n[6]),qn(document.body,"touchend",n[6]),qn(t,"click",n[11]),qn(t,"mousedown",n[5]),qn(t,"touchstart",XC(n[5])),qn(t,"touchend",n[7])],s=!0)},p(l,[c]){a&&a.p&&(!r||c&512)&&Up(a,o,l,l[9],r?Vp(o,l[9],c,null):Wp(l[9]),null),(!r||c&2)&&(t.disabled=l[1]),(!r||c&1)&&qt(t,"outline",l[0]==="outline"),(!r||c&1)&&qt(t,"filled",l[0]==="filled"),(!r||c&1)&&qt(t,"light",l[0]==="light"),(!r||c&4)&&qt(t,"success",l[2]==="success"),(!r||c&4)&&qt(t,"warning",l[2]==="warning"),(!r||c&4)&&qt(t,"danger",l[2]==="danger"),(!r||c&8)&&qt(t,"size-small",l[3]==="small"),(!r||c&8)&&qt(t,"size-large",l[3]==="large"),(!r||c&16)&&qt(t,"round",l[4])},i(l){r||(Ie(a,l),r=!0)},o(l){$e(a,l),r=!1},d(l){l&&de(e),l&&de(t),a&&a.d(l),s=!1,po(i)}}}function t1t(n,e,t){let{$$slots:r={},$$scope:s}=e,{variant:i="outline"}=e,{disabled:o=!1}=e,{type:a="default"}=e,{size:l="medium"}=e,{round:c=!1}=e,{pressed:u=!1}=e;const h=Pc();function f(){t(8,u=!0),h("pressed",u)}function d(){u&&(t(8,u=!1),h("pressed",u))}function p(g){h("click",g)}function m(g){dM.call(this,n,g)}return n.$$set=g=>{"variant"in g&&t(0,i=g.variant),"disabled"in g&&t(1,o=g.disabled),"type"in g&&t(2,a=g.type),"size"in g&&t(3,l=g.size),"round"in g&&t(4,c=g.round),"pressed"in g&&t(8,u=g.pressed),"$$scope"in g&&t(9,s=g.$$scope)},[i,o,a,l,c,f,d,p,u,s,r,m]}let zs=class extends xn{constructor(e){super(),wn(this,e,t1t,e1t,pn,{variant:0,disabled:1,type:2,size:3,round:4,pressed:8})}};function n1t(n){let e,t,r;return{c(){e=we("input"),Z(e,"class","marcelle svelte-1mutsa0"),e.disabled=n[2],Z(e,"type",n[3]),Z(e,"placeholder",n[1]),e.value=n[0]},m(s,i){me(s,e,i),t||(r=qn(e,"input",n[4]),t=!0)},p(s,[i]){i&4&&(e.disabled=s[2]),i&8&&Z(e,"type",s[3]),i&2&&Z(e,"placeholder",s[1]),i&1&&e.value!==s[0]&&(e.value=s[0])},i:tt,o:tt,d(s){s&&de(e),t=!1,r()}}}function r1t(n,e,t){let{placeholder:r=""}=e,{disabled:s=!1}=e,{type:i="text"}=e,{value:o=null}=e;function a(l){t(0,o=l.currentTarget.value)}return n.$$set=l=>{"placeholder"in l&&t(1,r=l.placeholder),"disabled"in l&&t(2,s=l.disabled),"type"in l&&t(3,i=l.type),"value"in l&&t(0,o=l.value)},[o,r,s,i,a]}class s1t extends xn{constructor(e){super(),wn(this,e,r1t,n1t,pn,{placeholder:1,disabled:2,type:3,value:0})}}function i1t(n){let e,t,r,s,i,o,a,l;const c=n[2].default,u=Bp(c,n,n[1],null);return{c(){e=we("div"),t=we("div"),r=we("div"),s=Ye(),i=we("div"),u&&u.c(),Z(r,"class","absolute inset-0 bg-gray-500 opacity-50"),Z(t,"class","overlay svelte-1sg0y6b"),Z(i,"class","modal svelte-1sg0y6b"),Z(e,"class","modal-container svelte-1sg0y6b")},m(h,f){me(h,e,f),se(e,t),se(t,r),se(e,s),se(e,i),u&&u.m(i,null),o=!0,a||(l=[qn(r,"click",n[0]),qn(r,"keypress",XC(n[3]))],a=!0)},p(h,[f]){u&&u.p&&(!o||f&2)&&Up(u,c,h,h[1],o?Vp(c,h[1],f,null):Wp(h[1]),null)},i(h){o||(Ie(u,h),o=!0)},o(h){$e(u,h),o=!1},d(h){h&&de(e),u&&u.d(h),a=!1,po(l)}}}function o1t(n,e,t){let{$$slots:r={},$$scope:s}=e;const i=Pc();function o(){i("quit")}const a=l=>l.key==="Escape"&&o();return n.$$set=l=>{"$$scope"in l&&t(1,s=l.$$scope)},[o,s,r,a]}class Ice extends xn{constructor(e){super(),wn(this,e,o1t,i1t,pn,{quit:0})}get quit(){return this.$$.ctx[0]}}function a1t(n){return n<.5?4*n*n*n:.5*Math.pow(2*n-2,3)+1}function UV(n){const e=n-1;return e*e*e+1}function pM(n,{delay:e=0,duration:t=400,easing:r=a1t,amount:s=5,opacity:i=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.filter==="none"?"":o.filter,c=a*(1-i),[u,h]=Rxt(s);return{delay:e,duration:t,easing:r,css:(f,d)=>`opacity: ${a-c*d}; filter: ${l} blur(${d*u}${h});`}}function jq(n,{delay:e=0,duration:t=400,easing:r=UV,axis:s="y"}={}){const i=getComputedStyle(n),o=+i.opacity,a=s==="y"?"height":"width",l=parseFloat(i[a]),c=s==="y"?["top","bottom"]:["left","right"],u=c.map(y=>`${y[0].toUpperCase()}${y.slice(1)}`),h=parseFloat(i[`padding${u[0]}`]),f=parseFloat(i[`padding${u[1]}`]),d=parseFloat(i[`margin${u[0]}`]),p=parseFloat(i[`margin${u[1]}`]),m=parseFloat(i[`border${u[0]}Width`]),g=parseFloat(i[`border${u[1]}Width`]);return{delay:e,duration:t,easing:r,css:y=>`overflow: hidden;opacity: ${Math.min(y*20,1)*o};${a}: ${y*l}px;padding-${c[0]}: ${y*h}px;padding-${c[1]}: ${y*f}px;margin-${c[0]}: ${y*d}px;margin-${c[1]}: ${y*p}px;border-${c[0]}-width: ${y*m}px;border-${c[1]}-width: ${y*g}px;`}}function qq(n,{delay:e=0,duration:t=400,easing:r=UV,start:s=0,opacity:i=0}={}){const o=getComputedStyle(n),a=+o.opacity,l=o.transform==="none"?"":o.transform,c=1-s,u=a*(1-i);return{delay:e,duration:t,easing:r,css:(h,f)=>`
			transform: ${l} scale(${1-c*f});
			opacity: ${a-u*f}
		`}}function l1t(n,{from:e,to:t},r={}){const s=getComputedStyle(n),i=s.transform==="none"?"":s.transform,[o,a]=s.transformOrigin.split(" ").map(parseFloat),l=e.left+e.width*o/t.width-(t.left+o),c=e.top+e.height*a/t.height-(t.top+a),{delay:u=0,duration:h=d=>Math.sqrt(d)*120,easing:f=UV}=r;return{delay:u,duration:t0(h)?h(Math.sqrt(l*l+c*c)):h,easing:f,css:(d,p)=>{const m=p*l,g=p*c,y=d+p*e.width/t.width,b=d+p*e.height/t.height;return`transform: ${i} translate(${m}px, ${g}px) scale(${y}, ${b});`}}}function Xq(n,e,t){const r=n.slice();return r[6]=e[t].title,r[7]=e[t].message,r[8]=e[t].type,r[9]=e[t].id,r}function c1t(n){let e;return{c(){e=Fs("path"),Z(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z`)},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function u1t(n){let e;return{c(){e=Fs("path"),Z(e,"d",`M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0
                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z`)},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Kq(n,e){let t,r,s,i,o,a,l,c=e[6]+"",u,h,f,d=e[7]+"",p,m,g,y,b,x,w,S,C,k,A=tt,M,E,N;function O(X,G){if(X[8]==="default")return u1t;if(X[8]==="danger")return c1t}let R=O(e),D=R&&R(e);function z(){return e[3](e[9])}function B(...X){return e[4](e[9],...X)}return{key:n,first:null,c(){t=we("div"),r=we("div"),s=we("div"),i=Fs("svg"),D&&D.c(),o=Ye(),a=we("div"),l=we("p"),u=He(c),h=Ye(),f=we("p"),p=He(d),m=Ye(),g=we("div"),y=Fs("svg"),b=Fs("title"),x=He("Close"),w=Fs("path"),S=Ye(),Z(i,"class","notification-svg mr-4 svelte-c58nio"),Z(i,"xmlns","http://www.w3.org/2000/svg"),Z(i,"viewBox","0 0 20 20"),qt(i,"default",e[8]==="default"),qt(i,"danger",e[8]==="danger"),Z(s,"class","py-1"),Z(l,"class","my-1 font-bold"),Z(f,"class","my-1 text-sm"),Z(w,"d",`M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1
              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10
              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0
              1.698z`),Z(y,"class","notification-svg ml-4 cursor-pointer svelte-c58nio"),Z(y,"role","button"),Z(y,"xmlns","http://www.w3.org/2000/svg"),Z(y,"viewBox","0 0 20 20"),qt(y,"default",e[8]==="default"),qt(y,"danger",e[8]==="danger"),Z(r,"class","flex items-start"),Z(t,"class","notification-card svelte-c58nio"),Z(t,"role","alert"),qt(t,"default",e[8]==="default"),qt(t,"danger",e[8]==="danger"),this.first=t},m(X,G){me(X,t,G),se(t,r),se(r,s),se(s,i),D&&D.m(i,null),se(r,o),se(r,a),se(a,l),se(l,u),se(a,h),se(a,f),se(f,p),se(r,m),se(r,g),se(g,y),se(y,b),se(b,x),se(y,w),se(t,S),M=!0,E||(N=[qn(y,"click",z),qn(y,"keypress",XC(B))],E=!0)},p(X,G){e=X,R!==(R=O(e))&&(D&&D.d(1),D=R&&R(e),D&&(D.c(),D.m(i,null))),(!M||G&1)&&qt(i,"default",e[8]==="default"),(!M||G&1)&&qt(i,"danger",e[8]==="danger"),(!M||G&1)&&c!==(c=e[6]+"")&&cn(u,c),(!M||G&1)&&d!==(d=e[7]+"")&&cn(p,d),(!M||G&1)&&qt(y,"default",e[8]==="default"),(!M||G&1)&&qt(y,"danger",e[8]==="danger"),(!M||G&1)&&qt(t,"default",e[8]==="default"),(!M||G&1)&&qt(t,"danger",e[8]==="danger")},r(){k=t.getBoundingClientRect()},f(){Hxt(t),A(),xce(t,k)},a(){A(),A=Gxt(t,k,l1t,{})},i(X){M||($u(()=>{M&&(C||(C=Cv(t,pM,{amount:10},!0)),C.run(1))}),M=!0)},o(X){C||(C=Cv(t,pM,{amount:10},!1)),C.run(0),M=!1},d(X){X&&de(t),D&&D.d(),X&&C&&C.end(),E=!1,po(N)}}}function h1t(n){let e,t=[],r=new Map,s,i=n[0].slice(0,10);const o=a=>a[9];for(let a=0;a<i.length;a+=1){let l=Xq(n,i,a),c=o(l);r.set(c,t[a]=Kq(c,l))}return{c(){e=we("div");for(let a=0;a<t.length;a+=1)t[a].c();Z(e,"class","marcelle notification-container svelte-c58nio")},m(a,l){me(a,e,l);for(let c=0;c<t.length;c+=1)t[c]&&t[c].m(e,null);s=!0},p(a,[l]){if(l&3){i=a[0].slice(0,10),dr();for(let c=0;c<t.length;c+=1)t[c].r();t=Ece(t,l,o,1,a,i,r,e,Jxt,Kq,null,Xq);for(let c=0;c<t.length;c+=1)t[c].a();pr()}},i(a){if(!s){for(let l=0;l<i.length;l+=1)Ie(t[l]);s=!0}},o(a){for(let l=0;l<t.length;l+=1)$e(t[l]);s=!1},d(a){a&&de(e);for(let l=0;l<t.length;l+=1)t[l].d()}}}function f1t(n,e,t){let{notifications:r=[]}=e;function s(c){t(0,r=r.filter(u=>u.id!==c))}let i=1;function o({title:c,message:u,type:h="default",duration:f=3e3}){const d={id:i,title:c,message:u,type:h};i+=1,t(0,r=[...r,d]),f>0&&setTimeout(()=>{s(d.id)},f)}const a=c=>s(c),l=(c,u)=>u.key==="Escape"&&s(c);return n.$$set=c=>{"notifications"in c&&t(0,r=c.notifications)},[r,s,o,a,l]}class d1t extends xn{constructor(e){super(),wn(this,e,f1t,h1t,pn,{notifications:0,add:2})}get add(){return this.$$.ctx[2]}}function p1t(n){let e,t,r,s,i,o,a,l,c,u;return{c(){e=we("div"),t=we("button"),r=He("-"),s=Ye(),i=we("input"),o=Ye(),a=we("button"),l=He("+"),t.disabled=n[1],Z(t,"class","left svelte-1w23q60"),Z(i,"type","number"),Z(i,"inputmode","decimal"),i.value=n[0],i.disabled=n[1],lu(i,"width","80px"),Z(i,"class","svelte-1w23q60"),a.disabled=n[1],Z(a,"class","right svelte-1w23q60"),Z(e,"class","flex")},m(h,f){me(h,e,f),se(e,t),se(t,r),se(e,s),se(e,i),se(e,o),se(e,a),se(a,l),c||(u=[qn(t,"click",n[3]),qn(i,"change",n[2]),qn(a,"click",n[4])],c=!0)},p(h,[f]){f&2&&(t.disabled=h[1]),f&1&&i.value!==h[0]&&(i.value=h[0]),f&2&&(i.disabled=h[1]),f&2&&(a.disabled=h[1])},i:tt,o:tt,d(h){h&&de(e),c=!1,po(u)}}}function m1t(n,e,t){let{disabled:r=!1}=e,{value:s}=e;function i(l){const c=l.target,u=parseFloat(c.value);Number.isNaN(u)?c.value=s.toString():t(0,s=u)}const o=()=>{t(0,s-=1)},a=()=>{t(0,s+=1)};return n.$$set=l=>{"disabled"in l&&t(1,r=l.disabled),"value"in l&&t(0,s=l.value)},[s,r,i,o,a]}class g1t extends xn{constructor(e){super(),wn(this,e,m1t,p1t,pn,{disabled:1,value:0})}}function Yq(n,e,t){const r=n.slice();return r[12]=e[t],r[14]=t,r}function Zq(n){let e,t,r,s,i,o,a,l,c,u=n[0],h=[];for(let f=0;f<u.length;f+=1)h[f]=Jq(Yq(n,u,f));return{c(){e=we("div");for(let f=0;f<h.length;f+=1)h[f].c();t=Ye(),r=we("button"),s=He("-"),i=Ye(),o=we("button"),a=He("+"),r.disabled=n[1],Z(r,"class","left svelte-1w23q60"),o.disabled=n[1],Z(o,"class","right svelte-1w23q60"),lu(o,"border-left","none"),Z(e,"class","flex items-center")},m(f,d){me(f,e,d);for(let p=0;p<h.length;p+=1)h[p]&&h[p].m(e,null);se(e,t),se(e,r),se(r,s),se(e,i),se(e,o),se(o,a),l||(c=[qn(r,"click",n[10]),qn(o,"click",n[11])],l=!0)},p(f,d){if(d&31){u=f[0];let p;for(p=0;p<u.length;p+=1){const m=Yq(f,u,p);h[p]?h[p].p(m,d):(h[p]=Jq(m),h[p].c(),h[p].m(e,t))}for(;p<h.length;p+=1)h[p].d(1);h.length=u.length}d&2&&(r.disabled=f[1]),d&2&&(o.disabled=f[1])},d(f){f&&de(e),qs(h,f),l=!1,po(c)}}}function Jq(n){let e,t,r,s,i,o,a,l,c,u,h;function f(){return n[7](n[14])}function d(...m){return n[8](n[14],...m)}function p(){return n[9](n[14])}return{c(){e=we("div"),t=we("button"),r=He("-"),s=Ye(),i=we("input"),a=Ye(),l=we("button"),c=He("+"),t.disabled=n[1],Z(t,"class","left svelte-1w23q60"),Z(i,"type","number"),Z(i,"inputmode","decimal"),i.value=o=n[12],i.disabled=n[1],lu(i,"width","80px"),Z(i,"class","svelte-1w23q60"),l.disabled=n[1],Z(l,"class","right svelte-1w23q60"),Z(e,"class","flex mr-2")},m(m,g){me(m,e,g),se(e,t),se(t,r),se(e,s),se(e,i),se(e,a),se(e,l),se(l,c),u||(h=[qn(t,"click",f),qn(i,"change",d),qn(l,"click",p)],u=!0)},p(m,g){n=m,g&2&&(t.disabled=n[1]),g&1&&o!==(o=n[12])&&i.value!==o&&(i.value=o),g&2&&(i.disabled=n[1]),g&2&&(l.disabled=n[1])},d(m){m&&de(e),u=!1,po(h)}}}function y1t(n){let e=n[0]&&Array.isArray(n[0]),t,r=e&&Zq(n);return{c(){r&&r.c(),t=mo()},m(s,i){r&&r.m(s,i),me(s,t,i)},p(s,[i]){i&1&&(e=s[0]&&Array.isArray(s[0])),e?r?r.p(s,i):(r=Zq(s),r.c(),r.m(t.parentNode,t)):r&&(r.d(1),r=null)},i:tt,o:tt,d(s){r&&r.d(s),s&&de(t)}}}function b1t(n,e,t){let{disabled:r=!1}=e,{value:s}=e;function i(m,g){const y=m.target,b=parseFloat(y.value);Number.isNaN(b)?y.value=s[g].toString():t(0,s[g]=b,s)}function o(m){const g=s.slice();g[m]-=1,t(0,s=g)}function a(m){const g=s.slice();g[m]+=1,t(0,s=g)}function l(){const m=s.slice();m.push(m.length?m[m.length-1]:0),t(0,s=m)}function c(){t(0,s=s.slice(0,s.length-1))}const u=m=>o(m),h=(m,g)=>i(g,m),f=m=>a(m),d=()=>c(),p=()=>l();return n.$$set=m=>{"disabled"in m&&t(1,r=m.disabled),"value"in m&&t(0,s=m.value)},[s,r,i,o,a,l,c,u,h,f,d,p]}let v1t=class extends xn{constructor(e){super(),wn(this,e,b1t,y1t,pn,{disabled:1,value:0})}};function Qq(n,e,t){const r=n.slice();return r[7]=e[t],r}function w1t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"d","M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z"),Z(e,"class","fill-current inline-block h-5 w-5"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"viewBox","0 0 20 20")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function e9(n){let e,t,r,s,i,o=n[0],a=[];for(let l=0;l<o.length;l+=1)a[l]=t9(Qq(n,o,l));return{c(){e=we("div"),t=we("div"),r=we("div");for(let l=0;l<a.length;l+=1)a[l].c();Z(r,"class","py-1"),Z(r,"role","menu"),Z(r,"aria-orientation","vertical"),Z(r,"aria-labelledby","options-menu"),Z(t,"class","origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"),Z(e,"class","origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50"),qt(e,"hidden",!1)},m(l,c){me(l,e,c),se(e,t),se(t,r);for(let u=0;u<a.length;u+=1)a[u]&&a[u].m(r,null);i=!0},p(l,c){if(c&9){o=l[0];let u;for(u=0;u<o.length;u+=1){const h=Qq(l,o,u);a[u]?a[u].p(h,c):(a[u]=t9(h),a[u].c(),a[u].m(r,null))}for(;u<a.length;u+=1)a[u].d(1);a.length=o.length}},i(l){i||($u(()=>{i&&(s||(s=Cv(e,jq,{duration:100},!0)),s.run(1))}),i=!0)},o(l){s||(s=Cv(e,jq,{duration:100},!1)),s.run(0),i=!1},d(l){l&&de(e),qs(a,l),l&&s&&s.end()}}}function t9(n){let e,t=n[7].text+"",r,s,i,o;function a(){return n[5](n[7])}return{c(){e=we("button"),r=He(t),s=Ye(),Z(e,"class","text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer")},m(l,c){me(l,e,c),se(e,r),se(e,s),i||(o=qn(e,"click",a),i=!0)},p(l,c){n=l,c&1&&t!==(t=n[7].text+"")&&cn(r,t)},d(l){l&&de(e),i=!1,o()}}}function x1t(n){let e,t,r,s,i,o,a;r=new zs({props:{size:"small",round:!0,$$slots:{default:[w1t]},$$scope:{ctx:n}}}),r.$on("click",n[2]);let l=n[1]&&e9(n);return{c(){e=Ye(),t=we("div"),It(r.$$.fragment),s=Ye(),l&&l.c(),Z(t,"class","relative")},m(c,u){me(c,e,u),me(c,t,u),kt(r,t,null),se(t,s),l&&l.m(t,null),i=!0,o||(a=qn(document.body,"click",n[4]),o=!0)},p(c,[u]){const h={};u&1024&&(h.$$scope={dirty:u,ctx:c}),r.$set(h),c[1]?l?(l.p(c,u),u&2&&Ie(l,1)):(l=e9(c),l.c(),Ie(l,1),l.m(t,null)):l&&(dr(),$e(l,1,1,()=>{l=null}),pr())},i(c){i||(Ie(r.$$.fragment,c),Ie(l),i=!0)},o(c){$e(r.$$.fragment,c),$e(l),i=!1},d(c){c&&de(e),c&&de(t),Tt(r),l&&l.d(),o=!1,a()}}}function _1t(n,e,t){let{actions:r=[]}=e;const s=Pc();let i=!1;function o(u){u.stopPropagation(),i?t(1,i=!1):t(1,i=!0)}function a(u){s("select",u)}const l=()=>{t(1,i=!1)},c=u=>a(u.code);return n.$$set=u=>{"actions"in u&&t(0,r=u.actions)},[r,i,o,a,l,c]}class S1t extends xn{constructor(e){super(),wn(this,e,_1t,x1t,pn,{actions:0})}}function C1t(n){let e,t;return{c(){e=we("div"),Z(e,"class","progress-line svelte-dee3y"),Z(e,"style",t=n[0]>=0?`--bar-mr: ${100-Math.floor(n[0]*100)}%;`:"--bar-mr: 0px"),qt(e,"thin",n[2]),qt(e,"indeterminate",n[0]===void 0||n[0]===null||n[0]<0),qt(e,"gray",n[1]==="idle"),qt(e,"green",n[1]==="success"),qt(e,"red",n[1]==="danger")},m(r,s){me(r,e,s)},p(r,[s]){s&1&&t!==(t=r[0]>=0?`--bar-mr: ${100-Math.floor(r[0]*100)}%;`:"--bar-mr: 0px")&&Z(e,"style",t),s&4&&qt(e,"thin",r[2]),s&1&&qt(e,"indeterminate",r[0]===void 0||r[0]===null||r[0]<0),s&2&&qt(e,"gray",r[1]==="idle"),s&2&&qt(e,"green",r[1]==="success"),s&2&&qt(e,"red",r[1]==="danger")},i:tt,o:tt,d(r){r&&de(e)}}}function k1t(n,e,t){let{progress:r}=e,{type:s="default"}=e,{thin:i=!1}=e;return n.$$set=o=>{"progress"in o&&t(0,r=o.progress),"type"in o&&t(1,s=o.type),"thin"in o&&t(2,i=o.thin)},[r,s,i]}class Ace extends xn{constructor(e){super(),wn(this,e,k1t,C1t,pn,{progress:0,type:1,thin:2})}}function n9(n,e,t){const r=n.slice();return r[7]=e[t],r}function r9(n){let e,t;return{c(){e=we("option"),t=He(n[2]),e.__value="",e.value=e.__value,e.disabled=!0,Z(e,"class","svelte-g3sqa4")},m(r,s){me(r,e,s),se(e,t)},p(r,s){s&4&&cn(t,r[2])},d(r){r&&de(e)}}}function s9(n){let e,t=n[7]+"",r,s;return{c(){e=we("option"),r=He(t),e.__value=s=n[7],e.value=e.__value,Z(e,"class","svelte-g3sqa4")},m(i,o){me(i,e,o),se(e,r)},p(i,o){o&2&&t!==(t=i[7]+"")&&cn(r,t),o&2&&s!==(s=i[7])&&(e.__value=s,e.value=e.__value)},d(i){i&&de(e)}}}function T1t(n){let e,t,r,s,i,o,a,l=n[2]&&r9(n),c=n[1],u=[];for(let h=0;h<c.length;h+=1)u[h]=s9(n9(n,c,h));return{c(){e=we("div"),t=we("select"),l&&l.c(),r=mo();for(let h=0;h<u.length;h+=1)u[h].c();s=Ye(),i=we("div"),i.innerHTML='<svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"></path></svg>',Z(t,"class","svelte-g3sqa4"),n[0]===void 0&&$u(()=>n[5].call(t)),qt(t,"small",n[3]==="small"),Z(i,"class","pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700"),Z(e,"class","select-container svelte-g3sqa4")},m(h,f){me(h,e,f),se(e,t),l&&l.m(t,null),se(t,r);for(let d=0;d<u.length;d+=1)u[d]&&u[d].m(t,null);Gq(t,n[0],!0),se(e,s),se(e,i),o||(a=[qn(t,"change",n[5]),qn(t,"change",n[6])],o=!0)},p(h,[f]){if(h[2]?l?l.p(h,f):(l=r9(h),l.c(),l.m(t,r)):l&&(l.d(1),l=null),f&2){c=h[1];let d;for(d=0;d<c.length;d+=1){const p=n9(h,c,d);u[d]?u[d].p(p,f):(u[d]=s9(p),u[d].c(),u[d].m(t,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}f&3&&Gq(t,h[0]),f&8&&qt(t,"small",h[3]==="small")},i:tt,o:tt,d(h){h&&de(e),l&&l.d(),qs(u,h),o=!1,po(a)}}}function E1t(n,e,t){let{options:r}=e,{value:s=""}=e,{placeholder:i="Select an Option"}=e,{size:o="normal"}=e;const a=Pc();function l(){s=zxt(this),t(0,s),t(1,r)}const c=u=>a("change",u.currentTarget.value);return n.$$set=u=>{"options"in u&&t(1,r=u.options),"value"in u&&t(0,s=u.value),"placeholder"in u&&t(2,i=u.placeholder),"size"in u&&t(3,o=u.size)},[s,r,i,o,a,l,c]}let Mce=class extends xn{constructor(e){super(),wn(this,e,E1t,T1t,pn,{options:1,value:0,placeholder:2,size:3})}};function I1t(n){let e;return{c(){e=we("span"),e.innerHTML='<span class="spinner svelte-zvuq20"><span class="dot1 svelte-zvuq20"></span>  <span class="dot2 svelte-zvuq20"></span></span>',Z(e,"class","spinner-container svelte-zvuq20")},m(t,r){me(t,e,r)},p:tt,i:tt,o:tt,d(t){t&&de(e)}}}class Nce extends xn{constructor(e){super(),wn(this,e,null,I1t,pn,{})}}function A1t(n){let e,t,r,s,i,o,a,l,c;return{c(){e=we("label"),t=we("input"),r=Ye(),s=we("span"),s.innerHTML=`<span class="track svelte-smv03c"></span> 
    <span class="thumb svelte-smv03c"></span>`,i=Ye(),o=we("span"),a=He(n[1]),Z(t,"type","checkbox"),t.disabled=n[2],Z(t,"class","svelte-smv03c"),Z(s,"class","switch svelte-smv03c"),Z(o,"class","ml-2 cursor-pointer"),Z(e,"class","marcelle")},m(u,h){me(u,e,h),se(e,t),t.checked=n[0],se(e,r),se(e,s),se(e,i),se(e,o),se(o,a),l||(c=qn(t,"change",n[3]),l=!0)},p(u,[h]){h&4&&(t.disabled=u[2]),h&1&&(t.checked=u[0]),h&2&&cn(a,u[1])},i:tt,o:tt,d(u){u&&de(e),l=!1,c()}}}function M1t(n,e,t){let{text:r=""}=e,{checked:s=!1}=e,{disabled:i=!1}=e;function o(){s=this.checked,t(0,s)}return n.$$set=a=>{"text"in a&&t(1,r=a.text),"checked"in a&&t(0,s=a.checked),"disabled"in a&&t(2,i=a.disabled)},[s,r,i,o]}class N1t extends xn{constructor(e){super(),wn(this,e,M1t,A1t,pn,{text:1,checked:0,disabled:2})}}const lb=[];function f_(n,e=tt){let t;const r=new Set;function s(a){if(pn(n,a)&&(n=a,t)){const l=!lb.length;for(const c of r)c[1](),lb.push(c,n);if(l){for(let c=0;c<lb.length;c+=2)lb[c][0](lb[c+1]);lb.length=0}}}function i(a){s(a(n))}function o(a,l=tt){const c=[a,l];return r.add(c),r.size===1&&(t=e(s)||tt),a(n),()=>{r.delete(c),r.size===0&&t&&(t(),t=null)}}return{set:s,update:i,subscribe:o}}function $1t(n){let e,t;const r=n[1].default,s=Bp(r,n,n[0],null);return{c(){e=we("div"),s&&s.c(),Z(e,"class","tabs")},m(i,o){me(i,e,o),s&&s.m(e,null),t=!0},p(i,[o]){s&&s.p&&(!t||o&1)&&Up(s,r,i,i[0],t?Vp(r,i[0],o,null):Wp(i[0]),null)},i(i){t||(Ie(s,i),t=!0)},o(i){$e(s,i),t=!1},d(i){i&&de(e),s&&s.d(i)}}}const WV={};function R1t(n,e,t){let{$$slots:r={},$$scope:s}=e;const i=[],o=[],a=f_(null),l=f_(null);return jxt(WV,{registerTab:c=>{i.push(c),a.update(u=>u||c),$g(()=>{const u=i.indexOf(c);i.splice(u,1),a.update(h=>h===c?i[u]||i[i.length-1]:h)})},registerPanel:c=>{o.push(c),l.update(u=>u||c),$g(()=>{const u=o.indexOf(c);o.splice(u,1),l.update(h=>h===c?o[u]||o[o.length-1]:h)})},selectTab:c=>{const u=i.indexOf(c);a.set(c),l.set(o[u])},selectedTab:a,selectedPanel:l}),n.$$set=c=>{"$$scope"in c&&t(0,s=c.$$scope)},[s,r]}class P1t extends xn{constructor(e){super(),wn(this,e,R1t,$1t,pn,{})}}function D1t(n){let e,t,r,s;const i=n[5].default,o=Bp(i,n,n[4],null);return{c(){e=we("div"),o&&o.c(),Z(e,"class","text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-d0yt2a"),Z(e,"role","tab"),qt(e,"selected",n[0]===n[1])},m(a,l){me(a,e,l),o&&o.m(e,null),t=!0,r||(s=qn(e,"click",n[6]),r=!0)},p(a,[l]){o&&o.p&&(!t||l&16)&&Up(o,i,a,a[4],t?Vp(i,a[4],l,null):Wp(a[4]),null),(!t||l&3)&&qt(e,"selected",a[0]===a[1])},i(a){t||(Ie(o,a),t=!0)},o(a){$e(o,a),t=!1},d(a){a&&de(e),o&&o.d(a),r=!1,s()}}}function O1t(n,e,t){let r,{$$slots:s={},$$scope:i}=e;const o={},{registerTab:a,selectTab:l,selectedTab:c}=Sce(WV);LV(n,c,h=>t(0,r=h)),a(o);const u=()=>l(o);return n.$$set=h=>{"$$scope"in h&&t(4,i=h.$$scope)},[r,o,l,c,i,s,u]}class IE extends xn{constructor(e){super(),wn(this,e,O1t,D1t,pn,{})}}function i9(n){let e;const t=n[4].default,r=Bp(t,n,n[3],null);return{c(){r&&r.c()},m(s,i){r&&r.m(s,i),e=!0},p(s,i){r&&r.p&&(!e||i&8)&&Up(r,t,s,s[3],e?Vp(t,s[3],i,null):Wp(s[3]),null)},i(s){e||(Ie(r,s),e=!0)},o(s){$e(r,s),e=!1},d(s){r&&r.d(s)}}}function F1t(n){let e,t,r=n[0]===n[1]&&i9(n);return{c(){r&&r.c(),e=mo()},m(s,i){r&&r.m(s,i),me(s,e,i),t=!0},p(s,[i]){s[0]===s[1]?r?(r.p(s,i),i&1&&Ie(r,1)):(r=i9(s),r.c(),Ie(r,1),r.m(e.parentNode,e)):r&&(dr(),$e(r,1,1,()=>{r=null}),pr())},i(s){t||(Ie(r),t=!0)},o(s){$e(r),t=!1},d(s){r&&r.d(s),s&&de(e)}}}function L1t(n,e,t){let r,{$$slots:s={},$$scope:i}=e;const o={},{registerPanel:a,selectedPanel:l}=Sce(WV);return LV(n,l,c=>t(0,r=c)),a(o),n.$$set=c=>{"$$scope"in c&&t(3,i=c.$$scope)},[r,o,l,i,s]}class AE extends xn{constructor(e){super(),wn(this,e,L1t,F1t,pn,{})}}function z1t(n){let e;return{c(){e=He(n[1])},m(t,r){me(t,e,r)},p(t,r){r&2&&cn(e,t[1])},i:tt,o:tt,d(t){t&&de(e)}}}function B1t(n){let e=n[1].toPrecision(2)+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=r[1].toPrecision(2)+"")&&cn(t,e)},i:tt,o:tt,d(r){r&&de(t)}}}function V1t(n){let e,t=fL(n[1]).join(", ")+"",r,s;return{c(){e=He("Array("),r=He(t),s=He(")")},m(i,o){me(i,e,o),me(i,r,o),me(i,s,o)},p(i,o){o&2&&t!==(t=fL(i[1]).join(", ")+"")&&cn(r,t)},i:tt,o:tt,d(i){i&&de(e),i&&de(r),i&&de(s)}}}function U1t(n){let e=n[3](n[1])+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=r[3](r[1])+"")&&cn(t,e)},i:tt,o:tt,d(r){r&&de(t)}}}function W1t(n){let e;const t=n[4].default,r=Bp(t,n,n[7],null);return{c(){r&&r.c()},m(s,i){r&&r.m(s,i),e=!0},p(s,i){r&&r.p&&(!e||i&128)&&Up(r,t,s,s[7],e?Vp(t,s[7],i,null):Wp(s[7]),null)},i(s){e||(Ie(r,s),e=!0)},o(s){$e(r,s),e=!1},d(s){r&&r.d(s)}}}function G1t(n){let e,t;return e=new zs({props:{size:"small",$$slots:{default:[q1t]},$$scope:{ctx:n}}}),e.$on("click",n[6]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&130&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function H1t(n){let e,t=n[1].text+"",r,s,i;return{c(){e=we("sl-button"),r=He(t),Cb(e,"type","text"),Cb(e,"size","small")},m(o,a){me(o,e,a),se(e,r),s||(i=qn(e,"click",n[5]),s=!0)},p(o,a){a&2&&t!==(t=o[1].text+"")&&cn(r,t)},i:tt,o:tt,d(o){o&&de(e),s=!1,i()}}}function j1t(n){let e,t;return{c(){e=we("img"),Z(e,"alt","thumbnail"),Sv(e.src,t=n[1])||Z(e,"src",t),Z(e,"width","30"),Z(e,"height","30"),Z(e,"class","rounded-md")},m(r,s){me(r,e,s)},p(r,s){s&2&&!Sv(e.src,t=r[1])&&Z(e,"src",t)},i:tt,o:tt,d(r){r&&de(e)}}}function q1t(n){let e;return{c(){e=He(n[1])},m(t,r){me(t,e,r)},p(t,r){r&2&&cn(e,t[1])},d(t){t&&de(e)}}}function X1t(n){let e,t,r,s;const i=[j1t,H1t,G1t,W1t,U1t,V1t,B1t,z1t],o=[];function a(l,c){return l[0]==="image"?0:l[0]==="link"?1:l[0]==="action"?2:l[0]==="slot"?3:l[0]==="date"?4:l[0]==="array"?5:typeof l[1]=="number"?6:7}return t=a(n),r=o[t]=i[t](n),{c(){e=we("td"),r.c(),Z(e,"class","svelte-fe0rg4")},m(l,c){me(l,e,c),o[t].m(e,null),s=!0},p(l,[c]){let u=t;t=a(l),t===u?o[t].p(l,c):(dr(),$e(o[u],1,1,()=>{o[u]=null}),pr(),r=o[t],r?r.p(l,c):(r=o[t]=i[t](l),r.c()),Ie(r,1),r.m(e,null))},i(l){s||(Ie(r),s=!0)},o(l){$e(r),s=!1},d(l){l&&de(e),o[t].d()}}}function fL(n){return Array.isArray(n)?n.length>0&&Array.isArray(n[0])?[n.length,...fL(n[0])]:[n.length]:[]}function K1t(n,e,t){let{$$slots:r={},$$scope:s}=e,{type:i="generic"}=e,{value:o=null}=e;const a=Pc();function l(h){try{return Yje(Date.parse(h),{includeSeconds:!0,addSuffix:!0})}catch(f){return console.log("Date Parsing Error",h,f),h}}const c=()=>{console.log("GOTO:",o.href)},u=()=>a("action",o);return n.$$set=h=>{"type"in h&&t(0,i=h.type),"value"in h&&t(1,o=h.value),"$$scope"in h&&t(7,s=h.$$scope)},[i,o,a,l,r,c,u,s]}class $ce extends xn{constructor(e){super(),wn(this,e,K1t,X1t,pn,{type:0,value:1})}}function o9(n){let e,t,r,s;const i=[Z1t,Y1t],o=[];function a(l,c){return l[2]?0:1}return e=a(n),t=o[e]=i[e](n),{c(){t.c(),r=mo()},m(l,c){o[e].m(l,c),me(l,r,c),s=!0},p(l,c){let u=e;e=a(l),e===u?o[e].p(l,c):(dr(),$e(o[u],1,1,()=>{o[u]=null}),pr(),t=o[e],t?t.p(l,c):(t=o[e]=i[e](l),t.c()),Ie(t,1),t.m(r.parentNode,r))},i(l){s||(Ie(t),s=!0)},o(l){$e(t),s=!1},d(l){o[e].d(l),l&&de(r)}}}function Y1t(n){let e,t;return e=new zs({props:{round:!0,size:"small",$$slots:{default:[J1t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&64&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Z1t(n){let e,t;return e=new zs({props:{round:!0,size:"small",$$slots:{default:[Q1t]},$$scope:{ctx:n}}}),e.$on("click",n[3]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&64&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function J1t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M16 17l-4 4m0 0l-4-4m4 4V3"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-6 w-6"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function Q1t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M8 7l4-4m0 0l4 4m-4-4v18"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-6 w-6"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function e_t(n){let e,t,r,s,i,o,a=n[1]&&o9(n);return{c(){e=we("th"),t=we("span"),r=we("span"),s=He(n[0]),i=Ye(),a&&a.c(),lu(r,"margin-top","0.5rem"),lu(r,"margin-bottom","0.5rem"),lu(t,"display","flex"),lu(t,"justify-content","space-between"),lu(t,"align-items","center"),Z(e,"class","svelte-1310j1m")},m(l,c){me(l,e,c),se(e,t),se(t,r),se(r,s),se(t,i),a&&a.m(t,null),o=!0},p(l,[c]){(!o||c&1)&&cn(s,l[0]),l[1]?a?(a.p(l,c),c&2&&Ie(a,1)):(a=o9(l),a.c(),Ie(a,1),a.m(t,null)):a&&(dr(),$e(a,1,1,()=>{a=null}),pr())},i(l){o||(Ie(a),o=!0)},o(l){$e(a),o=!1},d(l){l&&de(e),a&&a.d()}}}function t_t(n,e,t){let{name:r="name"}=e,{sortable:s=!1}=e,{sorting:i={col:"",ascending:!0}}=e;const o=Pc();let a=!0;function l(){t(2,a=!a),o("sort",{col:r,ascending:a})}return n.$$set=c=>{"name"in c&&t(0,r=c.name),"sortable"in c&&t(1,s=c.sortable),"sorting"in c&&t(4,i=c.sorting)},n.$$.update=()=>{n.$$.dirty&17&&i.col===r&&t(2,a=i.ascending)},[r,s,a,l,i]}class n_t extends xn{constructor(e){super(),wn(this,e,t_t,e_t,pn,{name:0,sortable:1,sorting:4})}}function a9(n,e,t){const r=n.slice();return r[10]=e[t].name,r[11]=e[t].multiple,r[12]=e[t].confirm,r}function r_t(n){let e=n[10]+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=r[10]+"")&&cn(t,e)},d(r){r&&de(t)}}}function l9(n){let e,t;function r(){return n[7](n[10],n[12])}return e=new zs({props:{size:"small",disabled:n[11]===!1&&n[0].length>1,type:n[10]==="delete"?"danger":"default",$$slots:{default:[r_t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){It(e.$$.fragment)},m(s,i){kt(e,s,i),t=!0},p(s,i){n=s;const o={};i&3&&(o.disabled=n[11]===!1&&n[0].length>1),i&2&&(o.type=n[10]==="delete"?"danger":"default"),i&32770&&(o.$$scope={dirty:i,ctx:n}),e.$set(o)},i(s){t||(Ie(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){Tt(e,s)}}}function c9(n){let e,t;return e=new Ice({props:{$$slots:{default:[o_t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&32780&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function s_t(n){let e;return{c(){e=He("Cancel")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function i_t(n){let e;return{c(){e=He("Confirm")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function o_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d;return l=new zs({props:{type:"danger",$$slots:{default:[s_t]},$$scope:{ctx:n}}}),l.$on("click",n[8]),f=new zs({props:{variant:"filled",$$slots:{default:[i_t]},$$scope:{ctx:n}}}),f.$on("click",n[4]),{c(){e=we("div"),t=we("p"),r=He("Do you want to "),s=He(n[2]),i=He(" the selected items?"),o=Ye(),a=we("div"),It(l.$$.fragment),c=Ye(),u=we("span"),h=Ye(),It(f.$$.fragment),Z(u,"class","w-2"),Z(a,"class","w-full flex justify-end"),Z(e,"class","p-8")},m(p,m){me(p,e,m),se(e,t),se(t,r),se(t,s),se(t,i),se(e,o),se(e,a),kt(l,a,null),se(a,c),se(a,u),se(a,h),kt(f,a,null),d=!0},p(p,m){(!d||m&4)&&cn(s,p[2]);const g={};m&32768&&(g.$$scope={dirty:m,ctx:p}),l.$set(g);const y={};m&32768&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(Ie(l.$$.fragment,p),Ie(f.$$.fragment,p),d=!0)},o(p){$e(l.$$.fragment,p),$e(f.$$.fragment,p),d=!1},d(p){p&&de(e),Tt(l),Tt(f)}}}function a_t(n){let e,t,r,s,i=n[1],o=[];for(let c=0;c<i.length;c+=1)o[c]=l9(a9(n,i,c));const a=c=>$e(o[c],1,1,()=>{o[c]=null});let l=n[3]&&c9(n);return{c(){e=we("div");for(let c=0;c<o.length;c+=1)o[c].c();t=Ye(),l&&l.c(),r=mo(),Z(e,"class","actions")},m(c,u){me(c,e,u);for(let h=0;h<o.length;h+=1)o[h]&&o[h].m(e,null);me(c,t,u),l&&l.m(c,u),me(c,r,u),s=!0},p(c,[u]){if(u&35){i=c[1];let h;for(h=0;h<i.length;h+=1){const f=a9(c,i,h);o[h]?(o[h].p(f,u),Ie(o[h],1)):(o[h]=l9(f),o[h].c(),Ie(o[h],1),o[h].m(e,null))}for(dr(),h=i.length;h<o.length;h+=1)a(h);pr()}c[3]?l?(l.p(c,u),u&8&&Ie(l,1)):(l=c9(c),l.c(),Ie(l,1),l.m(r.parentNode,r)):l&&(dr(),$e(l,1,1,()=>{l=null}),pr())},i(c){if(!s){for(let u=0;u<i.length;u+=1)Ie(o[u]);Ie(l),s=!0}},o(c){o=o.filter(Boolean);for(let u=0;u<o.length;u+=1)$e(o[u]);$e(l),s=!1},d(c){c&&de(e),qs(o,c),c&&de(t),l&&l.d(c),c&&de(r)}}}function l_t(n,e,t){let{provider:r}=e,{actions:s}=e,{selected:i}=e;const o=Pc();let a="",l=!1;async function c(){if(a==="delete")for(const d of i)await r.delete(d);else o("action",[a,i]);t(3,l=!1),t(0,i=[]),o("selected",i)}function u(d,p){t(2,a=d),!(!a||i.length===0)&&(p?t(3,l=!0):c())}const h=(d,p)=>u(d,p),f=()=>{t(3,l=!1)};return n.$$set=d=>{"provider"in d&&t(6,r=d.provider),"actions"in d&&t(1,s=d.actions),"selected"in d&&t(0,i=d.selected)},[i,s,a,l,c,u,r,h,f]}class c_t extends xn{constructor(e){super(),wn(this,e,l_t,a_t,pn,{provider:6,actions:1,selected:0})}}function u9(n){let e,t,r;function s(o){n[11](o)}let i={provider:n[1],actions:n[2]};return n[0]!==void 0&&(i.selected=n[0]),e=new c_t({props:i}),hi.push(()=>Zf(e,"selected",s)),e.$on("selected",n[12]),e.$on("action",n[13]),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.provider=o[1]),a&4&&(l.actions=o[2]),!t&&a&1&&(t=!0,l.selected=o[0],Yf(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function u_t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M15 19l-7-7 7-7"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-3 w-3"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function h_t(n){let e,t;return{c(){e=Fs("svg"),t=Fs("path"),Z(t,"stroke-linecap","round"),Z(t,"stroke-linejoin","round"),Z(t,"stroke-width","2"),Z(t,"d","M9 5l7 7-7 7"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"class","h-3 w-3"),Z(e,"fill","none"),Z(e,"viewBox","0 0 24 24"),Z(e,"stroke","currentColor")},m(r,s){me(r,e,s),se(e,t)},p:tt,d(r){r&&de(e)}}}function f_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b,x,w,S,C,k,A,M,E=n[2].length>0&&n[0].length>0&&u9(n);return l=new Mce({props:{size:"small",options:["10","20","50","all"],value:n[5].toString()}}),l.$on("change",n[14]),y=new zs({props:{round:!0,disabled:n[3]===1,$$slots:{default:[u_t]},$$scope:{ctx:n}}}),y.$on("click",n[15]),C=new zs({props:{round:!0,disabled:n[3]===n[6],$$slots:{default:[h_t]},$$scope:{ctx:n}}}),C.$on("click",n[17]),{c(){e=we("div"),t=we("div"),E&&E.c(),r=Ye(),s=we("div"),i=we("div"),o=He(`Items per page:
			`),a=we("div"),It(l.$$.fragment),c=Ye(),u=we("div"),h=He(n[7]),f=He("-"),d=He(n[8]),p=He(" of "),m=He(n[4]),g=Ye(),It(y.$$.fragment),b=Ye(),x=we("input"),S=Ye(),It(C.$$.fragment),Z(t,"class","actions"),Z(a,"class","w-12 ml-2"),Z(i,"class","flex items-center mx-4"),Z(u,"class","mx-3"),Z(x,"class","marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50"),x.value=w=n[3].toString(),Z(s,"class","flex items-center"),Z(e,"class","table-footer svelte-13k2ee6")},m(N,O){me(N,e,O),se(e,t),E&&E.m(t,null),se(e,r),se(e,s),se(s,i),se(i,o),se(i,a),kt(l,a,null),se(s,c),se(s,u),se(u,h),se(u,f),se(u,d),se(u,p),se(u,m),se(s,g),kt(y,s,null),se(s,b),se(s,x),se(s,S),kt(C,s,null),k=!0,A||(M=qn(x,"blur",n[16]),A=!0)},p(N,[O]){N[2].length>0&&N[0].length>0?E?(E.p(N,O),O&5&&Ie(E,1)):(E=u9(N),E.c(),Ie(E,1),E.m(t,null)):E&&(dr(),$e(E,1,1,()=>{E=null}),pr());const R={};O&32&&(R.value=N[5].toString()),l.$set(R),(!k||O&128)&&cn(h,N[7]),(!k||O&256)&&cn(d,N[8]),(!k||O&16)&&cn(m,N[4]);const D={};O&8&&(D.disabled=N[3]===1),O&262144&&(D.$$scope={dirty:O,ctx:N}),y.$set(D),(!k||O&8&&w!==(w=N[3].toString())&&x.value!==w)&&(x.value=w);const z={};O&72&&(z.disabled=N[3]===N[6]),O&262144&&(z.$$scope={dirty:O,ctx:N}),C.$set(z)},i(N){k||(Ie(E),Ie(l.$$.fragment,N),Ie(y.$$.fragment,N),Ie(C.$$.fragment,N),k=!0)},o(N){$e(E),$e(l.$$.fragment,N),$e(y.$$.fragment,N),$e(C.$$.fragment,N),k=!1},d(N){N&&de(e),E&&E.d(),Tt(l),Tt(y),Tt(C),A=!1,M()}}}function d_t(n,e,t){let r,{provider:s}=e,{actions:i}=e,{selected:o}=e,a=1,l=1,c=0,u=0,h=0,f=()=>{};function d(S){t(3,a=S),s.page(S)}function p(S){o=S,t(0,o)}function m(S){dM.call(this,n,S)}function g(S){dM.call(this,n,S)}const y=({detail:S})=>{const C=S==="all"?h:parseInt(S);s.paginate(C),t(5,r=C)},b=()=>{d(a-1)},x=S=>{let C=parseInt(S.currentTarget.value);isNaN(C)||d(Math.max(1,Math.min(l,C)))},w=()=>{d(a+1)};return n.$$set=S=>{"provider"in S&&t(1,s=S.provider),"actions"in S&&t(2,i=S.actions),"selected"in S&&t(0,o=S.selected)},n.$$.update=()=>{n.$$.dirty&2&&t(5,r=s.options.itemsPerPage),n.$$.dirty&1082&&(f(),t(10,f=s.total.subscribe(S=>{S===void 0||S===0?(t(6,l=1),t(7,c=0),t(8,u=0),t(4,h=0)):(t(6,l=Math.ceil(h/r)),t(7,c=(a-1)*r+1),t(8,u=Math.min(h||0,a*r)),t(4,h=S))})))},[o,s,i,a,h,r,l,c,u,d,f,p,m,g,y,b,x,w]}class p_t extends xn{constructor(e){super(),wn(this,e,d_t,f_t,pn,{provider:1,actions:2,selected:0})}}function h9(n,e,t){const r=n.slice();return r[22]=e[t],r[24]=t,r}function f9(n,e,t){const r=n.slice();return r[25]=e[t].type,r[26]=e[t].name,r}function d9(n,e,t){const r=n.slice();return r[26]=e[t].name,r[29]=e[t].sortable,r}function p9(n){let e,t,r,s,i,o,a,l;return{c(){e=we("div"),t=we("sl-alert"),r=we("sl-icon"),s=Ye(),i=we("strong"),i.textContent="Table Data Error",o=we("br"),a=Ye(),l=He(n[9]),Cb(r,"slot","icon"),Cb(r,"name","check2-circle"),Cb(t,"type","danger"),Cb(t,"open",""),Z(e,"class","service-error")},m(c,u){me(c,e,u),se(e,t),se(t,r),se(t,s),se(t,i),se(t,o),se(t,a),se(t,l)},p(c,u){u[0]&512&&cn(l,c[9])},d(c){c&&de(e)}}}function m9(n){let e,t=!n[4]&&g9(n);return{c(){e=we("th"),t&&t.c(),Z(e,"class","svelte-12gp9na")},m(r,s){me(r,e,s),t&&t.m(e,null)},p(r,s){r[4]?t&&(t.d(1),t=null):t?t.p(r,s):(t=g9(r),t.c(),t.m(e,null))},d(r){r&&de(e),t&&t.d()}}}function g9(n){let e,t,r,s;return{c(){e=we("input"),Z(e,"type","checkbox"),e.checked=t=n[6].length>0&&n[6].length===n[10].length},m(i,o){me(i,e,o),r||(s=qn(e,"click",n[12]),r=!0)},p(i,o){o[0]&1088&&t!==(t=i[6].length>0&&i[6].length===i[10].length)&&(e.checked=t)},d(i){i&&de(e),r=!1,s()}}}function y9(n){let e,t;return e=new n_t({props:{name:n[26],sortable:n[29],sorting:n[7]}}),e.$on("sort",n[11]),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s[0]&1&&(i.name=r[26]),s[0]&1&&(i.sortable=r[29]),s[0]&128&&(i.sorting=r[7]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function b9(n){let e,t;return e=new $ce({props:{type:"slot",$$slots:{default:[m_t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s[0]&64|s[1]&2&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function m_t(n){let e,t,r,s;function i(...o){return n[16](n[24],...o)}return{c(){e=we("input"),Z(e,"type","checkbox"),e.checked=t=n[6].includes(n[24])},m(o,a){me(o,e,a),r||(s=qn(e,"click",i),r=!0)},p(o,a){n=o,a[0]&64&&t!==(t=n[6].includes(n[24]))&&(e.checked=t)},d(o){o&&de(e),r=!1,s()}}}function v9(n){let e,t;function r(...s){return n[17](n[24],...s)}return e=new $ce({props:{type:n[25],value:n[22][n[26]]}}),e.$on("action",r),{c(){It(e.$$.fragment)},m(s,i){kt(e,s,i),t=!0},p(s,i){n=s;const o={};i[0]&1&&(o.type=n[25]),i[0]&1025&&(o.value=n[22][n[26]]),e.$set(o)},i(s){t||(Ie(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){Tt(e,s)}}}function w9(n){let e,t,r,s,i=n[3]&&b9(n),o=n[0],a=[];for(let c=0;c<o.length;c+=1)a[c]=v9(f9(n,o,c));const l=c=>$e(a[c],1,1,()=>{a[c]=null});return{c(){e=we("tr"),i&&i.c(),t=Ye();for(let c=0;c<a.length;c+=1)a[c].c();r=Ye(),Z(e,"class","svelte-12gp9na")},m(c,u){me(c,e,u),i&&i.m(e,null),se(e,t);for(let h=0;h<a.length;h+=1)a[h]&&a[h].m(e,null);se(e,r),s=!0},p(c,u){if(c[3]?i?(i.p(c,u),u[0]&8&&Ie(i,1)):(i=b9(c),i.c(),Ie(i,1),i.m(e,t)):i&&(dr(),$e(i,1,1,()=>{i=null}),pr()),u[0]&17409){o=c[0];let h;for(h=0;h<o.length;h+=1){const f=f9(c,o,h);a[h]?(a[h].p(f,u),Ie(a[h],1)):(a[h]=v9(f),a[h].c(),Ie(a[h],1),a[h].m(e,r))}for(dr(),h=o.length;h<a.length;h+=1)l(h);pr()}},i(c){if(!s){Ie(i);for(let u=0;u<o.length;u+=1)Ie(a[u]);s=!0}},o(c){$e(i),a=a.filter(Boolean);for(let u=0;u<a.length;u+=1)$e(a[u]);s=!1},d(c){c&&de(e),i&&i.d(),qs(a,c)}}}function g_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d=n[9]&&p9(n),p=n[3]&&m9(n),m=n[0],g=[];for(let k=0;k<m.length;k+=1)g[k]=y9(d9(n,m,k));const y=k=>$e(g[k],1,1,()=>{g[k]=null});let b=n[10],x=[];for(let k=0;k<b.length;k+=1)x[k]=w9(h9(n,b,k));const w=k=>$e(x[k],1,1,()=>{x[k]=null});function S(k){n[18](k)}let C={provider:n[1],actions:n[2]};return n[6]!==void 0&&(C.selected=n[6]),u=new p_t({props:C}),hi.push(()=>Zf(u,"selected",S)),u.$on("action",n[19]),{c(){d&&d.c(),e=Ye(),t=we("div"),r=we("table"),s=we("thead"),i=we("tr"),p&&p.c(),o=Ye();for(let k=0;k<g.length;k+=1)g[k].c();a=Ye(),l=we("tbody");for(let k=0;k<x.length;k+=1)x[k].c();c=Ye(),It(u.$$.fragment),Z(i,"class","svelte-12gp9na"),Z(s,"class","svelte-12gp9na"),Z(l,"class","svelte-12gp9na"),Z(r,"class","svelte-12gp9na"),Z(t,"class","marcelle table-container svelte-12gp9na")},m(k,A){d&&d.m(k,A),me(k,e,A),me(k,t,A),se(t,r),se(r,s),se(s,i),p&&p.m(i,null),se(i,o);for(let M=0;M<g.length;M+=1)g[M]&&g[M].m(i,null);se(r,a),se(r,l);for(let M=0;M<x.length;M+=1)x[M]&&x[M].m(l,null);se(t,c),kt(u,t,null),f=!0},p(k,A){if(k[9]?d?d.p(k,A):(d=p9(k),d.c(),d.m(e.parentNode,e)):d&&(d.d(1),d=null),k[3]?p?p.p(k,A):(p=m9(k),p.c(),p.m(i,o)):p&&(p.d(1),p=null),A[0]&2177){m=k[0];let E;for(E=0;E<m.length;E+=1){const N=d9(k,m,E);g[E]?(g[E].p(N,A),Ie(g[E],1)):(g[E]=y9(N),g[E].c(),Ie(g[E],1),g[E].m(i,null))}for(dr(),E=m.length;E<g.length;E+=1)y(E);pr()}if(A[0]&25673){b=k[10];let E;for(E=0;E<b.length;E+=1){const N=h9(k,b,E);x[E]?(x[E].p(N,A),Ie(x[E],1)):(x[E]=w9(N),x[E].c(),Ie(x[E],1),x[E].m(l,null))}for(dr(),E=b.length;E<x.length;E+=1)w(E);pr()}const M={};A[0]&2&&(M.provider=k[1]),A[0]&4&&(M.actions=k[2]),!h&&A[0]&64&&(h=!0,M.selected=k[6],Yf(()=>h=!1)),u.$set(M)},i(k){if(!f){for(let A=0;A<m.length;A+=1)Ie(g[A]);for(let A=0;A<b.length;A+=1)Ie(x[A]);Ie(u.$$.fragment,k),f=!0}},o(k){g=g.filter(Boolean);for(let A=0;A<g.length;A+=1)$e(g[A]);x=x.filter(Boolean);for(let A=0;A<x.length;A+=1)$e(x[A]);$e(u.$$.fragment,k),f=!1},d(k){d&&d.d(k),k&&de(e),k&&de(t),p&&p.d(),qs(g,k),qs(x,k),Tt(u)}}}function y_t(n,e,t){let r,s,i,o=tt,a=()=>(o(),o=os(s,R=>t(9,i=R)),s),l,c=tt,u=()=>(c(),c=os(r,R=>t(10,l=R)),r);n.$$.on_destroy.push(()=>o()),n.$$.on_destroy.push(()=>c());let{columns:h}=e,{provider:f}=e,{actions:d=[]}=e,{selectable:p=!0}=e,{singleSelection:m=!1}=e,{selection:g=[]}=e,y=[];const b=Pc();let x={col:"",ascending:!0};function w({detail:R}){t(7,x=R),f.sort(R)}async function S(){t(15,g=await Promise.all(y.map(f.get.bind(f)))),b("selection",g)}function C(){y.length===h_(r).length?t(6,y=[]):t(6,y=h_(r).map((R,D)=>D)),S()}function k(R,D){m?(t(6,y=D.currentTarget.checked?[R]:[]),S()):D.currentTarget.checked?y.includes(R)||(t(6,y=y.concat([R])),S()):(t(6,y=y.filter(z=>z!==R)),S())}async function A([R,D]){const z=Array.isArray(D)?await Promise.all(D.map(f.get.bind(f))):await f.get(D);b(R,z)}const M=(R,D)=>k(R,D),E=(R,{detail:D})=>{A([D,R])};function N(R){y=R,t(6,y),t(15,g),t(5,r),t(1,f)}const O=({detail:R})=>A(R);return n.$$set=R=>{"columns"in R&&t(0,h=R.columns),"provider"in R&&t(1,f=R.provider),"actions"in R&&t(2,d=R.actions),"selectable"in R&&t(3,p=R.selectable),"singleSelection"in R&&t(4,m=R.singleSelection),"selection"in R&&t(15,g=R.selection)},n.$$.update=()=>{n.$$.dirty[0]&2&&u(t(5,r=f.data)),n.$$.dirty[0]&2&&a(t(8,s=f.error)),n.$$.dirty[0]&32800&&t(6,y=g.map(R=>h_(r).indexOf(R)))},[h,f,d,p,m,r,y,x,s,i,l,w,C,k,A,g,M,E,N,O]}class Rce extends xn{constructor(e){super(),wn(this,e,y_t,g_t,pn,{columns:0,provider:1,actions:2,selectable:3,singleSelection:4,selection:15},null,[-1,-1])}}function b_t(n){let e,t;const r=n[1].default,s=Bp(r,n,n[0],null);return{c(){e=we("div"),s&&s.c(),Z(e,"class","flex border-solid border-0 border-b border-gray-200 mb-2")},m(i,o){me(i,e,o),s&&s.m(e,null),t=!0},p(i,[o]){s&&s.p&&(!t||o&1)&&Up(s,r,i,i[0],t?Vp(r,i[0],o,null):Wp(i[0]),null)},i(i){t||(Ie(s,i),t=!0)},o(i){$e(s,i),t=!1},d(i){i&&de(e),s&&s.d(i)}}}function v_t(n,e,t){let{$$slots:r={},$$scope:s}=e;return n.$$set=i=>{"$$scope"in i&&t(0,s=i.$$scope)},[s,r]}class w_t extends xn{constructor(e){super(),wn(this,e,v_t,b_t,pn,{})}}const x9={itemsPerPage:10};class Pce{constructor(e=x9){Mt(this,"options");Mt(this,"data",f_([]));Mt(this,"total",f_(0));Mt(this,"error",f_(null));this.options={...x9,...e}}paginate(e){this.options.itemsPerPage=e,this.update()}async get(e){const t=h_(this.data);return e>=0&&e<t.length?t[e]:null}}class x_t extends Pce{constructor({data:t,...r}){super(r);Mt(this,"rawData");Mt(this,"currentPage",1);this.rawData=t,this.total.set(t.length),this.data.set(this.rawData.slice(0,this.options.itemsPerPage))}async update(){this.page(this.currentPage)}async page(t){this.data.set(this.rawData.slice((t-1)*this.options.itemsPerPage,Math.min(t*this.options.itemsPerPage,this.rawData.length))),this.currentPage=t}async sort(t){this.rawData.sort((r,s)=>r[t.col]>s[t.col]?t.ascending?1:-1:r[t.col]<s[t.col]?t.ascending?-1:1:0),this.page(this.currentPage)}async delete(t){return this.rawData.splice(t,1),this.page(this.currentPage),null}}class __t extends Pce{constructor({service:t,columns:r,transform:s,...i}){super(i);Mt(this,"service");Mt(this,"query");Mt(this,"transform");this.service=t,this.transform=s||{},this.query={$sort:{updatedAt:-1},$limit:this.options.itemsPerPage},r&&(this.query.$select=r.map(o=>o.name).concat(["id"])),this.update(),this.service.on("created",this.update.bind(this)),this.service.on("patched",this.update.bind(this)),this.service.on("updated",this.update.bind(this)),this.service.on("removed",this.update.bind(this))}paginate(t){super.paginate(t),this.query.$limit=this.options.itemsPerPage,this.update()}async update(){try{const t=await this.service.find({query:this.query}),r=t.data.map((s,i)=>{const o=Object.entries(this.transform).map(([a,l])=>{try{return{[a]:l(s,i)}}catch{return{[a]:"transform error"}}}).reduce((a,l)=>({...a,...l}),{});return{...s,...o}});this.data.set(r),this.total.set(t.total),this.error.set(null)}catch(t){this.data.set([]),this.total.set(0),this.error.set(t)}}async page(t){this.query.$skip=(t-1)*this.query.$limit,this.update()}async sort(t){const{col:r,ascending:s}=t;r?this.query.$sort={[r]:s?1:-1}:delete this.query.$sort,this.update()}async delete(t){const r=h_(this.data)[t];return await this.service.remove(r.id),this.update(),r}}function _9(n){let e,t,r;return t=new Ace({props:{progress:n[2],thin:!0}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","absolute top-0 left-0 right-0")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&4&&(o.progress=s[2]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function S9(n){let e,t;return e=new Nce({}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function S_t(n){let e,t,r,s,i,o,a,l=n[2]!==!1&&_9(n),c=n[1]&&S9();const u=n[4].default,h=Bp(u,n,n[3],null);return{c(){e=we("div"),l&&l.c(),t=Ye(),r=we("span"),s=He(n[0]),i=Ye(),c&&c.c(),o=Ye(),h&&h.c(),Z(r,"class","card-title"),Z(e,"class","card-container svelte-xnhseh")},m(f,d){me(f,e,d),l&&l.m(e,null),se(e,t),se(e,r),se(r,s),se(e,i),c&&c.m(e,null),se(e,o),h&&h.m(e,null),a=!0},p(f,[d]){f[2]!==!1?l?(l.p(f,d),d&4&&Ie(l,1)):(l=_9(f),l.c(),Ie(l,1),l.m(e,t)):l&&(dr(),$e(l,1,1,()=>{l=null}),pr()),(!a||d&1)&&cn(s,f[0]),f[1]?c?d&2&&Ie(c,1):(c=S9(),c.c(),Ie(c,1),c.m(e,o)):c&&(dr(),$e(c,1,1,()=>{c=null}),pr()),h&&h.p&&(!a||d&8)&&Up(h,u,f,f[3],a?Vp(u,f[3],d,null):Wp(f[3]),null)},i(f){a||(Ie(l),Ie(c),Ie(h,f),a=!0)},o(f){$e(l),$e(c),$e(h,f),a=!1},d(f){f&&de(e),l&&l.d(),c&&c.d(),h&&h.d(f)}}}function C_t(n,e,t){let{$$slots:r={},$$scope:s}=e,{title:i}=e,{loading:o=!1}=e,{progress:a=!1}=e;return n.$$set=l=>{"title"in l&&t(0,i=l.title),"loading"in l&&t(1,o=l.loading),"progress"in l&&t(2,a=l.progress),"$$scope"in l&&t(3,s=l.$$scope)},[i,o,a,s,r]}class ra extends xn{constructor(e){super(),wn(this,e,C_t,S_t,pn,{title:0,loading:1,progress:2})}}let m1,ME;function mM({title:n,message:e,duration:t=3e3,type:r="default"}){m1||(m1=document.createElement("div"),m1.id="notification-container",document.body.appendChild(m1),ME=new d1t({target:m1})),ME==null||ME.add({title:n,message:e,duration:t,type:r})}function Dn(n,e,t,r){var s=arguments.length,i=s<3?e:r===null?r=Object.getOwnPropertyDescriptor(e,t):r,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")i=Reflect.decorate(n,e,t,r);else for(var a=n.length-1;a>=0;a--)(o=n[a])&&(i=(s<3?o(i):s>3?o(e,t,i):o(e,t))||i);return s>3&&i&&Object.defineProperty(e,t,i),i}function $t(n,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?n!==e||!r:!e.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(n):r?r.value:e.get(n)}function ir(n,e,t,r,s){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!s)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?n!==e||!s:!e.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?s.call(n,t):s?s.value=t:e.set(n,t),t}function zb(){}var Tm,Em,oI;function k_t(n){}const C9=C8e();function T_t(n){return n&&typeof n=="object"&&n.run!==void 0}function GV(n){return n&&typeof n=="object"&&n.run!==void 0&&n.id!==void 0}class mt{constructor(e,t=void 0){this.id=mt.nextId++,this.subscribers=[],this.value=void 0,this.ready=!1,Tm.set(this,void 0),Em.set(this,!1),oI.set(this,void 0),ir(this,Tm,!!t,"f");const[r,s]=vH(),[i,o]=vH();this.stopStream=r,this.set=l=>{this.value=l,i(l)};let a;GV(e)?(a=e,t===void 0&&ir(this,Tm,e.holding,"f"),e.holding&&(this.value=e.value)):T_t(e)?a=e:(a=pH(()=>this.value,BD(e)),this.value=e),this.stream=Q9e(mH(this.runListeners.bind(this),bH(s,gH(a,o))))}get(){return this.value}get holding(){return $t(this,Tm,"f")}run(e,t){return this.stream.run(e,t)}runListeners(e){this.value=e;for(const t of this.subscribers)t(e)}subscribe(e=k_t,t=zb){$t(this,Tm,"f")&&$t(this,Em,"f")&&e(this.value);const r=s=>{t(),e(s)};return this.subscribers.push(r),$t(this,Em,"f")||this.start(),()=>{const s=this.subscribers.indexOf(r);s!==-1&&this.subscribers.splice(s,1)}}async start(){return $t(this,Em,"f")||(mt.numActive++,X8e(this.stream,C9).then(()=>{mt.numActive--}),ir(this,Em,!0,"f"),ir(this,oI,new Promise((e,t)=>{BN({run:()=>{this.ready=!0,e()},error(r){t(r)},dispose(){}},C9)}),"f")),$t(this,oI,"f")}stop(){this.stopStream(void 0),ir(this,Em,!1,"f")}hold(e=!0){return ir(this,Tm,e,"f"),this}thru(e){return new mt(e(this))}startWith(e){const t=new mt(i7e(e,this));return this.holding&&(t.value=e),t}continueWith(e){const t=new mt(c7e(e,this));return this.holding&&(t.value=this.value),t}map(e){const t=new mt(pH(e,this));return this.holding&&(t.value=e(this.value)),t}constant(e){const t=new mt(o7e(e,this));return this.holding&&(t.value=e),t}tap(e){const t=new mt(mH(e,this));return this.holding&&(t.value=this.value),t}ap(e){const t=new mt(a7e(e,this));return this.holding&&e.holding&&(t.value=e.get()(this.value)),t}scan(e,t){const r=new mt(s7e(e,t,this));return this.holding&&(r.value=t),r}loop(e,t){return new mt(r7e(e,t,this))}withItems(e){return new mt(g7e(e,this))}zipItems(e,t){return new mt(m7e(e,t,this))}switchLatest(){return new mt(v9e(this))}join(){return new mt(cee(this))}chain(e){return new mt(l7e(e,this))}concatMap(e){return new mt(u7e(e,this))}mergeConcurrently(e){return new mt(h7e(e,this))}mergeMapConcurrently(e,t){return new mt(f7e(e,t,this))}merge(e){const t=new mt(gH(e,this));return this.holding&&(t.value=this.value),t}combine(e,t){const r=new mt(d7e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}zip(e,t){const r=new mt(y7e(e,t,this));return this.holding&&(r.value=e(t.value,this.value)),r}resample(e){return new mt(yH(this,e))}sample(e){return new mt(yH(e,this))}snapshot(e,t){return new mt(p7e(e,t,this))}filter(e){const t=new mt(b7e(e,this));return this.holding&&e(this.value)&&(t.value=this.value),t}skipRepeats(){const e=new mt(C9e(this));return this.holding&&(e.value=this.value),e}skipRepeatsWith(e){return new mt(v7e(e,this))}slice(e,t){return new mt(_7e(e,t,this))}take(e){return new mt(w7e(e,this))}skip(e){return new mt(x7e(e,this))}takeWhile(e){return new mt(S7e(e,this))}skipWhile(e){return new mt(C7e(e,this))}skipAfter(e){return new mt(k7e(e,this))}until(e){return new mt(bH(e,this))}since(e){return new mt(T7e(e,this))}during(e){return new mt(E7e(e,this))}delay(e){return new mt(I7e(e,this))}withLocalTime(e){return new mt(n7e(e,this))}throttle(e){return new mt(A7e(e,this))}debounce(e){return new mt(M7e(e,this))}awaitPromises(){return new mt(G9e(this))}recoverWith(e){return new mt(N7e(e,this))}static empty(){return new mt(Ki())}static never(){return new mt(P_())}static now(e){return new mt(BD(e))}static at(e,t){return new mt(nee(e,t))}static periodic(e){return new mt(j8e(e))}static throwError(e){return new mt(K9e(e))}}Tm=new WeakMap,Em=new WeakMap,oI=new WeakMap;mt.nextId=0;mt.numActive=0;var yc;(function(n){n[n.Debug=0]="Debug",n[n.Info=1]="Info",n[n.Warning=2]="Warning",n[n.Error=3]="Error"})(yc||(yc={}));const L1=new mt(P_()),ga={log(...n){console.log(...n),L1.set([yc.Info,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},debug(...n){L1.set([yc.Debug,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},info(...n){this.log(...n)},warning(...n){L1.set([yc.Warning,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])},error(...n){console.error(...n),L1.set([yc.Error,n.filter(e=>e!==void 0).map(e=>e.toString()).join(" ")])}};function E_t(){return L1}function Ln(n,e,t){const r=t.value;return t.value=function(...i){try{return r.apply(this,i)}catch(o){return ga.error(o),mM({title:o.name,message:o.message,type:"danger"}),o}},t}class Sp extends Error{constructor(e){super(e),this.name="Training Error"}}function Ta(n,{duration:e=3e3}={}){ga.error(`${n.name}: ${n.message}`,n),mM({title:n.name,message:n.message,type:"danger",duration:e})}function Dce(n,e){return async function*(){let t=0;for await(const r of n())e(r,t++)&&(yield await r)}}function qP(n,e){return async function*(){let t=0;for await(const r of n())yield await e(r,t++)}}function I_t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){yield*Dce(n,(t,r)=>r>=e)()}}function A_t(n,e){if(e<0)throw Error("Negative count is not supported, use await and sync iterator instead.");return async function*(){let t=e;for await(const r of n()){if(t--===0)return;yield await r}}}function XP(n,e){return async function*(){yield*await n(),yield*await e}}async function M_t(n,e){let t=0;for await(const r of n())e(r,t++)}async function N_t(n){const e=[];for await(const t of n())e.push(t);return e}function $_t(n,e){return async function*(){const t=e()[Symbol.asyncIterator]();for await(const r of n()){const s=await t.next();if(s.done)return;yield[r,s.value]}}}async function R_t(n,e,t){let[r,s]=[-1,t];for await(const i of n())s=++r===0&&t===void 0?i:e(s,i,r);if(t===void 0&&r===-1)throw new Error("Sequence contains no elements.");return s}function P_t(n){return typeof n[Symbol.iterator]=="function"}function D_t(n){return typeof n[Symbol.asyncIterator]=="function"}class dl{constructor(e){this.source=e}[Symbol.asyncIterator](){return this.source()[Symbol.asyncIterator]()}entries(){return new dl(qP(this.source,(e,t)=>[t,e]))}keys(){return new dl(qP(this.source,(e,t)=>t))}values(){return new dl(this.source)}forEach(e){return M_t(this.source,e)}concat(e){return P_t(e)?new dl(XP(this.source,async function*(t){yield*t}(e))):D_t(e)?new dl(XP(this.source,e)):new dl(XP(this.source,async function*(t){yield t}(e)))}reduce(e,t){return R_t(this.source,e,t)}filter(e){return new dl(Dce(this.source,e))}take(e){return new dl(A_t(this.source,e))}skip(e){return new dl(I_t(this.source,e))}map(e){return new dl(qP(this.source,e))}zip(e){return new dl($_t(this.source,e))}toArray(){return N_t(this.source)}}function KP(n){return n&&typeof n=="object"&&!Array.isArray(n)}function yl(n,...e){if(!e.length)return n;const t=e.shift(),r={...n};if(KP(n)&&KP(t))for(const s in t)KP(t[s])?(r[s]||Object.assign(r,{[s]:{}}),r[s]=yl(r[s],t[s])):Object.assign(r,{[s]:t[s]});return yl(r,...e)}window&&(window.onerror=n=>{typeof n=="string"&&mM({title:"An error occurred",message:n,type:"danger"})},window.addEventListener("unhandledrejection",n=>{mM({title:"An error occurred",message:n.reason,type:"danger"})}));let O_t=0;class Ia{constructor(){this.id=`component-${String(O_t++).padStart(3,"0")}`,this.$$={streams:[],app:void 0},F7e(this)}destroy(){var e;(e=this.$$.app)===null||e===void 0||e.$destroy(),this.$$.app=void 0}start(){this.$$.streams=Object.entries(this).filter(([e,t])=>e[0]==="$"&&GV(t)).map(([,e])=>(e.start(),e))}stop(){for(const e of this.$$.streams)e.stop()}dispose(){this.destroy(),this.stop()}}let YP=~~(Math.random()*16777215);const ZP=parseInt((Math.random()*16777215).toString(),10);function F_t(){const n=~~(Date.now()/1e3),e=Math.floor(Math.random()*1e5);YP=(YP+1)%16777215;const t=YP,r=new Uint8Array(12);return r[3]=n&255,r[2]=n>>8&255,r[1]=n>>16&255,r[0]=n>>24&255,r[6]=ZP&255,r[5]=ZP>>8&255,r[4]=ZP>>16&255,r[8]=e&255,r[7]=e>>8&255,r[11]=t&255,r[10]=t>>8&255,r[9]=t>>16&255,r.reduce((s,i)=>s+`0${i.toString(16)}`.slice(-2),"")}const Im=document.createElement("canvas"),cb=Im.getContext("2d"),g1=new Image;function k9(n){return new Promise((e,t)=>{n?(g1.addEventListener("load",()=>{Im.width=g1.width,Im.height=g1.height,cb==null||cb.drawImage(g1,0,0,Im.width,Im.height),e(cb==null?void 0:cb.getImageData(0,0,Im.width,Im.height))},!1),g1.src=n):t()})}function L_t(n){const{data:e,service:t}=n;return n.data={[t.id]:F_t(),...e},n}function vm(n){const{result:e,params:t}=n;if(e){if(e._id)e.id=e._id,delete e._id;else if(e.total&&Array.isArray(e.data))for(const[r,s]of e.data.entries())s._id&&(e.data[r].id=e.data[r]._id,delete e.data[r]._id)}else t&&t.query&&(t.query.id&&(n.params.query._id=n.params.query.id,delete n.params.query.id),t.query.$select&&t.query.$select.includes("id")&&!t.query.$select.includes("_id")&&n.params.query.$select.push("_id"));return n}function z_t(n){return n.data||(n.data={}),n.data.createdAt=new Date,n.data.updatedAt=n.data.createdAt,n}function T9(n){return!n.data||!n.data.createdAt||(n.data.updatedAt=new Date),n}function B_t(n,e){return t=>{const{data:r}=t;return t.data={[n]:e,...r},t}}function y1(n,e){return t=>(t.params=t.params||{},t.params.query=t.params.query||{},t.params.query[n]=e,t)}const aI=document.createElement("canvas"),V_t=aI.getContext("2d");async function U_t(n){const{data:e}=n;for(const[t,r]of Object.entries(e))if(r instanceof ImageData){const s=r.width,i=r.height;aI.width=s,aI.height=i,V_t.putImageData(r,0,0),n.data[t]=aI.toDataURL("image/jpeg")}return n}async function E9(n){if(!n.result)return n;const{result:e}=n,t=r=>r&&typeof r=="string"&&r.slice(0,22)==="data:image/jpeg;base64";if(e._id)for(const[r,s]of Object.entries(e).filter(([i])=>i!=="thumbnail"))t(s)&&(e[r]=await k9(s));else if(e.total&&Array.isArray(e.data))for(const[r,s]of e.data.entries())for(const[i,o]of Object.entries(s).filter(([a])=>a!=="thumbnail"))t(o)&&(e.data[r][i]=await k9(o));return n}async function W_t(n){var e,t;if(!(!((t=(e=n.params)===null||e===void 0?void 0:e.query)===null||t===void 0)&&t.$distinct)||n.type!=="before"||n.method!=="find")return n;const{$distinct:r,...s}=n.params.query;s.$select=[r],s.$skip=0;let i=1;const o=new Set;for(;s.$skip<i;){const a=await n.service.find({query:s});for(const l of a.data)o.add(l[r]);s.$skip+=a.limit,i=a.total}return n.result=Array.from(o),n}function G_t(n){let e;return{c(){e=He("Register")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function H_t(n){let e;return{c(){e=He("Log In")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function I9(n){let e,t,r,s,i,o,a,l,c;return{c(){e=we("div"),t=we("span"),t.innerHTML='<i class="fas fa-bell"></i>',r=Ye(),s=we("span"),i=we("b"),i.textContent="Login Error",o=Ye(),a=He(n[1]),l=Ye(),c=we("button"),c.innerHTML="<span>×</span>",Z(t,"class","text-xl inline-block mr-5 align-middle"),Z(i,"class","capitalize"),Z(s,"class","inline-block align-middle mr-8"),Z(c,"class","absolute bg-transparent text-2xl font-semibold leading-none right-0 top-0 mt-4 mr-6 outline-none focus:outline-none"),Z(e,"class","text-white px-6 py-4 border-0 rounded relative mb-4 bg-red-500")},m(u,h){me(u,e,h),se(e,t),se(e,r),se(e,s),se(s,i),se(s,o),se(s,a),se(e,l),se(e,c)},p(u,h){h&2&&cn(a,u[1])},d(u){u&&de(e)}}}function j_t(n){let e;return{c(){e=He("Register")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function q_t(n){let e;return{c(){e=He("Log In")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function X_t(n){let e,t,r,s;return{c(){e=He(`Already have an account?
        `),t=we("button"),t.textContent="Log In",Z(t,"class","text-blue-500")},m(i,o){me(i,e,o),me(i,t,o),r||(s=qn(t,"click",n[2]),r=!0)},p:tt,d(i){i&&de(e),i&&de(t),r=!1,s()}}}function K_t(n){let e,t,r,s;return{c(){e=He(`Don't have an account?
        `),t=we("button"),t.textContent="Register Here",Z(t,"class","text-blue-500")},m(i,o){me(i,e,o),me(i,t,o),r||(s=qn(t,"click",n[2]),r=!0)},p:tt,d(i){i&&de(e),i&&de(t),r=!1,s()}}}function Y_t(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g,y,b;function x(R,D){return R[0]==="login"?H_t:G_t}let w=x(n),S=w(n),C=n[1]&&I9(n);function k(R,D){return R[0]==="login"?q_t:j_t}let A=k(n),M=A(n);function E(R,D){return R[0]==="login"?K_t:X_t}let N=E(n),O=N(n);return{c(){e=we("div"),t=we("div"),r=we("h2"),S.c(),s=Ye(),i=we("p"),i.textContent="This Marcelle application requires authentication.",o=Ye(),C&&C.c(),a=Ye(),l=we("form"),c=we("div"),c.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Email</label> 
        <input type="email" name="email" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Email" style="transition: all 0.15s ease 0s;"/>`,u=Ye(),h=we("div"),h.innerHTML=`<label class="block uppercase text-gray-700 text-xs font-bold mb-2" for="grid-password">Password</label> 
        <input type="password" name="password" class="bg-gray-200 appearance-none border-2 border-gray-200 rounded w-full py-2 px-4 text-gray-700 leading-tight focus:outline-none focus:bg-white focus:border-purple-500" placeholder="Password" style="transition: all 0.15s ease 0s;"/>`,f=Ye(),d=we("div"),p=we("button"),M.c(),m=Ye(),g=we("p"),O.c(),Z(r,"class","text-xl"),Z(i,"class","text-gray-600"),Z(t,"class","p-4 text-center"),Z(c,"class","relative w-full mb-3"),Z(h,"class","relative w-full mb-3"),Z(p,"class","bg-gray-900 text-white active:bg-gray-700 text-sm font-bold uppercase px-6 py-3 rounded shadow hover:shadow-lg outline-none focus:outline-none mr-1 mb-1 w-full"),Z(p,"type","submit"),lu(p,"transition","all 0.15s ease 0s"),Z(d,"class","text-center mt-6"),Z(g,"class","my-4"),Z(e,"class","marcelle p-12")},m(R,D){me(R,e,D),se(e,t),se(t,r),S.m(r,null),se(t,s),se(t,i),se(e,o),C&&C.m(e,null),se(e,a),se(e,l),se(l,c),se(l,u),se(l,h),se(l,f),se(l,d),se(d,p),M.m(p,null),se(e,m),se(e,g),O.m(g,null),y||(b=qn(l,"submit",XC(n[7])),y=!0)},p(R,D){w!==(w=x(R))&&(S.d(1),S=w(R),S&&(S.c(),S.m(r,null))),R[1]?C?C.p(R,D):(C=I9(R),C.c(),C.m(e,a)):C&&(C.d(1),C=null),A!==(A=k(R))&&(M.d(1),M=A(R),M&&(M.c(),M.m(p,null))),N===(N=E(R))&&O?O.p(R,D):(O.d(1),O=N(R),O&&(O.c(),O.m(g,null)))},d(R){R&&de(e),S.d(),C&&C.d(),M.d(),O.d(),y=!1,b()}}}function Z_t(n){let e,t;return e=new Ice({props:{$$slots:{default:[Y_t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&515&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function J_t(n,e,t){const r=Pc();let{dataStore:s}=e,{mode:i="login"}=e,o;function a(){t(0,i=i==="login"?"register":"login")}function l(f){r("terminate",f)}async function c(f){const d=new FormData(f.target);try{const p=await s.login(d.get("email"),d.get("password"));l(p)}catch(p){t(1,o=p)}}async function u(f){const d=new FormData(f.target);try{const p=await s.signup(d.get("email"),d.get("password"));l(p)}catch{l(null)}}const h=f=>i==="login"?c(f):u(f);return n.$$set=f=>{"dataStore"in f&&t(5,s=f.dataStore),"mode"in f&&t(0,i=f.mode)},[i,o,a,c,u,s,l,h]}class Q_t extends xn{constructor(e){super(),wn(this,e,J_t,Z_t,pn,{dataStore:5,mode:0,terminate:6})}get terminate(){return this.$$.ctx[6]}}class kb extends dl{constructor(e,t={}){super(async function*(){const r={query:{},skip:0,take:-1,...t},s=r.take;let i=0,o=[];const a={...r.query,$skip:r.skip,$limit:10};for(;;)try{if(s>0&&i>=s)return;if(i++,o.length>0)yield o.shift();else{const l=await e.find({query:a});if(a.$skip=l.skip+l.limit,o=l.data,o.length>0)yield o.shift();else return}}catch(l){throw l.message=`Error thrown while iterating through a service: ${l.message}`,l}}),this.service=e,this.params={query:{},skip:0,take:-1,...t}}skip(e){return new kb(this.service,{...this.params,skip:e})}take(e){return new kb(this.service,{...this.params,take:e})}select(e){const t=QYe.cloneDeep(this.params);return t.query.$select=e,new kb(this.service,t)}query(e){return new kb(this.service,yl(this.params,{query:e}))}}function eSt(n){return new kb(n)}var lI,z1,B1,bb,V1;function tSt(n){try{new URL(n)}catch{return!1}return!0}var gl;(function(n){n[n.Memory=0]="Memory",n[n.LocalStorage=1]="LocalStorage",n[n.Remote=2]="Remote"})(gl||(gl={}));class Oce{constructor(e="memory"){if(this.requiresAuth=!1,this.apiPrefix="",this.$services=new mt([],!0),lI.set(this,void 0),z1.set(this,void 0),B1.set(this,Promise.resolve()),bb.set(this,!1),V1.set(this,zb),this.feathers=wYe(),this.location=e,tSt(e)){this.backend=gl.Remote;const t=new URL(e),r=t.host;this.apiPrefix=t.pathname.replace(/\/$/,"");const s=AKe(r,{transports:["websocket"],reconnectionAttempts:5,path:this.apiPrefix+"/socket.io"});this.feathers.configure(AYe(s,{timeout:15e3})),ir(this,lI,new Promise(i=>{this.feathers.io.on("init",({auth:o})=>{this.requiresAuth=o,o&&this.feathers.configure(XKe({path:`${this.apiPrefix}/authentication`})),i()})}),"f")}else if(e==="localStorage"){this.backend=gl.LocalStorage;const t=r=>JYe({storage:window.localStorage,name:r,id:"_id",multi:!0,paginate:{default:100,max:200}});ir(this,V1,r=>{this.feathers.use(`/${r}`,t(r))},"f")}else if(e==="memory")this.backend=gl.Memory,ir(this,V1,t=>{this.feathers.use(`/${t}`,KYe({id:"_id",paginate:{default:100,max:200}}))},"f");else throw new Error(`Cannot process backend location '${e}'`);this.setupAppHooks()}async connect(){return this.backend!==gl.Remote?{email:null}:($t(this,z1,"f")||(ga.log(`Connecting to backend ${this.location}...`),ir(this,z1,new Promise((e,t)=>{this.feathers.io.on("connect",()=>{ga.log(`Connected to backend ${this.location}!`),e()}),this.feathers.io.on("reconnect_failed",()=>{const r=new Error(`Cannot reach backend at location ${this.location}. Is the server running?
          If using locally, run 'npm run backend'`);r.name="DataStore connection error",t(),Ta(r,{duration:0})})}),"f")),await $t(this,lI,"f"),await $t(this,z1,"f"),this.authenticate())}async authenticate(){if(!this.requiresAuth)return this.user={email:null},this.user;if(this.user)return this.user;const e=()=>(ir(this,bb,!0,"f"),new Promise((t,r)=>{this.feathers.reAuthenticate().then(({user:s})=>{ir(this,bb,!1,"f"),this.user=s,ga.log(`Authenticated as ${s.email}`),t()}).catch(s=>{ir(this,bb,!1,"f"),r(s)})}));return ir(this,B1,$t(this,B1,"f").then(()=>$t(this,bb,"f")?null:e()),"f"),$t(this,B1,"f").then(()=>this.user)}async login(e,t){const r=await this.feathers.authenticate({strategy:"local",email:e,password:t});return this.user=r.user,this.user}async loginWithUI(){const e=new Q_t({target:document.body,props:{dataStore:this}});return new Promise((t,r)=>{e.$on("terminate",s=>{e.$destroy(),s?t(s):r()})})}async signup(e,t){try{return await this.service("users").create({email:e,password:t}),await this.login(e,t),this.user}catch(r){return ga.error("An error occurred during signup",r),{email:null}}}async logout(){await this.feathers.logout(),document.location.reload()}service(e){const t=Object.keys(this.feathers.services).includes(e);t||($t(this,V1,"f").call(this,e),this.$services.set(Object.keys(this.feathers.services)));const r=this.backend===gl.Remote?this.feathers.service(`${this.apiPrefix}/${e}`):this.feathers.service(e);return t||(r.items=()=>eSt(r)),r}setupAppHooks(){const e=this.backend!==gl.Remote?[L_t]:[],t=this.backend!==gl.Remote?[W_t]:[];this.feathers.hooks({before:{find:[...t,vm],create:[...e,z_t],update:[T9],patch:[T9]},after:{find:[vm],get:[vm],create:[vm],update:[vm],patch:[vm],remove:[vm]}})}}lI=new WeakMap,z1=new WeakMap,B1=new WeakMap,bb=new WeakMap,V1=new WeakMap;function HV(n){return new Oce(n)}async function VS(n,e,t){const r=document.createElement("a");r.style.display="none",document.body.appendChild(r);const s=new Blob([n],{type:t});r.href=URL.createObjectURL(s),r.download=e,r.click()}async function Fce(n){return new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const s=JSON.parse(r.result);e(s)},r.onerror=s=>{t(s)},r.readAsText(n)})}function KC(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").replace(/[\s_]+/g,"-").toLowerCase()}var U1,W1;class nSt extends Ia{constructor(e,t=HV()){super(),this.title="dataset",this.isDataset=!0,U1.set(this,void 0),this.query={},W1.set(this,new Set),this.$count=new mt(0,!0),this.$changes=new mt([]),this.name=e,this.title=`dataset (${e})`,ir(this,U1,t,"f"),this.start(),this.ready=new Promise((r,s)=>{$t(this,U1,"f").connect().then(()=>this.setup()).then(r).catch(i=>{const o=new Error(i==null?void 0:i.message);o.name=`Dataset Error (${e}): datastore connection failed`,Ta(o,{duration:0}),s(o)})})}async setup(){const e=KC(`instances-${this.name}`);this.instanceService=$t(this,U1,"f").service(e),this.instanceService.__hooks.before.find===void 0&&this.instanceService.hooks({before:{all:[],create:[B_t("datasetName",this.name),U_t],find:[y1("datasetName",this.name)],get:[y1("datasetName",this.name)],update:[y1("datasetName",this.name)],patch:[y1("datasetName",this.name)],remove:[y1("datasetName",this.name)]},after:{find:[E9],get:[E9]}}),this.instanceService.hooks({before:{update:[this.checkUpdates],patch:[this.checkUpdates]}}),await this.reset(),this.watchChanges()}async reset(){const{total:e}=await this.find({query:{$limit:0}});this.$count.set(e),this.$changes.set([{level:"dataset",type:"created"}])}async checkUpdates(e){if(Object.keys(this.query).length===0)return;const t=GH(this.query),r=t(e.data);try{const s=await this.get(e.id);t(s)&&!r&&(this.$count.set(this.$count.get()-1),this.$changes.set([{level:"instance",type:"removed",data:s}]))}catch{$t(this,W1,"f").add(e.id)}}watchChanges(){const e=GH(this.query);this.instanceService.on("created",r=>{if(!e(r))return;const s={...r,id:r.id||r._id};this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:s}])});const t=r=>{if(!e(r))return;const s={...r,id:r.id||r._id};$t(this,W1,"f").has(s.id)?(this.$count.set(this.$count.get()+1),this.$changes.set([{level:"instance",type:"created",data:s}]),$t(this,W1,"f").delete(s.id)):this.$changes.set([{level:"instance",type:"updated",data:s}])};this.instanceService.on("updated",t),this.instanceService.on("patched",t),this.instanceService.on("removed",r=>{if(!e(r))return;this.$count.set(this.$count.get()-1);const s={...r,id:r.id||r._id};this.$changes.set([{level:"instance",type:"removed",data:s}])})}async sift(e={}){return this.query=e,this.ready.then(()=>this.reset())}items(){return this.instanceService.items().query(this.query)}async find(e){const t=yl(e||{},{query:this.query});return this.instanceService.find(t)}async get(e,t){const r=yl(t||{},{query:this.query});return this.instanceService.get(e,r)}async create(e,t){const r=yl(t||{},{query:this.query});return this.instanceService.create(e,r)}async update(e,t,r){const s=yl(r||{},{query:this.query});return this.instanceService.update(e,t,s)}async patch(e,t,r){const s=yl(r||{},{query:this.query});return this.instanceService.patch(e,t,s)}async remove(e,t){const r=yl(t||{},{query:this.query});return this.instanceService.remove(e,r)}async clear(){await this.remove(null,{query:{}})}async distinct(e){const t={$distinct:e,...this.query};return this.instanceService.find({query:t})}async download(){const e=await this.find(),t={marcelleMeta:{type:"dataset"},instances:e.data},r=new Date(Date.now()),s=`${this.title}-${r.toISOString()}.json`;await VS(JSON.stringify(t),s,"text/plain")}async upload(e){const t=e.filter(i=>i.type==="application/json").map(i=>Fce(i)),s=(await Promise.all(t)).map(i=>i.instances.map(o=>{const{id:a,...l}=o;return this.create(l).catch(c=>{Ta(c)})}));await Promise.all(s)}mount(){}}U1=new WeakMap,W1=new WeakMap;function Lce(n,e){return new nSt(n,e)}function Ff(n){return typeof n=="object"&&n!==null&&n.isDataset}class r0 extends Ia{constructor(){super(),this.ready=!1,this.$training=new mt({status:"idle"},!0),this.$training.start(),this.$training.subscribe(({status:e})=>{(e==="success"||e==="loaded")&&(this.ready=!0)})}sync(e,t){return this.syncData={name:t,store:e},this.syncData.store.connect().then(()=>{this.syncData.service=this.syncData.store.service(this.serviceName),this.setupSync()}).catch(r=>{const s=new Error(r==null?void 0:r.message);s.name=`Model Sync Error (${t}): datastore connection failed`,Ta(s,{duration:0})}),this}async setupSync(){if(!this.syncData.service)return;const{data:e}=await this.syncData.service.find({query:{name:this.syncData.name,$select:["id"],$limit:1,$sort:{updatedAt:-1}}});let t=null;e.length===1&&(t=e[0].id,this.load(this.syncData.store,t));let r=!1;this.$training.subscribe(({status:i,data:o})=>{(i==="success"||i==="loaded"&&(o==null?void 0:o.source)!=="datastore")&&(r=!0,this.save(this.syncData.store,this.syncData.name,{},t).then(a=>{t=a}))});const s=i=>{(i._id===t||!t&&i.name===this.syncData.name)&&(t=i._id,r||this.load(this.syncData.store,t),r=!1)};this.syncData.service.on("created",s),this.syncData.service.on("updated",s),this.syncData.service.on("patched",s)}async saveToDatastore(e,t,r=null){await e.connect();const s=e.service(this.serviceName);if(!s||!t)return null;let i=r;return r?await s.update(r,t):i=(await s.create(t)).id,ga.info(`Model was saved to data store at location ${e.location}`),i}async loadFromDatastore(e,t){await e.connect();const r=e.service(this.serviceName);if(!r||!t)return null;let s;try{s=await r.get(t)}catch{const{data:o}=await r.find({query:{name:t,$limit:1,$sort:{updatedAt:-1}}});o.length===1&&(s=o[0])}if(s){const i=s.name;ga.info(`Model ${i} was loaded from data store at location ${e.location}`)}return s}mount(){}}function zce(n){if(!n.modelTopology.model_config||!n.modelTopology.model_config.config||!n.modelTopology.model_config.config.layers||n.modelTopology.model_config.config.layers.length>0&&!n.modelTopology.model_config.config.layers[0].class_name)return n;try{let e=!1;for(const[t,r]of n.modelTopology.model_config.config.layers.entries())if(r.class_name==="SeparableConv2D"){const s=["kernel_constraint","kernel_initializer","kernel_regularizer"];for(const i of s)Object.keys(n.modelTopology.model_config.config.layers[t].config).includes(i)&&(e=!0),delete n.modelTopology.model_config.config.layers[t].config[i]}e&&ga.warning("TFJS Model loading: experimentally removing Kernel attributes from SeparableConv2D layers")}catch(e){ga.warning("TFJS Model loading: An error occurred whil experimentally removing Kernel attributes from SeparableConv2D layers",e)}return n}function dL(...n){const e=oN(...n),t=e.load.bind(e);return e.load=async function(){const s=await t();return zce(s)},e}function Bce(...n){const e=wY(...n),t=e.load.bind(e);return e.load=async function(){const s=await t();return zce(s)},e}class G$ extends r0{constructor(){super(...arguments),this.serviceName="tfjs-models"}async warmup(){const e=this.model.inputs[0].shape.map(r=>r&&r>0?r:1),t=this.model.predict(Se(()=>ms(e)));await t.data(),t.dispose()}async save(e,t,r,s=null){if(!this.model)return null;let i;if(e.backend===gl.LocalStorage)await this.model.save(`indexeddb://${t}`),i=[["main",`indexeddb://${t}`]];else if(e.backend===gl.Remote){const a={};if(e.requiresAuth){const l=await e.feathers.authentication.getAccessToken(),c=new Headers({Authorization:`Bearer ${l}`});a.requestInit={headers:c}}i=await this.model.save(dL(`${e.location}/tfjs-models/upload`,a)).then(l=>l.responses[0].json())}const o={name:t,files:i,format:"tfjs",metadata:{tfjsModelFormat:this.model instanceof Hd?"layers-model":"graph-model",...this.labels&&{labels:this.labels},...r}};return this.saveToDatastore(e,o,s)}async load(e,t){if(!t)return null;this.$training.set({status:"loading"}),this.ready=!1,await j2();try{const r=await this.loadFromDatastore(e,t);this.loadFn=r.metadata.tfjsModelFormat==="graph-model"?Nl:K_;let s;if(e.backend===gl.LocalStorage)s=await this.loadFn(r.files[0][1]);else if(e.backend===gl.Remote){const i={};if(e.requiresAuth){const o=await e.feathers.authentication.getAccessToken(),a=new Headers({Authorization:`Bearer ${o}`});i.requestInit={headers:a}}s=await this.loadFn(dL(`${e.location}/tfjs-models/${r.id}/model.json`,i))}return s&&(this.model=s,await this.warmup()),r.metadata&&r.metadata.labels?this.labels=r.metadata.labels:this.labels=void 0,this.$training.set({status:"loaded",data:{source:"datastore",url:e.location}}),r}catch(r){throw console.log("[tfjs-model] Loading error",r),this.$training.set({status:"error"}),r}}async download(e){const t=KC(this.title),r={type:"tfjs-model",tfjsModelFormat:this.model instanceof Hd?"layers-model":"graph-model",name:t,...this.labels&&{labels:this.labels},...e},s=new Date(Date.now());await this.model.save(TY(async i=>{const o={modelTopology:i.modelTopology,weightsManifest:[{paths:[`./${t}.weights.bin`],weights:i.weightSpecs}],marcelle:r};return await VS(i.weightData,`${t}.weights.bin`,"application/octet-stream"),await VS(JSON.stringify(o),`${t}.json`,"text/plain"),{modelArtifactsInfo:{dateSaved:s,modelTopologyType:"JSON"}}}))}async upload(...e){this.$training.set({status:"loading"});try{const t=e.filter(o=>o.name.includes(".json")),r=e.filter(o=>o.name.includes(".bin")),{marcelle:s}=await new Promise((o,a)=>{const l=new FileReader;l.onload=()=>{const c=JSON.parse(l.result);o(c)},l.onerror=c=>a(new Error(`The provided files are not a valid marcelle model ${c}`)),l.readAsText(t[0])});if(this.loadFn=s.tfjsModelFormat==="graph-model"?Nl:K_,t.length===1&&e.length){const o=await this.loadFn(Bce([t[0],...r]));return o&&(this.model=o,await this.warmup()),s&&s.labels?this.labels=s.labels:this.labels=null,this.$training.set({status:"loaded",data:{source:"file"}}),{name:s.name,format:"tfjs",files:[],metadata:s}}const i=new Error("The provided files are not compatible with this model");throw i.name="File upload error",i}catch(t){throw this.$training.set({status:"error"}),t}}}Dn([Ln],G$.prototype,"warmup",null);Dn([Ln],G$.prototype,"upload",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rSt=1e-7,sSt=1e-4;class iSt{refCount(e){return za("refCount")}incRef(e){return za("incRef")}timerAvailable(){return!0}time(e){return za("time")}read(e){return za("read")}readSync(e){return za("readSync")}readToGPU(e,t){return za("readToGPU")}numDataIds(){return za("numDataIds")}disposeData(e,t){return za("disposeData")}write(e,t,r){return za("write")}move(e,t,r,s,i){return za("move")}createTensorFromGPUData(e,t,r){return za("createTensorFromGPUData")}memory(){return za("memory")}floatPrecision(){return za("floatPrecision")}epsilon(){return this.floatPrecision()===32?rSt:sSt}dispose(){return za("dispose")}}function za(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Bb(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Vce(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function oSt(n){return n%1===0}function cI(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Uce(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),Bi(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),Bi(n.every(r=>oSt(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function aSt(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:Uce(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function lSt(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function cSt(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function pL(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function uSt(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function jV(n){return typeof n=="string"||n instanceof String}function hSt(n){return typeof n=="boolean"}function fSt(n){return typeof n=="number"}function qV(n){return Array.isArray(n)?qV(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":fSt(n)?"float32":jV(n)?"string":hSt(n)?"bool":"float32"}function A9(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Wce(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function Gce(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=Gce(n+l*a,o,t,r)}return s}function M9(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Gce(0,n,e,t)}function dSt(n,e){const t=Hce(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Hce(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function pSt(n){n.forEach(e=>{Bi(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function XV(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N9="tfjsflags";class mSt{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=gSt,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ha().getBool("IS_TEST")||Ha().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Ha().getBool("IS_TEST")||Ha().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(XV(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);N9 in e&&e[N9].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=bSt(s,i)})}}function gSt(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(ySt(e,r[0],r[1]),r.join("="))),e}function ySt(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function bSt(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function Ha(){return jce}let jce=null;function vSt(n){jce=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let JP;function qce(){if(JP==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");JP=n}return JP}function wSt(){const n=qce();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function KV(n,e){const t=wSt();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const xSt="Abs",_St="Add",SSt="ArgMax",CSt="BatchMatMul",Xce="Cast",kSt="ComplexAbs",TSt="ExpandDims",ESt="GatherV2",ISt="Identity",ASt="Max",MSt="Min",NSt="Multiply",$St="Pow",RSt="Reshape",PSt="Sqrt",DSt="Sum";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(...n){Ha().getBool("IS_TEST")||Ha().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kce=KV("kernelRegistry",()=>new Map),OSt=KV("gradRegistry",()=>new Map);function $9(n,e){const t=FSt(n,e);return Kce.get(t)}function R9(n){return OSt.get(n)}function P9(n){const e=Kce.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function FSt(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LSt(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zSt(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Yce(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=US(n)),Ha().getBool("DEBUG")&&lSt(n,e),zSt(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function gM(){return Ha().platform.now()}function BSt(n,e="utf-8"){return e=e||"utf-8",Ha().platform.encode(n,e)}function D9(n,e="utf-8"){return e=e||"utf-8",Ha().platform.decode(n,e)}function Ru(n){return Ha().platform.isTypedArray!=null?Ha().platform.isTypedArray(n):LSt(n)}function US(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||XV(n)||n==null||Ru(n)&&t)e.push(n);else if(Array.isArray(n)||Ru(n))for(let r=0;r<n.length;++r)US(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)US(n[s],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VSt{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new WSt)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=gM();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:gM()-a})}if(Ha().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(h=>{USt(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function USt(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class WSt{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?cI(`${s}ms`,9):s.error,l=cI(e,25),c=t.rank,u=t.size,h=cI(t.shape.toString(),14);let f="";for(const d in i){const p=i[d];if(p!=null){const m=p.shape||t.shape,g=m.length;f+=`${d}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GSt(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const f=u[h];let d=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(m=>r[m.id]=!0),d=!0,s[c.id]=!0;break}if(d)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const f in u)i[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const d=c.inputs[f];r[d.id]&&(u[f]=d)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function HSt(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Vce(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=r(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O9=20,v1=3,QP=7;function jSt(n,e,t,r){const s=Wce(e),i=qSt(n,e,t,s),o=e.length,a=uI(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function qSt(n,e,t,r){const s=Bb(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?H1(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],G1(l[u+h],0,t).length)}return o}function G1(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(QP))} + ${parseFloat(n[1].toFixed(QP))}j`:jV(n)?r=`'${n}'`:t==="bool"?r=Zce(n):r=parseFloat(n.toFixed(QP)).toString(),cI(r,e)}function Zce(n){return n===0?"false":"true"}function uI(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=H1(n);return[G1(m[0],0,t)]}return t==="bool"?[Zce(n[0])]:[n[0].toString()]}if(l===1){if(a>O9){const g=v1*o;let y=Array.from(n.slice(0,g)),b=Array.from(n.slice((a-v1)*o,a*o));return t==="complex64"&&(y=H1(y),b=H1(b)),["["+y.map((x,w)=>G1(x,s[w],t)).join(", ")+", ..., "+b.map((x,w)=>G1(x,s[a-v1+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?H1(n):Array.from(n)).map((g,y)=>G1(g,s[y],t)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),h=r[0]*o,f=[];if(a>O9){for(let m=0;m<v1;m++){const g=m*h,y=g+h;f.push(...uI(n.slice(g,y),c,t,u,s,!1))}f.push("...");for(let m=a-v1;m<a;m++){const g=m*h,y=g+h;f.push(...uI(n.slice(g,y),c,t,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*h,y=g+h;f.push(...uI(n.slice(g,y),c,t,u,s,m===a-1))}const d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let m=1;m<f.length-1;m++)f[m]=" "+f[m]+d;let p=`,
`;for(let m=2;m<l;m++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(i?"":p),f}function H1(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lh=null,w1=null;function XSt(n){lh=n}class lc{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Bb(e),this.strides=Wce(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return w1.buffer(this.shape,this.dtype,e)}bufferSync(){return w1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return M9(this.shape,e,this.dtype==="complex64")}arraySync(){return M9(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=lh().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>D9(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),lh().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=lh().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>D9(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await lh().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),lh().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return w1.print(this,e)}clone(){return this.throwIfDisposed(),w1.clone(this)}toString(e=!1){const t=this.dataSync();return jSt(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),w1.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),lh().makeVariable(this,e,t,r)}}Object.defineProperty(lc,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Dc(){return KV("Tensor",()=>lc)}Dc();class mL extends lc{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Vce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);lh().disposeTensor(this),this.dataId=e.dataId,lh().incRef(this,null)}dispose(){lh().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(mL,Symbol.hasInstance,{value:n=>n instanceof lc&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var F9;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(F9||(F9={}));var gL;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(gL||(gL={}));var yL;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(yL||(yL={}));var bL;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(bL||(bL={}));var vL;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(vL||(vL={}));const KSt={float32:bL,int32:gL,bool:yL,complex64:vL};function YSt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return KSt[n][e]}function Jce(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Qce(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(n,e){if(n.dtype===e.dtype)return[n,e];const t=YSt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function ZSt(n){const e=[];return eue(n,e,new Set),e}function eue(n,e,t){if(n==null)return;if(n instanceof lc){e.push(n);return}if(!JSt(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),eue(i,e,t))}}function JSt(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eD(n){return n.kernelName!=null}class L9{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class kv{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new L9}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(b1(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new VSt(this.backendInstance),!0}setupRegisteredKernels(){P9(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){P9(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof iSt)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,b1(`Initialization of backend ${e} failed`),b1(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return b1(`Initialization of backend ${e} failed`),b1(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return kv.nextTensorId++}nextVariableId(){return kv.nextVariableId++}clone(e){const t=ws.runKernel(ISt,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return ws.runKernel(Xce,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!($9(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=eD(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(eD(e)){const{kernelName:p,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=$9(p,this.backendName);Bi(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,x);const w=x.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(s){const S=this.getTensorsForGradient(p,m,w);r=this.saveTensorsForBackwardMode(S)}return w}}else{const{forwardFunc:p}=e,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};a=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,g,y),y}}const{inputs:u,attrs:h}=e,f=eD(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(c,u,t,f,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=R9(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(Bi(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&jV(e[0])&&(i=e.map(l=>BSt(l)));const o=s.write(i,t,r),a=new lc(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),c=uSt(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new lc(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new mL(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*pL(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof mL||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*pL(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=R9(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const f=r[h],d=Hce(f.size,f.dtype);return this.makeTensor(d,f.shape,f.dtype)}return u}),s(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=ZSt(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(Bi(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Bi(i instanceof lc,()=>"The result y returned by f() must be a tensor.");const o=GSt(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??QSt(i.shape),HSt(a,o,c=>this.tidy(c),t2t);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return Bi(A9(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{Bi(t.every(a=>a instanceof lc),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),Bi(r.value instanceof lc,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Bi(A9(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];Bi(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Bi(u.every(f=>f instanceof lc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((f,d)=>{h[d]=()=>f}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=gM(),r=await this.backend.time(e);return r.wallMs=gM()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new L9;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}kv.nextTensorId=0;kv.nextVariableId=0;function QSt(n){const e=dSt(Bb(n),"float32");return ws.makeTensor(e,n,"float32")}function e2t(){const n=qce();if(n._tfengine==null){const e=new mSt(n);n._tfengine=new kv(e)}return vSt(n._tfengine.ENV),XSt(()=>n._tfengine),n._tfengine}const ws=e2t();function t2t(n,e){const t={a:n,b:e};return ws.runKernel(_St,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2t(n,e){let t=n;if(Ru(n))return e==="string"?[]:[n.length];if(Jce(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(Qce(n))return[n.buffer.size/(e==null?4:pL(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Ru(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ha().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&tue(n,r,[]),r}function tue(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ru(n)){Bi(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}Bi(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),Bi(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)tue(n[s],r,t.concat(s))}function z9(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function $i(n,e,t,r="numeric"){if(n instanceof lc)return z9(r,n.dtype,e,t),n;let s=qV(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),z9(r,s,e,t),n==null||!Ru(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=n2t(n,s);!Ru(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?Yce(n,s):US(n,[],!0);return ws.makeTensor(a,i,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2t="__op";function sa(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+r2t;const s=(...i)=>{ws.startScope(t);try{const o=r(...i);return XV(o)&&console.error("Cannot return a Promise inside of tidy."),ws.endScope(o),o}catch(o){throw ws.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2t(n,e,t=0,r=0){const s=$i(n,"x","gather"),i=$i(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return ws.runKernel(ESt,o,a)}const i2t=sa({gather_:s2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.gather=function(n,e,t){return this.throwIfDisposed(),i2t(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2t(n,e=0){const r={x:$i(n,"x","argMax")},s={axis:e};return ws.runKernel(SSt,r,s)}const a2t=sa({argMax_:o2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.argMax=function(n){return this.throwIfDisposed(),a2t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2t(n,e){const r={x:$i(n,"x","reshape","string_or_numeric")},s={shape:e};return ws.runKernel(RSt,r,s)}const fx=sa({reshape_:l2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c2t(n,e){const t=$i(n,"x","squeeze","string_or_numeric");return fx(t,aSt(t.shape,e).newShape)}const u2t=sa({squeeze_:c2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.squeeze=function(n){return this.throwIfDisposed(),u2t(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2t(n,e=0){const t=$i(n,"x","expandDims","string_or_numeric");Bi(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return ws.runKernel(TSt,r,s)}const f2t=sa({expandDims_:h2t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.expandDims=function(n){return this.throwIfDisposed(),f2t(this,n)};function B9(n,e=null,t=!1){const r=e?{$select:e}:{},s=Ff(n)?n.items().query(r):n,i=t?s.toArray():Promise.resolve(s);async function*o(){const a=await i;for await(const l of a)yield l}return Hrt(o)}function V9(n){const e={};for(const[t,r]of Object.entries(n)){const s=t.startsWith("val_")?t.replace("val_","")+"Val":t;e[s]=r}return e}class nue extends G${constructor({epochs:e=20,batchSize:t=8,validationSplit:r=.2}={}){super(),this.title="TFJSCustomModel",this.loadFn=K_,this.validationSplit=Math.max(Math.min(r,1),0),this.parameters={epochs:new mt(e,!0),batchSize:new mt(t,!0)}}transformDataset(e){return e.map(t=>({xs:Ei(t.x),ys:Ei(t.y)}))}async train(e,t){this.$training.set({status:"start",epochs:this.parameters.epochs.get()});const s=Ff(e)?e.$count.value:(await e.toArray()).length,i=Math.min(200,s),o=this.transformDataset(B9(e,["x","y"],s<200)).shuffle(i);let a,l;if(t)a=o,l=this.transformDataset(B9(t,["x","y"],s<200)).shuffle(i);else{const h=Math.floor(s*(1-this.validationSplit));a=o.take(h),l=this.validationSplit>0&&o.skip(h)}const[{xs:c,ys:u}]=await a.take(1).toArray();this.buildModel(c.shape,u.shape),this.fit(a,l)}_predict(e){return this.model?Se(()=>this.model.predict(Ei(e).expandDims(0)).gather(0)):null}clear(){delete this.model}fit(e,t){this.model.fitDataset(e.batch(this.parameters.batchSize.get()),{...t?{validationData:t.batch(this.parameters.batchSize.get())}:{},epochs:this.parameters.epochs.get(),callbacks:{onEpochEnd:(r,s)=>{this.$training.set({status:"epoch",epoch:r+1,epochs:this.parameters.epochs.get(),data:V9(s)})}}}).then(r=>{this.$training.set({status:"success",data:V9(r.history)})}).catch(r=>{throw this.$training.set({status:"error",data:r}),new Sp(r.message)})}}Dn([Ln],nue.prototype,"train",null);class rue extends nue{constructor(){super(...arguments),this.title="TFJSCustomClassifier"}async train(e,t){const r=Ff(e);if(this.labels=r?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:i})=>i).toArray())),this.labels.length===0){Ta(new Sp("This dataset is empty or is missing labels")),this.$training.set({status:"error"});return}if(this.labels.length===1){Ta(new Sp("At least two classes are needed to train the classifier")),this.$training.set({status:"error"});return}const s=this.labels.length;this.transformDataset=i=>i.map(o=>({xs:Ei(o.x),ys:Xb(this.labels.indexOf(o.y),s)})),super.train(e,t)}async predict(e){return this.model?Se(()=>{const t=this._predict(e),r=this.labels[t.argMax().arraySync()],i=t.arraySync().reduce((o,a,l)=>({...o,[this.labels[l]]:a}),{});return{label:r,confidences:i}}):{label:void 0,confidences:{}}}}Dn([Ln],rue.prototype,"train",null);function d2t(n){var g,y,b,x;let e,t,r,s,i=((g=n[2])==null?void 0:g.message)+"",o,a,l,c,u=Math.floor(((y=n[2])==null?void 0:y.progress)*100)+"",h,f,d,p,m;return p=new Ace({props:{progress:(b=n[2])==null?void 0:b.progress,type:(x=n[2])==null?void 0:x.type}}),{c(){var w,S,C,k,A,M;e=we("div"),t=we("div"),r=we("div"),s=we("span"),o=He(i),a=Ye(),l=we("div"),c=we("span"),h=He(u),f=He("%"),d=Ye(),It(p.$$.fragment),Z(s,"class","text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 svelte-cymqgb"),qt(s,"gray",((w=n[2])==null?void 0:w.type)==="idle"),qt(s,"green",((S=n[2])==null?void 0:S.type)==="success"),qt(s,"red",((C=n[2])==null?void 0:C.type)==="danger"),Z(c,"class","text-xs font-semibold inline-block text-blue-600 svelte-cymqgb"),qt(c,"tgray",((k=n[2])==null?void 0:k.type)==="idle"),qt(c,"tgreen",((A=n[2])==null?void 0:A.type)==="success"),qt(c,"tred",((M=n[2])==null?void 0:M.type)==="danger"),Z(l,"class","text-right"),Z(t,"class","flex mb-2 items-center justify-between"),Z(e,"class","relative pt-6 w-full"),lu(e,"min-width","250px")},m(w,S){me(w,e,S),se(e,t),se(t,r),se(r,s),se(s,o),se(t,a),se(t,l),se(l,c),se(c,h),se(c,f),se(e,d),kt(p,e,null),m=!0},p(w,S){var k,A,M,E,N,O,R,D,z,B;(!m||S&4)&&i!==(i=((k=w[2])==null?void 0:k.message)+"")&&cn(o,i),(!m||S&4)&&qt(s,"gray",((A=w[2])==null?void 0:A.type)==="idle"),(!m||S&4)&&qt(s,"green",((M=w[2])==null?void 0:M.type)==="success"),(!m||S&4)&&qt(s,"red",((E=w[2])==null?void 0:E.type)==="danger"),(!m||S&4)&&u!==(u=Math.floor(((N=w[2])==null?void 0:N.progress)*100)+"")&&cn(h,u),(!m||S&4)&&qt(c,"tgray",((O=w[2])==null?void 0:O.type)==="idle"),(!m||S&4)&&qt(c,"tgreen",((R=w[2])==null?void 0:R.type)==="success"),(!m||S&4)&&qt(c,"tred",((D=w[2])==null?void 0:D.type)==="danger");const C={};S&4&&(C.progress=(z=w[2])==null?void 0:z.progress),S&4&&(C.type=(B=w[2])==null?void 0:B.type),p.$set(C)},i(w){m||(Ie(p.$$.fragment,w),m=!0)},o(w){$e(p.$$.fragment,w),m=!1},d(w){w&&de(e),Tt(p)}}}function p2t(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[d2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&12&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function m2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{progress:a}=e;return i(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"progress"in l&&i(t(1,a=l.progress))},[o,a,r]}class g2t extends xn{constructor(e){super(),wn(this,e,m2t,p2t,pn,{title:0,progress:1})}}class y2t extends Ia{constructor(e){super(),this.$progress=e,this.title="progress bar",this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new g2t({target:t,props:{title:this.title,progress:this.$progress}}))}}function b2t(n){if(!n.$training)throw new Error("The argument is not a valid MLP");const e=n.$training.map(({status:r,epoch:s,epochs:i})=>{let o="default",a=i>0?s/i:null;return r==="error"&&(o="danger"),r==="idle"&&(o="idle",a=0),["success","loaded"].includes(r)&&(o="success",a=1),["start","loading"].includes(r)&&(a=null),{message:`Status: ${r}`,progress:a,type:o}}).hold(),t=new y2t(e);return t.title="Training Progress",t}var j1;class v2t extends Ia{constructor(e,t=HV()){super(),this.title="batch prediction",j1.set(this,void 0),this.$status=new mt({status:"loading"},!0),this.name=e,this.title=`batch prediction (${e})`,ir(this,j1,t||new Oce,"f"),this.start(),$t(this,j1,"f").connect().then(()=>{this.setup()}).catch(r=>{const s=new Error(r==null?void 0:r.message);s.name=`Batch Prediction Error (${e}): Datastore connection failed`,Ta(s,{duration:0})})}async setup(){const e=KC(`predictions-${this.name}`);this.predictionService=$t(this,j1,"f").service(e);const{total:t}=await this.predictionService.find({query:{$limit:1,$select:["id"]}});this.$status.set({status:t>0?"loaded":"idle"})}async predict(e,t){try{const r=Ff(t)?t.$count.value:(await t.toArray()).length;this.$status.set({status:"start"});const s=Ff(t)?t.items():t;let i=0;for await(const{id:o,x:a,y:l}of s){const c=await e.predict(a),u=await this.predictionService.create({...c,instanceId:o,yTrue:l});this.$status.set({status:"running",count:++i,total:r,data:u})}this.$status.set({status:"success",count:i,total:r})}catch(r){this.$status.set({status:"error",data:{error:r}})}}async clear(){await this.predictionService.remove(null,{query:{}})}items(){return this.predictionService.items()}mount(){}}j1=new WeakMap;function sue(...n){return new v2t(...n)}function w2t(n){let e;return{c(){e=He(n[10])},m(t,r){me(t,e,r)},p(t,r){r&1024&&cn(e,t[10])},d(t){t&&de(e)}}}function x2t(n){let e,t,r,s;function i(a){n[11](a)}let o={disabled:n[7],type:n[8],$$slots:{default:[w2t]},$$scope:{ctx:n}};return n[9]!==void 0&&(o.pressed=n[9]),t=new zs({props:o}),hi.push(()=>Zf(t,"pressed",i)),t.$on("click",n[12]),{c(){e=we("div"),It(t.$$.fragment)},m(a,l){me(a,e,l),kt(t,e,null),s=!0},p(a,l){const c={};l&128&&(c.disabled=a[7]),l&256&&(c.type=a[8]),l&9216&&(c.$$scope={dirty:l,ctx:a}),!r&&l&512&&(r=!0,c.pressed=a[9],Yf(()=>r=!1)),t.$set(c)},i(a){s||(Ie(t.$$.fragment,a),s=!0)},o(a){$e(t.$$.fragment,a),s=!1},d(a){a&&de(e),Tt(t)}}}function _2t(n){let e,t;return e=new ra({props:{title:n[0],loading:n[6],$$slots:{default:[x2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&64&&(i.loading=r[6]),s&10112&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function S2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(S,E=>t(6,r=E)),S),o,a=tt,l=()=>(a(),a=os(C,E=>t(7,o=E)),C),c,u=tt,h=()=>(u(),u=os(k,E=>t(8,c=E)),k),f,d=tt,p=()=>(d(),d=os(w,E=>t(9,f=E)),w),m,g=tt,y=()=>(g(),g=os(x,E=>t(10,m=E)),x);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u()),n.$$.on_destroy.push(()=>d()),n.$$.on_destroy.push(()=>g());let{title:b}=e,{text:x}=e;y();let{pressed:w}=e;p();let{loading:S}=e;i();let{disabled:C}=e;l();let{type:k}=e;h();function A(E){f=E,w.set(f)}function M(E){dM.call(this,n,E)}return n.$$set=E=>{"title"in E&&t(0,b=E.title),"text"in E&&y(t(1,x=E.text)),"pressed"in E&&p(t(2,w=E.pressed)),"loading"in E&&i(t(3,S=E.loading)),"disabled"in E&&l(t(4,C=E.disabled)),"type"in E&&h(t(5,k=E.type))},[b,x,w,S,C,k,r,o,c,f,m,A,M]}class C2t extends xn{constructor(e){super(),wn(this,e,S2t,_2t,pn,{title:0,text:1,pressed:2,loading:3,disabled:4,type:5})}}class k2t extends Ia{constructor(e="click me"){super(),this.title="button",this.$click=new mt(P_()),this.$pressed=new mt(!1,!0),this.$loading=new mt(!1,!0),this.$disabled=new mt(!1,!0),this.$type=new mt("default",!0),this.$text=new mt(e,!0),this.start(),this.$loading.skip(1).subscribe(t=>{this.$disabled.set(t)})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new C2t({target:t,props:{title:this.title,text:this.$text,pressed:this.$pressed,loading:this.$loading,disabled:this.$disabled,type:this.$type}}),this.$$.app.$on("click",this.$click.set))}}function s0(...n){return new k2t(...n)}function T2t(n){let e,t;return{c(){e=He("COCO-SSD loaded with base "),t=He(n[2])},m(r,s){me(r,e,s),me(r,t,s)},p(r,s){s&4&&cn(t,r[2])},d(r){r&&de(e),r&&de(t)}}}function E2t(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function I2t(n){let e;function t(i,o){return i[3]?E2t:T2t}let r=t(n),s=r(n);return{c(){e=we("p"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function A2t(n){let e,t;return e=new ra({props:{title:n[0],loading:n[3],$$slots:{default:[I2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]),s&28&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function M2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{base:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&i(t(1,a=c.loading)),"base"in c&&t(2,l=c.base)},[o,a,l,r]}class N2t extends xn{constructor(e){super(),wn(this,e,M2t,A2t,pn,{title:0,loading:1,base:2})}}var Am,_d;class dx extends r0{constructor({base:e="lite_mobilenet_v2"}={}){super(),this.title="COCO-SSD Object Detection",this.parameters={},this.serviceName="undefined",Am.set(this,void 0),_d.set(this,void 0),this.$loading=new mt(!0,!0),ir(this,_d,e,"f"),this.setup()}async setup(){await j2();const e=await LL(),t=Object.keys(e).filter(r=>r.includes("cocossd"));try{ir(this,Am,await N6.load({base:$t(this,_d,"f"),modelUrl:`indexeddb://cocossd-${$t(this,_d,"f")}`}),"f")}catch{t.length>0&&await zL(t[0]),ir(this,Am,await N6.load({base:$t(this,_d,"f")}),"f"),await $t(this,Am,"f").model.save(`indexeddb://cocossd-${$t(this,_d,"f")}`)}ga.info("COCO-SSD loaded with base `lite_mobilenet_v2`"),this.$loading.set(!1),this.start()}train(){throw new Sp("Model `CocoSsd` cannot be trained")}async predict(e){if(!$t(this,Am,"f"))throw new Error("Model is not loaded");return{outputs:(await $t(this,Am,"f").detect(e)).map(s=>({bbox:s.bbox,class:s.class,confidence:s.score}))}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new N2t({target:t,props:{title:this.title,loading:this.$loading,base:$t(this,_d,"f")}}))}save(){throw new Error("CocoSsd does not support saving")}load(){throw new Error("CocoSsd does not support loading")}download(){throw new Error("CocoSsd does not support downloading")}upload(){throw new Error("CocoSsd does not support uploading")}}Am=new WeakMap,_d=new WeakMap;Dn([Ln],dx.prototype,"train",null);Dn([Ln],dx.prototype,"predict",null);Dn([Ln],dx.prototype,"save",null);Dn([Ln],dx.prototype,"load",null);Dn([Ln],dx.prototype,"download",null);Dn([Ln],dx.prototype,"upload",null);function $2t(n){let e,t;return{c(){e=we("div"),t=we("canvas"),Z(e,"class","w-full h-96")},m(r,s){me(r,e,s),se(e,t),n[6](t)},p:tt,d(r){r&&de(e),n[6](null)}}}function R2t(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[$2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&32770&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function P2t(n,e,t){let{title:r}=e,{preset:s}=e,{options:i}=e,{datasets:o}=e;su.register(KE,VE,UE,gA,xb,Yat,nlt,Od,WE,iF,oF,eF,YE,GE,HE,$1,ZE,jE,nS,lF,Jse,eie);const a=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 206, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(255, 159, 64)"],l={data:{},options:{maintainAspectRatio:!1,animation:{duration:200},borderWidth:4}};function c(b){return{borderColor:a[b%6],backgroundColor:a[b%6],fill:!1,lineTension:.2}}function u(b,x,w){const S={labels:[]};let C=0;return S.datasets=b.map(({dataStream:k,label:A,options:M},E)=>{C=Math.max(C,k.get()?k.get().length:0),E===0&&(S.labels=M.labels||[],!M.labels&&k.get()&&k.get().length>0&&(typeof k.get()[0]=="number"?S.labels=Array.from(Array(k.get().length),(O,R)=>R.toString()):S.labels=k.get().map(O=>O.x.toString())));let N={...c(E),...x,...M,label:A,data:k.get()||[]};return(["bar","bar-fast"].includes(M.type)||["bar","bar-fast"].includes(w.type)&&!M.type)&&b.length===1&&(N.borderColor=a,N.backgroundColor=a),N}),S}let h,f=[],d;function p(){let b=yl(l,s.global);b=yl(b,{data:u(o,s.datasets,b),options:i}),i.xlabel&&(b=yl(b,{options:{scales:{x:{title:{display:!0,text:i.xlabel}}}}})),i.ylabel&&(b=yl(b,{options:{scales:{y:{title:{display:!0,text:i.ylabel}}}}}));const x=o.map(({dataStream:S})=>{var C;return((C=S.get())===null||C===void 0?void 0:C.length)||0});f=o.map(({dataStream:S,options:C},k)=>S.subscribe(A=>{if(A&&h){const M=x.reduce((E,N)=>Math.max(E,N));x[k]=A.length,!C.labels&&A.length>0&&x[k]>M&&(typeof A[0]=="number"?b.data.labels=Array.from(Array(A.length),(E,N)=>N.toString()):b.data.labels=A.map(E=>E.x.toString())),b.data.datasets[k].data=A;try{h.update()}catch(E){console.log(E)}}}));const w=d.getContext("2d");h=new su(w,b)}function m(){for(const b of f)b();h==null||h.destroy()}Nu(async()=>{await ea(),await ea(),p()});let g=o.length;$g(m);function y(b){hi[b?"unshift":"push"](()=>{d=b,t(1,d)})}return n.$$set=b=>{"title"in b&&t(0,r=b.title),"preset"in b&&t(2,s=b.preset),"options"in b&&t(3,i=b.options),"datasets"in b&&t(4,o=b.datasets)},n.$$.update=()=>{n.$$.dirty&48&&o.length!==g&&(m(),p(),t(5,g=o.length))},[r,d,s,i,o,g,y]}class D2t extends xn{constructor(e){super(),wn(this,e,P2t,R2t,pn,{title:0,preset:2,options:3,datasets:4})}}var hI,fI,fl;const U9={line:{global:{type:"line",options:{animation:{duration:200},scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:.2}},"line-fast":{global:{type:"line",options:{elements:{point:{radius:0}},animation:!1,tooltips:!1,spanGaps:!0,scales:{x:{ticks:{sampleSize:11}}}}},datasets:{fill:!1,lineTension:0}},bar:{global:{type:"bar",options:{animation:{duration:200},scales:{y:{beginAtZero:!0}}}}},"bar-fast":{global:{type:"bar",options:{animation:!1,scales:{y:{beginAtZero:!0}}}}},scatter:{global:{type:"scatter",options:{scales:{x:{type:"linear",position:"bottom"}}}}}};class O2t extends Ia{constructor({preset:e="line",options:t={}}={}){super(),this.title="generic chart",hI.set(this,void 0),fI.set(this,void 0),fl.set(this,[]),Object.keys(U9).includes(e)||Ta(new Error(`Preset ${e} is not recognized`)),ir(this,hI,e,"f"),ir(this,fI,U9[e],"f"),this.options=t,this.start()}addSeries(e,t,r={}){if(GV(e)){if($t(this,hI,"f")==="line-fast"){const s=e.debounce(10);s.value=e.get(),$t(this,fl,"f").push({dataStream:s,label:t,options:r})}else $t(this,fl,"f").push({dataStream:e,label:t,options:r});this.updateView()}else e.toArray().then(s=>{const i=new mt(s,!0);$t(this,fl,"f").push({dataStream:i,label:t,options:r}),this.updateView()})}setColors(e){$t(this,fl,"f")[0].label="clusters",$t(this,fl,"f")[0].options.backgroundColor=e.get(),$t(this,fl,"f")[0].options.color=e.get()}removeSeries(e){const t=$t(this,fl,"f").map(r=>r.dataStream).indexOf(e);t>-1&&$t(this,fl,"f").splice(t,1)}clear(){ir(this,fl,[],"f"),this.updateView()}updateView(){this.$$.app&&this.$$.app.$set({datasets:$t(this,fl,"f")})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new D2t({target:t,props:{title:this.title,preset:$t(this,fI,"f"),options:this.options,datasets:$t(this,fl,"f")}}))}}hI=new WeakMap,fI=new WeakMap,fl=new WeakMap;function iue(...n){return new O2t(...n)}function W9(n){let e,t;return{c(){e=new Bxt(!1),t=mo(),e.a=t},m(r,s){e.m(n[2],r,s),me(r,t,s)},p(r,s){s&4&&e.p(r[2])},d(r){r&&de(t),r&&e.d()}}}function F2t(n){let e,t=n[2]&&W9(n);return{c(){e=we("div"),t&&t.c(),Z(e,"class","grow")},m(r,s){me(r,e,s),t&&t.m(e,null)},p(r,s){r[2]?t?t.p(r,s):(t=W9(r),t.c(),t.m(e,null)):t&&(t.d(1),t=null)},d(r){r&&de(e),t&&t.d()}}}function L2t(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[F2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&12&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function z2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,l=>t(2,r=l)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{text:a}=e;return i(),n.$$set=l=>{"title"in l&&t(0,o=l.title),"text"in l&&i(t(1,a=l.text))},[o,a,r]}class B2t extends xn{constructor(e){super(),wn(this,e,z2t,L2t,pn,{title:0,text:1})}get title(){return this.$$.ctx[0]}set title(e){this.$$set({title:e}),Rg()}get text(){return this.$$.ctx[1]}set text(e){this.$$set({text:e}),Rg()}}class V2t extends Ia{constructor(e="click me"){super(),this.title="text",this.$value=new mt(e,!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new B2t({target:t,props:{title:this.title,text:this.$value}}))}}function H$(...n){return new V2t(...n)}var hf,eh;class U2t extends Ia{constructor(e){super(),this.title="confidence plot",hf.set(this,void 0),eh.set(this,void 0),this.$confidenceStream=e.map(({confidences:t})=>Object.entries(t).map(([r,s])=>({x:r,y:s})).sort((r,s)=>r.x<s.x?-1:r.x>s.x?1:0)),ir(this,hf,iue({preset:"bar-fast",options:{xlabel:"Label",ylabel:"Confidence",scales:{y:{suggestedMax:1}}}}),"f"),$t(this,hf,"f").addSeries(this.$confidenceStream,"Confidences"),$t(this,hf,"f").title="",ir(this,eh,H$("Waiting for predictions..."),"f"),$t(this,eh,"f").title=this.title,$t(this,eh,"f").$value=new mt(e.map(({label:t})=>`<p>Predicted Label: <code style="font-size: 1.5rem;">${t}</code></p>`).startWith("Waiting for predictions..."),!0),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);if(!t)return;const r=document.createElement("div");r.id=`${t.id}-${$t(this,eh,"f").id}`;const s=document.createElement("div");s.id=`${t.id}-${$t(this,hf,"f").id}`,t.appendChild(r),t.appendChild(s),$t(this,eh,"f").title=this.title,$t(this,eh,"f").mount(r),$t(this,hf,"f").mount(s),this.destroy=()=>{r.parentElement.removeChild(r),s.parentElement.removeChild(s),$t(this,eh,"f").destroy(),$t(this,hf,"f").destroy()}}destroy(){$t(this,eh,"f").destroy(),$t(this,hf,"f").destroy()}}hf=new WeakMap,eh=new WeakMap;function W2t(...n){return new U2t(...n)}function G2t(n){let e;return{c(){e=we("p"),e.textContent="Waiting for predictions...",Z(e,"class","m-2")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function H2t(n){let e,t,r=n[6].toFixed(2)+"",s,i,o,a,l,c;return{c(){e=we("p"),t=He("Global Accuracy: "),s=He(r),i=Ye(),o=we("div"),a=we("canvas"),Z(e,"class","m-2"),Z(o,"class","confusion-container svelte-1d2i0ke")},m(u,h){me(u,e,h),se(e,t),se(e,s),me(u,i,h),me(u,o,h),se(o,a),l||(c=$xt(n[7].call(null,a)),l=!0)},p(u,h){h&64&&r!==(r=u[6].toFixed(2)+"")&&cn(s,r)},d(u){u&&de(e),u&&de(i),u&&de(o),l=!1,c()}}}function j2t(n){let e;function t(i,o){return i[6]!==void 0?H2t:G2t}let r=t(n),s=r(n);return{c(){s.c(),e=mo()},m(i,o){s.m(i,o),me(i,e,o)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},d(i){s.d(i),i&&de(e)}}}function q2t(n){let e,t;return e=new ra({props:{title:n[0],loading:n[4],progress:n[5],$$slots:{default:[j2t]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&16&&(i.loading=r[4]),s&32&&(i.progress=r[5]),s&131136&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function X2t(n,e,t){let r,s=tt,i=()=>(s(),s=os(d,E=>t(4,r=E)),d),o,a=tt,l=()=>(a(),a=os(p,E=>t(5,o=E)),p),c,u=tt,h=()=>(u(),u=os(m,E=>t(6,c=E)),m);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a()),n.$$.on_destroy.push(()=>u());let{title:f}=e,{loading:d}=e;i();let{progress:p}=e;l();let{accuracy:m}=e;h();let{confusion:g}=e,{labels:y}=e,{selected:b}=e;su.register(gA,Jse,eie,mF,D1);let x=1,w=1,S=-1;const C={type:"matrix",data:{datasets:[{label:"Confusion Matrix",data:[],backgroundColor(E){if(E.dataset.data.length>0){if(E.dataIndex===S){const{x:O,y:R}=E.dataset.data[E.dataIndex];return O===R?"green":"red"}return`rgba(54, 162, 235, ${E.dataset.data[E.dataIndex].v/x})`}return"rgba(54, 162, 235, 0)"},width(E){const N=E.chart.chartArea;return N?(N.right-N.left)/w-2:0},height(E){const N=E.chart.chartArea;return N?(N.bottom-N.top)/w-2:0}}]},options:{aspectRatio:1,legend:{display:!1},plugins:{tooltip:{callbacks:{title([E]){return["count: "+E.dataset.data[E.dataIndex].v]},label(E){const N=E.dataset.data[E.dataIndex];return["true label: "+N.y,"predicted label: "+N.x]}}}},scales:{x:{type:"category",labels:[],ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"Predicted Label"}},y:{type:"category",labels:[],offset:!0,reverse:!0,ticks:{display:!0,autoSkip:!1},gridLines:{display:!1},title:{display:!0,text:"True Label"}}},onClick(E){try{const N=E.chart.tooltip.dataPoints[0].dataIndex;S===N?(b.set(null),S=-1):(b.set(E.chart.tooltip.dataPoints[0].raw),S=N,E.chart.update())}catch(N){console.log("[confusion matrix] selection error:",N)}}}};let k,A=[];function M(E){const N=E.getContext("2d");k=new su(N,C),A.push(y.subscribe(O=>{w=O.length,C.options.scales.x.labels=O.sort(),C.options.scales.y.labels=O.sort(),k.update()})),A.push(g.subscribe(O=>{x=O.reduce((R,{v:D})=>Math.max(R,D),0),C.data.datasets[0].data=O,k.update()}))}return $g(()=>{for(const E of A)E()}),n.$$set=E=>{"title"in E&&t(0,f=E.title),"loading"in E&&i(t(1,d=E.loading)),"progress"in E&&l(t(2,p=E.progress)),"accuracy"in E&&h(t(3,m=E.accuracy)),"confusion"in E&&t(8,g=E.confusion),"labels"in E&&t(9,y=E.labels),"selected"in E&&t(10,b=E.selected)},[f,d,p,m,r,o,c,M,g,y,b]}class K2t extends xn{constructor(e){super(),wn(this,e,X2t,q2t,pn,{title:0,loading:1,progress:2,accuracy:3,confusion:8,labels:9,selected:10})}}var vb;class Y2t extends Ia{constructor(e){super(),this.title="confusion matrix",vb.set(this,void 0),this.$confusion=new mt([],!0),this.$accuracy=new mt(void 0,!0),this.$labels=new mt([],!0),this.$selected=new mt(null,!0),this.$progress=new mt(!1,!0),ir(this,vb,e,"f"),this.start(),this.setup()}setup(){let e=[];$t(this,vb,"f").$status.subscribe(async({status:t,count:r,total:s,data:i})=>{t==="start"?(e=[],this.$progress.set(null)):t==="running"?(e.push(i),this.$progress.set(r/s)):t==="loaded"?(e=await $t(this,vb,"f").predictionService.items().query({$select:["id","label","yTrue"]}).toArray(),this.$progress.set(!1)):t==="loading"?(e=[],this.$progress.set(null)):this.$progress.set(!1),this.updateConfusionMatrix(e),this.updateAccuracy(e)})}updateConfusionMatrix(e){const t=e.map(c=>c.label),r=e.map(c=>c.yTrue),s=Array.from(new Set(t.concat(r)));i_(s,this.$labels.value)||this.$labels.set(s);const i=s.length,o=s.reduce((c,u,h)=>({...c,[u]:h}),{}),a=Array.from(Array(i**2),()=>0);for(let c=0;c<t.length;c+=1)a[o[t[c]]*i+o[r[c]]]+=1;const l=a.map((c,u)=>({x:s[Math.floor(u/i)],y:s[u%i],v:c}));this.$confusion.set(l)}updateAccuracy(e){e.length===0?this.$accuracy.set(void 0):this.$accuracy.set(e.reduce((t,{label:r,yTrue:s})=>t+(r===s?1:0),0)/e.length)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new K2t({target:t,props:{title:this.title,loading:$t(this,vb,"f").$status.map(({status:r})=>r==="loading"),progress:this.$progress,confusion:this.$confusion,accuracy:this.$accuracy,labels:this.$labels,selected:this.$selected}}))}}vb=new WeakMap;function oue(...n){return new Y2t(...n)}const{window:G9}=Pxt;function H9(n,e,t){const r=n.slice();return r[27]=e[t][0],r[28]=e[t][1].loaded,r[29]=e[t][1].total,r[30]=e[t][1].instances,r}function j9(n,e,t){const r=n.slice();return r[33]=e[t].id,r[34]=e[t].thumbnail,r}function q9(n){let e,t,r,s,i;function o(f,d){return f[6]>0?J2t:Z2t}let a=o(n),l=a(n),c=Object.entries(n[5]),u=[];for(let f=0;f<c.length;f+=1)u[f]=Y9(H9(n,c,f));const h=f=>$e(u[f],1,1,()=>{u[f]=null});return{c(){l.c(),e=Ye(),t=we("div");for(let f=0;f<u.length;f+=1)u[f].c();Z(t,"class","flex flex-wrap")},m(f,d){l.m(f,d),me(f,e,d),me(f,t,d);for(let p=0;p<u.length;p+=1)u[p]&&u[p].m(t,null);r=!0,s||(i=[qn(t,"click",n[18]),qn(t,"keypress",XC(n[19]))],s=!0)},p(f,d){if(a===(a=o(f))&&l?l.p(f,d):(l.d(1),l=a(f),l&&(l.c(),l.m(e.parentNode,e))),d[0]&6560){c=Object.entries(f[5]);let p;for(p=0;p<c.length;p+=1){const m=H9(f,c,p);u[p]?(u[p].p(m,d),Ie(u[p],1)):(u[p]=Y9(m),u[p].c(),Ie(u[p],1),u[p].m(t,null))}for(dr(),p=c.length;p<u.length;p+=1)h(p);pr()}},i(f){if(!r){for(let d=0;d<c.length;d+=1)Ie(u[d]);r=!0}},o(f){u=u.filter(Boolean);for(let d=0;d<u.length;d+=1)$e(u[d]);r=!1},d(f){l.d(f),f&&de(e),f&&de(t),qs(u,f),s=!1,po(i)}}}function Z2t(n){let e;return{c(){e=we("p"),e.textContent="This dataset is empty.",Z(e,"class","ml-3 mt-2")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function J2t(n){let e,t,r,s,i=n[6]>1?"s":"",o,a;return{c(){e=we("p"),t=He("This dataset contains "),r=He(n[6]),s=He(" instance"),o=He(i),a=He("."),Z(e,"class","ml-3 mt-2")},m(l,c){me(l,e,c),se(e,t),se(e,r),se(e,s),se(e,o),se(e,a)},p(l,c){c[0]&64&&cn(r,l[6]),c[0]&64&&i!==(i=l[6]>1?"s":"")&&cn(o,i)},d(l){l&&de(e)}}}function X9(n,e){let t,r,s,i,o,a,l;function c(){return e[16](e[33])}return{key:n,first:null,c(){t=we("img"),Sv(t.src,r=e[34])||Z(t,"src",r),Z(t,"alt","thumbnail"),Z(t,"class","m-1 svelte-14ms951"),qt(t,"selected",e[7].includes(e[33])),this.first=t},m(u,h){me(u,t,h),o=!0,a||(l=qn(t,"click",Fxt(c)),a=!0)},p(u,h){e=u,(!o||h[0]&32&&!Sv(t.src,r=e[34]))&&Z(t,"src",r),(!o||h[0]&160)&&qt(t,"selected",e[7].includes(e[33]))},i(u){o||($u(()=>{o&&(i&&i.end(1),s=Kxt(t,qq,{}),s.start())}),o=!0)},o(u){s&&s.invalidate(),i=Yxt(t,qq,{}),o=!1},d(u){u&&de(t),u&&i&&i.end(),a=!1,l()}}}function K9(n){let e,t;function r(){return n[17](n[27])}return e=new zs({props:{size:"small",variant:"light",$$slots:{default:[Q2t]},$$scope:{ctx:n}}}),e.$on("click",r),{c(){It(e.$$.fragment)},m(s,i){kt(e,s,i),t=!0},p(s,i){n=s;const o={};i[1]&64&&(o.$$scope={dirty:i,ctx:n}),e.$set(o)},i(s){t||(Ie(e.$$.fragment,s),t=!0)},o(s){$e(e.$$.fragment,s),t=!1},d(s){Tt(e,s)}}}function Q2t(n){let e;return{c(){e=He("View More")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Y9(n){let e,t,r,s,i=n[27]+"",o,a,l,c,u,h=[],f=new Map,d,p,m,g;function y(...S){return n[15](n[27],...S)}l=new S1t({props:{actions:[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])}}),l.$on("select",y);let b=n[30];const x=S=>S[33];for(let S=0;S<b.length;S+=1){let C=j9(n,b,S),k=x(C);f.set(k,h[S]=X9(k,C))}let w=n[28]<n[29]&&K9(n);return{c(){e=we("div"),t=we("div"),r=we("div"),s=we("span"),o=He(i),a=Ye(),It(l.$$.fragment),c=Ye(),u=we("div");for(let S=0;S<h.length;S+=1)h[S].c();d=Ye(),p=we("div"),w&&w.c(),m=Ye(),Z(s,"class","browser-class-title svelte-14ms951"),Z(r,"class","browser-class-header svelte-14ms951"),Z(u,"class","browser-class-body svelte-14ms951"),Z(t,"class","w-full"),Z(p,"class","pb-1"),Z(e,"class","browser-class svelte-14ms951")},m(S,C){me(S,e,C),se(e,t),se(t,r),se(r,s),se(s,o),se(r,a),kt(l,r,null),se(t,c),se(t,u);for(let k=0;k<h.length;k+=1)h[k]&&h[k].m(u,null);se(e,d),se(e,p),w&&w.m(p,null),se(e,m),g=!0},p(S,C){n=S,(!g||C[0]&32)&&i!==(i=n[27]+"")&&cn(o,i);const k={};C[0]&128&&(k.actions=[{code:"edit",text:"Edit class label"},{code:"delete",text:"Delete class"}].concat(n[7].length>0?[{code:"deleteInstances",text:`Delete selected instance${n[7].length>1?"s":""}`},{code:"relabelInstances",text:`Relabel selected instance${n[7].length>1?"s":""}`}]:[])),l.$set(k),C[0]&2208&&(b=n[30],dr(),h=Ece(h,C,x,1,n,b,f,u,Tce,X9,null,j9),pr()),n[28]<n[29]?w?(w.p(n,C),C[0]&32&&Ie(w,1)):(w=K9(n),w.c(),Ie(w,1),w.m(p,null)):w&&(dr(),$e(w,1,1,()=>{w=null}),pr())},i(S){if(!g){Ie(l.$$.fragment,S);for(let C=0;C<b.length;C+=1)Ie(h[C]);Ie(w),g=!0}},o(S){$e(l.$$.fragment,S);for(let C=0;C<h.length;C+=1)$e(h[C]);$e(w),g=!1},d(S){S&&de(e),Tt(l);for(let C=0;C<h.length;C+=1)h[C].d();w&&w.d()}}}function Z9(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg class="inline flex-shrink-0 mr-3 w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg> 
      <div><span class="font-medium">Data Store connection Error!</span> This data store probably requires
        authentication</div>`,Z(e,"class","flex p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg dark:bg-red-200 dark:text-red-800"),Z(e,"role","alert")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function eCt(n){let e,t,r,s=n[5]&&!n[4]&&q9(n),i=n[4]&&Z9();return{c(){s&&s.c(),e=Ye(),i&&i.c(),t=mo()},m(o,a){s&&s.m(o,a),me(o,e,a),i&&i.m(o,a),me(o,t,a),r=!0},p(o,a){o[5]&&!o[4]?s?(s.p(o,a),a[0]&48&&Ie(s,1)):(s=q9(o),s.c(),Ie(s,1),s.m(e.parentNode,e)):s&&(dr(),$e(s,1,1,()=>{s=null}),pr()),o[4]?i||(i=Z9(),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i(o){r||(Ie(s),r=!0)},o(o){$e(s),r=!1},d(o){s&&s.d(o),o&&de(e),i&&i.d(o),o&&de(t)}}}function tCt(n){let e,t,r,s;return e=new ra({props:{title:n[0],loading:n[3],$$slots:{default:[eCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(i,o){kt(e,i,o),t=!0,r||(s=[qn(G9,"keydown",n[9]),qn(G9,"keyup",n[10])],r=!0)},p(i,o){const a={};o[0]&1&&(a.title=i[0]),o[0]&8&&(a.loading=i[3]),o[0]&240|o[1]&64&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){t||(Ie(e.$$.fragment,i),t=!0)},o(i){$e(e.$$.fragment,i),t=!1},d(i){Tt(e,i),r=!1,po(s)}}}function nCt(n,e,t){let r,s=tt,i=()=>(s(),s=os(h,G=>t(6,r=G)),h),o,a=tt,l=()=>(a(),a=os(d,G=>t(7,o=G)),d);n.$$.on_destroy.push(()=>s()),n.$$.on_destroy.push(()=>a());let{title:c}=e,{batchSize:u}=e,{count:h}=e;i();let{dataset:f}=e,{selected:d}=e;l();let p=!1,m=!1,g={};async function y(G){await f.ready;for await(const te of f.items().query({y:G,$sort:{updatedAt:-1}}).skip(g[G].loaded).take(u).select(["id","y","thumbnail"]))t(5,g[G].instances=[...g[G].instances,te],g),t(5,g[G].loaded+=1,g)}async function b(){if(p)return;t(3,p=!0);try{t(4,m=!1),await f.ready}catch{t(3,p=!1),t(4,m=!0);return}const G=await f.distinct("y");t(5,g=G.reduce((te,ge)=>({...te,[ge]:{total:0,loaded:0,instances:[]}}),{}));for(const te of G){const{total:ge}=await f.find({query:{$limit:0,y:te}});if(t(5,g[te].total=ge,g),u>0)await y(te);else for(;g[te].loaded<g[te].total;)await y(te)}t(3,p=!1)}function x(G){for(const[te,{instances:ge}]of Object.entries(g))if(ge.map(ae=>ae.id).includes(G))return te;return null}async function w(){let G=Promise.resolve();for(const te of d.get())G=G.then(()=>f.remove(te));await G,d.set([])}async function S(G){let te=Promise.resolve();for(const ge of d.get())te=te.then(()=>f.patch(ge,{y:G}));await te,d.set([])}let C=!1,k=!1;function A(G){["Meta","Control"].includes(G.key)?C=!0:G.key==="Shift"?k=!0:(G.key==="Delete"||G.key==="Backspace"&&C)&&w()}function M(G){["Meta","Control"].includes(G.key)?C=!1:G.key==="Shift"&&(k=!1)}let E=null;function N(G){if(C){if(!G)return;d.get().includes(G)?d.set(d.get().filter(te=>te!==G)):d.set(d.get().concat([G]))}else if(k){if(!E||!G)return;const te=x(E),ge=x(G);if(te!==ge)return;const ae=g[te].instances.map(De=>De.id),Ne=ae.indexOf(E),ke=ae.indexOf(G);d.set(Ne<ke?ae.slice(Ne,ke+1):ae.slice(ke,Ne+1))}else d.set(G?[G]:[]),E=G}function O(G,te){let ge;switch(te){case"edit":ge=window.prompt("Enter the new label",G),ge&&f.patch(null,{y:ge},{query:{y:G}});break;case"delete":f.remove(null,{query:{y:G}});break;case"deleteInstances":w();break;case"relabelInstances":ge=window.prompt("Enter the new label",G),ge&&S(ge);break;default:alert(`Class ${G}: ${te}`);break}}Nu(()=>{b(),f.$changes.subscribe(async G=>{for(const{level:te,type:ge,data:ae}of G)if(te==="dataset")ge==="created"&&(N(),b());else if(te==="instance")if(ge==="created")g[ae.y]||t(5,g[ae.y]={total:0,loaded:0,instances:[]},g),t(5,g[ae.y].total+=1,g),t(5,g[ae.y].loaded+=1,g),t(5,g[ae.y].instances=[{id:ae.id,y:ae.y,thumbnail:ae.thumbnail},...g[ae.y].instances],g);else if(ge==="updated"){const Ne=x(ae.id);t(5,g[Ne].total-=1,g),t(5,g[Ne].loaded-=1,g),t(5,g[Ne].instances=g[Ne].instances.filter(({id:ke})=>ke!==ae.id),g),g[Ne].total===0&&(delete g[Ne],t(5,g)),g[ae.y]||t(5,g[ae.y]={total:0,loaded:0,instances:[]},g),t(5,g[ae.y].instances=[{id:ae.id,y:ae.y,thumbnail:ae.thumbnail},...g[ae.y].instances],g)}else ge==="removed"&&(t(5,g[ae.y].total-=1,g),t(5,g[ae.y].loaded-=1,g),t(5,g[ae.y].instances=g[ae.y].instances.filter(({id:Ne})=>Ne!==ae.id),g),g[ae.y].total===0&&(delete g[ae.y],t(5,g)))})});const R=(G,te)=>O(G,te.detail),D=G=>N(G),z=G=>y(G),B=()=>N(),X=G=>G.key==="Escape"&&N();return n.$$set=G=>{"title"in G&&t(0,c=G.title),"batchSize"in G&&t(13,u=G.batchSize),"count"in G&&i(t(1,h=G.count)),"dataset"in G&&t(14,f=G.dataset),"selected"in G&&l(t(2,d=G.selected))},[c,h,d,p,m,g,r,o,y,A,M,N,O,u,f,R,D,z,B,X]}class rCt extends xn{constructor(e){super(),wn(this,e,nCt,tCt,pn,{title:0,batchSize:13,count:1,dataset:14,selected:2},null,[-1,-1])}}var q1;class sCt extends Ia{constructor(e,{batchSize:t=6}={}){super(),this.title="dataset browser",q1.set(this,void 0),this.$selected=new mt([],!0),ir(this,q1,e,"f"),this.batchSize=t,this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new rCt({target:t,props:{title:this.title,batchSize:this.batchSize,count:$t(this,q1,"f").$count,dataset:$t(this,q1,"f"),selected:this.$selected}}))}}q1=new WeakMap;function aue(...n){return new sCt(...n)}function iCt(n){let e;return{c(){e=we("canvas"),Z(e,"class","w-full max-w-full")},m(t,r){me(t,e,r),n[3](e)},p:tt,d(t){t&&de(e),n[3](null)}}}function oCt(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[iCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&34&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function aCt(n,e,t){let{title:r}=e,{imageStream:s}=e,i,o=zb;Nu(async()=>{await ea(),await ea();const l=i.getContext("2d");o=s.subscribe(c=>{if(!(Array.isArray(c)&&c.length===0)){if(c instanceof ImageData)t(1,i.width=c.width,i),t(1,i.height=c.height,i),l.putImageData(c,0,0);else if(Array.isArray(c))throw new Error("This component does not yet support multiple images")}})}),$g(()=>{o()});function a(l){hi[l?"unshift":"push"](()=>{i=l,t(1,i)})}return n.$$set=l=>{"title"in l&&t(0,r=l.title),"imageStream"in l&&t(2,s=l.imageStream)},[r,i,s,a]}class lCt extends xn{constructor(e){super(),wn(this,e,aCt,oCt,pn,{title:0,imageStream:2})}get title(){return this.$$.ctx[0]}set title(e){this.$$set({title:e}),Rg()}get imageStream(){return this.$$.ctx[2]}set imageStream(e){this.$$set({imageStream:e}),Rg()}}var dI;class cCt extends Ia{constructor(e){super(),this.title="image display",dI.set(this,void 0),ir(this,dI,e,"f")}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new lCt({target:t,props:{title:this.title,imageStream:$t(this,dI,"f")}}))}}dI=new WeakMap;function lue(...n){return new cCt(...n)}function J9(n,e,t){const r=n.slice();return r[18]=e[t],r}function Q9(n){let e;return{c(){e=we("div"),e.innerHTML=`<i><svg class="fill-current w-12 h-12 mb-3 text-blue-700" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19.479 10.092c-.212-3.951-3.473-7.092-7.479-7.092-4.005 0-7.267 3.141-7.479 7.092-2.57.463-4.521 2.706-4.521 5.408 0 3.037 2.463 5.5 5.5 5.5h13c3.037 0 5.5-2.463 5.5-5.5 0-2.702-1.951-4.945-4.521-5.408zm-7.479-1.092l4 4h-3v4h-2v-4h-3l4-4z"></path></svg></i> 
      <p class="text-lg text-blue-700">Drop files to upload</p>`,Z(e,"class","overlay svelte-u8vb5e")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function uCt(n){let e;return{c(){e=He("Upload a file")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function e7(n){let e,t;return{c(){e=we("img"),Z(e,"class","mx-auto my-2 w-32"),Sv(e.src,t=n[18]||"https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png")||Z(e,"src",t),Z(e,"alt","no data")},m(r,s){me(r,e,s)},p(r,s){s&8&&!Sv(e.src,t=r[18]||"https://user-images.githubusercontent.com/507615/54591670-ac0a0180-4a65-11e9-846c-e55ffce0fe7b.png")&&Z(e,"src",t)},d(r){r&&de(e)}}}function hCt(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p=n[2]&&Q9();l=new zs({props:{$$slots:{default:[uCt]},$$scope:{ctx:n}}}),l.$on("click",n[8]);let m=n[3],g=[];for(let y=0;y<m.length;y+=1)g[y]=e7(J9(n,m,y));return{c(){p&&p.c(),e=Ye(),t=we("div"),r=we("div"),s=we("p"),s.innerHTML="<span>Drag and drop an image or</span>",i=Ye(),o=we("input"),a=Ye(),It(l.$$.fragment),c=Ye(),u=we("div");for(let y=0;y<g.length;y+=1)g[y].c();Z(s,"class","mb-3 font-semibold text-gray-900 flex flex-wrap justify-center"),Z(o,"type","file"),o.multiple=!0,Z(o,"class","hidden"),Z(r,"class","border-dashed border-2 border-gray-300 py-8 flex flex-col justify-center items-center"),Z(u,"class","flex flex-wrap"),Z(t,"class","image-upload svelte-u8vb5e")},m(y,b){p&&p.m(y,b),me(y,e,b),me(y,t,b),se(t,r),se(r,s),se(r,i),se(r,o),n[13](o),se(r,a),kt(l,r,null),se(t,c),se(t,u);for(let x=0;x<g.length;x+=1)g[x]&&g[x].m(u,null);h=!0,f||(d=[qn(t,"dragenter",n[4]),qn(t,"dragleave",n[5]),qn(t,"dragover",n[6]),qn(t,"drop",n[7])],f=!0)},p(y,b){y[2]?p||(p=Q9(),p.c(),p.m(e.parentNode,e)):p&&(p.d(1),p=null);const x={};if(b&2097152&&(x.$$scope={dirty:b,ctx:y}),l.$set(x),b&8){m=y[3];let w;for(w=0;w<m.length;w+=1){const S=J9(y,m,w);g[w]?g[w].p(S,b):(g[w]=e7(S),g[w].c(),g[w].m(u,null))}for(;w<g.length;w+=1)g[w].d(1);g.length=m.length}},i(y){h||(Ie(l.$$.fragment,y),h=!0)},o(y){$e(l.$$.fragment,y),h=!1},d(y){p&&p.d(y),y&&de(e),y&&de(t),n[13](null),Tt(l),qs(g,y),f=!1,po(d)}}}function fCt(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[hCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&2097166&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function dCt(n,e,t){let{title:r}=e,{images:s}=e,{thumbnails:i}=e,{width:o}=e,{height:a}=e,l,c=0,u=!1,h=[];const f=({dataTransfer:{types:S=[]}})=>S.indexOf("Files")>-1;function d(S){S.preventDefault(),f(S)&&(c+=1,t(2,u=!0))}function p(){c-=1,c<1&&t(2,u=!1)}function m(S){f(S)&&S.preventDefault()}async function g(S){const{image:C}=await Sj(S,{...o>0&&{maxWidth:o},...a>0&&{maxHeight:a},cover:!0,crop:!0,canvas:!0,crossOrigin:"Anonymous"}),{image:k}=await Sj(S,{maxWidth:60,maxHeight:60,cover:!0,crop:!0,canvas:!0,crossOrigin:"Anonymous"}),A=C,M=A.getContext("2d").getImageData(0,0,o||A.width,a||A.height),N=k.toDataURL("image/jpeg");i.set(N),s.set(M)}async function y(S){t(3,h=[]);let C=Promise.resolve();for(let k=0;k<S.length;k++){const A=S[k];A.type.match("image.*")&&(C=C.then(()=>g(A))),t(2,u=!1),c=0}await C}function b(S){S.preventDefault(),y(S.dataTransfer.files)}Nu(async()=>{await ea(),await ea(),l.addEventListener("change",S=>{y(S.target.files)})});function x(){l&&l.click()}function w(S){hi[S?"unshift":"push"](()=>{l=S,t(1,l)})}return n.$$set=S=>{"title"in S&&t(0,r=S.title),"images"in S&&t(9,s=S.images),"thumbnails"in S&&t(10,i=S.thumbnails),"width"in S&&t(11,o=S.width),"height"in S&&t(12,a=S.height)},[r,l,u,h,d,p,m,b,x,s,i,o,a,w]}class pCt extends xn{constructor(e){super(),wn(this,e,dCt,fCt,pn,{title:0,images:9,thumbnails:10,width:11,height:12})}}var pI,mI;class mCt extends Ia{constructor({width:e=0,height:t=0}={}){super(),this.title="image upload",this.$images=new mt(P_()),this.$thumbnails=new mt(P_()),pI.set(this,void 0),mI.set(this,void 0),ir(this,pI,e,"f"),ir(this,mI,t,"f"),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new pCt({target:t,props:{title:this.title,images:this.$images,thumbnails:this.$thumbnails,width:$t(this,pI,"f"),height:$t(this,mI,"f")}}))}}pI=new WeakMap,mI=new WeakMap;function gCt(...n){return new mCt(...n)}function yCt(n,e){return n.map((t,r)=>Math.abs(t-e[r])**2).reduce((t,r)=>t+r)**(1/2)}class ZV extends r0{constructor({k:e=3}={}){super(),this.title="k-means clustering",this.serviceName="kmeans-models",this.parameters={k:new mt(e,!0)},this.$centers=new mt([],!1),this.$clusters=new mt([],!1),this.dataset=[],this.start()}async train(e){this.$training.set({status:"start",epochs:1});const t=Ff(e)?e.items():e;for await(const{x:s}of t)this.dataset.push(s);const r=oft(this.dataset,this.parameters.k.get());this.$centers.set(r.centroids.map(s=>s.centroid)),this.$clusters.set(r.clusters),this.$training.set({status:"success"})}async predict(e){let t=0,r=1e3;const s={};let i=0;for(let o=0;o<this.$centers.get().length;o++){const a=yCt(this.$centers.get()[o],e);a<r&&(r=a,t=o),s[`${o}`]=Math.exp(a),i+=Math.exp(a)}if(Object.entries(s).forEach(([o])=>{s[o]/=i}),this.$centers.get().length===0){const o=new Error("KMeans is not trained");o.name="[KMeans] Prediction Error",Ta(o)}return{cluster:t,confidences:s}}async batchPredict(e){const t=[],r=Ff(e)?e.items():e;for await(const{x:i}of r)t.push(i);const s=[];for(let i=0;i<t.length;i++)this.predict(t[i]).then(o=>s.push(o));if(this.$centers.get().length===0){const i=new Error("KMeans is not trained");i.name="[KMeans] Prediction Error",Ta(i)}return s}async save(e,t,r,s=null){const i=await this.write(r);return i.name=t,this.saveToDatastore(e,i,s)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);VS(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(s=>s.name.includes(".json")),r=await new Promise((s,i)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);s(a)},o.onerror=i,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){return{name:KC(this.title),files:[],format:"ml-kmeans",metadata:{clusters:this.$clusters.get(),centers:this.$centers.get(),...e}}}async read(e){const t=e.metadata.data;t&&(Object.entries(t).forEach(([r,s])=>{}),this.$clusters.set(e.metadata.labels),this.$training.set({status:"loaded"}))}}Dn([Ln],ZV.prototype,"train",null);Dn([Ln],ZV.prototype,"predict",null);Dn([Ln],ZV.prototype,"batchPredict",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.flatten=function(){return this.throwIfDisposed(),fx(this,[this.size])};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bCt(n){const e=$i(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return ws.runKernel(kSt,t)}else{const t={x:e};return ws.runKernel(xSt,t)}}const xd=sa({abs_:bCt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vCt(n,e){const t=$i(n,"x","cast");if(!cSt(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return ws.runKernel(Xce,r,s)}const cue=sa({cast_:vCt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wCt(n,e,t=!1,r=!1){let s=$i(n,"a","matMul"),i=$i(e,"b","matMul");[s,i]=YV(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return ws.runKernel(CSt,o,a)}const xCt=sa({matMul_:wCt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ct(n,e){let t=$i(n,"a","mul"),r=$i(e,"b","mul");[t,r]=YV(t,r);const s={a:t,b:r};return ws.runKernel(NSt,s)}const SCt=sa({mul_:_Ct});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CCt(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function kCt(n,e){const t=e.map(r=>1);return CCt(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TCt(n,e=null,t=!1){const s={x:$i(n,"x","max")},i={reductionIndices:e,keepDims:t};return ws.runKernel(ASt,s,i)}const tD=sa({max_:TCt});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECt(n,e=null,t=!1){const s={x:$i(n,"x","min")},i={axis:e,keepDims:t};return ws.runKernel(MSt,s,i)}const t7=sa({min_:ECt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ICt(n,e){let t=$i(n,"base","pow"),r=$i(e,"exp","pow");[t,r]=YV(t,r);const s={a:t,b:r};return ws.runKernel($St,s)}const ACt=sa({pow_:ICt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MCt(n,e,t,r){if(r==null)r=qV(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Qce(n)||Jce(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ws.backend.createTensorFromGPUData(n,e||t,r)}if(!Ru(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){pSt(e);const s=Bb(e),i=Bb(t);Bi(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Bb(e.slice(o)):!0;Bi(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ru(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Yce(n,r):US(n,[],!0),ws.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NCt(n,e){if((Ru(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ru(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return MCt(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ct(n){const t={x:$i(n,"x","sqrt","float32")};return ws.runKernel(PSt,t)}const n7=sa({sqrt_:$Ct});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RCt(n){const e=$i(n,"x","square"),t={};return ws.runKernel("Square",{x:e},t)}const PCt=sa({square_:RCt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCt(n,e=null,t=!1){let r=$i(n,"x","sum");r.dtype==="bool"&&(r=cue(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return ws.runKernel(DSt,s,i)}const ub=sa({sum_:DCt});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OCt(n,e="euclidean",t=null,r=!1){n=$i(n,"x","norm");const s=uue(n,e,t);let i=s.shape;if(r){const o=Uce(t,n.shape);i=kCt(s.shape,o)}return fx(s,i)}function uue(n,e,t=null){if(n.rank===0)return xd(n);if(n.rank!==1&&t===null)return uue(fx(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ub(xd(n),t);if(e===1/0)return tD(xd(n),t);if(e===-1/0)return t7(xd(n),t);if(e==="euclidean"||e===2)return n7(ub(ACt(xd(n),NCt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return tD(ub(xd(n),t[0]),t[1]-1);if(e===1/0)return tD(ub(xd(n),t[1]),t[0]);if(e===-1/0)return t7(ub(xd(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return n7(ub(PCt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const FCt=sa({norm_:OCt});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.norm=function(n,e,t){return this.throwIfDisposed(),FCt(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),xCt(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.as1D=function(){return this.throwIfDisposed(),fx(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.as2D=function(n,e){return this.throwIfDisposed(),fx(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.asType=function(n){return this.throwIfDisposed(),cue(this,n)};class hue extends r0{constructor({k:e=3}={}){super(),this.title="KNN classifier",this.serviceName="knn-classifier-models",this.classifier=new hft,this.parameters={k:new mt(e,!0)}}async train(e){this.labels=Ff(e)?await e.distinct("y"):this.labels=Array.from(new Set(await e.map(({y:r})=>r).toArray()));const t=Ff(e)?e.items():e;if(this.labels.length<1)throw this.$training.set({status:"error"}),new Error("Cannot train a kNN with no classes");this.$training.set({status:"start",epochs:1}),this.classifier.clearAllClasses();for await(const{x:r,y:s}of t)this.classifier.addExample(Ei(r),s);this.$training.set({status:"success"})}async predict(e){if(!this.classifier||!this.labels||this.labels.length<1)return{label:void 0,confidences:{}};const{label:t,confidences:r}=await this.classifier.predictClass(Ei(e),this.parameters.k.get());return{label:t,confidences:r}}clear(){delete this.classifier}async save(e,t,r,s=null){const i=await this.write(r);return i.name=t,this.saveToDatastore(e,i,s)}async load(e,t){const r=await this.loadFromDatastore(e,t);return await this.read(r),r}async download(e){const t=await this.write(e);VS(JSON.stringify(t),`${t.name}.json`,"text/plain")}async upload(...e){const t=e.filter(s=>s.name.includes(".json")),r=await new Promise((s,i)=>{const o=new FileReader;o.onload=()=>{const a=JSON.parse(o.result);s(a)},o.onerror=i,o.readAsText(t[0])});return await this.read(r),r}async write(e={}){if(!this.classifier)return null;const t=this.classifier.getClassifierDataset(),r={};for(const i of Object.keys(t)){const o=t[i].arraySync();r[i]=o}return{name:KC(this.title),files:[],format:"knn-classifier",metadata:{labels:this.labels,data:r,...e}}}async read(e){const t=e.metadata.data;if(!t)return;const r={};for(const[s,i]of Object.entries(t))r[s]=qa(i);this.labels=e.metadata.labels,this.classifier.setClassifierDataset(r),this.$training.set({status:"loaded"})}}Dn([Ln],hue.prototype,"train",null);Dn([Ln],hue.prototype,"predict",null);class LCt extends rue{constructor({layers:e=[64,32],...t}={}){super(t),this.title="MLPClassifier",this.parameters={layers:new mt(e,!0),...this.parameters}}buildModel(e,t){this.model=srt();for(const[s,i]of this.parameters.layers.get().entries()){const o={units:i,activation:"relu"};s===0&&(o.inputDim=e[0]),this.model.add(I6(o))}this.model.add(I6({units:t[0],activation:"softmax"}));const r=Sd.adam();this.model.compile({optimizer:r,loss:"categoricalCrossentropy",metrics:["accuracy"]})}}function zCt(...n){return new LCt(...n)}function BCt(n){let e,t,r,s,i;return{c(){e=He("Using Mobilenet v"),t=He(n[2]),r=He(" with alpha = "),s=He(n[3]),i=He(".")},m(o,a){me(o,e,a),me(o,t,a),me(o,r,a),me(o,s,a),me(o,i,a)},p(o,a){a&4&&cn(t,o[2]),a&8&&cn(s,o[3])},d(o){o&&de(e),o&&de(t),o&&de(r),o&&de(s),o&&de(i)}}}function VCt(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function UCt(n){let e;function t(i,o){return i[4]?VCt:BCt}let r=t(n),s=r(n);return{c(){e=we("p"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function WCt(n){let e,t;return e=new ra({props:{title:n[0],loading:n[4],$$slots:{default:[UCt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&16&&(i.loading=r[4]),s&60&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function GCt(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,u=>t(4,r=u)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{version:l}=e,{alpha:c}=e;return n.$$set=u=>{"title"in u&&t(0,o=u.title),"loading"in u&&i(t(1,a=u.loading)),"version"in u&&t(2,l=u.version),"alpha"in u&&t(3,c=u.alpha)},[o,a,l,c,r]}class HCt extends xn{constructor(e){super(),wn(this,e,GCt,WCt,pn,{title:0,loading:1,version:2,alpha:3})}}var ff;class px extends r0{constructor({version:e=1,alpha:t=1}={}){if(super(),this.title="mobileNet",this.parameters={},this.serviceName="undefined",ff.set(this,void 0),this.$loading=new mt(!0,!0),![1,2].includes(e))throw new Error("Mobilenet version must be 1 or 2");if(![.25,.5,.75,1].includes(t))throw new Error("Mobilenet alpha must be 0.25 | 0.50 | 0.75 | 1.0");this.version=e,this.alpha=t,this.setup()}async setup(){await j2();const e=await LL(),t=Object.keys(e).filter(r=>r.includes("mobileNet"));try{ir(this,ff,await Mj({modelUrl:`indexeddb://mobilenet-v${this.version}-${this.alpha}`,version:this.version,alpha:this.alpha}),"f")}catch{t.length>0&&await zL(t[0]),ir(this,ff,await Mj({version:this.version,alpha:this.alpha}),"f"),await $t(this,ff,"f").model.save(`indexeddb://mobilenet-v${this.version}-${this.alpha}`)}return ga.info(`MobileNet v${this.version} loaded with alpha = ${this.alpha}`),this.$loading.set(!1),this.start(),this}async process(e){return $t(this,ff,"f")?Se(()=>$t(this,ff,"f").infer(e,!0).arraySync()[0]):[]}async predict(e){if(!$t(this,ff,"f"))throw new Error("Mobilenet is not loaded");const t=await $t(this,ff,"f").classify(e,5);return{label:t[0].className,confidences:t.reduce((r,s)=>({...r,[s.className]:s.probability}),{})}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new HCt({target:t,props:{title:this.title,loading:this.$loading,version:this.version,alpha:this.alpha}}))}train(){throw new Sp("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}ff=new WeakMap;Dn([Ln],px.prototype,"train",null);Dn([Ln],px.prototype,"save",null);Dn([Ln],px.prototype,"load",null);Dn([Ln],px.prototype,"download",null);Dn([Ln],px.prototype,"upload",null);function jCt(...n){return new px(...n)}function qCt(n){let e,t,r;function s(o){n[7](o)}let i={type:"text"};return n[2]!==void 0&&(i.value=n[2]),e=new s1t({props:i}),hi.push(()=>Zf(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],Yf(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function XCt(n){let e,t,r;function s(o){n[6](o)}let i={};return n[2]!==void 0&&(i.value=n[2]),e=new v1t({props:i}),hi.push(()=>Zf(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],Yf(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function KCt(n){let e,t,r;function s(o){n[5](o)}let i={};return n[2]!==void 0&&(i.value=n[2]),e=new g1t({props:i}),hi.push(()=>Zf(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.value=o[2],Yf(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function YCt(n){let e,t,r;function s(o){n[4](o)}let i={};return n[2]!==void 0&&(i.checked=n[2]),e=new N1t({props:i}),hi.push(()=>Zf(e,"checked",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};!t&&a&4&&(t=!0,l.checked=o[2],Yf(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function ZCt(n){let e,t,r;function s(o){n[3](o)}let i={options:n[1].options};return n[2]!==void 0&&(i.value=n[2]),e=new Mce({props:i}),hi.push(()=>Zf(e,"value",s)),{c(){It(e.$$.fragment)},m(o,a){kt(e,o,a),r=!0},p(o,a){const l={};a&2&&(l.options=o[1].options),!t&&a&4&&(t=!0,l.value=o[2],Yf(()=>t=!1)),e.$set(l)},i(o){r||(Ie(e.$$.fragment,o),r=!0)},o(o){$e(e.$$.fragment,o),r=!1},d(o){Tt(e,o)}}}function JCt(n){let e,t,r,s,i,o,a,l;const c=[ZCt,YCt,KCt,XCt,qCt],u=[];function h(f,d){return d&2&&(t=null),d&3&&(r=null),d&3&&(s=null),d&3&&(i=null),t==null&&(t=!!(f[1].type==="menu"&&Array.isArray(f[1].options)&&f[1].options.length>0)),t?0:(r==null&&(r=f[1].type==="boolean"||f[1].type==="auto"&&typeof f[0].get()=="boolean"),r?1:(s==null&&(s=f[1].type==="number"||f[1].type==="auto"&&typeof f[0].get()=="number"),s?2:(i==null&&(i=!!(f[1].type==="number array"||f[1].type==="auto"&&Array.isArray(f[0].get())&&f[0].get().length&&typeof f[0].get()[0]=="number")),i?3:4)))}return o=h(n,-1),a=u[o]=c[o](n),{c(){e=we("div"),a.c(),lu(e,"flex-grow","1")},m(f,d){me(f,e,d),u[o].m(e,null),l=!0},p(f,[d]){let p=o;o=h(f,d),o===p?u[o].p(f,d):(dr(),$e(u[p],1,1,()=>{u[p]=null}),pr(),a=u[o],a?a.p(f,d):(a=u[o]=c[o](f),a.c()),Ie(a,1),a.m(e,null))},i(f){l||(Ie(a),l=!0)},o(f){$e(a),l=!1},d(f){f&&de(e),u[o].d()}}}function QCt(n,e,t){let r,s=tt,i=()=>(s(),s=os(o,d=>t(2,r=d)),o);n.$$.on_destroy.push(()=>s());let{stream:o}=e;i();let{spec:a}=e;function l(d){r=d,o.set(r)}function c(d){r=d,o.set(r)}function u(d){r=d,o.set(r)}function h(d){r=d,o.set(r)}function f(d){r=d,o.set(r)}return n.$$set=d=>{"stream"in d&&i(t(0,o=d.stream)),"spec"in d&&t(1,a=d.spec)},[o,a,r,l,c,u,h,f]}class fue extends xn{constructor(e){super(),wn(this,e,QCt,JCt,pn,{stream:0,spec:1})}}function r7(n,e,t){const r=n.slice();return r[4]=e[t][0],r[5]=e[t][1],r}function ekt(n){let e,t;return e=new fue({props:{stream:n[5],spec:{type:"auto"}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&2&&(i.stream=r[5]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function tkt(n){let e,t;return e=new fue({props:{stream:n[5],spec:n[2][n[4]]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&2&&(i.stream=r[5]),s&6&&(i.spec=r[2][r[4]]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function s7(n){let e,t,r=n[4]+"",s,i,o,a,l,c;const u=[tkt,ekt],h=[];function f(d,p){return d[4]in d[2]?0:1}return o=f(n),a=h[o]=u[o](n),{c(){e=we("div"),t=we("p"),s=He(r),i=Ye(),a.c(),l=Ye(),Z(t,"class","w-32 my-2"),Z(e,"class","flex my-1 items-center")},m(d,p){me(d,e,p),se(e,t),se(t,s),se(e,i),h[o].m(e,null),se(e,l),c=!0},p(d,p){(!c||p&2)&&r!==(r=d[4]+"")&&cn(s,r);let m=o;o=f(d),o===m?h[o].p(d,p):(dr(),$e(h[m],1,1,()=>{h[m]=null}),pr(),a=h[o],a?a.p(d,p):(a=h[o]=u[o](d),a.c()),Ie(a,1),a.m(e,l))},i(d){c||(Ie(a),c=!0)},o(d){$e(a),c=!1},d(d){d&&de(e),h[o].d()}}}function nkt(n){let e,t,r=Object.entries(n[1]),s=[];for(let o=0;o<r.length;o+=1)s[o]=s7(r7(n,r,o));const i=o=>$e(s[o],1,1,()=>{s[o]=null});return{c(){e=we("div");for(let o=0;o<s.length;o+=1)s[o].c();Z(e,"class","m-2")},m(o,a){me(o,e,a);for(let l=0;l<s.length;l+=1)s[l]&&s[l].m(e,null);t=!0},p(o,a){if(a&6){r=Object.entries(o[1]);let l;for(l=0;l<r.length;l+=1){const c=r7(o,r,l);s[l]?(s[l].p(c,a),Ie(s[l],1)):(s[l]=s7(c),s[l].c(),Ie(s[l],1),s[l].m(e,null))}for(dr(),l=r.length;l<s.length;l+=1)i(l);pr()}},i(o){if(!t){for(let a=0;a<r.length;a+=1)Ie(s[a]);t=!0}},o(o){s=s.filter(Boolean);for(let a=0;a<s.length;a+=1)$e(s[a]);t=!1},d(o){o&&de(e),qs(s,o)}}}function rkt(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[nkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&262&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function skt(n,e,t){let{title:r}=e,{parameters:s}=e,{config:i={}}=e,o=[];return n.$$set=a=>{"title"in a&&t(0,r=a.title),"parameters"in a&&t(1,s=a.parameters),"config"in a&&t(2,i=a.config)},n.$$.update=()=>{if(n.$$.dirty&10){for(const a of o)a();t(3,o=Object.values(s).map(a=>a.subscribe()))}},[r,s,i,o]}class ikt extends xn{constructor(e){super(),wn(this,e,skt,rkt,pn,{title:0,parameters:1,config:2})}}var gI;class okt extends Ia{constructor(e,t={}){super(),this.title="modelParameters",gI.set(this,void 0),ir(this,gI,e,"f"),this.config=t}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new ikt({target:t,props:{title:this.title,parameters:$t(this,gI,"f").parameters,config:this.config}}))}}gI=new WeakMap;function akt(n,e={}){if(!n.parameters)throw new Error("The argument is not a valid component with parameters");return new okt(n,e)}function lkt(n){let e;return{c(){e=we("p"),e.textContent="No model loaded"},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function ckt(n){let e,t,r,s;return{c(){e=we("p"),t=He("Model Loaded from "),r=He(n[2]),s=He(".")},m(i,o){me(i,e,o),se(e,t),se(e,r),se(e,s)},p(i,o){o&4&&cn(r,i[2])},d(i){i&&de(e)}}}function ukt(n){let e;return{c(){e=we("p"),e.textContent="Loading Model..."},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function hkt(n){let e;function t(i,o){return i[3]==="loading"?ukt:i[3]==="loaded"?ckt:lkt}let r=t(n),s=r(n);return{c(){e=we("div"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function fkt(n){let e,t;return e=new ra({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[hkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]==="loading"),s&268&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function dkt(n,e,t){let r,s,i,o=tt,a=()=>(o(),o=os(f,d=>t(7,i=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=i.status),n.$$.dirty&240&&t(2,s=!(t(4,l=i.data)===null||l===void 0)&&l.source?i.data.source==="datastore"?`datastore at ${t(5,c=i.data)===null||c===void 0?void 0:c.url}`:i.data.source==="url"?`url ${t(6,u=i.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,s,r,l,c,u,i]}class pkt extends xn{constructor(e){super(),wn(this,e,dkt,fkt,pn,{title:0,training:1})}}var df;function i7(n,e){return n===e}function o7(n,e){return n===e}class Gu extends r0{constructor({inputType:e,taskType:t,inputShape:r}){super(),this.title="onnx model",this.parameters={},this.serviceName="onnx-models",this.$loading=new mt(!1,!0),this.$ready=new mt(!1,!0),this.modelName="",this.lockLoading=Promise.resolve(),df.set(this,void 0),this.inputType=e,this.taskType=t,this.inputShape=r,this.start()}train(){throw new Sp("Model `OnnxModel` cannot be trained")}async predict(e){if(!$t(this,df,"f")||!this.$ready.get())throw new Error("Model is not loaded");const t=this.preprocess(e),r=await $t(this,df,"f").run({[$t(this,df,"f").inputNames[0]]:t});return await this.postprocess(r)}async loadFromUrl(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{await this.loadModel(e,e),this.$training.set({status:"loaded",data:{source:"url",url:e}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}async loadFromFile(e){if(e){this.$training.set({status:"loading"}),this.$ready.set(!1),this.$loading.set(!0);try{const t=await new Promise((r,s)=>{const i=new FileReader;i.onload=function(){const a=this.result;r(a)},i.onerror=function(){s()},i.readAsArrayBuffer(e)});await this.loadModel(t,e.name),this.$training.set({status:"loaded",data:{source:"file"}}),this.$loading.set(!1),this.$ready.set(!0)}catch(t){throw this.$training.set({status:"error"}),this.$loading.set(!1),t}}}async loadModel(e,t){this.ready=!1,this.lockLoading=this.lockLoading.then(()=>ort.InferenceSession.create(e)).then(r=>{ir(this,df,r,"f")}),await this.lockLoading,this.modelName=t;try{await this.warmup()}catch(r){console.log("ONNX Model warmup failed",r)}this.ready=!0}preprocess(e){if(i7(this.inputType,"image"))return this.preprocessImage(e);if(i7(this.inputType,"generic")){const t=e.flat().flat().flat().flat().flat();return new ort.Tensor("float32",Float32Array.from(t),this.inputShape)}throw new Error("Invalid input data type")}preprocessImage(e){throw new Error("ONNX for Images: Not yet implemented")}async postprocess(e){if(o7(this.taskType,"classification")){const t=this.labels?s=>this.labels[s]:s=>s.toString(),r=Array.from(e.probabilities.data).reduce((s,i,o)=>({...s,[t(o)]:i}),{});return{label:t(e.label.data[0]),confidences:r}}if(o7(this.taskType,"generic")){const t={};for(const r of $t(this,df,"f").outputNames)t[r]=Array.from(e[r].data);return t}throw new Error("Invalid output data type")}async warmup(){const e=Float32Array.from(Array(this.inputShape.reduce((r,s)=>r*s,1)),()=>Math.random()),t=new ort.Tensor("float32",e,this.inputShape);await $t(this,df,"f").run({[$t(this,df,"f").inputNames[0]]:t})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new pkt({target:t,props:{title:this.title,training:this.$training}}))}save(){throw new Error("OnnxModel does not support saving")}load(){throw new Error("OnnxModel does not support loading")}download(){throw new Error("OnnxModel does not support downloading")}upload(){throw new Error("OnnxModel does not support uploading")}}df=new WeakMap;Dn([Ln],Gu.prototype,"train",null);Dn([Ln],Gu.prototype,"predict",null);Dn([Ln],Gu.prototype,"loadFromUrl",null);Dn([Ln],Gu.prototype,"loadFromFile",null);Dn([Ln],Gu.prototype,"loadModel",null);Dn([Ln],Gu.prototype,"preprocess",null);Dn([Ln],Gu.prototype,"postprocess",null);Dn([Ln],Gu.prototype,"save",null);Dn([Ln],Gu.prototype,"load",null);Dn([Ln],Gu.prototype,"download",null);Dn([Ln],Gu.prototype,"upload",null);const mkt={MoveNet:.35,PoseNet:.5,BlazePose:.65},gkt=["#ffffff","#800000","#469990","#e6194b","#42d4f4","#fabed4","#aaffc3","#9a6324","#000075","#f58231","#4363d8","#ffd8b1","#dcbeff","#808000","#ffe119","#911eb4","#bfef45","#f032e6","#3cb44b","#a9a9a9"];class a7{constructor(e,t){this.model=e,this.width=t,this.params={lineWidth:2,radius:4,scoreThreshold:mkt[e]},this.canvas=document.createElement("canvas"),this.canvas.width=this.width,this.canvas.height=this.width,this.ctx=this.canvas.getContext("2d")}drawKeypoint(e){if((e.score!=null?e.score:1)>=this.params.scoreThreshold){const r=new Path2D;r.arc(e.x,e.y,this.params.radius,0,2*Math.PI),this.ctx.fill(r),this.ctx.stroke(r)}}drawKeypoints(e){const t=Bj.getKeypointIndexBySide(this.model);this.ctx.fillStyle="Red",this.ctx.strokeStyle="White",this.ctx.lineWidth=this.params.lineWidth;for(const r of t.middle)this.drawKeypoint(e[r]);this.ctx.fillStyle="Green";for(const r of t.left)this.drawKeypoint(e[r]);this.ctx.fillStyle="Orange";for(const r of t.right)this.drawKeypoint(e[r])}drawSkeleton(e,t){const r=t!=null?gkt[t%20]:"White";this.ctx.fillStyle=r,this.ctx.strokeStyle=r,this.ctx.lineWidth=this.params.lineWidth,Bj.getAdjacentPairs(this.model).forEach(([s,i])=>{const o=e[s],a=e[i],l=o.score!=null?o.score:1,c=a.score!=null?a.score:1,u=this.params.scoreThreshold||0;l>=u&&c>=u&&(this.ctx.beginPath(),this.ctx.moveTo(o.x,o.y),this.ctx.lineTo(a.x,a.y),this.ctx.stroke())})}drawResult(e){if(e.keypoints!=null&&(this.drawKeypoints(e.keypoints),this.drawSkeleton(e.keypoints,e.id)),e.keypoints3D!=null)throw new Error("Keypoints 3D is not Implemented...")}drawResults(e){for(const t of e)this.drawResult(t)}drawImage(e){this.ctx.clearRect(0,0,e.width,e.width),this.canvas.height=e.height,this.canvas.width=e.width,this.ctx.putImageData(e,0,0)}render(e,t,r="ImageData"){return this.drawImage(e),this.drawResults(t),r==="ImageData"?this.ctx.getImageData(0,0,this.width,this.width):this.canvas.toDataURL("image/jpeg")}}function ykt(n){let e,t,r;return{c(){e=He("Using "),t=He(n[2]),r=He(" pose detector.")},m(s,i){me(s,e,i),me(s,t,i),me(s,r,i)},p(s,i){i&4&&cn(t,s[2])},d(s){s&&de(e),s&&de(t),s&&de(r)}}}function bkt(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function vkt(n){let e;function t(i,o){return i[3]?bkt:ykt}let r=t(n),s=r(n);return{c(){e=we("p"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function wkt(n){let e,t;return e=new ra({props:{title:n[0],loading:n[3],$$slots:{default:[vkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]),s&28&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function xkt(n,e,t){let r,s=tt,i=()=>(s(),s=os(a,c=>t(3,r=c)),a);n.$$.on_destroy.push(()=>s());let{title:o}=e,{loading:a}=e;i();let{model:l}=e;return n.$$set=c=>{"title"in c&&t(0,o=c.title),"loading"in c&&i(t(1,a=c.loading)),"model"in c&&t(2,l=c.model)},[o,a,l,r]}class _kt extends xn{constructor(e){super(),wn(this,e,xkt,wkt,pn,{title:0,loading:1,model:2})}}var X1,yI,bI;class YC extends r0{constructor(e="MoveNet",t){super(),this.model=e,this.modelConfig=t,this.title="Pose Detection",this.parameters={},this.serviceName="undefined",X1.set(this,void 0),this.$loading=new mt(!0,!0),this.$bodyParts=new mt("Full body",!1),yI.set(this,void 0),bI.set(this,void 0),ir(this,yI,new a7(io[e],224),"f"),ir(this,bI,new a7(io[e],60),"f"),this.start(),this.setup(e,t)}async setup(e,t){await j2(),ir(this,X1,await Cdt(io[e],t),"f"),ga.info(`${e} loaded`),this.$loading.set(!1),this.start()}async predict(e){return $t(this,X1,"f")?await $t(this,X1,"f").estimatePoses(e):(ga.error("Movenet is not loaded"),[])}postprocess(e,t){const r=t&&Array.isArray(t)&&t.length>0?(s,i)=>t.includes(i):()=>!0;return e.map(s=>{const i=s.keypoints[0];return s.keypoints.filter(r).reduce((o,a)=>[...o,(a.x-i.x)/100,(a.y-i.y)/100],[])}).reduce((s,i)=>[...s,...i],[])}thumbnail(e,t){return $t(this,bI,"f").render(e,t,"dataURL")}render(e,t){return $t(this,yI,"f").render(e,t)}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new _kt({target:t,props:{title:this.title,loading:this.$loading,model:this.model}}))}train(){throw new Sp("Model `MobileNet` cannot be trained")}save(){throw new Error("MobileNet does not support saving")}load(){throw new Error("MobileNet does not support loading")}download(){throw new Error("MobileNet does not support downloading")}upload(){throw new Error("MobileNet does not support uploading")}}X1=new WeakMap,yI=new WeakMap,bI=new WeakMap;Dn([Ln],YC.prototype,"train",null);Dn([Ln],YC.prototype,"save",null);Dn([Ln],YC.prototype,"load",null);Dn([Ln],YC.prototype,"download",null);Dn([Ln],YC.prototype,"upload",null);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Dc().prototype.mul=function(n){return this.throwIfDisposed(),SCt(this,n)};function Skt(n){let e;return{c(){e=we("p"),e.textContent="No model loaded"},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function Ckt(n){let e,t,r,s;return{c(){e=we("p"),t=He("Model Loaded from "),r=He(n[2]),s=He(".")},m(i,o){me(i,e,o),se(e,t),se(e,r),se(e,s)},p(i,o){o&4&&cn(r,i[2])},d(i){i&&de(e)}}}function kkt(n){let e;return{c(){e=we("p"),e.textContent="Loading Model..."},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function Tkt(n){let e;function t(i,o){return i[3]==="loading"?kkt:i[3]==="loaded"?Ckt:Skt}let r=t(n),s=r(n);return{c(){e=we("div"),s.c(),Z(e,"class","p-2 text-sm text-gray-600")},m(i,o){me(i,e,o),s.m(e,null)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e,null)))},d(i){i&&de(e),s.d()}}}function Ekt(n){let e,t;return e=new ra({props:{title:n[0],loading:n[3]==="loading",$$slots:{default:[Tkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&8&&(i.loading=r[3]==="loading"),s&268&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Ikt(n,e,t){let r,s,i,o=tt,a=()=>(o(),o=os(f,d=>t(7,i=d)),f);n.$$.on_destroy.push(()=>o());var l,c,u;let{title:h}=e,{training:f}=e;return a(),n.$$set=d=>{"title"in d&&t(0,h=d.title),"training"in d&&a(t(1,f=d.training))},n.$$.update=()=>{n.$$.dirty&128&&t(3,r=i.status),n.$$.dirty&240&&t(2,s=!(t(4,l=i.data)===null||l===void 0)&&l.source?i.data.source==="datastore"?`datastore at ${t(5,c=i.data)===null||c===void 0?void 0:c.url}`:i.data.source==="url"?`url ${t(6,u=i.data)===null||u===void 0?void 0:u.url}`:"files":"unknown source")},[h,f,s,r,l,c,u,i]}class Akt extends xn{constructor(e){super(),wn(this,e,Ikt,Ekt,pn,{title:0,training:1})}}function l7(n,e){return n===e}function nD(n,e){return n===e}class i0 extends G${constructor({inputType:e,taskType:t,segmentationOptions:r={applyArgmax:!1,output:"image"}}){super(),this.title="tfjs model",this.parameters={},this.segmentationOptions={applyArgmax:!1,output:"image",...r},this.inputType=e,this.taskType=t,this.$training.subscribe(({status:s})=>{s==="loaded"&&(this.inputShape=this.model.inputs[0].shape.map(i=>i&&i>0?i:1))})}train(){throw new Sp("Model `TfModel` cannot be trained")}async predict(e){if(!this.model||this.$training.get().status!=="loaded")throw new Error("Model is not loaded");const t=Se(()=>{const s=this.preprocess(e);return this.model.predict(s.expandDims(0)).gather(0)}),r=await this.postprocess(t);return t.dispose(),r}preprocess(e){if(l7(this.inputType,"image"))return this.preprocessImage(e);if(l7(this.inputType,"generic"))return Ei(e);throw new Error("Invalid input data type")}preprocessImage(e){return Ci.resizeBilinear(oC(e),[this.inputShape[1],this.inputShape[2]])}async postprocess(e){if(nD(this.taskType,"classification")){const t=this.labels?i=>this.labels[i]:i=>i.toString(),r=Se(()=>e.argMax().dataSync()[0]),s=e.arraySync().reduce((i,o,a)=>({...i,[t(a)]:o}),{});return{label:t(r),confidences:s}}if(nD(this.taskType,"segmentation")){const[t,r]=e.shape,s=this.segmentationOptions.applyArgmax?Se(()=>e.argMax(-1).mul(.5)):e,i=this.segmentationOptions.output==="image"?new ImageData(await iC(s),t,r):await s.array();return this.segmentationOptions.applyArgmax&&s.dispose(),i}if(nD(this.taskType,"generic"))return e.array();throw new Error("Invalid output data type")}async loadFromFiles(e){this.$training.set({status:"loading"});try{const t=e.filter(s=>s.name.includes(".json")),r=e.filter(s=>s.name.includes(".bin"));if(t.length!==1){const s=new Error("The provided files are not compatible with this model");throw s.name="File upload error",s}if(this.$training.set({status:"loading"}),e.length){const s=await Fce(t[0]);this.loadFn=s.format==="graph-model"?Nl:K_,this.model=await this.loadFn(Bce([t[0],...r])),await this.warmup(),this.$training.set({status:"loaded",data:{source:"file"}})}}catch(t){throw this.$training.set({status:"error"}),t}}async loadFromUrl(e){this.$training.set({status:"loading"});try{const t=await fetch(e).then(r=>r.json());this.loadFn=t.format==="graph-model"?Nl:K_,this.model=await this.loadFn(dL(e)),await this.warmup(),this.$training.set({status:"loaded",data:{source:"url",url:e}})}catch(t){throw console.log("[tf-model] Loading error",t),this.$training.set({status:"error"}),t}}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new Akt({target:t,props:{title:this.title,training:this.$training}}))}}Dn([Ln],i0.prototype,"train",null);Dn([Ln],i0.prototype,"predict",null);Dn([Ln],i0.prototype,"preprocess",null);Dn([Ln],i0.prototype,"preprocessImage",null);Dn([Ln],i0.prototype,"postprocess",null);Dn([Ln],i0.prototype,"loadFromFiles",null);Dn([Ln],i0.prototype,"loadFromUrl",null);const Mkt=n=>function(t,r,s){const i=s.value;return s.value=function(...a){const l=this[n].then(()=>i.apply(this,a));return this[n]=l,l},s};function Nkt(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,Z(e,"class","empty svelte-yj1ygt")},m(t,r){me(t,e,r)},p:tt,i:tt,o:tt,d(t){t&&de(e)}}}function $kt(n){let e,t;return e=new Rce({props:{columns:[{name:"field"},...n[2]],provider:n[1],selectable:!1}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&4&&(i.columns=[{name:"field"},...r[2]]),s&2&&(i.provider=r[1]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Rkt(n){let e,t,r,s;const i=[$kt,Nkt],o=[];function a(l,c){return l[0].length>0?0:1}return e=a(n),t=o[e]=i[e](n),{c(){t.c(),r=mo()},m(l,c){o[e].m(l,c),me(l,r,c),s=!0},p(l,[c]){let u=e;e=a(l),e===u?o[e].p(l,c):(dr(),$e(o[u],1,1,()=>{o[u]=null}),pr(),t=o[e],t?t.p(l,c):(t=o[e]=i[e](l),t.c()),Ie(t,1),t.m(r.parentNode,r))},i(l){s||(Ie(t),s=!0)},o(l){$e(t),s=!1},d(l){o[e].d(l),l&&de(r)}}}function Pkt(n,e,t){let r,s,i,o,{runs:a}=e;return n.$$set=l=>{"runs"in l&&t(0,a=l.runs)},n.$$.update=()=>{n.$$.dirty&1&&t(2,r=a.map((l,c)=>({name:`Run ${c+1}`}))),n.$$.dirty&1&&t(4,s=a.length>0?Object.keys(a[0]).filter(l=>l!=="logs"):[]),n.$$.dirty&17&&t(3,i=s.map(l=>a.map((c,u)=>({[`Run ${u+1}`]:c[l]})).reduce((c,u)=>({...c,...u}),{field:l}))),n.$$.dirty&8&&t(1,o=new x_t({data:i}))},[a,o,r,i,s]}class due extends xn{constructor(e){super(),wn(this,e,Pkt,Rkt,pn,{runs:0})}}function c7(n,e,t){const r=n.slice();return r[5]=e[t],r[6]=e,r[7]=t,r}function u7(n){let e,t=n[7];const r=()=>n[3](e,t),s=()=>n[3](null,t);return{c(){e=we("div"),Z(e,"class","card inner-card xl:flex-1 svelte-1o4ebpu")},m(i,o){me(i,e,o),r()},p(i,o){n=i,t!==n[7]&&(s(),t=n[7],r())},d(i){i&&de(e),s()}}}function Dkt(n){let e,t=Object.values(n[0]),r=[];for(let s=0;s<t.length;s+=1)r[s]=u7(c7(n,t,s));return{c(){e=we("div");for(let s=0;s<r.length;s+=1)r[s].c();Z(e,"class","grid grid-cols-1 gap-1")},m(s,i){me(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null);n[4](e)},p(s,[i]){if(i&5){t=Object.values(s[0]);let o;for(o=0;o<t.length;o+=1){const a=c7(s,t,o);r[o]?r[o].p(a,i):(r[o]=u7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},i:tt,o:tt,d(s){s&&de(e),qs(r,s),n[4](null)}}}function Okt(n,e,t){let{charts:r}=e,s,i=[];Nu(async()=>{await ea(),await ea(),Object.keys(r).length>1&&s.clientWidth>700&&t(1,s.style.gridTemplateColumns="repeat(2, minmax(0, 1fr))",s);for(const[l,c]of Object.values(r).entries())c.mount(i[l])}),$g(()=>{for(const l of Object.values(r))l.destroy()});function o(l,c){hi[l?"unshift":"push"](()=>{i[c]=l,t(2,i)})}function a(l){hi[l?"unshift":"push"](()=>{s=l,t(1,s)})}return n.$$set=l=>{"charts"in l&&t(0,r=l.charts)},[r,s,i,o,a]}class Fkt extends xn{constructor(e){super(),wn(this,e,Okt,Dkt,pn,{charts:0})}}class Lkt extends Ia{constructor(e,t={loss:["loss","lossVal"],accuracy:["acc","accVal"]}){if(super(),this.model=e,this.title="training plot",this.charts={},!e){const o=new Error("[training plot] No model was provided");o.name="Component Compatibility Error",Ta(o)}if(!e.$training){const o=new Error("[training plot] The provided model is incompatible with the training plot component, missing `$training` stream");o.name="Component Compatibility Error",Ta(o)}let r=t;typeof t=="string"&&(r=[t]),Array.isArray(r)&&(r=r.reduce((o,a)=>({...o,[a]:a}),{}));const s={};for(const[o,a]of Object.entries(r)){const l=Array.isArray(a)?a:[a];this.charts[o]=iue({preset:"line-fast",options:{xlabel:"Epoch",ylabel:o}});for(const c of l)Object.keys(s).includes(c)||(s[c]=new mt([],!0)),this.charts[o].addSeries(s[c],c);this.charts[o].title=o}function i(){for(const o of Object.values(s))o.set([])}e.$training.subscribe(o=>{if(o.status==="start")i();else if(o.data)for(const[a,l]of Object.entries(o.data)){if(!Object.keys(s).includes(a))return;Array.isArray(l)?s[a].set(l.map((c,u)=>({x:u+1,y:c}))):s[a].set(s[a].get().concat([{x:s[a].get().length+1,y:l}]))}}),this.start()}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.$$.app=new Fkt({target:t,props:{charts:this.charts}}))}}function pue(...n){return new Lkt(...n)}function zkt(n){let e;return{c(){e=we("div"),e.innerHTML=`<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7l4-4m0 0l4 4m-4-4v18"></path></svg> 
    <p>Select one or several runs to display information</p>`,Z(e,"class","empty svelte-yj1ygt")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function Bkt(n){let e;return{c(){e=we("div")},m(t,r){me(t,e,r),n[7](e)},p:tt,d(t){t&&de(e),n[7](null)}}}function Vkt(n){let e;function t(i,o){return i[0].length>0?Bkt:zkt}let r=t(n),s=r(n);return{c(){s.c(),e=mo()},m(i,o){s.m(i,o),me(i,e,o)},p(i,[o]){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},i:tt,o:tt,d(i){s.d(i),i&&de(e)}}}function Ukt(n,e,t){let r,s,{names:i}=e,{logs:o}=e,a,l,c;$g(()=>{c&&c.destroy()});function u(h){hi[h?"unshift":"push"](()=>{a=h,t(1,a)})}return n.$$set=h=>{"names"in h&&t(2,i=h.names),"logs"in h&&t(0,o=h.logs)},n.$$.update=()=>{n.$$.dirty&9&&(t(3,l=Array.from(new Set(o.map(Object.keys).flat()))),l.sort()),n.$$.dirty&5&&t(6,r=o.map((h,f)=>Object.entries(h).reduce((d,[p,m])=>({...d,[`${p} (${i[f]})`]:m}),{})).reduce((h,f)=>({...h,...f}),{})),n.$$.dirty&72&&t(5,s=l.reduce((h,f)=>({...h,[f]:Object.keys(r).filter(d=>d.startsWith(`${f} (`))}),{})),n.$$.dirty&114&&(c&&c.destroy(),t(4,c=pue({$training:new mt({status:"success",data:r},!0)},s)),c.mount(a))},[o,a,i,l,c,s,r,u]}class Wkt extends xn{constructor(e){super(),wn(this,e,Ukt,Vkt,pn,{names:2,logs:0})}}function h7(n,e,t){const r=n.slice();return r[13]=e[t],r[15]=t,r}function Gkt(n){let e;return{c(){e=He("Graphs")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Hkt(n){let e;return{c(){e=He("Metadata")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function jkt(n){let e;return{c(){e=He("Parameters")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function qkt(n){let e;return{c(){e=He("Model Summary")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function Xkt(n){let e,t,r,s,i,o,a,l;return e=new IE({props:{$$slots:{default:[Gkt]},$$scope:{ctx:n}}}),r=new IE({props:{$$slots:{default:[Hkt]},$$scope:{ctx:n}}}),i=new IE({props:{$$slots:{default:[jkt]},$$scope:{ctx:n}}}),a=new IE({props:{$$slots:{default:[qkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment),t=Ye(),It(r.$$.fragment),s=Ye(),It(i.$$.fragment),o=Ye(),It(a.$$.fragment)},m(c,u){kt(e,c,u),me(c,t,u),kt(r,c,u),me(c,s,u),kt(i,c,u),me(c,o,u),kt(a,c,u),l=!0},p(c,u){const h={};u&65536&&(h.$$scope={dirty:u,ctx:c}),e.$set(h);const f={};u&65536&&(f.$$scope={dirty:u,ctx:c}),r.$set(f);const d={};u&65536&&(d.$$scope={dirty:u,ctx:c}),i.$set(d);const p={};u&65536&&(p.$$scope={dirty:u,ctx:c}),a.$set(p)},i(c){l||(Ie(e.$$.fragment,c),Ie(r.$$.fragment,c),Ie(i.$$.fragment,c),Ie(a.$$.fragment,c),l=!0)},o(c){$e(e.$$.fragment,c),$e(r.$$.fragment,c),$e(i.$$.fragment,c),$e(a.$$.fragment,c),l=!1},d(c){Tt(e,c),c&&de(t),Tt(r,c),c&&de(s),Tt(i,c),c&&de(o),Tt(a,c)}}}function Kkt(n){let e,t;return e=new Wkt({props:{logs:n[4].map(p7),names:n[4].map(m7)}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.logs=r[4].map(p7)),s&16&&(i.names=r[4].map(m7)),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Ykt(n){let e,t;return e=new due({props:{runs:n[4]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.runs=r[4]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function Zkt(n){let e,t;return e=new due({props:{runs:n[4].map(g7)}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&16&&(i.runs=r[4].map(g7)),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function f7(n){let e,t,r,s=n[15]+1+"",i,o,a,l,c=n[13]+"",u,h,f;return{c(){e=we("div"),t=we("h2"),r=He("Model "),i=He(s),o=Ye(),a=we("div"),l=we("pre"),u=He(c),h=we("br"),f=Ye(),Z(a,"class","summary svelte-y4izzs")},m(d,p){me(d,e,p),se(e,t),se(t,r),se(t,i),se(e,o),se(e,a),se(a,l),se(l,u),se(l,h),se(e,f)},p(d,p){p&16&&c!==(c=d[13]+"")&&cn(u,c)},d(d){d&&de(e)}}}function Jkt(n){let e,t=n[4].map(y7),r=[];for(let s=0;s<t.length;s+=1)r[s]=f7(h7(n,t,s));return{c(){e=we("div");for(let s=0;s<r.length;s+=1)r[s].c();Z(e,"class","summaries svelte-y4izzs")},m(s,i){me(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(s,i){if(i&16){t=s[4].map(y7);let o;for(o=0;o<t.length;o+=1){const a=h7(s,t,o);r[o]?r[o].p(a,i):(r[o]=f7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(s){s&&de(e),qs(r,s)}}}function Qkt(n){let e,t,r,s,i,o,a,l,c,u;return e=new w_t({props:{$$slots:{default:[Xkt]},$$scope:{ctx:n}}}),r=new AE({props:{$$slots:{default:[Kkt]},$$scope:{ctx:n}}}),i=new AE({props:{$$slots:{default:[Ykt]},$$scope:{ctx:n}}}),a=new AE({props:{$$slots:{default:[Zkt]},$$scope:{ctx:n}}}),c=new AE({props:{$$slots:{default:[Jkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment),t=Ye(),It(r.$$.fragment),s=Ye(),It(i.$$.fragment),o=Ye(),It(a.$$.fragment),l=Ye(),It(c.$$.fragment)},m(h,f){kt(e,h,f),me(h,t,f),kt(r,h,f),me(h,s,f),kt(i,h,f),me(h,o,f),kt(a,h,f),me(h,l,f),kt(c,h,f),u=!0},p(h,f){const d={};f&65536&&(d.$$scope={dirty:f,ctx:h}),e.$set(d);const p={};f&65552&&(p.$$scope={dirty:f,ctx:h}),r.$set(p);const m={};f&65552&&(m.$$scope={dirty:f,ctx:h}),i.$set(m);const g={};f&65552&&(g.$$scope={dirty:f,ctx:h}),a.$set(g);const y={};f&65552&&(y.$$scope={dirty:f,ctx:h}),c.$set(y)},i(h){u||(Ie(e.$$.fragment,h),Ie(r.$$.fragment,h),Ie(i.$$.fragment,h),Ie(a.$$.fragment,h),Ie(c.$$.fragment,h),u=!0)},o(h){$e(e.$$.fragment,h),$e(r.$$.fragment,h),$e(i.$$.fragment,h),$e(a.$$.fragment,h),$e(c.$$.fragment,h),u=!1},d(h){Tt(e,h),h&&de(t),Tt(r,h),h&&de(s),Tt(i,h),h&&de(o),Tt(a,h),h&&de(l),Tt(c,h)}}}function eTt(n){let e,t,r,s,i,o,a;function l(u){n[10](u)}let c={columns:n[7],provider:n[6],actions:[...n[1].map(d7),{name:"delete",confirm:!0}]};return n[4]!==void 0&&(c.selection=n[4]),e=new Rce({props:c}),hi.push(()=>Zf(e,"selection",l)),n[11](e),e.$on("select",n[12]),o=new P1t({props:{$$slots:{default:[Qkt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment),r=Ye(),s=we("br"),i=Ye(),It(o.$$.fragment)},m(u,h){kt(e,u,h),me(u,r,h),me(u,s,h),me(u,i,h),kt(o,u,h),a=!0},p(u,h){const f={};h&2&&(f.actions=[...u[1].map(d7),{name:"delete",confirm:!0}]),!t&&h&16&&(t=!0,f.selection=u[4],Yf(()=>t=!1)),e.$set(f);const d={};h&65552&&(d.$$scope={dirty:h,ctx:u}),o.$set(d)},i(u){a||(Ie(e.$$.fragment,u),Ie(o.$$.fragment,u),a=!0)},o(u){$e(e.$$.fragment,u),$e(o.$$.fragment,u),a=!1},d(u){n[11](null),Tt(e,u),u&&de(r),u&&de(s),u&&de(i),Tt(o,u)}}}function tTt(n){let e,t;return e=new ra({props:{title:n[0],$$slots:{default:[eTt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title=r[0]),s&65562&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}const d7=n=>typeof n=="string"?{name:n}:n,p7=n=>n.logs,m7=n=>n.name,g7=n=>n.params,y7=n=>{var e;return((e=n.model)==null?void 0:e.summary)||"No summary available"};function nTt(n,e,t){let r,s=tt,i=()=>(s(),s=os(u,b=>t(4,r=b)),u);n.$$.on_destroy.push(()=>s());let{title:o}=e,{service:a}=e,{metrics:l}=e,{actions:c}=e,{selection:u}=e;i();const h=Pc(),f=new __t({service:a,transform:{...l.reduce((b,x)=>({...b,[x]:w=>x in w.logs?w.logs[x][w.logs[x].length-1]:"metrics not found"}),{}),...c.reduce((b,x)=>({...b,[typeof x=="string"?x:x.name]:()=>typeof x=="string"?x:x.name}),{})}});f.data.subscribe(()=>{u.set([])});const d=[{name:"name",sortable:!0},{name:"start",sortable:!0,type:"date"},...l.map(b=>({name:b})),{name:"epochs"},{name:"status"},...c.map(b=>({name:typeof b=="string"?b:b.name,type:"action"}))];let p;Nu(async()=>{await ea(),await ea();for(const b of c){const x=typeof b=="string"?b:b.name;p.$on(x,({detail:w})=>{h(x,w)})}});function m(b){r=b,u.set(r)}function g(b){hi[b?"unshift":"push"](()=>{p=b,t(3,p)})}const y=({detail:b})=>h("load",b);return n.$$set=b=>{"title"in b&&t(0,o=b.title),"service"in b&&t(8,a=b.service),"metrics"in b&&t(9,l=b.metrics),"actions"in b&&t(1,c=b.actions),"selection"in b&&i(t(2,u=b.selection))},[o,c,u,p,r,h,f,d,a,l,m,g,y]}class rTt extends xn{constructor(e){super(),wn(this,e,nTt,tTt,pn,{title:0,service:8,metrics:9,actions:1,selection:2})}}function sTt(n,e){const t={...n};for(const[r,s]of Object.entries(e))t[r]=(t[r]||[]).concat([s]);return t}const iTt={metrics:["accuracy","accuracyVal","loss","lossVal"],actions:[]};class oTt extends Ia{constructor(e,t={}){super(),this.dataStore=e,this.title="Training History",this.$selection=new mt([],!0),this.$actions=new mt(null).skip(1),this.ready=Promise.resolve(),this.stopTracking=zb,this.lock=Promise.resolve(),this.options={...iTt,...t},this.lock=this.lock.then(zb),this.start(),this.ready=this.ready.then(()=>this.dataStore.connect()).then(()=>{this.runService=this.dataStore.service("runs")}).catch(()=>{ga.log("[dataset] dataStore connection failed")})}track(e,t="anonymous"){return this.ready.then(()=>(this.stopTracking(),this.model=e,this.modelName=t,this.runService.find({query:{basename:t,$sort:{createdAt:-1},$select:["name"],$limit:1}}))).then(({data:r})=>r.length>0?parseInt(r[0].name.split(`${t}-`)[1])+1:1).then(r=>{this.nextIndex=r,this.crtRun=null,this.stopTracking=this.model?this.model.$training.subscribe(this.trackTrainingStream):zb}),this}async trackTrainingStream(e){if(e.status==="start")this.crtRun=await this.runService.create({name:`${this.modelName}-${this.nextIndex++}`,basename:this.modelName,start:new Date(Date.now()).toISOString(),source:"js",status:e.status,epochs:e.epochs,params:Object.entries(this.model.parameters).map(([t,r])=>({[t]:r.get()})).reduce((t,r)=>({...t,...r}),{}),logs:{}});else if(e.status==="epoch")this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:sTt(this.crtRun.logs,e.data)});else if(e.status==="success"){const t=await this.model.save(this.dataStore,this.modelName,{});this.runService.patch(this.crtRun.id,{status:e.status,epoch:e.epoch,logs:e.data,checkpoints:(this.crtRun.checkpoints||[]).concat([{id:t,name:`${this.crtRun.name}@final`,service:this.model.serviceName}])})}else e.status==="error"&&this.runService.patch(this.crtRun.id,{status:e.status})}mount(e){const t=e||document.querySelector(`#${this.id}`);t&&(this.destroy(),this.ready.then(()=>{this.$$.app=new rTt({target:t,props:{title:this.title,service:this.runService,metrics:this.options.metrics,actions:this.options.actions,selection:this.$selection}});for(const r of this.options.actions){const s=typeof r=="string"?r:r.name;this.$$.app.$on(s,({detail:i})=>{this.$actions.set({name:s,data:i})})}}))}}Dn([Mkt("lock")],oTt.prototype,"trackTrainingStream",null);function b7(n){return typeof n=="string"}function v7(n){return Array.isArray(n)}let aTt=class{constructor(e,t=!0){this.name=e,this.showSidebar=t,this.components=[],this.componentsLeft=[]}use(...e){return this.components=this.components.concat(e),this}sidebar(...e){return this.componentsLeft=this.componentsLeft.concat(e),this}mount(){for(const e of this.components)if(v7(e))for(const t of e)t.mount();else b7(e)||e.mount();for(const e of this.componentsLeft)e.mount()}destroy(){for(const e of this.components)if(v7(e))for(const t of e)t.destroy();else b7(e)||e.destroy();for(const e of this.componentsLeft)e.destroy()}};function lTt(n,e,t,r){return n instanceof RegExp?n:(n instanceof Array&&(n=`(${n.join("|")})`),n=n.concat(r?"":"/?").replace(/\/\(/g,"(?:/").replace(/\+/g,"__plus__").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g,(s,i,o,a,l,c)=>(e.push({name:a,optional:!!c}),i=i||"",`${c?"":i}(?:${c?i:""}${o||""}${l||o&&"([^/.]+?)"||"([^/]+?)"})${c||""}`)).replace(/([/.])/g,"\\$1").replace(/__plus__/g,"(.+)").replace(/\*/g,"(.*)"),new RegExp(`^${n}$`,t?"":"i"))}class cTt{constructor(e,t){this.path=e,this.name=t,this.keys=[],this.fns=[],this.params={},this.regex=lTt(this.path,this.keys,!1,!1)}addHandler(e){this.fns.push(e)}removeHandler(e){this.fns=this.fns.filter(t=>e===t)}run(e){for(const t of this.fns)t.apply(this,e)}match(e,t){const r=this.regex.exec(e);if(!r)return!1;for(let s=1,i=r.length;s<i;s++){const o=this.keys[s-1],a=typeof r[s]=="string"?decodeURIComponent(r[s]):r[s];o&&(this.params[o.name]=a),t.push(a)}return!0}}function uTt(n,e){const t=[];return e.match(n,t)?(e.run(t),!0):!1}class hTt{constructor(){this.map={},this.routes=[],this.addListener()}route(e,t){const r=e.split(" "),s=r.length===2?r[0]:null;e=r.length===2?r[1]:r[0],Object.keys(this.map).includes(e)||(this.map[e]=new cTt(e,s),this.routes.push(this.map[e])),this.map[e].addHandler(t),this.reload()}addListener(){window.addEventListener("hashchange",this.reload.bind(this),!1)}removeListener(){window.removeEventListener("hashchange",this.reload.bind(this))}reload(){const e=window.location.hash.substring(1);for(let t=0;t<this.routes.length;t++){const r=this.routes[t];if(uTt(e,r))return}}navigate(e,{silent:t=!1}={}){t&&this.removeListener(),setTimeout(()=>{window.location.hash=e,t&&setTimeout(()=>{this.addListener()},1)},1)}}function w7(n,e,t){const r=n.slice();return r[1]=e[t],r}function x7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function _7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function S7(n){let e,t,r=n[0].showSidebar&&C7(n),s=n[0].components,i=[];for(let o=0;o<s.length;o+=1)i[o]=E7(w7(n,s,o));return{c(){r&&r.c(),e=Ye(),t=we("div");for(let o=0;o<i.length;o+=1)i[o].c();Z(t,"class","right svelte-15dyumc"),qt(t,"fullw",!n[0].showSidebar)},m(o,a){r&&r.m(o,a),me(o,e,a),me(o,t,a);for(let l=0;l<i.length;l+=1)i[l]&&i[l].m(t,null)},p(o,a){if(o[0].showSidebar?r?r.p(o,a):(r=C7(o),r.c(),r.m(e.parentNode,e)):r&&(r.d(1),r=null),a&1){s=o[0].components;let l;for(l=0;l<s.length;l+=1){const c=w7(o,s,l);i[l]?i[l].p(c,a):(i[l]=E7(c),i[l].c(),i[l].m(t,null))}for(;l<i.length;l+=1)i[l].d(1);i.length=s.length}a&1&&qt(t,"fullw",!o[0].showSidebar)},d(o){r&&r.d(o),o&&de(e),o&&de(t),qs(i,o)}}}function C7(n){let e,t=n[0].componentsLeft,r=[];for(let s=0;s<t.length;s+=1)r[s]=k7(_7(n,t,s));return{c(){e=we("div");for(let s=0;s<r.length;s+=1)r[s].c();Z(e,"class","left svelte-15dyumc")},m(s,i){me(s,e,i);for(let o=0;o<r.length;o+=1)r[o]&&r[o].m(e,null)},p(s,i){if(i&1){t=s[0].componentsLeft;let o;for(o=0;o<t.length;o+=1){const a=_7(s,t,o);r[o]?r[o].p(a,i):(r[o]=k7(a),r[o].c(),r[o].m(e,null))}for(;o<r.length;o+=1)r[o].d(1);r.length=t.length}},d(s){s&&de(e),qs(r,s)}}}function k7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&de(e)}}}function fTt(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[1].id),Z(e,"class","card")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[1].id)&&Z(e,"id",t)},d(r){r&&de(e)}}}function dTt(n){let e,t=n[1]+"",r;return{c(){e=we("h2"),r=He(t),Z(e,"class","svelte-15dyumc")},m(s,i){me(s,e,i),se(e,r)},p(s,i){i&1&&t!==(t=s[1]+"")&&cn(r,t)},d(s){s&&de(e)}}}function pTt(n){let e,t,r=n[1],s=[];for(let i=0;i<r.length;i+=1)s[i]=T7(x7(n,r,i));return{c(){e=we("div");for(let i=0;i<s.length;i+=1)s[i].c();t=Ye(),Z(e,"class","flex flex-row flex-wrap items-stretch")},m(i,o){me(i,e,o);for(let a=0;a<s.length;a+=1)s[a]&&s[a].m(e,null);se(e,t)},p(i,o){if(o&1){r=i[1];let a;for(a=0;a<r.length;a+=1){const l=x7(i,r,a);s[a]?s[a].p(l,o):(s[a]=T7(l),s[a].c(),s[a].m(e,t))}for(;a<s.length;a+=1)s[a].d(1);s.length=r.length}},d(i){i&&de(e),qs(s,i)}}}function T7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&de(e)}}}function E7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?pTt:typeof o[1]=="string"?dTt:fTt}let s=r(n,-1),i=s(n);return{c(){i.c(),t=mo()},m(o,a){i.m(o,a),me(o,t,a)},p(o,a){s===(s=r(o,a))&&i?i.p(o,a):(i.d(1),i=s(o),i&&(i.c(),i.m(t.parentNode,t)))},d(o){i.d(o),o&&de(t)}}}function mTt(n){let e,t=n[0]&&S7(n);return{c(){t&&t.c(),e=mo()},m(r,s){t&&t.m(r,s),me(r,e,s)},p(r,[s]){r[0]?t?t.p(r,s):(t=S7(r),t.c(),t.m(e.parentNode,e)):t&&(t.d(1),t=null)},i:tt,o:tt,d(r){t&&t.d(r),r&&de(e)}}}function gTt(n,e,t){let{dashboard:r}=e;return _ce(()=>{r.mount()}),n.$$set=s=>{"dashboard"in s&&t(0,r=s.dashboard)},[r]}class yTt extends xn{constructor(e){super(),wn(this,e,gTt,mTt,pn,{dashboard:0})}}function bTt(n){let e;return{c(){e=He("This dataset is empty")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function vTt(n){let e,t,r,s=n[3]?"s":"",i,o;return{c(){e=He("This dataset contains "),t=He(n[3]),r=He(" instance"),i=He(s),o=He(".")},m(a,l){me(a,e,l),me(a,t,l),me(a,r,l),me(a,i,l),me(a,o,l)},p(a,l){l&8&&cn(t,a[3]),l&8&&s!==(s=a[3]?"s":"")&&cn(i,s)},d(a){a&&de(e),a&&de(t),a&&de(r),a&&de(i),a&&de(o)}}}function I7(n){let e,t,r,s;return e=new zs({props:{$$slots:{default:[wTt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){It(e.$$.fragment),t=Ye(),r=we("span"),Z(r,"class","w-1")},m(i,o){kt(e,i,o),me(i,t,o),me(i,r,o),s=!0},p(i,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ie(e.$$.fragment,i),s=!0)},o(i){$e(e.$$.fragment,i),s=!1},d(i){Tt(e,i),i&&de(t),i&&de(r)}}}function wTt(n){let e;return{c(){e=He("Download Dataset")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function xTt(n){let e;return{c(){e=He("Upload Dataset")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function _Tt(n){let e;return{c(){e=He("Clear Dataset")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function STt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d,p,m,g;function y(S,C){return S[3]?vTt:bTt}let b=y(n),x=b(n),w=n[3]&&I7(n);return c=new zs({props:{$$slots:{default:[xTt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zs({props:{type:"danger",$$slots:{default:[_Tt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=we("span"),r=He(t),s=Ye(),i=we("p"),x.c(),o=Ye(),a=we("div"),w&&w.c(),l=Ye(),It(c.$$.fragment),u=Ye(),h=we("span"),f=Ye(),d=we("input"),p=Ye(),It(m.$$.fragment),Z(e,"class","card-title"),Z(i,"class","pb-2"),Z(h,"class","w-1"),Z(d,"type","file"),d.multiple=!0,Z(d,"class","hidden"),Z(a,"class","flex")},m(S,C){me(S,e,C),se(e,r),me(S,s,C),me(S,i,C),x.m(i,null),me(S,o,C),me(S,a,C),w&&w.m(a,null),se(a,l),kt(c,a,null),se(a,u),se(a,h),se(a,f),se(a,d),n[7](d),se(a,p),kt(m,a,null),g=!0},p(S,[C]){(!g||C&1)&&t!==(t=S[0].title+"")&&cn(r,t),b===(b=y(S))&&x?x.p(S,C):(x.d(1),x=b(S),x&&(x.c(),x.m(i,null))),S[3]?w?(w.p(S,C),C&8&&Ie(w,1)):(w=I7(S),w.c(),Ie(w,1),w.m(a,l)):w&&(dr(),$e(w,1,1,()=>{w=null}),pr());const k={};C&256&&(k.$$scope={dirty:C,ctx:S}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:S}),m.$set(A)},i(S){g||(Ie(w),Ie(c.$$.fragment,S),Ie(m.$$.fragment,S),g=!0)},o(S){$e(w),$e(c.$$.fragment,S),$e(m.$$.fragment,S),g=!1},d(S){S&&de(e),S&&de(s),S&&de(i),x.d(),S&&de(o),S&&de(a),w&&w.d(),Tt(c),n[7](null),Tt(m)}}}function CTt(n,e,t){let r,s,i=tt,o=()=>(i(),i=os(r,d=>t(3,s=d)),r);n.$$.on_destroy.push(()=>i());let{dataset:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}Nu(async()=>{await ea(),await ea(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){hi[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"dataset"in d&&t(0,a=d.dataset)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,s,c,u,h,f]}class kTt extends xn{constructor(e){super(),wn(this,e,CTt,STt,pn,{dataset:0})}}function A7(n){let e,t,r,s={ctx:n,current:null,token:null,hasCatch:!1,pending:ATt,then:ETt,catch:TTt,value:4,blocks:[,,,]};return Hq(t=n[0].connect(),s),{c(){e=mo(),s.block.c()},m(i,o){me(i,e,o),s.block.m(i,s.anchor=o),s.mount=()=>e.parentNode,s.anchor=e,r=!0},p(i,o){n=i,s.ctx=n,o&1&&t!==(t=n[0].connect())&&Hq(t,s)||Zxt(s,n,o)},i(i){r||(Ie(s.block),r=!0)},o(i){for(let o=0;o<3;o+=1){const a=s.blocks[o];$e(a)}r=!1},d(i){i&&de(e),s.block.d(i),s.token=null,s=null}}}function TTt(n){return{c:tt,m:tt,p:tt,i:tt,o:tt,d:tt}}function ETt(n){let e,t,r=n[4].email+"",s,i,o,a,l;return a=new zs({props:{$$slots:{default:[ITt]},$$scope:{ctx:n}}}),a.$on("click",n[3]),{c(){e=we("p"),t=He("Hello, "),s=He(r),i=Ye(),o=we("div"),It(a.$$.fragment),Z(e,"class","pb-2"),Z(o,"class","flex")},m(c,u){me(c,e,u),se(e,t),se(e,s),me(c,i,u),me(c,o,u),kt(a,o,null),l=!0},p(c,u){(!l||u&1)&&r!==(r=c[4].email+"")&&cn(s,r);const h={};u&32&&(h.$$scope={dirty:u,ctx:c}),a.$set(h)},i(c){l||(Ie(a.$$.fragment,c),l=!0)},o(c){$e(a.$$.fragment,c),l=!1},d(c){c&&de(e),c&&de(i),c&&de(o),Tt(a)}}}function ITt(n){let e;return{c(){e=He("Log out")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function ATt(n){let e,t;return e=new Nce({}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p:tt,i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function M7(n){let e,t,r=n[2].join(", ")+"",s;return{c(){e=we("div"),t=He("This data store contains the following services: "),s=He(r)},m(i,o){me(i,e,o),se(e,t),se(e,s)},p(i,o){o&4&&r!==(r=i[2].join(", ")+"")&&cn(s,r)},d(i){i&&de(e)}}}function MTt(n){let e,t,r,s=n[0].requiresAuth&&A7(n),i=n[2]&&M7(n);return{c(){s&&s.c(),e=Ye(),i&&i.c(),t=mo()},m(o,a){s&&s.m(o,a),me(o,e,a),i&&i.m(o,a),me(o,t,a),r=!0},p(o,a){o[0].requiresAuth?s?(s.p(o,a),a&1&&Ie(s,1)):(s=A7(o),s.c(),Ie(s,1),s.m(e.parentNode,e)):s&&(dr(),$e(s,1,1,()=>{s=null}),pr()),o[2]?i?i.p(o,a):(i=M7(o),i.c(),i.m(t.parentNode,t)):i&&(i.d(1),i=null)},i(o){r||(Ie(s),r=!0)},o(o){$e(s),r=!1},d(o){s&&s.d(o),o&&de(e),i&&i.d(o),o&&de(t)}}}function NTt(n){let e,t;return e=new ra({props:{title:"data store ("+n[0].location+")",$$slots:{default:[MTt]},$$scope:{ctx:n}}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,[s]){const i={};s&1&&(i.title="data store ("+r[0].location+")"),s&37&&(i.$$scope={dirty:s,ctx:r}),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function $Tt(n,e,t){let r,s,i=tt,o=()=>(i(),i=os(r,c=>t(2,s=c)),r);n.$$.on_destroy.push(()=>i());let{dataStore:a}=e;function l(){a.logout()}return n.$$set=c=>{"dataStore"in c&&t(0,a=c.dataStore)},n.$$.update=()=>{n.$$.dirty&1&&o(t(1,r=a.$services))},[a,r,s,l]}class RTt extends xn{constructor(e){super(),wn(this,e,$Tt,NTt,pn,{dataStore:0})}}function PTt(n){let e;return{c(){e=He("Download Model")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function DTt(n){let e;return{c(){e=He("Upload Model")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function OTt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d;return o=new zs({props:{$$slots:{default:[PTt]},$$scope:{ctx:n}}}),o.$on("click",n[2]),f=new zs({props:{$$slots:{default:[DTt]},$$scope:{ctx:n}}}),f.$on("click",n[3]),{c(){e=we("span"),r=He(t),s=Ye(),i=we("div"),It(o.$$.fragment),a=Ye(),l=we("span"),c=Ye(),u=we("input"),h=Ye(),It(f.$$.fragment),Z(e,"class","card-title"),Z(l,"class","w-1"),Z(u,"type","file"),u.multiple=!0,Z(u,"class","hidden"),Z(i,"class","flex")},m(p,m){me(p,e,m),se(e,r),me(p,s,m),me(p,i,m),kt(o,i,null),se(i,a),se(i,l),se(i,c),se(i,u),n[4](u),se(i,h),kt(f,i,null),d=!0},p(p,[m]){(!d||m&1)&&t!==(t=p[0].title+"")&&cn(r,t);const g={};m&32&&(g.$$scope={dirty:m,ctx:p}),o.$set(g);const y={};m&32&&(y.$$scope={dirty:m,ctx:p}),f.$set(y)},i(p){d||(Ie(o.$$.fragment,p),Ie(f.$$.fragment,p),d=!0)},o(p){$e(o.$$.fragment,p),$e(f.$$.fragment,p),d=!1},d(p){p&&de(e),p&&de(s),p&&de(i),Tt(o),n[4](null),Tt(f)}}}function rD(n){return"download"in n}function FTt(n,e,t){let{model:r}=e,s;function i(){rD(r)?r.download():Ta(new Error("This model cannot be saved"))}function o(){rD(r)?s==null||s.click():Ta(new Error("This model cannot be uploaded"))}Nu(async()=>{await ea(),await ea(),s.addEventListener("change",l=>{const c=l.target.files,u=[];for(let h=0;h<c.length;h++)u.push(c[h]);rD(r)&&r.upload(...u)})});function a(l){hi[l?"unshift":"push"](()=>{s=l,t(1,s)})}return n.$$set=l=>{"model"in l&&t(0,r=l.model)},[r,s,i,o,a]}class LTt extends xn{constructor(e){super(),wn(this,e,FTt,OTt,pn,{model:0})}}function zTt(n){let e;return{c(){e=He("This batch prediction component is empty")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function BTt(n){let e,t,r,s=n[3]?"s":"",i;return{c(){e=He(`This batch prediction component contains
    `),t=He(n[3]),r=He(`
    prediction`),i=He(s)},m(o,a){me(o,e,a),me(o,t,a),me(o,r,a),me(o,i,a)},p(o,a){a&8&&cn(t,o[3]),a&8&&s!==(s=o[3]?"s":"")&&cn(i,s)},d(o){o&&de(e),o&&de(t),o&&de(r),o&&de(i)}}}function N7(n){let e,t,r,s;return e=new zs({props:{$$slots:{default:[VTt]},$$scope:{ctx:n}}}),e.$on("click",n[4]),{c(){It(e.$$.fragment),t=Ye(),r=we("span"),Z(r,"class","w-1")},m(i,o){kt(e,i,o),me(i,t,o),me(i,r,o),s=!0},p(i,o){const a={};o&256&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ie(e.$$.fragment,i),s=!0)},o(i){$e(e.$$.fragment,i),s=!1},d(i){Tt(e,i),i&&de(t),i&&de(r)}}}function VTt(n){let e;return{c(){e=He("Download Predictions")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function UTt(n){let e;return{c(){e=He("Upload Predictions")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function WTt(n){let e;return{c(){e=He("Clear Predictions")},m(t,r){me(t,e,r)},d(t){t&&de(e)}}}function GTt(n){let e,t=n[0].title+"",r,s,i,o,a,l,c,u,h,f,d,p,m,g;function y(S,C){return S[3]?BTt:zTt}let b=y(n),x=b(n),w=n[3]&&N7(n);return c=new zs({props:{$$slots:{default:[UTt]},$$scope:{ctx:n}}}),c.$on("click",n[5]),m=new zs({props:{type:"danger",$$slots:{default:[WTt]},$$scope:{ctx:n}}}),m.$on("click",n[6]),{c(){e=we("span"),r=He(t),s=Ye(),i=we("p"),x.c(),o=Ye(),a=we("div"),w&&w.c(),l=Ye(),It(c.$$.fragment),u=Ye(),h=we("span"),f=Ye(),d=we("input"),p=Ye(),It(m.$$.fragment),Z(e,"class","card-title"),Z(i,"class","pb-2"),Z(h,"class","w-1"),Z(d,"type","file"),d.multiple=!0,Z(d,"class","hidden"),Z(a,"class","flex")},m(S,C){me(S,e,C),se(e,r),me(S,s,C),me(S,i,C),x.m(i,null),me(S,o,C),me(S,a,C),w&&w.m(a,null),se(a,l),kt(c,a,null),se(a,u),se(a,h),se(a,f),se(a,d),n[7](d),se(a,p),kt(m,a,null),g=!0},p(S,[C]){(!g||C&1)&&t!==(t=S[0].title+"")&&cn(r,t),b===(b=y(S))&&x?x.p(S,C):(x.d(1),x=b(S),x&&(x.c(),x.m(i,null))),S[3]?w?(w.p(S,C),C&8&&Ie(w,1)):(w=N7(S),w.c(),Ie(w,1),w.m(a,l)):w&&(dr(),$e(w,1,1,()=>{w=null}),pr());const k={};C&256&&(k.$$scope={dirty:C,ctx:S}),c.$set(k);const A={};C&256&&(A.$$scope={dirty:C,ctx:S}),m.$set(A)},i(S){g||(Ie(w),Ie(c.$$.fragment,S),Ie(m.$$.fragment,S),g=!0)},o(S){$e(w),$e(c.$$.fragment,S),$e(m.$$.fragment,S),g=!1},d(S){S&&de(e),S&&de(s),S&&de(i),x.d(),S&&de(o),S&&de(a),w&&w.d(),Tt(c),n[7](null),Tt(m)}}}function HTt(n,e,t){let r,s,i=tt,o=()=>(i(),i=os(r,d=>t(3,s=d)),r);n.$$.on_destroy.push(()=>i());let{prediction:a}=e,l;function c(){a.download()}function u(){l==null||l.click()}function h(){a.clear()}Nu(async()=>{await ea(),await ea(),l.addEventListener("change",d=>{const p=d.target.files,m=[];for(let g=0;g<p.length;g++)m.push(p[g]);a.upload(m)})});function f(d){hi[d?"unshift":"push"](()=>{l=d,t(1,l)})}return n.$$set=d=>{"prediction"in d&&t(0,a=d.prediction)},n.$$.update=()=>{n.$$.dirty&1&&o(t(2,r=a.$count))},[a,l,r,s,c,u,h,f]}class jTt extends xn{constructor(e){super(),wn(this,e,HTt,GTt,pn,{prediction:0})}}function $7(n,e,t){const r=n.slice();return r[1]=e[t],r}function R7(n,e,t){const r=n.slice();return r[4]=e[t].id,r}function P7(n,e,t){const r=n.slice();return r[7]=e[t],r}function D7(n,e,t){const r=n.slice();return r[10]=e[t],r}function O7(n,e,t){const r=n.slice();return r[13]=e[t],r}function F7(n,e,t){const r=n.slice();return r[16]=e[t],r}function L7(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m,g=n[0].xDataStores,y=[];for(let D=0;D<g.length;D+=1)y[D]=z7(F7(n,g,D));const b=D=>$e(y[D],1,1,()=>{y[D]=null});let x=n[0].xModels,w=[];for(let D=0;D<x.length;D+=1)w[D]=B7(O7(n,x,D));const S=D=>$e(w[D],1,1,()=>{w[D]=null});let C=n[0].xDatasets,k=[];for(let D=0;D<C.length;D+=1)k[D]=V7(D7(n,C,D));const A=D=>$e(k[D],1,1,()=>{k[D]=null});let M=n[0].xPredictions,E=[];for(let D=0;D<M.length;D+=1)E[D]=U7(P7(n,M,D));const N=D=>$e(E[D],1,1,()=>{E[D]=null});let O=n[0].components,R=[];for(let D=0;D<O.length;D+=1)R[D]=G7($7(n,O,D));return{c(){e=we("div"),t=we("h2"),t.textContent="Data Stores",r=Ye();for(let D=0;D<y.length;D+=1)y[D].c();s=Ye(),i=we("h2"),i.textContent="Models",o=Ye();for(let D=0;D<w.length;D+=1)w[D].c();a=Ye(),l=we("h2"),l.textContent="Datasets",c=Ye();for(let D=0;D<k.length;D+=1)k[D].c();u=Ye(),h=we("h2"),h.textContent="Predictions",f=Ye();for(let D=0;D<E.length;D+=1)E[D].c();d=Ye(),p=we("div");for(let D=0;D<R.length;D+=1)R[D].c();Z(e,"class","left svelte-inuorr"),Z(p,"class","right svelte-inuorr")},m(D,z){me(D,e,z),se(e,t),se(e,r);for(let B=0;B<y.length;B+=1)y[B]&&y[B].m(e,null);se(e,s),se(e,i),se(e,o);for(let B=0;B<w.length;B+=1)w[B]&&w[B].m(e,null);se(e,a),se(e,l),se(e,c);for(let B=0;B<k.length;B+=1)k[B]&&k[B].m(e,null);se(e,u),se(e,h),se(e,f);for(let B=0;B<E.length;B+=1)E[B]&&E[B].m(e,null);me(D,d,z),me(D,p,z);for(let B=0;B<R.length;B+=1)R[B]&&R[B].m(p,null);m=!0},p(D,z){if(z&1){g=D[0].xDataStores;let B;for(B=0;B<g.length;B+=1){const X=F7(D,g,B);y[B]?(y[B].p(X,z),Ie(y[B],1)):(y[B]=z7(X),y[B].c(),Ie(y[B],1),y[B].m(e,s))}for(dr(),B=g.length;B<y.length;B+=1)b(B);pr()}if(z&1){x=D[0].xModels;let B;for(B=0;B<x.length;B+=1){const X=O7(D,x,B);w[B]?(w[B].p(X,z),Ie(w[B],1)):(w[B]=B7(X),w[B].c(),Ie(w[B],1),w[B].m(e,a))}for(dr(),B=x.length;B<w.length;B+=1)S(B);pr()}if(z&1){C=D[0].xDatasets;let B;for(B=0;B<C.length;B+=1){const X=D7(D,C,B);k[B]?(k[B].p(X,z),Ie(k[B],1)):(k[B]=V7(X),k[B].c(),Ie(k[B],1),k[B].m(e,u))}for(dr(),B=C.length;B<k.length;B+=1)A(B);pr()}if(z&1){M=D[0].xPredictions;let B;for(B=0;B<M.length;B+=1){const X=P7(D,M,B);E[B]?(E[B].p(X,z),Ie(E[B],1)):(E[B]=U7(X),E[B].c(),Ie(E[B],1),E[B].m(e,null))}for(dr(),B=M.length;B<E.length;B+=1)N(B);pr()}if(z&1){O=D[0].components;let B;for(B=0;B<O.length;B+=1){const X=$7(D,O,B);R[B]?R[B].p(X,z):(R[B]=G7(X),R[B].c(),R[B].m(p,null))}for(;B<R.length;B+=1)R[B].d(1);R.length=O.length}},i(D){if(!m){for(let z=0;z<g.length;z+=1)Ie(y[z]);for(let z=0;z<x.length;z+=1)Ie(w[z]);for(let z=0;z<C.length;z+=1)Ie(k[z]);for(let z=0;z<M.length;z+=1)Ie(E[z]);m=!0}},o(D){y=y.filter(Boolean);for(let z=0;z<y.length;z+=1)$e(y[z]);w=w.filter(Boolean);for(let z=0;z<w.length;z+=1)$e(w[z]);k=k.filter(Boolean);for(let z=0;z<k.length;z+=1)$e(k[z]);E=E.filter(Boolean);for(let z=0;z<E.length;z+=1)$e(E[z]);m=!1},d(D){D&&de(e),qs(y,D),qs(w,D),qs(k,D),qs(E,D),D&&de(d),D&&de(p),qs(R,D)}}}function z7(n){let e,t,r;return t=new RTt({props:{dataStore:n[16]}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","card")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.dataStore=s[16]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function B7(n){let e,t,r;return t=new LTt({props:{model:n[13]}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","card")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.model=s[13]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function V7(n){let e,t,r;return t=new kTt({props:{dataset:n[10]}}),{c(){e=we("div"),It(t.$$.fragment),Z(e,"class","card")},m(s,i){me(s,e,i),kt(t,e,null),r=!0},p(s,i){const o={};i&1&&(o.dataset=s[10]),t.$set(o)},i(s){r||(Ie(t.$$.fragment,s),r=!0)},o(s){$e(t.$$.fragment,s),r=!1},d(s){s&&de(e),Tt(t)}}}function U7(n){let e,t,r,s;return t=new jTt({props:{prediction:n[7]}}),{c(){e=we("div"),It(t.$$.fragment),r=Ye(),Z(e,"class","card")},m(i,o){me(i,e,o),kt(t,e,null),se(e,r),s=!0},p(i,o){const a={};o&1&&(a.prediction=i[7]),t.$set(a)},i(i){s||(Ie(t.$$.fragment,i),s=!0)},o(i){$e(t.$$.fragment,i),s=!1},d(i){i&&de(e),Tt(t)}}}function qTt(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[1].id),Z(e,"class","card")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[1].id)&&Z(e,"id",t)},d(r){r&&de(e)}}}function XTt(n){let e,t=n[1]+"",r;return{c(){e=we("h2"),r=He(t)},m(s,i){me(s,e,i),se(e,r)},p(s,i){i&1&&t!==(t=s[1]+"")&&cn(r,t)},d(s){s&&de(e)}}}function KTt(n){let e,t,r=n[1],s=[];for(let i=0;i<r.length;i+=1)s[i]=W7(R7(n,r,i));return{c(){e=we("div");for(let i=0;i<s.length;i+=1)s[i].c();t=Ye(),Z(e,"class","flex flex-row flex-wrap items-stretch")},m(i,o){me(i,e,o);for(let a=0;a<s.length;a+=1)s[a]&&s[a].m(e,null);se(e,t)},p(i,o){if(o&1){r=i[1];let a;for(a=0;a<r.length;a+=1){const l=R7(i,r,a);s[a]?s[a].p(l,o):(s[a]=W7(l),s[a].c(),s[a].m(e,t))}for(;a<s.length;a+=1)s[a].d(1);s.length=r.length}},d(i){i&&de(e),qs(s,i)}}}function W7(n){let e,t;return{c(){e=we("div"),Z(e,"id",t=n[4]),Z(e,"class","card flex-none xl:flex-1 w-full xl:w-auto")},m(r,s){me(r,e,s)},p(r,s){s&1&&t!==(t=r[4])&&Z(e,"id",t)},d(r){r&&de(e)}}}function G7(n){let e,t;function r(o,a){return a&1&&(e=null),e==null&&(e=!!Array.isArray(o[1])),e?KTt:typeof o[1]=="string"?XTt:qTt}let s=r(n,-1),i=s(n);return{c(){i.c(),t=mo()},m(o,a){i.m(o,a),me(o,t,a)},p(o,a){s===(s=r(o,a))&&i?i.p(o,a):(i.d(1),i=s(o),i&&(i.c(),i.m(t.parentNode,t)))},d(o){i.d(o),o&&de(t)}}}function YTt(n){let e,t,r=n[0]&&L7(n);return{c(){r&&r.c(),e=mo()},m(s,i){r&&r.m(s,i),me(s,e,i),t=!0},p(s,[i]){s[0]?r?(r.p(s,i),i&1&&Ie(r,1)):(r=L7(s),r.c(),Ie(r,1),r.m(e.parentNode,e)):r&&(dr(),$e(r,1,1,()=>{r=null}),pr())},i(s){t||(Ie(r),t=!0)},o(s){$e(r),t=!1},d(s){r&&r.d(s),s&&de(e)}}}function ZTt(n,e,t){let{settings:r}=e;return _ce(()=>{r.mount()}),n.$$set=s=>{"settings"in s&&t(0,r=s.settings)},[r]}let JTt=class extends xn{constructor(e){super(),wn(this,e,ZTt,YTt,pn,{settings:0})}};function H7(n,e,t){const r=n.slice();return r[8]=e[t][0],r[9]=e[t][1],r[11]=t,r}function j7(n){let e,t=n[9]+"",r,s,i;return{c(){e=we("a"),r=He(t),s=Ye(),Z(e,"href",i=`#${n[8]}`),Z(e,"class","ml-2 mr-5 flex items-center hover:text-black border-solid border-0 border-b-2 border-transparent svelte-1ut593v"),qt(e,"active",!n[4]&&n[2]===n[9])},m(o,a){me(o,e,a),se(e,r),se(e,s)},p(o,a){a&2&&t!==(t=o[9]+"")&&cn(r,t),a&2&&i!==(i=`#${o[8]}`)&&Z(e,"href",i),a&22&&qt(e,"active",!o[4]&&o[2]===o[9])},d(o){o&&de(e)}}}function QTt(n){let e,t,r;return{c(){e=Fs("svg"),t=Fs("circle"),r=Fs("path"),Z(t,"cx","12"),Z(t,"cy","12"),Z(t,"r","3"),Z(r,"d","M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"width","24"),Z(e,"height","24"),Z(e,"viewBox","0 0 24 24"),Z(e,"fill","none"),Z(e,"stroke","currentColor"),Z(e,"stroke-width","2"),Z(e,"stroke-linecap","round"),Z(e,"stroke-linejoin","round"),Z(e,"class","feather feather-settings")},m(s,i){me(s,e,i),se(e,t),se(e,r)},p:tt,d(s){s&&de(e)}}}function q7(n){let e,t,r,s;return e=new zs({props:{round:!0,type:"danger",$$slots:{default:[eEt]},$$scope:{ctx:n}}}),e.$on("click",n[5]),{c(){It(e.$$.fragment),t=Ye(),r=we("span"),Z(r,"class","w-1")},m(i,o){kt(e,i,o),me(i,t,o),me(i,r,o),s=!0},p(i,o){const a={};o&4096&&(a.$$scope={dirty:o,ctx:i}),e.$set(a)},i(i){s||(Ie(e.$$.fragment,i),s=!0)},o(i){$e(e.$$.fragment,i),s=!1},d(i){Tt(e,i),i&&de(t),i&&de(r)}}}function eEt(n){let e,t,r;return{c(){e=Fs("svg"),t=Fs("path"),r=Fs("line"),Z(t,"d","M18.36 6.64a9 9 0 1 1-12.73 0"),Z(r,"x1","12"),Z(r,"y1","2"),Z(r,"x2","12"),Z(r,"y2","12"),Z(e,"xmlns","http://www.w3.org/2000/svg"),Z(e,"width","24"),Z(e,"height","24"),Z(e,"viewBox","0 0 24 24"),Z(e,"fill","none"),Z(e,"stroke","currentColor"),Z(e,"stroke-width","2"),Z(e,"stroke-linecap","round"),Z(e,"stroke-linejoin","round"),Z(e,"class","feather feather-power")},m(s,i){me(s,e,i),se(e,t),se(e,r)},p:tt,d(s){s&&de(e)}}}function tEt(n){let e,t,r,s,i,o,a,l,c,u,h,f,d,p,m=Object.entries(n[1]),g=[];for(let b=0;b<m.length;b+=1)g[b]=j7(H7(n,m,b));u=new zs({props:{round:!0,$$slots:{default:[QTt]},$$scope:{ctx:n}}}),u.$on("click",n[6]);let y=n[3]&&q7(n);return{c(){e=we("header"),t=we("div"),r=we("a"),s=we("span"),i=He(n[0]),o=Ye(),a=we("nav");for(let b=0;b<g.length;b+=1)g[b].c();l=Ye(),c=we("div"),It(u.$$.fragment),h=Ye(),f=we("span"),d=Ye(),y&&y.c(),Z(s,"class","mx-3 text-lg"),Z(r,"href","#/"),Z(r,"class","flex p-3 title-font font-medium items-center text-gray-900 mb-4 md:mb-0 border-solid border-0 border-r border-gray-200 svelte-1ut593v"),Z(a,"class","flex items-stretch justify-start flex-wrap text-base grow mx-4"),Z(f,"class","w-1"),Z(c,"class","flex items-center"),Z(t,"class","mx-auto flex flex-wrap flex-col md:flex-row items-stretch w-full"),Z(e,"class","bg-white text-gray-700 body-font")},m(b,x){me(b,e,x),se(e,t),se(t,r),se(r,s),se(s,i),se(t,o),se(t,a);for(let w=0;w<g.length;w+=1)g[w]&&g[w].m(a,null);se(t,l),se(t,c),kt(u,c,null),se(c,h),se(c,f),se(c,d),y&&y.m(c,null),p=!0},p(b,[x]){if((!p||x&1)&&cn(i,b[0]),x&22){m=Object.entries(b[1]);let S;for(S=0;S<m.length;S+=1){const C=H7(b,m,S);g[S]?g[S].p(C,x):(g[S]=j7(C),g[S].c(),g[S].m(a,null))}for(;S<g.length;S+=1)g[S].d(1);g.length=m.length}const w={};x&4096&&(w.$$scope={dirty:x,ctx:b}),u.$set(w),b[3]?y?(y.p(b,x),x&8&&Ie(y,1)):(y=q7(b),y.c(),Ie(y,1),y.m(c,null)):y&&(dr(),$e(y,1,1,()=>{y=null}),pr())},i(b){p||(Ie(u.$$.fragment,b),Ie(y),p=!0)},o(b){$e(u.$$.fragment,b),$e(y),p=!1},d(b){b&&de(e),qs(g,b),Tt(u),y&&y.d()}}}function nEt(n,e,t){let{title:r}=e,{items:s}=e,{current:i}=e,{closable:o}=e,{showSettings:a=!1}=e;const l=Pc();function c(){a?window.location.href=window.location.href.split("#")[0]+"#"+Object.keys(s)[Object.values(s).indexOf(i)]:window.location.href=window.location.href.split("#")[0]+"#settings"}function u(){setTimeout(()=>{l("quit")},400)}return n.$$set=h=>{"title"in h&&t(0,r=h.title),"items"in h&&t(1,s=h.items),"current"in h&&t(2,i=h.current),"closable"in h&&t(3,o=h.closable),"showSettings"in h&&t(4,a=h.showSettings)},[r,s,i,o,a,u,c]}class rEt extends xn{constructor(e){super(),wn(this,e,nEt,tEt,pn,{title:0,items:1,current:2,closable:3,showSettings:4,quit:5})}get quit(){return this.$$.ctx[5]}}function sEt(n){let e;return{c(){e=He(" ")},m(t,r){me(t,e,r)},p:tt,d(t){t&&de(e)}}}function iEt(n){let e;function t(i,o){return i[1][0]===yc.Warning?lEt:i[1][0]===yc.Error?aEt:oEt}let r=t(n),s=r(n);return{c(){s.c(),e=mo()},m(i,o){s.m(i,o),me(i,e,o)},p(i,o){r===(r=t(i))&&s?s.p(i,o):(s.d(1),s=r(i),s&&(s.c(),s.m(e.parentNode,e)))},d(i){s.d(i),i&&de(e)}}}function oEt(n){let e=(n[1][1]||"")+"",t;return{c(){t=He(e)},m(r,s){me(r,t,s)},p(r,s){s&2&&e!==(e=(r[1][1]||"")+"")&&cn(t,e)},d(r){r&&de(t)}}}function aEt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=He(`Err:
        `),r=He(t)},m(s,i){me(s,e,i),me(s,r,i)},p(s,i){i&2&&t!==(t=(s[1][1]||"")+"")&&cn(r,t)},d(s){s&&de(e),s&&de(r)}}}function lEt(n){let e,t=(n[1][1]||"")+"",r;return{c(){e=He(`Warn:
        `),r=He(t)},m(s,i){me(s,e,i),me(s,r,i)},p(s,i){i&2&&t!==(t=(s[1][1]||"")+"")&&cn(r,t)},d(s){s&&de(e),s&&de(r)}}}function cEt(n){let e,t,r,s,i,o;function a(u,h){return u[1]?iEt:sEt}let l=a(n),c=l(n);return{c(){e=we("footer"),t=we("p"),c.c(),r=Ye(),s=we("p"),i=He("© 2021 "),o=He(n[0]),Z(t,"class","console svelte-i04gf3"),qt(t,"error",n[1]&&n[1][0]===yc.Error),qt(t,"warning",n[1]&&n[1][0]===yc.Warning),Z(s,"class","text-sm text-gray-500 sm:ml-4 sm:pl-4 sm:border-gray-200"),Z(e,"class","bg-white text-gray-600 border-t px-5 py-1 flex items-center justify-between flex-col sm:flex-row")},m(u,h){me(u,e,h),se(e,t),c.m(t,null),se(e,r),se(e,s),se(s,i),se(s,o)},p(u,[h]){l===(l=a(u))&&c?c.p(u,h):(c.d(1),c=l(u),c&&(c.c(),c.m(t,null))),h&2&&qt(t,"error",u[1]&&u[1][0]===yc.Error),h&2&&qt(t,"warning",u[1]&&u[1][0]===yc.Warning),h&1&&cn(o,u[0])},i:tt,o:tt,d(u){u&&de(e),c.d()}}}function uEt(n,e,t){let r,{author:s}=e;const i=E_t();return LV(n,i,o=>t(1,r=o)),n.$$set=o=>{"author"in o&&t(0,s=o.author)},[s,r,i]}class hEt extends xn{constructor(e){super(),wn(this,e,uEt,cEt,pn,{author:0})}}function X7(n){let e,t,r,s,i,o,a,l,c,u,h;r=new rEt({props:{title:n[0],items:n[10].reduce(n[12],{}),current:n[9],showSettings:n[8],closable:n[4]}}),r.$on("quit",n[5]);const f=[dEt,fEt],d=[];function p(m,g){return m[8]?0:m[9]?1:-1}return~(o=p(n))&&(a=d[o]=f[o](n)),c=new hEt({props:{author:n[1]}}),{c(){e=we("div"),t=we("div"),It(r.$$.fragment),s=Ye(),i=we("main"),a&&a.c(),l=Ye(),It(c.$$.fragment),Z(i,"class","main-container svelte-1da5cws"),Z(t,"class","app-container svelte-1da5cws"),Z(e,"class","marcelle fixed h-screen w-full max-w-full overflow-y-scroll overflow-x-hidden top-0 left-0 z-50")},m(m,g){me(m,e,g),se(e,t),kt(r,t,null),se(t,s),se(t,i),~o&&d[o].m(i,null),se(t,l),kt(c,t,null),h=!0},p(m,g){n=m;const y={};g&1&&(y.title=n[0]),g&1088&&(y.items=n[10].reduce(n[12],{})),g&512&&(y.current=n[9]),g&256&&(y.showSettings=n[8]),g&16&&(y.closable=n[4]),r.$set(y);let b=o;o=p(n),o===b?~o&&d[o].p(n,g):(a&&(dr(),$e(d[b],1,1,()=>{d[b]=null}),pr()),~o?(a=d[o],a?a.p(n,g):(a=d[o]=f[o](n),a.c()),Ie(a,1),a.m(i,null)):a=null);const x={};g&2&&(x.author=n[1]),c.$set(x)},i(m){h||(Ie(r.$$.fragment,m),Ie(a),Ie(c.$$.fragment,m),$u(()=>{h&&(u||(u=Cv(t,pM,{amount:10,duration:n[4]?400:0},!0)),u.run(1))}),h=!0)},o(m){$e(r.$$.fragment,m),$e(a),$e(c.$$.fragment,m),u||(u=Cv(t,pM,{amount:10,duration:n[4]?400:0},!1)),u.run(0),h=!1},d(m){m&&de(e),Tt(r),~o&&d[o].d(),Tt(c),m&&u&&u.end()}}}function fEt(n){let e,t;return e=new yTt({props:{dashboard:n[2][n[9]]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&516&&(i.dashboard=r[2][r[9]]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function dEt(n){let e,t;return e=new JTt({props:{settings:n[3]}}),{c(){It(e.$$.fragment)},m(r,s){kt(e,r,s),t=!0},p(r,s){const i={};s&8&&(i.settings=r[3]),e.$set(i)},i(r){t||(Ie(e.$$.fragment,r),t=!0)},o(r){$e(e.$$.fragment,r),t=!1},d(r){Tt(e,r)}}}function pEt(n){let e,t,r,s;document.title=e=n[0];let i=n[7]&&X7(n);return{c(){t=Ye(),i&&i.c(),r=mo()},m(o,a){me(o,t,a),i&&i.m(o,a),me(o,r,a),s=!0},p(o,[a]){(!s||a&1)&&e!==(e=o[0])&&(document.title=e),o[7]?i?(i.p(o,a),a&128&&Ie(i,1)):(i=X7(o),i.c(),Ie(i,1),i.m(r.parentNode,r)):i&&(dr(),$e(i,1,1,()=>{i=null}),pr())},i(o){s||(Ie(i),s=!0)},o(o){$e(i),s=!1},d(o){o&&de(t),i&&i.d(o),o&&de(r)}}}function K7(n){let e=n.replace(/^\s+|\s+$/g,"");e=e.toLowerCase();const t="àáäâèéëêìíïîòóöôùúüûñç·/_,:;",r="aaaaeeeeiiiioooouuuunc------";for(let s=0,i=t.length;s<i;s++)e=e.replace(new RegExp(t.charAt(s),"g"),r.charAt(s));return e=e.replace(/[^a-z0-9 -]/g,"").replace(/\s+/g,"-").replace(/-+/g,"-"),e}function mEt(n,e,t){let r,s;const i=Pc();let{title:o}=e,{author:a}=e,{dashboards:l={}}=e,{settings:c}=e,{page:u}=e,{closable:h}=e,f=!1;Nu(()=>{t(7,f=!0)});function d(){t(7,f=!1),setTimeout(()=>{i("quit")},400)}let p=!1,m=Object.keys(l)[0]||void 0;Nu(()=>{try{const y=new hTt;y.route("settings",()=>{t(8,p=!0),m&&l[m].destroy(),u.set("settings")}),s.forEach((b,x)=>{y.route(b,()=>{t(8,p=!1),m!==r[x]&&(m&&l[m].destroy(),t(9,m=r[x]),u.set(b===""?K7(r[0]):b))})})}catch(y){console.log("Could not enable router",y)}});const g=(y,b,x)=>({...y,[b]:r[x]});return n.$$set=y=>{"title"in y&&t(0,o=y.title),"author"in y&&t(1,a=y.author),"dashboards"in y&&t(2,l=y.dashboards),"settings"in y&&t(3,c=y.settings),"page"in y&&t(11,u=y.page),"closable"in y&&t(4,h=y.closable)},n.$$.update=()=>{n.$$.dirty&4&&t(6,r=Object.keys(l)),n.$$.dirty&64&&t(10,s=[""].concat(r.slice(1).map(K7)))},[o,a,l,c,h,d,r,f,p,m,s,u,g]}let gEt=class extends xn{constructor(e){super(),wn(this,e,mEt,pEt,pn,{title:0,author:1,dashboards:2,settings:3,page:11,closable:4,quit:5})}get quit(){return this.$$.ctx[5]}};function Y7(n){return typeof n=="string"}function Z7(n){return Array.isArray(n)}class yEt{constructor(){this.name="settings",this.components=[],this.xModels=[],this.xDatasets=[],this.xPredictions=[],this.xDataStores=[]}use(...e){return this.components=this.components.concat(e),this}dataStores(...e){return this.xDataStores=e,this}models(...e){return this.xModels=e,this}datasets(...e){return this.xDatasets=e,this}predictions(...e){return this.xPredictions=e,this}mount(){for(const e of this.components)if(Z7(e))for(const t of e)t.mount();else Y7(e)||e.mount()}destroy(){for(const e of this.components)if(Z7(e))for(const t of e)t.destroy();else Y7(e)||e.destroy()}}class bEt{constructor({title:e="Hello, Marcelle!",author:t="author",closable:r=!1}){this.panels={},this.settings=new yEt,this.$active=new mt(!1,!0),this.$page=new mt("",!0),this.title=e,this.author=t,this.closable=r}page(e,t){return Object.keys(this.panels).includes(e)||(this.panels[e]=new aTt(e,t)),this.panels[e]}show(){this.app=new gEt({target:document.body,props:{title:this.title,author:this.author,dashboards:this.panels,settings:this.settings,page:this.$page,closable:this.closable}}),this.$active.set(!0),this.app.$on("quit",()=>{var e;this.$active.set(!1),(e=this.app)===null||e===void 0||e.$destroy();for(const t of Object.values(this.panels))t.destroy();this.app=void 0})}hide(){var e;(e=this.app)===null||e===void 0||e.quit()}}function vEt(n){return new bEt(n)}const mx=HV("localStorage"),gx=vEt({title:"Train your visual classifier",author:"Téo Sanchez"});async function wEt(n,e){const t=await fetch(`${n}`);if(!t.ok)throw new Error(`Failed to fetch local JSON file: ${n}`);const r=await t.json();if(r.marcelleMeta.type==="dataset")for(const s of r.instances)e.create(s);else console.error("The json file is not a Marcelle dataset");return r}async function J7(n,e){try{return await wEt(n,e)}catch(t){console.error(t)}}async function yx(n,e,t){e.clear(),t.clear(),await new Promise(r=>setTimeout(r,800));try{await J7(`/assets/${n}/${n}_train.json`,e)}catch(r){console.error(r)}try{await J7(`/assets/${n}/${n}_test.json`,t)}catch(r){console.error(r)}}async function xEt(n){return new Promise((e,t)=>{const r=new Image;r.onload=()=>{const s=document.createElement("canvas");s.width=r.width,s.height=r.height;const i=s.getContext("2d");i.drawImage(r,0,0);const o=i.getImageData(0,0,s.width,s.height);e(o)},r.onerror=s=>t(s),r.src=n,n.startsWith("data:")?r.src=n:r.src=`data:image/jpeg;base64,${n}`})}const Oc=Lce("trainingSet",mx),j$=aue(Oc);j$.title="Training set";const _Et=jCt(),Dh=Lce("testSet",mx),q$=aue(Dh);q$.title="Test set";const SEt=H$("");SEt.title="Toy datasets";const JV=s0("miniFRUIT");JV.title="Fruit classification";JV.$click.subscribe(()=>{yx("miniFRUIT",Oc,Dh)});const CEt=H$("");CEt.title="Social datasets";const QV=s0("miniMASK");QV.title="Mask classification";QV.$click.subscribe(()=>{yx("miniMASK",Oc,Dh)});const eU=s0("miniROAD");eU.title="Traffic light classification";eU.$click.subscribe(()=>{yx("miniROAD",Oc,Dh)});const tU=s0("miniTRASH");tU.title="Trash classification";tU.$click.subscribe(()=>{yx("miniTRASH",Oc,Dh)});const kEt=H$("");kEt.title="Medical datasets";const nU=s0("miniRETINA");nU.title="Retina disease classification";nU.$click.subscribe(()=>{yx("miniRETINA",Oc,Dh)});const rU=s0("miniSKIN");rU.title="Skin cancer classification";rU.$click.subscribe(()=>{yx("miniSKIN",Oc,Dh)});const sU=j$.$selected.map(n=>({source:"training",id:n.length>0?n[n.length-1]:void 0})).map(({_:n,id:e})=>e).filter(n=>n!==void 0).map(n=>Oc.get(n)).awaitPromises().map(n=>n.thumbnail).merge(q$.$selected.map(n=>({source:"test",id:n.length>0?n[n.length-1]:void 0})).map(({_:n,id:e})=>e).filter(n=>n!==void 0).map(n=>Dh.get(n)).awaitPromises().map(n=>n.thumbnail)).map(n=>xEt(n)).awaitPromises(),mue=lue(sU);mue.title="Image selected";function TEt(n){n.page("Choose your task and dataset").sidebar(mue).use([JV,QV,eU,tU,rU,nU],[j$,q$])}const iU=s0("Train");iU.title="Train the neural network";const pu=zCt({layers:[64,32],epochs:15,batch:8}).sync(mx,"mlp"),gue=akt(pu);gue.title="Neural network parameters";iU.$click.subscribe(()=>{pu.train(Oc)});const yue=b2t(pu);yue.title="Training progress";const bue=pue(pu);bue.title="Learning curve";function EEt(n){n.page("Training").sidebar(iU,yue).use(gue,bue)}const wL=sue("mlp",mx),xL=sue("mlp",mx),vue=oue(wL,Oc);vue.title="Confusion on training set";const wue=oue(xL,Dh);wue.title="Confusion on test set";pu.$training.subscribe(async()=>{pu.ready||Ta(new Error("No classifier has been trained")),await wL.clear(),await xL.clear(),await wL.predict(pu,Oc),await xL.predict(pu,Dh)});function IEt(n){n.page("Testing").use([vue,wue])}const X$=gCt();X$.title="Upload new image to be classified";const AEt=sU.merge(X$.$images).filter(()=>pu.ready).map(async n=>pu.predict(await _Et.process(n))).awaitPromises(),xue=lue(sU.merge(X$.$images));xue.title="Image selected";const _ue=W2t(AEt);_ue.title="Prediction confidence";function MEt(n){n.page("Deployment").sidebar(xue,_ue).use([j$,q$],X$)}TEt(gx);EEt(gx);IEt(gx);MEt(gx);gx.settings.dataStores(mx).datasets(Oc).models(pu);gx.show();
